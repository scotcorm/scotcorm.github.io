<html>
<head>
<title>test_timedelta64.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_timedelta64.py</font>
</center></td></tr></table>
<pre><span class="s0"># Arithmetic tests for DataFrame/Series/Index/Array classes that should</span>
<span class="s0"># behave identically.</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">OutOfBoundsDatetime</span><span class="s2">,</span>
    <span class="s1">PerformanceWarning</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">offsets</span><span class="s2">,</span>
    <span class="s1">timedelta_range</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Float64Index</span><span class="s2">,</span>
    <span class="s1">Int64Index</span><span class="s2">,</span>
    <span class="s1">UInt64Index</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.tests.arithmetic.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_invalid_addsub_type</span><span class="s2">,</span>
    <span class="s1">assert_invalid_comparison</span><span class="s2">,</span>
    <span class="s1">get_upcast_box</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">assert_dtype(obj</span><span class="s2">, </span><span class="s1">expected_dtype):</span>
    <span class="s3">&quot;&quot;&quot; 
    Helper to check the dtype for a Series, Index, or single-column DataFrame. 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = tm.get_dtype(obj)</span>

    <span class="s2">assert </span><span class="s1">dtype == expected_dtype</span>


<span class="s2">def </span><span class="s1">get_expected_name(box</span><span class="s2">, </span><span class="s1">names):</span>
    <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">DataFrame:</span>
        <span class="s0"># Since we are operating with a DataFrame and a non-DataFrame,</span>
        <span class="s0"># the non-DataFrame is cast to Series and its name ignored.</span>
        <span class="s1">exname = names[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">box </span><span class="s2">in </span><span class="s1">[tm.to_array</span><span class="s2">, </span><span class="s1">pd.array]:</span>
        <span class="s1">exname = names[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">exname = names[</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">exname</span>


<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Timedelta64[ns] dtype Comparisons</span>


<span class="s2">class </span><span class="s1">TestTimedelta64ArrayLikeComparisons:</span>
    <span class="s0"># Comparison tests for timedelta64[ns] vectors fully parametrized over</span>
    <span class="s0">#  DataFrame/Series/TimedeltaIndex/TimedeltaArray.  Ideally all comparison</span>
    <span class="s0">#  tests will eventually end up here.</span>

    <span class="s2">def </span><span class="s1">test_compare_timedelta64_zerodim(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#26689 should unbox when comparing with zerodim array</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = (</span>
            <span class="s1">box_with_array </span><span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">not in </span><span class="s1">[pd.Index</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">np.ndarray</span>
        <span class="s1">)</span>

        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;2H&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">other = np.array(tdi.to_numpy()[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">res = tdi &lt;= other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;td_scalar&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_timedelta64()</span><span class="s2">,</span>
            <span class="s1">offsets.Hour(</span><span class="s4">24</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_compare_timedeltalike_scalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">td_scalar):</span>
        <span class="s0"># regression test for GH#5963</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = box </span><span class="s2">if </span><span class="s1">box </span><span class="s2">not in </span><span class="s1">[pd.Index</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">np.ndarray</span>

        <span class="s1">ser = Series([timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">timedelta(days=</span><span class="s4">2</span><span class="s1">)])</span>
        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">actual = ser &gt; td_scalar</span>
        <span class="s1">expected = Series([</span><span class="s2">False, True</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(actual</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;invalid&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4">345600000000000</span><span class="s2">,</span>
            <span class="s5">&quot;a&quot;</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">).now(</span><span class="s5">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">).now().to_datetime64()</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">).now().to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">).date()</span><span class="s2">,</span>
            <span class="s1">np.array(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># zero-dim mismatched dtype</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_td64_comparisons_invalid(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">invalid):</span>
        <span class="s0"># GH#13624 for str</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">obj = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">assert_invalid_comparison(obj</span><span class="s2">, </span><span class="s1">invalid</span><span class="s2">, </span><span class="s1">box)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">list(range(</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">).astype(np.float32)</span><span class="s2">,</span>
            <span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">).astype(object)</span><span class="s2">,</span>
            <span class="s1">pd.date_range(</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=</span><span class="s5">&quot;UTC&quot;</span><span class="s1">).array</span><span class="s2">,</span>
            <span class="s1">np.array(pd.date_range(</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">list(pd.date_range(</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">pd.date_range(</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).astype(object)</span><span class="s2">,</span>
            <span class="s1">pd.period_range(</span><span class="s5">&quot;1971-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).array</span><span class="s2">,</span>
            <span class="s1">pd.period_range(</span><span class="s5">&quot;1971-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).astype(object)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_td64arr_cmp_arraylike_invalid(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># We don't parametrize this over box_with_array because listlike</span>
        <span class="s0">#  other plays poorly with assert_invalid_comparison reversed checks</span>

        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)._data</span>
        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">assert_invalid_comparison(rng</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_cmp_mixed_invalid(self):</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s1">)._data</span>
        <span class="s1">other = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">rng[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">)])</span>

        <span class="s1">result = rng == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False, False, False, True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng != other</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">~expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Invalid comparison between|Cannot compare type|not supported between&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng &lt; other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng &gt; other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng &lt;= other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng &gt;= other</span>


<span class="s2">class </span><span class="s1">TestTimedelta64ArrayComparisons:</span>
    <span class="s0"># TODO: All of these need to be parametrized over box</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">object])</span>
    <span class="s2">def </span><span class="s1">test_comp_nat(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">left = TimedeltaIndex([Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;3 days&quot;</span><span class="s1">)])</span>
        <span class="s1">right = TimedeltaIndex([NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;3 days&quot;</span><span class="s1">)])</span>

        <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs = left</span><span class="s2">, </span><span class="s1">right</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">object:</span>
            <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs = left.astype(object)</span><span class="s2">, </span><span class="s1">right.astype(object)</span>

        <span class="s1">result = rhs == lhs</span>
        <span class="s1">expected = np.array([</span><span class="s2">False, False, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rhs != lhs</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = np.array([</span><span class="s2">False, False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(lhs == NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_numpy_array_equal(NaT == rhs</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = np.array([</span><span class="s2">True, True, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(lhs != NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_numpy_array_equal(NaT != lhs</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = np.array([</span><span class="s2">False, False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(lhs &lt; NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_numpy_array_equal(NaT &gt; lhs</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_comparisons_nat(self):</span>
        <span class="s1">tdidx1 = TimedeltaIndex(</span>
            <span class="s1">[</span>
                <span class="s5">&quot;1 day&quot;</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s5">&quot;1 day 00:00:01&quot;</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s5">&quot;1 day 00:00:01&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;5 day 00:00:03&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tdidx2 = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s5">&quot;2 day&quot;</span><span class="s2">, </span><span class="s5">&quot;2 day&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;1 day 00:00:02&quot;</span><span class="s2">, </span><span class="s5">&quot;5 days 00:00:03&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tdarr = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">np.timedelta64(</span><span class="s4">2</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.timedelta64(</span><span class="s4">2</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.timedelta64(</span><span class="s5">&quot;nat&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.timedelta64(</span><span class="s5">&quot;nat&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">) + np.timedelta64(</span><span class="s4">2</span><span class="s2">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.timedelta64(</span><span class="s4">5</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">) + np.timedelta64(</span><span class="s4">3</span><span class="s2">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s1">cases = [(tdidx1</span><span class="s2">, </span><span class="s1">tdidx2)</span><span class="s2">, </span><span class="s1">(tdidx1</span><span class="s2">, </span><span class="s1">tdarr)]</span>

        <span class="s0"># Check pd.NaT is handles as the same as np.nan</span>
        <span class="s2">for </span><span class="s1">idx1</span><span class="s2">, </span><span class="s1">idx2 </span><span class="s2">in </span><span class="s1">cases:</span>

            <span class="s1">result = idx1 &lt; idx2</span>
            <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, False</span><span class="s1">])</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = idx2 &gt; idx1</span>
            <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, False</span><span class="s1">])</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = idx1 &lt;= idx2</span>
            <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, True</span><span class="s1">])</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = idx2 &gt;= idx1</span>
            <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, True</span><span class="s1">])</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = idx1 == idx2</span>
            <span class="s1">expected = np.array([</span><span class="s2">False, False, False, False, False, True</span><span class="s1">])</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = idx1 != idx2</span>
            <span class="s1">expected = np.array([</span><span class="s2">True, True, True, True, True, False</span><span class="s1">])</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># TODO: better name</span>
    <span class="s2">def </span><span class="s1">test_comparisons_coverage(self):</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">result = rng &lt; rng[</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, True, True</span><span class="s1">] + [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng == list(rng)</span>
        <span class="s1">exp = rng == rng</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>


<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Timedelta64[ns] dtype Arithmetic Operations</span>


<span class="s2">class </span><span class="s1">TestTimedelta64ArithmeticUnsorted:</span>
    <span class="s0"># Tests moved from type-specific test files but not</span>
    <span class="s0">#  yet sorted/parametrized/de-duplicated</span>

    <span class="s2">def </span><span class="s1">test_ufunc_coercions(self):</span>
        <span class="s0"># normal ops are also tested in tseries/test_timedeltas.py</span>
        <span class="s1">idx = TimedeltaIndex([</span><span class="s5">&quot;2H&quot;</span><span class="s2">, </span><span class="s5">&quot;4H&quot;</span><span class="s2">, </span><span class="s5">&quot;6H&quot;</span><span class="s2">, </span><span class="s5">&quot;8H&quot;</span><span class="s2">, </span><span class="s5">&quot;10H&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2H&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[idx * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">np.multiply(idx</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">TimedeltaIndex)</span>
            <span class="s1">exp = TimedeltaIndex([</span><span class="s5">&quot;4H&quot;</span><span class="s2">, </span><span class="s5">&quot;8H&quot;</span><span class="s2">, </span><span class="s5">&quot;12H&quot;</span><span class="s2">, </span><span class="s5">&quot;16H&quot;</span><span class="s2">, </span><span class="s5">&quot;20H&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;4H&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;4H&quot;</span>

        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[idx / </span><span class="s4">2</span><span class="s2">, </span><span class="s1">np.divide(idx</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">TimedeltaIndex)</span>
            <span class="s1">exp = TimedeltaIndex([</span><span class="s5">&quot;1H&quot;</span><span class="s2">, </span><span class="s5">&quot;2H&quot;</span><span class="s2">, </span><span class="s5">&quot;3H&quot;</span><span class="s2">, </span><span class="s5">&quot;4H&quot;</span><span class="s2">, </span><span class="s5">&quot;5H&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;H&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;H&quot;</span>

        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[-idx</span><span class="s2">, </span><span class="s1">np.negative(idx)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">TimedeltaIndex)</span>
            <span class="s1">exp = TimedeltaIndex(</span>
                <span class="s1">[</span><span class="s5">&quot;-2H&quot;</span><span class="s2">, </span><span class="s5">&quot;-4H&quot;</span><span class="s2">, </span><span class="s5">&quot;-6H&quot;</span><span class="s2">, </span><span class="s5">&quot;-8H&quot;</span><span class="s2">, </span><span class="s5">&quot;-10H&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;-2H&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;-2H&quot;</span>

        <span class="s1">idx = TimedeltaIndex([</span><span class="s5">&quot;-2H&quot;</span><span class="s2">, </span><span class="s5">&quot;-1H&quot;</span><span class="s2">, </span><span class="s5">&quot;0H&quot;</span><span class="s2">, </span><span class="s5">&quot;1H&quot;</span><span class="s2">, </span><span class="s5">&quot;2H&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;H&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[abs(idx)</span><span class="s2">, </span><span class="s1">np.absolute(idx)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">TimedeltaIndex)</span>
            <span class="s1">exp = TimedeltaIndex([</span><span class="s5">&quot;2H&quot;</span><span class="s2">, </span><span class="s5">&quot;1H&quot;</span><span class="s2">, </span><span class="s5">&quot;0H&quot;</span><span class="s2">, </span><span class="s5">&quot;1H&quot;</span><span class="s2">, </span><span class="s5">&quot;2H&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq </span><span class="s2">is None</span>

    <span class="s2">def </span><span class="s1">test_subtraction_ops(self):</span>
        <span class="s0"># with datetimes/timedelta and tdi/dti</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">td = Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>
        <span class="s1">dt = Timestamp(</span><span class="s5">&quot;20130101&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s5">&quot;cannot subtract a datelike from a TimedeltaArray&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi - dt</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi - dti</span>

        <span class="s1">msg = </span><span class="s5">r&quot;unsupported operand type\(s\) for -&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td - dt</span>

        <span class="s1">msg = </span><span class="s5">&quot;(bad|unsupported) operand type for unary&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td - dti</span>

        <span class="s1">result = dt - dti</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;-1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;-2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti - dt</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tdi - td</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;1 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = td - tdi</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;-1 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = dti - td</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s5">&quot;20121231&quot;</span><span class="s2">, </span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s5">&quot;20130102&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;bar&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = dt - tdi</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20121231&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;20121230&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_subtraction_ops_with_tz(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>

        <span class="s0"># check that dt/dti subtraction ops with tz are validated</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">dti = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">ts = Timestamp(</span><span class="s5">&quot;20130101&quot;</span><span class="s1">)</span>
        <span class="s1">dt = ts.to_pydatetime()</span>
        <span class="s1">dti_tz = pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">).tz_localize(</span><span class="s5">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">dti_tz = tm.box_expected(dti_tz</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">ts_tz = Timestamp(</span><span class="s5">&quot;20130101&quot;</span><span class="s1">).tz_localize(</span><span class="s5">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">ts_tz2 = Timestamp(</span><span class="s5">&quot;20130101&quot;</span><span class="s1">).tz_localize(</span><span class="s5">&quot;CET&quot;</span><span class="s1">)</span>
        <span class="s1">dt_tz = ts_tz.to_pydatetime()</span>
        <span class="s1">td = Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">_check(result</span><span class="s2">, </span><span class="s1">expected):</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timedelta)</span>

        <span class="s0"># scalars</span>
        <span class="s1">result = ts - ts</span>
        <span class="s1">expected = Timedelta(</span><span class="s5">&quot;0 days&quot;</span><span class="s1">)</span>
        <span class="s1">_check(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dt_tz - ts_tz</span>
        <span class="s1">expected = Timedelta(</span><span class="s5">&quot;0 days&quot;</span><span class="s1">)</span>
        <span class="s1">_check(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ts_tz - dt_tz</span>
        <span class="s1">expected = Timedelta(</span><span class="s5">&quot;0 days&quot;</span><span class="s1">)</span>
        <span class="s1">_check(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># tz mismatches</span>
        <span class="s1">msg = </span><span class="s5">&quot;Cannot subtract tz-naive and tz-aware datetime-like objects.&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dt_tz - ts</span>
        <span class="s1">msg = </span><span class="s5">&quot;can't subtract offset-naive and offset-aware datetimes&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dt_tz - dt</span>
        <span class="s1">msg = </span><span class="s5">&quot;can't subtract offset-naive and offset-aware datetimes&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dt - dt_tz</span>
        <span class="s1">msg = </span><span class="s5">&quot;Cannot subtract tz-naive and tz-aware datetime-like objects.&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts - dt_tz</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts_tz2 - ts</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts_tz2 - dt</span>

        <span class="s1">msg = </span><span class="s5">&quot;Cannot subtract tz-naive and tz-aware&quot;</span>
        <span class="s0"># with dti</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti - ts_tz</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti_tz - ts</span>

        <span class="s1">result = dti_tz - dt_tz</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dt_tz - dti_tz</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;-1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;-2 days&quot;</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti_tz - ts_tz</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ts_tz - dti_tz</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;-1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;-2 days&quot;</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = td - td</span>
        <span class="s1">expected = Timedelta(</span><span class="s5">&quot;0 days&quot;</span><span class="s1">)</span>
        <span class="s1">_check(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti_tz - td</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20121231&quot;</span><span class="s2">, </span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s5">&quot;20130102&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s5">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dti_tdi_numeric_ops(self):</span>
        <span class="s0"># These are normally union/diff set-like ops</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>

        <span class="s1">result = tdi - tdi</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;0 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tdi + tdi</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;2 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;4 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti - tdi  </span><span class="s0"># name will be reset</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20121231&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;20130101&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_addition_ops(self):</span>
        <span class="s0"># with datetimes/timedelta and tdi/dti</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">td = Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>
        <span class="s1">dt = Timestamp(</span><span class="s5">&quot;20130101&quot;</span><span class="s1">)</span>

        <span class="s1">result = tdi + dt</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20130102&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;20130103&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dt + tdi</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20130102&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;20130103&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = td + tdi</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;2 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;3 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tdi + td</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;2 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;3 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># unequal length</span>
        <span class="s1">msg = </span><span class="s5">&quot;cannot add indices of unequal length&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi + dti[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">1</span><span class="s1">] + dti</span>

        <span class="s0"># random indexes</span>
        <span class="s1">msg = </span><span class="s5">&quot;Addition/subtraction of integers and integer-arrays&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi + Int64Index([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

        <span class="s0"># this is a union!</span>
        <span class="s0"># pytest.raises(TypeError, lambda : Int64Index([1,2,3]) + tdi)</span>

        <span class="s1">result = tdi + dti  </span><span class="s0"># name will be reset</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20130102&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;20130105&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti + tdi  </span><span class="s0"># name will be reset</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;20130102&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;20130105&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dt + td</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">&quot;20130102&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = td + dt</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">&quot;20130102&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s0"># TODO: Needs more informative name, probably split up into</span>
    <span class="s0"># more targeted tests</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_timedelta(self</span><span class="s2">, </span><span class="s1">freq):</span>
        <span class="s1">index = pd.date_range(</span><span class="s5">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">freq=freq)</span>

        <span class="s1">shifted = index + timedelta(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">back = shifted + timedelta(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">back = back._with_freq(</span><span class="s5">&quot;infer&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(index</span><span class="s2">, </span><span class="s1">back)</span>

        <span class="s2">if </span><span class="s1">freq == </span><span class="s5">&quot;D&quot;</span><span class="s1">:</span>
            <span class="s1">expected = pd.tseries.offsets.Day(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">index.freq == expected</span>
            <span class="s2">assert </span><span class="s1">shifted.freq == expected</span>
            <span class="s2">assert </span><span class="s1">back.freq == expected</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s0"># freq == 'B'</span>
            <span class="s2">assert </span><span class="s1">index.freq == pd.tseries.offsets.BusinessDay(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">shifted.freq </span><span class="s2">is None</span>
            <span class="s2">assert </span><span class="s1">back.freq == pd.tseries.offsets.BusinessDay(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">result = index - timedelta(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected = index + timedelta(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># GH#4134, buggy with timedeltas</span>
        <span class="s1">rng = pd.date_range(</span><span class="s5">&quot;2013&quot;</span><span class="s2">, </span><span class="s5">&quot;2014&quot;</span><span class="s1">)</span>
        <span class="s1">s = Series(rng)</span>
        <span class="s1">result1 = rng - offsets.Hour(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result2 = DatetimeIndex(s - np.timedelta64(</span><span class="s4">100000000</span><span class="s1">))</span>
        <span class="s1">result3 = rng - np.timedelta64(</span><span class="s4">100000000</span><span class="s1">)</span>
        <span class="s1">result4 = DatetimeIndex(s - offsets.Hour(</span><span class="s4">1</span><span class="s1">))</span>

        <span class="s2">assert </span><span class="s1">result1.freq == rng.freq</span>
        <span class="s1">result1 = result1._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result1</span><span class="s2">, </span><span class="s1">result4)</span>

        <span class="s2">assert </span><span class="s1">result3.freq == rng.freq</span>
        <span class="s1">result3 = result3._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result2</span><span class="s2">, </span><span class="s1">result3)</span>

    <span class="s2">def </span><span class="s1">test_tda_add_sub_index(self):</span>
        <span class="s0"># Check that TimedeltaArray defers to Index on arithmetic ops</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">])</span>
        <span class="s1">tda = tdi.array</span>

        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;1999-12-31&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s1">result = tda + dti</span>
        <span class="s1">expected = tdi + dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tda + tdi</span>
        <span class="s1">expected = tdi + tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tda - tdi</span>
        <span class="s1">expected = tdi - tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_tda_add_dt64_object_array(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># Result should be cast back to DatetimeArray</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>
        <span class="s1">dti = dti._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">tdi = dti - dti</span>

        <span class="s1">obj = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">other = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">result = obj + other.astype(object)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Binary operations TimedeltaIndex and timedelta-like</span>

    <span class="s2">def </span><span class="s1">test_tdi_iadd_timedeltalike(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># only test adding/sub offsets as + is now numeric</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s1">)</span>
        <span class="s1">expected = timedelta_range(</span><span class="s5">&quot;1 days 02:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days 02:00:00&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">orig_rng = rng</span>
        <span class="s1">rng += two_hours</span>
        <span class="s1">tm.assert_equal(rng</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is not </span><span class="s1">pd.Index:</span>
            <span class="s0"># Check that operation is actually inplace</span>
            <span class="s1">tm.assert_equal(orig_rng</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_tdi_isub_timedeltalike(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># only test adding/sub offsets as - is now numeric</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s1">)</span>
        <span class="s1">expected = timedelta_range(</span><span class="s5">&quot;0 days 22:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;9 days 22:00:00&quot;</span><span class="s1">)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">orig_rng = rng</span>
        <span class="s1">rng -= two_hours</span>
        <span class="s1">tm.assert_equal(rng</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is not </span><span class="s1">pd.Index:</span>
            <span class="s0"># Check that operation is actually inplace</span>
            <span class="s1">tm.assert_equal(orig_rng</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># -------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">test_tdi_ops_attributes(self):</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;2 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s1">result = rng + </span><span class="s4">1 </span><span class="s1">* rng.freq</span>
        <span class="s1">exp = timedelta_range(</span><span class="s5">&quot;4 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;2D&quot;</span>

        <span class="s1">result = rng - </span><span class="s4">2 </span><span class="s1">* rng.freq</span>
        <span class="s1">exp = timedelta_range(</span><span class="s5">&quot;-2 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;2D&quot;</span>

        <span class="s1">result = rng * </span><span class="s4">2</span>
        <span class="s1">exp = timedelta_range(</span><span class="s5">&quot;4 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;4D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;4D&quot;</span>

        <span class="s1">result = rng / </span><span class="s4">2</span>
        <span class="s1">exp = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;D&quot;</span>

        <span class="s1">result = -rng</span>
        <span class="s1">exp = timedelta_range(</span><span class="s5">&quot;-2 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;-2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s5">&quot;-2D&quot;</span>

        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;-2 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s1">result = abs(rng)</span>
        <span class="s1">exp = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s5">&quot;2 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">assert </span><span class="s1">result.freq </span><span class="s2">is None</span>


<span class="s2">class </span><span class="s1">TestAddSubNaTMasking:</span>
    <span class="s0"># TODO: parametrize over boxes</span>

    <span class="s2">def </span><span class="s1">test_tdarr_add_timestamp_nat_masking(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#17991 checking for overflow-masking with NaT</span>
        <span class="s1">tdinat = pd.to_timedelta([</span><span class="s5">&quot;24658 days 11:15:00&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">])</span>
        <span class="s1">tdobj = tm.box_expected(tdinat</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">tsneg = Timestamp(</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">ts_neg_variants = [</span>
            <span class="s1">tsneg</span><span class="s2">,</span>
            <span class="s1">tsneg.to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">tsneg.to_datetime64().astype(</span><span class="s5">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">tsneg.to_datetime64().astype(</span><span class="s5">&quot;datetime64[D]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">tspos = Timestamp(</span><span class="s5">&quot;1980-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">ts_pos_variants = [</span>
            <span class="s1">tspos</span><span class="s2">,</span>
            <span class="s1">tspos.to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">tspos.to_datetime64().astype(</span><span class="s5">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">tspos.to_datetime64().astype(</span><span class="s5">&quot;datetime64[D]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s2">for </span><span class="s1">variant </span><span class="s2">in </span><span class="s1">ts_neg_variants + ts_pos_variants:</span>
            <span class="s1">res = tdobj + variant</span>
            <span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">DataFrame:</span>
                <span class="s2">assert </span><span class="s1">res.iloc[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] </span><span class="s2">is </span><span class="s1">NaT</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">res[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">test_tdi_add_overflow(self):</span>
        <span class="s0"># See GH#14068</span>
        <span class="s0"># preliminary test scalar analogue of vectorized tests below</span>
        <span class="s0"># TODO: Make raised error message more informative and test</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;10155196800000000000&quot;</span><span class="s1">):</span>
            <span class="s1">pd.to_timedelta(</span><span class="s4">106580</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">) + Timestamp(</span><span class="s5">&quot;2000&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;10155196800000000000&quot;</span><span class="s1">):</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2000&quot;</span><span class="s1">) + pd.to_timedelta(</span><span class="s4">106580</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s1">_NaT = NaT.value + </span><span class="s4">1</span>
        <span class="s1">msg = </span><span class="s5">&quot;Overflow in int64 addition&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.to_timedelta([</span><span class="s4">106580</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">) + Timestamp(</span><span class="s5">&quot;2000&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">Timestamp(</span><span class="s5">&quot;2000&quot;</span><span class="s1">) + pd.to_timedelta([</span><span class="s4">106580</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.to_timedelta([_NaT]) - Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.to_timedelta([</span><span class="s5">&quot;5 days&quot;</span><span class="s2">, </span><span class="s1">_NaT]) - Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">(</span>
                <span class="s1">pd.to_timedelta([_NaT</span><span class="s2">, </span><span class="s5">&quot;5 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 hours&quot;</span><span class="s1">])</span>
                <span class="s1">- pd.to_timedelta([</span><span class="s5">&quot;7 seconds&quot;</span><span class="s2">, </span><span class="s1">_NaT</span><span class="s2">, </span><span class="s5">&quot;4 hours&quot;</span><span class="s1">])</span>
            <span class="s1">)</span>

        <span class="s0"># These should not overflow!</span>
        <span class="s1">exp = TimedeltaIndex([NaT])</span>
        <span class="s1">result = pd.to_timedelta([NaT]) - Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">exp = TimedeltaIndex([</span><span class="s5">&quot;4 days&quot;</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">result = pd.to_timedelta([</span><span class="s5">&quot;5 days&quot;</span><span class="s2">, </span><span class="s1">NaT]) - Timedelta(</span><span class="s5">&quot;1 days&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">exp = TimedeltaIndex([NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;5 hours&quot;</span><span class="s1">])</span>
        <span class="s1">result = pd.to_timedelta([NaT</span><span class="s2">, </span><span class="s5">&quot;5 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 hours&quot;</span><span class="s1">]) + pd.to_timedelta(</span>
            <span class="s1">[</span><span class="s5">&quot;7 seconds&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;4 hours&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>


<span class="s2">class </span><span class="s1">TestTimedeltaArraylikeAddSubOps:</span>
    <span class="s0"># Tests for timedelta64[ns] __add__, __sub__, __radd__, __rsub__</span>

    <span class="s0"># TODO: moved from tests.indexes.timedeltas.test_arithmetic; needs</span>
    <span class="s0">#  parametrization+de-duplication</span>
    <span class="s2">def </span><span class="s1">test_timedelta_ops_with_missing_values(self):</span>
        <span class="s0"># setup</span>
        <span class="s1">s1 = pd.to_timedelta(Series([</span><span class="s5">&quot;00:00:01&quot;</span><span class="s1">]))</span>
        <span class="s1">s2 = pd.to_timedelta(Series([</span><span class="s5">&quot;00:00:02&quot;</span><span class="s1">]))</span>

        <span class="s1">msg = </span><span class="s5">r&quot;dtype datetime64\[ns\] cannot be converted to timedelta64\[ns\]&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s0"># Passing datetime64-dtype data to TimedeltaIndex is no longer</span>
            <span class="s0">#  supported GH#29794</span>
            <span class="s1">pd.to_timedelta(Series([NaT]))  </span><span class="s0"># TODO: belongs elsewhere?</span>

        <span class="s1">sn = pd.to_timedelta(Series([NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">))</span>

        <span class="s1">df1 = DataFrame([</span><span class="s5">&quot;00:00:01&quot;</span><span class="s1">]).apply(pd.to_timedelta)</span>
        <span class="s1">df2 = DataFrame([</span><span class="s5">&quot;00:00:02&quot;</span><span class="s1">]).apply(pd.to_timedelta)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s0"># Passing datetime64-dtype data to TimedeltaIndex is no longer</span>
            <span class="s0">#  supported GH#29794</span>
            <span class="s1">DataFrame([NaT]).apply(pd.to_timedelta)  </span><span class="s0"># TODO: belongs elsewhere?</span>

        <span class="s1">dfn = DataFrame([NaT.value]).apply(pd.to_timedelta)</span>

        <span class="s1">scalar1 = pd.to_timedelta(</span><span class="s5">&quot;00:00:01&quot;</span><span class="s1">)</span>
        <span class="s1">scalar2 = pd.to_timedelta(</span><span class="s5">&quot;00:00:02&quot;</span><span class="s1">)</span>
        <span class="s1">timedelta_NaT = pd.to_timedelta(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span>

        <span class="s1">actual = scalar1 + scalar1</span>
        <span class="s2">assert </span><span class="s1">actual == scalar2</span>
        <span class="s1">actual = scalar2 - scalar1</span>
        <span class="s2">assert </span><span class="s1">actual == scalar1</span>

        <span class="s1">actual = s1 + s1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">s2)</span>
        <span class="s1">actual = s2 - s1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">s1)</span>

        <span class="s1">actual = s1 + scalar1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">s2)</span>
        <span class="s1">actual = scalar1 + s1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">s2)</span>
        <span class="s1">actual = s2 - scalar1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">s1)</span>
        <span class="s1">actual = -scalar1 + s2</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">s1)</span>

        <span class="s1">actual = s1 + timedelta_NaT</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">sn)</span>
        <span class="s1">actual = timedelta_NaT + s1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">sn)</span>
        <span class="s1">actual = s1 - timedelta_NaT</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">sn)</span>
        <span class="s1">actual = -timedelta_NaT + s1</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">sn)</span>

        <span class="s1">msg = </span><span class="s5">&quot;unsupported operand type&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">s1 + np.nan</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">np.nan + s1</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">s1 - np.nan</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">-np.nan + s1</span>

        <span class="s1">actual = s1 + NaT</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">sn)</span>
        <span class="s1">actual = s2 - NaT</span>
        <span class="s1">tm.assert_series_equal(actual</span><span class="s2">, </span><span class="s1">sn)</span>

        <span class="s1">actual = s1 + df1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df2)</span>
        <span class="s1">actual = s2 - df1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df1)</span>
        <span class="s1">actual = df1 + s1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df2)</span>
        <span class="s1">actual = df2 - s1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df1)</span>

        <span class="s1">actual = df1 + df1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df2)</span>
        <span class="s1">actual = df2 - df1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df1)</span>

        <span class="s1">actual = df1 + scalar1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df2)</span>
        <span class="s1">actual = df2 - scalar1</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">df1)</span>

        <span class="s1">actual = df1 + timedelta_NaT</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">dfn)</span>
        <span class="s1">actual = df1 - timedelta_NaT</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">dfn)</span>

        <span class="s1">msg = </span><span class="s5">&quot;cannot subtract a datelike from|unsupported operand type&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df1 + np.nan</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df1 - np.nan</span>

        <span class="s1">actual = df1 + NaT  </span><span class="s0"># NaT is datetime, not timedelta</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">dfn)</span>
        <span class="s1">actual = df1 - NaT</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s2">, </span><span class="s1">dfn)</span>

    <span class="s0"># TODO: moved from tests.series.test_operators, needs splitting, cleanup,</span>
    <span class="s0"># de-duplication, box-parametrization...</span>
    <span class="s2">def </span><span class="s1">test_operators_timedelta64(self):</span>
        <span class="s0"># series ops</span>
        <span class="s1">v1 = pd.date_range(</span><span class="s5">&quot;2012-1-1&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">v2 = pd.date_range(</span><span class="s5">&quot;2012-1-2&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">rs = Series(v2) - Series(v1)</span>
        <span class="s1">xp = Series(</span><span class="s4">1e9 </span><span class="s1">* </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">24</span><span class="s2">, </span><span class="s1">rs.index).astype(</span><span class="s5">&quot;int64&quot;</span><span class="s1">).astype(</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(rs</span><span class="s2">, </span><span class="s1">xp)</span>
        <span class="s2">assert </span><span class="s1">rs.dtype == </span><span class="s5">&quot;timedelta64[ns]&quot;</span>

        <span class="s1">df = DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: v1})</span>
        <span class="s1">td = Series([timedelta(days=i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)])</span>
        <span class="s2">assert </span><span class="s1">td.dtype == </span><span class="s5">&quot;timedelta64[ns]&quot;</span>

        <span class="s0"># series on the rhs</span>
        <span class="s1">result = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] - df[</span><span class="s5">&quot;A&quot;</span><span class="s1">].shift()</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;timedelta64[ns]&quot;</span>

        <span class="s1">result = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] + td</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;M8[ns]&quot;</span>

        <span class="s0"># scalar Timestamp on rhs</span>
        <span class="s1">maxa = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">].max()</span>
        <span class="s2">assert </span><span class="s1">isinstance(maxa</span><span class="s2">, </span><span class="s1">Timestamp)</span>

        <span class="s1">resultb = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] - df[</span><span class="s5">&quot;A&quot;</span><span class="s1">].max()</span>
        <span class="s2">assert </span><span class="s1">resultb.dtype == </span><span class="s5">&quot;timedelta64[ns]&quot;</span>

        <span class="s0"># timestamp on lhs</span>
        <span class="s1">result = resultb + df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span>
        <span class="s1">values = [Timestamp(</span><span class="s5">&quot;20111230&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">&quot;20120101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">&quot;20120103&quot;</span><span class="s1">)]</span>
        <span class="s1">expected = Series(values</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># datetimes on rhs</span>
        <span class="s1">result = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] - datetime(</span><span class="s4">2001</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected = Series([timedelta(days=</span><span class="s4">4017 </span><span class="s1">+ i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;m8[ns]&quot;</span>

        <span class="s1">d = datetime(</span><span class="s4">2001</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">resulta = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] - d</span>
        <span class="s2">assert </span><span class="s1">resulta.dtype == </span><span class="s5">&quot;m8[ns]&quot;</span>

        <span class="s0"># roundtrip</span>
        <span class="s1">resultb = resulta + d</span>
        <span class="s1">tm.assert_series_equal(df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">resultb)</span>

        <span class="s0"># timedeltas on rhs</span>
        <span class="s1">td = timedelta(days=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">resulta = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] + td</span>
        <span class="s1">resultb = resulta - td</span>
        <span class="s1">tm.assert_series_equal(resultb</span><span class="s2">, </span><span class="s1">df[</span><span class="s5">&quot;A&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">resultb.dtype == </span><span class="s5">&quot;M8[ns]&quot;</span>

        <span class="s0"># roundtrip</span>
        <span class="s1">td = timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">resulta = df[</span><span class="s5">&quot;A&quot;</span><span class="s1">] + td</span>
        <span class="s1">resultb = resulta - td</span>
        <span class="s1">tm.assert_series_equal(df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">resultb)</span>
        <span class="s2">assert </span><span class="s1">resultb.dtype == </span><span class="s5">&quot;M8[ns]&quot;</span>

        <span class="s0"># inplace</span>
        <span class="s1">value = rs[</span><span class="s4">2</span><span class="s1">] + np.timedelta64(timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">rs[</span><span class="s4">2</span><span class="s1">] += np.timedelta64(timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">rs[</span><span class="s4">2</span><span class="s1">] == value</span>

    <span class="s2">def </span><span class="s1">test_timedelta64_ops_nat(self):</span>
        <span class="s0"># GH 11349</span>
        <span class="s1">timedelta_series = Series([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;1s&quot;</span><span class="s1">)])</span>
        <span class="s1">nat_series_dtype_timedelta = Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">single_nat_dtype_timedelta = Series([NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s0"># subtraction</span>
        <span class="s1">tm.assert_series_equal(timedelta_series - NaT</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>
        <span class="s1">tm.assert_series_equal(-NaT + timedelta_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">timedelta_series - single_nat_dtype_timedelta</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">-single_nat_dtype_timedelta + timedelta_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>

        <span class="s0"># addition</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timedelta + NaT</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">NaT + nat_series_dtype_timedelta</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timedelta + single_nat_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timedelta</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">single_nat_dtype_timedelta + nat_series_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timedelta</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(timedelta_series + NaT</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>
        <span class="s1">tm.assert_series_equal(NaT + timedelta_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">timedelta_series + single_nat_dtype_timedelta</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">single_nat_dtype_timedelta + timedelta_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timedelta + NaT</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">NaT + nat_series_dtype_timedelta</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timedelta + single_nat_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timedelta</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">single_nat_dtype_timedelta + nat_series_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timedelta</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s0"># multiplication</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timedelta * </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s4">1.0 </span><span class="s1">* nat_series_dtype_timedelta</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(timedelta_series * </span><span class="s4">1</span><span class="s2">, </span><span class="s1">timedelta_series)</span>
        <span class="s1">tm.assert_series_equal(</span><span class="s4">1 </span><span class="s1">* timedelta_series</span><span class="s2">, </span><span class="s1">timedelta_series)</span>

        <span class="s1">tm.assert_series_equal(timedelta_series * </span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">Series([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;1.5s&quot;</span><span class="s1">)]))</span>
        <span class="s1">tm.assert_series_equal(</span><span class="s4">1.5 </span><span class="s1">* timedelta_series</span><span class="s2">, </span><span class="s1">Series([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;1.5s&quot;</span><span class="s1">)]))</span>

        <span class="s1">tm.assert_series_equal(timedelta_series * np.nan</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>
        <span class="s1">tm.assert_series_equal(np.nan * timedelta_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>

        <span class="s0"># division</span>
        <span class="s1">tm.assert_series_equal(timedelta_series / </span><span class="s4">2</span><span class="s2">, </span><span class="s1">Series([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;0.5s&quot;</span><span class="s1">)]))</span>
        <span class="s1">tm.assert_series_equal(timedelta_series / </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">Series([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;0.5s&quot;</span><span class="s1">)]))</span>
        <span class="s1">tm.assert_series_equal(timedelta_series / np.nan</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta)</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Binary operations td64 arraylike and datetime-like</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;cls&quot;</span><span class="s2">, </span><span class="s1">[Timestamp</span><span class="s2">, </span><span class="s1">datetime</span><span class="s2">, </span><span class="s1">np.datetime64])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_datetimelike_scalar(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span>
    <span class="s1">):</span>
        <span class="s0"># GH#11925, GH#29558, GH#23215</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">dt_scalar = Timestamp(</span><span class="s5">&quot;2012-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">if </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">datetime:</span>
            <span class="s1">ts = dt_scalar.to_pydatetime()</span>
        <span class="s2">elif </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">np.datetime64:</span>
            <span class="s2">if </span><span class="s1">tz_naive_fixture </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return</span>
            <span class="s1">ts = dt_scalar.to_datetime64()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ts = dt_scalar</span>

        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;1 day&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">expected = pd.date_range(</span><span class="s5">&quot;2012-01-02&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">tdarr = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">tm.assert_equal(ts + tdarr</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(tdarr + ts</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected2 = pd.date_range(</span><span class="s5">&quot;2011-12-31&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;-1D&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected2 = tm.box_expected(expected2</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">tm.assert_equal(ts - tdarr</span><span class="s2">, </span><span class="s1">expected2)</span>
        <span class="s1">tm.assert_equal(ts + (-tdarr)</span><span class="s2">, </span><span class="s1">expected2)</span>

        <span class="s1">msg = </span><span class="s5">&quot;cannot subtract a datelike&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdarr - ts</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_datetime64_nat(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#23215</span>
        <span class="s1">other = np.datetime64(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span>

        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;1 day&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">])</span>

        <span class="s1">tdser = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">tm.assert_equal(tdser + other</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(other + tdser</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_sub_dt64_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;-1 Day&quot;</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">dtarr = dti.values</span>
        <span class="s1">expected = DatetimeIndex(dtarr) - tdi</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">msg = </span><span class="s5">&quot;cannot subtract a datelike from&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi - dtarr</span>

        <span class="s0"># TimedeltaIndex.__rsub__</span>
        <span class="s1">result = dtarr - tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_dt64_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;-1 Day&quot;</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">dtarr = dti.values</span>
        <span class="s1">expected = DatetimeIndex(dtarr) + tdi</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdi + dtarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = dtarr + tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Invalid __add__/__sub__ operations</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;pi_freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s5">&quot;W&quot;</span><span class="s2">, </span><span class="s5">&quot;Q&quot;</span><span class="s2">, </span><span class="s5">&quot;H&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;tdi_freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s5">&quot;H&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_sub_periodlike(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">box_with_array2</span><span class="s2">, </span><span class="s1">tdi_freq</span><span class="s2">, </span><span class="s1">pi_freq</span>
    <span class="s1">):</span>
        <span class="s0"># GH#20049 subtracting PeriodIndex should raise TypeError</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 hours&quot;</span><span class="s2">, </span><span class="s5">&quot;2 hours&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=tdi_freq)</span>
        <span class="s1">dti = Timestamp(</span><span class="s5">&quot;2018-03-07 17:16:40&quot;</span><span class="s1">) + tdi</span>
        <span class="s1">pi = dti.to_period(pi_freq)</span>
        <span class="s1">per = pi[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">pi = tm.box_expected(pi</span><span class="s2">, </span><span class="s1">box_with_array2)</span>
        <span class="s1">msg = </span><span class="s5">&quot;cannot subtract|unsupported operand type&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi - pi</span>

        <span class="s0"># GH#13078 subtraction of Period scalar not supported</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi - per</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s0"># GH#12624 for str case</span>
            <span class="s5">&quot;a&quot;</span><span class="s2">,</span>
            <span class="s0"># GH#19123</span>
            <span class="s4">1</span><span class="s2">,</span>
            <span class="s4">1.5</span><span class="s2">,</span>
            <span class="s1">np.array(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_td64arr_addsub_numeric_scalar_invalid(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># vector-like others are tested in test_td64arr_add_sub_numeric_arr_invalid</span>
        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">assert_invalid_addsub_type(tdarr</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;vec&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">pd.Index([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">DataFrame([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_td64arr_addsub_numeric_arr_invalid(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">vec</span><span class="s2">, </span><span class="s1">any_real_numpy_dtype</span>
    <span class="s1">):</span>
        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">vector = vec.astype(any_real_numpy_dtype)</span>
        <span class="s1">assert_invalid_addsub_type(tdarr</span><span class="s2">, </span><span class="s1">vector)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_int(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">one):</span>
        <span class="s0"># Variants of `one` for #19012, deprecated GH#22535</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days 09:00:00&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;H&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Addition/subtraction of integers&quot;</span>
        <span class="s1">assert_invalid_addsub_type(tdarr</span><span class="s2">, </span><span class="s1">one</span><span class="s2">, </span><span class="s1">msg)</span>

        <span class="s0"># TODO: get inplace ops into assert_invalid_addsub_type</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdarr += one</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdarr -= one</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_integer_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#19959, deprecated GH#22535</span>
        <span class="s0"># GH#22696 for DataFrame case, check that we don't dispatch to numpy</span>
        <span class="s0">#  implementation, which treats int64 as m8[ns]</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days 09:00:00&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;H&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">other = tm.box_expected([</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Addition/subtraction of integers and integer-arrays&quot;</span>
        <span class="s1">assert_invalid_addsub_type(tdarr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_addsub_integer_array_no_freq(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#19959</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;3 Hours&quot;</span><span class="s1">])</span>
        <span class="s1">tdarr = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">other = tm.box_expected([</span><span class="s4">14</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">16</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Addition/subtraction of integers&quot;</span>
        <span class="s1">assert_invalid_addsub_type(tdarr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Operations with timedelta-like others</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_td64_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">dti = pd.date_range(</span><span class="s5">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">tdi = dti - dti.shift(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tdarr = tdi.values</span>

        <span class="s1">expected = </span><span class="s4">2 </span><span class="s1">* tdi</span>
        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = tdi + tdarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = tdarr + tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected_sub = </span><span class="s4">0 </span><span class="s1">* tdi</span>
        <span class="s1">result = tdi - tdarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected_sub)</span>
        <span class="s1">result = tdarr - tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected_sub)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_tdi(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0"># GH#17250 make sure result dtype is correct</span>
        <span class="s0"># GH#19043 make sure names are propagated correctly</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">exname = get_expected_name(box</span><span class="s2">, </span><span class="s1">names)</span>

        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;0 days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 day&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">tdi = np.array(tdi) </span><span class="s2">if </span><span class="s1">box </span><span class="s2">in </span><span class="s1">[tm.to_array</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">tdi</span>
        <span class="s1">ser = Series([Timedelta(hours=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(hours=</span><span class="s4">4</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">expected = Series([Timedelta(hours=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hours=</span><span class="s4">4</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=exname)</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = tdi + ser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_dtype(result</span><span class="s2">, </span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">result = ser + tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_dtype(result</span><span class="s2">, </span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[Timedelta(hours=-</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hours=-</span><span class="s4">4</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=exname</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = tdi - ser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_dtype(result</span><span class="s2">, </span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">result = ser - tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">-expected)</span>
        <span class="s1">assert_dtype(result</span><span class="s2">, </span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;tdnat&quot;</span><span class="s2">, </span><span class="s1">[np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_td64_nat(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">tdnat):</span>
        <span class="s0"># GH#18808, GH#23320 special handling for timedelta64(&quot;NaT&quot;)</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">tdi = TimedeltaIndex([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s5">&quot;1s&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;NaT&quot;</span><span class="s1">] * </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">obj = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = obj + tdnat</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = tdnat + obj</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = obj - tdnat</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = tdnat - obj</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_timedeltalike(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># only test adding/sub offsets as + is now numeric</span>
        <span class="s0"># GH#10699 for Tick cases</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s1">)</span>
        <span class="s1">expected = timedelta_range(</span><span class="s5">&quot;1 days 02:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days 02:00:00&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = rng + two_hours</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = two_hours + rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_sub_timedeltalike(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># only test adding/sub offsets as - is now numeric</span>
        <span class="s0"># GH#10699 for Tick cases</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s1">)</span>
        <span class="s1">expected = timedelta_range(</span><span class="s5">&quot;0 days 22:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;9 days 22:00:00&quot;</span><span class="s1">)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = rng - two_hours</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = two_hours - rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">-expected)</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># __add__/__sub__ with DateOffsets and arrays of DateOffsets</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_offset_index(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18849, GH#19744</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">exname = get_expected_name(box</span><span class="s2">, </span><span class="s1">names)</span>

        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days 00:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;3 days 04:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">other = pd.Index([offsets.Hour(n=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">offsets.Minute(n=-</span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">other = np.array(other) </span><span class="s2">if </span><span class="s1">box </span><span class="s2">in </span><span class="s1">[tm.to_array</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">other</span>

        <span class="s1">expected = TimedeltaIndex(</span>
            <span class="s1">[tdi[n] + other[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdi))]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">name=exname</span>
        <span class="s1">)</span>
        <span class="s1">expected_sub = TimedeltaIndex(</span>
            <span class="s1">[tdi[n] - other[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdi))]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">name=exname</span>
        <span class="s1">)</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected_sub = tm.box_expected(expected_sub</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res = tdi + other</span>
        <span class="s1">tm.assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res2 = other + tdi</span>
        <span class="s1">tm.assert_equal(res2</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res_sub = tdi - other</span>
        <span class="s1">tm.assert_equal(res_sub</span><span class="s2">, </span><span class="s1">expected_sub)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_offset_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18849, GH#18824</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days 00:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;3 days 04:00:00&quot;</span><span class="s1">])</span>
        <span class="s1">other = np.array([offsets.Hour(n=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">offsets.Minute(n=-</span><span class="s4">2</span><span class="s1">)])</span>

        <span class="s1">expected = TimedeltaIndex(</span>
            <span class="s1">[tdi[n] + other[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdi))]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;infer&quot;</span>
        <span class="s1">)</span>
        <span class="s1">expected_sub = TimedeltaIndex(</span>
            <span class="s1">[tdi[n] - other[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdi))]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;infer&quot;</span>
        <span class="s1">)</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res = tdi + other</span>
        <span class="s1">tm.assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res2 = other + tdi</span>
        <span class="s1">tm.assert_equal(res2</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected_sub = tm.box_expected(expected_sub</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res_sub = tdi - other</span>
        <span class="s1">tm.assert_equal(res_sub</span><span class="s2">, </span><span class="s1">expected_sub)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_with_offset_series(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18849</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">box2 = Series </span><span class="s2">if </span><span class="s1">box </span><span class="s2">in </span><span class="s1">[pd.Index</span><span class="s2">, </span><span class="s1">tm.to_array</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">box</span>
        <span class="s1">exname = get_expected_name(box</span><span class="s2">, </span><span class="s1">names)</span>

        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days 00:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;3 days 04:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">other = Series([offsets.Hour(n=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">offsets.Minute(n=-</span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">expected_add = Series([tdi[n] + other[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdi))]</span><span class="s2">, </span><span class="s1">name=exname)</span>
        <span class="s1">obj = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected_add = tm.box_expected(expected_add</span><span class="s2">, </span><span class="s1">box2)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res = obj + other</span>
        <span class="s1">tm.assert_equal(res</span><span class="s2">, </span><span class="s1">expected_add)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res2 = other + obj</span>
        <span class="s1">tm.assert_equal(res2</span><span class="s2">, </span><span class="s1">expected_add)</span>

        <span class="s1">expected_sub = Series([tdi[n] - other[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdi))]</span><span class="s2">, </span><span class="s1">name=exname)</span>
        <span class="s1">expected_sub = tm.box_expected(expected_sub</span><span class="s2">, </span><span class="s1">box2)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res3 = obj - other</span>
        <span class="s1">tm.assert_equal(res3</span><span class="s2">, </span><span class="s1">expected_sub)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;obox&quot;</span><span class="s2">, </span><span class="s1">[np.array</span><span class="s2">, </span><span class="s1">pd.Index</span><span class="s2">, </span><span class="s1">Series])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_addsub_anchored_offset_arraylike(self</span><span class="s2">, </span><span class="s1">obox</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18824</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 days 00:00:00&quot;</span><span class="s2">, </span><span class="s5">&quot;3 days 04:00:00&quot;</span><span class="s1">])</span>
        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">anchored = obox([offsets.MonthEnd()</span><span class="s2">, </span><span class="s1">offsets.Day(n=</span><span class="s4">2</span><span class="s1">)])</span>

        <span class="s0"># addition/subtraction ops with anchored offsets should issue</span>
        <span class="s0"># a PerformanceWarning and _then_ raise a TypeError.</span>
        <span class="s1">msg = </span><span class="s5">&quot;has incorrect type|cannot add the type MonthEnd&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
                <span class="s1">tdi + anchored</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
                <span class="s1">anchored + tdi</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
                <span class="s1">tdi - anchored</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
                <span class="s1">anchored - tdi</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Unsorted</span>

    <span class="s2">def </span><span class="s1">test_td64arr_add_sub_object_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;1 day&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">other = np.array([Timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">offsets.Day(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">&quot;2000-01-04&quot;</span><span class="s1">)])</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">result = tdarr + other</span>

        <span class="s1">expected = pd.Index(</span>
            <span class="s1">[Timedelta(days=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(days=</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">&quot;2000-01-07&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;unsupported operand type|cannot subtract a datelike&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
                <span class="s1">tdarr - other</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">result = other - tdarr</span>

        <span class="s1">expected = pd.Index([Timedelta(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">&quot;2000-01-01&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestTimedeltaArraylikeMulDivOps:</span>
    <span class="s0"># Tests for timedelta64[ns]</span>
    <span class="s0"># __mul__, __rmul__, __div__, __rdiv__, __floordiv__, __rfloordiv__</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Multiplication</span>
    <span class="s0"># organized with scalar others first, then array-like</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_int(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = idx * </span><span class="s4">1</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">idx)</span>

        <span class="s1">result = </span><span class="s4">1 </span><span class="s1">* idx</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">idx)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_tdlike_scalar_raises(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">msg = </span><span class="s5">&quot;argument must be an integer|cannot use operands with types dtype&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng * two_hours</span>

    <span class="s2">def </span><span class="s1">test_tdi_mul_int_array_zerodim(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">rng5 = np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">idx = TimedeltaIndex(rng5)</span>
        <span class="s1">expected = TimedeltaIndex(rng5 * </span><span class="s4">5</span><span class="s1">)</span>

        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = idx * np.array(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_tdi_mul_int_array(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">rng5 = np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">idx = TimedeltaIndex(rng5)</span>
        <span class="s1">expected = TimedeltaIndex(rng5 ** </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = idx * rng5</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_tdi_mul_int_series(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = Series </span><span class="s2">if </span><span class="s1">box </span><span class="s2">in </span><span class="s1">[pd.Index</span><span class="s2">, </span><span class="s1">tm.to_array</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">expected = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">) ** </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = idx * Series(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_tdi_mul_float_series(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = Series </span><span class="s2">if </span><span class="s1">box </span><span class="s2">in </span><span class="s1">[pd.Index</span><span class="s2">, </span><span class="s1">tm.to_array</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">rng5f = np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">expected = TimedeltaIndex(rng5f * (rng5f + </span><span class="s4">1.0</span><span class="s1">))</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = idx * Series(rng5f + </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># TODO: Put Series/DataFrame in others?</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Int64Index(range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">UInt64Index(range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">Float64Index(range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">pd.RangeIndex(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_tdi_rmul_arraylike(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">tdi = TimedeltaIndex([</span><span class="s5">&quot;1 Day&quot;</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s1">)._with_freq(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">xbox = get_upcast_box(tdi</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = other * tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">commute = tdi * other</span>
        <span class="s1">tm.assert_equal(commute</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># __div__, __rdiv__</span>

    <span class="s2">def </span><span class="s1">test_td64arr_div_nat_invalid(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># don't allow division by NaT (maybe could in the future)</span>
        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;unsupported operand type&quot;</span><span class="s1">):</span>
            <span class="s1">rng / NaT</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot divide NaTType by&quot;</span><span class="s1">):</span>
            <span class="s1">NaT / rng</span>

        <span class="s1">dt64nat = np.datetime64(</span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s5">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s0"># 'divide' on npdev as of 2021-12-18</span>
                <span class="s5">&quot;ufunc '(true_divide|divide)' cannot use operands&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;cannot perform __r?truediv__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Cannot divide datetime64 by TimedeltaArray&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng / dt64nat</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dt64nat / rng</span>

    <span class="s2">def </span><span class="s1">test_td64arr_div_td64nat(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#23829</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s1">)</span>
        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">other = np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span>

        <span class="s1">expected = np.array([np.nan] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = rng / other</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = other / rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_div_int(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = idx / </span><span class="s4">1</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">idx)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot divide&quot;</span><span class="s1">):</span>
            <span class="s0"># GH#23829</span>
            <span class="s4">1 </span><span class="s1">/ idx</span>

    <span class="s2">def </span><span class="s1">test_td64arr_div_tdlike_scalar(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#20088, GH#22163 ensure DataFrame returns correct dtype</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">rng = timedelta_range(</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s5">&quot;10 days&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Float64Index((np.arange(</span><span class="s4">10</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">12</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = rng / two_hours</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = two_hours / rng</span>
        <span class="s1">expected = </span><span class="s4">1 </span><span class="s1">/ expected</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;m&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s5">&quot;h&quot;</span><span class="s2">, </span><span class="s5">&quot;m&quot;</span><span class="s2">, </span><span class="s5">&quot;s&quot;</span><span class="s2">, </span><span class="s5">&quot;ms&quot;</span><span class="s2">, </span><span class="s5">&quot;us&quot;</span><span class="s2">, </span><span class="s5">&quot;ns&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_div_td64_scalar(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">ser = Series([Timedelta(days=</span><span class="s4">59</span><span class="s1">)] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">ser[</span><span class="s4">2</span><span class="s1">] = np.nan</span>
        <span class="s1">flat = ser</span>
        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s0"># op</span>
        <span class="s1">expected = Series([x / np.timedelta64(m</span><span class="s2">, </span><span class="s1">unit) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">flat])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">result = ser / np.timedelta64(m</span><span class="s2">, </span><span class="s1">unit)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># reverse op</span>
        <span class="s1">expected = Series([Timedelta(np.timedelta64(m</span><span class="s2">, </span><span class="s1">unit)) / x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">flat])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">result = np.timedelta64(m</span><span class="s2">, </span><span class="s1">unit) / ser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_div_tdlike_scalar_with_nat(self</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">rng = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Float64Index([</span><span class="s4">12</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">24</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = rng / two_hours</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = two_hours / rng</span>
        <span class="s1">expected = </span><span class="s4">1 </span><span class="s1">/ expected</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_div_td64_ndarray(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#22631</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">rng = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">])</span>
        <span class="s1">expected = Float64Index([</span><span class="s4">12</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">24</span><span class="s1">])</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">other = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[h]&quot;</span><span class="s1">)</span>
        <span class="s1">result = rng / other</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng / tm.box_expected(other</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng / other.astype(object)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng / list(other)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># reversed op</span>
        <span class="s1">expected = </span><span class="s4">1 </span><span class="s1">/ expected</span>
        <span class="s1">result = other / rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tm.box_expected(other</span><span class="s2">, </span><span class="s1">box) / rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = other.astype(object) / rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = list(other) / rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_tdarr_div_length_mismatch(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">rng = TimedeltaIndex([</span><span class="s5">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">&quot;2 days&quot;</span><span class="s1">])</span>
        <span class="s1">mismatched = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">msg = </span><span class="s5">&quot;Cannot divide vectors|Unable to coerce to Series&quot;</span>
        <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">[mismatched</span><span class="s2">, </span><span class="s1">mismatched[:</span><span class="s4">2</span><span class="s1">]]:</span>
            <span class="s0"># one shorter, one longer</span>
            <span class="s2">for </span><span class="s1">other </span><span class="s2">in </span><span class="s1">[obj</span><span class="s2">, </span><span class="s1">np.array(obj)</span><span class="s2">, </span><span class="s1">pd.Index(obj)]:</span>
                <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                    <span class="s1">rng / other</span>
                <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                    <span class="s1">other / rng</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># __floordiv__, __rfloordiv__</span>

    <span class="s2">def </span><span class="s1">test_td64arr_floordiv_td64arr_with_nat(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">using_array_manager</span>
    <span class="s1">):</span>
        <span class="s0"># GH#35529</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>

        <span class="s1">left = Series([</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">222330</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">right = Series([</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">222330</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">left = tm.box_expected(left</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">right = tm.box_expected(right</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">expected = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">DataFrame </span><span class="s2">and </span><span class="s1">using_array_manager:</span>
            <span class="s0"># INFO(ArrayManager) floorfiv returns integer, and ArrayManager</span>
            <span class="s0"># performs ops column-wise and thus preserves int64 dtype for</span>
            <span class="s0"># columns without missing values</span>
            <span class="s1">expected[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]] = expected[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]].astype(</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>

        <span class="s1">result = left // right</span>

        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># case that goes through __rfloordiv__ with arraylike</span>
        <span class="s1">result = np.asarray(left) // right</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_floordiv_tdscalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">scalar_td):</span>
        <span class="s0"># GH#18831, GH#19125</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = np.ndarray </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">else </span><span class="s1">box</span>
        <span class="s1">td = Timedelta(</span><span class="s5">&quot;5m3s&quot;</span><span class="s1">)  </span><span class="s0"># i.e. (scalar_td - 1sec) / 2</span>

        <span class="s1">td1 = Series([td</span><span class="s2">, </span><span class="s1">td</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">td1 = tm.box_expected(td1</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = td1 // scalar_td</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># Reversed op</span>
        <span class="s1">expected = Series([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = scalar_td // td1</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># same thing buts let's be explicit about calling __rfloordiv__</span>
        <span class="s1">result = td1.__rfloordiv__(scalar_td)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_floordiv_int(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">result = idx // </span><span class="s4">1</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">idx)</span>

        <span class="s1">pattern = </span><span class="s5">&quot;floor_divide cannot use operands|Cannot divide int by Timedelta*&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s4">1 </span><span class="s1">// idx</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># mod, divmod</span>
    <span class="s0"># TODO: operations with timedelta-like arrays, numeric arrays,</span>
    <span class="s0">#  reversed ops</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mod_tdscalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">three_days):</span>
        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s5">&quot;9 days&quot;</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s5">&quot;2 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;0 Days&quot;</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdarr % three_days</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">warn = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">DataFrame </span><span class="s2">and </span><span class="s1">isinstance(three_days</span><span class="s2">, </span><span class="s1">pd.DateOffset):</span>
            <span class="s1">warn = PerformanceWarning</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s1">result = divmod(tdarr</span><span class="s2">, </span><span class="s1">three_days)</span>

        <span class="s1">tm.assert_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tdarr // three_days)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mod_int(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;1 ns&quot;</span><span class="s2">, </span><span class="s5">&quot;10 ns&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;1 ns&quot;</span><span class="s2">, </span><span class="s5">&quot;0 ns&quot;</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdarr % </span><span class="s4">2</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Cannot divide int by&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s4">2 </span><span class="s1">% tdarr</span>

        <span class="s1">result = divmod(tdarr</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tdarr // </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_rmod_tdscalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">three_days):</span>
        <span class="s1">tdi = timedelta_range(</span><span class="s5">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s5">&quot;9 days&quot;</span><span class="s1">)</span>
        <span class="s1">tdarr = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">expected = [</span><span class="s5">&quot;0 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s5">&quot;0 Days&quot;</span><span class="s1">] + [</span><span class="s5">&quot;3 Days&quot;</span><span class="s1">] * </span><span class="s4">6</span>
        <span class="s1">expected = TimedeltaIndex(expected)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = three_days % tdarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = divmod(three_days</span><span class="s2">, </span><span class="s1">tdarr)</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">three_days // tdarr)</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Operations with invalid others</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_tdscalar_invalid(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">scalar_td):</span>
        <span class="s1">td1 = Series([timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">td1.iloc[</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s1">td1 = tm.box_expected(td1</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s0"># check that we are getting a TypeError</span>
        <span class="s0"># with 'operate' (from core/ops.py) for the ops that are not</span>
        <span class="s0"># defined</span>
        <span class="s1">pattern = </span><span class="s5">&quot;operate|unsupported|cannot|not supported&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s1">td1 * scalar_td</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s1">scalar_td * td1</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_too_short_raises(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">msg = </span><span class="s5">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s5">&quot;cannot use operands with types dtype&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Cannot multiply with unequal lengths&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Unable to coerce to Series&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s0"># length check before dtype check</span>
            <span class="s1">idx * idx[:</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx * np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_td64arr_raises(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">idx = TimedeltaIndex(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">msg = </span><span class="s5">&quot;cannot use operands with types dtype&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx * idx</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Operations with numeric others</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_numeric_scalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">one):</span>
        <span class="s0"># GH#4521</span>
        <span class="s0"># divide/multiply by integers</span>
        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s5">&quot;-59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;-59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">tdser = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdser * (-one)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = (-one) * tdser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s5">&quot;118 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;118 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdser * (</span><span class="s4">2 </span><span class="s1">* one)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = (</span><span class="s4">2 </span><span class="s1">* one) * tdser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;two&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s4">2.0</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_div_numeric_scalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">two):</span>
        <span class="s0"># GH#4521</span>
        <span class="s0"># divide/multiply by integers</span>
        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s5">&quot;29.5D&quot;</span><span class="s2">, </span><span class="s5">&quot;29.5D&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">tdser = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdser / two</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot divide&quot;</span><span class="s1">):</span>
            <span class="s1">two / tdser</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;two&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s4">2.0</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_td64arr_floordiv_numeric_scalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">two):</span>
        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s5">&quot;29.5D&quot;</span><span class="s2">, </span><span class="s5">&quot;29.5D&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">tdser = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = tdser // two</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot divide&quot;</span><span class="s1">):</span>
            <span class="s1">two // tdser</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;vector&quot;</span><span class="s2">,</span>
        <span class="s1">[np.array([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])</span><span class="s2">, </span><span class="s1">pd.Index([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])</span><span class="s2">, </span><span class="s1">Series([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_td64arr_rmul_numeric_array(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">box_with_array</span><span class="s2">,</span>
        <span class="s1">vector</span><span class="s2">,</span>
        <span class="s1">any_real_numpy_dtype</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0"># GH#4521</span>
        <span class="s0"># divide/multiply by integers</span>

        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">vector = vector.astype(any_real_numpy_dtype)</span>

        <span class="s1">expected = Series([</span><span class="s5">&quot;1180 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;1770 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">tdser = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">xbox = get_upcast_box(tdser</span><span class="s2">, </span><span class="s1">vector)</span>

        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = tdser * vector</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = vector * tdser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;vector&quot;</span><span class="s2">,</span>
        <span class="s1">[np.array([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])</span><span class="s2">, </span><span class="s1">pd.Index([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])</span><span class="s2">, </span><span class="s1">Series([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_td64arr_div_numeric_array(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">vector</span><span class="s2">, </span><span class="s1">any_real_numpy_dtype</span>
    <span class="s1">):</span>
        <span class="s0"># GH#4521</span>
        <span class="s0"># divide/multiply by integers</span>

        <span class="s1">tdser = Series([</span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;59 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">vector = vector.astype(any_real_numpy_dtype)</span>

        <span class="s1">expected = Series([</span><span class="s5">&quot;2.95D&quot;</span><span class="s2">, </span><span class="s5">&quot;1D 23H 12m&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">tdser = tm.box_expected(tdser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">xbox = get_upcast_box(tdser</span><span class="s2">, </span><span class="s1">vector)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = tdser / vector</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">pattern = </span><span class="s5">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s5">&quot;true_divide'? cannot use operands&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;cannot perform __div__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;cannot perform __truediv__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;unsupported operand&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Cannot divide&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s1">vector / tdser</span>

        <span class="s1">result = tdser / vector.astype(object)</span>
        <span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">DataFrame:</span>
            <span class="s1">expected = [tdser.iloc[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n] / vector[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(vector))]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = [tdser[n] / vector[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(tdser))]</span>
        <span class="s1">expected = pd.Index(expected)  </span><span class="s0"># do dtype inference</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s2">assert </span><span class="s1">tm.get_dtype(expected) == </span><span class="s5">&quot;m8[ns]&quot;</span>

        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s1">vector.astype(object) / tdser</span>

    <span class="s2">def </span><span class="s1">test_td64arr_mul_int_series(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0"># GH#19042 test for correct name attachment</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">exname = get_expected_name(box</span><span class="s2">, </span><span class="s1">names)</span>

        <span class="s1">tdi = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s5">&quot;0days&quot;</span><span class="s2">, </span><span class="s5">&quot;1day&quot;</span><span class="s2">, </span><span class="s5">&quot;2days&quot;</span><span class="s2">, </span><span class="s5">&quot;3days&quot;</span><span class="s2">, </span><span class="s5">&quot;4days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0"># TODO: Should we be parametrizing over types for `ser` too?</span>
        <span class="s1">ser = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.int64</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s5">&quot;0days&quot;</span><span class="s2">, </span><span class="s5">&quot;1day&quot;</span><span class="s2">, </span><span class="s5">&quot;4days&quot;</span><span class="s2">, </span><span class="s5">&quot;9days&quot;</span><span class="s2">, </span><span class="s5">&quot;16days&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s2">,</span>
            <span class="s1">name=exname</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">xbox = get_upcast_box(tdi</span><span class="s2">, </span><span class="s1">ser)</span>

        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = ser * tdi</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tdi * ser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># TODO: Should we be parametrizing over types for `ser` too?</span>
    <span class="s2">def </span><span class="s1">test_float_series_rdiv_td64arr(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0"># GH#19042 test for correct name attachment</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">tdi = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s5">&quot;0days&quot;</span><span class="s2">, </span><span class="s5">&quot;1day&quot;</span><span class="s2">, </span><span class="s5">&quot;2days&quot;</span><span class="s2">, </span><span class="s5">&quot;3days&quot;</span><span class="s2">, </span><span class="s5">&quot;4days&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">ser = Series([</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4.5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.float64</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">xname = names[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">if </span><span class="s1">box </span><span class="s2">not in </span><span class="s1">[tm.to_array</span><span class="s2">, </span><span class="s1">pd.array] </span><span class="s2">else </span><span class="s1">names[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[tdi[n] / ser[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(ser))]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s2">,</span>
            <span class="s1">name=xname</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">tdi = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">xbox = get_upcast_box(tdi</span><span class="s2">, </span><span class="s1">ser)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = ser.__rtruediv__(tdi)</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">DataFrame:</span>
            <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_td64arr_all_nat_div_object_dtype_numeric(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#39750 make sure we infer the result as td64</span>
        <span class="s1">tdi = TimedeltaIndex([NaT</span><span class="s2">, </span><span class="s1">NaT])</span>

        <span class="s1">left = tm.box_expected(tdi</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">right = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">result = left / right</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">left)</span>

        <span class="s1">result = left // right</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">left)</span>


<span class="s2">class </span><span class="s1">TestTimedelta64ArrayLikeArithmetic:</span>
    <span class="s0"># Arithmetic tests for timedelta64[ns] vectors fully parametrized over</span>
    <span class="s0">#  DataFrame/Series/TimedeltaIndex/TimedeltaArray.  Ideally all arithmetic</span>
    <span class="s0">#  tests will eventually end up here.</span>

    <span class="s2">def </span><span class="s1">test_td64arr_pow_invalid(self</span><span class="s2">, </span><span class="s1">scalar_td</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">td1 = Series([timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">td1.iloc[</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s1">td1 = tm.box_expected(td1</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s0"># check that we are getting a TypeError</span>
        <span class="s0"># with 'operate' (from core/ops.py) for the ops that are not</span>
        <span class="s0"># defined</span>
        <span class="s1">pattern = </span><span class="s5">&quot;operate|unsupported|cannot|not supported&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s1">scalar_td ** td1</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=pattern):</span>
            <span class="s1">td1 ** scalar_td</span>


<span class="s2">def </span><span class="s1">test_add_timestamp_to_timedelta():</span>
    <span class="s0"># GH: 35897</span>
    <span class="s1">timestamp = Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">)</span>
    <span class="s1">result = timestamp + timedelta_range(</span><span class="s5">&quot;0s&quot;</span><span class="s2">, </span><span class="s5">&quot;1s&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">31</span><span class="s1">)</span>
    <span class="s1">expected = DatetimeIndex(</span>
        <span class="s1">[</span>
            <span class="s1">timestamp</span>
            <span class="s1">+ (</span>
                <span class="s1">pd.to_timedelta(</span><span class="s5">&quot;0.033333333s&quot;</span><span class="s1">) * i</span>
                <span class="s1">+ pd.to_timedelta(</span><span class="s5">&quot;0.000000001s&quot;</span><span class="s1">) * divmod(i</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">31</span><span class="s1">)</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>