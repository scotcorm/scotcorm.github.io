<html>
<head>
<title>test_decimal.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_decimal.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">decimal</span>
<span class="s0">import </span><span class="s1">operator</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.api.types </span><span class="s0">import </span><span class="s1">infer_dtype</span>
<span class="s0">from </span><span class="s1">pandas.tests.extension </span><span class="s0">import </span><span class="s1">base</span>
<span class="s0">from </span><span class="s1">pandas.tests.extension.decimal.array </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DecimalArray</span><span class="s0">,</span>
    <span class="s1">DecimalDtype</span><span class="s0">,</span>
    <span class="s1">make_data</span><span class="s0">,</span>
    <span class="s1">to_decimal</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">dtype():</span>
    <span class="s0">return </span><span class="s1">DecimalDtype()</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">data():</span>
    <span class="s0">return </span><span class="s1">DecimalArray(make_data())</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">data_for_twos():</span>
    <span class="s0">return </span><span class="s1">DecimalArray([decimal.Decimal(</span><span class="s2">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">100</span><span class="s1">)])</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">data_missing():</span>
    <span class="s0">return </span><span class="s1">DecimalArray([decimal.Decimal(</span><span class="s3">&quot;NaN&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s2">1</span><span class="s1">)])</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">data_for_sorting():</span>
    <span class="s0">return </span><span class="s1">DecimalArray(</span>
        <span class="s1">[decimal.Decimal(</span><span class="s3">&quot;1&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;2&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;0&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">data_missing_for_sorting():</span>
    <span class="s0">return </span><span class="s1">DecimalArray(</span>
        <span class="s1">[decimal.Decimal(</span><span class="s3">&quot;1&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;NaN&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;0&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">na_cmp():</span>
    <span class="s0">return lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x.is_nan() </span><span class="s0">and </span><span class="s1">y.is_nan()</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">na_value():</span>
    <span class="s0">return </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;NaN&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">data_for_grouping():</span>
    <span class="s1">b = decimal.Decimal(</span><span class="s3">&quot;1.0&quot;</span><span class="s1">)</span>
    <span class="s1">a = decimal.Decimal(</span><span class="s3">&quot;0.0&quot;</span><span class="s1">)</span>
    <span class="s1">c = decimal.Decimal(</span><span class="s3">&quot;2.0&quot;</span><span class="s1">)</span>
    <span class="s1">na = decimal.Decimal(</span><span class="s3">&quot;NaN&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">DecimalArray([b</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c])</span>


<span class="s0">class </span><span class="s1">TestDtype(base.BaseDtypeTests):</span>
    <span class="s0">def </span><span class="s1">test_hashable(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s0">pass</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_infer_dtype(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">data_missing</span><span class="s0">, </span><span class="s1">skipna):</span>
        <span class="s4"># here overriding base test to ensure we fall back to return</span>
        <span class="s4"># &quot;unknown-array&quot; for an EA pandas doesn't know</span>
        <span class="s0">assert </span><span class="s1">infer_dtype(data</span><span class="s0">, </span><span class="s1">skipna=skipna) == </span><span class="s3">&quot;unknown-array&quot;</span>
        <span class="s0">assert </span><span class="s1">infer_dtype(data_missing</span><span class="s0">, </span><span class="s1">skipna=skipna) == </span><span class="s3">&quot;unknown-array&quot;</span>


<span class="s0">class </span><span class="s1">TestInterface(base.BaseInterfaceTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestConstructors(base.BaseConstructorsTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestReshaping(base.BaseReshapingTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestGetitem(base.BaseGetitemTests):</span>
    <span class="s0">def </span><span class="s1">test_take_na_value_other_decimal(self):</span>
        <span class="s1">arr = DecimalArray([decimal.Decimal(</span><span class="s3">&quot;1.0&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;2.0&quot;</span><span class="s1">)])</span>
        <span class="s1">result = arr.take([</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">allow_fill=</span><span class="s0">True, </span><span class="s1">fill_value=decimal.Decimal(</span><span class="s3">&quot;-1.0&quot;</span><span class="s1">))</span>
        <span class="s1">expected = DecimalArray([decimal.Decimal(</span><span class="s3">&quot;1.0&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;-1.0&quot;</span><span class="s1">)])</span>
        <span class="s1">self.assert_extension_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestIndex(base.BaseIndexTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestMissing(base.BaseMissingTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">Reduce:</span>
    <span class="s0">def </span><span class="s1">check_reduce(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s1">skipna):</span>

        <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;median&quot;</span><span class="s0">, </span><span class="s3">&quot;skew&quot;</span><span class="s0">, </span><span class="s3">&quot;kurt&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s3">r&quot;decimal does not support the .* operation&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">getattr(s</span><span class="s0">, </span><span class="s1">op_name)(skipna=skipna)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = getattr(s</span><span class="s0">, </span><span class="s1">op_name)(skipna=skipna)</span>
            <span class="s1">expected = getattr(np.asarray(s)</span><span class="s0">, </span><span class="s1">op_name)()</span>
            <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestNumericReduce(Reduce</span><span class="s0">, </span><span class="s1">base.BaseNumericReduceTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestBooleanReduce(Reduce</span><span class="s0">, </span><span class="s1">base.BaseBooleanReduceTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestMethods(base.BaseMethodsTests):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dropna&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_value_counts(self</span><span class="s0">, </span><span class="s1">all_data</span><span class="s0">, </span><span class="s1">dropna</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s1">all_data = all_data[:</span><span class="s2">10</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">dropna:</span>
            <span class="s1">other = np.array(all_data[~all_data.isna()])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">other = all_data</span>

        <span class="s1">vcs = pd.Series(all_data).value_counts(dropna=dropna)</span>
        <span class="s1">vcs_ex = pd.Series(other).value_counts(dropna=dropna)</span>

        <span class="s0">with </span><span class="s1">decimal.localcontext() </span><span class="s0">as </span><span class="s1">ctx:</span>
            <span class="s4"># avoid raising when comparing Decimal(&quot;NAN&quot;) &lt; Decimal(2)</span>
            <span class="s1">ctx.traps[decimal.InvalidOperation] = </span><span class="s0">False</span>

            <span class="s1">result = vcs.sort_index()</span>
            <span class="s1">expected = vcs_ex.sort_index()</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestCasting(base.BaseCastingTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestGroupby(base.BaseGroupbyTests):</span>
    <span class="s0">def </span><span class="s1">test_groupby_agg_extension(self</span><span class="s0">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">super().test_groupby_agg_extension(data_for_grouping)</span>


<span class="s0">class </span><span class="s1">TestSetitem(base.BaseSetitemTests):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestPrinting(base.BasePrintingTests):</span>
    <span class="s0">def </span><span class="s1">test_series_repr(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s4"># Overriding this base test to explicitly test that</span>
        <span class="s4"># the custom _formatter is used</span>
        <span class="s1">ser = pd.Series(data)</span>
        <span class="s0">assert </span><span class="s1">data.dtype.name </span><span class="s0">in </span><span class="s1">repr(ser)</span>
        <span class="s0">assert </span><span class="s3">&quot;Decimal: &quot; </span><span class="s0">in </span><span class="s1">repr(ser)</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">reason=(</span>
        <span class="s3">&quot;DecimalArray constructor raises bc _from_sequence wants Decimals, not ints.&quot;</span>
        <span class="s3">&quot;Easy to fix, just need to do it.&quot;</span>
    <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">raises=TypeError</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_series_constructor_coerce_data_to_extension_dtype_raises():</span>
    <span class="s1">xpr = (</span>
        <span class="s3">&quot;Cannot cast data to extension dtype 'decimal'. Pass the &quot;</span>
        <span class="s3">&quot;extension array directly.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=xpr):</span>
        <span class="s1">pd.Series([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=DecimalDtype())</span>


<span class="s0">def </span><span class="s1">test_series_constructor_with_dtype():</span>
    <span class="s1">arr = DecimalArray([decimal.Decimal(</span><span class="s3">&quot;10.0&quot;</span><span class="s1">)])</span>
    <span class="s1">result = pd.Series(arr</span><span class="s0">, </span><span class="s1">dtype=DecimalDtype())</span>
    <span class="s1">expected = pd.Series(arr)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = pd.Series(arr</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">10</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_dataframe_constructor_with_dtype():</span>
    <span class="s1">arr = DecimalArray([decimal.Decimal(</span><span class="s3">&quot;10.0&quot;</span><span class="s1">)])</span>

    <span class="s1">result = pd.DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: arr}</span><span class="s0">, </span><span class="s1">dtype=DecimalDtype())</span>
    <span class="s1">expected = pd.DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: arr})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">arr = DecimalArray([decimal.Decimal(</span><span class="s3">&quot;10.0&quot;</span><span class="s1">)])</span>
    <span class="s1">result = pd.DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: arr}</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s2">10</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;frame&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_astype_dispatches(frame):</span>
    <span class="s4"># This is a dtype-specific test that ensures Series[decimal].astype</span>
    <span class="s4"># gets all the way through to ExtensionArray.astype</span>
    <span class="s4"># Designing a reliable smoke test that works for arbitrary data types</span>
    <span class="s4"># is difficult.</span>
    <span class="s1">data = pd.Series(DecimalArray([decimal.Decimal(</span><span class="s2">2</span><span class="s1">)])</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">ctx = decimal.Context()</span>
    <span class="s1">ctx.prec = </span><span class="s2">5</span>

    <span class="s0">if </span><span class="s1">frame:</span>
        <span class="s1">data = data.to_frame()</span>

    <span class="s1">result = data.astype(DecimalDtype(ctx))</span>

    <span class="s0">if </span><span class="s1">frame:</span>
        <span class="s1">result = result[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span>

    <span class="s0">assert </span><span class="s1">result.dtype.context.prec == ctx.prec</span>


<span class="s0">class </span><span class="s1">TestArithmeticOps(base.BaseArithmeticOpsTests):</span>
    <span class="s0">def </span><span class="s1">check_opname(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">exc=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">super().check_opname(s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">exc=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_arith_series_with_array(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">all_arithmetic_operators):</span>
        <span class="s1">op_name = all_arithmetic_operators</span>
        <span class="s1">s = pd.Series(data)</span>

        <span class="s1">context = decimal.getcontext()</span>
        <span class="s1">divbyzerotrap = context.traps[decimal.DivisionByZero]</span>
        <span class="s1">invalidoptrap = context.traps[decimal.InvalidOperation]</span>
        <span class="s1">context.traps[decimal.DivisionByZero] = </span><span class="s2">0</span>
        <span class="s1">context.traps[decimal.InvalidOperation] = </span><span class="s2">0</span>

        <span class="s4"># Decimal supports ops with int, but not float</span>
        <span class="s1">other = pd.Series([int(d * </span><span class="s2">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">data])</span>
        <span class="s1">self.check_opname(s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s0">if </span><span class="s3">&quot;mod&quot; </span><span class="s0">not in </span><span class="s1">op_name:</span>
            <span class="s1">self.check_opname(s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s1">s * </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">self.check_opname(s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.check_opname(s</span><span class="s0">, </span><span class="s1">op_name</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">context.traps[decimal.DivisionByZero] = divbyzerotrap</span>
        <span class="s1">context.traps[decimal.InvalidOperation] = invalidoptrap</span>

    <span class="s0">def </span><span class="s1">_check_divmod_op(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">exc=NotImplementedError):</span>
        <span class="s4"># We implement divmod</span>
        <span class="s1">super()._check_divmod_op(s</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">exc=</span><span class="s0">None</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestComparisonOps(base.BaseComparisonOpsTests):</span>
    <span class="s0">def </span><span class="s1">test_compare_scalar(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">comparison_op):</span>
        <span class="s1">s = pd.Series(data)</span>
        <span class="s1">self._compare_other(s</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">comparison_op</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_compare_array(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">comparison_op):</span>
        <span class="s1">s = pd.Series(data)</span>

        <span class="s1">alter = np.random.choice([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">len(data))</span>
        <span class="s4"># Randomly double, halve or keep same value</span>
        <span class="s1">other = pd.Series(data) * [decimal.Decimal(pow(</span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">i)) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">alter]</span>
        <span class="s1">self._compare_other(s</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">comparison_op</span><span class="s0">, </span><span class="s1">other)</span>


<span class="s0">class </span><span class="s1">DecimalArrayWithoutFromSequence(DecimalArray):</span>
    <span class="s5">&quot;&quot;&quot;Helper class for testing error handling in _from_sequence.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_from_sequence(cls</span><span class="s0">, </span><span class="s1">scalars</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;For the test&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">DecimalArrayWithoutCoercion(DecimalArrayWithoutFromSequence):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_create_arithmetic_method(cls</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s0">return </span><span class="s1">cls._create_method(op</span><span class="s0">, </span><span class="s1">coerce_to_dtype=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">DecimalArrayWithoutCoercion._add_arithmetic_ops()</span>


<span class="s0">def </span><span class="s1">test_combine_from_sequence_raises(monkeypatch):</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/22850</span>
    <span class="s1">cls = DecimalArrayWithoutFromSequence</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">construct_array_type(cls):</span>
        <span class="s0">return </span><span class="s1">DecimalArrayWithoutFromSequence</span>

    <span class="s1">monkeypatch.setattr(DecimalDtype</span><span class="s0">, </span><span class="s3">&quot;construct_array_type&quot;</span><span class="s0">, </span><span class="s1">construct_array_type)</span>

    <span class="s1">arr = cls([decimal.Decimal(</span><span class="s3">&quot;1.0&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;2.0&quot;</span><span class="s1">)])</span>
    <span class="s1">ser = pd.Series(arr)</span>
    <span class="s1">result = ser.combine(ser</span><span class="s0">, </span><span class="s1">operator.add)</span>

    <span class="s4"># note: object dtype</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[decimal.Decimal(</span><span class="s3">&quot;2.0&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;4.0&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;class_&quot;</span><span class="s0">, </span><span class="s1">[DecimalArrayWithoutFromSequence</span><span class="s0">, </span><span class="s1">DecimalArrayWithoutCoercion]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_scalar_ops_from_sequence_raises(class_):</span>
    <span class="s4"># op(EA, EA) should return an EA, or an ndarray if it's not possible</span>
    <span class="s4"># to return an EA with the return values.</span>
    <span class="s1">arr = class_([decimal.Decimal(</span><span class="s3">&quot;1.0&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;2.0&quot;</span><span class="s1">)])</span>
    <span class="s1">result = arr + arr</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[decimal.Decimal(</span><span class="s3">&quot;2.0&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;4.0&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;reverse, expected_div, expected_mod&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s0">False, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_divmod_array(reverse</span><span class="s0">, </span><span class="s1">expected_div</span><span class="s0">, </span><span class="s1">expected_mod):</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/22930</span>
    <span class="s1">arr = to_decimal([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">reverse:</span>
        <span class="s1">div</span><span class="s0">, </span><span class="s1">mod = divmod(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">arr)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">div</span><span class="s0">, </span><span class="s1">mod = divmod(arr</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">expected_div = to_decimal(expected_div)</span>
    <span class="s1">expected_mod = to_decimal(expected_mod)</span>

    <span class="s1">tm.assert_extension_array_equal(div</span><span class="s0">, </span><span class="s1">expected_div)</span>
    <span class="s1">tm.assert_extension_array_equal(mod</span><span class="s0">, </span><span class="s1">expected_mod)</span>


<span class="s0">def </span><span class="s1">test_ufunc_fallback(data):</span>
    <span class="s1">a = data[:</span><span class="s2">5</span><span class="s1">]</span>
    <span class="s1">s = pd.Series(a</span><span class="s0">, </span><span class="s1">index=range(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">))</span>
    <span class="s1">result = np.abs(s)</span>
    <span class="s1">expected = pd.Series(np.abs(a)</span><span class="s0">, </span><span class="s1">index=range(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_array_ufunc():</span>
    <span class="s1">a = to_decimal([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">result = np.exp(a)</span>
    <span class="s1">expected = to_decimal(np.exp(a._data))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_array_ufunc_series():</span>
    <span class="s1">a = to_decimal([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">s = pd.Series(a)</span>
    <span class="s1">result = np.exp(s)</span>
    <span class="s1">expected = pd.Series(to_decimal(np.exp(a._data)))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_array_ufunc_series_scalar_other():</span>
    <span class="s4"># check _HANDLED_TYPES</span>
    <span class="s1">a = to_decimal([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">s = pd.Series(a)</span>
    <span class="s1">result = np.add(s</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">expected = pd.Series(np.add(a</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s2">1</span><span class="s1">)))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_array_ufunc_series_defer():</span>
    <span class="s1">a = to_decimal([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">s = pd.Series(a)</span>

    <span class="s1">expected = pd.Series(to_decimal([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]))</span>
    <span class="s1">r1 = np.add(s</span><span class="s0">, </span><span class="s1">a)</span>
    <span class="s1">r2 = np.add(a</span><span class="s0">, </span><span class="s1">s)</span>

    <span class="s1">tm.assert_series_equal(r1</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_series_equal(r2</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_agg():</span>
    <span class="s4"># Ensure that the result of agg is inferred to be decimal dtype</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/29141</span>

    <span class="s1">data = make_data()[:</span><span class="s2">5</span><span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s3">&quot;id1&quot;</span><span class="s1">: [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;id2&quot;</span><span class="s1">: [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;decimals&quot;</span><span class="s1">: DecimalArray(data)}</span>
    <span class="s1">)</span>

    <span class="s4"># single key, selected column</span>
    <span class="s1">expected = pd.Series(to_decimal([data[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data[</span><span class="s2">3</span><span class="s1">]]))</span>
    <span class="s1">result = df.groupby(</span><span class="s3">&quot;id1&quot;</span><span class="s1">)[</span><span class="s3">&quot;decimals&quot;</span><span class="s1">].agg(</span><span class="s0">lambda </span><span class="s1">x: x.iloc[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">result = df[</span><span class="s3">&quot;decimals&quot;</span><span class="s1">].groupby(df[</span><span class="s3">&quot;id1&quot;</span><span class="s1">]).agg(</span><span class="s0">lambda </span><span class="s1">x: x.iloc[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># multiple keys, selected column</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">to_decimal([data[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data[</span><span class="s2">3</span><span class="s1">]])</span><span class="s0">,</span>
        <span class="s1">index=pd.MultiIndex.from_tuples([(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">result = df.groupby([</span><span class="s3">&quot;id1&quot;</span><span class="s0">, </span><span class="s3">&quot;id2&quot;</span><span class="s1">])[</span><span class="s3">&quot;decimals&quot;</span><span class="s1">].agg(</span><span class="s0">lambda </span><span class="s1">x: x.iloc[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">result = df[</span><span class="s3">&quot;decimals&quot;</span><span class="s1">].groupby([df[</span><span class="s3">&quot;id1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">df[</span><span class="s3">&quot;id2&quot;</span><span class="s1">]]).agg(</span><span class="s0">lambda </span><span class="s1">x: x.iloc[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># multiple columns</span>
    <span class="s1">expected = pd.DataFrame({</span><span class="s3">&quot;id2&quot;</span><span class="s1">: [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;decimals&quot;</span><span class="s1">: to_decimal([data[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data[</span><span class="s2">3</span><span class="s1">]])})</span>
    <span class="s1">result = df.groupby(</span><span class="s3">&quot;id1&quot;</span><span class="s1">).agg(</span><span class="s0">lambda </span><span class="s1">x: x.iloc[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_groupby_agg_ea_method(monkeypatch):</span>
    <span class="s4"># Ensure that the result of agg is inferred to be decimal dtype</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/29141</span>

    <span class="s0">def </span><span class="s1">DecimalArray__my_sum(self):</span>
        <span class="s0">return </span><span class="s1">np.sum(np.array(self))</span>

    <span class="s1">monkeypatch.setattr(DecimalArray</span><span class="s0">, </span><span class="s3">&quot;my_sum&quot;</span><span class="s0">, </span><span class="s1">DecimalArray__my_sum</span><span class="s0">, </span><span class="s1">raising=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">data = make_data()[:</span><span class="s2">5</span><span class="s1">]</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;id&quot;</span><span class="s1">: [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;decimals&quot;</span><span class="s1">: DecimalArray(data)})</span>
    <span class="s1">expected = pd.Series(to_decimal([data[</span><span class="s2">0</span><span class="s1">] + data[</span><span class="s2">1</span><span class="s1">] + data[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data[</span><span class="s2">3</span><span class="s1">] + data[</span><span class="s2">4</span><span class="s1">]]))</span>

    <span class="s1">result = df.groupby(</span><span class="s3">&quot;id&quot;</span><span class="s1">)[</span><span class="s3">&quot;decimals&quot;</span><span class="s1">].agg(</span><span class="s0">lambda </span><span class="s1">x: x.values.my_sum())</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">s = pd.Series(DecimalArray(data))</span>
    <span class="s1">result = s.groupby(np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])).agg(</span><span class="s0">lambda </span><span class="s1">x: x.values.my_sum())</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_indexing_no_materialize(monkeypatch):</span>
    <span class="s4"># See https://github.com/pandas-dev/pandas/issues/29708</span>
    <span class="s4"># Ensure that indexing operations do not materialize (convert to a numpy</span>
    <span class="s4"># array) the ExtensionArray unnecessary</span>

    <span class="s0">def </span><span class="s1">DecimalArray__array__(self</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">Exception(</span><span class="s3">&quot;tried to convert a DecimalArray to a numpy array&quot;</span><span class="s1">)</span>

    <span class="s1">monkeypatch.setattr(DecimalArray</span><span class="s0">, </span><span class="s3">&quot;__array__&quot;</span><span class="s0">, </span><span class="s1">DecimalArray__array__</span><span class="s0">, </span><span class="s1">raising=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">data = make_data()</span>
    <span class="s1">s = pd.Series(DecimalArray(data))</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: s</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: range(len(s))})</span>

    <span class="s4"># ensure the following operations do not raise an error</span>
    <span class="s1">s[s &gt; </span><span class="s2">0.5</span><span class="s1">]</span>
    <span class="s1">df[s &gt; </span><span class="s2">0.5</span><span class="s1">]</span>
    <span class="s1">s.at[</span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">df.at[</span><span class="s2">0</span><span class="s0">, </span><span class="s3">&quot;a&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_to_numpy_keyword():</span>
    <span class="s4"># test the extra keyword</span>
    <span class="s1">values = [decimal.Decimal(</span><span class="s3">&quot;1.1111&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;2.2222&quot;</span><span class="s1">)]</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[decimal.Decimal(</span><span class="s3">&quot;1.11&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">&quot;2.22&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span>
    <span class="s1">)</span>
    <span class="s1">a = pd.array(values</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;decimal&quot;</span><span class="s1">)</span>
    <span class="s1">result = a.to_numpy(decimals=</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = pd.Series(a).to_numpy(decimals=</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>