<html>
<head>
<title>khash.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #0f9795;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
khash.h</font>
</center></td></tr></table>
<pre><span class="s0">/* The MIT License 
 
   Copyright (c) 2008, 2009, 2011 by Attractive Chaos &lt;attractor@live.co.uk&gt; 
 
   Permission is hereby granted, free of charge, to any person obtaining 
   a copy of this software and associated documentation files (the 
   &quot;Software&quot;), to deal in the Software without restriction, including 
   without limitation the rights to use, copy, modify, merge, publish, 
   distribute, sublicense, and/or sell copies of the Software, and to 
   permit persons to whom the Software is furnished to do so, subject to 
   the following conditions: 
 
   The above copyright notice and this permission notice shall be 
   included in all copies or substantial portions of the Software. 
 
   THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, 
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS 
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
   SOFTWARE. 
*/</span>

<span class="s0">/* 
  An example: 
 
#include &quot;khash.h&quot; 
KHASH_MAP_INIT_INT(32, char) 
int main() { 
    int ret, is_missing; 
    khiter_t k; 
    khash_t(32) *h = kh_init(32); 
    k = kh_put(32, h, 5, &amp;ret); 
    if (!ret) kh_del(32, h, k); 
    kh_value(h, k) = 10; 
    k = kh_get(32, h, 10); 
    is_missing = (k == kh_end(h)); 
    k = kh_get(32, h, 5); 
    kh_del(32, h, k); 
    for (k = kh_begin(h); k != kh_end(h); ++k) 
        if (kh_exist(h, k)) kh_value(h, k) = 1; 
    kh_destroy(32, h); 
    return 0; 
} 
*/</span>

<span class="s0">/* 
  2011-09-16 (0.2.6): 
 
    * The capacity is a power of 2. This seems to dramatically improve the 
      speed for simple keys. Thank Zilong Tan for the suggestion. Reference: 
 
       - https://github.com/stefanocasazza/ULib 
       - https://nothings.org/computer/judy/ 
 
    * Allow to optionally use linear probing which usually has better 
      performance for random input. Double hashing is still the default as it 
      is more robust to certain non-random input. 
 
    * Added Wang's integer hash function (not used by default). This hash 
      function is more robust to certain non-random input. 
 
  2011-02-14 (0.2.5): 
 
    * Allow to declare global functions. 
 
  2009-09-26 (0.2.4): 
 
    * Improve portability 
 
  2008-09-19 (0.2.3): 
 
    * Corrected the example 
    * Improved interfaces 
 
  2008-09-11 (0.2.2): 
 
    * Improved speed a little in kh_put() 
 
  2008-09-10 (0.2.1): 
 
    * Added kh_clear() 
    * Fixed a compiling error 
 
  2008-09-02 (0.2.0): 
 
    * Changed to token concatenation which increases flexibility. 
 
  2008-08-31 (0.1.2): 
 
    * Fixed a bug in kh_get(), which has not been tested previously. 
 
  2008-08-31 (0.1.1): 
 
    * Added destructor 
*/</span>


<span class="s2">#ifndef </span><span class="s1">__AC_KHASH_H</span>
<span class="s2">#define </span><span class="s1">__AC_KHASH_H</span>

<span class="s0">/*! 
  @header 
 
  Generic hash table library. 
 */</span>

<span class="s2">#define </span><span class="s1">AC_VERSION_KHASH_H </span><span class="s3">&quot;0.2.6&quot;</span>

<span class="s2">#include </span><span class="s1">&lt;stdlib.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;string.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;limits.h&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;../inline_helper.h&quot;</span>


<span class="s0">// hooks for memory allocator, C-runtime allocator used per default</span>
<span class="s2">#ifndef </span><span class="s1">KHASH_MALLOC</span>
<span class="s2">#define </span><span class="s1">KHASH_MALLOC malloc</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef </span><span class="s1">KHASH_REALLOC</span>
<span class="s2">#define </span><span class="s1">KHASH_REALLOC realloc</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef </span><span class="s1">KHASH_CALLOC</span>
<span class="s2">#define </span><span class="s1">KHASH_CALLOC calloc</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef </span><span class="s1">KHASH_FREE</span>
<span class="s2">#define </span><span class="s1">KHASH_FREE free</span>
<span class="s2">#endif</span>


<span class="s2">#if </span><span class="s1">UINT_MAX == </span><span class="s4">0xffffffff</span><span class="s1">u</span>
<span class="s2">typedef unsigned int </span><span class="s1">khuint32_t;</span>
<span class="s2">typedef signed int </span><span class="s1">khint32_t;</span>
<span class="s1">#elif ULONG_MAX == </span><span class="s4">0xffffffff</span><span class="s1">u</span>
<span class="s2">typedef unsigned long </span><span class="s1">khuint32_t;</span>
<span class="s2">typedef signed long </span><span class="s1">khint32_t;</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">ULONG_MAX == ULLONG_MAX</span>
<span class="s2">typedef unsigned long </span><span class="s1">khuint64_t;</span>
<span class="s2">typedef signed long </span><span class="s1">khint64_t;</span>
<span class="s2">#else</span>
<span class="s2">typedef unsigned long long </span><span class="s1">khuint64_t;</span>
<span class="s2">typedef signed long long </span><span class="s1">khint64_t;</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">UINT_MAX == </span><span class="s4">0xffff</span><span class="s1">u</span>
<span class="s2">typedef unsigned int </span><span class="s1">khuint16_t;</span>
<span class="s2">typedef signed int </span><span class="s1">khint16_t;</span>
<span class="s1">#elif USHRT_MAX == </span><span class="s4">0xffff</span><span class="s1">u</span>
<span class="s2">typedef unsigned short </span><span class="s1">khuint16_t;</span>
<span class="s2">typedef signed short </span><span class="s1">khint16_t;</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">UCHAR_MAX == </span><span class="s4">0xff</span><span class="s1">u</span>
<span class="s2">typedef unsigned char </span><span class="s1">khuint8_t;</span>
<span class="s2">typedef signed char </span><span class="s1">khint8_t;</span>
<span class="s2">#endif</span>

<span class="s2">typedef double </span><span class="s1">khfloat64_t;</span>
<span class="s2">typedef float </span><span class="s1">khfloat32_t;</span>

<span class="s2">typedef </span><span class="s1">khuint32_t khuint_t;</span>
<span class="s2">typedef </span><span class="s1">khuint_t khiter_t;</span>

<span class="s2">#define </span><span class="s1">__ac_isempty(flag, i) ((flag[i&gt;&gt;</span><span class="s4">5</span><span class="s1">]&gt;&gt;(i&amp;</span><span class="s4">0x1f</span><span class="s1">U))&amp;</span><span class="s4">1</span><span class="s1">)</span>
<span class="s2">#define </span><span class="s1">__ac_isdel(flag, i) (</span><span class="s4">0</span><span class="s1">)</span>
<span class="s2">#define </span><span class="s1">__ac_iseither(flag, i) __ac_isempty(flag, i)</span>
<span class="s2">#define </span><span class="s1">__ac_set_isdel_false(flag, i) (</span><span class="s4">0</span><span class="s1">)</span>
<span class="s2">#define </span><span class="s1">__ac_set_isempty_false(flag, i) (flag[i&gt;&gt;</span><span class="s4">5</span><span class="s1">]&amp;=~(</span><span class="s4">1</span><span class="s1">ul&lt;&lt;(i&amp;</span><span class="s4">0x1f</span><span class="s1">U)))</span>
<span class="s2">#define </span><span class="s1">__ac_set_isempty_true(flag, i) (flag[i&gt;&gt;</span><span class="s4">5</span><span class="s1">]|=(</span><span class="s4">1</span><span class="s1">ul&lt;&lt;(i&amp;</span><span class="s4">0x1f</span><span class="s1">U)))</span>
<span class="s2">#define </span><span class="s1">__ac_set_isboth_false(flag, i) __ac_set_isempty_false(flag, i)</span>
<span class="s2">#define </span><span class="s1">__ac_set_isdel_true(flag, i) ((</span><span class="s2">void</span><span class="s1">)</span><span class="s4">0</span><span class="s1">)</span>


<span class="s0">// specializations of https://github.com/aappleby/smhasher/blob/master/src/MurmurHash2.cpp</span>
<span class="s1">khuint32_t PANDAS_INLINE murmur2_32to32(khuint32_t k){</span>
    <span class="s2">const </span><span class="s1">khuint32_t SEED = </span><span class="s4">0xc70f6907</span><span class="s1">UL;</span>
    <span class="s0">// 'm' and 'r' are mixing constants generated offline.</span>
    <span class="s0">// They're not really 'magic', they just happen to work well.</span>
    <span class="s2">const </span><span class="s1">khuint32_t M_32 = </span><span class="s4">0x5bd1e995</span><span class="s1">;</span>
    <span class="s2">const int </span><span class="s1">R_32 = </span><span class="s4">24</span><span class="s1">;</span>

    <span class="s0">// Initialize the hash to a 'random' value</span>
    <span class="s1">khuint32_t h = SEED ^ </span><span class="s4">4</span><span class="s1">;</span>

    <span class="s0">//handle 4 bytes:</span>
    <span class="s1">k *= M_32;</span>
    <span class="s1">k ^= k &gt;&gt; R_32;</span>
    <span class="s1">k *= M_32;</span>

    <span class="s1">h *= M_32;</span>
    <span class="s1">h ^= k;</span>

    <span class="s0">// Do a few final mixes of the hash to ensure the &quot;last few</span>
    <span class="s0">// bytes&quot; are well-incorporated. (Really needed here?)</span>
    <span class="s1">h ^= h &gt;&gt; </span><span class="s4">13</span><span class="s1">;</span>
    <span class="s1">h *= M_32;</span>
    <span class="s1">h ^= h &gt;&gt; </span><span class="s4">15</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">h;</span>
<span class="s1">}</span>

<span class="s0">// it is possible to have a special x64-version, which would need less operations, but</span>
<span class="s0">// using 32bit version always has also some benefits:</span>
<span class="s0">//    - one code for 32bit and 64bit builds</span>
<span class="s0">//    - the same case for 32bit and 64bit builds</span>
<span class="s0">//    - no performance difference could be measured compared to a possible x64-version</span>

<span class="s1">khuint32_t PANDAS_INLINE murmur2_32_32to32(khuint32_t k1, khuint32_t k2){</span>
    <span class="s2">const </span><span class="s1">khuint32_t SEED = </span><span class="s4">0xc70f6907</span><span class="s1">UL;</span>
    <span class="s0">// 'm' and 'r' are mixing constants generated offline.</span>
    <span class="s0">// They're not really 'magic', they just happen to work well.</span>
    <span class="s2">const </span><span class="s1">khuint32_t M_32 = </span><span class="s4">0x5bd1e995</span><span class="s1">;</span>
    <span class="s2">const int </span><span class="s1">R_32 = </span><span class="s4">24</span><span class="s1">;</span>

    <span class="s0">// Initialize the hash to a 'random' value</span>
    <span class="s1">khuint32_t h = SEED ^ </span><span class="s4">4</span><span class="s1">;</span>

    <span class="s0">//handle first 4 bytes:</span>
    <span class="s1">k1 *= M_32;</span>
    <span class="s1">k1 ^= k1 &gt;&gt; R_32;</span>
    <span class="s1">k1 *= M_32;</span>

    <span class="s1">h *= M_32;</span>
    <span class="s1">h ^= k1;</span>

    <span class="s0">//handle second 4 bytes:</span>
    <span class="s1">k2 *= M_32;</span>
    <span class="s1">k2 ^= k2 &gt;&gt; R_32;</span>
    <span class="s1">k2 *= M_32;</span>

    <span class="s1">h *= M_32;</span>
    <span class="s1">h ^= k2;</span>

    <span class="s0">// Do a few final mixes of the hash to ensure the &quot;last few</span>
    <span class="s0">// bytes&quot; are well-incorporated.</span>
    <span class="s1">h ^= h &gt;&gt; </span><span class="s4">13</span><span class="s1">;</span>
    <span class="s1">h *= M_32;</span>
    <span class="s1">h ^= h &gt;&gt; </span><span class="s4">15</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">h;</span>
<span class="s1">}</span>

<span class="s1">khuint32_t PANDAS_INLINE murmur2_64to32(khuint64_t k){</span>
    <span class="s1">khuint32_t k1 = (khuint32_t)k;</span>
    <span class="s1">khuint32_t k2 = (khuint32_t)(k &gt;&gt; </span><span class="s4">32</span><span class="s1">);</span>

    <span class="s2">return </span><span class="s1">murmur2_32_32to32(k1, k2);</span>
<span class="s1">}</span>


<span class="s2">#ifdef </span><span class="s1">KHASH_LINEAR</span>
<span class="s2">#define </span><span class="s1">__ac_inc(k, m) </span><span class="s4">1</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">__ac_inc(k, m) (murmur2_32to32(k) | </span><span class="s4">1</span><span class="s1">) &amp; (m)</span>
<span class="s2">#endif</span>

<span class="s2">#define </span><span class="s1">__ac_fsize(m) ((m) &lt; </span><span class="s4">32</span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: (m)&gt;&gt;</span><span class="s4">5</span><span class="s1">)</span>

<span class="s2">#ifndef </span><span class="s1">kroundup32</span>
<span class="s2">#define </span><span class="s1">kroundup32(x) (--(x), (x)|=(x)&gt;&gt;</span><span class="s4">1</span><span class="s1">, (x)|=(x)&gt;&gt;</span><span class="s4">2</span><span class="s1">, (x)|=(x)&gt;&gt;</span><span class="s4">4</span><span class="s1">, (x)|=(x)&gt;&gt;</span><span class="s4">8</span><span class="s1">, (x)|=(x)&gt;&gt;</span><span class="s4">16</span><span class="s1">, ++(x))</span>
<span class="s2">#endif</span>

<span class="s2">static const double </span><span class="s1">__ac_HASH_UPPER = </span><span class="s4">0.77</span><span class="s1">;</span>

<span class="s2">#define </span><span class="s1">KHASH_DECLARE(name, khkey_t, khval_t)		 					\</span>
	<span class="s2">typedef struct </span><span class="s1">{													\</span>
		<span class="s1">khuint_t n_buckets, size, n_occupied, upper_bound;				\</span>
		<span class="s1">khuint32_t *flags;												\</span>
		<span class="s1">khkey_t *keys;													\</span>
		<span class="s1">khval_t *vals;													\</span>
	<span class="s1">} kh_##name##_t;													\</span>
	<span class="s2">extern </span><span class="s1">kh_##name##_t *kh_init_##name();								\</span>
	<span class="s2">extern void </span><span class="s1">kh_destroy_##name(kh_##name##_t *h);					\</span>
	<span class="s2">extern void </span><span class="s1">kh_clear_##name(kh_##name##_t *h);						\</span>
	<span class="s2">extern </span><span class="s1">khuint_t kh_get_##name(</span><span class="s2">const </span><span class="s1">kh_##name##_t *h, khkey_t key); 	\</span>
	<span class="s2">extern void </span><span class="s1">kh_resize_##name(kh_##name##_t *h, khuint_t new_n_buckets); \</span>
	<span class="s2">extern </span><span class="s1">khuint_t kh_put_##name(kh_##name##_t *h, khkey_t key, </span><span class="s2">int </span><span class="s1">*ret); \</span>
	<span class="s2">extern void </span><span class="s1">kh_del_##name(kh_##name##_t *h, khuint_t x);</span>

<span class="s2">#define </span><span class="s1">KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \</span>
	<span class="s2">typedef struct </span><span class="s1">{													\</span>
		<span class="s1">khuint_t n_buckets, size, n_occupied, upper_bound;				\</span>
		<span class="s1">khuint32_t *flags;												\</span>
		<span class="s1">khkey_t *keys;													\</span>
		<span class="s1">khval_t *vals;													\</span>
	<span class="s1">} kh_##name##_t;													\</span>
	<span class="s1">SCOPE kh_##name##_t *kh_init_##name(</span><span class="s2">void</span><span class="s1">) {								\</span>
		<span class="s2">return </span><span class="s1">(kh_##name##_t*)KHASH_CALLOC(</span><span class="s4">1</span><span class="s1">, </span><span class="s2">sizeof</span><span class="s1">(kh_##name##_t));		\</span>
	<span class="s1">}																	\</span>
	<span class="s1">SCOPE </span><span class="s2">void </span><span class="s1">kh_destroy_##name(kh_##name##_t *h)						\</span>
	<span class="s1">{																	\</span>
		<span class="s2">if </span><span class="s1">(h) {														\</span>
			<span class="s1">KHASH_FREE(h</span><span class="s5">-&gt;</span><span class="s1">keys); KHASH_FREE(h</span><span class="s5">-&gt;</span><span class="s1">flags);								\</span>
			<span class="s1">KHASH_FREE(h</span><span class="s5">-&gt;</span><span class="s1">vals);												\</span>
			<span class="s1">KHASH_FREE(h);													\</span>
		<span class="s1">}																\</span>
	<span class="s1">}																	\</span>
	<span class="s1">SCOPE </span><span class="s2">void </span><span class="s1">kh_clear_##name(kh_##name##_t *h)						\</span>
	<span class="s1">{																	\</span>
		<span class="s2">if </span><span class="s1">(h &amp;&amp; h</span><span class="s5">-&gt;</span><span class="s1">flags) {											\</span>
			<span class="s1">memset(h</span><span class="s5">-&gt;</span><span class="s1">flags, </span><span class="s4">0xaa</span><span class="s1">, __ac_fsize(h</span><span class="s5">-&gt;</span><span class="s1">n_buckets) * </span><span class="s2">sizeof</span><span class="s1">(khuint32_t)); \</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">size = h</span><span class="s5">-&gt;</span><span class="s1">n_occupied = </span><span class="s4">0</span><span class="s1">;								\</span>
		<span class="s1">}																\</span>
	<span class="s1">}																	\</span>
	<span class="s1">SCOPE khuint_t kh_get_##name(</span><span class="s2">const </span><span class="s1">kh_##name##_t *h, khkey_t key) 	\</span>
	<span class="s1">{																	\</span>
		<span class="s2">if </span><span class="s1">(h</span><span class="s5">-&gt;</span><span class="s1">n_buckets) {												\</span>
			<span class="s1">khuint_t inc, k, i, last, mask;								\</span>
			<span class="s1">mask = h</span><span class="s5">-&gt;</span><span class="s1">n_buckets - </span><span class="s4">1</span><span class="s1">;									\</span>
			<span class="s1">k = __hash_func(key); i = k &amp; mask;							\</span>
			<span class="s1">inc = __ac_inc(k, mask); last = i; </span><span class="s0">/* inc==1 for linear probing */ </span><span class="s1">\</span>
			<span class="s2">while </span><span class="s1">(!__ac_isempty(h</span><span class="s5">-&gt;</span><span class="s1">flags, i) &amp;&amp; (__ac_isdel(h</span><span class="s5">-&gt;</span><span class="s1">flags, i) || !__hash_equal(h</span><span class="s5">-&gt;</span><span class="s1">keys[i], key))) { \</span>
				<span class="s1">i = (i + inc) &amp; mask; 									\</span>
				<span class="s2">if </span><span class="s1">(i == last) </span><span class="s2">return </span><span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">n_buckets;						\</span>
			<span class="s1">}															\</span>
			<span class="s2">return </span><span class="s1">__ac_iseither(h</span><span class="s5">-&gt;</span><span class="s1">flags, i)? h</span><span class="s5">-&gt;</span><span class="s1">n_buckets : i;		\</span>
		<span class="s1">} </span><span class="s2">else return </span><span class="s4">0</span><span class="s1">;												\</span>
	<span class="s1">}																	\</span>
	<span class="s1">SCOPE </span><span class="s2">void </span><span class="s1">kh_resize_##name(kh_##name##_t *h, khuint_t new_n_buckets) \</span>
	<span class="s1">{ </span><span class="s0">/* This function uses 0.25*n_bucktes bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ </span><span class="s1">\</span>
		<span class="s1">khuint32_t *new_flags = </span><span class="s4">0</span><span class="s1">;										\</span>
		<span class="s1">khuint_t j = </span><span class="s4">1</span><span class="s1">;													\</span>
		<span class="s1">{																\</span>
			<span class="s1">kroundup32(new_n_buckets); 									\</span>
			<span class="s2">if </span><span class="s1">(new_n_buckets &lt; </span><span class="s4">4</span><span class="s1">) new_n_buckets = </span><span class="s4">4</span><span class="s1">;					\</span>
			<span class="s2">if </span><span class="s1">(h</span><span class="s5">-&gt;</span><span class="s1">size &gt;= (khuint_t)(new_n_buckets * __ac_HASH_UPPER + </span><span class="s4">0.5</span><span class="s1">)) j = </span><span class="s4">0</span><span class="s1">;	</span><span class="s0">/* requested size is too small */ </span><span class="s1">\</span>
			<span class="s2">else </span><span class="s1">{ </span><span class="s0">/* hash table size to be changed (shrink or expand); rehash */ </span><span class="s1">\</span>
				<span class="s1">new_flags = (khuint32_t*)KHASH_MALLOC(__ac_fsize(new_n_buckets) * </span><span class="s2">sizeof</span><span class="s1">(khuint32_t));	\</span>
				<span class="s1">memset(new_flags, </span><span class="s4">0xff</span><span class="s1">, __ac_fsize(new_n_buckets) * </span><span class="s2">sizeof</span><span class="s1">(khuint32_t)); \</span>
				<span class="s2">if </span><span class="s1">(h</span><span class="s5">-&gt;</span><span class="s1">n_buckets &lt; new_n_buckets) {	</span><span class="s0">/* expand */		</span><span class="s1">\</span>
					<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">keys = (khkey_t*)KHASH_REALLOC(h</span><span class="s5">-&gt;</span><span class="s1">keys, new_n_buckets * </span><span class="s2">sizeof</span><span class="s1">(khkey_t)); \</span>
					<span class="s2">if </span><span class="s1">(kh_is_map) h</span><span class="s5">-&gt;</span><span class="s1">vals = (khval_t*)KHASH_REALLOC(h</span><span class="s5">-&gt;</span><span class="s1">vals, new_n_buckets * </span><span class="s2">sizeof</span><span class="s1">(khval_t)); \</span>
				<span class="s1">} </span><span class="s0">/* otherwise shrink */								</span><span class="s1">\</span>
			<span class="s1">}															\</span>
		<span class="s1">}																\</span>
		<span class="s2">if </span><span class="s1">(j) { </span><span class="s0">/* rehashing is needed */								</span><span class="s1">\</span>
			<span class="s2">for </span><span class="s1">(j = </span><span class="s4">0</span><span class="s1">; j != h</span><span class="s5">-&gt;</span><span class="s1">n_buckets; ++j) {						\</span>
				<span class="s2">if </span><span class="s1">(__ac_iseither(h</span><span class="s5">-&gt;</span><span class="s1">flags, j) == </span><span class="s4">0</span><span class="s1">) {					\</span>
					<span class="s1">khkey_t key = h</span><span class="s5">-&gt;</span><span class="s1">keys[j];							\</span>
					<span class="s1">khval_t val;										\</span>
					<span class="s1">khuint_t new_mask;									\</span>
					<span class="s1">new_mask = new_n_buckets - </span><span class="s4">1</span><span class="s1">; 						\</span>
					<span class="s2">if </span><span class="s1">(kh_is_map) val = h</span><span class="s5">-&gt;</span><span class="s1">vals[j];					\</span>
					<span class="s1">__ac_set_isempty_true(h</span><span class="s5">-&gt;</span><span class="s1">flags, j);					\</span>
					<span class="s2">while </span><span class="s1">(</span><span class="s4">1</span><span class="s1">) { </span><span class="s0">/* kick-out process; sort of like in Cuckoo hashing */ </span><span class="s1">\</span>
						<span class="s1">khuint_t inc, k, i;								\</span>
						<span class="s1">k = __hash_func(key);							\</span>
						<span class="s1">i = k &amp; new_mask;								\</span>
						<span class="s1">inc = __ac_inc(k, new_mask);					\</span>
						<span class="s2">while </span><span class="s1">(!__ac_isempty(new_flags, i)) i = (i + inc) &amp; new_mask; \</span>
						<span class="s1">__ac_set_isempty_false(new_flags, i);			\</span>
						<span class="s2">if </span><span class="s1">(i &lt; h</span><span class="s5">-&gt;</span><span class="s1">n_buckets &amp;&amp; __ac_iseither(h</span><span class="s5">-&gt;</span><span class="s1">flags, i) == </span><span class="s4">0</span><span class="s1">) { </span><span class="s0">/* kick out the existing element */ </span><span class="s1">\</span>
							<span class="s1">{ khkey_t tmp = h</span><span class="s5">-&gt;</span><span class="s1">keys[i]; h</span><span class="s5">-&gt;</span><span class="s1">keys[i] = key; key = tmp; } \</span>
							<span class="s2">if </span><span class="s1">(kh_is_map) { khval_t tmp = h</span><span class="s5">-&gt;</span><span class="s1">vals[i]; h</span><span class="s5">-&gt;</span><span class="s1">vals[i] = val; val = tmp; } \</span>
							<span class="s1">__ac_set_isempty_true(h</span><span class="s5">-&gt;</span><span class="s1">flags, i); </span><span class="s0">/* mark it as deleted in the old hash table */ </span><span class="s1">\</span>
						<span class="s1">} </span><span class="s2">else </span><span class="s1">{ </span><span class="s0">/* write the element and jump out of the loop */ </span><span class="s1">\</span>
							<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">keys[i] = key;							\</span>
							<span class="s2">if </span><span class="s1">(kh_is_map) h</span><span class="s5">-&gt;</span><span class="s1">vals[i] = val;			\</span>
							<span class="s2">break</span><span class="s1">;										\</span>
						<span class="s1">}												\</span>
					<span class="s1">}													\</span>
				<span class="s1">}														\</span>
			<span class="s1">}															\</span>
			<span class="s2">if </span><span class="s1">(h</span><span class="s5">-&gt;</span><span class="s1">n_buckets &gt; new_n_buckets) { </span><span class="s0">/* shrink the hash table */ </span><span class="s1">\</span>
				<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">keys = (khkey_t*)KHASH_REALLOC(h</span><span class="s5">-&gt;</span><span class="s1">keys, new_n_buckets * </span><span class="s2">sizeof</span><span class="s1">(khkey_t)); \</span>
				<span class="s2">if </span><span class="s1">(kh_is_map) h</span><span class="s5">-&gt;</span><span class="s1">vals = (khval_t*)KHASH_REALLOC(h</span><span class="s5">-&gt;</span><span class="s1">vals, new_n_buckets * </span><span class="s2">sizeof</span><span class="s1">(khval_t)); \</span>
			<span class="s1">}															\</span>
			<span class="s1">KHASH_FREE(h</span><span class="s5">-&gt;</span><span class="s1">flags); </span><span class="s0">/* free the working space */				</span><span class="s1">\</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">flags = new_flags;										\</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">n_buckets = new_n_buckets;								\</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">n_occupied = h</span><span class="s5">-&gt;</span><span class="s1">size;									\</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">upper_bound = (khuint_t)(h</span><span class="s5">-&gt;</span><span class="s1">n_buckets * __ac_HASH_UPPER + </span><span class="s4">0.5</span><span class="s1">); \</span>
		<span class="s1">}																\</span>
	<span class="s1">}																	\</span>
	<span class="s1">SCOPE khuint_t kh_put_##name(kh_##name##_t *h, khkey_t key, </span><span class="s2">int </span><span class="s1">*ret) \</span>
	<span class="s1">{																	\</span>
		<span class="s1">khuint_t x;														\</span>
		<span class="s2">if </span><span class="s1">(h</span><span class="s5">-&gt;</span><span class="s1">n_occupied &gt;= h</span><span class="s5">-&gt;</span><span class="s1">upper_bound) { </span><span class="s0">/* update the hash table */ </span><span class="s1">\</span>
			<span class="s2">if </span><span class="s1">(h</span><span class="s5">-&gt;</span><span class="s1">n_buckets &gt; (h</span><span class="s5">-&gt;</span><span class="s1">size&lt;&lt;</span><span class="s4">1</span><span class="s1">)) kh_resize_##name(h, h</span><span class="s5">-&gt;</span><span class="s1">n_buckets - </span><span class="s4">1</span><span class="s1">); </span><span class="s0">/* clear &quot;deleted&quot; elements */ </span><span class="s1">\</span>
			<span class="s2">else </span><span class="s1">kh_resize_##name(h, h</span><span class="s5">-&gt;</span><span class="s1">n_buckets + </span><span class="s4">1</span><span class="s1">); </span><span class="s0">/* expand the hash table */ </span><span class="s1">\</span>
		<span class="s1">} </span><span class="s0">/* TODO: to implement automatically shrinking; resize() already support shrinking */ </span><span class="s1">\</span>
		<span class="s1">{																\</span>
			<span class="s1">khuint_t inc, k, i, site, last, mask = h</span><span class="s5">-&gt;</span><span class="s1">n_buckets - </span><span class="s4">1</span><span class="s1">;		\</span>
			<span class="s1">x = site = h</span><span class="s5">-&gt;</span><span class="s1">n_buckets; k = __hash_func(key); i = k &amp; mask; \</span>
			<span class="s2">if </span><span class="s1">(__ac_isempty(h</span><span class="s5">-&gt;</span><span class="s1">flags, i)) x = i; </span><span class="s0">/* for speed up */	</span><span class="s1">\</span>
			<span class="s2">else </span><span class="s1">{														\</span>
				<span class="s1">inc = __ac_inc(k, mask); last = i;						\</span>
				<span class="s2">while </span><span class="s1">(!__ac_isempty(h</span><span class="s5">-&gt;</span><span class="s1">flags, i) &amp;&amp; (__ac_isdel(h</span><span class="s5">-&gt;</span><span class="s1">flags, i) || !__hash_equal(h</span><span class="s5">-&gt;</span><span class="s1">keys[i], key))) { \</span>
					<span class="s2">if </span><span class="s1">(__ac_isdel(h</span><span class="s5">-&gt;</span><span class="s1">flags, i)) site = i;				\</span>
					<span class="s1">i = (i + inc) &amp; mask; 								\</span>
					<span class="s2">if </span><span class="s1">(i == last) { x = site; </span><span class="s2">break</span><span class="s1">; }					\</span>
				<span class="s1">}														\</span>
				<span class="s2">if </span><span class="s1">(x == h</span><span class="s5">-&gt;</span><span class="s1">n_buckets) {								\</span>
					<span class="s2">if </span><span class="s1">(__ac_isempty(h</span><span class="s5">-&gt;</span><span class="s1">flags, i) &amp;&amp; site != h</span><span class="s5">-&gt;</span><span class="s1">n_buckets) x = site; \</span>
					<span class="s2">else </span><span class="s1">x = i;											\</span>
				<span class="s1">}														\</span>
			<span class="s1">}															\</span>
		<span class="s1">}																\</span>
		<span class="s2">if </span><span class="s1">(__ac_isempty(h</span><span class="s5">-&gt;</span><span class="s1">flags, x)) { </span><span class="s0">/* not present at all */		</span><span class="s1">\</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">keys[x] = key;											\</span>
			<span class="s1">__ac_set_isboth_false(h</span><span class="s5">-&gt;</span><span class="s1">flags, x);							\</span>
			<span class="s1">++h</span><span class="s5">-&gt;</span><span class="s1">size; ++h</span><span class="s5">-&gt;</span><span class="s1">n_occupied;									\</span>
			<span class="s1">*ret = </span><span class="s4">1</span><span class="s1">;													\</span>
		<span class="s1">} </span><span class="s2">else if </span><span class="s1">(__ac_isdel(h</span><span class="s5">-&gt;</span><span class="s1">flags, x)) { </span><span class="s0">/* deleted */				</span><span class="s1">\</span>
			<span class="s1">h</span><span class="s5">-&gt;</span><span class="s1">keys[x] = key;											\</span>
			<span class="s1">__ac_set_isboth_false(h</span><span class="s5">-&gt;</span><span class="s1">flags, x);							\</span>
			<span class="s1">++h</span><span class="s5">-&gt;</span><span class="s1">size;													\</span>
			<span class="s1">*ret = </span><span class="s4">2</span><span class="s1">;													\</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">*ret = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">/* Don't touch h-&gt;keys[x] if present and not deleted */ </span><span class="s1">\</span>
		<span class="s2">return </span><span class="s1">x;														\</span>
	<span class="s1">}																	\</span>
	<span class="s1">SCOPE </span><span class="s2">void </span><span class="s1">kh_del_##name(kh_##name##_t *h, khuint_t x)				\</span>
	<span class="s1">{																	\</span>
		<span class="s2">if </span><span class="s1">(x != h</span><span class="s5">-&gt;</span><span class="s1">n_buckets &amp;&amp; !__ac_iseither(h</span><span class="s5">-&gt;</span><span class="s1">flags, x)) {			\</span>
			<span class="s1">__ac_set_isdel_true(h</span><span class="s5">-&gt;</span><span class="s1">flags, x);							\</span>
			<span class="s1">--h</span><span class="s5">-&gt;</span><span class="s1">size;													\</span>
		<span class="s1">}																\</span>
	<span class="s1">}</span>

<span class="s2">#define </span><span class="s1">KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \</span>
	<span class="s1">KHASH_INIT2(name, PANDAS_INLINE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)</span>

<span class="s0">/* --- BEGIN OF HASH FUNCTIONS --- */</span>

<span class="s0">/*! @function 
  @abstract     Integer hash function 
  @param  key   The integer [khuint32_t] 
  @return       The hash value [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_int_hash_func(key) (khuint32_t)(key)</span>
<span class="s0">/*! @function 
  @abstract     Integer comparison function 
 */</span>
<span class="s2">#define </span><span class="s1">kh_int_hash_equal(a, b) ((a) == (b))</span>
<span class="s0">/*! @function 
  @abstract     64-bit integer hash function 
  @param  key   The integer [khuint64_t] 
  @return       The hash value [khuint_t] 
 */</span>
<span class="s1">PANDAS_INLINE khuint_t kh_int64_hash_func(khuint64_t key)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">(khuint_t)((key)&gt;&gt;</span><span class="s4">33</span><span class="s1">^(key)^(key)&lt;&lt;</span><span class="s4">11</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">/*! @function 
  @abstract     64-bit integer comparison function 
 */</span>
<span class="s2">#define </span><span class="s1">kh_int64_hash_equal(a, b) ((a) == (b))</span>

<span class="s0">/*! @function 
  @abstract     const char* hash function 
  @param  s     Pointer to a null terminated string 
  @return       The hash value 
 */</span>
<span class="s1">PANDAS_INLINE khuint_t __ac_X31_hash_string(</span><span class="s2">const char </span><span class="s1">*s)</span>
<span class="s1">{</span>
	<span class="s1">khuint_t h = *s;</span>
	<span class="s2">if </span><span class="s1">(h) </span><span class="s2">for </span><span class="s1">(++s ; *s; ++s) h = (h &lt;&lt; </span><span class="s4">5</span><span class="s1">) - h + *s;</span>
	<span class="s2">return </span><span class="s1">h;</span>
<span class="s1">}</span>
<span class="s0">/*! @function 
  @abstract     Another interface to const char* hash function 
  @param  key   Pointer to a null terminated string [const char*] 
  @return       The hash value [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_str_hash_func(key) __ac_X31_hash_string(key)</span>
<span class="s0">/*! @function 
  @abstract     Const char* comparison function 
 */</span>
<span class="s2">#define </span><span class="s1">kh_str_hash_equal(a, b) (strcmp(a, b) == </span><span class="s4">0</span><span class="s1">)</span>

<span class="s1">PANDAS_INLINE khuint_t __ac_Wang_hash(khuint_t key)</span>
<span class="s1">{</span>
    <span class="s1">key += ~(key &lt;&lt; </span><span class="s4">15</span><span class="s1">);</span>
    <span class="s1">key ^=  (key &gt;&gt; </span><span class="s4">10</span><span class="s1">);</span>
    <span class="s1">key +=  (key &lt;&lt; </span><span class="s4">3</span><span class="s1">);</span>
    <span class="s1">key ^=  (key &gt;&gt; </span><span class="s4">6</span><span class="s1">);</span>
    <span class="s1">key += ~(key &lt;&lt; </span><span class="s4">11</span><span class="s1">);</span>
    <span class="s1">key ^=  (key &gt;&gt; </span><span class="s4">16</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">key;</span>
<span class="s1">}</span>
<span class="s2">#define </span><span class="s1">kh_int_hash_func2(k) __ac_Wang_hash((khuint_t)key)</span>

<span class="s0">/* --- END OF HASH FUNCTIONS --- */</span>

<span class="s0">/* Other convenient macros... */</span>

<span class="s0">/*! 
  @abstract Type of the hash table. 
  @param  name  Name of the hash table [symbol] 
 */</span>
<span class="s2">#define </span><span class="s1">khash_t(name) kh_##name##_t</span>

<span class="s0">/*! @function 
  @abstract     Initiate a hash table. 
  @param  name  Name of the hash table [symbol] 
  @return       Pointer to the hash table [khash_t(name)*] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_init(name) kh_init_##name(</span><span class="s2">void</span><span class="s1">)</span>

<span class="s0">/*! @function 
  @abstract     Destroy a hash table. 
  @param  name  Name of the hash table [symbol] 
  @param  h     Pointer to the hash table [khash_t(name)*] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_destroy(name, h) kh_destroy_##name(h)</span>

<span class="s0">/*! @function 
  @abstract     Reset a hash table without deallocating memory. 
  @param  name  Name of the hash table [symbol] 
  @param  h     Pointer to the hash table [khash_t(name)*] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_clear(name, h) kh_clear_##name(h)</span>

<span class="s0">/*! @function 
  @abstract     Resize a hash table. 
  @param  name  Name of the hash table [symbol] 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  s     New size [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_resize(name, h, s) kh_resize_##name(h, s)</span>

<span class="s0">/*! @function 
  @abstract     Insert a key to the hash table. 
  @param  name  Name of the hash table [symbol] 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  k     Key [type of keys] 
  @param  r     Extra return code: 0 if the key is present in the hash table; 
                1 if the bucket is empty (never used); 2 if the element in 
                the bucket has been deleted [int*] 
  @return       Iterator to the inserted element [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_put(name, h, k, r) kh_put_##name(h, k, r)</span>

<span class="s0">/*! @function 
  @abstract     Retrieve a key from the hash table. 
  @param  name  Name of the hash table [symbol] 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  k     Key [type of keys] 
  @return       Iterator to the found element, or kh_end(h) is the element is absent [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_get(name, h, k) kh_get_##name(h, k)</span>

<span class="s0">/*! @function 
  @abstract     Remove a key from the hash table. 
  @param  name  Name of the hash table [symbol] 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  k     Iterator to the element to be deleted [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_del(name, h, k) kh_del_##name(h, k)</span>

<span class="s0">/*! @function 
  @abstract     Test whether a bucket contains data. 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  x     Iterator to the bucket [khuint_t] 
  @return       1 if containing data; 0 otherwise [int] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_exist(h, x) (!__ac_iseither((h)</span><span class="s5">-&gt;</span><span class="s1">flags, (x)))</span>

<span class="s0">/*! @function 
  @abstract     Get key given an iterator 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  x     Iterator to the bucket [khuint_t] 
  @return       Key [type of keys] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_key(h, x) ((h)</span><span class="s5">-&gt;</span><span class="s1">keys[x])</span>

<span class="s0">/*! @function 
  @abstract     Get value given an iterator 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @param  x     Iterator to the bucket [khuint_t] 
  @return       Value [type of values] 
  @discussion   For hash sets, calling this results in segfault. 
 */</span>
<span class="s2">#define </span><span class="s1">kh_val(h, x) ((h)</span><span class="s5">-&gt;</span><span class="s1">vals[x])</span>

<span class="s0">/*! @function 
  @abstract     Alias of kh_val() 
 */</span>
<span class="s2">#define </span><span class="s1">kh_value(h, x) ((h)</span><span class="s5">-&gt;</span><span class="s1">vals[x])</span>

<span class="s0">/*! @function 
  @abstract     Get the start iterator 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @return       The start iterator [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_begin(h) (khuint_t)(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">/*! @function 
  @abstract     Get the end iterator 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @return       The end iterator [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_end(h) ((h)</span><span class="s5">-&gt;</span><span class="s1">n_buckets)</span>

<span class="s0">/*! @function 
  @abstract     Get the number of elements in the hash table 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @return       Number of elements in the hash table [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_size(h) ((h)</span><span class="s5">-&gt;</span><span class="s1">size)</span>

<span class="s0">/*! @function 
  @abstract     Get the number of buckets in the hash table 
  @param  h     Pointer to the hash table [khash_t(name)*] 
  @return       Number of buckets in the hash table [khuint_t] 
 */</span>
<span class="s2">#define </span><span class="s1">kh_n_buckets(h) ((h)</span><span class="s5">-&gt;</span><span class="s1">n_buckets)</span>

<span class="s0">/* More convenient interfaces */</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash set containing integer keys 
  @param  name  Name of the hash table [symbol] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_SET_INIT_INT(name)										\</span>
	<span class="s1">KHASH_INIT(name, khint32_t, </span><span class="s2">char</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing integer keys 
  @param  name  Name of the hash table [symbol] 
  @param  khval_t  Type of values [type] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_INT(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khint32_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>

<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_UINT(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khuint32_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing 64-bit integer keys 
  @param  name  Name of the hash table [symbol] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_SET_INIT_UINT64(name)										\</span>
	<span class="s1">KHASH_INIT(name, khuint64_t, </span><span class="s2">char</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, kh_int64_hash_func, kh_int64_hash_equal)</span>

<span class="s2">#define </span><span class="s1">KHASH_SET_INIT_INT64(name)										\</span>
	<span class="s1">KHASH_INIT(name, khint64_t, </span><span class="s2">char</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, kh_int64_hash_func, kh_int64_hash_equal)</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing 64-bit integer keys 
  @param  name  Name of the hash table [symbol] 
  @param  khval_t  Type of values [type] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_UINT64(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khuint64_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int64_hash_func, kh_int64_hash_equal)</span>

<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_INT64(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khint64_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int64_hash_func, kh_int64_hash_equal)</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing 16bit-integer keys 
  @param  name  Name of the hash table [symbol] 
  @param  khval_t  Type of values [type] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_INT16(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khint16_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>

<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_UINT16(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khuint16_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing 8bit-integer keys 
  @param  name  Name of the hash table [symbol] 
  @param  khval_t  Type of values [type] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_INT8(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khint8_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>

<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_UINT8(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khuint8_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_int_hash_func, kh_int_hash_equal)</span>



<span class="s2">typedef const char </span><span class="s1">*kh_cstr_t;</span>
<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing const char* keys 
  @param  name  Name of the hash table [symbol] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_SET_INIT_STR(name)										\</span>
	<span class="s1">KHASH_INIT(name, kh_cstr_t, </span><span class="s2">char</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, kh_str_hash_func, kh_str_hash_equal)</span>

<span class="s0">/*! @function 
  @abstract     Instantiate a hash map containing const char* keys 
  @param  name  Name of the hash table [symbol] 
  @param  khval_t  Type of values [type] 
 */</span>
<span class="s2">#define </span><span class="s1">KHASH_MAP_INIT_STR(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, kh_cstr_t, khval_t, </span><span class="s4">1</span><span class="s1">, kh_str_hash_func, kh_str_hash_equal)</span>


<span class="s2">#define </span><span class="s1">kh_exist_str(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_float64(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_uint64(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_int64(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_float32(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_int32(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_uint32(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_int16(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_uint16(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_int8(h, k) (kh_exist(h, k))</span>
<span class="s2">#define </span><span class="s1">kh_exist_uint8(h, k) (kh_exist(h, k))</span>

<span class="s1">KHASH_MAP_INIT_STR(str, size_t)</span>
<span class="s1">KHASH_MAP_INIT_INT(int32, size_t)</span>
<span class="s1">KHASH_MAP_INIT_UINT(uint32, size_t)</span>
<span class="s1">KHASH_MAP_INIT_INT64(int64, size_t)</span>
<span class="s1">KHASH_MAP_INIT_UINT64(uint64, size_t)</span>
<span class="s1">KHASH_MAP_INIT_INT16(int16, size_t)</span>
<span class="s1">KHASH_MAP_INIT_UINT16(uint16, size_t)</span>
<span class="s1">KHASH_MAP_INIT_INT8(int8, size_t)</span>
<span class="s1">KHASH_MAP_INIT_UINT8(uint8, size_t)</span>


<span class="s2">#endif </span><span class="s0">/* __AC_KHASH_H */</span>
</pre>
</body>
</html>