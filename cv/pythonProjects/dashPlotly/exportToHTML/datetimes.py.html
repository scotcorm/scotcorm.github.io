<html>
<head>
<title>datetimes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
datetimes.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s0">,</span>
    <span class="s1">datetime</span><span class="s0">,</span>
    <span class="s1">time</span><span class="s0">,</span>
    <span class="s1">timedelta</span><span class="s0">,</span>
    <span class="s1">tzinfo</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">Literal</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s0">,</span>
    <span class="s1">Period</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">index </span><span class="s0">as </span><span class="s1">libindex</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Resolution</span><span class="s0">,</span>
    <span class="s1">timezones</span><span class="s0">,</span>
    <span class="s1">to_offset</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s0">import </span><span class="s1">prefix_mapping</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Dtype</span><span class="s0">,</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">cache_readonly</span><span class="s0">,</span>
    <span class="s1">doc</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DT64NS_DTYPE</span><span class="s0">,</span>
    <span class="s1">is_datetime64_dtype</span><span class="s0">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">is_valid_na_for_dtype</span>

<span class="s0">from </span><span class="s1">pandas.core.arrays.datetimes </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
    <span class="s1">tz_to_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.core.common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">get_unanimous_names</span><span class="s0">,</span>
    <span class="s1">maybe_extract_name</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.datetimelike </span><span class="s0">import </span><span class="s1">DatetimeTimedeltaMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.extension </span><span class="s0">import </span><span class="s1">inherit_names</span>
<span class="s0">from </span><span class="s1">pandas.core.tools.times </span><span class="s0">import </span><span class="s1">to_time</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">DataFrame</span><span class="s0">,</span>
        <span class="s1">Float64Index</span><span class="s0">,</span>
        <span class="s1">PeriodIndex</span><span class="s0">,</span>
        <span class="s1">TimedeltaIndex</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_new_DatetimeIndex(cls</span><span class="s0">, </span><span class="s1">d):</span>
    <span class="s2">&quot;&quot;&quot; 
    This is called upon unpickling, rather than the default which doesn't 
    have arguments and breaks __new__ 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s3">&quot;data&quot; </span><span class="s0">in </span><span class="s1">d </span><span class="s0">and not </span><span class="s1">isinstance(d[</span><span class="s3">&quot;data&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">DatetimeIndex):</span>
        <span class="s4"># Avoid need to verify integrity by calling simple_new directly</span>
        <span class="s1">data = d.pop(</span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">DatetimeArray):</span>
            <span class="s4"># For backward compat with older pickles, we may need to construct</span>
            <span class="s4">#  a DatetimeArray to adapt to the newer _simple_new signature</span>
            <span class="s1">tz = d.pop(</span><span class="s3">&quot;tz&quot;</span><span class="s1">)</span>
            <span class="s1">freq = d.pop(</span><span class="s3">&quot;freq&quot;</span><span class="s1">)</span>
            <span class="s1">dta = DatetimeArray._simple_new(data</span><span class="s0">, </span><span class="s1">dtype=tz_to_dtype(tz)</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dta = data</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;tz&quot;</span><span class="s0">, </span><span class="s3">&quot;freq&quot;</span><span class="s1">]:</span>
                <span class="s4"># These are already stored in our DatetimeArray; if they are</span>
                <span class="s4">#  also in the pickle and don't match, we have a problem.</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                    <span class="s0">assert </span><span class="s1">d[key] == getattr(dta</span><span class="s0">, </span><span class="s1">key)</span>
                    <span class="s1">d.pop(key)</span>
        <span class="s1">result = cls._simple_new(dta</span><span class="s0">, </span><span class="s1">**d)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s4"># TODO: If we knew what was going in to **d, we might be able to</span>
            <span class="s4">#  go through _simple_new instead</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">result = cls.__new__(cls</span><span class="s0">, </span><span class="s1">**d)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@inherit_names(</span>
    <span class="s1">DatetimeArray._field_ops</span>
    <span class="s1">+ [</span>
        <span class="s1">method</span>
        <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">DatetimeArray._datetimelike_methods</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">(</span><span class="s3">&quot;tz_localize&quot;</span><span class="s0">, </span><span class="s3">&quot;tz_convert&quot;</span><span class="s1">)</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
    <span class="s1">wrap=</span><span class="s0">True,</span>
<span class="s1">)</span>
<span class="s1">@inherit_names([</span><span class="s3">&quot;is_normalized&quot;</span><span class="s0">, </span><span class="s3">&quot;_resolution_obj&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">DatetimeArray</span><span class="s0">, </span><span class="s1">cache=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s1">@inherit_names(</span>
    <span class="s1">[</span>
        <span class="s3">&quot;tz&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;tzinfo&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;dtype&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;to_pydatetime&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_format_native_types&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;date&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;time&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;timetz&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;std&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">+ DatetimeArray._bool_ops</span><span class="s0">,</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">class </span><span class="s1">DatetimeIndex(DatetimeTimedeltaMixin):</span>
    <span class="s2">&quot;&quot;&quot; 
    Immutable ndarray-like of datetime64 data. 
 
    Represented internally as int64, and which can be boxed to Timestamp objects 
    that are subclasses of datetime and carry metadata. 
 
    Parameters 
    ---------- 
    data : array-like (1-dimensional), optional 
        Optional datetime-like data to construct index with. 
    freq : str or pandas offset object, optional 
        One of pandas date offset strings or corresponding objects. The string 
        'infer' can be passed in order to set the frequency of the index as the 
        inferred frequency upon creation. 
    tz : pytz.timezone or dateutil.tz.tzfile or datetime.tzinfo or str 
        Set the Timezone of the data. 
    normalize : bool, default False 
        Normalize start/end dates to midnight before generating date range. 
    closed : {'left', 'right'}, optional 
        Set whether to include `start` and `end` that are on the 
        boundary. The default includes boundary points on either end. 
    ambiguous : 'infer', bool-ndarray, 'NaT', default 'raise' 
        When clocks moved backward due to DST, ambiguous times may arise. 
        For example in Central European Time (UTC+01), when going from 03:00 
        DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC 
        and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter 
        dictates how ambiguous times should be handled. 
 
        - 'infer' will attempt to infer fall dst-transition hours based on 
          order 
        - bool-ndarray where True signifies a DST time, False signifies a 
          non-DST time (note that this flag is only applicable for ambiguous 
          times) 
        - 'NaT' will return NaT where there are ambiguous times 
        - 'raise' will raise an AmbiguousTimeError if there are ambiguous times. 
    dayfirst : bool, default False 
        If True, parse dates in `data` with the day first order. 
    yearfirst : bool, default False 
        If True parse dates in `data` with the year first order. 
    dtype : numpy.dtype or DatetimeTZDtype or str, default None 
        Note that the only NumPy dtype allowed is ‘datetime64[ns]’. 
    copy : bool, default False 
        Make a copy of input ndarray. 
    name : label, default None 
        Name to be stored in the index. 
 
    Attributes 
    ---------- 
    year 
    month 
    day 
    hour 
    minute 
    second 
    microsecond 
    nanosecond 
    date 
    time 
    timetz 
    dayofyear 
    day_of_year 
    weekofyear 
    week 
    dayofweek 
    day_of_week 
    weekday 
    quarter 
    tz 
    freq 
    freqstr 
    is_month_start 
    is_month_end 
    is_quarter_start 
    is_quarter_end 
    is_year_start 
    is_year_end 
    is_leap_year 
    inferred_freq 
 
    Methods 
    ------- 
    normalize 
    strftime 
    snap 
    tz_convert 
    tz_localize 
    round 
    floor 
    ceil 
    to_period 
    to_perioddelta 
    to_pydatetime 
    to_series 
    to_frame 
    month_name 
    day_name 
    mean 
    std 
 
    See Also 
    -------- 
    Index : The base pandas Index type. 
    TimedeltaIndex : Index of timedelta64 data. 
    PeriodIndex : Index of Period data. 
    to_datetime : Convert argument to datetime. 
    date_range : Create a fixed-frequency DatetimeIndex. 
 
    Notes 
    ----- 
    To learn more about the frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
    &quot;&quot;&quot;</span>

    <span class="s1">_typ = </span><span class="s3">&quot;datetimeindex&quot;</span>

    <span class="s1">_data_cls = DatetimeArray</span>
    <span class="s1">_engine_type = libindex.DatetimeEngine</span>
    <span class="s1">_supports_partial_string_indexing = </span><span class="s0">True</span>

    <span class="s1">_data: DatetimeArray</span>
    <span class="s1">inferred_freq: str | </span><span class="s0">None</span>
    <span class="s1">tz: tzinfo | </span><span class="s0">None</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># methods that dispatch to DatetimeArray and wrap result</span>

    <span class="s1">@doc(DatetimeArray.strftime)</span>
    <span class="s0">def </span><span class="s1">strftime(self</span><span class="s0">, </span><span class="s1">date_format) -&gt; Index:</span>
        <span class="s1">arr = self._data.strftime(date_format)</span>
        <span class="s0">return </span><span class="s1">Index(arr</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@doc(DatetimeArray.tz_convert)</span>
    <span class="s0">def </span><span class="s1">tz_convert(self</span><span class="s0">, </span><span class="s1">tz) -&gt; DatetimeIndex:</span>
        <span class="s1">arr = self._data.tz_convert(tz)</span>
        <span class="s0">return </span><span class="s1">type(self)._simple_new(arr</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@doc(DatetimeArray.tz_localize)</span>
    <span class="s0">def </span><span class="s1">tz_localize(self</span><span class="s0">, </span><span class="s1">tz</span><span class="s0">, </span><span class="s1">ambiguous=</span><span class="s3">&quot;raise&quot;</span><span class="s0">, </span><span class="s1">nonexistent=</span><span class="s3">&quot;raise&quot;</span><span class="s1">) -&gt; DatetimeIndex:</span>
        <span class="s1">arr = self._data.tz_localize(tz</span><span class="s0">, </span><span class="s1">ambiguous</span><span class="s0">, </span><span class="s1">nonexistent)</span>
        <span class="s0">return </span><span class="s1">type(self)._simple_new(arr</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@doc(DatetimeArray.to_period)</span>
    <span class="s0">def </span><span class="s1">to_period(self</span><span class="s0">, </span><span class="s1">freq=</span><span class="s0">None</span><span class="s1">) -&gt; PeriodIndex:</span>
        <span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">PeriodIndex</span>

        <span class="s1">arr = self._data.to_period(freq)</span>
        <span class="s0">return </span><span class="s1">PeriodIndex._simple_new(arr</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@doc(DatetimeArray.to_perioddelta)</span>
    <span class="s0">def </span><span class="s1">to_perioddelta(self</span><span class="s0">, </span><span class="s1">freq) -&gt; TimedeltaIndex:</span>
        <span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">TimedeltaIndex</span>

        <span class="s1">arr = self._data.to_perioddelta(freq)</span>
        <span class="s0">return </span><span class="s1">TimedeltaIndex._simple_new(arr</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@doc(DatetimeArray.to_julian_date)</span>
    <span class="s0">def </span><span class="s1">to_julian_date(self) -&gt; Float64Index:</span>
        <span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">Float64Index</span>

        <span class="s1">arr = self._data.to_julian_date()</span>
        <span class="s0">return </span><span class="s1">Float64Index._simple_new(arr</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@doc(DatetimeArray.isocalendar)</span>
    <span class="s0">def </span><span class="s1">isocalendar(self) -&gt; DataFrame:</span>
        <span class="s1">df = self._data.isocalendar()</span>
        <span class="s0">return </span><span class="s1">df.set_index(self)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Constructors</span>

    <span class="s0">def </span><span class="s1">__new__(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">data=</span><span class="s0">None,</span>
        <span class="s1">freq=lib.no_default</span><span class="s0">,</span>
        <span class="s1">tz=</span><span class="s0">None,</span>
        <span class="s1">normalize: bool = </span><span class="s0">False,</span>
        <span class="s1">closed=</span><span class="s0">None,</span>
        <span class="s1">ambiguous=</span><span class="s3">&quot;raise&quot;</span><span class="s0">,</span>
        <span class="s1">dayfirst: bool = </span><span class="s0">False,</span>
        <span class="s1">yearfirst: bool = </span><span class="s0">False,</span>
        <span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">name: Hashable = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; DatetimeIndex:</span>

        <span class="s0">if </span><span class="s1">is_scalar(data):</span>
            <span class="s0">raise </span><span class="s1">cls._scalar_data_error(data)</span>

        <span class="s4"># - Cases checked above all return/raise before reaching here - #</span>

        <span class="s1">name = maybe_extract_name(name</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">cls)</span>

        <span class="s1">dtarr = DatetimeArray._from_sequence_not_strict(</span>
            <span class="s1">data</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
            <span class="s1">copy=copy</span><span class="s0">,</span>
            <span class="s1">tz=tz</span><span class="s0">,</span>
            <span class="s1">freq=freq</span><span class="s0">,</span>
            <span class="s1">dayfirst=dayfirst</span><span class="s0">,</span>
            <span class="s1">yearfirst=yearfirst</span><span class="s0">,</span>
            <span class="s1">ambiguous=ambiguous</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">subarr = cls._simple_new(dtarr</span><span class="s0">, </span><span class="s1">name=name)</span>
        <span class="s0">return </span><span class="s1">subarr</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_is_dates_only(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a boolean if we are only dates (and don't have a timezone) 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas.io.formats.format </span><span class="s0">import </span><span class="s1">is_dates_only</span>

        <span class="s4"># error: Argument 1 to &quot;is_dates_only&quot; has incompatible type</span>
        <span class="s4"># &quot;Union[ExtensionArray, ndarray]&quot;; expected &quot;Union[ndarray,</span>
        <span class="s4"># DatetimeArray, Index, DatetimeIndex]&quot;</span>
        <span class="s0">return </span><span class="s1">self.tz </span><span class="s0">is None and </span><span class="s1">is_dates_only(self._values)  </span><span class="s4"># type: ignore[arg-type]</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">d = {</span><span class="s3">&quot;data&quot;</span><span class="s1">: self._data</span><span class="s0">, </span><span class="s3">&quot;name&quot;</span><span class="s1">: self.name}</span>
        <span class="s0">return </span><span class="s1">_new_DatetimeIndex</span><span class="s0">, </span><span class="s1">(type(self)</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, None</span>

    <span class="s0">def </span><span class="s1">_is_comparable_dtype(self</span><span class="s0">, </span><span class="s1">dtype: DtypeObj) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot; 
        Can we compare values of the given dtype to our own? 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.tz </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># If we have tz, we can compare to tzaware</span>
            <span class="s0">return </span><span class="s1">is_datetime64tz_dtype(dtype)</span>
        <span class="s4"># if we dont have tz, we can only compare to tznaive</span>
        <span class="s0">return </span><span class="s1">is_datetime64_dtype(dtype)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Rendering Methods</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_formatter_func(self):</span>
        <span class="s0">from </span><span class="s1">pandas.io.formats.format </span><span class="s0">import </span><span class="s1">get_format_datetime64</span>

        <span class="s1">formatter = get_format_datetime64(is_dates_only=self._is_dates_only)</span>
        <span class="s0">return lambda </span><span class="s1">x: </span><span class="s3">f&quot;'</span><span class="s0">{</span><span class="s1">formatter(x)</span><span class="s0">}</span><span class="s3">'&quot;</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Set Operation Methods</span>

    <span class="s0">def </span><span class="s1">union_many(self</span><span class="s0">, </span><span class="s1">others):</span>
        <span class="s2">&quot;&quot;&quot; 
        A bit of a hack to accelerate unioning a collection of indexes. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;DatetimeIndex.union_many is deprecated and will be removed in &quot;</span>
            <span class="s3">&quot;a future version. Use obj.union instead.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">this = self</span>

        <span class="s0">for </span><span class="s1">other </span><span class="s0">in </span><span class="s1">others:</span>
            <span class="s0">if not </span><span class="s1">isinstance(this</span><span class="s0">, </span><span class="s1">DatetimeIndex):</span>
                <span class="s1">this = Index.union(this</span><span class="s0">, </span><span class="s1">other)</span>
                <span class="s0">continue</span>

            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">DatetimeIndex):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">other = DatetimeIndex(other)</span>
                <span class="s0">except </span><span class="s1">TypeError:</span>
                    <span class="s0">pass</span>

            <span class="s1">this</span><span class="s0">, </span><span class="s1">other = this._maybe_utc_convert(other)</span>

            <span class="s0">if </span><span class="s1">len(self) </span><span class="s0">and </span><span class="s1">len(other) </span><span class="s0">and </span><span class="s1">this._can_fast_union(other):</span>
                <span class="s4"># union already has fastpath handling for empty cases</span>
                <span class="s1">this = this._fast_union(other)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">this = Index.union(this</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s1">res_name = get_unanimous_names(self</span><span class="s0">, </span><span class="s1">*others)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">this.name != res_name:</span>
            <span class="s0">return </span><span class="s1">this.rename(res_name)</span>
        <span class="s0">return </span><span class="s1">this</span>

    <span class="s0">def </span><span class="s1">_maybe_utc_convert(self</span><span class="s0">, </span><span class="s1">other: Index) -&gt; tuple[DatetimeIndex</span><span class="s0">, </span><span class="s1">Index]:</span>
        <span class="s1">this = self</span>

        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">DatetimeIndex):</span>
            <span class="s0">if </span><span class="s1">(self.tz </span><span class="s0">is None</span><span class="s1">) ^ (other.tz </span><span class="s0">is None</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot join tz-naive with tz-aware DatetimeIndex&quot;</span><span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">timezones.tz_compare(self.tz</span><span class="s0">, </span><span class="s1">other.tz):</span>
                <span class="s1">this = self.tz_convert(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
                <span class="s1">other = other.tz_convert(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">this</span><span class="s0">, </span><span class="s1">other</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">_get_time_micros(self) -&gt; np.ndarray:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the number of microseconds since midnight. 
 
        Returns 
        ------- 
        ndarray[int64_t] 
        &quot;&quot;&quot;</span>
        <span class="s1">values = self._data._local_timestamps()</span>

        <span class="s1">nanos = values % (</span><span class="s5">24 </span><span class="s1">* </span><span class="s5">3600 </span><span class="s1">* </span><span class="s5">1_000_000_000</span><span class="s1">)</span>
        <span class="s1">micros = nanos // </span><span class="s5">1000</span>

        <span class="s1">micros[self._isnan] = -</span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">micros</span>

    <span class="s0">def </span><span class="s1">to_series(self</span><span class="s0">, </span><span class="s1">keep_tz=lib.no_default</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">None, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a Series with both index and values equal to the index keys 
        useful with map for returning an indexer based on an index. 
 
        Parameters 
        ---------- 
        keep_tz : optional, defaults True 
            Return the data keeping the timezone. 
 
            If keep_tz is True: 
 
              If the timezone is not set, the resulting 
              Series will have a datetime64[ns] dtype. 
 
              Otherwise the Series will have an datetime64[ns, tz] dtype; the 
              tz will be preserved. 
 
            If keep_tz is False: 
 
              Series will have a datetime64[ns] dtype. TZ aware 
              objects will have the tz removed. 
 
            .. versionchanged:: 1.0.0 
                The default value is now True.  In a future version, 
                this keyword will be removed entirely.  Stop passing the 
                argument to obtain the future behavior and silence the warning. 
 
        index : Index, optional 
            Index of resulting Series. If None, defaults to original index. 
        name : str, optional 
            Name of resulting Series. If None, defaults to name of original 
            index. 
 
        Returns 
        ------- 
        Series 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s0">if </span><span class="s1">index </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">index = self._view()</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">name = self.name</span>

        <span class="s0">if </span><span class="s1">keep_tz </span><span class="s0">is not </span><span class="s1">lib.no_default:</span>
            <span class="s0">if </span><span class="s1">keep_tz:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s3">&quot;The 'keep_tz' keyword in DatetimeIndex.to_series &quot;</span>
                    <span class="s3">&quot;is deprecated and will be removed in a future version. &quot;</span>
                    <span class="s3">&quot;You can stop passing 'keep_tz' to silence this warning.&quot;</span><span class="s0">,</span>
                    <span class="s1">FutureWarning</span><span class="s0">,</span>
                    <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s3">&quot;Specifying 'keep_tz=False' is deprecated and this &quot;</span>
                    <span class="s3">&quot;option will be removed in a future release. If &quot;</span>
                    <span class="s3">&quot;you want to remove the timezone information, you &quot;</span>
                    <span class="s3">&quot;can do 'idx.tz_convert(None)' before calling &quot;</span>
                    <span class="s3">&quot;'to_series'.&quot;</span><span class="s0">,</span>
                    <span class="s1">FutureWarning</span><span class="s0">,</span>
                    <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">keep_tz = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">keep_tz </span><span class="s0">and </span><span class="s1">self.tz </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># preserve the tz &amp; copy</span>
            <span class="s1">values = self.copy(deep=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># error: Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;Union[ExtensionArray, ndarray]&quot;, variable has type &quot;DatetimeIndex&quot;)</span>
            <span class="s1">values = self._values.view(</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">).copy()  </span><span class="s4"># type: ignore[assignment]</span>

        <span class="s0">return </span><span class="s1">Series(values</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s0">def </span><span class="s1">snap(self</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;S&quot;</span><span class="s1">) -&gt; DatetimeIndex:</span>
        <span class="s2">&quot;&quot;&quot; 
        Snap time stamps to nearest occurring frequency. 
 
        Returns 
        ------- 
        DatetimeIndex 
        &quot;&quot;&quot;</span>
        <span class="s4"># Superdumb, punting on any optimizing</span>
        <span class="s1">freq = to_offset(freq)</span>

        <span class="s1">snapped = np.empty(len(self)</span><span class="s0">, </span><span class="s1">dtype=DT64NS_DTYPE)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate(self):</span>
            <span class="s1">s = v</span>
            <span class="s0">if not </span><span class="s1">freq.is_on_offset(s):</span>
                <span class="s1">t0 = freq.rollback(s)</span>
                <span class="s1">t1 = freq.rollforward(s)</span>
                <span class="s0">if </span><span class="s1">abs(s - t0) &lt; abs(t1 - s):</span>
                    <span class="s1">s = t0</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">s = t1</span>
            <span class="s1">snapped[i] = s</span>

        <span class="s1">dta = DatetimeArray(snapped</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s0">return </span><span class="s1">DatetimeIndex._simple_new(dta</span><span class="s0">, </span><span class="s1">name=self.name)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Indexing Methods</span>

    <span class="s0">def </span><span class="s1">_parsed_string_to_bounds(self</span><span class="s0">, </span><span class="s1">reso: Resolution</span><span class="s0">, </span><span class="s1">parsed: datetime):</span>
        <span class="s2">&quot;&quot;&quot; 
        Calculate datetime bounds for parsed time string and its resolution. 
 
        Parameters 
        ---------- 
        reso : str 
            Resolution provided by parsed string. 
        parsed : datetime 
            Datetime from parsed string. 
 
        Returns 
        ------- 
        lower, upper: pd.Timestamp 
        &quot;&quot;&quot;</span>
        <span class="s1">grp = reso.freq_group</span>
        <span class="s1">per = Period(parsed</span><span class="s0">, </span><span class="s1">freq=grp.value)</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = per.start_time</span><span class="s0">, </span><span class="s1">per.end_time</span>

        <span class="s4"># GH 24076</span>
        <span class="s4"># If an incoming date string contained a UTC offset, need to localize</span>
        <span class="s4"># the parsed date to this offset first before aligning with the index's</span>
        <span class="s4"># timezone</span>
        <span class="s1">start = start.tz_localize(parsed.tzinfo)</span>
        <span class="s1">end = end.tz_localize(parsed.tzinfo)</span>

        <span class="s0">if </span><span class="s1">parsed.tzinfo </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.tz </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;The index must be timezone aware when indexing &quot;</span>
                    <span class="s3">&quot;with a date string with a UTC offset&quot;</span>
                <span class="s1">)</span>
        <span class="s1">start = self._maybe_cast_for_get_loc(start)</span>
        <span class="s1">end = self._maybe_cast_for_get_loc(end)</span>
        <span class="s0">return </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span>

    <span class="s0">def </span><span class="s1">_can_partial_date_slice(self</span><span class="s0">, </span><span class="s1">reso: Resolution) -&gt; bool:</span>
        <span class="s4"># History of conversation GH#3452, GH#3931, GH#2369, GH#14826</span>
        <span class="s0">return </span><span class="s1">reso &gt; self._resolution_obj</span>

    <span class="s0">def </span><span class="s1">_deprecate_mismatched_indexing(self</span><span class="s0">, </span><span class="s1">key) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4"># GH#36148</span>
        <span class="s4"># we get here with isinstance(key, self._data._recognized_scalars)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._data._assert_tzawareness_compat(key)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">if </span><span class="s1">self.tz </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">msg = (</span>
                    <span class="s3">&quot;Indexing a timezone-naive DatetimeIndex with a &quot;</span>
                    <span class="s3">&quot;timezone-aware datetime is deprecated and will &quot;</span>
                    <span class="s3">&quot;raise KeyError in a future version.  &quot;</span>
                    <span class="s3">&quot;Use a timezone-naive object instead.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = (</span>
                    <span class="s3">&quot;Indexing a timezone-aware DatetimeIndex with a &quot;</span>
                    <span class="s3">&quot;timezone-naive datetime is deprecated and will &quot;</span>
                    <span class="s3">&quot;raise KeyError in a future version. &quot;</span>
                    <span class="s3">&quot;Use a timezone-aware object instead.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=find_stack_level())</span>

    <span class="s0">def </span><span class="s1">get_loc(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">method=</span><span class="s0">None, </span><span class="s1">tolerance=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get integer location for requested label 
 
        Returns 
        ------- 
        loc : int 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check_indexing_error(key)</span>

        <span class="s1">orig_key = key</span>
        <span class="s0">if </span><span class="s1">is_valid_na_for_dtype(key</span><span class="s0">, </span><span class="s1">self.dtype):</span>
            <span class="s1">key = NaT</span>

        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">self._data._recognized_scalars):</span>
            <span class="s4"># needed to localize naive datetimes</span>
            <span class="s1">self._deprecate_mismatched_indexing(key)</span>
            <span class="s1">key = self._maybe_cast_for_get_loc(key)</span>

        <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">parsed</span><span class="s0">, </span><span class="s1">reso = self._parse_with_reso(key)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">KeyError(key) </span><span class="s0">from </span><span class="s1">err</span>

            <span class="s0">if </span><span class="s1">self._can_partial_date_slice(reso):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">self._partial_date_slice(reso</span><span class="s0">, </span><span class="s1">parsed)</span>
                <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s0">if </span><span class="s1">method </span><span class="s0">is None</span><span class="s1">:</span>
                        <span class="s0">raise </span><span class="s1">KeyError(key) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">key = self._maybe_cast_for_get_loc(key)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s4"># FIXME(dateutil#1180): we get here because parse_with_reso</span>
                <span class="s4">#  doesn't raise on &quot;t2m&quot;</span>
                <span class="s0">raise </span><span class="s1">KeyError(key) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">timedelta):</span>
            <span class="s4"># GH#20464</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;Cannot index </span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} </span><span class="s3">with </span><span class="s0">{</span><span class="s1">type(key).__name__</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">time):</span>
            <span class="s0">if </span><span class="s1">method </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">&quot;cannot yet lookup inexact labels when key is a time object&quot;</span>
                <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self.indexer_at_time(key)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># unrecognized type</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Index.get_loc(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">tolerance)</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s0">raise </span><span class="s1">KeyError(orig_key) </span><span class="s0">from </span><span class="s1">err</span>

    <span class="s0">def </span><span class="s1">_maybe_cast_for_get_loc(self</span><span class="s0">, </span><span class="s1">key) -&gt; Timestamp:</span>
        <span class="s4"># needed to localize naive datetimes or dates (GH 35690)</span>
        <span class="s1">key = Timestamp(key)</span>
        <span class="s0">if </span><span class="s1">key.tzinfo </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">key = key.tz_localize(self.tz)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">key = key.tz_convert(self.tz)</span>
        <span class="s0">return </span><span class="s1">key</span>

    <span class="s1">@doc(DatetimeTimedeltaMixin._maybe_cast_slice_bound)</span>
    <span class="s0">def </span><span class="s1">_maybe_cast_slice_bound(self</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">side: str</span><span class="s0">, </span><span class="s1">kind=lib.no_default):</span>
        <span class="s1">label = super()._maybe_cast_slice_bound(label</span><span class="s0">, </span><span class="s1">side</span><span class="s0">, </span><span class="s1">kind=kind)</span>
        <span class="s1">self._deprecate_mismatched_indexing(label)</span>
        <span class="s0">return </span><span class="s1">self._maybe_cast_for_get_loc(label)</span>

    <span class="s0">def </span><span class="s1">slice_indexer(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None, </span><span class="s1">step=</span><span class="s0">None, </span><span class="s1">kind=lib.no_default):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return indexer for specified label slice. 
        Index.slice_indexer, customized to handle time slicing. 
 
        In addition to functionality provided by Index.slice_indexer, does the 
        following: 
 
        - if both `start` and `end` are instances of `datetime.time`, it 
          invokes `indexer_between_time` 
        - if `start` and `end` are both either string or None perform 
          value-based selection in non-monotonic cases. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._deprecated_arg(kind</span><span class="s0">, </span><span class="s3">&quot;kind&quot;</span><span class="s0">, </span><span class="s3">&quot;slice_indexer&quot;</span><span class="s1">)</span>

        <span class="s4"># For historical reasons DatetimeIndex supports slices between two</span>
        <span class="s4"># instances of datetime.time as if it were applying a slice mask to</span>
        <span class="s4"># an array of (self.hour, self.minute, self.seconds, self.microsecond).</span>
        <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">time) </span><span class="s0">and </span><span class="s1">isinstance(end</span><span class="s0">, </span><span class="s1">time):</span>
            <span class="s0">if </span><span class="s1">step </span><span class="s0">is not None and </span><span class="s1">step != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Must have step size of 1 with time slices&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self.indexer_between_time(start</span><span class="s0">, </span><span class="s1">end)</span>

        <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">time) </span><span class="s0">or </span><span class="s1">isinstance(end</span><span class="s0">, </span><span class="s1">time):</span>
            <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;Cannot mix time and non-time slice keys&quot;</span><span class="s1">)</span>

        <span class="s4"># Pandas supports slicing with dates, treated as datetimes at midnight.</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/31501</span>
        <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">date) </span><span class="s0">and not </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">datetime):</span>
            <span class="s1">start = datetime.combine(start</span><span class="s0">, </span><span class="s1">time(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">isinstance(end</span><span class="s0">, </span><span class="s1">date) </span><span class="s0">and not </span><span class="s1">isinstance(end</span><span class="s0">, </span><span class="s1">datetime):</span>
            <span class="s1">end = datetime.combine(end</span><span class="s0">, </span><span class="s1">time(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s0">def </span><span class="s1">check_str_or_none(point):</span>
            <span class="s0">return </span><span class="s1">point </span><span class="s0">is not None and not </span><span class="s1">isinstance(point</span><span class="s0">, </span><span class="s1">str)</span>

        <span class="s4"># GH#33146 if start and end are combinations of str and None and Index is not</span>
        <span class="s4"># monotonic, we can not use Index.slice_indexer because it does not honor the</span>
        <span class="s4"># actual elements, is only searching for start and end</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">check_str_or_none(start)</span>
            <span class="s0">or </span><span class="s1">check_str_or_none(end)</span>
            <span class="s0">or </span><span class="s1">self.is_monotonic_increasing</span>
        <span class="s1">):</span>
            <span class="s0">return </span><span class="s1">Index.slice_indexer(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">step</span><span class="s0">, </span><span class="s1">kind=kind)</span>

        <span class="s1">mask = np.array(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">deprecation_mask = np.array(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">start </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">start_casted = self._maybe_cast_slice_bound(start</span><span class="s0">, </span><span class="s3">&quot;left&quot;</span><span class="s1">)</span>
            <span class="s1">mask = start_casted &lt;= self</span>
            <span class="s1">deprecation_mask = start_casted == self</span>

        <span class="s0">if </span><span class="s1">end </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">end_casted = self._maybe_cast_slice_bound(end</span><span class="s0">, </span><span class="s3">&quot;right&quot;</span><span class="s1">)</span>
            <span class="s1">mask = (self &lt;= end_casted) &amp; mask</span>
            <span class="s1">deprecation_mask = (end_casted == self) | deprecation_mask</span>

        <span class="s0">if not </span><span class="s1">deprecation_mask.any():</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Value based partial slicing on non-monotonic DatetimeIndexes &quot;</span>
                <span class="s3">&quot;with non-existing keys is deprecated and will raise a &quot;</span>
                <span class="s3">&quot;KeyError in a future Version.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">indexer = mask.nonzero()[</span><span class="s5">0</span><span class="s1">][::step]</span>
        <span class="s0">if </span><span class="s1">len(indexer) == len(self):</span>
            <span class="s0">return </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">indexer</span>

    <span class="s1">@doc(Index.get_slice_bound)</span>
    <span class="s0">def </span><span class="s1">get_slice_bound(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">side: Literal[</span><span class="s3">&quot;left&quot;</span><span class="s0">, </span><span class="s3">&quot;right&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">kind=lib.no_default</span>
    <span class="s1">) -&gt; int:</span>
        <span class="s4"># GH#42855 handle date here instead of _maybe_cast_slice_bound</span>
        <span class="s0">if </span><span class="s1">isinstance(label</span><span class="s0">, </span><span class="s1">date) </span><span class="s0">and not </span><span class="s1">isinstance(label</span><span class="s0">, </span><span class="s1">datetime):</span>
            <span class="s1">label = Timestamp(label).to_pydatetime()</span>
        <span class="s0">return </span><span class="s1">super().get_slice_bound(label</span><span class="s0">, </span><span class="s1">side=side</span><span class="s0">, </span><span class="s1">kind=kind)</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">inferred_type(self) -&gt; str:</span>
        <span class="s4"># b/c datetime is represented as microseconds since the epoch, make</span>
        <span class="s4"># sure we can't have ambiguous indexing</span>
        <span class="s0">return </span><span class="s3">&quot;datetime64&quot;</span>

    <span class="s0">def </span><span class="s1">indexer_at_time(self</span><span class="s0">, </span><span class="s1">time</span><span class="s0">, </span><span class="s1">asof: bool = </span><span class="s0">False</span><span class="s1">) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return index locations of values at particular time of day 
        (e.g. 9:30AM). 
 
        Parameters 
        ---------- 
        time : datetime.time or str 
            Time passed in either as object (datetime.time) or as string in 
            appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;, &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;, 
            &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;, &quot;%I%M%S%p&quot;). 
 
        Returns 
        ------- 
        np.ndarray[np.intp] 
 
        See Also 
        -------- 
        indexer_between_time : Get index locations of values between particular 
            times of day. 
        DataFrame.at_time : Select values at particular time of day. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">asof:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;'asof' argument is not supported&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(time</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">from </span><span class="s1">dateutil.parser </span><span class="s0">import </span><span class="s1">parse</span>

            <span class="s1">time = parse(time).time()</span>

        <span class="s0">if </span><span class="s1">time.tzinfo:</span>
            <span class="s0">if </span><span class="s1">self.tz </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Index must be timezone aware.&quot;</span><span class="s1">)</span>
            <span class="s1">time_micros = self.tz_convert(time.tzinfo)._get_time_micros()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">time_micros = self._get_time_micros()</span>
        <span class="s1">micros = _time_to_micros(time)</span>
        <span class="s0">return </span><span class="s1">(time_micros == micros).nonzero()[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">indexer_between_time(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">start_time</span><span class="s0">, </span><span class="s1">end_time</span><span class="s0">, </span><span class="s1">include_start: bool = </span><span class="s0">True, </span><span class="s1">include_end: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return index locations of values between particular times of day 
        (e.g., 9:00-9:30AM). 
 
        Parameters 
        ---------- 
        start_time, end_time : datetime.time, str 
            Time passed either as object (datetime.time) or as string in 
            appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;, &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;, 
            &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;,&quot;%I%M%S%p&quot;). 
        include_start : bool, default True 
        include_end : bool, default True 
 
        Returns 
        ------- 
        np.ndarray[np.intp] 
 
        See Also 
        -------- 
        indexer_at_time : Get index locations of values at particular time of day. 
        DataFrame.between_time : Select values between particular times of day. 
        &quot;&quot;&quot;</span>
        <span class="s1">start_time = to_time(start_time)</span>
        <span class="s1">end_time = to_time(end_time)</span>
        <span class="s1">time_micros = self._get_time_micros()</span>
        <span class="s1">start_micros = _time_to_micros(start_time)</span>
        <span class="s1">end_micros = _time_to_micros(end_time)</span>

        <span class="s0">if </span><span class="s1">include_start </span><span class="s0">and </span><span class="s1">include_end:</span>
            <span class="s1">lop = rop = operator.le</span>
        <span class="s0">elif </span><span class="s1">include_start:</span>
            <span class="s1">lop = operator.le</span>
            <span class="s1">rop = operator.lt</span>
        <span class="s0">elif </span><span class="s1">include_end:</span>
            <span class="s1">lop = operator.lt</span>
            <span class="s1">rop = operator.le</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">lop = rop = operator.lt</span>

        <span class="s0">if </span><span class="s1">start_time &lt;= end_time:</span>
            <span class="s1">join_op = operator.and_</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">join_op = operator.or_</span>

        <span class="s1">mask = join_op(lop(start_micros</span><span class="s0">, </span><span class="s1">time_micros)</span><span class="s0">, </span><span class="s1">rop(time_micros</span><span class="s0">, </span><span class="s1">end_micros))</span>

        <span class="s0">return </span><span class="s1">mask.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">date_range(</span>
    <span class="s1">start=</span><span class="s0">None,</span>
    <span class="s1">end=</span><span class="s0">None,</span>
    <span class="s1">periods=</span><span class="s0">None,</span>
    <span class="s1">freq=</span><span class="s0">None,</span>
    <span class="s1">tz=</span><span class="s0">None,</span>
    <span class="s1">normalize: bool = </span><span class="s0">False,</span>
    <span class="s1">name: Hashable = </span><span class="s0">None,</span>
    <span class="s1">closed: str | </span><span class="s0">None </span><span class="s1">| lib.NoDefault = lib.no_default</span><span class="s0">,</span>
    <span class="s1">inclusive: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">) -&gt; DatetimeIndex:</span>
    <span class="s2">&quot;&quot;&quot; 
    Return a fixed frequency DatetimeIndex. 
 
    Returns the range of equally spaced time points (where the difference between any 
    two adjacent points is specified by the given frequency) such that they all 
    satisfy `start &lt;[=] x &lt;[=] end`, where the first one and the last one are, resp., 
    the first and last time points in that range that fall on the boundary of ``freq`` 
    (if given as a frequency string) or that are valid for ``freq`` (if given as a 
    :class:`pandas.tseries.offsets.DateOffset`). (If exactly one of ``start``, 
    ``end``, or ``freq`` is *not* specified, this missing parameter can be computed 
    given ``periods``, the number of timesteps in the range. See the note below.) 
 
    Parameters 
    ---------- 
    start : str or datetime-like, optional 
        Left bound for generating dates. 
    end : str or datetime-like, optional 
        Right bound for generating dates. 
    periods : int, optional 
        Number of periods to generate. 
    freq : str or DateOffset, default 'D' 
        Frequency strings can have multiples, e.g. '5H'. See 
        :ref:`here &lt;timeseries.offset_aliases&gt;` for a list of 
        frequency aliases. 
    tz : str or tzinfo, optional 
        Time zone name for returning localized DatetimeIndex, for example 
        'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is 
        timezone-naive. 
    normalize : bool, default False 
        Normalize start/end dates to midnight before generating date range. 
    name : str, default None 
        Name of the resulting DatetimeIndex. 
    closed : {None, 'left', 'right'}, optional 
        Make the interval closed with respect to the given frequency to 
        the 'left', 'right', or both sides (None, the default). 
 
        .. deprecated:: 1.4.0 
           Argument `closed` has been deprecated to standardize boundary inputs. 
           Use `inclusive` instead, to set each bound as closed or open. 
    inclusive : {&quot;both&quot;, &quot;neither&quot;, &quot;left&quot;, &quot;right&quot;}, default &quot;both&quot; 
        Include boundaries; Whether to set each bound as closed or open. 
 
        .. versionadded:: 1.4.0 
    **kwargs 
        For compatibility. Has no effect on the result. 
 
    Returns 
    ------- 
    rng : DatetimeIndex 
 
    See Also 
    -------- 
    DatetimeIndex : An immutable container for datetimes. 
    timedelta_range : Return a fixed frequency TimedeltaIndex. 
    period_range : Return a fixed frequency PeriodIndex. 
    interval_range : Return a fixed frequency IntervalIndex. 
 
    Notes 
    ----- 
    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``, 
    exactly three must be specified. If ``freq`` is omitted, the resulting 
    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between 
    ``start`` and ``end`` (closed on both sides). 
 
    To learn more about the frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
    Examples 
    -------- 
    **Specifying the values** 
 
    The next four examples generate the same `DatetimeIndex`, but vary 
    the combination of `start`, `end` and `periods`. 
 
    Specify `start` and `end`, with the default daily frequency. 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', end='1/08/2018') 
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04', 
                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Specify `start` and `periods`, the number of periods (days). 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=8) 
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04', 
                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Specify `end` and `periods`, the number of periods (days). 
 
    &gt;&gt;&gt; pd.date_range(end='1/1/2018', periods=8) 
    DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28', 
                   '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Specify `start`, `end`, and `periods`; the frequency is generated 
    automatically (linearly spaced). 
 
    &gt;&gt;&gt; pd.date_range(start='2018-04-24', end='2018-04-27', periods=3) 
    DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00', 
                   '2018-04-27 00:00:00'], 
                  dtype='datetime64[ns]', freq=None) 
 
    **Other Parameters** 
 
    Changed the `freq` (frequency) to ``'M'`` (month end frequency). 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, freq='M') 
    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30', 
                   '2018-05-31'], 
                  dtype='datetime64[ns]', freq='M') 
 
    Multiples are allowed 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, freq='3M') 
    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31', 
                   '2019-01-31'], 
                  dtype='datetime64[ns]', freq='3M') 
 
    `freq` can also be specified as an Offset object. 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3)) 
    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31', 
                   '2019-01-31'], 
                  dtype='datetime64[ns]', freq='3M') 
 
    Specify `tz` to set the timezone. 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo') 
    DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00', 
                   '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00', 
                   '2018-01-05 00:00:00+09:00'], 
                  dtype='datetime64[ns, Asia/Tokyo]', freq='D') 
 
    `inclusive` controls whether to include `start` and `end` that are on the 
    boundary. The default, &quot;both&quot;, includes boundary points on either end. 
 
    &gt;&gt;&gt; pd.date_range(start='2017-01-01', end='2017-01-04', inclusive=&quot;both&quot;) 
    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Use ``inclusive='left'`` to exclude `end` if it falls on the boundary. 
 
    &gt;&gt;&gt; pd.date_range(start='2017-01-01', end='2017-01-04', inclusive='left') 
    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Use ``inclusive='right'`` to exclude `start` if it falls on the boundary, and 
    similarly ``inclusive='neither'`` will exclude both `start` and `end`. 
 
    &gt;&gt;&gt; pd.date_range(start='2017-01-01', end='2017-01-04', inclusive='right') 
    DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'], 
                  dtype='datetime64[ns]', freq='D') 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">inclusive </span><span class="s0">is not None and not </span><span class="s1">isinstance(closed</span><span class="s0">, </span><span class="s1">lib.NoDefault):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Deprecated argument `closed` cannot be passed&quot;</span>
            <span class="s3">&quot;if argument `inclusive` is not None&quot;</span>
        <span class="s1">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance(closed</span><span class="s0">, </span><span class="s1">lib.NoDefault):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Argument `closed` is deprecated in favor of `inclusive`.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">closed </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">inclusive = </span><span class="s3">&quot;both&quot;</span>
        <span class="s0">elif </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;left&quot;</span><span class="s0">, </span><span class="s3">&quot;right&quot;</span><span class="s1">):</span>
            <span class="s1">inclusive = closed</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Argument `closed` has to be either 'left', 'right' or None&quot;</span>
            <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">inclusive </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">inclusive = </span><span class="s3">&quot;both&quot;</span>

    <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None and </span><span class="s1">com.any_none(periods</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end):</span>
        <span class="s1">freq = </span><span class="s3">&quot;D&quot;</span>

    <span class="s1">dtarr = DatetimeArray._generate_range(</span>
        <span class="s1">start=start</span><span class="s0">,</span>
        <span class="s1">end=end</span><span class="s0">,</span>
        <span class="s1">periods=periods</span><span class="s0">,</span>
        <span class="s1">freq=freq</span><span class="s0">,</span>
        <span class="s1">tz=tz</span><span class="s0">,</span>
        <span class="s1">normalize=normalize</span><span class="s0">,</span>
        <span class="s1">inclusive=inclusive</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">DatetimeIndex._simple_new(dtarr</span><span class="s0">, </span><span class="s1">name=name)</span>


<span class="s0">def </span><span class="s1">bdate_range(</span>
    <span class="s1">start=</span><span class="s0">None,</span>
    <span class="s1">end=</span><span class="s0">None,</span>
    <span class="s1">periods: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">freq=</span><span class="s3">&quot;B&quot;</span><span class="s0">,</span>
    <span class="s1">tz=</span><span class="s0">None,</span>
    <span class="s1">normalize: bool = </span><span class="s0">True,</span>
    <span class="s1">name: Hashable = </span><span class="s0">None,</span>
    <span class="s1">weekmask=</span><span class="s0">None,</span>
    <span class="s1">holidays=</span><span class="s0">None,</span>
    <span class="s1">closed: lib.NoDefault = lib.no_default</span><span class="s0">,</span>
    <span class="s1">inclusive: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">) -&gt; DatetimeIndex:</span>
    <span class="s2">&quot;&quot;&quot; 
    Return a fixed frequency DatetimeIndex, with business day as the default 
    frequency. 
 
    Parameters 
    ---------- 
    start : str or datetime-like, default None 
        Left bound for generating dates. 
    end : str or datetime-like, default None 
        Right bound for generating dates. 
    periods : int, default None 
        Number of periods to generate. 
    freq : str or DateOffset, default 'B' (business daily) 
        Frequency strings can have multiples, e.g. '5H'. 
    tz : str or None 
        Time zone name for returning localized DatetimeIndex, for example 
        Asia/Beijing. 
    normalize : bool, default False 
        Normalize start/end dates to midnight before generating date range. 
    name : str, default None 
        Name of the resulting DatetimeIndex. 
    weekmask : str or None, default None 
        Weekmask of valid business days, passed to ``numpy.busdaycalendar``, 
        only used when custom frequency strings are passed.  The default 
        value None is equivalent to 'Mon Tue Wed Thu Fri'. 
    holidays : list-like or None, default None 
        Dates to exclude from the set of valid business days, passed to 
        ``numpy.busdaycalendar``, only used when custom frequency strings 
        are passed. 
    closed : str, default None 
        Make the interval closed with respect to the given frequency to 
        the 'left', 'right', or both sides (None). 
 
        .. deprecated:: 1.4.0 
           Argument `closed` has been deprecated to standardize boundary inputs. 
           Use `inclusive` instead, to set each bound as closed or open. 
    inclusive : {&quot;both&quot;, &quot;neither&quot;, &quot;left&quot;, &quot;right&quot;}, default &quot;both&quot; 
        Include boundaries; Whether to set each bound as closed or open. 
 
        .. versionadded:: 1.4.0 
    **kwargs 
        For compatibility. Has no effect on the result. 
 
    Returns 
    ------- 
    DatetimeIndex 
 
    Notes 
    ----- 
    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``, 
    exactly three must be specified.  Specifying ``freq`` is a requirement 
    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not 
    desired. 
 
    To learn more about the frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
    Examples 
    -------- 
    Note how the two weekend days are skipped in the result. 
 
    &gt;&gt;&gt; pd.bdate_range(start='1/1/2018', end='1/08/2018') 
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04', 
               '2018-01-05', '2018-01-08'], 
              dtype='datetime64[ns]', freq='B') 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s3">&quot;freq must be specified for bdate_range; use date_range instead&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s0">if </span><span class="s1">isinstance(freq</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">freq.startswith(</span><span class="s3">&quot;C&quot;</span><span class="s1">):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">weekmask = weekmask </span><span class="s0">or </span><span class="s3">&quot;Mon Tue Wed Thu Fri&quot;</span>
            <span class="s1">freq = prefix_mapping[freq](holidays=holidays</span><span class="s0">, </span><span class="s1">weekmask=weekmask)</span>
        <span class="s0">except </span><span class="s1">(KeyError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s1">msg = </span><span class="s3">f&quot;invalid custom frequency string: </span><span class="s0">{</span><span class="s1">freq</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg) </span><span class="s0">from </span><span class="s1">err</span>
    <span class="s0">elif </span><span class="s1">holidays </span><span class="s0">or </span><span class="s1">weekmask:</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;a custom frequency string is required when holidays or &quot;</span>
            <span class="s3">f&quot;weekmask are passed, got frequency </span><span class="s0">{</span><span class="s1">freq</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s0">return </span><span class="s1">date_range(</span>
        <span class="s1">start=start</span><span class="s0">,</span>
        <span class="s1">end=end</span><span class="s0">,</span>
        <span class="s1">periods=periods</span><span class="s0">,</span>
        <span class="s1">freq=freq</span><span class="s0">,</span>
        <span class="s1">tz=tz</span><span class="s0">,</span>
        <span class="s1">normalize=normalize</span><span class="s0">,</span>
        <span class="s1">name=name</span><span class="s0">,</span>
        <span class="s1">closed=closed</span><span class="s0">,</span>
        <span class="s1">inclusive=inclusive</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_time_to_micros(time_obj: time) -&gt; int:</span>
    <span class="s1">seconds = time_obj.hour * </span><span class="s5">60 </span><span class="s1">* </span><span class="s5">60 </span><span class="s1">+ </span><span class="s5">60 </span><span class="s1">* time_obj.minute + time_obj.second</span>
    <span class="s0">return </span><span class="s5">1_000_000 </span><span class="s1">* seconds + time_obj.microsecond</span>
</pre>
</body>
</html>