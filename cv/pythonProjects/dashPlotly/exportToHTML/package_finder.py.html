<html>
<head>
<title>package_finder.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
package_finder.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Routines related to PyPI, indexes&quot;&quot;&quot;</span>

<span class="s2"># The following comment should be removed at some point in the future.</span>
<span class="s2"># mypy: strict-optional=False</span>

<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">FrozenSet</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Set</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">pip._vendor.packaging </span><span class="s3">import </span><span class="s1">specifiers</span>
<span class="s3">from </span><span class="s1">pip._vendor.packaging.tags </span><span class="s3">import </span><span class="s1">Tag</span>
<span class="s3">from </span><span class="s1">pip._vendor.packaging.utils </span><span class="s3">import </span><span class="s1">canonicalize_name</span>
<span class="s3">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s3">import </span><span class="s1">_BaseVersion</span>
<span class="s3">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s3">import </span><span class="s1">parse </span><span class="s3">as </span><span class="s1">parse_version</span>

<span class="s3">from </span><span class="s1">pip._internal.exceptions </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">BestVersionAlreadyInstalled</span><span class="s3">,</span>
    <span class="s1">DistributionNotFound</span><span class="s3">,</span>
    <span class="s1">InvalidWheelFilename</span><span class="s3">,</span>
    <span class="s1">UnsupportedWheel</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">pip._internal.index.collector </span><span class="s3">import </span><span class="s1">LinkCollector</span><span class="s3">, </span><span class="s1">parse_links</span>
<span class="s3">from </span><span class="s1">pip._internal.models.candidate </span><span class="s3">import </span><span class="s1">InstallationCandidate</span>
<span class="s3">from </span><span class="s1">pip._internal.models.format_control </span><span class="s3">import </span><span class="s1">FormatControl</span>
<span class="s3">from </span><span class="s1">pip._internal.models.link </span><span class="s3">import </span><span class="s1">Link</span>
<span class="s3">from </span><span class="s1">pip._internal.models.search_scope </span><span class="s3">import </span><span class="s1">SearchScope</span>
<span class="s3">from </span><span class="s1">pip._internal.models.selection_prefs </span><span class="s3">import </span><span class="s1">SelectionPreferences</span>
<span class="s3">from </span><span class="s1">pip._internal.models.target_python </span><span class="s3">import </span><span class="s1">TargetPython</span>
<span class="s3">from </span><span class="s1">pip._internal.models.wheel </span><span class="s3">import </span><span class="s1">Wheel</span>
<span class="s3">from </span><span class="s1">pip._internal.req </span><span class="s3">import </span><span class="s1">InstallRequirement</span>
<span class="s3">from </span><span class="s1">pip._internal.utils._log </span><span class="s3">import </span><span class="s1">getLogger</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.filetypes </span><span class="s3">import </span><span class="s1">WHEEL_EXTENSION</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s3">import </span><span class="s1">Hashes</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.logging </span><span class="s3">import </span><span class="s1">indent_log</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.misc </span><span class="s3">import </span><span class="s1">build_netloc</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.packaging </span><span class="s3">import </span><span class="s1">check_requires_python</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.unpacking </span><span class="s3">import </span><span class="s1">SUPPORTED_EXTENSIONS</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;FormatControl&quot;</span><span class="s3">, </span><span class="s4">&quot;BestCandidateResult&quot;</span><span class="s3">, </span><span class="s4">&quot;PackageFinder&quot;</span><span class="s1">]</span>


<span class="s1">logger = getLogger(__name__)</span>

<span class="s1">BuildTag = Union[Tuple[()]</span><span class="s3">, </span><span class="s1">Tuple[int</span><span class="s3">, </span><span class="s1">str]]</span>
<span class="s1">CandidateSortingKey = Tuple[int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">_BaseVersion</span><span class="s3">, </span><span class="s1">Optional[int]</span><span class="s3">, </span><span class="s1">BuildTag]</span>


<span class="s3">def </span><span class="s1">_check_link_requires_python(</span>
    <span class="s1">link: Link</span><span class="s3">,</span>
    <span class="s1">version_info: Tuple[int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int]</span><span class="s3">,</span>
    <span class="s1">ignore_requires_python: bool = </span><span class="s3">False,</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether the given Python version is compatible with a link's 
    &quot;Requires-Python&quot; value. 
 
    :param version_info: A 3-tuple of ints representing the Python 
        major-minor-micro version to check. 
    :param ignore_requires_python: Whether to ignore the &quot;Requires-Python&quot; 
        value if the given Python version isn't compatible. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">is_compatible = check_requires_python(</span>
            <span class="s1">link.requires_python</span><span class="s3">,</span>
            <span class="s1">version_info=version_info</span><span class="s3">,</span>
        <span class="s1">)</span>
    <span class="s3">except </span><span class="s1">specifiers.InvalidSpecifier:</span>
        <span class="s1">logger.debug(</span>
            <span class="s4">&quot;Ignoring invalid Requires-Python (%r) for link: %s&quot;</span><span class="s3">,</span>
            <span class="s1">link.requires_python</span><span class="s3">,</span>
            <span class="s1">link</span><span class="s3">,</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">is_compatible:</span>
            <span class="s1">version = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(map(str</span><span class="s3">, </span><span class="s1">version_info))</span>
            <span class="s3">if not </span><span class="s1">ignore_requires_python:</span>
                <span class="s1">logger.verbose(</span>
                    <span class="s4">&quot;Link requires a different Python (%s not in: %r): %s&quot;</span><span class="s3">,</span>
                    <span class="s1">version</span><span class="s3">,</span>
                    <span class="s1">link.requires_python</span><span class="s3">,</span>
                    <span class="s1">link</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s3">return False</span>

            <span class="s1">logger.debug(</span>
                <span class="s4">&quot;Ignoring failed Requires-Python check (%s not in: %r) for link: %s&quot;</span><span class="s3">,</span>
                <span class="s1">version</span><span class="s3">,</span>
                <span class="s1">link.requires_python</span><span class="s3">,</span>
                <span class="s1">link</span><span class="s3">,</span>
            <span class="s1">)</span>

    <span class="s3">return True</span>


<span class="s3">class </span><span class="s1">LinkEvaluator:</span>

    <span class="s0">&quot;&quot;&quot; 
    Responsible for evaluating links for a particular project. 
    &quot;&quot;&quot;</span>

    <span class="s1">_py_version_re = re.compile(</span><span class="s4">r&quot;-py([123]\.?[0-9]?)$&quot;</span><span class="s1">)</span>

    <span class="s2"># Don't include an allow_yanked default value to make sure each call</span>
    <span class="s2"># site considers whether yanked releases are allowed. This also causes</span>
    <span class="s2"># that decision to be made explicit in the calling code, which helps</span>
    <span class="s2"># people when reading the code.</span>
    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">project_name: str</span><span class="s3">,</span>
        <span class="s1">canonical_name: str</span><span class="s3">,</span>
        <span class="s1">formats: FrozenSet[str]</span><span class="s3">,</span>
        <span class="s1">target_python: TargetPython</span><span class="s3">,</span>
        <span class="s1">allow_yanked: bool</span><span class="s3">,</span>
        <span class="s1">ignore_requires_python: Optional[bool] = </span><span class="s3">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        :param project_name: The user supplied package name. 
        :param canonical_name: The canonical package name. 
        :param formats: The formats allowed for this package. Should be a set 
            with 'binary' or 'source' or both in it. 
        :param target_python: The target Python interpreter to use when 
            evaluating link compatibility. This is used, for example, to 
            check wheel compatibility, as well as when checking the Python 
            version, e.g. the Python version embedded in a link filename 
            (or egg fragment) and against an HTML link's optional PEP 503 
            &quot;data-requires-python&quot; attribute. 
        :param allow_yanked: Whether files marked as yanked (in the sense 
            of PEP 592) are permitted to be candidates for install. 
        :param ignore_requires_python: Whether to ignore incompatible 
            PEP 503 &quot;data-requires-python&quot; values in HTML links. Defaults 
            to False. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">ignore_requires_python </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">ignore_requires_python = </span><span class="s3">False</span>

        <span class="s1">self._allow_yanked = allow_yanked</span>
        <span class="s1">self._canonical_name = canonical_name</span>
        <span class="s1">self._ignore_requires_python = ignore_requires_python</span>
        <span class="s1">self._formats = formats</span>
        <span class="s1">self._target_python = target_python</span>

        <span class="s1">self.project_name = project_name</span>

    <span class="s3">def </span><span class="s1">evaluate_link(self</span><span class="s3">, </span><span class="s1">link: Link) -&gt; Tuple[bool</span><span class="s3">, </span><span class="s1">Optional[str]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Determine whether a link is a candidate for installation. 
 
        :return: A tuple (is_candidate, result), where `result` is (1) a 
            version string if `is_candidate` is True, and (2) if 
            `is_candidate` is False, an optional string to log the reason 
            the link fails to qualify. 
        &quot;&quot;&quot;</span>
        <span class="s1">version = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">link.is_yanked </span><span class="s3">and not </span><span class="s1">self._allow_yanked:</span>
            <span class="s1">reason = link.yanked_reason </span><span class="s3">or </span><span class="s4">&quot;&lt;none given&gt;&quot;</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s4">f&quot;yanked for reason: </span><span class="s3">{</span><span class="s1">reason</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">link.egg_fragment:</span>
            <span class="s1">egg_info = link.egg_fragment</span>
            <span class="s1">ext = link.ext</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">egg_info</span><span class="s3">, </span><span class="s1">ext = link.splitext()</span>
            <span class="s3">if not </span><span class="s1">ext:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s4">&quot;not a file&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">ext </span><span class="s3">not in </span><span class="s1">SUPPORTED_EXTENSIONS:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s4">f&quot;unsupported archive format: </span><span class="s3">{</span><span class="s1">ext</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s4">&quot;binary&quot; </span><span class="s3">not in </span><span class="s1">self._formats </span><span class="s3">and </span><span class="s1">ext == WHEEL_EXTENSION:</span>
                <span class="s1">reason = </span><span class="s4">&quot;No binaries permitted for {}&quot;</span><span class="s1">.format(self.project_name)</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s1">reason)</span>
            <span class="s3">if </span><span class="s4">&quot;macosx10&quot; </span><span class="s3">in </span><span class="s1">link.path </span><span class="s3">and </span><span class="s1">ext == </span><span class="s4">&quot;.zip&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s4">&quot;macosx10 one&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">ext == WHEEL_EXTENSION:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">wheel = Wheel(link.filename)</span>
                <span class="s3">except </span><span class="s1">InvalidWheelFilename:</span>
                    <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s4">&quot;invalid wheel filename&quot;</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">canonicalize_name(wheel.name) != self._canonical_name:</span>
                    <span class="s1">reason = </span><span class="s4">&quot;wrong project name (not {})&quot;</span><span class="s1">.format(self.project_name)</span>
                    <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s1">reason)</span>

                <span class="s1">supported_tags = self._target_python.get_tags()</span>
                <span class="s3">if not </span><span class="s1">wheel.supported(supported_tags):</span>
                    <span class="s2"># Include the wheel's tags in the reason string to</span>
                    <span class="s2"># simplify troubleshooting compatibility issues.</span>
                    <span class="s1">file_tags = wheel.get_formatted_file_tags()</span>
                    <span class="s1">reason = (</span>
                        <span class="s4">&quot;none of the wheel's tags ({}) are compatible &quot;</span>
                        <span class="s4">&quot;(run pip debug --verbose to show compatible tags)&quot;</span><span class="s1">.format(</span>
                            <span class="s4">&quot;, &quot;</span><span class="s1">.join(file_tags)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s1">reason)</span>

                <span class="s1">version = wheel.version</span>

        <span class="s2"># This should be up by the self.ok_binary check, but see issue 2700.</span>
        <span class="s3">if </span><span class="s4">&quot;source&quot; </span><span class="s3">not in </span><span class="s1">self._formats </span><span class="s3">and </span><span class="s1">ext != WHEEL_EXTENSION:</span>
            <span class="s1">reason = </span><span class="s4">f&quot;No sources permitted for </span><span class="s3">{</span><span class="s1">self.project_name</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s1">reason)</span>

        <span class="s3">if not </span><span class="s1">version:</span>
            <span class="s1">version = _extract_version_from_fragment(</span>
                <span class="s1">egg_info</span><span class="s3">,</span>
                <span class="s1">self._canonical_name</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">version:</span>
            <span class="s1">reason = </span><span class="s4">f&quot;Missing project version for </span><span class="s3">{</span><span class="s1">self.project_name</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s1">reason)</span>

        <span class="s1">match = self._py_version_re.search(version)</span>
        <span class="s3">if </span><span class="s1">match:</span>
            <span class="s1">version = version[: match.start()]</span>
            <span class="s1">py_version = match.group(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">py_version != self._target_python.py_version:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s3">False, </span><span class="s4">&quot;Python version is incorrect&quot;</span><span class="s1">)</span>

        <span class="s1">supports_python = _check_link_requires_python(</span>
            <span class="s1">link</span><span class="s3">,</span>
            <span class="s1">version_info=self._target_python.py_version_info</span><span class="s3">,</span>
            <span class="s1">ignore_requires_python=self._ignore_requires_python</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">supports_python:</span>
            <span class="s2"># Return None for the reason text to suppress calling</span>
            <span class="s2"># _log_skipped_link().</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">False, None</span><span class="s1">)</span>

        <span class="s1">logger.debug(</span><span class="s4">&quot;Found link %s, version: %s&quot;</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">version)</span>

        <span class="s3">return </span><span class="s1">(</span><span class="s3">True, </span><span class="s1">version)</span>


<span class="s3">def </span><span class="s1">filter_unallowed_hashes(</span>
    <span class="s1">candidates: List[InstallationCandidate]</span><span class="s3">,</span>
    <span class="s1">hashes: Hashes</span><span class="s3">,</span>
    <span class="s1">project_name: str</span><span class="s3">,</span>
<span class="s1">) -&gt; List[InstallationCandidate]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Filter out candidates whose hashes aren't allowed, and return a new 
    list of candidates. 
 
    If at least one candidate has an allowed hash, then all candidates with 
    either an allowed hash or no hash specified are returned.  Otherwise, 
    the given candidates are returned. 
 
    Including the candidates with no hash specified when there is a match 
    allows a warning to be logged if there is a more preferred candidate 
    with no hash specified.  Returning all candidates in the case of no 
    matches lets pip report the hash of the candidate that would otherwise 
    have been installed (e.g. permitting the user to more easily update 
    their requirements file with the desired hash). 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">hashes:</span>
        <span class="s1">logger.debug(</span>
            <span class="s4">&quot;Given no hashes to check %s links for project %r: &quot;</span>
            <span class="s4">&quot;discarding no candidates&quot;</span><span class="s3">,</span>
            <span class="s1">len(candidates)</span><span class="s3">,</span>
            <span class="s1">project_name</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s2"># Make sure we're not returning back the given value.</span>
        <span class="s3">return </span><span class="s1">list(candidates)</span>

    <span class="s1">matches_or_no_digest = []</span>
    <span class="s2"># Collect the non-matches for logging purposes.</span>
    <span class="s1">non_matches = []</span>
    <span class="s1">match_count = </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">candidate </span><span class="s3">in </span><span class="s1">candidates:</span>
        <span class="s1">link = candidate.link</span>
        <span class="s3">if not </span><span class="s1">link.has_hash:</span>
            <span class="s3">pass</span>
        <span class="s3">elif </span><span class="s1">link.is_hash_allowed(hashes=hashes):</span>
            <span class="s1">match_count += </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">non_matches.append(candidate)</span>
            <span class="s3">continue</span>

        <span class="s1">matches_or_no_digest.append(candidate)</span>

    <span class="s3">if </span><span class="s1">match_count:</span>
        <span class="s1">filtered = matches_or_no_digest</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># Make sure we're not returning back the given value.</span>
        <span class="s1">filtered = list(candidates)</span>

    <span class="s3">if </span><span class="s1">len(filtered) == len(candidates):</span>
        <span class="s1">discard_message = </span><span class="s4">&quot;discarding no candidates&quot;</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">discard_message = </span><span class="s4">&quot;discarding {} non-matches:</span><span class="s3">\n  </span><span class="s4">{}&quot;</span><span class="s1">.format(</span>
            <span class="s1">len(non_matches)</span><span class="s3">,</span>
            <span class="s4">&quot;</span><span class="s3">\n  </span><span class="s4">&quot;</span><span class="s1">.join(str(candidate.link) </span><span class="s3">for </span><span class="s1">candidate </span><span class="s3">in </span><span class="s1">non_matches)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">logger.debug(</span>
        <span class="s4">&quot;Checked %s links for project %r against %s hashes &quot;</span>
        <span class="s4">&quot;(%s matches, %s no digest): %s&quot;</span><span class="s3">,</span>
        <span class="s1">len(candidates)</span><span class="s3">,</span>
        <span class="s1">project_name</span><span class="s3">,</span>
        <span class="s1">hashes.digest_count</span><span class="s3">,</span>
        <span class="s1">match_count</span><span class="s3">,</span>
        <span class="s1">len(matches_or_no_digest) - match_count</span><span class="s3">,</span>
        <span class="s1">discard_message</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">filtered</span>


<span class="s3">class </span><span class="s1">CandidatePreferences:</span>

    <span class="s0">&quot;&quot;&quot; 
    Encapsulates some of the preferences for filtering and sorting 
    InstallationCandidate objects. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">prefer_binary: bool = </span><span class="s3">False,</span>
        <span class="s1">allow_all_prereleases: bool = </span><span class="s3">False,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        :param allow_all_prereleases: Whether to allow all pre-releases. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.allow_all_prereleases = allow_all_prereleases</span>
        <span class="s1">self.prefer_binary = prefer_binary</span>


<span class="s3">class </span><span class="s1">BestCandidateResult:</span>
    <span class="s0">&quot;&quot;&quot;A collection of candidates, returned by `PackageFinder.find_best_candidate`. 
 
    This class is only intended to be instantiated by CandidateEvaluator's 
    `compute_best_candidate()` method. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">candidates: List[InstallationCandidate]</span><span class="s3">,</span>
        <span class="s1">applicable_candidates: List[InstallationCandidate]</span><span class="s3">,</span>
        <span class="s1">best_candidate: Optional[InstallationCandidate]</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        :param candidates: A sequence of all available candidates found. 
        :param applicable_candidates: The applicable candidates. 
        :param best_candidate: The most preferred candidate found, or None 
            if no applicable candidates were found. 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">set(applicable_candidates) &lt;= set(candidates)</span>

        <span class="s3">if </span><span class="s1">best_candidate </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">assert not </span><span class="s1">applicable_candidates</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">best_candidate </span><span class="s3">in </span><span class="s1">applicable_candidates</span>

        <span class="s1">self._applicable_candidates = applicable_candidates</span>
        <span class="s1">self._candidates = candidates</span>

        <span class="s1">self.best_candidate = best_candidate</span>

    <span class="s3">def </span><span class="s1">iter_all(self) -&gt; Iterable[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot;Iterate through all candidates.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">iter(self._candidates)</span>

    <span class="s3">def </span><span class="s1">iter_applicable(self) -&gt; Iterable[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot;Iterate through the applicable candidates.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">iter(self._applicable_candidates)</span>


<span class="s3">class </span><span class="s1">CandidateEvaluator:</span>

    <span class="s0">&quot;&quot;&quot; 
    Responsible for filtering and sorting candidates for installation based 
    on what tags are valid. 
    &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">create(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">project_name: str</span><span class="s3">,</span>
        <span class="s1">target_python: Optional[TargetPython] = </span><span class="s3">None,</span>
        <span class="s1">prefer_binary: bool = </span><span class="s3">False,</span>
        <span class="s1">allow_all_prereleases: bool = </span><span class="s3">False,</span>
        <span class="s1">specifier: Optional[specifiers.BaseSpecifier] = </span><span class="s3">None,</span>
        <span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None,</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;CandidateEvaluator&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Create a CandidateEvaluator object. 
 
        :param target_python: The target Python interpreter to use when 
            checking compatibility. If None (the default), a TargetPython 
            object will be constructed from the running Python. 
        :param specifier: An optional object implementing `filter` 
            (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable 
            versions. 
        :param hashes: An optional collection of allowed hashes. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">target_python </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">target_python = TargetPython()</span>
        <span class="s3">if </span><span class="s1">specifier </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">specifier = specifiers.SpecifierSet()</span>

        <span class="s1">supported_tags = target_python.get_tags()</span>

        <span class="s3">return </span><span class="s1">cls(</span>
            <span class="s1">project_name=project_name</span><span class="s3">,</span>
            <span class="s1">supported_tags=supported_tags</span><span class="s3">,</span>
            <span class="s1">specifier=specifier</span><span class="s3">,</span>
            <span class="s1">prefer_binary=prefer_binary</span><span class="s3">,</span>
            <span class="s1">allow_all_prereleases=allow_all_prereleases</span><span class="s3">,</span>
            <span class="s1">hashes=hashes</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">project_name: str</span><span class="s3">,</span>
        <span class="s1">supported_tags: List[Tag]</span><span class="s3">,</span>
        <span class="s1">specifier: specifiers.BaseSpecifier</span><span class="s3">,</span>
        <span class="s1">prefer_binary: bool = </span><span class="s3">False,</span>
        <span class="s1">allow_all_prereleases: bool = </span><span class="s3">False,</span>
        <span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        :param supported_tags: The PEP 425 tags supported by the target 
            Python in order of preference (most preferred first). 
        &quot;&quot;&quot;</span>
        <span class="s1">self._allow_all_prereleases = allow_all_prereleases</span>
        <span class="s1">self._hashes = hashes</span>
        <span class="s1">self._prefer_binary = prefer_binary</span>
        <span class="s1">self._project_name = project_name</span>
        <span class="s1">self._specifier = specifier</span>
        <span class="s1">self._supported_tags = supported_tags</span>
        <span class="s2"># Since the index of the tag in the _supported_tags list is used</span>
        <span class="s2"># as a priority, precompute a map from tag to index/priority to be</span>
        <span class="s2"># used in wheel.find_most_preferred_tag.</span>
        <span class="s1">self._wheel_tag_preferences = {</span>
            <span class="s1">tag: idx </span><span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">enumerate(supported_tags)</span>
        <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">get_applicable_candidates(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">candidates: List[InstallationCandidate]</span><span class="s3">,</span>
    <span class="s1">) -&gt; List[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the applicable candidates from a list of candidates. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Using None infers from the specifier instead.</span>
        <span class="s1">allow_prereleases = self._allow_all_prereleases </span><span class="s3">or None</span>
        <span class="s1">specifier = self._specifier</span>
        <span class="s1">versions = {</span>
            <span class="s1">str(v)</span>
            <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">specifier.filter(</span>
                <span class="s2"># We turn the version object into a str here because otherwise</span>
                <span class="s2"># when we're debundled but setuptools isn't, Python will see</span>
                <span class="s2"># packaging.version.Version and</span>
                <span class="s2"># pkg_resources._vendor.packaging.version.Version as different</span>
                <span class="s2"># types. This way we'll use a str as a common data interchange</span>
                <span class="s2"># format. If we stop using the pkg_resources provided specifier</span>
                <span class="s2"># and start using our own, we can drop the cast to str().</span>
                <span class="s1">(str(c.version) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">candidates)</span><span class="s3">,</span>
                <span class="s1">prereleases=allow_prereleases</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s2"># Again, converting version to str to deal with debundling.</span>
        <span class="s1">applicable_candidates = [c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">candidates </span><span class="s3">if </span><span class="s1">str(c.version) </span><span class="s3">in </span><span class="s1">versions]</span>

        <span class="s1">filtered_applicable_candidates = filter_unallowed_hashes(</span>
            <span class="s1">candidates=applicable_candidates</span><span class="s3">,</span>
            <span class="s1">hashes=self._hashes</span><span class="s3">,</span>
            <span class="s1">project_name=self._project_name</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">sorted(filtered_applicable_candidates</span><span class="s3">, </span><span class="s1">key=self._sort_key)</span>

    <span class="s3">def </span><span class="s1">_sort_key(self</span><span class="s3">, </span><span class="s1">candidate: InstallationCandidate) -&gt; CandidateSortingKey:</span>
        <span class="s0">&quot;&quot;&quot; 
        Function to pass as the `key` argument to a call to sorted() to sort 
        InstallationCandidates by preference. 
 
        Returns a tuple such that tuples sorting as greater using Python's 
        default comparison operator are more preferred. 
 
        The preference is as follows: 
 
        First and foremost, candidates with allowed (matching) hashes are 
        always preferred over candidates without matching hashes. This is 
        because e.g. if the only candidate with an allowed hash is yanked, 
        we still want to use that candidate. 
 
        Second, excepting hash considerations, candidates that have been 
        yanked (in the sense of PEP 592) are always less preferred than 
        candidates that haven't been yanked. Then: 
 
        If not finding wheels, they are sorted by version only. 
        If finding wheels, then the sort order is by version, then: 
          1. existing installs 
          2. wheels ordered via Wheel.support_index_min(self._supported_tags) 
          3. source archives 
        If prefer_binary was set, then all wheels are sorted above sources. 
 
        Note: it was considered to embed this logic into the Link 
              comparison operators, but then different sdist links 
              with the same version, would have to be considered equal 
        &quot;&quot;&quot;</span>
        <span class="s1">valid_tags = self._supported_tags</span>
        <span class="s1">support_num = len(valid_tags)</span>
        <span class="s1">build_tag: BuildTag = ()</span>
        <span class="s1">binary_preference = </span><span class="s5">0</span>
        <span class="s1">link = candidate.link</span>
        <span class="s3">if </span><span class="s1">link.is_wheel:</span>
            <span class="s2"># can raise InvalidWheelFilename</span>
            <span class="s1">wheel = Wheel(link.filename)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">pri = -(</span>
                    <span class="s1">wheel.find_most_preferred_tag(</span>
                        <span class="s1">valid_tags</span><span class="s3">, </span><span class="s1">self._wheel_tag_preferences</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s3">raise </span><span class="s1">UnsupportedWheel(</span>
                    <span class="s4">&quot;{} is not a supported wheel for this platform. It &quot;</span>
                    <span class="s4">&quot;can't be sorted.&quot;</span><span class="s1">.format(wheel.filename)</span>
                <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">self._prefer_binary:</span>
                <span class="s1">binary_preference = </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">wheel.build_tag </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">match = re.match(</span><span class="s4">r&quot;^(\d+)(.*)$&quot;</span><span class="s3">, </span><span class="s1">wheel.build_tag)</span>
                <span class="s1">build_tag_groups = match.groups()</span>
                <span class="s1">build_tag = (int(build_tag_groups[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">build_tag_groups[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s2"># sdist</span>
            <span class="s1">pri = -(support_num)</span>
        <span class="s1">has_allowed_hash = int(link.is_hash_allowed(self._hashes))</span>
        <span class="s1">yank_value = -</span><span class="s5">1 </span><span class="s1">* int(link.is_yanked)  </span><span class="s2"># -1 for yanked.</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">has_allowed_hash</span><span class="s3">,</span>
            <span class="s1">yank_value</span><span class="s3">,</span>
            <span class="s1">binary_preference</span><span class="s3">,</span>
            <span class="s1">candidate.version</span><span class="s3">,</span>
            <span class="s1">pri</span><span class="s3">,</span>
            <span class="s1">build_tag</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">sort_best_candidate(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">candidates: List[InstallationCandidate]</span><span class="s3">,</span>
    <span class="s1">) -&gt; Optional[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the best candidate per the instance's sort order, or None if 
        no candidate is acceptable. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">candidates:</span>
            <span class="s3">return None</span>
        <span class="s1">best_candidate = max(candidates</span><span class="s3">, </span><span class="s1">key=self._sort_key)</span>
        <span class="s3">return </span><span class="s1">best_candidate</span>

    <span class="s3">def </span><span class="s1">compute_best_candidate(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">candidates: List[InstallationCandidate]</span><span class="s3">,</span>
    <span class="s1">) -&gt; BestCandidateResult:</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute and return a `BestCandidateResult` instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">applicable_candidates = self.get_applicable_candidates(candidates)</span>

        <span class="s1">best_candidate = self.sort_best_candidate(applicable_candidates)</span>

        <span class="s3">return </span><span class="s1">BestCandidateResult(</span>
            <span class="s1">candidates</span><span class="s3">,</span>
            <span class="s1">applicable_candidates=applicable_candidates</span><span class="s3">,</span>
            <span class="s1">best_candidate=best_candidate</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">PackageFinder:</span>
    <span class="s0">&quot;&quot;&quot;This finds packages. 
 
    This is meant to match easy_install's technique for looking for 
    packages, by reading pages and looking for appropriate links. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">link_collector: LinkCollector</span><span class="s3">,</span>
        <span class="s1">target_python: TargetPython</span><span class="s3">,</span>
        <span class="s1">allow_yanked: bool</span><span class="s3">,</span>
        <span class="s1">use_deprecated_html5lib: bool</span><span class="s3">,</span>
        <span class="s1">format_control: Optional[FormatControl] = </span><span class="s3">None,</span>
        <span class="s1">candidate_prefs: Optional[CandidatePreferences] = </span><span class="s3">None,</span>
        <span class="s1">ignore_requires_python: Optional[bool] = </span><span class="s3">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        This constructor is primarily meant to be used by the create() class 
        method and from tests. 
 
        :param format_control: A FormatControl object, used to control 
            the selection of source packages / binary packages when consulting 
            the index and links. 
        :param candidate_prefs: Options to use when creating a 
            CandidateEvaluator object. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">candidate_prefs </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">candidate_prefs = CandidatePreferences()</span>

        <span class="s1">format_control = format_control </span><span class="s3">or </span><span class="s1">FormatControl(set()</span><span class="s3">, </span><span class="s1">set())</span>

        <span class="s1">self._allow_yanked = allow_yanked</span>
        <span class="s1">self._candidate_prefs = candidate_prefs</span>
        <span class="s1">self._ignore_requires_python = ignore_requires_python</span>
        <span class="s1">self._link_collector = link_collector</span>
        <span class="s1">self._target_python = target_python</span>
        <span class="s1">self._use_deprecated_html5lib = use_deprecated_html5lib</span>

        <span class="s1">self.format_control = format_control</span>

        <span class="s2"># These are boring links that have already been logged somehow.</span>
        <span class="s1">self._logged_links: Set[Link] = set()</span>

    <span class="s2"># Don't include an allow_yanked default value to make sure each call</span>
    <span class="s2"># site considers whether yanked releases are allowed. This also causes</span>
    <span class="s2"># that decision to be made explicit in the calling code, which helps</span>
    <span class="s2"># people when reading the code.</span>
    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">create(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">link_collector: LinkCollector</span><span class="s3">,</span>
        <span class="s1">selection_prefs: SelectionPreferences</span><span class="s3">,</span>
        <span class="s1">target_python: Optional[TargetPython] = </span><span class="s3">None,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">use_deprecated_html5lib: bool</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;PackageFinder&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Create a PackageFinder. 
 
        :param selection_prefs: The candidate selection preferences, as a 
            SelectionPreferences object. 
        :param target_python: The target Python interpreter to use when 
            checking compatibility. If None (the default), a TargetPython 
            object will be constructed from the running Python. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">target_python </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">target_python = TargetPython()</span>

        <span class="s1">candidate_prefs = CandidatePreferences(</span>
            <span class="s1">prefer_binary=selection_prefs.prefer_binary</span><span class="s3">,</span>
            <span class="s1">allow_all_prereleases=selection_prefs.allow_all_prereleases</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">cls(</span>
            <span class="s1">candidate_prefs=candidate_prefs</span><span class="s3">,</span>
            <span class="s1">link_collector=link_collector</span><span class="s3">,</span>
            <span class="s1">target_python=target_python</span><span class="s3">,</span>
            <span class="s1">allow_yanked=selection_prefs.allow_yanked</span><span class="s3">,</span>
            <span class="s1">format_control=selection_prefs.format_control</span><span class="s3">,</span>
            <span class="s1">ignore_requires_python=selection_prefs.ignore_requires_python</span><span class="s3">,</span>
            <span class="s1">use_deprecated_html5lib=use_deprecated_html5lib</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">target_python(self) -&gt; TargetPython:</span>
        <span class="s3">return </span><span class="s1">self._target_python</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">search_scope(self) -&gt; SearchScope:</span>
        <span class="s3">return </span><span class="s1">self._link_collector.search_scope</span>

    <span class="s1">@search_scope.setter</span>
    <span class="s3">def </span><span class="s1">search_scope(self</span><span class="s3">, </span><span class="s1">search_scope: SearchScope) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._link_collector.search_scope = search_scope</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">find_links(self) -&gt; List[str]:</span>
        <span class="s3">return </span><span class="s1">self._link_collector.find_links</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">index_urls(self) -&gt; List[str]:</span>
        <span class="s3">return </span><span class="s1">self.search_scope.index_urls</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">trusted_hosts(self) -&gt; Iterable[str]:</span>
        <span class="s3">for </span><span class="s1">host_port </span><span class="s3">in </span><span class="s1">self._link_collector.session.pip_trusted_origins:</span>
            <span class="s3">yield </span><span class="s1">build_netloc(*host_port)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">allow_all_prereleases(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self._candidate_prefs.allow_all_prereleases</span>

    <span class="s3">def </span><span class="s1">set_allow_all_prereleases(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._candidate_prefs.allow_all_prereleases = </span><span class="s3">True</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">prefer_binary(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self._candidate_prefs.prefer_binary</span>

    <span class="s3">def </span><span class="s1">set_prefer_binary(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._candidate_prefs.prefer_binary = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">make_link_evaluator(self</span><span class="s3">, </span><span class="s1">project_name: str) -&gt; LinkEvaluator:</span>
        <span class="s1">canonical_name = canonicalize_name(project_name)</span>
        <span class="s1">formats = self.format_control.get_allowed_formats(canonical_name)</span>

        <span class="s3">return </span><span class="s1">LinkEvaluator(</span>
            <span class="s1">project_name=project_name</span><span class="s3">,</span>
            <span class="s1">canonical_name=canonical_name</span><span class="s3">,</span>
            <span class="s1">formats=formats</span><span class="s3">,</span>
            <span class="s1">target_python=self._target_python</span><span class="s3">,</span>
            <span class="s1">allow_yanked=self._allow_yanked</span><span class="s3">,</span>
            <span class="s1">ignore_requires_python=self._ignore_requires_python</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_sort_links(self</span><span class="s3">, </span><span class="s1">links: Iterable[Link]) -&gt; List[Link]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns elements of links in order, non-egg links first, egg links 
        second, while eliminating duplicates 
        &quot;&quot;&quot;</span>
        <span class="s1">eggs</span><span class="s3">, </span><span class="s1">no_eggs = []</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s1">seen: Set[Link] = set()</span>
        <span class="s3">for </span><span class="s1">link </span><span class="s3">in </span><span class="s1">links:</span>
            <span class="s3">if </span><span class="s1">link </span><span class="s3">not in </span><span class="s1">seen:</span>
                <span class="s1">seen.add(link)</span>
                <span class="s3">if </span><span class="s1">link.egg_fragment:</span>
                    <span class="s1">eggs.append(link)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">no_eggs.append(link)</span>
        <span class="s3">return </span><span class="s1">no_eggs + eggs</span>

    <span class="s3">def </span><span class="s1">_log_skipped_link(self</span><span class="s3">, </span><span class="s1">link: Link</span><span class="s3">, </span><span class="s1">reason: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">not in </span><span class="s1">self._logged_links:</span>
            <span class="s2"># Put the link at the end so the reason is more visible and because</span>
            <span class="s2"># the link string is usually very long.</span>
            <span class="s1">logger.debug(</span><span class="s4">&quot;Skipping link: %s: %s&quot;</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">, </span><span class="s1">link)</span>
            <span class="s1">self._logged_links.add(link)</span>

    <span class="s3">def </span><span class="s1">get_install_candidate(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">link_evaluator: LinkEvaluator</span><span class="s3">, </span><span class="s1">link: Link</span>
    <span class="s1">) -&gt; Optional[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot; 
        If the link is a candidate for install, convert it to an 
        InstallationCandidate and return it. Otherwise, return None. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_candidate</span><span class="s3">, </span><span class="s1">result = link_evaluator.evaluate_link(link)</span>
        <span class="s3">if not </span><span class="s1">is_candidate:</span>
            <span class="s3">if </span><span class="s1">result:</span>
                <span class="s1">self._log_skipped_link(link</span><span class="s3">, </span><span class="s1">reason=result)</span>
            <span class="s3">return None</span>

        <span class="s3">return </span><span class="s1">InstallationCandidate(</span>
            <span class="s1">name=link_evaluator.project_name</span><span class="s3">,</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">version=result</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">evaluate_links(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">link_evaluator: LinkEvaluator</span><span class="s3">, </span><span class="s1">links: Iterable[Link]</span>
    <span class="s1">) -&gt; List[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert links that are candidates to InstallationCandidate objects. 
        &quot;&quot;&quot;</span>
        <span class="s1">candidates = []</span>
        <span class="s3">for </span><span class="s1">link </span><span class="s3">in </span><span class="s1">self._sort_links(links):</span>
            <span class="s1">candidate = self.get_install_candidate(link_evaluator</span><span class="s3">, </span><span class="s1">link)</span>
            <span class="s3">if </span><span class="s1">candidate </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">candidates.append(candidate)</span>

        <span class="s3">return </span><span class="s1">candidates</span>

    <span class="s3">def </span><span class="s1">process_project_url(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">project_url: Link</span><span class="s3">, </span><span class="s1">link_evaluator: LinkEvaluator</span>
    <span class="s1">) -&gt; List[InstallationCandidate]:</span>
        <span class="s1">logger.debug(</span>
            <span class="s4">&quot;Fetching project page and analyzing links: %s&quot;</span><span class="s3">,</span>
            <span class="s1">project_url</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">html_page = self._link_collector.fetch_page(project_url)</span>
        <span class="s3">if </span><span class="s1">html_page </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s1">page_links = list(parse_links(html_page</span><span class="s3">, </span><span class="s1">self._use_deprecated_html5lib))</span>

        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s1">package_links = self.evaluate_links(</span>
                <span class="s1">link_evaluator</span><span class="s3">,</span>
                <span class="s1">links=page_links</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">package_links</span>

    <span class="s1">@functools.lru_cache(maxsize=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">find_all_candidates(self</span><span class="s3">, </span><span class="s1">project_name: str) -&gt; List[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot;Find all available InstallationCandidate for project_name 
 
        This checks index_urls and find_links. 
        All versions found are returned as an InstallationCandidate list. 
 
        See LinkEvaluator.evaluate_link() for details on which files 
        are accepted. 
        &quot;&quot;&quot;</span>
        <span class="s1">link_evaluator = self.make_link_evaluator(project_name)</span>

        <span class="s1">collected_sources = self._link_collector.collect_sources(</span>
            <span class="s1">project_name=project_name</span><span class="s3">,</span>
            <span class="s1">candidates_from_page=functools.partial(</span>
                <span class="s1">self.process_project_url</span><span class="s3">,</span>
                <span class="s1">link_evaluator=link_evaluator</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">page_candidates_it = itertools.chain.from_iterable(</span>
            <span class="s1">source.page_candidates()</span>
            <span class="s3">for </span><span class="s1">sources </span><span class="s3">in </span><span class="s1">collected_sources</span>
            <span class="s3">for </span><span class="s1">source </span><span class="s3">in </span><span class="s1">sources</span>
            <span class="s3">if </span><span class="s1">source </span><span class="s3">is not None</span>
        <span class="s1">)</span>
        <span class="s1">page_candidates = list(page_candidates_it)</span>

        <span class="s1">file_links_it = itertools.chain.from_iterable(</span>
            <span class="s1">source.file_links()</span>
            <span class="s3">for </span><span class="s1">sources </span><span class="s3">in </span><span class="s1">collected_sources</span>
            <span class="s3">for </span><span class="s1">source </span><span class="s3">in </span><span class="s1">sources</span>
            <span class="s3">if </span><span class="s1">source </span><span class="s3">is not None</span>
        <span class="s1">)</span>
        <span class="s1">file_candidates = self.evaluate_links(</span>
            <span class="s1">link_evaluator</span><span class="s3">,</span>
            <span class="s1">sorted(file_links_it</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">logger.isEnabledFor(logging.DEBUG) </span><span class="s3">and </span><span class="s1">file_candidates:</span>
            <span class="s1">paths = []</span>
            <span class="s3">for </span><span class="s1">candidate </span><span class="s3">in </span><span class="s1">file_candidates:</span>
                <span class="s3">assert </span><span class="s1">candidate.link.url  </span><span class="s2"># we need to have a URL</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">paths.append(candidate.link.file_path)</span>
                <span class="s3">except </span><span class="s1">Exception:</span>
                    <span class="s1">paths.append(candidate.link.url)  </span><span class="s2"># it's not a local file</span>

            <span class="s1">logger.debug(</span><span class="s4">&quot;Local files found: %s&quot;</span><span class="s3">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(paths))</span>

        <span class="s2"># This is an intentional priority ordering</span>
        <span class="s3">return </span><span class="s1">file_candidates + page_candidates</span>

    <span class="s3">def </span><span class="s1">make_candidate_evaluator(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">project_name: str</span><span class="s3">,</span>
        <span class="s1">specifier: Optional[specifiers.BaseSpecifier] = </span><span class="s3">None,</span>
        <span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None,</span>
    <span class="s1">) -&gt; CandidateEvaluator:</span>
        <span class="s0">&quot;&quot;&quot;Create a CandidateEvaluator object to use.&quot;&quot;&quot;</span>
        <span class="s1">candidate_prefs = self._candidate_prefs</span>
        <span class="s3">return </span><span class="s1">CandidateEvaluator.create(</span>
            <span class="s1">project_name=project_name</span><span class="s3">,</span>
            <span class="s1">target_python=self._target_python</span><span class="s3">,</span>
            <span class="s1">prefer_binary=candidate_prefs.prefer_binary</span><span class="s3">,</span>
            <span class="s1">allow_all_prereleases=candidate_prefs.allow_all_prereleases</span><span class="s3">,</span>
            <span class="s1">specifier=specifier</span><span class="s3">,</span>
            <span class="s1">hashes=hashes</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@functools.lru_cache(maxsize=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">find_best_candidate(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">project_name: str</span><span class="s3">,</span>
        <span class="s1">specifier: Optional[specifiers.BaseSpecifier] = </span><span class="s3">None,</span>
        <span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None,</span>
    <span class="s1">) -&gt; BestCandidateResult:</span>
        <span class="s0">&quot;&quot;&quot;Find matches for the given project and specifier. 
 
        :param specifier: An optional object implementing `filter` 
            (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable 
            versions. 
 
        :return: A `BestCandidateResult` instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">candidates = self.find_all_candidates(project_name)</span>
        <span class="s1">candidate_evaluator = self.make_candidate_evaluator(</span>
            <span class="s1">project_name=project_name</span><span class="s3">,</span>
            <span class="s1">specifier=specifier</span><span class="s3">,</span>
            <span class="s1">hashes=hashes</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">candidate_evaluator.compute_best_candidate(candidates)</span>

    <span class="s3">def </span><span class="s1">find_requirement(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">req: InstallRequirement</span><span class="s3">, </span><span class="s1">upgrade: bool</span>
    <span class="s1">) -&gt; Optional[InstallationCandidate]:</span>
        <span class="s0">&quot;&quot;&quot;Try to find a Link matching req 
 
        Expects req, an InstallRequirement and upgrade, a boolean 
        Returns a InstallationCandidate if found, 
        Raises DistributionNotFound or BestVersionAlreadyInstalled otherwise 
        &quot;&quot;&quot;</span>
        <span class="s1">hashes = req.hashes(trust_internet=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">best_candidate_result = self.find_best_candidate(</span>
            <span class="s1">req.name</span><span class="s3">,</span>
            <span class="s1">specifier=req.specifier</span><span class="s3">,</span>
            <span class="s1">hashes=hashes</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">best_candidate = best_candidate_result.best_candidate</span>

        <span class="s1">installed_version: Optional[_BaseVersion] = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">req.satisfied_by </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">installed_version = req.satisfied_by.version</span>

        <span class="s3">def </span><span class="s1">_format_versions(cand_iter: Iterable[InstallationCandidate]) -&gt; str:</span>
            <span class="s2"># This repeated parse_version and str() conversion is needed to</span>
            <span class="s2"># handle different vendoring sources from pip and pkg_resources.</span>
            <span class="s2"># If we stop using the pkg_resources provided specifier and start</span>
            <span class="s2"># using our own, we can drop the cast to str().</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s1">sorted(</span>
                        <span class="s1">{str(c.version) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cand_iter}</span><span class="s3">,</span>
                        <span class="s1">key=parse_version</span><span class="s3">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s3">or </span><span class="s4">&quot;none&quot;</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">installed_version </span><span class="s3">is None and </span><span class="s1">best_candidate </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">logger.critical(</span>
                <span class="s4">&quot;Could not find a version that satisfies the requirement %s &quot;</span>
                <span class="s4">&quot;(from versions: %s)&quot;</span><span class="s3">,</span>
                <span class="s1">req</span><span class="s3">,</span>
                <span class="s1">_format_versions(best_candidate_result.iter_all())</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s3">raise </span><span class="s1">DistributionNotFound(</span>
                <span class="s4">&quot;No matching distribution found for {}&quot;</span><span class="s1">.format(req)</span>
            <span class="s1">)</span>

        <span class="s1">best_installed = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">installed_version </span><span class="s3">and </span><span class="s1">(</span>
            <span class="s1">best_candidate </span><span class="s3">is None or </span><span class="s1">best_candidate.version &lt;= installed_version</span>
        <span class="s1">):</span>
            <span class="s1">best_installed = </span><span class="s3">True</span>

        <span class="s3">if not </span><span class="s1">upgrade </span><span class="s3">and </span><span class="s1">installed_version </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">best_installed:</span>
                <span class="s1">logger.debug(</span>
                    <span class="s4">&quot;Existing installed version (%s) is most up-to-date and &quot;</span>
                    <span class="s4">&quot;satisfies requirement&quot;</span><span class="s3">,</span>
                    <span class="s1">installed_version</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">logger.debug(</span>
                    <span class="s4">&quot;Existing installed version (%s) satisfies requirement &quot;</span>
                    <span class="s4">&quot;(most up-to-date version is %s)&quot;</span><span class="s3">,</span>
                    <span class="s1">installed_version</span><span class="s3">,</span>
                    <span class="s1">best_candidate.version</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">best_installed:</span>
            <span class="s2"># We have an existing version, and its the best version</span>
            <span class="s1">logger.debug(</span>
                <span class="s4">&quot;Installed version (%s) is most up-to-date (past versions: %s)&quot;</span><span class="s3">,</span>
                <span class="s1">installed_version</span><span class="s3">,</span>
                <span class="s1">_format_versions(best_candidate_result.iter_applicable())</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">BestVersionAlreadyInstalled</span>

        <span class="s1">logger.debug(</span>
            <span class="s4">&quot;Using version %s (newest of versions: %s)&quot;</span><span class="s3">,</span>
            <span class="s1">best_candidate.version</span><span class="s3">,</span>
            <span class="s1">_format_versions(best_candidate_result.iter_applicable())</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">best_candidate</span>


<span class="s3">def </span><span class="s1">_find_name_version_sep(fragment: str</span><span class="s3">, </span><span class="s1">canonical_name: str) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot;Find the separator's index based on the package's canonical name. 
 
    :param fragment: A &lt;package&gt;+&lt;version&gt; filename &quot;fragment&quot; (stem) or 
        egg fragment. 
    :param canonical_name: The package's canonical name. 
 
    This function is needed since the canonicalized name does not necessarily 
    have the same length as the egg info's name part. An example:: 
 
    &gt;&gt;&gt; fragment = 'foo__bar-1.0' 
    &gt;&gt;&gt; canonical_name = 'foo-bar' 
    &gt;&gt;&gt; _find_name_version_sep(fragment, canonical_name) 
    8 
    &quot;&quot;&quot;</span>
    <span class="s2"># Project name and version must be separated by one single dash. Find all</span>
    <span class="s2"># occurrences of dashes; if the string in front of it matches the canonical</span>
    <span class="s2"># name, this is the one separating the name and version parts.</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">enumerate(fragment):</span>
        <span class="s3">if </span><span class="s1">c != </span><span class="s4">&quot;-&quot;</span><span class="s1">:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">canonicalize_name(fragment[:i]) == canonical_name:</span>
            <span class="s3">return </span><span class="s1">i</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">fragment</span><span class="s3">} </span><span class="s4">does not match </span><span class="s3">{</span><span class="s1">canonical_name</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_extract_version_from_fragment(fragment: str</span><span class="s3">, </span><span class="s1">canonical_name: str) -&gt; Optional[str]:</span>
    <span class="s0">&quot;&quot;&quot;Parse the version string from a &lt;package&gt;+&lt;version&gt; filename 
    &quot;fragment&quot; (stem) or egg fragment. 
 
    :param fragment: The string to parse. E.g. foo-2.1 
    :param canonical_name: The canonicalized name of the package this 
        belongs to. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">version_start = _find_name_version_sep(fragment</span><span class="s3">, </span><span class="s1">canonical_name) + </span><span class="s5">1</span>
    <span class="s3">except </span><span class="s1">ValueError:</span>
        <span class="s3">return None</span>
    <span class="s1">version = fragment[version_start:]</span>
    <span class="s3">if not </span><span class="s1">version:</span>
        <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">version</span>
</pre>
</body>
</html>