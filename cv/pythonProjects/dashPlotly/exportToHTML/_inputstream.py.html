<html>
<head>
<title>_inputstream.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #a5c261;}
.s5 { color: #6897bb;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_inputstream.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span><span class="s0">, </span><span class="s1">division</span><span class="s0">, </span><span class="s1">unicode_literals</span>

<span class="s0">from </span><span class="s1">pip._vendor.six </span><span class="s0">import </span><span class="s1">text_type</span>
<span class="s0">from </span><span class="s1">pip._vendor.six.moves </span><span class="s0">import </span><span class="s1">http_client</span><span class="s0">, </span><span class="s1">urllib</span>

<span class="s0">import </span><span class="s1">codecs</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span><span class="s0">, </span><span class="s1">StringIO</span>

<span class="s0">from </span><span class="s1">pip._vendor </span><span class="s0">import </span><span class="s1">webencodings</span>

<span class="s0">from </span><span class="s1">.constants </span><span class="s0">import </span><span class="s1">EOF</span><span class="s0">, </span><span class="s1">spaceCharacters</span><span class="s0">, </span><span class="s1">asciiLetters</span><span class="s0">, </span><span class="s1">asciiUppercase</span>
<span class="s0">from </span><span class="s1">.constants </span><span class="s0">import </span><span class="s1">_ReparseException</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_utils</span>

<span class="s2"># Non-unicode versions of constants for use in the pre-parser</span>
<span class="s1">spaceCharactersBytes = frozenset([item.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">spaceCharacters])</span>
<span class="s1">asciiLettersBytes = frozenset([item.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">asciiLetters])</span>
<span class="s1">asciiUppercaseBytes = frozenset([item.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">asciiUppercase])</span>
<span class="s1">spacesAngleBrackets = spaceCharactersBytes | frozenset([</span><span class="s4">b&quot;&gt;&quot;</span><span class="s0">, </span><span class="s4">b&quot;&lt;&quot;</span><span class="s1">])</span>


<span class="s1">invalid_unicode_no_surrogate = </span><span class="s3">&quot;[</span><span class="s0">\u0001</span><span class="s3">-</span><span class="s0">\u0008\u000B\u000E</span><span class="s3">-</span><span class="s0">\u001F\u007F</span><span class="s3">-</span><span class="s0">\u009F\uFDD0</span><span class="s3">-</span><span class="s0">\uFDEF\uFFFE\uFFFF\U0001FFFE\U0001FFFF\U0002FFFE\U0002FFFF\U0003FFFE\U0003FFFF\U0004FFFE\U0004FFFF\U0005FFFE\U0005FFFF\U0006FFFE\U0006FFFF\U0007FFFE\U0007FFFF\U0008FFFE\U0008FFFF\U0009FFFE\U0009FFFF\U000AFFFE\U000AFFFF\U000BFFFE\U000BFFFF\U000CFFFE\U000CFFFF\U000DFFFE\U000DFFFF\U000EFFFE\U000EFFFF\U000FFFFE\U000FFFFF\U0010FFFE\U0010FFFF</span><span class="s3">]&quot;  </span><span class="s2"># noqa</span>

<span class="s0">if </span><span class="s1">_utils.supports_lone_surrogates:</span>
    <span class="s2"># Use one extra step of indirection and create surrogates with</span>
    <span class="s2"># eval. Not using this indirection would introduce an illegal</span>
    <span class="s2"># unicode literal on platforms not supporting such lone</span>
    <span class="s2"># surrogates.</span>
    <span class="s0">assert </span><span class="s1">invalid_unicode_no_surrogate[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;]&quot; </span><span class="s0">and </span><span class="s1">invalid_unicode_no_surrogate.count(</span><span class="s3">&quot;]&quot;</span><span class="s1">) == </span><span class="s5">1</span>
    <span class="s1">invalid_unicode_re = re.compile(invalid_unicode_no_surrogate[:-</span><span class="s5">1</span><span class="s1">] +</span>
                                    <span class="s1">eval(</span><span class="s3">'&quot;</span><span class="s0">\\</span><span class="s3">uD800-</span><span class="s0">\\</span><span class="s3">uDFFF&quot;'</span><span class="s1">) +  </span><span class="s2"># pylint:disable=eval-used</span>
                                    <span class="s3">&quot;]&quot;</span><span class="s1">)</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">invalid_unicode_re = re.compile(invalid_unicode_no_surrogate)</span>

<span class="s1">non_bmp_invalid_codepoints = {</span><span class="s5">0x1FFFE</span><span class="s0">, </span><span class="s5">0x1FFFF</span><span class="s0">, </span><span class="s5">0x2FFFE</span><span class="s0">, </span><span class="s5">0x2FFFF</span><span class="s0">, </span><span class="s5">0x3FFFE</span><span class="s0">,</span>
                              <span class="s5">0x3FFFF</span><span class="s0">, </span><span class="s5">0x4FFFE</span><span class="s0">, </span><span class="s5">0x4FFFF</span><span class="s0">, </span><span class="s5">0x5FFFE</span><span class="s0">, </span><span class="s5">0x5FFFF</span><span class="s0">,</span>
                              <span class="s5">0x6FFFE</span><span class="s0">, </span><span class="s5">0x6FFFF</span><span class="s0">, </span><span class="s5">0x7FFFE</span><span class="s0">, </span><span class="s5">0x7FFFF</span><span class="s0">, </span><span class="s5">0x8FFFE</span><span class="s0">,</span>
                              <span class="s5">0x8FFFF</span><span class="s0">, </span><span class="s5">0x9FFFE</span><span class="s0">, </span><span class="s5">0x9FFFF</span><span class="s0">, </span><span class="s5">0xAFFFE</span><span class="s0">, </span><span class="s5">0xAFFFF</span><span class="s0">,</span>
                              <span class="s5">0xBFFFE</span><span class="s0">, </span><span class="s5">0xBFFFF</span><span class="s0">, </span><span class="s5">0xCFFFE</span><span class="s0">, </span><span class="s5">0xCFFFF</span><span class="s0">, </span><span class="s5">0xDFFFE</span><span class="s0">,</span>
                              <span class="s5">0xDFFFF</span><span class="s0">, </span><span class="s5">0xEFFFE</span><span class="s0">, </span><span class="s5">0xEFFFF</span><span class="s0">, </span><span class="s5">0xFFFFE</span><span class="s0">, </span><span class="s5">0xFFFFF</span><span class="s0">,</span>
                              <span class="s5">0x10FFFE</span><span class="s0">, </span><span class="s5">0x10FFFF</span><span class="s1">}</span>

<span class="s1">ascii_punctuation_re = re.compile(</span><span class="s3">&quot;[</span><span class="s0">\u0009</span><span class="s3">-</span><span class="s0">\u000D\u0020</span><span class="s3">-</span><span class="s0">\u002F\u003A</span><span class="s3">-</span><span class="s0">\u0040\u005C\u005B</span><span class="s3">-</span><span class="s0">\u0060\u007B</span><span class="s3">-</span><span class="s0">\u007E</span><span class="s3">]&quot;</span><span class="s1">)</span>

<span class="s2"># Cache for charsUntil()</span>
<span class="s1">charsUntilRegEx = {}</span>


<span class="s0">class </span><span class="s1">BufferedStream(object):</span>
    <span class="s6">&quot;&quot;&quot;Buffering for streams that do not have buffering of their own 
 
    The buffer is implemented as a list of chunks on the assumption that 
    joining many strings will be slow since it is O(n**2) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">stream):</span>
        <span class="s1">self.stream = stream</span>
        <span class="s1">self.buffer = []</span>
        <span class="s1">self.position = [-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s2"># chunk number, offset</span>

    <span class="s0">def </span><span class="s1">tell(self):</span>
        <span class="s1">pos = </span><span class="s5">0</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">self.buffer[:self.position[</span><span class="s5">0</span><span class="s1">]]:</span>
            <span class="s1">pos += len(chunk)</span>
        <span class="s1">pos += self.position[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">pos</span>

    <span class="s0">def </span><span class="s1">seek(self</span><span class="s0">, </span><span class="s1">pos):</span>
        <span class="s0">assert </span><span class="s1">pos &lt;= self._bufferedBytes()</span>
        <span class="s1">offset = pos</span>
        <span class="s1">i = </span><span class="s5">0</span>
        <span class="s0">while </span><span class="s1">len(self.buffer[i]) &lt; offset:</span>
            <span class="s1">offset -= len(self.buffer[i])</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s1">self.position = [i</span><span class="s0">, </span><span class="s1">offset]</span>

    <span class="s0">def </span><span class="s1">read(self</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s0">if not </span><span class="s1">self.buffer:</span>
            <span class="s0">return </span><span class="s1">self._readStream(bytes)</span>
        <span class="s0">elif </span><span class="s1">(self.position[</span><span class="s5">0</span><span class="s1">] == len(self.buffer) </span><span class="s0">and</span>
              <span class="s1">self.position[</span><span class="s5">1</span><span class="s1">] == len(self.buffer[-</span><span class="s5">1</span><span class="s1">])):</span>
            <span class="s0">return </span><span class="s1">self._readStream(bytes)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._readFromBuffer(bytes)</span>

    <span class="s0">def </span><span class="s1">_bufferedBytes(self):</span>
        <span class="s0">return </span><span class="s1">sum([len(item) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self.buffer])</span>

    <span class="s0">def </span><span class="s1">_readStream(self</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s1">data = self.stream.read(bytes)</span>
        <span class="s1">self.buffer.append(data)</span>
        <span class="s1">self.position[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>
        <span class="s1">self.position[</span><span class="s5">1</span><span class="s1">] = len(data)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">_readFromBuffer(self</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s1">remainingBytes = bytes</span>
        <span class="s1">rv = []</span>
        <span class="s1">bufferIndex = self.position[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">bufferOffset = self.position[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">while </span><span class="s1">bufferIndex &lt; len(self.buffer) </span><span class="s0">and </span><span class="s1">remainingBytes != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">remainingBytes &gt; </span><span class="s5">0</span>
            <span class="s1">bufferedData = self.buffer[bufferIndex]</span>

            <span class="s0">if </span><span class="s1">remainingBytes &lt;= len(bufferedData) - bufferOffset:</span>
                <span class="s1">bytesToRead = remainingBytes</span>
                <span class="s1">self.position = [bufferIndex</span><span class="s0">, </span><span class="s1">bufferOffset + bytesToRead]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bytesToRead = len(bufferedData) - bufferOffset</span>
                <span class="s1">self.position = [bufferIndex</span><span class="s0">, </span><span class="s1">len(bufferedData)]</span>
                <span class="s1">bufferIndex += </span><span class="s5">1</span>
            <span class="s1">rv.append(bufferedData[bufferOffset:bufferOffset + bytesToRead])</span>
            <span class="s1">remainingBytes -= bytesToRead</span>

            <span class="s1">bufferOffset = </span><span class="s5">0</span>

        <span class="s0">if </span><span class="s1">remainingBytes:</span>
            <span class="s1">rv.append(self._readStream(remainingBytes))</span>

        <span class="s0">return </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(rv)</span>


<span class="s0">def </span><span class="s1">HTMLInputStream(source</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s2"># Work around Python bug #20007: read(0) closes the connection.</span>
    <span class="s2"># http://bugs.python.org/issue20007</span>
    <span class="s0">if </span><span class="s1">(isinstance(source</span><span class="s0">, </span><span class="s1">http_client.HTTPResponse) </span><span class="s0">or</span>
        <span class="s2"># Also check for addinfourl wrapping HTTPResponse</span>
        <span class="s1">(isinstance(source</span><span class="s0">, </span><span class="s1">urllib.response.addbase) </span><span class="s0">and</span>
         <span class="s1">isinstance(source.fp</span><span class="s0">, </span><span class="s1">http_client.HTTPResponse))):</span>
        <span class="s1">isUnicode = </span><span class="s0">False</span>
    <span class="s0">elif </span><span class="s1">hasattr(source</span><span class="s0">, </span><span class="s3">&quot;read&quot;</span><span class="s1">):</span>
        <span class="s1">isUnicode = isinstance(source.read(</span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">text_type)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">isUnicode = isinstance(source</span><span class="s0">, </span><span class="s1">text_type)</span>

    <span class="s0">if </span><span class="s1">isUnicode:</span>
        <span class="s1">encodings = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">if </span><span class="s1">x.endswith(</span><span class="s3">&quot;_encoding&quot;</span><span class="s1">)]</span>
        <span class="s0">if </span><span class="s1">encodings:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot set an encoding with a unicode input, set %r&quot; </span><span class="s1">% encodings)</span>

        <span class="s0">return </span><span class="s1">HTMLUnicodeInputStream(source</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">HTMLBinaryInputStream(source</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">HTMLUnicodeInputStream(object):</span>
    <span class="s6">&quot;&quot;&quot;Provides a unicode stream of characters to the HTMLTokenizer. 
 
    This class takes care of character encoding and removing or replacing 
    incorrect byte-sequences and also provides column and line tracking. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_defaultChunkSize = </span><span class="s5">10240</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">source):</span>
        <span class="s6">&quot;&quot;&quot;Initialises the HTMLInputStream. 
 
        HTMLInputStream(source, [encoding]) -&gt; Normalized stream from source 
        for use by html5lib. 
 
        source can be either a file-object, local filename or a string. 
 
        The optional encoding parameter must be a string that indicates 
        the encoding.  If specified, that encoding will be used, 
        regardless of any BOM or later declaration (such as in a meta 
        element) 
 
        &quot;&quot;&quot;</span>

        <span class="s0">if not </span><span class="s1">_utils.supports_lone_surrogates:</span>
            <span class="s2"># Such platforms will have already checked for such</span>
            <span class="s2"># surrogate errors, so no need to do this checking.</span>
            <span class="s1">self.reportCharacterErrors = </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">len(</span><span class="s3">&quot;</span><span class="s0">\U0010FFFF</span><span class="s3">&quot;</span><span class="s1">) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.reportCharacterErrors = self.characterErrorsUCS4</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.reportCharacterErrors = self.characterErrorsUCS2</span>

        <span class="s2"># List of where new lines occur</span>
        <span class="s1">self.newLines = [</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">self.charEncoding = (lookupEncoding(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">&quot;certain&quot;</span><span class="s1">)</span>
        <span class="s1">self.dataStream = self.openStream(source)</span>

        <span class="s1">self.reset()</span>

    <span class="s0">def </span><span class="s1">reset(self):</span>
        <span class="s1">self.chunk = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.chunkSize = </span><span class="s5">0</span>
        <span class="s1">self.chunkOffset = </span><span class="s5">0</span>
        <span class="s1">self.errors = []</span>

        <span class="s2"># number of (complete) lines in previous chunks</span>
        <span class="s1">self.prevNumLines = </span><span class="s5">0</span>
        <span class="s2"># number of columns in the last line of the previous chunk</span>
        <span class="s1">self.prevNumCols = </span><span class="s5">0</span>

        <span class="s2"># Deal with CR LF and surrogates split over chunk boundaries</span>
        <span class="s1">self._bufferedCharacter = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">openStream(self</span><span class="s0">, </span><span class="s1">source):</span>
        <span class="s6">&quot;&quot;&quot;Produces a file object from source. 
 
        source can be either a file object, local filename or a string. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Already a file object</span>
        <span class="s0">if </span><span class="s1">hasattr(source</span><span class="s0">, </span><span class="s3">'read'</span><span class="s1">):</span>
            <span class="s1">stream = source</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">stream = StringIO(source)</span>

        <span class="s0">return </span><span class="s1">stream</span>

    <span class="s0">def </span><span class="s1">_position(self</span><span class="s0">, </span><span class="s1">offset):</span>
        <span class="s1">chunk = self.chunk</span>
        <span class="s1">nLines = chunk.count(</span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s1">positionLine = self.prevNumLines + nLines</span>
        <span class="s1">lastLinePos = chunk.rfind(</span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s0">if </span><span class="s1">lastLinePos == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">positionColumn = self.prevNumCols + offset</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">positionColumn = offset - (lastLinePos + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">(positionLine</span><span class="s0">, </span><span class="s1">positionColumn)</span>

    <span class="s0">def </span><span class="s1">position(self):</span>
        <span class="s6">&quot;&quot;&quot;Returns (line, col) of the current position in the stream.&quot;&quot;&quot;</span>
        <span class="s1">line</span><span class="s0">, </span><span class="s1">col = self._position(self.chunkOffset)</span>
        <span class="s0">return </span><span class="s1">(line + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">col)</span>

    <span class="s0">def </span><span class="s1">char(self):</span>
        <span class="s6">&quot;&quot;&quot; Read one character from the stream or queue if available. Return 
            EOF when EOF is reached. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Read a new chunk from the input stream if necessary</span>
        <span class="s0">if </span><span class="s1">self.chunkOffset &gt;= self.chunkSize:</span>
            <span class="s0">if not </span><span class="s1">self.readChunk():</span>
                <span class="s0">return </span><span class="s1">EOF</span>

        <span class="s1">chunkOffset = self.chunkOffset</span>
        <span class="s1">char = self.chunk[chunkOffset]</span>
        <span class="s1">self.chunkOffset = chunkOffset + </span><span class="s5">1</span>

        <span class="s0">return </span><span class="s1">char</span>

    <span class="s0">def </span><span class="s1">readChunk(self</span><span class="s0">, </span><span class="s1">chunkSize=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">chunkSize </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">chunkSize = self._defaultChunkSize</span>

        <span class="s1">self.prevNumLines</span><span class="s0">, </span><span class="s1">self.prevNumCols = self._position(self.chunkSize)</span>

        <span class="s1">self.chunk = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.chunkSize = </span><span class="s5">0</span>
        <span class="s1">self.chunkOffset = </span><span class="s5">0</span>

        <span class="s1">data = self.dataStream.read(chunkSize)</span>

        <span class="s2"># Deal with CR LF and surrogates broken across chunks</span>
        <span class="s0">if </span><span class="s1">self._bufferedCharacter:</span>
            <span class="s1">data = self._bufferedCharacter + data</span>
            <span class="s1">self._bufferedCharacter = </span><span class="s0">None</span>
        <span class="s0">elif not </span><span class="s1">data:</span>
            <span class="s2"># We have no more data, bye-bye stream</span>
            <span class="s0">return False</span>

        <span class="s0">if </span><span class="s1">len(data) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">lastv = ord(data[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">lastv == </span><span class="s5">0x0D </span><span class="s0">or </span><span class="s5">0xD800 </span><span class="s1">&lt;= lastv &lt;= </span><span class="s5">0xDBFF</span><span class="s1">:</span>
                <span class="s1">self._bufferedCharacter = data[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">data = data[:-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">self.reportCharacterErrors:</span>
            <span class="s1">self.reportCharacterErrors(data)</span>

        <span class="s2"># Replace invalid characters</span>
        <span class="s1">data = data.replace(</span><span class="s3">&quot;</span><span class="s0">\r\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">data = data.replace(</span><span class="s3">&quot;</span><span class="s0">\r</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s1">self.chunk = data</span>
        <span class="s1">self.chunkSize = len(data)</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">characterErrorsUCS4(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(len(invalid_unicode_re.findall(data))):</span>
            <span class="s1">self.errors.append(</span><span class="s3">&quot;invalid-codepoint&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">characterErrorsUCS2(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s2"># Someone picked the wrong compile option</span>
        <span class="s2"># You lose</span>
        <span class="s1">skip = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">invalid_unicode_re.finditer(data):</span>
            <span class="s0">if </span><span class="s1">skip:</span>
                <span class="s0">continue</span>
            <span class="s1">codepoint = ord(match.group())</span>
            <span class="s1">pos = match.start()</span>
            <span class="s2"># Pretty sure there should be endianness issues here</span>
            <span class="s0">if </span><span class="s1">_utils.isSurrogatePair(data[pos:pos + </span><span class="s5">2</span><span class="s1">]):</span>
                <span class="s2"># We have a surrogate pair!</span>
                <span class="s1">char_val = _utils.surrogatePairToCodepoint(data[pos:pos + </span><span class="s5">2</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s1">char_val </span><span class="s0">in </span><span class="s1">non_bmp_invalid_codepoints:</span>
                    <span class="s1">self.errors.append(</span><span class="s3">&quot;invalid-codepoint&quot;</span><span class="s1">)</span>
                <span class="s1">skip = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">(codepoint &gt;= </span><span class="s5">0xD800 </span><span class="s0">and </span><span class="s1">codepoint &lt;= </span><span class="s5">0xDFFF </span><span class="s0">and</span>
                  <span class="s1">pos == len(data) - </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">self.errors.append(</span><span class="s3">&quot;invalid-codepoint&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">skip = </span><span class="s0">False</span>
                <span class="s1">self.errors.append(</span><span class="s3">&quot;invalid-codepoint&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">charsUntil(self</span><span class="s0">, </span><span class="s1">characters</span><span class="s0">, </span><span class="s1">opposite=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot; Returns a string of characters from the stream up to but not 
        including any character in 'characters' or EOF. 'characters' must be 
        a container that supports the 'in' method and iteration over its 
        characters. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Use a cache of regexps to find the required characters</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">chars = charsUntilRegEx[(characters</span><span class="s0">, </span><span class="s1">opposite)]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">if __debug__</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">characters:</span>
                    <span class="s0">assert</span><span class="s1">(ord(c) &lt; </span><span class="s5">128</span><span class="s1">)</span>
            <span class="s1">regex = </span><span class="s3">&quot;&quot;</span><span class="s1">.join([</span><span class="s3">&quot;</span><span class="s0">\\</span><span class="s3">x%02x&quot; </span><span class="s1">% ord(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">characters])</span>
            <span class="s0">if not </span><span class="s1">opposite:</span>
                <span class="s1">regex = </span><span class="s3">&quot;^%s&quot; </span><span class="s1">% regex</span>
            <span class="s1">chars = charsUntilRegEx[(characters</span><span class="s0">, </span><span class="s1">opposite)] = re.compile(</span><span class="s3">&quot;[%s]+&quot; </span><span class="s1">% regex)</span>

        <span class="s1">rv = []</span>

        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s2"># Find the longest matching prefix</span>
            <span class="s1">m = chars.match(self.chunk</span><span class="s0">, </span><span class="s1">self.chunkOffset)</span>
            <span class="s0">if </span><span class="s1">m </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s2"># If nothing matched, and it wasn't because we ran out of chunk,</span>
                <span class="s2"># then stop</span>
                <span class="s0">if </span><span class="s1">self.chunkOffset != self.chunkSize:</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">end = m.end()</span>
                <span class="s2"># If not the whole chunk matched, return everything</span>
                <span class="s2"># up to the part that didn't match</span>
                <span class="s0">if </span><span class="s1">end != self.chunkSize:</span>
                    <span class="s1">rv.append(self.chunk[self.chunkOffset:end])</span>
                    <span class="s1">self.chunkOffset = end</span>
                    <span class="s0">break</span>
            <span class="s2"># If the whole remainder of the chunk matched,</span>
            <span class="s2"># use it all and read the next chunk</span>
            <span class="s1">rv.append(self.chunk[self.chunkOffset:])</span>
            <span class="s0">if not </span><span class="s1">self.readChunk():</span>
                <span class="s2"># Reached EOF</span>
                <span class="s0">break</span>

        <span class="s1">r = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(rv)</span>
        <span class="s0">return </span><span class="s1">r</span>

    <span class="s0">def </span><span class="s1">unget(self</span><span class="s0">, </span><span class="s1">char):</span>
        <span class="s2"># Only one character is allowed to be ungotten at once - it must</span>
        <span class="s2"># be consumed again before any further call to unget</span>
        <span class="s0">if </span><span class="s1">char </span><span class="s0">is not </span><span class="s1">EOF:</span>
            <span class="s0">if </span><span class="s1">self.chunkOffset == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2"># unget is called quite rarely, so it's a good idea to do</span>
                <span class="s2"># more work here if it saves a bit of work in the frequently</span>
                <span class="s2"># called char and charsUntil.</span>
                <span class="s2"># So, just prepend the ungotten character onto the current</span>
                <span class="s2"># chunk:</span>
                <span class="s1">self.chunk = char + self.chunk</span>
                <span class="s1">self.chunkSize += </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.chunkOffset -= </span><span class="s5">1</span>
                <span class="s0">assert </span><span class="s1">self.chunk[self.chunkOffset] == char</span>


<span class="s0">class </span><span class="s1">HTMLBinaryInputStream(HTMLUnicodeInputStream):</span>
    <span class="s6">&quot;&quot;&quot;Provides a unicode stream of characters to the HTMLTokenizer. 
 
    This class takes care of character encoding and removing or replacing 
    incorrect byte-sequences and also provides column and line tracking. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">override_encoding=</span><span class="s0">None, </span><span class="s1">transport_encoding=</span><span class="s0">None,</span>
                 <span class="s1">same_origin_parent_encoding=</span><span class="s0">None, </span><span class="s1">likely_encoding=</span><span class="s0">None,</span>
                 <span class="s1">default_encoding=</span><span class="s3">&quot;windows-1252&quot;</span><span class="s0">, </span><span class="s1">useChardet=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Initialises the HTMLInputStream. 
 
        HTMLInputStream(source, [encoding]) -&gt; Normalized stream from source 
        for use by html5lib. 
 
        source can be either a file-object, local filename or a string. 
 
        The optional encoding parameter must be a string that indicates 
        the encoding.  If specified, that encoding will be used, 
        regardless of any BOM or later declaration (such as in a meta 
        element) 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Raw Stream - for unicode objects this will encode to utf-8 and set</span>
        <span class="s2">#              self.charEncoding as appropriate</span>
        <span class="s1">self.rawStream = self.openStream(source)</span>

        <span class="s1">HTMLUnicodeInputStream.__init__(self</span><span class="s0">, </span><span class="s1">self.rawStream)</span>

        <span class="s2"># Encoding Information</span>
        <span class="s2"># Number of bytes to use when looking for a meta element with</span>
        <span class="s2"># encoding information</span>
        <span class="s1">self.numBytesMeta = </span><span class="s5">1024</span>
        <span class="s2"># Number of bytes to use when using detecting encoding using chardet</span>
        <span class="s1">self.numBytesChardet = </span><span class="s5">100</span>
        <span class="s2"># Things from args</span>
        <span class="s1">self.override_encoding = override_encoding</span>
        <span class="s1">self.transport_encoding = transport_encoding</span>
        <span class="s1">self.same_origin_parent_encoding = same_origin_parent_encoding</span>
        <span class="s1">self.likely_encoding = likely_encoding</span>
        <span class="s1">self.default_encoding = default_encoding</span>

        <span class="s2"># Determine encoding</span>
        <span class="s1">self.charEncoding = self.determineEncoding(useChardet)</span>
        <span class="s0">assert </span><span class="s1">self.charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span>

        <span class="s2"># Call superclass</span>
        <span class="s1">self.reset()</span>

    <span class="s0">def </span><span class="s1">reset(self):</span>
        <span class="s1">self.dataStream = self.charEncoding[</span><span class="s5">0</span><span class="s1">].codec_info.streamreader(self.rawStream</span><span class="s0">, </span><span class="s3">'replace'</span><span class="s1">)</span>
        <span class="s1">HTMLUnicodeInputStream.reset(self)</span>

    <span class="s0">def </span><span class="s1">openStream(self</span><span class="s0">, </span><span class="s1">source):</span>
        <span class="s6">&quot;&quot;&quot;Produces a file object from source. 
 
        source can be either a file object, local filename or a string. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Already a file object</span>
        <span class="s0">if </span><span class="s1">hasattr(source</span><span class="s0">, </span><span class="s3">'read'</span><span class="s1">):</span>
            <span class="s1">stream = source</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">stream = BytesIO(source)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">stream.seek(stream.tell())</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s1">stream = BufferedStream(stream)</span>

        <span class="s0">return </span><span class="s1">stream</span>

    <span class="s0">def </span><span class="s1">determineEncoding(self</span><span class="s0">, </span><span class="s1">chardet=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2"># BOMs take precedence over everything</span>
        <span class="s2"># This will also read past the BOM if present</span>
        <span class="s1">charEncoding = self.detectBOM()</span><span class="s0">, </span><span class="s3">&quot;certain&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># If we've been overridden, we've been overridden</span>
        <span class="s1">charEncoding = lookupEncoding(self.override_encoding)</span><span class="s0">, </span><span class="s3">&quot;certain&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># Now check the transport layer</span>
        <span class="s1">charEncoding = lookupEncoding(self.transport_encoding)</span><span class="s0">, </span><span class="s3">&quot;certain&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># Look for meta elements with encoding information</span>
        <span class="s1">charEncoding = self.detectEncodingMeta()</span><span class="s0">, </span><span class="s3">&quot;tentative&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># Parent document encoding</span>
        <span class="s1">charEncoding = lookupEncoding(self.same_origin_parent_encoding)</span><span class="s0">, </span><span class="s3">&quot;tentative&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None and not </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">].name.startswith(</span><span class="s3">&quot;utf-16&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># &quot;likely&quot; encoding</span>
        <span class="s1">charEncoding = lookupEncoding(self.likely_encoding)</span><span class="s0">, </span><span class="s3">&quot;tentative&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># Guess with chardet, if available</span>
        <span class="s0">if </span><span class="s1">chardet:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">from </span><span class="s1">pip._vendor.chardet.universaldetector </span><span class="s0">import </span><span class="s1">UniversalDetector</span>
            <span class="s0">except </span><span class="s1">ImportError:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">buffers = []</span>
                <span class="s1">detector = UniversalDetector()</span>
                <span class="s0">while not </span><span class="s1">detector.done:</span>
                    <span class="s1">buffer = self.rawStream.read(self.numBytesChardet)</span>
                    <span class="s0">assert </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">bytes)</span>
                    <span class="s0">if not </span><span class="s1">buffer:</span>
                        <span class="s0">break</span>
                    <span class="s1">buffers.append(buffer)</span>
                    <span class="s1">detector.feed(buffer)</span>
                <span class="s1">detector.close()</span>
                <span class="s1">encoding = lookupEncoding(detector.result[</span><span class="s3">'encoding'</span><span class="s1">])</span>
                <span class="s1">self.rawStream.seek(</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">encoding </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">encoding</span><span class="s0">, </span><span class="s3">&quot;tentative&quot;</span>

        <span class="s2"># Try the default encoding</span>
        <span class="s1">charEncoding = lookupEncoding(self.default_encoding)</span><span class="s0">, </span><span class="s3">&quot;tentative&quot;</span>
        <span class="s0">if </span><span class="s1">charEncoding[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">charEncoding</span>

        <span class="s2"># Fallback to html5lib's default if even that hasn't worked</span>
        <span class="s0">return </span><span class="s1">lookupEncoding(</span><span class="s3">&quot;windows-1252&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">&quot;tentative&quot;</span>

    <span class="s0">def </span><span class="s1">changeEncoding(self</span><span class="s0">, </span><span class="s1">newEncoding):</span>
        <span class="s0">assert </span><span class="s1">self.charEncoding[</span><span class="s5">1</span><span class="s1">] != </span><span class="s3">&quot;certain&quot;</span>
        <span class="s1">newEncoding = lookupEncoding(newEncoding)</span>
        <span class="s0">if </span><span class="s1">newEncoding </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">newEncoding.name </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;utf-16be&quot;</span><span class="s0">, </span><span class="s3">&quot;utf-16le&quot;</span><span class="s1">):</span>
            <span class="s1">newEncoding = lookupEncoding(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">newEncoding </span><span class="s0">is not None</span>
        <span class="s0">elif </span><span class="s1">newEncoding == self.charEncoding[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">self.charEncoding = (self.charEncoding[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;certain&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.rawStream.seek(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">self.charEncoding = (newEncoding</span><span class="s0">, </span><span class="s3">&quot;certain&quot;</span><span class="s1">)</span>
            <span class="s1">self.reset()</span>
            <span class="s0">raise </span><span class="s1">_ReparseException(</span><span class="s3">&quot;Encoding changed from %s to %s&quot; </span><span class="s1">% (self.charEncoding[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">newEncoding))</span>

    <span class="s0">def </span><span class="s1">detectBOM(self):</span>
        <span class="s6">&quot;&quot;&quot;Attempts to detect at BOM at the start of the stream. If 
        an encoding can be determined from the BOM return the name of the 
        encoding otherwise return None&quot;&quot;&quot;</span>
        <span class="s1">bomDict = {</span>
            <span class="s1">codecs.BOM_UTF8: </span><span class="s3">'utf-8'</span><span class="s0">,</span>
            <span class="s1">codecs.BOM_UTF16_LE: </span><span class="s3">'utf-16le'</span><span class="s0">, </span><span class="s1">codecs.BOM_UTF16_BE: </span><span class="s3">'utf-16be'</span><span class="s0">,</span>
            <span class="s1">codecs.BOM_UTF32_LE: </span><span class="s3">'utf-32le'</span><span class="s0">, </span><span class="s1">codecs.BOM_UTF32_BE: </span><span class="s3">'utf-32be'</span>
        <span class="s1">}</span>

        <span class="s2"># Go to beginning of file and read in 4 bytes</span>
        <span class="s1">string = self.rawStream.read(</span><span class="s5">4</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(string</span><span class="s0">, </span><span class="s1">bytes)</span>

        <span class="s2"># Try detecting the BOM using bytes from the string</span>
        <span class="s1">encoding = bomDict.get(string[:</span><span class="s5">3</span><span class="s1">])         </span><span class="s2"># UTF-8</span>
        <span class="s1">seek = </span><span class="s5">3</span>
        <span class="s0">if not </span><span class="s1">encoding:</span>
            <span class="s2"># Need to detect UTF-32 before UTF-16</span>
            <span class="s1">encoding = bomDict.get(string)         </span><span class="s2"># UTF-32</span>
            <span class="s1">seek = </span><span class="s5">4</span>
            <span class="s0">if not </span><span class="s1">encoding:</span>
                <span class="s1">encoding = bomDict.get(string[:</span><span class="s5">2</span><span class="s1">])  </span><span class="s2"># UTF-16</span>
                <span class="s1">seek = </span><span class="s5">2</span>

        <span class="s2"># Set the read position past the BOM if one was found, otherwise</span>
        <span class="s2"># set it to the start of the stream</span>
        <span class="s0">if </span><span class="s1">encoding:</span>
            <span class="s1">self.rawStream.seek(seek)</span>
            <span class="s0">return </span><span class="s1">lookupEncoding(encoding)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.rawStream.seek(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">detectEncodingMeta(self):</span>
        <span class="s6">&quot;&quot;&quot;Report the encoding declared by the meta element 
        &quot;&quot;&quot;</span>
        <span class="s1">buffer = self.rawStream.read(self.numBytesMeta)</span>
        <span class="s0">assert </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">bytes)</span>
        <span class="s1">parser = EncodingParser(buffer)</span>
        <span class="s1">self.rawStream.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">encoding = parser.getEncoding()</span>

        <span class="s0">if </span><span class="s1">encoding </span><span class="s0">is not None and </span><span class="s1">encoding.name </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;utf-16be&quot;</span><span class="s0">, </span><span class="s3">&quot;utf-16le&quot;</span><span class="s1">):</span>
            <span class="s1">encoding = lookupEncoding(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">encoding</span>


<span class="s0">class </span><span class="s1">EncodingBytes(bytes):</span>
    <span class="s6">&quot;&quot;&quot;String-like object with an associated position and various extra methods 
    If the position is ever greater than the string length then an exception is 
    raised&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__new__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">assert </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">bytes)</span>
        <span class="s0">return </span><span class="s1">bytes.__new__(self</span><span class="s0">, </span><span class="s1">value.lower())</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s2"># pylint:disable=unused-argument</span>
        <span class="s1">self._position = -</span><span class="s5">1</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s1">p = self._position = self._position + </span><span class="s5">1</span>
        <span class="s0">if </span><span class="s1">p &gt;= len(self):</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
        <span class="s0">elif </span><span class="s1">p &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span>
        <span class="s0">return </span><span class="s1">self[p:p + </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">next(self):</span>
        <span class="s2"># Py2 compat</span>
        <span class="s0">return </span><span class="s1">self.__next__()</span>

    <span class="s0">def </span><span class="s1">previous(self):</span>
        <span class="s1">p = self._position</span>
        <span class="s0">if </span><span class="s1">p &gt;= len(self):</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
        <span class="s0">elif </span><span class="s1">p &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span>
        <span class="s1">self._position = p = p - </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">self[p:p + </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">setPosition(self</span><span class="s0">, </span><span class="s1">position):</span>
        <span class="s0">if </span><span class="s1">self._position &gt;= len(self):</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
        <span class="s1">self._position = position</span>

    <span class="s0">def </span><span class="s1">getPosition(self):</span>
        <span class="s0">if </span><span class="s1">self._position &gt;= len(self):</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
        <span class="s0">if </span><span class="s1">self._position &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._position</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return None</span>

    <span class="s1">position = property(getPosition</span><span class="s0">, </span><span class="s1">setPosition)</span>

    <span class="s0">def </span><span class="s1">getCurrentByte(self):</span>
        <span class="s0">return </span><span class="s1">self[self.position:self.position + </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">currentByte = property(getCurrentByte)</span>

    <span class="s0">def </span><span class="s1">skip(self</span><span class="s0">, </span><span class="s1">chars=spaceCharactersBytes):</span>
        <span class="s6">&quot;&quot;&quot;Skip past a list of characters&quot;&quot;&quot;</span>
        <span class="s1">p = self.position               </span><span class="s2"># use property for the error-checking</span>
        <span class="s0">while </span><span class="s1">p &lt; len(self):</span>
            <span class="s1">c = self[p:p + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">c </span><span class="s0">not in </span><span class="s1">chars:</span>
                <span class="s1">self._position = p</span>
                <span class="s0">return </span><span class="s1">c</span>
            <span class="s1">p += </span><span class="s5">1</span>
        <span class="s1">self._position = p</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">skipUntil(self</span><span class="s0">, </span><span class="s1">chars):</span>
        <span class="s1">p = self.position</span>
        <span class="s0">while </span><span class="s1">p &lt; len(self):</span>
            <span class="s1">c = self[p:p + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">chars:</span>
                <span class="s1">self._position = p</span>
                <span class="s0">return </span><span class="s1">c</span>
            <span class="s1">p += </span><span class="s5">1</span>
        <span class="s1">self._position = p</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">matchBytes(self</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s6">&quot;&quot;&quot;Look for a sequence of bytes at the start of a string. If the bytes 
        are found return True and advance the position to the byte after the 
        match. Otherwise return False and leave the position alone&quot;&quot;&quot;</span>
        <span class="s1">rv = self.startswith(bytes</span><span class="s0">, </span><span class="s1">self.position)</span>
        <span class="s0">if </span><span class="s1">rv:</span>
            <span class="s1">self.position += len(bytes)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">jumpTo(self</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s6">&quot;&quot;&quot;Look for the next sequence of bytes matching a given sequence. If 
        a match is found advance the position to the last byte of the match&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._position = self.index(bytes</span><span class="s0">, </span><span class="s1">self.position) + len(bytes) - </span><span class="s5">1</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
        <span class="s0">return True</span>


<span class="s0">class </span><span class="s1">EncodingParser(object):</span>
    <span class="s6">&quot;&quot;&quot;Mini parser for detecting character encoding from meta elements&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s6">&quot;&quot;&quot;string - the data to work on for encoding detection&quot;&quot;&quot;</span>
        <span class="s1">self.data = EncodingBytes(data)</span>
        <span class="s1">self.encoding = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">getEncoding(self):</span>
        <span class="s0">if </span><span class="s4">b&quot;&lt;meta&quot; </span><span class="s0">not in </span><span class="s1">self.data:</span>
            <span class="s0">return None</span>

        <span class="s1">methodDispatch = (</span>
            <span class="s1">(</span><span class="s4">b&quot;&lt;!--&quot;</span><span class="s0">, </span><span class="s1">self.handleComment)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">b&quot;&lt;meta&quot;</span><span class="s0">, </span><span class="s1">self.handleMeta)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">b&quot;&lt;/&quot;</span><span class="s0">, </span><span class="s1">self.handlePossibleEndTag)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">b&quot;&lt;!&quot;</span><span class="s0">, </span><span class="s1">self.handleOther)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">b&quot;&lt;?&quot;</span><span class="s0">, </span><span class="s1">self.handleOther)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">b&quot;&lt;&quot;</span><span class="s0">, </span><span class="s1">self.handlePossibleStartTag))</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self.data:</span>
            <span class="s1">keepParsing = </span><span class="s0">True</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.data.jumpTo(</span><span class="s4">b&quot;&lt;&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">StopIteration:</span>
                <span class="s0">break</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">method </span><span class="s0">in </span><span class="s1">methodDispatch:</span>
                <span class="s0">if </span><span class="s1">self.data.matchBytes(key):</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">keepParsing = method()</span>
                        <span class="s0">break</span>
                    <span class="s0">except </span><span class="s1">StopIteration:</span>
                        <span class="s1">keepParsing = </span><span class="s0">False</span>
                        <span class="s0">break</span>
            <span class="s0">if not </span><span class="s1">keepParsing:</span>
                <span class="s0">break</span>

        <span class="s0">return </span><span class="s1">self.encoding</span>

    <span class="s0">def </span><span class="s1">handleComment(self):</span>
        <span class="s6">&quot;&quot;&quot;Skip over comments&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.data.jumpTo(</span><span class="s4">b&quot;--&gt;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">handleMeta(self):</span>
        <span class="s0">if </span><span class="s1">self.data.currentByte </span><span class="s0">not in </span><span class="s1">spaceCharactersBytes:</span>
            <span class="s2"># if we have &lt;meta not followed by a space so just keep going</span>
            <span class="s0">return True</span>
        <span class="s2"># We have a valid meta element we want to search for attributes</span>
        <span class="s1">hasPragma = </span><span class="s0">False</span>
        <span class="s1">pendingEncoding = </span><span class="s0">None</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s2"># Try to find the next attribute after the current position</span>
            <span class="s1">attr = self.getAttribute()</span>
            <span class="s0">if </span><span class="s1">attr </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">attr[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">b&quot;http-equiv&quot;</span><span class="s1">:</span>
                    <span class="s1">hasPragma = attr[</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">b&quot;content-type&quot;</span>
                    <span class="s0">if </span><span class="s1">hasPragma </span><span class="s0">and </span><span class="s1">pendingEncoding </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">self.encoding = pendingEncoding</span>
                        <span class="s0">return False</span>
                <span class="s0">elif </span><span class="s1">attr[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">b&quot;charset&quot;</span><span class="s1">:</span>
                    <span class="s1">tentativeEncoding = attr[</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">codec = lookupEncoding(tentativeEncoding)</span>
                    <span class="s0">if </span><span class="s1">codec </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">self.encoding = codec</span>
                        <span class="s0">return False</span>
                <span class="s0">elif </span><span class="s1">attr[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">b&quot;content&quot;</span><span class="s1">:</span>
                    <span class="s1">contentParser = ContentAttrParser(EncodingBytes(attr[</span><span class="s5">1</span><span class="s1">]))</span>
                    <span class="s1">tentativeEncoding = contentParser.parse()</span>
                    <span class="s0">if </span><span class="s1">tentativeEncoding </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">codec = lookupEncoding(tentativeEncoding)</span>
                        <span class="s0">if </span><span class="s1">codec </span><span class="s0">is not None</span><span class="s1">:</span>
                            <span class="s0">if </span><span class="s1">hasPragma:</span>
                                <span class="s1">self.encoding = codec</span>
                                <span class="s0">return False</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">pendingEncoding = codec</span>

    <span class="s0">def </span><span class="s1">handlePossibleStartTag(self):</span>
        <span class="s0">return </span><span class="s1">self.handlePossibleTag(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">handlePossibleEndTag(self):</span>
        <span class="s1">next(self.data)</span>
        <span class="s0">return </span><span class="s1">self.handlePossibleTag(</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">handlePossibleTag(self</span><span class="s0">, </span><span class="s1">endTag):</span>
        <span class="s1">data = self.data</span>
        <span class="s0">if </span><span class="s1">data.currentByte </span><span class="s0">not in </span><span class="s1">asciiLettersBytes:</span>
            <span class="s2"># If the next byte is not an ascii letter either ignore this</span>
            <span class="s2"># fragment (possible start tag case) or treat it according to</span>
            <span class="s2"># handleOther</span>
            <span class="s0">if </span><span class="s1">endTag:</span>
                <span class="s1">data.previous()</span>
                <span class="s1">self.handleOther()</span>
            <span class="s0">return True</span>

        <span class="s1">c = data.skipUntil(spacesAngleBrackets)</span>
        <span class="s0">if </span><span class="s1">c == </span><span class="s4">b&quot;&lt;&quot;</span><span class="s1">:</span>
            <span class="s2"># return to the first step in the overall &quot;two step&quot; algorithm</span>
            <span class="s2"># reprocessing the &lt; byte</span>
            <span class="s1">data.previous()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Read all attributes</span>
            <span class="s1">attr = self.getAttribute()</span>
            <span class="s0">while </span><span class="s1">attr </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">attr = self.getAttribute()</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">handleOther(self):</span>
        <span class="s0">return </span><span class="s1">self.data.jumpTo(</span><span class="s4">b&quot;&gt;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">getAttribute(self):</span>
        <span class="s6">&quot;&quot;&quot;Return a name,value pair for the next attribute in the stream, 
        if one is found, or None&quot;&quot;&quot;</span>
        <span class="s1">data = self.data</span>
        <span class="s2"># Step 1 (skip chars)</span>
        <span class="s1">c = data.skip(spaceCharactersBytes | frozenset([</span><span class="s4">b&quot;/&quot;</span><span class="s1">]))</span>
        <span class="s0">assert </span><span class="s1">c </span><span class="s0">is None or </span><span class="s1">len(c) == </span><span class="s5">1</span>
        <span class="s2"># Step 2</span>
        <span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">(</span><span class="s4">b&quot;&gt;&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s0">return None</span>
        <span class="s2"># Step 3</span>
        <span class="s1">attrName = []</span>
        <span class="s1">attrValue = []</span>
        <span class="s2"># Step 4 attribute name</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">c == </span><span class="s4">b&quot;=&quot; </span><span class="s0">and </span><span class="s1">attrName:</span>
                <span class="s0">break</span>
            <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">spaceCharactersBytes:</span>
                <span class="s2"># Step 6!</span>
                <span class="s1">c = data.skip()</span>
                <span class="s0">break</span>
            <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">(</span><span class="s4">b&quot;/&quot;</span><span class="s0">, </span><span class="s4">b&quot;&gt;&quot;</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrName)</span><span class="s0">, </span><span class="s4">b&quot;&quot;</span>
            <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">asciiUppercaseBytes:</span>
                <span class="s1">attrName.append(c.lower())</span>
            <span class="s0">elif </span><span class="s1">c </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">attrName.append(c)</span>
            <span class="s2"># Step 5</span>
            <span class="s1">c = next(data)</span>
        <span class="s2"># Step 7</span>
        <span class="s0">if </span><span class="s1">c != </span><span class="s4">b&quot;=&quot;</span><span class="s1">:</span>
            <span class="s1">data.previous()</span>
            <span class="s0">return </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrName)</span><span class="s0">, </span><span class="s4">b&quot;&quot;</span>
        <span class="s2"># Step 8</span>
        <span class="s1">next(data)</span>
        <span class="s2"># Step 9</span>
        <span class="s1">c = data.skip()</span>
        <span class="s2"># Step 10</span>
        <span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">(</span><span class="s4">b&quot;'&quot;</span><span class="s0">, </span><span class="s4">b'&quot;'</span><span class="s1">):</span>
            <span class="s2"># 10.1</span>
            <span class="s1">quoteChar = c</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s2"># 10.2</span>
                <span class="s1">c = next(data)</span>
                <span class="s2"># 10.3</span>
                <span class="s0">if </span><span class="s1">c == quoteChar:</span>
                    <span class="s1">next(data)</span>
                    <span class="s0">return </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrName)</span><span class="s0">, </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrValue)</span>
                <span class="s2"># 10.4</span>
                <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">asciiUppercaseBytes:</span>
                    <span class="s1">attrValue.append(c.lower())</span>
                <span class="s2"># 10.5</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">attrValue.append(c)</span>
        <span class="s0">elif </span><span class="s1">c == </span><span class="s4">b&quot;&gt;&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrName)</span><span class="s0">, </span><span class="s4">b&quot;&quot;</span>
        <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">asciiUppercaseBytes:</span>
            <span class="s1">attrValue.append(c.lower())</span>
        <span class="s0">elif </span><span class="s1">c </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">attrValue.append(c)</span>
        <span class="s2"># Step 11</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s1">c = next(data)</span>
            <span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">spacesAngleBrackets:</span>
                <span class="s0">return </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrName)</span><span class="s0">, </span><span class="s4">b&quot;&quot;</span><span class="s1">.join(attrValue)</span>
            <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">asciiUppercaseBytes:</span>
                <span class="s1">attrValue.append(c.lower())</span>
            <span class="s0">elif </span><span class="s1">c </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">attrValue.append(c)</span>


<span class="s0">class </span><span class="s1">ContentAttrParser(object):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s0">assert </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">bytes)</span>
        <span class="s1">self.data = data</span>

    <span class="s0">def </span><span class="s1">parse(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Check if the attr name is charset</span>
            <span class="s2"># otherwise return</span>
            <span class="s1">self.data.jumpTo(</span><span class="s4">b&quot;charset&quot;</span><span class="s1">)</span>
            <span class="s1">self.data.position += </span><span class="s5">1</span>
            <span class="s1">self.data.skip()</span>
            <span class="s0">if not </span><span class="s1">self.data.currentByte == </span><span class="s4">b&quot;=&quot;</span><span class="s1">:</span>
                <span class="s2"># If there is no = sign keep looking for attrs</span>
                <span class="s0">return None</span>
            <span class="s1">self.data.position += </span><span class="s5">1</span>
            <span class="s1">self.data.skip()</span>
            <span class="s2"># Look for an encoding between matching quote marks</span>
            <span class="s0">if </span><span class="s1">self.data.currentByte </span><span class="s0">in </span><span class="s1">(</span><span class="s4">b'&quot;'</span><span class="s0">, </span><span class="s4">b&quot;'&quot;</span><span class="s1">):</span>
                <span class="s1">quoteMark = self.data.currentByte</span>
                <span class="s1">self.data.position += </span><span class="s5">1</span>
                <span class="s1">oldPosition = self.data.position</span>
                <span class="s0">if </span><span class="s1">self.data.jumpTo(quoteMark):</span>
                    <span class="s0">return </span><span class="s1">self.data[oldPosition:self.data.position]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Unquoted value</span>
                <span class="s1">oldPosition = self.data.position</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">self.data.skipUntil(spaceCharactersBytes)</span>
                    <span class="s0">return </span><span class="s1">self.data[oldPosition:self.data.position]</span>
                <span class="s0">except </span><span class="s1">StopIteration:</span>
                    <span class="s2"># Return the whole remaining value</span>
                    <span class="s0">return </span><span class="s1">self.data[oldPosition:]</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">lookupEncoding(encoding):</span>
    <span class="s6">&quot;&quot;&quot;Return the python codec name corresponding to an encoding or None if the 
    string doesn't correspond to a valid encoding.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(encoding</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">encoding = encoding.decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">UnicodeDecodeError:</span>
            <span class="s0">return None</span>

    <span class="s0">if </span><span class="s1">encoding </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">webencodings.lookup(encoding)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">return None</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return None</span>
</pre>
</body>
</html>