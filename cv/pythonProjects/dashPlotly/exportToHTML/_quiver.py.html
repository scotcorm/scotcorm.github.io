<html>
<head>
<title>_quiver.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_quiver.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">math</span>

<span class="s0">from </span><span class="s1">plotly </span><span class="s0">import </span><span class="s1">exceptions</span>
<span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">graph_objs</span>
<span class="s0">from </span><span class="s1">plotly.figure_factory </span><span class="s0">import </span><span class="s1">utils</span>


<span class="s0">def </span><span class="s1">create_quiver(</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">scale=</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">arrow_scale=</span><span class="s2">0.3</span><span class="s0">, </span><span class="s1">angle=math.pi / </span><span class="s2">9</span><span class="s0">, </span><span class="s1">scaleratio=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns data for a quiver plot. 
 
    :param (list|ndarray) x: x coordinates of the arrow locations 
    :param (list|ndarray) y: y coordinates of the arrow locations 
    :param (list|ndarray) u: x components of the arrow vectors 
    :param (list|ndarray) v: y components of the arrow vectors 
    :param (float in [0,1]) scale: scales size of the arrows(ideally to 
        avoid overlap). Default = .1 
    :param (float in [0,1]) arrow_scale: value multiplied to length of barb 
        to get length of arrowhead. Default = .3 
    :param (angle in radians) angle: angle of arrowhead. Default = pi/9 
    :param (positive float) scaleratio: the ratio between the scale of the y-axis 
        and the scale of the x-axis (scale_y / scale_x). Default = None, the 
        scale ratio is not fixed. 
    :param kwargs: kwargs passed through plotly.graph_objs.Scatter 
        for more information on valid kwargs call 
        help(plotly.graph_objs.Scatter) 
 
    :rtype (dict): returns a representation of quiver figure. 
 
    Example 1: Trivial Quiver 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_quiver 
    &gt;&gt;&gt; import math 
 
    &gt;&gt;&gt; # 1 Arrow from (0,0) to (1,1) 
    &gt;&gt;&gt; fig = create_quiver(x=[0], y=[0], u=[1], v=[1], scale=1) 
    &gt;&gt;&gt; fig.show() 
 
 
    Example 2: Quiver plot using meshgrid 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_quiver 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import math 
 
    &gt;&gt;&gt; # Add data 
    &gt;&gt;&gt; x,y = np.meshgrid(np.arange(0, 2, .2), np.arange(0, 2, .2)) 
    &gt;&gt;&gt; u = np.cos(x)*y 
    &gt;&gt;&gt; v = np.sin(x)*y 
 
    &gt;&gt;&gt; #Create quiver 
    &gt;&gt;&gt; fig = create_quiver(x, y, u, v) 
    &gt;&gt;&gt; fig.show() 
 
 
    Example 3: Styling the quiver plot 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_quiver 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import math 
 
    &gt;&gt;&gt; # Add data 
    &gt;&gt;&gt; x, y = np.meshgrid(np.arange(-np.pi, math.pi, .5), 
    ...                    np.arange(-math.pi, math.pi, .5)) 
    &gt;&gt;&gt; u = np.cos(x)*y 
    &gt;&gt;&gt; v = np.sin(x)*y 
 
    &gt;&gt;&gt; # Create quiver 
    &gt;&gt;&gt; fig = create_quiver(x, y, u, v, scale=.2, arrow_scale=.3, angle=math.pi/6, 
    ...                     name='Wind Velocity', line=dict(width=1)) 
 
    &gt;&gt;&gt; # Add title to layout 
    &gt;&gt;&gt; fig.update_layout(title='Quiver Plot') # doctest: +SKIP 
    &gt;&gt;&gt; fig.show() 
 
 
    Example 4: Forcing a fix scale ratio to maintain the arrow length 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_quiver 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; # Add data 
    &gt;&gt;&gt; x,y = np.meshgrid(np.arange(0.5, 3.5, .5), np.arange(0.5, 4.5, .5)) 
    &gt;&gt;&gt; u = x 
    &gt;&gt;&gt; v = y 
    &gt;&gt;&gt; angle = np.arctan(v / u) 
    &gt;&gt;&gt; norm = 0.25 
    &gt;&gt;&gt; u = norm * np.cos(angle) 
    &gt;&gt;&gt; v = norm * np.sin(angle) 
 
    &gt;&gt;&gt; # Create quiver with a fix scale ratio 
    &gt;&gt;&gt; fig = create_quiver(x, y, u, v, scale = 1, scaleratio = 0.5) 
    &gt;&gt;&gt; fig.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">utils.validate_equal_length(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v)</span>
    <span class="s1">utils.validate_positive_scalars(arrow_scale=arrow_scale</span><span class="s0">, </span><span class="s1">scale=scale)</span>

    <span class="s0">if </span><span class="s1">scaleratio </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">quiver_obj = _Quiver(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">arrow_scale</span><span class="s0">, </span><span class="s1">angle)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">quiver_obj = _Quiver(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">arrow_scale</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">scaleratio)</span>

    <span class="s1">barb_x</span><span class="s0">, </span><span class="s1">barb_y = quiver_obj.get_barbs()</span>
    <span class="s1">arrow_x</span><span class="s0">, </span><span class="s1">arrow_y = quiver_obj.get_quiver_arrows()</span>

    <span class="s1">quiver_plot = graph_objs.Scatter(</span>
        <span class="s1">x=barb_x + arrow_x</span><span class="s0">, </span><span class="s1">y=barb_y + arrow_y</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;lines&quot;</span><span class="s0">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>

    <span class="s1">data = [quiver_plot]</span>

    <span class="s0">if </span><span class="s1">scaleratio </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">layout = graph_objs.Layout(hovermode=</span><span class="s4">&quot;closest&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">layout = graph_objs.Layout(</span>
            <span class="s1">hovermode=</span><span class="s4">&quot;closest&quot;</span><span class="s0">, </span><span class="s1">yaxis=dict(scaleratio=scaleratio</span><span class="s0">, </span><span class="s1">scaleanchor=</span><span class="s4">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">graph_objs.Figure(data=data</span><span class="s0">, </span><span class="s1">layout=layout)</span>


<span class="s0">class </span><span class="s1">_Quiver(object):</span>
    <span class="s3">&quot;&quot;&quot; 
    Refer to FigureFactory.create_quiver() for docstring 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">arrow_scale</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">scaleratio=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">x = utils.flatten(x)</span>
        <span class="s0">except </span><span class="s1">exceptions.PlotlyError:</span>
            <span class="s0">pass</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">y = utils.flatten(y)</span>
        <span class="s0">except </span><span class="s1">exceptions.PlotlyError:</span>
            <span class="s0">pass</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">u = utils.flatten(u)</span>
        <span class="s0">except </span><span class="s1">exceptions.PlotlyError:</span>
            <span class="s0">pass</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">v = utils.flatten(v)</span>
        <span class="s0">except </span><span class="s1">exceptions.PlotlyError:</span>
            <span class="s0">pass</span>

        <span class="s1">self.x = x</span>
        <span class="s1">self.y = y</span>
        <span class="s1">self.u = u</span>
        <span class="s1">self.v = v</span>
        <span class="s1">self.scale = scale</span>
        <span class="s1">self.scaleratio = scaleratio</span>
        <span class="s1">self.arrow_scale = arrow_scale</span>
        <span class="s1">self.angle = angle</span>
        <span class="s1">self.end_x = []</span>
        <span class="s1">self.end_y = []</span>
        <span class="s1">self.scale_uv()</span>
        <span class="s1">barb_x</span><span class="s0">, </span><span class="s1">barb_y = self.get_barbs()</span>
        <span class="s1">arrow_x</span><span class="s0">, </span><span class="s1">arrow_y = self.get_quiver_arrows()</span>

    <span class="s0">def </span><span class="s1">scale_uv(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Scales u and v to avoid overlap of the arrows. 
 
        u and v are added to x and y to get the 
        endpoints of the arrows so a smaller scale value will 
        result in less overlap of arrows. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.u = [i * self.scale * self.scaleratio </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.u]</span>
        <span class="s1">self.v = [i * self.scale </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.v]</span>

    <span class="s0">def </span><span class="s1">get_barbs(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Creates x and y startpoint and endpoint pairs 
 
        After finding the endpoint of each barb this zips startpoint and 
        endpoint pairs to create 2 lists: x_values for barbs and y values 
        for barbs 
 
        :rtype: (list, list) barb_x, barb_y: list of startpoint and endpoint 
            x_value pairs separated by a None to create the barb of the arrow, 
            and list of startpoint and endpoint y_value pairs separated by a 
            None to create the barb of the arrow. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.end_x = [i + j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.x</span><span class="s0">, </span><span class="s1">self.u)]</span>
        <span class="s1">self.end_y = [i + j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.y</span><span class="s0">, </span><span class="s1">self.v)]</span>
        <span class="s1">empty = [</span><span class="s0">None</span><span class="s1">] * len(self.x)</span>
        <span class="s1">barb_x = utils.flatten(zip(self.x</span><span class="s0">, </span><span class="s1">self.end_x</span><span class="s0">, </span><span class="s1">empty))</span>
        <span class="s1">barb_y = utils.flatten(zip(self.y</span><span class="s0">, </span><span class="s1">self.end_y</span><span class="s0">, </span><span class="s1">empty))</span>
        <span class="s0">return </span><span class="s1">barb_x</span><span class="s0">, </span><span class="s1">barb_y</span>

    <span class="s0">def </span><span class="s1">get_quiver_arrows(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Creates lists of x and y values to plot the arrows 
 
        Gets length of each barb then calculates the length of each side of 
        the arrow. Gets angle of barb and applies angle to each side of the 
        arrowhead. Next uses arrow_scale to scale the length of arrowhead and 
        creates x and y values for arrowhead point1 and point2. Finally x and y 
        values for point1, endpoint and point2s for each arrowhead are 
        separated by a None and zipped to create lists of x and y values for 
        the arrows. 
 
        :rtype: (list, list) arrow_x, arrow_y: list of point1, endpoint, point2 
            x_values separated by a None to create the arrowhead and list of 
            point1, endpoint, point2 y_values separated by a None to create 
            the barb of the arrow. 
        &quot;&quot;&quot;</span>
        <span class="s1">dif_x = [i - j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.end_x</span><span class="s0">, </span><span class="s1">self.x)]</span>
        <span class="s1">dif_y = [i - j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.end_y</span><span class="s0">, </span><span class="s1">self.y)]</span>

        <span class="s5"># Get barb lengths(default arrow length = 30% barb length)</span>
        <span class="s1">barb_len = [</span><span class="s0">None</span><span class="s1">] * len(self.x)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(barb_len)):</span>
            <span class="s1">barb_len[index] = math.hypot(dif_x[index] / self.scaleratio</span><span class="s0">, </span><span class="s1">dif_y[index])</span>

        <span class="s5"># Make arrow lengths</span>
        <span class="s1">arrow_len = [</span><span class="s0">None</span><span class="s1">] * len(self.x)</span>
        <span class="s1">arrow_len = [i * self.arrow_scale </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">barb_len]</span>

        <span class="s5"># Get barb angles</span>
        <span class="s1">barb_ang = [</span><span class="s0">None</span><span class="s1">] * len(self.x)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(barb_ang)):</span>
            <span class="s1">barb_ang[index] = math.atan2(dif_y[index]</span><span class="s0">, </span><span class="s1">dif_x[index] / self.scaleratio)</span>

        <span class="s5"># Set angles to create arrow</span>
        <span class="s1">ang1 = [i + self.angle </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">barb_ang]</span>
        <span class="s1">ang2 = [i - self.angle </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">barb_ang]</span>

        <span class="s1">cos_ang1 = [</span><span class="s0">None</span><span class="s1">] * len(ang1)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(ang1)):</span>
            <span class="s1">cos_ang1[index] = math.cos(ang1[index])</span>
        <span class="s1">seg1_x = [i * j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(arrow_len</span><span class="s0">, </span><span class="s1">cos_ang1)]</span>

        <span class="s1">sin_ang1 = [</span><span class="s0">None</span><span class="s1">] * len(ang1)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(ang1)):</span>
            <span class="s1">sin_ang1[index] = math.sin(ang1[index])</span>
        <span class="s1">seg1_y = [i * j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(arrow_len</span><span class="s0">, </span><span class="s1">sin_ang1)]</span>

        <span class="s1">cos_ang2 = [</span><span class="s0">None</span><span class="s1">] * len(ang2)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(ang2)):</span>
            <span class="s1">cos_ang2[index] = math.cos(ang2[index])</span>
        <span class="s1">seg2_x = [i * j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(arrow_len</span><span class="s0">, </span><span class="s1">cos_ang2)]</span>

        <span class="s1">sin_ang2 = [</span><span class="s0">None</span><span class="s1">] * len(ang2)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(ang2)):</span>
            <span class="s1">sin_ang2[index] = math.sin(ang2[index])</span>
        <span class="s1">seg2_y = [i * j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(arrow_len</span><span class="s0">, </span><span class="s1">sin_ang2)]</span>

        <span class="s5"># Set coordinates to create arrow</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(self.end_x)):</span>
            <span class="s1">point1_x = [i - j * self.scaleratio </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.end_x</span><span class="s0">, </span><span class="s1">seg1_x)]</span>
            <span class="s1">point1_y = [i - j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.end_y</span><span class="s0">, </span><span class="s1">seg1_y)]</span>
            <span class="s1">point2_x = [i - j * self.scaleratio </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.end_x</span><span class="s0">, </span><span class="s1">seg2_x)]</span>
            <span class="s1">point2_y = [i - j </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(self.end_y</span><span class="s0">, </span><span class="s1">seg2_y)]</span>

        <span class="s5"># Combine lists to create arrow</span>
        <span class="s1">empty = [</span><span class="s0">None</span><span class="s1">] * len(self.end_x)</span>
        <span class="s1">arrow_x = utils.flatten(zip(point1_x</span><span class="s0">, </span><span class="s1">self.end_x</span><span class="s0">, </span><span class="s1">point2_x</span><span class="s0">, </span><span class="s1">empty))</span>
        <span class="s1">arrow_y = utils.flatten(zip(point1_y</span><span class="s0">, </span><span class="s1">self.end_y</span><span class="s0">, </span><span class="s1">point2_y</span><span class="s0">, </span><span class="s1">empty))</span>
        <span class="s0">return </span><span class="s1">arrow_x</span><span class="s0">, </span><span class="s1">arrow_y</span>
</pre>
</body>
</html>