<html>
<head>
<title>rules.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rules.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
 
Rules for building C/API module with f2py2e. 
 
Here is a skeleton of a new wrapper function (13Dec2001): 
 
wrapper_function(args) 
  declarations 
  get_python_arguments, say, `a' and `b' 
 
  get_a_from_python 
  if (successful) { 
 
    get_b_from_python 
    if (successful) { 
 
      callfortran 
      if (successful) { 
 
        put_a_to_python 
        if (successful) { 
 
          put_b_to_python 
          if (successful) { 
 
            buildvalue = ... 
 
          } 
 
        } 
 
      } 
 
    } 
    cleanup_b 
 
  } 
  cleanup_a 
 
  return buildvalue 
 
Copyright 1999,2000 Pearu Peterson all rights reserved, 
Pearu Peterson &lt;pearu@ioc.ee&gt; 
Permission to use, modify, and distribute this software is given under the 
terms of the NumPy License. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
$Date: 2005/08/30 08:58:42 $ 
Pearu Peterson 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">copy</span>

<span class="s0"># __version__.version is now the same as the NumPy version</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">__version__</span>
<span class="s1">f2py_version = __version__.version</span>
<span class="s1">numpy_version = __version__.version</span>

<span class="s3">from </span><span class="s1">.auxfuncs </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">applyrules</span><span class="s3">, </span><span class="s1">debugcapi</span><span class="s3">, </span><span class="s1">dictappend</span><span class="s3">, </span><span class="s1">errmess</span><span class="s3">, </span><span class="s1">gentitle</span><span class="s3">, </span><span class="s1">getargs2</span><span class="s3">,</span>
    <span class="s1">hascallstatement</span><span class="s3">, </span><span class="s1">hasexternals</span><span class="s3">, </span><span class="s1">hasinitvalue</span><span class="s3">, </span><span class="s1">hasnote</span><span class="s3">, </span><span class="s1">hasresultnote</span><span class="s3">,</span>
    <span class="s1">isarray</span><span class="s3">, </span><span class="s1">isarrayofstrings</span><span class="s3">, </span><span class="s1">iscomplex</span><span class="s3">, </span><span class="s1">iscomplexarray</span><span class="s3">,</span>
    <span class="s1">iscomplexfunction</span><span class="s3">, </span><span class="s1">iscomplexfunction_warn</span><span class="s3">, </span><span class="s1">isdummyroutine</span><span class="s3">, </span><span class="s1">isexternal</span><span class="s3">,</span>
    <span class="s1">isfunction</span><span class="s3">, </span><span class="s1">isfunction_wrap</span><span class="s3">, </span><span class="s1">isint1array</span><span class="s3">, </span><span class="s1">isintent_aux</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">,</span>
    <span class="s1">isintent_callback</span><span class="s3">, </span><span class="s1">isintent_copy</span><span class="s3">, </span><span class="s1">isintent_hide</span><span class="s3">, </span><span class="s1">isintent_inout</span><span class="s3">,</span>
    <span class="s1">isintent_nothide</span><span class="s3">, </span><span class="s1">isintent_out</span><span class="s3">, </span><span class="s1">isintent_overwrite</span><span class="s3">, </span><span class="s1">islogical</span><span class="s3">,</span>
    <span class="s1">islong_complex</span><span class="s3">, </span><span class="s1">islong_double</span><span class="s3">, </span><span class="s1">islong_doublefunction</span><span class="s3">, </span><span class="s1">islong_long</span><span class="s3">,</span>
    <span class="s1">islong_longfunction</span><span class="s3">, </span><span class="s1">ismoduleroutine</span><span class="s3">, </span><span class="s1">isoptional</span><span class="s3">, </span><span class="s1">isrequired</span><span class="s3">, </span><span class="s1">isscalar</span><span class="s3">,</span>
    <span class="s1">issigned_long_longarray</span><span class="s3">, </span><span class="s1">isstring</span><span class="s3">, </span><span class="s1">isstringarray</span><span class="s3">, </span><span class="s1">isstringfunction</span><span class="s3">,</span>
    <span class="s1">issubroutine</span><span class="s3">, </span><span class="s1">issubroutine_wrap</span><span class="s3">, </span><span class="s1">isthreadsafe</span><span class="s3">, </span><span class="s1">isunsigned</span><span class="s3">,</span>
    <span class="s1">isunsigned_char</span><span class="s3">, </span><span class="s1">isunsigned_chararray</span><span class="s3">, </span><span class="s1">isunsigned_long_long</span><span class="s3">,</span>
    <span class="s1">isunsigned_long_longarray</span><span class="s3">, </span><span class="s1">isunsigned_short</span><span class="s3">, </span><span class="s1">isunsigned_shortarray</span><span class="s3">,</span>
    <span class="s1">l_and</span><span class="s3">, </span><span class="s1">l_not</span><span class="s3">, </span><span class="s1">l_or</span><span class="s3">, </span><span class="s1">outmess</span><span class="s3">, </span><span class="s1">replace</span><span class="s3">, </span><span class="s1">stripcomma</span><span class="s3">, </span><span class="s1">requiresf90wrapper</span>
<span class="s1">)</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">capi_maps</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">cfuncs</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">common_rules</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">use_rules</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">f90mod_rules</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">func2subr</span>

<span class="s1">options = {}</span>
<span class="s1">sepdict = {}</span>
<span class="s0">#for k in ['need_cfuncs']: sepdict[k]=','</span>
<span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'decl'</span><span class="s3">,</span>
          <span class="s4">'frompyobj'</span><span class="s3">,</span>
          <span class="s4">'cleanupfrompyobj'</span><span class="s3">,</span>
          <span class="s4">'topyarr'</span><span class="s3">, </span><span class="s4">'method'</span><span class="s3">,</span>
          <span class="s4">'pyobjfrom'</span><span class="s3">, </span><span class="s4">'closepyobjfrom'</span><span class="s3">,</span>
          <span class="s4">'freemem'</span><span class="s3">,</span>
          <span class="s4">'userincludes'</span><span class="s3">,</span>
          <span class="s4">'includes0'</span><span class="s3">, </span><span class="s4">'includes'</span><span class="s3">, </span><span class="s4">'typedefs'</span><span class="s3">, </span><span class="s4">'typedefs_generated'</span><span class="s3">,</span>
          <span class="s4">'cppmacros'</span><span class="s3">, </span><span class="s4">'cfuncs'</span><span class="s3">, </span><span class="s4">'callbacks'</span><span class="s3">,</span>
          <span class="s4">'latexdoc'</span><span class="s3">,</span>
          <span class="s4">'restdoc'</span><span class="s3">,</span>
          <span class="s4">'routine_defs'</span><span class="s3">, </span><span class="s4">'externroutines'</span><span class="s3">,</span>
          <span class="s4">'initf2pywraphooks'</span><span class="s3">,</span>
          <span class="s4">'commonhooks'</span><span class="s3">, </span><span class="s4">'initcommonhooks'</span><span class="s3">,</span>
          <span class="s4">'f90modhooks'</span><span class="s3">, </span><span class="s4">'initf90modhooks'</span><span class="s1">]:</span>
    <span class="s1">sepdict[k] = </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span>

<span class="s0">#################### Rules for C/API module #################</span>

<span class="s1">generationtime = int(os.environ.get(</span><span class="s4">'SOURCE_DATE_EPOCH'</span><span class="s3">, </span><span class="s1">time.time()))</span>
<span class="s1">module_rules = {</span>
    <span class="s4">'modulebody'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">/* File: #modulename#module.c 
 * This file is auto-generated with f2py (version:#f2py_version#). 
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition, 
 * written by Pearu Peterson &lt;pearu@cens.ioc.ee&gt;. 
 * Generation date: &quot;&quot;&quot; </span><span class="s1">+ time.asctime(time.gmtime(generationtime)) + </span><span class="s4">&quot;&quot;&quot; 
 * Do not edit this file directly unless you know what you are doing!!! 
 */ 
 
#ifdef __cplusplus 
extern </span><span class="s3">\&quot;</span><span class="s4">C</span><span class="s3">\&quot; </span><span class="s4">{ 
#endif 
 
#ifndef PY_SSIZE_T_CLEAN 
#define PY_SSIZE_T_CLEAN 
#endif /* PY_SSIZE_T_CLEAN */ 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cfuncs.py: includes&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#includes# 
#includes0# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/rules.py: mod_rules['modulebody']&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
static PyObject *#modulename#_error; 
static PyObject *#modulename#_module; 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cfuncs.py: typedefs&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#typedefs# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cfuncs.py: typedefs_generated&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#typedefs_generated# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cfuncs.py: cppmacros&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#cppmacros# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cfuncs.py: cfuncs&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#cfuncs# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cfuncs.py: userincludes&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#userincludes# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/capi_rules.py: usercode&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#usercode# 
 
/* See f2py2e/rules.py */ 
#externroutines# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/capi_rules.py: usercode1&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#usercode1# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/cb_rules.py: buildcallback&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#callbacks# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/rules.py: buildapi&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#body# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/f90mod_rules.py: buildhooks&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#f90modhooks# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/rules.py: module_rules['modulebody']&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/common_rules.py: buildhooks&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
#commonhooks# 
 
&quot;&quot;&quot; </span><span class="s1">+ gentitle(</span><span class="s4">&quot;See f2py2e/rules.py&quot;</span><span class="s1">) + </span><span class="s4">&quot;&quot;&quot; 
 
static FortranDataDef f2py_routine_defs[] = { 
#routine_defs# 
    {NULL} 
}; 
 
static PyMethodDef f2py_module_methods[] = { 
#pymethoddef# 
    {NULL,NULL} 
}; 
 
static struct PyModuleDef moduledef = { 
    PyModuleDef_HEAD_INIT, 
    &quot;#modulename#&quot;, 
    NULL, 
    -1, 
    f2py_module_methods, 
    NULL, 
    NULL, 
    NULL, 
    NULL 
}; 
 
PyMODINIT_FUNC PyInit_#modulename#(void) { 
    int i; 
    PyObject *m,*d, *s, *tmp; 
    m = #modulename#_module = PyModule_Create(&amp;moduledef); 
    Py_SET_TYPE(&amp;PyFortran_Type, &amp;PyType_Type); 
    import_array(); 
    if (PyErr_Occurred()) 
        {PyErr_SetString(PyExc_ImportError, </span><span class="s3">\&quot;</span><span class="s4">can't initialize module #modulename# (failed to import numpy)</span><span class="s3">\&quot;</span><span class="s4">); return m;} 
    d = PyModule_GetDict(m); 
    s = PyUnicode_FromString(</span><span class="s3">\&quot;</span><span class="s4">#f2py_version#</span><span class="s3">\&quot;</span><span class="s4">); 
    PyDict_SetItemString(d, </span><span class="s3">\&quot;</span><span class="s4">__version__</span><span class="s3">\&quot;</span><span class="s4">, s); 
    Py_DECREF(s); 
    s = PyUnicode_FromString( 
        </span><span class="s3">\&quot;</span><span class="s4">This module '#modulename#' is auto-generated with f2py (version:#f2py_version#).</span><span class="s3">\\</span><span class="s4">nFunctions:</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;\n</span><span class="s4">#docs#</span><span class="s3">\&quot;</span><span class="s4">.</span><span class="s3">\&quot;</span><span class="s4">); 
    PyDict_SetItemString(d, </span><span class="s3">\&quot;</span><span class="s4">__doc__</span><span class="s3">\&quot;</span><span class="s4">, s); 
    Py_DECREF(s); 
    s = PyUnicode_FromString(</span><span class="s3">\&quot;</span><span class="s4">&quot;&quot;&quot; </span><span class="s1">+ numpy_version + </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\&quot;</span><span class="s4">); 
    PyDict_SetItemString(d, </span><span class="s3">\&quot;</span><span class="s4">__f2py_numpy_version__</span><span class="s3">\&quot;</span><span class="s4">, s); 
    Py_DECREF(s); 
    #modulename#_error = PyErr_NewException (</span><span class="s3">\&quot;</span><span class="s4">#modulename#.error</span><span class="s3">\&quot;</span><span class="s4">, NULL, NULL); 
    /* 
     * Store the error object inside the dict, so that it could get deallocated. 
     * (in practice, this is a module, so it likely will not and cannot.) 
     */ 
    PyDict_SetItemString(d, </span><span class="s3">\&quot;</span><span class="s4">_#modulename#_error</span><span class="s3">\&quot;</span><span class="s4">, #modulename#_error); 
    Py_DECREF(#modulename#_error); 
    for(i=0;f2py_routine_defs[i].name!=NULL;i++) { 
        tmp = PyFortranObject_NewAsAttr(&amp;f2py_routine_defs[i]); 
        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp); 
        Py_DECREF(tmp); 
    } 
#initf2pywraphooks# 
#initf90modhooks# 
#initcommonhooks# 
#interface_usercode# 
 
#ifdef F2PY_REPORT_ATEXIT 
    if (! PyErr_Occurred()) 
        on_exit(f2py_report_on_exit,(void*)</span><span class="s3">\&quot;</span><span class="s4">#modulename#</span><span class="s3">\&quot;</span><span class="s4">); 
#endif 
    return m; 
} 
#ifdef __cplusplus 
} 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">'separatorsfor'</span><span class="s1">: {</span><span class="s4">'latexdoc'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n\n</span><span class="s4">'</span><span class="s3">,</span>
                      <span class="s4">'restdoc'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n\n</span><span class="s4">'</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s4">'latexdoc'</span><span class="s1">: [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">section{Module </span><span class="s3">\\</span><span class="s4">texttt{#texmodulename#}}</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                 <span class="s4">'#modnote#</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                 <span class="s4">'#latexdoc#'</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s4">'restdoc'</span><span class="s1">: [</span><span class="s4">'Module #modulename#</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">+ </span><span class="s4">'=' </span><span class="s1">* </span><span class="s5">80</span><span class="s3">,</span>
                <span class="s4">'</span><span class="s3">\n</span><span class="s4">#restdoc#'</span><span class="s1">]</span>
<span class="s1">}</span>

<span class="s1">defmod_rules = [</span>
    <span class="s1">{</span><span class="s4">'body'</span><span class="s1">: </span><span class="s4">'/*eof body*/'</span><span class="s3">,</span>
     <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'/*eof method*/'</span><span class="s3">,</span>
     <span class="s4">'externroutines'</span><span class="s1">: </span><span class="s4">'/*eof externroutines*/'</span><span class="s3">,</span>
     <span class="s4">'routine_defs'</span><span class="s1">: </span><span class="s4">'/*eof routine_defs*/'</span><span class="s3">,</span>
     <span class="s4">'initf90modhooks'</span><span class="s1">: </span><span class="s4">'/*eof initf90modhooks*/'</span><span class="s3">,</span>
     <span class="s4">'initf2pywraphooks'</span><span class="s1">: </span><span class="s4">'/*eof initf2pywraphooks*/'</span><span class="s3">,</span>
     <span class="s4">'initcommonhooks'</span><span class="s1">: </span><span class="s4">'/*eof initcommonhooks*/'</span><span class="s3">,</span>
     <span class="s4">'latexdoc'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
     <span class="s4">'restdoc'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
     <span class="s4">'modnote'</span><span class="s1">: {hasnote: </span><span class="s4">'#note#'</span><span class="s3">, </span><span class="s1">l_not(hasnote): </span><span class="s4">''</span><span class="s1">}</span><span class="s3">,</span>
     <span class="s1">}</span>
<span class="s1">]</span>

<span class="s1">routine_rules = {</span>
    <span class="s4">'separatorsfor'</span><span class="s1">: sepdict</span><span class="s3">,</span>
    <span class="s4">'body'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#begintitle# 
static char doc_#apiname#[] = </span><span class="s3">\&quot;\\\n</span><span class="s4">#docreturn##name#(#docsignatureshort#)</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\\</span><span class="s4">nWrapper for ``#name#``.</span><span class="s3">\\\n\\</span><span class="s4">n#docstrsigns#</span><span class="s3">\&quot;</span><span class="s4">; 
/* #declfortranroutine# */ 
static PyObject *#apiname#(const PyObject *capi_self, 
                           PyObject *capi_args, 
                           PyObject *capi_keywds, 
                           #functype# (*f2py_func)(#callprotoargument#)) { 
    PyObject * volatile capi_buildvalue = NULL; 
    volatile int f2py_success = 1; 
#decl# 
    static char *capi_kwlist[] = {#kwlist##kwlistopt##kwlistxa#NULL}; 
#usercode# 
#routdebugenter# 
#ifdef F2PY_REPORT_ATEXIT 
f2py_start_clock(); 
#endif 
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,</span><span class="s3">\\</span>
        <span class="s3">\&quot;</span><span class="s4">#argformat#|#keyformat##xaformat#:#pyname#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\\</span>
        <span class="s4">capi_kwlist#args_capi##keys_capi##keys_xa#))</span><span class="s3">\n        </span><span class="s4">return NULL; 
#frompyobj# 
/*end of frompyobj*/ 
#ifdef F2PY_REPORT_ATEXIT 
f2py_start_call_clock(); 
#endif 
#callfortranroutine# 
if (PyErr_Occurred()) 
  f2py_success = 0; 
#ifdef F2PY_REPORT_ATEXIT 
f2py_stop_call_clock(); 
#endif 
/*end of callfortranroutine*/ 
        if (f2py_success) { 
#pyobjfrom# 
/*end of pyobjfrom*/ 
        CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">Building return value.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        capi_buildvalue = Py_BuildValue(</span><span class="s3">\&quot;</span><span class="s4">#returnformat#</span><span class="s3">\&quot;</span><span class="s4">#return#); 
/*closepyobjfrom*/ 
#closepyobjfrom# 
        } /*if (f2py_success) after callfortranroutine*/ 
/*cleanupfrompyobj*/ 
#cleanupfrompyobj# 
    if (capi_buildvalue == NULL) { 
#routdebugfailure# 
    } else { 
#routdebugleave# 
    } 
    CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">Freeing memory.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#freemem# 
#ifdef F2PY_REPORT_ATEXIT 
f2py_stop_clock(); 
#endif 
    return capi_buildvalue; 
} 
#endtitle# 
&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">'routine_defs'</span><span class="s1">: </span><span class="s4">'#routine_def#'</span><span class="s3">,</span>
    <span class="s4">'initf2pywraphooks'</span><span class="s1">: </span><span class="s4">'#initf2pywraphook#'</span><span class="s3">,</span>
    <span class="s4">'externroutines'</span><span class="s1">: </span><span class="s4">'#declfortranroutine#'</span><span class="s3">,</span>
    <span class="s4">'doc'</span><span class="s1">: </span><span class="s4">'#docreturn##name#(#docsignature#)'</span><span class="s3">,</span>
    <span class="s4">'docshort'</span><span class="s1">: </span><span class="s4">'#docreturn##name#(#docsignatureshort#)'</span><span class="s3">,</span>
    <span class="s4">'docs'</span><span class="s1">: </span><span class="s4">'&quot;    #docreturn##name#(#docsignature#)</span><span class="s3">\\</span><span class="s4">n&quot;</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
    <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'arrayobject.h'</span><span class="s3">, </span><span class="s4">'CFUNCSMESS'</span><span class="s3">, </span><span class="s4">'MINMAX'</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s4">'cppmacros'</span><span class="s1">: {debugcapi: </span><span class="s4">'#define DEBUGCFUNCS'</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s4">'latexdoc'</span><span class="s1">: [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">subsection{Wrapper function </span><span class="s3">\\</span><span class="s4">texttt{#texname#}}</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                 <span class="s4">&quot;&quot;&quot; 
</span><span class="s3">\\</span><span class="s4">noindent{{}</span><span class="s3">\\</span><span class="s4">verb@#docreturn##name#@{}}</span><span class="s3">\\</span><span class="s4">texttt{(#latexdocsignatureshort#)} 
#routnote# 
 
#latexdocstrsigns# 
&quot;&quot;&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s4">'restdoc'</span><span class="s1">: [</span><span class="s4">'Wrapped function ``#name#``</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">+ </span><span class="s4">'-' </span><span class="s1">* </span><span class="s5">80</span><span class="s3">,</span>

                <span class="s1">]</span>
<span class="s1">}</span>

<span class="s0">################## Rules for C/API function ##############</span>

<span class="s1">rout_rules = [</span>
    <span class="s1">{  </span><span class="s0"># Init</span>
        <span class="s4">'separatorsfor'</span><span class="s1">: {</span><span class="s4">'callfortranroutine'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'routdebugenter'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'routdebugleave'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'routdebugfailure'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'setjmpbuf'</span><span class="s1">: </span><span class="s4">' || '</span><span class="s3">,</span>
                          <span class="s4">'docstrreq'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'docstropt'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'docstrout'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'docstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'docstrsigns'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">n&quot;</span><span class="s3">\n</span><span class="s4">&quot;'</span><span class="s3">,</span>
                          <span class="s4">'latexdocstrsigns'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'latexdocstrreq'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'latexdocstropt'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'latexdocstrout'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'latexdocstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'kwlist'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'kwlistopt'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'callfortran'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'callfortranappend'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'docsign'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'docsignopt'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'/*decl*/'</span><span class="s3">,</span>
        <span class="s4">'freemem'</span><span class="s1">: </span><span class="s4">'/*freemem*/'</span><span class="s3">,</span>
        <span class="s4">'docsignshort'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'docsignoptshort'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'docstrsigns'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'latexdocstrsigns'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'docstrreq'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">nParameters</span><span class="s3">\\</span><span class="s4">n----------'</span><span class="s3">,</span>
        <span class="s4">'docstropt'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">nOther Parameters</span><span class="s3">\\</span><span class="s4">n----------------'</span><span class="s3">,</span>
        <span class="s4">'docstrout'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">nReturns</span><span class="s3">\\</span><span class="s4">n-------'</span><span class="s3">,</span>
        <span class="s4">'docstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">nNotes</span><span class="s3">\\</span><span class="s4">n-----</span><span class="s3">\\</span><span class="s4">nCall-back functions::</span><span class="s3">\\</span><span class="s4">n'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrreq'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Required arguments:'</span><span class="s3">,</span>
        <span class="s4">'latexdocstropt'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Optional arguments:'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrout'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Return objects:'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Call-back functions:'</span><span class="s3">,</span>
        <span class="s4">'args_capi'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'keys_capi'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'functype'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'/*frompyobj*/'</span><span class="s3">,</span>
        <span class="s0"># this list will be reversed</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: [</span><span class="s4">'/*end of cleanupfrompyobj*/'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: </span><span class="s4">'/*pyobjfrom*/'</span><span class="s3">,</span>
        <span class="s0"># this list will be reversed</span>
        <span class="s4">'closepyobjfrom'</span><span class="s1">: [</span><span class="s4">'/*end of closepyobjfrom*/'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'topyarr'</span><span class="s1">: </span><span class="s4">'/*topyarr*/'</span><span class="s3">, </span><span class="s4">'routdebugleave'</span><span class="s1">: </span><span class="s4">'/*routdebugleave*/'</span><span class="s3">,</span>
        <span class="s4">'routdebugenter'</span><span class="s1">: </span><span class="s4">'/*routdebugenter*/'</span><span class="s3">,</span>
        <span class="s4">'routdebugfailure'</span><span class="s1">: </span><span class="s4">'/*routdebugfailure*/'</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">: </span><span class="s4">'/*callfortranroutine*/'</span><span class="s3">,</span>
        <span class="s4">'argformat'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'keyformat'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'need_cfuncs'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'docreturn'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'return'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'returnformat'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'rformat'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'kwlistxa'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'keys_xa'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'xaformat'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'docsignxa'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'docsignxashort'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'initf2pywraphook'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'routnote'</span><span class="s1">: {hasnote: </span><span class="s4">'--- #note#'</span><span class="s3">, </span><span class="s1">l_not(hasnote): </span><span class="s4">''</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'apiname'</span><span class="s1">: </span><span class="s4">'f2py_rout_#modulename#_#name#'</span><span class="s3">,</span>
        <span class="s4">'pyname'</span><span class="s1">: </span><span class="s4">'#modulename#.#name#'</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_not(ismoduleroutine)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'apiname'</span><span class="s1">: </span><span class="s4">'f2py_rout_#modulename#_#f90modulename#_#name#'</span><span class="s3">,</span>
        <span class="s4">'pyname'</span><span class="s1">: </span><span class="s4">'#modulename#.#f90modulename#.#name#'</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: ismoduleroutine</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Subroutine</span>
        <span class="s4">'functype'</span><span class="s1">: </span><span class="s4">'void'</span><span class="s3">,</span>
        <span class="s4">'declfortranroutine'</span><span class="s1">: {l_and(l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isintent_c))</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);'</span><span class="s3">,</span>
                               <span class="s1">l_and(l_not(ismoduleroutine)</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'extern void #fortranname#(#callprotoargument#);'</span><span class="s3">,</span>
                               <span class="s1">ismoduleroutine: </span><span class="s4">''</span><span class="s3">,</span>
                               <span class="s1">isdummyroutine: </span><span class="s4">''</span>
                               <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'routine_def'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">l_and(l_not(ismoduleroutine)</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">l_and(l_not(ismoduleroutine)</span><span class="s3">, </span><span class="s1">isdummyroutine): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {l_and(l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isintent_c))</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'F_FUNC'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">: [</span>
            <span class="s1">{debugcapi: [</span>
                <span class="s4">&quot;&quot;&quot;    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Fortran subroutine `#fortranname#(#callfortran#)</span><span class="s3">\'\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">);&quot;&quot;&quot;</span><span class="s1">]}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">if (#setjmpbuf#) { 
            f2py_success = 0; 
        } else {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'            Py_BEGIN_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hascallstatement: </span><span class="s4">'''                #callstatement#; 
                /*(*f2py_func)(#callfortran#);*/'''</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_not(l_or(hascallstatement</span><span class="s3">, </span><span class="s1">isdummyroutine))</span>
                   <span class="s1">: </span><span class="s4">'                (*f2py_func)(#callfortran#);'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'            Py_END_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">&quot;&quot;&quot;        }&quot;&quot;&quot;</span><span class="s1">}</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(issubroutine</span><span class="s3">, </span><span class="s1">l_not(issubroutine_wrap))</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Wrapped function</span>
        <span class="s4">'functype'</span><span class="s1">: </span><span class="s4">'void'</span><span class="s3">,</span>
        <span class="s4">'declfortranroutine'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);'</span><span class="s3">,</span>
                               <span class="s1">isdummyroutine: </span><span class="s4">''</span><span class="s3">,</span>
                               <span class="s1">}</span><span class="s3">,</span>

        <span class="s4">'routine_def'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#F_WRAPPEDFUNC#(#name_lower#,#NAME#),(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">isdummyroutine: </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'initf2pywraphook'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">''' 
    { 
      extern #ctype# #F_FUNC#(#name_lower#,#NAME#)(void); 
      PyObject* o = PyDict_GetItemString(d,&quot;#name#&quot;); 
      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL); 
      PyObject_SetAttrString(o,&quot;_cpointer&quot;, tmp); 
      Py_DECREF(tmp); 
      s = PyUnicode_FromString(&quot;#name#&quot;); 
      PyObject_SetAttrString(o,&quot;__name__&quot;, s); 
      Py_DECREF(s); 
    } 
    '''</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): [</span><span class="s4">'F_WRAPPEDFUNC'</span><span class="s3">, </span><span class="s4">'F_FUNC'</span><span class="s1">]}</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">: [</span>
            <span class="s1">{debugcapi: [</span>
                <span class="s4">&quot;&quot;&quot;    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)</span><span class="s3">\'\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">);&quot;&quot;&quot;</span><span class="s1">]}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (#setjmpbuf#) { 
        f2py_success = 0; 
    } else {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'    Py_BEGIN_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_not(l_or(hascallstatement</span><span class="s3">, </span><span class="s1">isdummyroutine))</span>
                   <span class="s1">: </span><span class="s4">'    (*f2py_func)(#callfortran#);'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hascallstatement:</span>
                <span class="s4">'    #callstatement#;</span><span class="s3">\n    </span><span class="s4">/*(*f2py_func)(#callfortran#);*/'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'    Py_END_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">'    }'</span><span class="s1">}</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isfunction_wrap</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Wrapped subroutine</span>
        <span class="s4">'functype'</span><span class="s1">: </span><span class="s4">'void'</span><span class="s3">,</span>
        <span class="s4">'declfortranroutine'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);'</span><span class="s3">,</span>
                               <span class="s1">isdummyroutine: </span><span class="s4">''</span><span class="s3">,</span>
                               <span class="s1">}</span><span class="s3">,</span>

        <span class="s4">'routine_def'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#F_WRAPPEDFUNC#(#name_lower#,#NAME#),(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">isdummyroutine: </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'initf2pywraphook'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): </span><span class="s4">''' 
    { 
      extern void #F_FUNC#(#name_lower#,#NAME#)(void); 
      PyObject* o = PyDict_GetItemString(d,&quot;#name#&quot;); 
      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL); 
      PyObject_SetAttrString(o,&quot;_cpointer&quot;, tmp); 
      Py_DECREF(tmp); 
      s = PyUnicode_FromString(&quot;#name#&quot;); 
      PyObject_SetAttrString(o,&quot;__name__&quot;, s); 
      Py_DECREF(s); 
    } 
    '''</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isdummyroutine)): [</span><span class="s4">'F_WRAPPEDFUNC'</span><span class="s3">, </span><span class="s4">'F_FUNC'</span><span class="s1">]}</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">: [</span>
            <span class="s1">{debugcapi: [</span>
                <span class="s4">&quot;&quot;&quot;    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)</span><span class="s3">\'\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">);&quot;&quot;&quot;</span><span class="s1">]}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (#setjmpbuf#) { 
        f2py_success = 0; 
    } else {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'    Py_BEGIN_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_not(l_or(hascallstatement</span><span class="s3">, </span><span class="s1">isdummyroutine))</span>
                   <span class="s1">: </span><span class="s4">'    (*f2py_func)(#callfortran#);'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hascallstatement:</span>
                <span class="s4">'    #callstatement#;</span><span class="s3">\n    </span><span class="s4">/*(*f2py_func)(#callfortran#);*/'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'    Py_END_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">'    }'</span><span class="s1">}</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: issubroutine_wrap</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Function</span>
        <span class="s4">'functype'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
        <span class="s4">'docreturn'</span><span class="s1">: {l_not(isintent_hide): </span><span class="s4">'#rname#,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstrout'</span><span class="s1">: </span><span class="s4">'#pydocsignout#'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrout'</span><span class="s1">: [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsignout#@{}}'</span><span class="s3">,</span>
                           <span class="s1">{hasresultnote: </span><span class="s4">'--- #resultnote#'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">: [{l_and(debugcapi</span><span class="s3">, </span><span class="s1">isstringfunction): </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef USESCOMPAQFORTRAN 
    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Fortran function #ctype# #fortranname#(#callcompaqfortran#)</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#else 
    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#endif 
&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
                               <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">l_not(isstringfunction)): </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
&quot;&quot;&quot;</span><span class="s1">}</span>
                               <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isfunction</span><span class="s3">, </span><span class="s1">l_not(isfunction_wrap))</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Scalar function</span>
        <span class="s4">'declfortranroutine'</span><span class="s1">: {l_and(l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isintent_c))</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'extern #ctype# #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);'</span><span class="s3">,</span>
                               <span class="s1">l_and(l_not(ismoduleroutine)</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'extern #ctype# #fortranname#(#callprotoargument#);'</span><span class="s3">,</span>
                               <span class="s1">isdummyroutine: </span><span class="s4">''</span>
                               <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'routine_def'</span><span class="s1">: {l_and(l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isintent_c))</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">l_and(l_not(ismoduleroutine)</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">, </span><span class="s1">l_not(isdummyroutine)): </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">isdummyroutine: </span><span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: [{iscomplexfunction_warn: </span><span class="s4">'    #ctype# #name#_return_value={0,0};'</span><span class="s3">,</span>
                  <span class="s1">l_not(iscomplexfunction): </span><span class="s4">'    #ctype# #name#_return_value=0;'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{iscomplexfunction:</span>
                  <span class="s4">'    PyObject *#name#_return_value_capi = Py_None;'</span><span class="s1">}</span>
                 <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">: [</span>
            <span class="s1">{hasexternals: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (#setjmpbuf#) { 
        f2py_success = 0; 
    } else {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'    Py_BEGIN_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hascallstatement: </span><span class="s4">'''    #callstatement#; 
/*    #name#_return_value = (*f2py_func)(#callfortran#);*/ 
'''</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_not(l_or(hascallstatement</span><span class="s3">, </span><span class="s1">isdummyroutine))</span>
                   <span class="s1">: </span><span class="s4">'    #name#_return_value = (*f2py_func)(#callfortran#);'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isthreadsafe: </span><span class="s4">'    Py_END_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hasexternals: </span><span class="s4">'    }'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">iscomplexfunction)</span>
                   <span class="s1">: </span><span class="s4">'    fprintf(stderr,&quot;#routdebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#name#_return_value.r,#name#_return_value.i);'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">l_not(iscomplexfunction)): </span><span class="s4">'    fprintf(stderr,&quot;#routdebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#name#_return_value);'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {iscomplexfunction: </span><span class="s4">'    #name#_return_value_capi = pyobj_from_#ctype#1(#name#_return_value);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [{l_not(isdummyroutine): </span><span class="s4">'F_FUNC'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{iscomplexfunction: </span><span class="s4">'pyobj_from_#ctype#1'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{islong_longfunction: </span><span class="s4">'long_long'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{islong_doublefunction: </span><span class="s4">'long_double'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'returnformat'</span><span class="s1">: {l_not(isintent_hide): </span><span class="s4">'#rformat#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: {iscomplexfunction: </span><span class="s4">',#name#_return_value_capi'</span><span class="s3">,</span>
                   <span class="s1">l_not(l_or(iscomplexfunction</span><span class="s3">, </span><span class="s1">isintent_hide)): </span><span class="s4">',#name#_return_value'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isfunction</span><span class="s3">, </span><span class="s1">l_not(isstringfunction)</span><span class="s3">, </span><span class="s1">l_not(isfunction_wrap))</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># String function # in use for --no-wrap</span>
        <span class="s4">'declfortranroutine'</span><span class="s1">: </span><span class="s4">'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);'</span><span class="s3">,</span>
        <span class="s4">'routine_def'</span><span class="s1">: {l_not(l_or(ismoduleroutine</span><span class="s3">, </span><span class="s1">isintent_c)):</span>
                        <span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},'</span><span class="s3">,</span>
                        <span class="s1">l_and(l_not(ismoduleroutine)</span><span class="s3">, </span><span class="s1">isintent_c):</span>
                        <span class="s4">'    {</span><span class="s3">\&quot;</span><span class="s4">#name#</span><span class="s3">\&quot;</span><span class="s4">,-1,{{-1}},0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},'</span>
                        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: [</span><span class="s4">'    #ctype# #name#_return_value = NULL;'</span><span class="s3">,</span>
                 <span class="s4">'    int #name#_return_value_len = 0;'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'callfortran'</span><span class="s1">:</span><span class="s4">'#name#_return_value,#name#_return_value_len,'</span><span class="s3">,</span>
        <span class="s4">'callfortranroutine'</span><span class="s1">:[</span><span class="s4">'    #name#_return_value_len = #rlength#;'</span><span class="s3">,</span>
                              <span class="s4">'    if ((#name#_return_value = (string)malloc('</span>
                              <span class="s1">+ </span><span class="s4">'#name#_return_value_len+1) == NULL) {'</span><span class="s3">,</span>
                              <span class="s4">'        PyErr_SetString(PyExc_MemoryError, </span><span class="s3">\&quot;</span><span class="s4">out of memory</span><span class="s3">\&quot;</span><span class="s4">);'</span><span class="s3">,</span>
                              <span class="s4">'        f2py_success = 0;'</span><span class="s3">,</span>
                              <span class="s4">'    } else {'</span><span class="s3">,</span>
                              <span class="s4">&quot;        (#name#_return_value)[#name#_return_value_len] = '</span><span class="s3">\\</span><span class="s4">0';&quot;</span><span class="s3">,</span>
                              <span class="s4">'    }'</span><span class="s3">,</span>
                              <span class="s4">'    if (f2py_success) {'</span><span class="s3">,</span>
                              <span class="s1">{hasexternals: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">if (#setjmpbuf#) { 
            f2py_success = 0; 
        } else {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
                              <span class="s1">{isthreadsafe: </span><span class="s4">'        Py_BEGIN_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
                              <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef USESCOMPAQFORTRAN 
        (*f2py_func)(#callcompaqfortran#); 
#else 
        (*f2py_func)(#callfortran#); 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
                              <span class="s1">{isthreadsafe: </span><span class="s4">'        Py_END_ALLOW_THREADS'</span><span class="s1">}</span><span class="s3">,</span>
                              <span class="s1">{hasexternals: </span><span class="s4">'        }'</span><span class="s1">}</span><span class="s3">,</span>
                              <span class="s1">{debugcapi:</span>
                                  <span class="s4">'        fprintf(stderr,&quot;#routdebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#name#_return_value_len,#name#_return_value);'</span><span class="s1">}</span><span class="s3">,</span>
                              <span class="s4">'    } /* if (f2py_success) after (string)malloc */'</span><span class="s3">,</span>
                              <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'returnformat'</span><span class="s1">: </span><span class="s4">'#rformat#'</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: </span><span class="s4">',#name#_return_value'</span><span class="s3">,</span>
        <span class="s4">'freemem'</span><span class="s1">: </span><span class="s4">'    STRINGFREE(#name#_return_value);'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'F_FUNC'</span><span class="s3">, </span><span class="s4">'#ctype#'</span><span class="s3">, </span><span class="s4">'STRINGFREE'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">:l_and(isstringfunction</span><span class="s3">, </span><span class="s1">l_not(isfunction_wrap))  </span><span class="s0"># ???obsolete</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># Debugging</span>
        <span class="s4">'routdebugenter'</span><span class="s1">: </span><span class="s4">'    fprintf(stderr,&quot;debug-capi:Python C/API function #modulename#.#name#(#docsignature#)</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s3">,</span>
        <span class="s4">'routdebugleave'</span><span class="s1">: </span><span class="s4">'    fprintf(stderr,&quot;debug-capi:Python C/API function #modulename#.#name#: successful.</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s3">,</span>
        <span class="s4">'routdebugfailure'</span><span class="s1">: </span><span class="s4">'    fprintf(stderr,&quot;debug-capi:Python C/API function #modulename#.#name#: failure.</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: debugcapi</span>
    <span class="s1">}</span>
<span class="s1">]</span>

<span class="s0">################ Rules for arguments ##################</span>

<span class="s1">typedef_need_dict = {islong_long: </span><span class="s4">'long_long'</span><span class="s3">,</span>
                     <span class="s1">islong_double: </span><span class="s4">'long_double'</span><span class="s3">,</span>
                     <span class="s1">islong_complex: </span><span class="s4">'complex_long_double'</span><span class="s3">,</span>
                     <span class="s1">isunsigned_char: </span><span class="s4">'unsigned_char'</span><span class="s3">,</span>
                     <span class="s1">isunsigned_short: </span><span class="s4">'unsigned_short'</span><span class="s3">,</span>
                     <span class="s1">isunsigned: </span><span class="s4">'unsigned'</span><span class="s3">,</span>
                     <span class="s1">isunsigned_long_long: </span><span class="s4">'unsigned_long_long'</span><span class="s3">,</span>
                     <span class="s1">isunsigned_chararray: </span><span class="s4">'unsigned_char'</span><span class="s3">,</span>
                     <span class="s1">isunsigned_shortarray: </span><span class="s4">'unsigned_short'</span><span class="s3">,</span>
                     <span class="s1">isunsigned_long_longarray: </span><span class="s4">'unsigned_long_long'</span><span class="s3">,</span>
                     <span class="s1">issigned_long_longarray: </span><span class="s4">'long_long'</span><span class="s3">,</span>
                     <span class="s1">}</span>

<span class="s1">aux_rules = [</span>
    <span class="s1">{</span>
        <span class="s4">'separatorsfor'</span><span class="s1">: sepdict</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [</span><span class="s4">'    /* Processing auxiliary variable #varname# */'</span><span class="s3">,</span>
                      <span class="s1">{debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebuginfo#</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s1">}</span><span class="s3">, </span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    /* End of cleaning variable #varname# */'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: typedef_need_dict</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Scalars (not complex)</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    #ctype# #varname# = 0;'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {hasinitvalue: </span><span class="s4">'math.h'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {hasinitvalue: </span><span class="s4">'    #varname# = #init#;'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex))</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{</span>
        <span class="s4">'return'</span><span class="s1">: </span><span class="s4">',#varname#'</span><span class="s3">,</span>
        <span class="s4">'docstrout'</span><span class="s1">: </span><span class="s4">'#pydocsignout#'</span><span class="s3">,</span>
        <span class="s4">'docreturn'</span><span class="s1">: </span><span class="s4">'#outvarname#,'</span><span class="s3">,</span>
        <span class="s4">'returnformat'</span><span class="s1">: </span><span class="s4">'#varrformat#'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex)</span><span class="s3">, </span><span class="s1">isintent_out)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Complex scalars</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    #ctype# #varname#;'</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {hasinitvalue: </span><span class="s4">'    #varname#.r = #init.r#, #varname#.i = #init.i#;'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: iscomplex</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># String</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: [</span><span class="s4">'    #ctype# #varname# = NULL;'</span><span class="s3">,</span>
                 <span class="s4">'    int slen(#varname#);'</span><span class="s3">,</span>
                 <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">:[</span><span class="s4">'len..'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">:isstring</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Array</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: [</span><span class="s4">'    #ctype# *#varname# = NULL;'</span><span class="s3">,</span>
                 <span class="s4">'    npy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};'</span><span class="s3">,</span>
                 <span class="s4">'    const int #varname#_Rank = #rank#;'</span><span class="s3">,</span>
                 <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">:[</span><span class="s4">'len..'</span><span class="s3">, </span><span class="s1">{hasinitvalue: </span><span class="s4">'forcomb'</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{hasinitvalue: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isarray</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Scalararray</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">l_not(iscomplexarray))</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Not hidden</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">l_not(iscomplexarray)</span><span class="s3">, </span><span class="s1">isintent_nothide)</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*1 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isint1array</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*-1 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isunsigned_chararray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*-2 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isunsigned_shortarray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*-8 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isunsigned_long_longarray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Complexarray</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: iscomplexarray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Stringarray</span>
    <span class="s1">{</span>
        <span class="s4">'callfortranappend'</span><span class="s1">: {isarrayofstrings: </span><span class="s4">'flen(#varname#),'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'string'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isstringarray</span>
    <span class="s1">}</span>
<span class="s1">]</span>

<span class="s1">arg_rules = [</span>
    <span class="s1">{</span>
        <span class="s4">'separatorsfor'</span><span class="s1">: sepdict</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [</span><span class="s4">'    /* Processing variable #varname# */'</span><span class="s3">,</span>
                      <span class="s1">{debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebuginfo#</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s1">}</span><span class="s3">, </span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    /* End of cleaning variable #varname# */'</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: typedef_need_dict</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Doc signatures</span>
    <span class="s1">{</span>
        <span class="s4">'docstropt'</span><span class="s1">: {l_and(isoptional</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'#pydocsign#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstrreq'</span><span class="s1">: {l_and(isrequired</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'#pydocsign#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstrout'</span><span class="s1">: {isintent_out: </span><span class="s4">'#pydocsignout#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'latexdocstropt'</span><span class="s1">: {l_and(isoptional</span><span class="s3">, </span><span class="s1">isintent_nothide): [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsign#@{}}'</span><span class="s3">,</span>
                                                                 <span class="s1">{hasnote: </span><span class="s4">'--- #note#'</span><span class="s1">}]}</span><span class="s3">,</span>
        <span class="s4">'latexdocstrreq'</span><span class="s1">: {l_and(isrequired</span><span class="s3">, </span><span class="s1">isintent_nothide): [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsign#@{}}'</span><span class="s3">,</span>
                                                                 <span class="s1">{hasnote: </span><span class="s4">'--- #note#'</span><span class="s1">}]}</span><span class="s3">,</span>
        <span class="s4">'latexdocstrout'</span><span class="s1">: {isintent_out: [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsignout#@{}}'</span><span class="s3">,</span>
                                          <span class="s1">{l_and(hasnote</span><span class="s3">, </span><span class="s1">isintent_hide): </span><span class="s4">'--- #note#'</span><span class="s3">,</span>
                                           <span class="s1">l_and(hasnote</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'--- See above.'</span><span class="s1">}]}</span><span class="s3">,</span>
        <span class="s4">'depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Required/Optional arguments</span>
    <span class="s1">{</span>
        <span class="s4">'kwlist'</span><span class="s1">: </span><span class="s4">'&quot;#varname#&quot;,'</span><span class="s3">,</span>
        <span class="s4">'docsign'</span><span class="s1">: </span><span class="s4">'#varname#,'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isintent_nothide</span><span class="s3">, </span><span class="s1">l_not(isoptional))</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{</span>
        <span class="s4">'kwlistopt'</span><span class="s1">: </span><span class="s4">'&quot;#varname#&quot;,'</span><span class="s3">,</span>
        <span class="s4">'docsignopt'</span><span class="s1">: </span><span class="s4">'#varname#=#showinit#,'</span><span class="s3">,</span>
        <span class="s4">'docsignoptshort'</span><span class="s1">: </span><span class="s4">'#varname#,'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isintent_nothide</span><span class="s3">, </span><span class="s1">isoptional)</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Docstring/BuildValue</span>
    <span class="s1">{</span>
        <span class="s4">'docreturn'</span><span class="s1">: </span><span class="s4">'#outvarname#,'</span><span class="s3">,</span>
        <span class="s4">'returnformat'</span><span class="s1">: </span><span class="s4">'#varrformat#'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isintent_out</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Externals (call-back functions)</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'docsignxa'</span><span class="s1">: {isintent_nothide: </span><span class="s4">'#varname#_extra_args=(),'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docsignxashort'</span><span class="s1">: {isintent_nothide: </span><span class="s4">'#varname#_extra_args,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstropt'</span><span class="s1">: {isintent_nothide: </span><span class="s4">'#varname#_extra_args : input tuple, optional</span><span class="s3">\\</span><span class="s4">n    Default: ()'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstrcbs'</span><span class="s1">: </span><span class="s4">'#cbdocstr#'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[] #cblatexdocstr#'</span><span class="s3">,</span>
        <span class="s4">'latexdocstropt'</span><span class="s1">: {isintent_nothide: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#varname#_extra_args := () input tuple@{}} --- Extra arguments for call-back function {{}</span><span class="s3">\\</span><span class="s4">verb@#varname#@{}}.'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: [</span><span class="s4">'    #cbname#_t #varname#_cb = { Py_None, NULL, 0 };'</span><span class="s3">,</span>
                 <span class="s4">'    #cbname#_t *#varname#_cb_ptr = &amp;#varname#_cb;'</span><span class="s3">,</span>
                 <span class="s4">'    PyTupleObject *#varname#_xa_capi = NULL;'</span><span class="s3">,</span>
                 <span class="s1">{l_not(isintent_callback):</span>
                  <span class="s4">'    #cbname#_typedef #varname#_cptr;'</span><span class="s1">}</span>
                 <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'kwlistxa'</span><span class="s1">: {isintent_nothide: </span><span class="s4">'&quot;#varname#_extra_args&quot;,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'argformat'</span><span class="s1">: {isrequired: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keyformat'</span><span class="s1">: {isoptional: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'xaformat'</span><span class="s1">: {isintent_nothide: </span><span class="s4">'O!'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_capi'</span><span class="s1">: {isrequired: </span><span class="s4">',&amp;#varname#_cb.capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keys_capi'</span><span class="s1">: {isoptional: </span><span class="s4">',&amp;#varname#_cb.capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keys_xa'</span><span class="s1">: </span><span class="s4">',&amp;PyTuple_Type,&amp;#varname#_xa_capi'</span><span class="s3">,</span>
        <span class="s4">'setjmpbuf'</span><span class="s1">: </span><span class="s4">'(setjmp(#varname#_cb.jmpbuf))'</span><span class="s3">,</span>
        <span class="s4">'callfortran'</span><span class="s1">: {l_not(isintent_callback): </span><span class="s4">'#varname#_cptr,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#cbname#'</span><span class="s3">, </span><span class="s4">'setjmp.h'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">:isexternal</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{l_not(isintent_callback): </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">if(F2PyCapsule_Check(#varname#_cb.capi)) { 
  #varname#_cptr = F2PyCapsule_AsVoidPtr(#varname#_cb.capi); 
} else { 
  #varname#_cptr = #cbname#; 
} 
&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{isintent_callback: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">if (#varname#_cb.capi==Py_None) { 
  #varname#_cb.capi = PyObject_GetAttrString(#modulename#_module,</span><span class="s3">\&quot;</span><span class="s4">#varname#</span><span class="s3">\&quot;</span><span class="s4">); 
  if (#varname#_cb.capi) { 
    if (#varname#_xa_capi==NULL) { 
      if (PyObject_HasAttrString(#modulename#_module,</span><span class="s3">\&quot;</span><span class="s4">#varname#_extra_args</span><span class="s3">\&quot;</span><span class="s4">)) { 
        PyObject* capi_tmp = PyObject_GetAttrString(#modulename#_module,</span><span class="s3">\&quot;</span><span class="s4">#varname#_extra_args</span><span class="s3">\&quot;</span><span class="s4">); 
        if (capi_tmp) { 
          #varname#_xa_capi = (PyTupleObject *)PySequence_Tuple(capi_tmp); 
          Py_DECREF(capi_tmp); 
        } 
        else { 
          #varname#_xa_capi = (PyTupleObject *)Py_BuildValue(</span><span class="s3">\&quot;</span><span class="s4">()</span><span class="s3">\&quot;</span><span class="s4">); 
        } 
        if (#varname#_xa_capi==NULL) { 
          PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">Failed to convert #modulename#.#varname#_extra_args to tuple.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
          return NULL; 
        } 
      } 
    } 
  } 
  if (#varname#_cb.capi==NULL) { 
    PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">Callback #varname# not defined (as an argument or module #modulename# attribute).</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
    return NULL; 
  } 
} 
&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (create_cb_arglist(#varname#_cb.capi,#varname#_xa_capi,#maxnofargs#,#nofoptargs#,&amp;#varname#_cb.nofargs,&amp;#varname#_cb.args_capi,</span><span class="s3">\&quot;</span><span class="s4">failed in processing argument list for call-back #varname#.</span><span class="s3">\&quot;</span><span class="s4">)) { 
&quot;&quot;&quot;</span><span class="s3">,</span>
            <span class="s1">{debugcapi: [</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Assuming %d arguments; at most #maxnofargs#(-#nofoptargs#) is expected.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">,#varname#_cb.nofargs); 
        CFUNCSMESSPY(</span><span class="s3">\&quot;</span><span class="s4">for #varname#=</span><span class="s3">\&quot;</span><span class="s4">,#varname#_cb.capi);&quot;&quot;&quot;</span><span class="s3">,</span>
                         <span class="s1">{l_not(isintent_callback): </span><span class="s4">&quot;&quot;&quot;        fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">#vardebugshowvalue# (call-back in C).</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">,#cbname#);&quot;&quot;&quot;</span><span class="s1">}]}</span><span class="s3">,</span>
            <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">Saving callback variables for `#varname#`.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        #varname#_cb_ptr = swap_active_#cbname#(#varname#_cb_ptr);&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">Restoring callback variables for `#varname#`.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        #varname#_cb_ptr = swap_active_#cbname#(#varname#_cb_ptr); 
        Py_DECREF(#varname#_cb.args_capi); 
    }&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'SWAP'</span><span class="s3">, </span><span class="s4">'create_cb_arglist'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">:isexternal</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">:</span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Scalars (not complex)</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    #ctype# #varname# = 0;'</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#varname#);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'callfortran'</span><span class="s1">: {isintent_c: </span><span class="s4">'#varname#,'</span><span class="s3">, </span><span class="s1">l_not(isintent_c): </span><span class="s4">'&amp;#varname#,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: {isintent_out: </span><span class="s4">',#varname#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex))</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'need'</span><span class="s1">: {hasinitvalue: </span><span class="s4">'math.h'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex))</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Not hidden</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    PyObject *#varname#_capi = Py_None;'</span><span class="s3">,</span>
        <span class="s4">'argformat'</span><span class="s1">: {isrequired: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keyformat'</span><span class="s1">: {isoptional: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_capi'</span><span class="s1">: {isrequired: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keys_capi'</span><span class="s1">: {isoptional: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {isintent_inout: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">f2py_success = try_pyarr_from_#ctype#(#varname#_capi,&amp;#varname#); 
    if (f2py_success) {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'closepyobjfrom'</span><span class="s1">: {isintent_inout: </span><span class="s4">&quot;    } /*if (f2py_success) of #varname# pyobjfrom*/&quot;</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {isintent_inout: </span><span class="s4">'try_pyarr_from_#ctype#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex)</span><span class="s3">, </span><span class="s1">isintent_nothide)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [</span>
            <span class="s0"># hasinitvalue...</span>
            <span class="s0">#   if pyobj is None:</span>
            <span class="s0">#     varname = init</span>
            <span class="s0">#   else</span>
            <span class="s0">#     from_pyobj(varname)</span>
            <span class="s0">#</span>
            <span class="s0"># isoptional and noinitvalue...</span>
            <span class="s0">#   if pyobj is not None:</span>
            <span class="s0">#     from_pyobj(varname)</span>
            <span class="s0">#   else:</span>
            <span class="s0">#     varname is uninitialized</span>
            <span class="s0">#</span>
            <span class="s0"># ...</span>
            <span class="s0">#   from_pyobj(varname)</span>
            <span class="s0">#</span>
            <span class="s1">{hasinitvalue: </span><span class="s4">'    if (#varname#_capi == Py_None) #varname# = #init#; else'</span><span class="s3">,</span>
             <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_and(isoptional</span><span class="s3">, </span><span class="s1">l_not(hasinitvalue)): </span><span class="s4">'    if (#varname#_capi != Py_None)'</span><span class="s3">,</span>
             <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_not(islogical): </span><span class="s4">'''</span><span class="s3">\ 
        </span><span class="s4">f2py_success = #ctype#_from_pyobj(&amp;#varname#,#varname#_capi,&quot;#pyname#() #nth# (#varname#) can</span><span class="s3">\'</span><span class="s4">t be converted to #ctype#&quot;); 
    if (f2py_success) {'''</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{islogical: </span><span class="s4">'''</span><span class="s3">\ 
        </span><span class="s4">#varname# = (#ctype#)PyObject_IsTrue(#varname#_capi); 
        f2py_success = 1; 
    if (f2py_success) {'''</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    } /*if (f2py_success) of #varname#*/'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {l_not(islogical): </span><span class="s4">'#ctype#_from_pyobj'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex)</span><span class="s3">, </span><span class="s1">isintent_nothide)</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Hidden</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {hasinitvalue: </span><span class="s4">'    #varname# = #init#;'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: typedef_need_dict</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex)</span><span class="s3">, </span><span class="s1">isintent_hide)</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#varname#);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex))</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Complex scalars</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    #ctype# #varname#;'</span><span class="s3">,</span>
        <span class="s4">'callfortran'</span><span class="s1">: {isintent_c: </span><span class="s4">'#varname#,'</span><span class="s3">, </span><span class="s1">l_not(isintent_c): </span><span class="s4">'&amp;#varname#,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#varname#.r,#varname#.i);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: {isintent_out: </span><span class="s4">',#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: iscomplex</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Not hidden</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    PyObject *#varname#_capi = Py_None;'</span><span class="s3">,</span>
        <span class="s4">'argformat'</span><span class="s1">: {isrequired: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keyformat'</span><span class="s1">: {isoptional: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_capi'</span><span class="s1">: {isrequired: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keys_capi'</span><span class="s1">: {isoptional: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {isintent_inout: </span><span class="s4">'try_pyarr_from_#ctype#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {isintent_inout: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">f2py_success = try_pyarr_from_#ctype#(#varname#_capi,&amp;#varname#); 
        if (f2py_success) {&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'closepyobjfrom'</span><span class="s1">: {isintent_inout: </span><span class="s4">&quot;        } /*if (f2py_success) of #varname# pyobjfrom*/&quot;</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(iscomplex</span><span class="s3">, </span><span class="s1">isintent_nothide)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{hasinitvalue: </span><span class="s4">'    if (#varname#_capi==Py_None) {#varname#.r = #init.r#, #varname#.i = #init.i#;} else'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{l_and(isoptional</span><span class="s3">, </span><span class="s1">l_not(hasinitvalue))</span>
                             <span class="s1">: </span><span class="s4">'    if (#varname#_capi != Py_None)'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">'        f2py_success = #ctype#_from_pyobj(&amp;#varname#,#varname#_capi,&quot;#pyname#() #nth# (#varname#) can</span><span class="s3">\'</span><span class="s4">t be converted to #ctype#&quot;);'</span>
                      <span class="s4">'</span><span class="s3">\n    </span><span class="s4">if (f2py_success) {'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    }  /*if (f2py_success) of #varname# frompyobj*/'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#ctype#_from_pyobj'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(iscomplex</span><span class="s3">, </span><span class="s1">isintent_nothide)</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Hidden</span>
        <span class="s4">'decl'</span><span class="s1">: {isintent_out: </span><span class="s4">'    PyObject *#varname#_capi = Py_None;'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(iscomplex</span><span class="s3">, </span><span class="s1">isintent_hide)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {hasinitvalue: </span><span class="s4">'    #varname#.r = #init.r#, #varname#.i = #init.i#;'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(iscomplex</span><span class="s3">, </span><span class="s1">isintent_hide)</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {isintent_out: </span><span class="s4">'    #varname#_capi = pyobj_from_#ctype#1(#varname#);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'pyobj_from_#ctype#1'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: iscomplex</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,#varname#.r,#varname#.i);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: iscomplex</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># String</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: [</span><span class="s4">'    #ctype# #varname# = NULL;'</span><span class="s3">,</span>
                 <span class="s4">'    int slen(#varname#);'</span><span class="s3">,</span>
                 <span class="s4">'    PyObject *#varname#_capi = Py_None;'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'callfortran'</span><span class="s1">:</span><span class="s4">'#varname#,'</span><span class="s3">,</span>
        <span class="s4">'callfortranappend'</span><span class="s1">:</span><span class="s4">'slen(#varname#),'</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">:[</span>
            <span class="s1">{debugcapi:</span>
             <span class="s4">'    fprintf(stderr,'</span>
             <span class="s4">'&quot;#vardebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,slen(#varname#),#varname#);'</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s0"># The trailing null value for Fortran is blank.</span>
            <span class="s1">{l_and(isintent_out</span><span class="s3">, </span><span class="s1">l_not(isintent_c)):</span>
             <span class="s4">&quot;        STRINGPADN(#varname#, slen(#varname#), ' ', '</span><span class="s3">\\</span><span class="s4">0');&quot;</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: {isintent_out: </span><span class="s4">',#varname#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'len..'</span><span class="s3">,</span>
                 <span class="s1">{l_and(isintent_out</span><span class="s3">, </span><span class="s1">l_not(isintent_c)): </span><span class="s4">'STRINGPADN'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">:isstring</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [</span>
            <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">slen(#varname#) = #length#; 
    f2py_success = #ctype#_from_pyobj(&amp;#varname#,&amp;slen(#varname#),#init#,&quot;&quot;&quot;</span>
<span class="s4">&quot;&quot;&quot;#varname#_capi,</span><span class="s3">\&quot;</span><span class="s4">#ctype#_from_pyobj failed in converting #nth#&quot;&quot;&quot;</span>
<span class="s4">&quot;&quot;&quot;`#varname#</span><span class="s3">\' </span><span class="s4">of #pyname# to C #ctype#</span><span class="s3">\&quot;</span><span class="s4">); 
    if (f2py_success) {&quot;&quot;&quot;</span><span class="s3">,</span>
            <span class="s0"># The trailing null value for Fortran is blank.</span>
            <span class="s1">{l_not(isintent_c):</span>
             <span class="s4">&quot;        STRINGPADN(#varname#, slen(#varname#), '</span><span class="s3">\\</span><span class="s4">0', ' ');&quot;</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">STRINGFREE(#varname#); 
    }  /*if (f2py_success) of #varname#*/&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#ctype#_from_pyobj'</span><span class="s3">, </span><span class="s4">'len..'</span><span class="s3">, </span><span class="s4">'STRINGFREE'</span><span class="s3">,</span>
                 <span class="s1">{l_not(isintent_c): </span><span class="s4">'STRINGPADN'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">:isstring</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">:</span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Not hidden</span>
        <span class="s4">'argformat'</span><span class="s1">: {isrequired: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keyformat'</span><span class="s1">: {isoptional: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_capi'</span><span class="s1">: {isrequired: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keys_capi'</span><span class="s1">: {isoptional: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: [</span>
            <span class="s1">{l_and(isintent_inout</span><span class="s3">, </span><span class="s1">l_not(isintent_c)):</span>
             <span class="s4">&quot;        STRINGPADN(#varname#, slen(#varname#), ' ', '</span><span class="s3">\\</span><span class="s4">0');&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{isintent_inout: </span><span class="s4">'''</span><span class="s3">\ 
    </span><span class="s4">f2py_success = try_pyarr_from_#ctype#(#varname#_capi, #varname#, 
                                          slen(#varname#)); 
    if (f2py_success) {'''</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'closepyobjfrom'</span><span class="s1">: {isintent_inout: </span><span class="s4">'    } /*if (f2py_success) of #varname# pyobjfrom*/'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {isintent_inout: </span><span class="s4">'try_pyarr_from_#ctype#'</span><span class="s3">,</span>
                 <span class="s1">l_and(isintent_inout</span><span class="s3">, </span><span class="s1">l_not(isintent_c)): </span><span class="s4">'STRINGPADN'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isstring</span><span class="s3">, </span><span class="s1">isintent_nothide)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Hidden</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isstring</span><span class="s3">, </span><span class="s1">isintent_hide)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;#vardebugshowvalue#</span><span class="s3">\\</span><span class="s4">n&quot;,slen(#varname#),#varname#);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isstring</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Array</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'decl'</span><span class="s1">: [</span><span class="s4">'    #ctype# *#varname# = NULL;'</span><span class="s3">,</span>
                 <span class="s4">'    npy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};'</span><span class="s3">,</span>
                 <span class="s4">'    const int #varname#_Rank = #rank#;'</span><span class="s3">,</span>
                 <span class="s4">'    PyArrayObject *capi_#varname#_tmp = NULL;'</span><span class="s3">,</span>
                 <span class="s4">'    int capi_#varname#_intent = 0;'</span><span class="s3">,</span>
                 <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'callfortran'</span><span class="s1">:</span><span class="s4">'#varname#,'</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">:{isintent_out: </span><span class="s4">',capi_#varname#_tmp'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'len..'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isarray</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># intent(overwrite) array</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    int capi_overwrite_#varname# = 1;'</span><span class="s3">,</span>
        <span class="s4">'kwlistxa'</span><span class="s1">: </span><span class="s4">'&quot;overwrite_#varname#&quot;,'</span><span class="s3">,</span>
        <span class="s4">'xaformat'</span><span class="s1">: </span><span class="s4">'i'</span><span class="s3">,</span>
        <span class="s4">'keys_xa'</span><span class="s1">: </span><span class="s4">',&amp;capi_overwrite_#varname#'</span><span class="s3">,</span>
        <span class="s4">'docsignxa'</span><span class="s1">: </span><span class="s4">'overwrite_#varname#=1,'</span><span class="s3">,</span>
        <span class="s4">'docsignxashort'</span><span class="s1">: </span><span class="s4">'overwrite_#varname#,'</span><span class="s3">,</span>
        <span class="s4">'docstropt'</span><span class="s1">: </span><span class="s4">'overwrite_#varname# : input int, optional</span><span class="s3">\\</span><span class="s4">n    Default: 1'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_overwrite)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'    capi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_overwrite)</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># intent(copy) array</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    int capi_overwrite_#varname# = 0;'</span><span class="s3">,</span>
        <span class="s4">'kwlistxa'</span><span class="s1">: </span><span class="s4">'&quot;overwrite_#varname#&quot;,'</span><span class="s3">,</span>
        <span class="s4">'xaformat'</span><span class="s1">: </span><span class="s4">'i'</span><span class="s3">,</span>
        <span class="s4">'keys_xa'</span><span class="s1">: </span><span class="s4">',&amp;capi_overwrite_#varname#'</span><span class="s3">,</span>
        <span class="s4">'docsignxa'</span><span class="s1">: </span><span class="s4">'overwrite_#varname#=0,'</span><span class="s3">,</span>
        <span class="s4">'docsignxashort'</span><span class="s1">: </span><span class="s4">'overwrite_#varname#,'</span><span class="s3">,</span>
        <span class="s4">'docstropt'</span><span class="s1">: </span><span class="s4">'overwrite_#varname# : input int, optional</span><span class="s3">\\</span><span class="s4">n    Default: 0'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_copy)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'    capi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_copy)</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'need'</span><span class="s1">: [{hasinitvalue: </span><span class="s4">'forcomb'</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{hasinitvalue: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isarray</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Not hidden</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    PyObject *#varname#_capi = Py_None;'</span><span class="s3">,</span>
        <span class="s4">'argformat'</span><span class="s1">: {isrequired: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keyformat'</span><span class="s1">: {isoptional: </span><span class="s4">'O'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_capi'</span><span class="s1">: {isrequired: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'keys_capi'</span><span class="s1">: {isoptional: </span><span class="s4">',&amp;#varname#_capi'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_nothide)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [</span><span class="s4">'    #setdims#;'</span><span class="s3">,</span>
                      <span class="s4">'    capi_#varname#_intent |= #intent#;'</span><span class="s3">,</span>
                      <span class="s1">{isintent_hide:</span>
                       <span class="s4">'    capi_#varname#_tmp = array_from_pyobj(#atype#,#varname#_Dims,#varname#_Rank,capi_#varname#_intent,Py_None);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{isintent_nothide:</span>
                       <span class="s4">'    capi_#varname#_tmp = array_from_pyobj(#atype#,#varname#_Dims,#varname#_Rank,capi_#varname#_intent,#varname#_capi);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (capi_#varname#_tmp == NULL) { 
        PyObject *exc, *val, *tb; 
        PyErr_Fetch(&amp;exc, &amp;val, &amp;tb); 
        PyErr_SetString(exc ? exc : #modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">failed in converting #nth# `#varname#</span><span class="s3">\' </span><span class="s4">of #pyname# to C/Fortran array</span><span class="s3">\&quot; </span><span class="s4">); 
        npy_PyErr_ChainExceptionsCause(exc, val, tb); 
    } else { 
        #varname# = (#ctype# *)(PyArray_DATA(capi_#varname#_tmp)); 
&quot;&quot;&quot;</span><span class="s3">,</span>
                      <span class="s1">{hasinitvalue: [</span>
                          <span class="s1">{isintent_nothide:</span>
                              <span class="s4">'    if (#varname#_capi == Py_None) {'</span><span class="s1">}</span><span class="s3">,</span>
                          <span class="s1">{isintent_hide: </span><span class="s4">'    {'</span><span class="s1">}</span><span class="s3">,</span>
                          <span class="s1">{iscomplexarray: </span><span class="s4">'        #ctype# capi_c;'</span><span class="s1">}</span><span class="s3">,</span>
                          <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
        </span><span class="s4">int *_i,capi_i=0; 
        CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">#name#: Initializing #varname#=#init#</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        if (initforcomb(PyArray_DIMS(capi_#varname#_tmp),PyArray_NDIM(capi_#varname#_tmp),1)) { 
            while ((_i = nextforcomb())) 
                #varname#[capi_i++] = #init#; /* fortran way */ 
        } else { 
            PyObject *exc, *val, *tb; 
            PyErr_Fetch(&amp;exc, &amp;val, &amp;tb); 
            PyErr_SetString(exc ? exc : #modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">Initialization of #nth# #varname# failed (initforcomb).</span><span class="s3">\&quot;</span><span class="s4">); 
            npy_PyErr_ChainExceptionsCause(exc, val, tb); 
            f2py_success = 0; 
        } 
    } 
    if (f2py_success) {&quot;&quot;&quot;</span><span class="s1">]}</span><span class="s3">,</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: [  </span><span class="s0"># note that this list will be reversed</span>
            <span class="s4">'    }  /*if (capi_#varname#_tmp == NULL) ... else of #varname#*/'</span><span class="s3">,</span>
            <span class="s1">{l_not(l_or(isintent_out</span><span class="s3">, </span><span class="s1">isintent_hide)): </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if((PyObject *)capi_#varname#_tmp!=#varname#_capi) { 
        Py_XDECREF(capi_#varname#_tmp); }&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{l_and(isintent_hide</span><span class="s3">, </span><span class="s1">l_not(isintent_out))</span>
                   <span class="s1">: </span><span class="s4">&quot;&quot;&quot;        Py_XDECREF(capi_#varname#_tmp);&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">{hasinitvalue: </span><span class="s4">'    }  /*if (f2py_success) of #varname# init*/'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isarray</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Scalararray</span>
    <span class="s1">{  </span><span class="s0"># Common</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">l_not(iscomplexarray))</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Not hidden</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">l_not(iscomplexarray)</span><span class="s3">, </span><span class="s1">isintent_nothide)</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*1 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isint1array</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*-1 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isunsigned_chararray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*-2 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isunsigned_shortarray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Integer*-8 array</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isunsigned_long_longarray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Complexarray</span>
    <span class="s1">{</span><span class="s4">'need'</span><span class="s1">: </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: iscomplexarray</span><span class="s3">,</span>
     <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
     <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Stringarray</span>
    <span class="s1">{</span>
        <span class="s4">'callfortranappend'</span><span class="s1">: {isarrayofstrings: </span><span class="s4">'flen(#varname#),'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'string'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isstringarray</span>
    <span class="s1">}</span>
<span class="s1">]</span>

<span class="s0">################# Rules for checking ###############</span>

<span class="s1">check_rules = [</span>
    <span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:Checking `#check#</span><span class="s3">\'\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'len..'</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'    CHECKSCALAR(#check#,</span><span class="s3">\&quot;</span><span class="s4">#check#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\&quot;</span><span class="s4">#nth# #varname#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\&quot;</span><span class="s4">#varshowvalue#</span><span class="s3">\&quot;</span><span class="s4">,#varname#) {'</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    } /*CHECKSCALAR(#check#)*/'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'CHECKSCALAR'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(iscomplex))</span><span class="s3">,</span>
        <span class="s4">'_break'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'    CHECKSTRING(#check#,</span><span class="s3">\&quot;</span><span class="s4">#check#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\&quot;</span><span class="s4">#nth# #varname#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\&quot;</span><span class="s4">#varshowvalue#</span><span class="s3">\&quot;</span><span class="s4">,#varname#) {'</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    } /*CHECKSTRING(#check#)*/'</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'CHECKSTRING'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isstring</span><span class="s3">,</span>
        <span class="s4">'_break'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'CHECKARRAY'</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'    CHECKARRAY(#check#,</span><span class="s3">\&quot;</span><span class="s4">#check#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\&quot;</span><span class="s4">#nth# #varname#</span><span class="s3">\&quot;</span><span class="s4">) {'</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    } /*CHECKARRAY(#check#)*/'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isarray</span><span class="s3">,</span>
        <span class="s4">'_break'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'need'</span><span class="s1">: </span><span class="s4">'CHECKGENERIC'</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'    CHECKGENERIC(#check#,</span><span class="s3">\&quot;</span><span class="s4">#check#</span><span class="s3">\&quot;</span><span class="s4">,</span><span class="s3">\&quot;</span><span class="s4">#nth# #varname#</span><span class="s3">\&quot;</span><span class="s4">) {'</span><span class="s3">,</span>
        <span class="s4">'cleanupfrompyobj'</span><span class="s1">: </span><span class="s4">'    } /*CHECKGENERIC(#check#)*/'</span><span class="s3">,</span>
    <span class="s1">}</span>
<span class="s1">]</span>

<span class="s0">########## Applying the rules. No need to modify what follows #############</span>

<span class="s0">#################### Build C/API module #######################</span>


<span class="s3">def </span><span class="s1">buildmodule(m</span><span class="s3">, </span><span class="s1">um):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return 
    &quot;&quot;&quot;</span>
    <span class="s1">outmess(</span><span class="s4">'    Building module &quot;%s&quot;...</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (m[</span><span class="s4">'name'</span><span class="s1">]))</span>
    <span class="s1">ret = {}</span>
    <span class="s1">mod_rules = defmod_rules[:]</span>
    <span class="s1">vrd = capi_maps.modsign2map(m)</span>
    <span class="s1">rd = dictappend({</span><span class="s4">'f2py_version'</span><span class="s1">: f2py_version}</span><span class="s3">, </span><span class="s1">vrd)</span>
    <span class="s1">funcwrappers = []</span>
    <span class="s1">funcwrappers2 = []  </span><span class="s0"># F90 codes</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">m[</span><span class="s4">'interfaced'</span><span class="s1">]:</span>
        <span class="s1">nb = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">bi </span><span class="s3">in </span><span class="s1">m[</span><span class="s4">'body'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">bi[</span><span class="s4">'block'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'interface'</span><span class="s3">, </span><span class="s4">'abstract interface'</span><span class="s1">]:</span>
                <span class="s1">errmess(</span><span class="s4">'buildmodule: Expected interface block. Skipping.</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s3">continue</span>
            <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">bi[</span><span class="s4">'body'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">b[</span><span class="s4">'name'</span><span class="s1">] == n:</span>
                    <span class="s1">nb = b</span>
                    <span class="s3">break</span>

        <span class="s3">if not </span><span class="s1">nb:</span>
            <span class="s1">errmess(</span>
                <span class="s4">'buildmodule: Could not found the body of interfaced routine &quot;%s&quot;. Skipping.</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (n))</span>
            <span class="s3">continue</span>
        <span class="s1">nb_list = [nb]</span>
        <span class="s3">if </span><span class="s4">'entry' </span><span class="s3">in </span><span class="s1">nb:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a </span><span class="s3">in </span><span class="s1">nb[</span><span class="s4">'entry'</span><span class="s1">].items():</span>
                <span class="s1">nb1 = copy.deepcopy(nb)</span>
                <span class="s3">del </span><span class="s1">nb1[</span><span class="s4">'entry'</span><span class="s1">]</span>
                <span class="s1">nb1[</span><span class="s4">'name'</span><span class="s1">] = k</span>
                <span class="s1">nb1[</span><span class="s4">'args'</span><span class="s1">] = a</span>
                <span class="s1">nb_list.append(nb1)</span>
        <span class="s3">for </span><span class="s1">nb </span><span class="s3">in </span><span class="s1">nb_list:</span>
            <span class="s0"># requiresf90wrapper must be called before buildapi as it</span>
            <span class="s0"># rewrites assumed shape arrays as automatic arrays.</span>
            <span class="s1">isf90 = requiresf90wrapper(nb)</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">wrap = buildapi(nb)</span>
            <span class="s3">if </span><span class="s1">wrap:</span>
                <span class="s3">if </span><span class="s1">isf90:</span>
                    <span class="s1">funcwrappers2.append(wrap)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">funcwrappers.append(wrap)</span>
            <span class="s1">ar = applyrules(api</span><span class="s3">, </span><span class="s1">vrd)</span>
            <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>

    <span class="s0"># Construct COMMON block support</span>
    <span class="s1">cr</span><span class="s3">, </span><span class="s1">wrap = common_rules.buildhooks(m)</span>
    <span class="s3">if </span><span class="s1">wrap:</span>
        <span class="s1">funcwrappers.append(wrap)</span>
    <span class="s1">ar = applyrules(cr</span><span class="s3">, </span><span class="s1">vrd)</span>
    <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>

    <span class="s0"># Construct F90 module support</span>
    <span class="s1">mr</span><span class="s3">, </span><span class="s1">wrap = f90mod_rules.buildhooks(m)</span>
    <span class="s3">if </span><span class="s1">wrap:</span>
        <span class="s1">funcwrappers2.append(wrap)</span>
    <span class="s1">ar = applyrules(mr</span><span class="s3">, </span><span class="s1">vrd)</span>
    <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>

    <span class="s3">for </span><span class="s1">u </span><span class="s3">in </span><span class="s1">um:</span>
        <span class="s1">ar = use_rules.buildusevars(u</span><span class="s3">, </span><span class="s1">m[</span><span class="s4">'use'</span><span class="s1">][u[</span><span class="s4">'name'</span><span class="s1">]])</span>
        <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>

    <span class="s1">needs = cfuncs.get_needs()</span>
    <span class="s1">code = {}</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">needs.keys():</span>
        <span class="s1">code[n] = []</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">needs[n]:</span>
            <span class="s1">c = </span><span class="s4">''</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.includes0:</span>
                <span class="s1">c = cfuncs.includes0[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.includes:</span>
                <span class="s1">c = cfuncs.includes[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.userincludes:</span>
                <span class="s1">c = cfuncs.userincludes[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.typedefs:</span>
                <span class="s1">c = cfuncs.typedefs[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.typedefs_generated:</span>
                <span class="s1">c = cfuncs.typedefs_generated[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.cppmacros:</span>
                <span class="s1">c = cfuncs.cppmacros[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.cfuncs:</span>
                <span class="s1">c = cfuncs.cfuncs[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.callbacks:</span>
                <span class="s1">c = cfuncs.callbacks[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.f90modhooks:</span>
                <span class="s1">c = cfuncs.f90modhooks[k]</span>
            <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cfuncs.commonhooks:</span>
                <span class="s1">c = cfuncs.commonhooks[k]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">errmess(</span><span class="s4">'buildmodule: unknown need %s.</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (repr(k)))</span>
                <span class="s3">continue</span>
            <span class="s1">code[n].append(c)</span>
    <span class="s1">mod_rules.append(code)</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">mod_rules:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](m)) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
            <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">m)</span>
            <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
    <span class="s1">ar = applyrules(module_rules</span><span class="s3">, </span><span class="s1">rd)</span>

    <span class="s1">fn = os.path.join(options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vrd[</span><span class="s4">'coutput'</span><span class="s1">])</span>
    <span class="s1">ret[</span><span class="s4">'csrc'</span><span class="s1">] = fn</span>
    <span class="s3">with </span><span class="s1">open(fn</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">f.write(ar[</span><span class="s4">'modulebody'</span><span class="s1">].replace(</span><span class="s4">'</span><span class="s3">\t</span><span class="s4">'</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* </span><span class="s4">' '</span><span class="s1">))</span>
    <span class="s1">outmess(</span><span class="s4">'    Wrote C/API module &quot;%s&quot; to file &quot;%s&quot;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (m[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fn))</span>

    <span class="s3">if </span><span class="s1">options[</span><span class="s4">'dorestdoc'</span><span class="s1">]:</span>
        <span class="s1">fn = os.path.join(</span>
            <span class="s1">options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vrd[</span><span class="s4">'modulename'</span><span class="s1">] + </span><span class="s4">'module.rest'</span><span class="s1">)</span>
        <span class="s3">with </span><span class="s1">open(fn</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s4">'.. -*- rest -*-</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">f.write(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(ar[</span><span class="s4">'restdoc'</span><span class="s1">]))</span>
        <span class="s1">outmess(</span><span class="s4">'    ReST Documentation is saved to file &quot;%s/%smodule.rest&quot;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                <span class="s1">(options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vrd[</span><span class="s4">'modulename'</span><span class="s1">]))</span>
    <span class="s3">if </span><span class="s1">options[</span><span class="s4">'dolatexdoc'</span><span class="s1">]:</span>
        <span class="s1">fn = os.path.join(</span>
            <span class="s1">options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vrd[</span><span class="s4">'modulename'</span><span class="s1">] + </span><span class="s4">'module.tex'</span><span class="s1">)</span>
        <span class="s1">ret[</span><span class="s4">'ltx'</span><span class="s1">] = fn</span>
        <span class="s3">with </span><span class="s1">open(fn</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span>
                <span class="s4">'%% This file is auto-generated with f2py (version:%s)</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (f2py_version))</span>
            <span class="s3">if </span><span class="s4">'shortlatex' </span><span class="s3">not in </span><span class="s1">options:</span>
                <span class="s1">f.write(</span>
                    <span class="s4">'</span><span class="s3">\\</span><span class="s4">documentclass{article}</span><span class="s3">\n\\</span><span class="s4">usepackage{a4wide}</span><span class="s3">\n\\</span><span class="s4">begin{document}</span><span class="s3">\n\\</span><span class="s4">tableofcontents</span><span class="s3">\n\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s1">f.write(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(ar[</span><span class="s4">'latexdoc'</span><span class="s1">]))</span>
            <span class="s3">if </span><span class="s4">'shortlatex' </span><span class="s3">not in </span><span class="s1">options:</span>
                <span class="s1">f.write(</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">end{document}'</span><span class="s1">)</span>
        <span class="s1">outmess(</span><span class="s4">'    Documentation is saved to file &quot;%s/%smodule.tex&quot;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                <span class="s1">(options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vrd[</span><span class="s4">'modulename'</span><span class="s1">]))</span>
    <span class="s3">if </span><span class="s1">funcwrappers:</span>
        <span class="s1">wn = os.path.join(options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vrd[</span><span class="s4">'f2py_wrapper_output'</span><span class="s1">])</span>
        <span class="s1">ret[</span><span class="s4">'fsrc'</span><span class="s1">] = wn</span>
        <span class="s3">with </span><span class="s1">open(wn</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s4">'C     -*- fortran -*-</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">f.write(</span>
                <span class="s4">'C     This file is autogenerated with f2py (version:%s)</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (f2py_version))</span>
            <span class="s1">f.write(</span>
                <span class="s4">'C     It contains Fortran 77 wrappers to fortran functions.</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">lines = []</span>
            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'</span><span class="s3">\n\n</span><span class="s4">'</span><span class="s1">.join(funcwrappers) + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">).split(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= l.find(</span><span class="s4">'!'</span><span class="s1">) &lt; </span><span class="s5">66</span><span class="s1">:</span>
                    <span class="s0"># don't split comment lines</span>
                    <span class="s1">lines.append(l + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s3">elif </span><span class="s1">l </span><span class="s3">and </span><span class="s1">l[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">' '</span><span class="s1">:</span>
                    <span class="s3">while </span><span class="s1">len(l) &gt;= </span><span class="s5">66</span><span class="s1">:</span>
                        <span class="s1">lines.append(l[:</span><span class="s5">66</span><span class="s1">] + </span><span class="s4">'</span><span class="s3">\n     </span><span class="s4">&amp;'</span><span class="s1">)</span>
                        <span class="s1">l = l[</span><span class="s5">66</span><span class="s1">:]</span>
                    <span class="s1">lines.append(l + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">lines.append(l + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">lines = </span><span class="s4">''</span><span class="s1">.join(lines).replace(</span><span class="s4">'</span><span class="s3">\n     </span><span class="s4">&amp;</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">f.write(lines)</span>
        <span class="s1">outmess(</span><span class="s4">'    Fortran 77 wrappers are saved to &quot;%s&quot;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (wn))</span>
    <span class="s3">if </span><span class="s1">funcwrappers2:</span>
        <span class="s1">wn = os.path.join(</span>
            <span class="s1">options[</span><span class="s4">'buildpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'%s-f2pywrappers2.f90' </span><span class="s1">% (vrd[</span><span class="s4">'modulename'</span><span class="s1">]))</span>
        <span class="s1">ret[</span><span class="s4">'fsrc'</span><span class="s1">] = wn</span>
        <span class="s3">with </span><span class="s1">open(wn</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s4">'!     -*- f90 -*-</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">f.write(</span>
                <span class="s4">'!     This file is autogenerated with f2py (version:%s)</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (f2py_version))</span>
            <span class="s1">f.write(</span>
                <span class="s4">'!     It contains Fortran 90 wrappers to fortran functions.</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">lines = []</span>
            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'</span><span class="s3">\n\n</span><span class="s4">'</span><span class="s1">.join(funcwrappers2) + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">).split(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= l.find(</span><span class="s4">'!'</span><span class="s1">) &lt; </span><span class="s5">72</span><span class="s1">:</span>
                    <span class="s0"># don't split comment lines</span>
                    <span class="s1">lines.append(l + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s3">elif </span><span class="s1">len(l) &gt; </span><span class="s5">72 </span><span class="s3">and </span><span class="s1">l[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">' '</span><span class="s1">:</span>
                    <span class="s1">lines.append(l[:</span><span class="s5">72</span><span class="s1">] + </span><span class="s4">'&amp;</span><span class="s3">\n     </span><span class="s4">&amp;'</span><span class="s1">)</span>
                    <span class="s1">l = l[</span><span class="s5">72</span><span class="s1">:]</span>
                    <span class="s3">while </span><span class="s1">len(l) &gt; </span><span class="s5">66</span><span class="s1">:</span>
                        <span class="s1">lines.append(l[:</span><span class="s5">66</span><span class="s1">] + </span><span class="s4">'&amp;</span><span class="s3">\n     </span><span class="s4">&amp;'</span><span class="s1">)</span>
                        <span class="s1">l = l[</span><span class="s5">66</span><span class="s1">:]</span>
                    <span class="s1">lines.append(l + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">lines.append(l + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">lines = </span><span class="s4">''</span><span class="s1">.join(lines).replace(</span><span class="s4">'</span><span class="s3">\n     </span><span class="s4">&amp;</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">f.write(lines)</span>
        <span class="s1">outmess(</span><span class="s4">'    Fortran 90 wrappers are saved to &quot;%s&quot;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (wn))</span>
    <span class="s3">return </span><span class="s1">ret</span>

<span class="s0">################## Build C/API function #############</span>

<span class="s1">stnd = {</span><span class="s5">1</span><span class="s1">: </span><span class="s4">'st'</span><span class="s3">, </span><span class="s5">2</span><span class="s1">: </span><span class="s4">'nd'</span><span class="s3">, </span><span class="s5">3</span><span class="s1">: </span><span class="s4">'rd'</span><span class="s3">, </span><span class="s5">4</span><span class="s1">: </span><span class="s4">'th'</span><span class="s3">, </span><span class="s5">5</span><span class="s1">: </span><span class="s4">'th'</span><span class="s3">,</span>
        <span class="s5">6</span><span class="s1">: </span><span class="s4">'th'</span><span class="s3">, </span><span class="s5">7</span><span class="s1">: </span><span class="s4">'th'</span><span class="s3">, </span><span class="s5">8</span><span class="s1">: </span><span class="s4">'th'</span><span class="s3">, </span><span class="s5">9</span><span class="s1">: </span><span class="s4">'th'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">: </span><span class="s4">'th'</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">buildapi(rout):</span>
    <span class="s1">rout</span><span class="s3">, </span><span class="s1">wrap = func2subr.assubr(rout)</span>
    <span class="s1">args</span><span class="s3">, </span><span class="s1">depargs = getargs2(rout)</span>
    <span class="s1">capi_maps.depargs = depargs</span>
    <span class="s1">var = rout[</span><span class="s4">'vars'</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">ismoduleroutine(rout):</span>
        <span class="s1">outmess(</span><span class="s4">'            Constructing wrapper function &quot;%s.%s&quot;...</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                <span class="s1">(rout[</span><span class="s4">'modulename'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rout[</span><span class="s4">'name'</span><span class="s1">]))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">outmess(</span><span class="s4">'        Constructing wrapper function &quot;%s&quot;...</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (rout[</span><span class="s4">'name'</span><span class="s1">]))</span>
    <span class="s0"># Routine</span>
    <span class="s1">vrd = capi_maps.routsign2map(rout)</span>
    <span class="s1">rd = dictappend({}</span><span class="s3">, </span><span class="s1">vrd)</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">rout_rules:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](rout)) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
            <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">rout)</span>
            <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>

    <span class="s0"># Args</span>
    <span class="s1">nth</span><span class="s3">, </span><span class="s1">nthk = </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span>
    <span class="s1">savevrd = {}</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s1">vrd = capi_maps.sign2map(a</span><span class="s3">, </span><span class="s1">var[a])</span>
        <span class="s3">if </span><span class="s1">isintent_aux(var[a]):</span>
            <span class="s1">_rules = aux_rules</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_rules = arg_rules</span>
            <span class="s3">if not </span><span class="s1">isintent_hide(var[a]):</span>
                <span class="s3">if not </span><span class="s1">isoptional(var[a]):</span>
                    <span class="s1">nth = nth + </span><span class="s5">1</span>
                    <span class="s1">vrd[</span><span class="s4">'nth'</span><span class="s1">] = repr(nth) + stnd[nth % </span><span class="s5">10</span><span class="s1">] + </span><span class="s4">' argument'</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">nthk = nthk + </span><span class="s5">1</span>
                    <span class="s1">vrd[</span><span class="s4">'nth'</span><span class="s1">] = repr(nthk) + stnd[nthk % </span><span class="s5">10</span><span class="s1">] + </span><span class="s4">' keyword'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">vrd[</span><span class="s4">'nth'</span><span class="s1">] = </span><span class="s4">'hidden'</span>
        <span class="s1">savevrd[a] = vrd</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">_rules:</span>
            <span class="s3">if </span><span class="s4">'_depend' </span><span class="s3">in </span><span class="s1">r:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](var[a])) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
                <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">var[a])</span>
                <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
                <span class="s3">if </span><span class="s4">'_break' </span><span class="s3">in </span><span class="s1">r:</span>
                    <span class="s3">break</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">depargs:</span>
        <span class="s3">if </span><span class="s1">isintent_aux(var[a]):</span>
            <span class="s1">_rules = aux_rules</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_rules = arg_rules</span>
        <span class="s1">vrd = savevrd[a]</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">_rules:</span>
            <span class="s3">if </span><span class="s4">'_depend' </span><span class="s3">not in </span><span class="s1">r:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](var[a])) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
                <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">var[a])</span>
                <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
                <span class="s3">if </span><span class="s4">'_break' </span><span class="s3">in </span><span class="s1">r:</span>
                    <span class="s3">break</span>
        <span class="s3">if </span><span class="s4">'check' </span><span class="s3">in </span><span class="s1">var[a]:</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">var[a][</span><span class="s4">'check'</span><span class="s1">]:</span>
                <span class="s1">vrd[</span><span class="s4">'check'</span><span class="s1">] = c</span>
                <span class="s1">ar = applyrules(check_rules</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">var[a])</span>
                <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
    <span class="s3">if </span><span class="s1">isinstance(rd[</span><span class="s4">'cleanupfrompyobj'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">rd[</span><span class="s4">'cleanupfrompyobj'</span><span class="s1">].reverse()</span>
    <span class="s3">if </span><span class="s1">isinstance(rd[</span><span class="s4">'closepyobjfrom'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">rd[</span><span class="s4">'closepyobjfrom'</span><span class="s1">].reverse()</span>
    <span class="s1">rd[</span><span class="s4">'docsignature'</span><span class="s1">] = stripcomma(replace(</span><span class="s4">'#docsign##docsignopt##docsignxa#'</span><span class="s3">,</span>
                                            <span class="s1">{</span><span class="s4">'docsign'</span><span class="s1">: rd[</span><span class="s4">'docsign'</span><span class="s1">]</span><span class="s3">,</span>
                                             <span class="s4">'docsignopt'</span><span class="s1">: rd[</span><span class="s4">'docsignopt'</span><span class="s1">]</span><span class="s3">,</span>
                                             <span class="s4">'docsignxa'</span><span class="s1">: rd[</span><span class="s4">'docsignxa'</span><span class="s1">]}))</span>
    <span class="s1">optargs = stripcomma(replace(</span><span class="s4">'#docsignopt##docsignxa#'</span><span class="s3">,</span>
                                 <span class="s1">{</span><span class="s4">'docsignxa'</span><span class="s1">: rd[</span><span class="s4">'docsignxashort'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s4">'docsignopt'</span><span class="s1">: rd[</span><span class="s4">'docsignoptshort'</span><span class="s1">]}</span>
                                 <span class="s1">))</span>
    <span class="s3">if </span><span class="s1">optargs == </span><span class="s4">''</span><span class="s1">:</span>
        <span class="s1">rd[</span><span class="s4">'docsignatureshort'</span><span class="s1">] = stripcomma(</span>
            <span class="s1">replace(</span><span class="s4">'#docsign#'</span><span class="s3">, </span><span class="s1">{</span><span class="s4">'docsign'</span><span class="s1">: rd[</span><span class="s4">'docsign'</span><span class="s1">]}))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">rd[</span><span class="s4">'docsignatureshort'</span><span class="s1">] = replace(</span><span class="s4">'#docsign#[#docsignopt#]'</span><span class="s3">,</span>
                                          <span class="s1">{</span><span class="s4">'docsign'</span><span class="s1">: rd[</span><span class="s4">'docsign'</span><span class="s1">]</span><span class="s3">,</span>
                                           <span class="s4">'docsignopt'</span><span class="s1">: optargs</span><span class="s3">,</span>
                                           <span class="s1">})</span>
    <span class="s1">rd[</span><span class="s4">'latexdocsignatureshort'</span><span class="s1">] = rd[</span><span class="s4">'docsignatureshort'</span><span class="s1">].replace(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">_'</span><span class="s1">)</span>
    <span class="s1">rd[</span><span class="s4">'latexdocsignatureshort'</span><span class="s1">] = rd[</span>
        <span class="s4">'latexdocsignatureshort'</span><span class="s1">].replace(</span><span class="s4">','</span><span class="s3">, </span><span class="s4">', '</span><span class="s1">)</span>
    <span class="s1">cfs = stripcomma(replace(</span><span class="s4">'#callfortran##callfortranappend#'</span><span class="s3">, </span><span class="s1">{</span>
                     <span class="s4">'callfortran'</span><span class="s1">: rd[</span><span class="s4">'callfortran'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'callfortranappend'</span><span class="s1">: rd[</span><span class="s4">'callfortranappend'</span><span class="s1">]}))</span>
    <span class="s3">if </span><span class="s1">len(rd[</span><span class="s4">'callfortranappend'</span><span class="s1">]) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">rd[</span><span class="s4">'callcompaqfortran'</span><span class="s1">] = stripcomma(replace(</span><span class="s4">'#callfortran# 0,#callfortranappend#'</span><span class="s3">, </span><span class="s1">{</span>
                                             <span class="s4">'callfortran'</span><span class="s1">: rd[</span><span class="s4">'callfortran'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'callfortranappend'</span><span class="s1">: rd[</span><span class="s4">'callfortranappend'</span><span class="s1">]}))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">rd[</span><span class="s4">'callcompaqfortran'</span><span class="s1">] = cfs</span>
    <span class="s1">rd[</span><span class="s4">'callfortran'</span><span class="s1">] = cfs</span>
    <span class="s3">if </span><span class="s1">isinstance(rd[</span><span class="s4">'docreturn'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">rd[</span><span class="s4">'docreturn'</span><span class="s1">] = stripcomma(</span>
            <span class="s1">replace(</span><span class="s4">'#docreturn#'</span><span class="s3">, </span><span class="s1">{</span><span class="s4">'docreturn'</span><span class="s1">: rd[</span><span class="s4">'docreturn'</span><span class="s1">]})) + </span><span class="s4">' = '</span>
    <span class="s1">rd[</span><span class="s4">'docstrsigns'</span><span class="s1">] = []</span>
    <span class="s1">rd[</span><span class="s4">'latexdocstrsigns'</span><span class="s1">] = []</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'docstrreq'</span><span class="s3">, </span><span class="s4">'docstropt'</span><span class="s3">, </span><span class="s4">'docstrout'</span><span class="s3">, </span><span class="s4">'docstrcbs'</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">rd </span><span class="s3">and </span><span class="s1">isinstance(rd[k]</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">rd[</span><span class="s4">'docstrsigns'</span><span class="s1">] = rd[</span><span class="s4">'docstrsigns'</span><span class="s1">] + rd[k]</span>
        <span class="s1">k = </span><span class="s4">'latex' </span><span class="s1">+ k</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">rd </span><span class="s3">and </span><span class="s1">isinstance(rd[k]</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">rd[</span><span class="s4">'latexdocstrsigns'</span><span class="s1">] = rd[</span><span class="s4">'latexdocstrsigns'</span><span class="s1">] + rd[k][</span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">] +\</span>
                <span class="s1">[</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">begin{description}'</span><span class="s1">] + rd[k][</span><span class="s5">1</span><span class="s1">:] +\</span>
                <span class="s1">[</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">end{description}'</span><span class="s1">]</span>

    <span class="s1">ar = applyrules(routine_rules</span><span class="s3">, </span><span class="s1">rd)</span>
    <span class="s3">if </span><span class="s1">ismoduleroutine(rout):</span>
        <span class="s1">outmess(</span><span class="s4">'              %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (ar[</span><span class="s4">'docshort'</span><span class="s1">]))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">outmess(</span><span class="s4">'          %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (ar[</span><span class="s4">'docshort'</span><span class="s1">]))</span>
    <span class="s3">return </span><span class="s1">ar</span><span class="s3">, </span><span class="s1">wrap</span>


<span class="s0">#################### EOF rules.py #######################</span>
</pre>
</body>
</html>