<html>
<head>
<title>test_extract.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_extract.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">_testing </span><span class="s0">as </span><span class="s1">tm</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_kwarg_wrong_type_raises(any_string_dtype):</span>
    <span class="s2"># TODO: should this raise TypeError</span>
    <span class="s1">values = Series([</span><span class="s3">&quot;fooBAD__barBAD&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;expand must be True or False&quot;</span><span class="s1">):</span>
        <span class="s1">values.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*(BAD)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">None</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_kwarg(any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;fooBAD__barBAD&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">expected = DataFrame([</span><span class="s3">&quot;BAD__&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;BAD__&quot;</span><span class="s0">, </span><span class="s3">&quot;BAD&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*(BAD)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_False_mixed_object():</span>
    <span class="s1">ser = Series(</span>
        <span class="s1">[</span><span class="s3">&quot;aBAD_BAD&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;BAD_b_BAD&quot;</span><span class="s0">, True, </span><span class="s1">datetime.today()</span><span class="s0">, </span><span class="s3">&quot;foo&quot;</span><span class="s0">, None, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s2"># two groups</span>
    <span class="s1">result = ser.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*(BAD)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">er = [np.nan</span><span class="s0">, </span><span class="s1">np.nan]  </span><span class="s2"># empty row</span>
    <span class="s1">expected = DataFrame([[</span><span class="s3">&quot;BAD_&quot;</span><span class="s0">, </span><span class="s3">&quot;BAD&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;BAD_&quot;</span><span class="s0">, </span><span class="s3">&quot;BAD&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># single group</span>
    <span class="s1">result = ser.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*BAD&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">[</span><span class="s3">&quot;BAD_&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;BAD_&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_index_raises():</span>
    <span class="s2"># GH9980</span>
    <span class="s2"># Index only works with one regex group since</span>
    <span class="s2"># multi-group would expand to a frame</span>
    <span class="s1">idx = Index([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;A2&quot;</span><span class="s0">, </span><span class="s3">&quot;A3&quot;</span><span class="s0">, </span><span class="s3">&quot;A4&quot;</span><span class="s0">, </span><span class="s3">&quot;B5&quot;</span><span class="s1">])</span>
    <span class="s1">msg = </span><span class="s3">&quot;only one regex group is supported with Index&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">idx.str.extract(</span><span class="s3">&quot;([AB])([123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_no_capture_groups_raises(index_or_series</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s1">s_or_idx = index_or_series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">msg = </span><span class="s3">&quot;pattern contains no capture groups&quot;</span>

    <span class="s2"># no groups</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s_or_idx.str.extract(</span><span class="s3">&quot;[ABC][123]&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s2"># only non-capturing groups</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s_or_idx.str.extract(</span><span class="s3">&quot;(?:[AB]).*&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_single_capture_group(index_or_series</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s2"># single group renames series/index properly</span>
    <span class="s1">s_or_idx = index_or_series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;A2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s_or_idx.str.extract(</span><span class="s3">r&quot;(?P&lt;uno&gt;A)\d&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">expected = index_or_series([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;uno&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s0">if </span><span class="s1">index_or_series == Series:</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_capture_groups(any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s2"># one group, no matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(_)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two groups, no matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(_)(_)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one group, some matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])[123]&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two groups, some matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])([123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one named group</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two named groups</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># mix named and unnamed groups</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s4">0</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one normal group, one non-capturing group</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])(?:[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two normal groups, one non-capturing group</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A11&quot;</span><span class="s0">, </span><span class="s3">&quot;B22&quot;</span><span class="s0">, </span><span class="s3">&quot;C33&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])([123])(?:[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one optional group followed by one normal group</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])?(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one normal group followed by one optional group</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[ABC])(?P&lt;number&gt;[123])?&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_capture_groups_index(index</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/issues/6348</span>
    <span class="s2"># not passing index to the extractor</span>
    <span class="s1">data = [</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">len(index) &lt; len(data):</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;Index too short&quot;</span><span class="s1">)</span>

    <span class="s1">index = index[: len(data)]</span>
    <span class="s1">s = Series(data</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">r&quot;(\d)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">r&quot;(?P&lt;letter&gt;\D)(?P&lt;number&gt;\d)?&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=index</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_single_series_name_is_preserved(any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;bob&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">r&quot;(?P&lt;sue&gt;[a-z])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;sue&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_True(any_string_dtype):</span>
    <span class="s2"># Contains tests like those in test_match and some others.</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;fooBAD__barBAD&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*(BAD)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;BAD__&quot;</span><span class="s0">, </span><span class="s3">&quot;BAD&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_True_mixed_object():</span>
    <span class="s1">er = [np.nan</span><span class="s0">, </span><span class="s1">np.nan]  </span><span class="s2"># empty row</span>
    <span class="s1">mixed = Series(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;aBAD_BAD&quot;</span><span class="s0">,</span>
            <span class="s1">np.nan</span><span class="s0">,</span>
            <span class="s3">&quot;BAD_b_BAD&quot;</span><span class="s0">,</span>
            <span class="s0">True,</span>
            <span class="s1">datetime.today()</span><span class="s0">,</span>
            <span class="s3">&quot;foo&quot;</span><span class="s0">,</span>
            <span class="s0">None,</span>
            <span class="s4">1</span><span class="s0">,</span>
            <span class="s4">2.0</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">result = mixed.str.extract(</span><span class="s3">&quot;.*(BAD[_]+).*(BAD)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([[</span><span class="s3">&quot;BAD_&quot;</span><span class="s0">, </span><span class="s3">&quot;BAD&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;BAD_&quot;</span><span class="s0">, </span><span class="s3">&quot;BAD&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er</span><span class="s0">, </span><span class="s1">er])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_True_single_capture_group_raises(</span>
    <span class="s1">index_or_series</span><span class="s0">, </span><span class="s1">any_string_dtype</span>
<span class="s1">):</span>
    <span class="s2"># these should work for both Series and Index</span>
    <span class="s2"># no groups</span>
    <span class="s1">s_or_idx = index_or_series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">msg = </span><span class="s3">&quot;pattern contains no capture groups&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s_or_idx.str.extract(</span><span class="s3">&quot;[ABC][123]&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s2"># only non-capturing groups</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s_or_idx.str.extract(</span><span class="s3">&quot;(?:[AB]).*&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_extract_expand_True_single_capture_group(index_or_series</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s2"># single group renames series/index properly</span>
    <span class="s1">s_or_idx = index_or_series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;A2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s_or_idx.str.extract(</span><span class="s3">r&quot;(?P&lt;uno&gt;A)\d&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;uno&quot;</span><span class="s1">: [</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">&quot;series_name&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_extract_series(name</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s2"># extract should give the same result whether or not the series has a name.</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s2"># one group, no matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(_)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two groups, no matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(_)(_)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one group, some matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])[123]&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two groups, some matches</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])([123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one named group</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;letter&quot;</span><span class="s1">: [</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]}</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two named groups</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># mix named and unnamed groups</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s4">0</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one normal group, one non-capturing group</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])(?:[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_optional_groups(any_string_dtype):</span>

    <span class="s2"># two normal groups, one non-capturing group</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A11&quot;</span><span class="s0">, </span><span class="s3">&quot;B22&quot;</span><span class="s0">, </span><span class="s3">&quot;C33&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;([AB])([123])(?:[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one optional group followed by one normal group</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])?(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one normal group followed by one optional group</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">&quot;(?P&lt;letter&gt;[ABC])(?P&lt;number&gt;[123])?&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_dataframe_capture_groups_index(index</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s2"># GH6348</span>
    <span class="s2"># not passing index to the extractor</span>

    <span class="s1">data = [</span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;B2&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">len(index) &lt; len(data):</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;Index too short&quot;</span><span class="s1">)</span>

    <span class="s1">index = index[: len(data)]</span>
    <span class="s1">s = Series(data</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">r&quot;(\d)&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = s.str.extract(</span><span class="s3">r&quot;(?P&lt;letter&gt;\D)(?P&lt;number&gt;\d)?&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=index</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extract_single_group_returns_frame(any_string_dtype):</span>
    <span class="s2"># GH11386 extract should always return DataFrame, even when</span>
    <span class="s2"># there is only one group. Prior to v0.18.0, extract returned</span>
    <span class="s2"># Series when there was only one group in the regex.</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extract(</span><span class="s3">r&quot;(?P&lt;letter&gt;[a-z])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;letter&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extractall(any_string_dtype):</span>
    <span class="s1">data = [</span>
        <span class="s3">&quot;dave@google.com&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;tdhock5@gmail.com&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;maudelaperriere@gmail.com&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;rob@gmail.com some text steve@gmail.com&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;a@b.com some text c@d.com and e@f.com&quot;</span><span class="s0">,</span>
        <span class="s1">np.nan</span><span class="s0">,</span>
        <span class="s3">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">expected_tuples = [</span>
        <span class="s1">(</span><span class="s3">&quot;dave&quot;</span><span class="s0">, </span><span class="s3">&quot;google&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;tdhock5&quot;</span><span class="s0">, </span><span class="s3">&quot;gmail&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;maudelaperriere&quot;</span><span class="s0">, </span><span class="s3">&quot;gmail&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;rob&quot;</span><span class="s0">, </span><span class="s3">&quot;gmail&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;steve&quot;</span><span class="s0">, </span><span class="s3">&quot;gmail&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;e&quot;</span><span class="s0">, </span><span class="s3">&quot;f&quot;</span><span class="s0">, </span><span class="s3">&quot;com&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">pat = </span><span class="s3">r&quot;&quot;&quot; 
    (?P&lt;user&gt;[a-z0-9]+) 
    @ 
    (?P&lt;domain&gt;[a-z]+) 
    \. 
    (?P&lt;tld&gt;[a-z]{2,4}) 
    &quot;&quot;&quot;</span>
    <span class="s1">expected_columns = [</span><span class="s3">&quot;user&quot;</span><span class="s0">, </span><span class="s3">&quot;domain&quot;</span><span class="s0">, </span><span class="s3">&quot;tld&quot;</span><span class="s1">]</span>
    <span class="s1">s = Series(data</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s2"># extractall should return a DataFrame with one row for each match, indexed by the</span>
    <span class="s2"># subject from which the match came.</span>
    <span class="s1">expected_index = MultiIndex.from_tuples(</span>
        <span class="s1">[(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">names=(</span><span class="s0">None, </span><span class="s3">&quot;match&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">expected_tuples</span><span class="s0">, </span><span class="s1">expected_index</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">result = s.str.extractall(pat</span><span class="s0">, </span><span class="s1">flags=re.VERBOSE)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># The index of the input Series should be used to construct the index of the output</span>
    <span class="s2"># DataFrame:</span>
    <span class="s1">mi = MultiIndex.from_tuples(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;single&quot;</span><span class="s0">, </span><span class="s3">&quot;Dave&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;single&quot;</span><span class="s0">, </span><span class="s3">&quot;Toby&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;single&quot;</span><span class="s0">, </span><span class="s3">&quot;Maude&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;robAndSteve&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;abcdef&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;none&quot;</span><span class="s0">, </span><span class="s3">&quot;missing&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;none&quot;</span><span class="s0">, </span><span class="s3">&quot;empty&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">s = Series(data</span><span class="s0">, </span><span class="s1">index=mi</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">expected_index = MultiIndex.from_tuples(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;single&quot;</span><span class="s0">, </span><span class="s3">&quot;Dave&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;single&quot;</span><span class="s0">, </span><span class="s3">&quot;Toby&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;single&quot;</span><span class="s0">, </span><span class="s3">&quot;Maude&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;robAndSteve&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;robAndSteve&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;abcdef&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;abcdef&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;multiple&quot;</span><span class="s0">, </span><span class="s3">&quot;abcdef&quot;</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=(</span><span class="s0">None, None, </span><span class="s3">&quot;match&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">expected_tuples</span><span class="s0">, </span><span class="s1">expected_index</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">result = s.str.extractall(pat</span><span class="s0">, </span><span class="s1">flags=re.VERBOSE)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># MultiIndexed subject with names.</span>
    <span class="s1">s = Series(data</span><span class="s0">, </span><span class="s1">index=mi</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">s.index.names = (</span><span class="s3">&quot;matches&quot;</span><span class="s0">, </span><span class="s3">&quot;description&quot;</span><span class="s1">)</span>
    <span class="s1">expected_index.names = (</span><span class="s3">&quot;matches&quot;</span><span class="s0">, </span><span class="s3">&quot;description&quot;</span><span class="s0">, </span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">expected_tuples</span><span class="s0">, </span><span class="s1">expected_index</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">result = s.str.extractall(pat</span><span class="s0">, </span><span class="s1">flags=re.VERBOSE)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pat,expected_names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2"># optional groups.</span>
        <span class="s1">(</span><span class="s3">&quot;(?P&lt;letter&gt;[AB])?(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s2"># only one of two groups has a name.</span>
        <span class="s1">(</span><span class="s3">&quot;([AB])?(?P&lt;number&gt;[123])&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s3">&quot;number&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_extractall_column_names(pat</span><span class="s0">, </span><span class="s1">expected_names</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s3">&quot;A1&quot;</span><span class="s0">, </span><span class="s3">&quot;32&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">result = s.str.extractall(pat)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[(</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.nan</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.nan</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_tuples([(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=(</span><span class="s0">None, </span><span class="s3">&quot;match&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">columns=expected_names</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extractall_single_group(any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">expected_index = MultiIndex.from_tuples(</span>
        <span class="s1">[(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=(</span><span class="s0">None, </span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2"># extractall(one named group) returns DataFrame with one named column.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">r&quot;(?P&lt;letter&gt;[a-z])&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">{</span><span class="s3">&quot;letter&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># extractall(one un-named group) returns DataFrame with one un-named column.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">r&quot;([a-z])&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extractall_single_group_with_quantifier(any_string_dtype):</span>
    <span class="s2"># GH#13382</span>
    <span class="s2"># extractall(one un-named group with quantifier) returns DataFrame with one un-named</span>
    <span class="s2"># column.</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;ab3&quot;</span><span class="s0">, </span><span class="s3">&quot;abc3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4cd2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">r&quot;([a-z]+)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s0">, </span><span class="s3">&quot;abc&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;cd&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_tuples(</span>
            <span class="s1">[(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=(</span><span class="s0">None, </span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data, names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;i1&quot;</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, </span><span class="s3">&quot;i2&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;i1&quot;</span><span class="s0">, </span><span class="s3">&quot;i2&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;i1&quot;</span><span class="s0">, </span><span class="s3">&quot;i2&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, </span><span class="s3">&quot;i2&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;i1&quot;</span><span class="s0">, </span><span class="s3">&quot;i2&quot;</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_extractall_no_matches(data</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">any_string_dtype):</span>
    <span class="s2"># GH19075 extractall with no matches should return a valid MultiIndex</span>
    <span class="s1">n = len(data)</span>
    <span class="s0">if </span><span class="s1">len(names) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">index = Index(range(n)</span><span class="s0">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">tuples = (tuple([i] * (n - </span><span class="s4">1</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n))</span>
        <span class="s1">index = MultiIndex.from_tuples(tuples</span><span class="s0">, </span><span class="s1">names=names)</span>
    <span class="s1">s = Series(data</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">expected_index = MultiIndex.from_tuples([]</span><span class="s0">, </span><span class="s1">names=(names + (</span><span class="s3">&quot;match&quot;</span><span class="s0">,</span><span class="s1">)))</span>

    <span class="s2"># one un-named group.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">&quot;(z)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(columns=[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two un-named groups.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">&quot;(z)(z)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(columns=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one named group.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">&quot;(?P&lt;first&gt;z)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">columns=[</span><span class="s3">&quot;first&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># two named groups.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">&quot;(?P&lt;first&gt;z)(?P&lt;second&gt;z)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">columns=[</span><span class="s3">&quot;first&quot;</span><span class="s0">, </span><span class="s3">&quot;second&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># one named, one un-named.</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">&quot;(z)(?P&lt;second&gt;z)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">columns=[</span><span class="s4">0</span><span class="s0">, </span><span class="s3">&quot;second&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=expected_index</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extractall_stringindex(any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a1a2&quot;</span><span class="s0">, </span><span class="s3">&quot;b1&quot;</span><span class="s0">, </span><span class="s3">&quot;c1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;xxx&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">r&quot;[ab](?P&lt;digit&gt;\d)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">{</span><span class="s3">&quot;digit&quot;</span><span class="s1">: [</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_tuples([(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s0">None, </span><span class="s3">&quot;match&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s2"># index should return the same result as the default index without name thus</span>
    <span class="s2"># index.name doesn't affect to the result</span>
    <span class="s0">if </span><span class="s1">any_string_dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">Index([</span><span class="s3">&quot;a1a2&quot;</span><span class="s0">, </span><span class="s3">&quot;b1&quot;</span><span class="s0">, </span><span class="s3">&quot;c1&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">Index([</span><span class="s3">&quot;a1a2&quot;</span><span class="s0">, </span><span class="s3">&quot;b1&quot;</span><span class="s0">, </span><span class="s3">&quot;c1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;xxx&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]:</span>

            <span class="s1">result = idx.str.extractall(</span><span class="s3">r&quot;[ab](?P&lt;digit&gt;\d)&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">s = Series(</span>
        <span class="s1">[</span><span class="s3">&quot;a1a2&quot;</span><span class="s0">, </span><span class="s3">&quot;b1&quot;</span><span class="s0">, </span><span class="s3">&quot;c1&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s3">&quot;s_name&quot;</span><span class="s0">,</span>
        <span class="s1">index=Index([</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s3">&quot;yy&quot;</span><span class="s0">, </span><span class="s3">&quot;zz&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;idx_name&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">result = s.str.extractall(</span><span class="s3">r&quot;[ab](?P&lt;digit&gt;\d)&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">{</span><span class="s3">&quot;digit&quot;</span><span class="s1">: [</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_tuples(</span>
            <span class="s1">[(</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;yy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s3">&quot;idx_name&quot;</span><span class="s0">, </span><span class="s3">&quot;match&quot;</span><span class="s1">]</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_extractall_no_capture_groups_raises(any_string_dtype):</span>
    <span class="s2"># Does not make sense to use extractall with a regex that has no capture groups.</span>
    <span class="s2"># (it returns DataFrame with one column for each capture group)</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;no capture groups&quot;</span><span class="s1">):</span>
        <span class="s1">s.str.extractall(</span><span class="s3">r&quot;[a-z]&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_extract_index_one_two_groups():</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;d4c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;A3&quot;</span><span class="s0">, </span><span class="s3">&quot;B3&quot;</span><span class="s0">, </span><span class="s3">&quot;D4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s1">)</span>
    <span class="s1">r = s.index.str.extract(</span><span class="s3">r&quot;([A-Z])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">e = DataFrame([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(r</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s2"># Prior to v0.18.0, index.str.extract(regex with one group)</span>
    <span class="s2"># returned Index. With more than one group, extract raised an</span>
    <span class="s2"># error (GH9980). Now extract always returns DataFrame.</span>
    <span class="s1">r = s.index.str.extract(</span><span class="s3">r&quot;(?P&lt;letter&gt;[A-Z])(?P&lt;digit&gt;[0-9])&quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">e_list = [(</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;D&quot;</span><span class="s0">, </span><span class="s3">&quot;4&quot;</span><span class="s1">)]</span>
    <span class="s1">e = DataFrame(e_list</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s3">&quot;letter&quot;</span><span class="s0">, </span><span class="s3">&quot;digit&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(r</span><span class="s0">, </span><span class="s1">e)</span>


<span class="s0">def </span><span class="s1">test_extractall_same_as_extract(any_string_dtype):</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">pattern_two_noname = </span><span class="s3">r&quot;([a-z])([0-9])&quot;</span>
    <span class="s1">extract_two_noname = s.str.extract(pattern_two_noname</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_multi_index = s.str.extractall(pattern_two_noname)</span>
    <span class="s1">no_multi_index = has_multi_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_two_noname</span><span class="s0">, </span><span class="s1">no_multi_index)</span>

    <span class="s1">pattern_two_named = </span><span class="s3">r&quot;(?P&lt;letter&gt;[a-z])(?P&lt;digit&gt;[0-9])&quot;</span>
    <span class="s1">extract_two_named = s.str.extract(pattern_two_named</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_multi_index = s.str.extractall(pattern_two_named)</span>
    <span class="s1">no_multi_index = has_multi_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_two_named</span><span class="s0">, </span><span class="s1">no_multi_index)</span>

    <span class="s1">pattern_one_named = </span><span class="s3">r&quot;(?P&lt;group_name&gt;[a-z])&quot;</span>
    <span class="s1">extract_one_named = s.str.extract(pattern_one_named</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_multi_index = s.str.extractall(pattern_one_named)</span>
    <span class="s1">no_multi_index = has_multi_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_one_named</span><span class="s0">, </span><span class="s1">no_multi_index)</span>

    <span class="s1">pattern_one_noname = </span><span class="s3">r&quot;([a-z])&quot;</span>
    <span class="s1">extract_one_noname = s.str.extract(pattern_one_noname</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_multi_index = s.str.extractall(pattern_one_noname)</span>
    <span class="s1">no_multi_index = has_multi_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_one_noname</span><span class="s0">, </span><span class="s1">no_multi_index)</span>


<span class="s0">def </span><span class="s1">test_extractall_same_as_extract_subject_index(any_string_dtype):</span>
    <span class="s2"># same as above tests, but s has an MultiIndex.</span>
    <span class="s1">mi = MultiIndex.from_tuples(</span>
        <span class="s1">[(</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;first&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;second&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;third&quot;</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">names=(</span><span class="s3">&quot;capital&quot;</span><span class="s0">, </span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a3&quot;</span><span class="s0">, </span><span class="s3">&quot;b3&quot;</span><span class="s0">, </span><span class="s3">&quot;c2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=mi</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series_name&quot;</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">pattern_two_noname = </span><span class="s3">r&quot;([a-z])([0-9])&quot;</span>
    <span class="s1">extract_two_noname = s.str.extract(pattern_two_noname</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_match_index = s.str.extractall(pattern_two_noname)</span>
    <span class="s1">no_match_index = has_match_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_two_noname</span><span class="s0">, </span><span class="s1">no_match_index)</span>

    <span class="s1">pattern_two_named = </span><span class="s3">r&quot;(?P&lt;letter&gt;[a-z])(?P&lt;digit&gt;[0-9])&quot;</span>
    <span class="s1">extract_two_named = s.str.extract(pattern_two_named</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_match_index = s.str.extractall(pattern_two_named)</span>
    <span class="s1">no_match_index = has_match_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_two_named</span><span class="s0">, </span><span class="s1">no_match_index)</span>

    <span class="s1">pattern_one_named = </span><span class="s3">r&quot;(?P&lt;group_name&gt;[a-z])&quot;</span>
    <span class="s1">extract_one_named = s.str.extract(pattern_one_named</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_match_index = s.str.extractall(pattern_one_named)</span>
    <span class="s1">no_match_index = has_match_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_one_named</span><span class="s0">, </span><span class="s1">no_match_index)</span>

    <span class="s1">pattern_one_noname = </span><span class="s3">r&quot;([a-z])&quot;</span>
    <span class="s1">extract_one_noname = s.str.extract(pattern_one_noname</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">has_match_index = s.str.extractall(pattern_one_noname)</span>
    <span class="s1">no_match_index = has_match_index.xs(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">&quot;match&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(extract_one_noname</span><span class="s0">, </span><span class="s1">no_match_index)</span>
</pre>
</body>
</html>