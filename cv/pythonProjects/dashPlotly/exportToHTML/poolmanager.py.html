<html>
<head>
<title>poolmanager.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
poolmanager.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">logging</span>

<span class="s0">from </span><span class="s1">._collections </span><span class="s0">import </span><span class="s1">RecentlyUsedContainer</span>
<span class="s0">from </span><span class="s1">.connectionpool </span><span class="s0">import </span><span class="s1">HTTPConnectionPool</span><span class="s0">, </span><span class="s1">HTTPSConnectionPool</span><span class="s0">, </span><span class="s1">port_by_scheme</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">LocationValueError</span><span class="s0">,</span>
    <span class="s1">MaxRetryError</span><span class="s0">,</span>
    <span class="s1">ProxySchemeUnknown</span><span class="s0">,</span>
    <span class="s1">ProxySchemeUnsupported</span><span class="s0">,</span>
    <span class="s1">URLSchemeUnknown</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.packages </span><span class="s0">import </span><span class="s1">six</span>
<span class="s0">from </span><span class="s1">.packages.six.moves.urllib.parse </span><span class="s0">import </span><span class="s1">urljoin</span>
<span class="s0">from </span><span class="s1">.request </span><span class="s0">import </span><span class="s1">RequestMethods</span>
<span class="s0">from </span><span class="s1">.util.proxy </span><span class="s0">import </span><span class="s1">connection_requires_http_tunnel</span>
<span class="s0">from </span><span class="s1">.util.retry </span><span class="s0">import </span><span class="s1">Retry</span>
<span class="s0">from </span><span class="s1">.util.url </span><span class="s0">import </span><span class="s1">parse_url</span>

<span class="s1">__all__ = [</span><span class="s2">&quot;PoolManager&quot;</span><span class="s0">, </span><span class="s2">&quot;ProxyManager&quot;</span><span class="s0">, </span><span class="s2">&quot;proxy_from_url&quot;</span><span class="s1">]</span>


<span class="s1">log = logging.getLogger(__name__)</span>

<span class="s1">SSL_KEYWORDS = (</span>
    <span class="s2">&quot;key_file&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cert_file&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cert_reqs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ca_certs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ssl_version&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ca_cert_dir&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ssl_context&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;key_password&quot;</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s3"># All known keyword arguments that could be provided to the pool manager, its</span>
<span class="s3"># pools, or the underlying connections. This is used to construct a pool key.</span>
<span class="s1">_key_fields = (</span>
    <span class="s2">&quot;key_scheme&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_host&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_port&quot;</span><span class="s0">,  </span><span class="s3"># int</span>
    <span class="s2">&quot;key_timeout&quot;</span><span class="s0">,  </span><span class="s3"># int or float or Timeout</span>
    <span class="s2">&quot;key_retries&quot;</span><span class="s0">,  </span><span class="s3"># int or Retry</span>
    <span class="s2">&quot;key_strict&quot;</span><span class="s0">,  </span><span class="s3"># bool</span>
    <span class="s2">&quot;key_block&quot;</span><span class="s0">,  </span><span class="s3"># bool</span>
    <span class="s2">&quot;key_source_address&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_key_file&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_key_password&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_cert_file&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_cert_reqs&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_ca_certs&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_ssl_version&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_ca_cert_dir&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_ssl_context&quot;</span><span class="s0">,  </span><span class="s3"># instance of ssl.SSLContext or urllib3.util.ssl_.SSLContext</span>
    <span class="s2">&quot;key_maxsize&quot;</span><span class="s0">,  </span><span class="s3"># int</span>
    <span class="s2">&quot;key_headers&quot;</span><span class="s0">,  </span><span class="s3"># dict</span>
    <span class="s2">&quot;key__proxy&quot;</span><span class="s0">,  </span><span class="s3"># parsed proxy url</span>
    <span class="s2">&quot;key__proxy_headers&quot;</span><span class="s0">,  </span><span class="s3"># dict</span>
    <span class="s2">&quot;key__proxy_config&quot;</span><span class="s0">,  </span><span class="s3"># class</span>
    <span class="s2">&quot;key_socket_options&quot;</span><span class="s0">,  </span><span class="s3"># list of (level (int), optname (int), value (int or str)) tuples</span>
    <span class="s2">&quot;key__socks_options&quot;</span><span class="s0">,  </span><span class="s3"># dict</span>
    <span class="s2">&quot;key_assert_hostname&quot;</span><span class="s0">,  </span><span class="s3"># bool or string</span>
    <span class="s2">&quot;key_assert_fingerprint&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
    <span class="s2">&quot;key_server_hostname&quot;</span><span class="s0">,  </span><span class="s3"># str</span>
<span class="s1">)</span>

<span class="s3">#: The namedtuple class used to construct keys for the connection pool.</span>
<span class="s3">#: All custom key schemes should include the fields in this key at a minimum.</span>
<span class="s1">PoolKey = collections.namedtuple(</span><span class="s2">&quot;PoolKey&quot;</span><span class="s0">, </span><span class="s1">_key_fields)</span>

<span class="s1">_proxy_config_fields = (</span><span class="s2">&quot;ssl_context&quot;</span><span class="s0">, </span><span class="s2">&quot;use_forwarding_for_https&quot;</span><span class="s1">)</span>
<span class="s1">ProxyConfig = collections.namedtuple(</span><span class="s2">&quot;ProxyConfig&quot;</span><span class="s0">, </span><span class="s1">_proxy_config_fields)</span>


<span class="s0">def </span><span class="s1">_default_key_normalizer(key_class</span><span class="s0">, </span><span class="s1">request_context):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create a pool key out of a request context dictionary. 
 
    According to RFC 3986, both the scheme and host are case-insensitive. 
    Therefore, this function normalizes both before constructing the pool 
    key for an HTTPS request. If you wish to change this behaviour, provide 
    alternate callables to ``key_fn_by_scheme``. 
 
    :param key_class: 
        The class to use when constructing the key. This should be a namedtuple 
        with the ``scheme`` and ``host`` keys at a minimum. 
    :type  key_class: namedtuple 
    :param request_context: 
        A dictionary-like object that contain the context for a request. 
    :type  request_context: dict 
 
    :return: A namedtuple that can be used as a connection pool key. 
    :rtype:  PoolKey 
    &quot;&quot;&quot;</span>
    <span class="s3"># Since we mutate the dictionary, make a copy first</span>
    <span class="s1">context = request_context.copy()</span>
    <span class="s1">context[</span><span class="s2">&quot;scheme&quot;</span><span class="s1">] = context[</span><span class="s2">&quot;scheme&quot;</span><span class="s1">].lower()</span>
    <span class="s1">context[</span><span class="s2">&quot;host&quot;</span><span class="s1">] = context[</span><span class="s2">&quot;host&quot;</span><span class="s1">].lower()</span>

    <span class="s3"># These are both dictionaries and need to be transformed into frozensets</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;headers&quot;</span><span class="s0">, </span><span class="s2">&quot;_proxy_headers&quot;</span><span class="s0">, </span><span class="s2">&quot;_socks_options&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">context </span><span class="s0">and </span><span class="s1">context[key] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">context[key] = frozenset(context[key].items())</span>

    <span class="s3"># The socket_options key may be a list and needs to be transformed into a</span>
    <span class="s3"># tuple.</span>
    <span class="s1">socket_opts = context.get(</span><span class="s2">&quot;socket_options&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">socket_opts </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">context[</span><span class="s2">&quot;socket_options&quot;</span><span class="s1">] = tuple(socket_opts)</span>

    <span class="s3"># Map the kwargs to the names in the namedtuple - this is necessary since</span>
    <span class="s3"># namedtuples can't have fields starting with '_'.</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">list(context.keys()):</span>
        <span class="s1">context[</span><span class="s2">&quot;key_&quot; </span><span class="s1">+ key] = context.pop(key)</span>

    <span class="s3"># Default to ``None`` for keys missing from the context</span>
    <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">key_class._fields:</span>
        <span class="s0">if </span><span class="s1">field </span><span class="s0">not in </span><span class="s1">context:</span>
            <span class="s1">context[field] = </span><span class="s0">None</span>

    <span class="s0">return </span><span class="s1">key_class(**context)</span>


<span class="s3">#: A dictionary that maps a scheme to a callable that creates a pool key.</span>
<span class="s3">#: This can be used to alter the way pool keys are constructed, if desired.</span>
<span class="s3">#: Each PoolManager makes a copy of this dictionary so they can be configured</span>
<span class="s3">#: globally here, or individually on the instance.</span>
<span class="s1">key_fn_by_scheme = {</span>
    <span class="s2">&quot;http&quot;</span><span class="s1">: functools.partial(_default_key_normalizer</span><span class="s0">, </span><span class="s1">PoolKey)</span><span class="s0">,</span>
    <span class="s2">&quot;https&quot;</span><span class="s1">: functools.partial(_default_key_normalizer</span><span class="s0">, </span><span class="s1">PoolKey)</span><span class="s0">,</span>
<span class="s1">}</span>

<span class="s1">pool_classes_by_scheme = {</span><span class="s2">&quot;http&quot;</span><span class="s1">: HTTPConnectionPool</span><span class="s0">, </span><span class="s2">&quot;https&quot;</span><span class="s1">: HTTPSConnectionPool}</span>


<span class="s0">class </span><span class="s1">PoolManager(RequestMethods):</span>
    <span class="s4">&quot;&quot;&quot; 
    Allows for arbitrary requests while transparently keeping track of 
    necessary connection pools for you. 
 
    :param num_pools: 
        Number of connection pools to cache before discarding the least 
        recently used pool. 
 
    :param headers: 
        Headers to include with all requests, unless other headers are given 
        explicitly. 
 
    :param \\**connection_pool_kw: 
        Additional parameters are used to create fresh 
        :class:`urllib3.connectionpool.ConnectionPool` instances. 
 
    Example:: 
 
        &gt;&gt;&gt; manager = PoolManager(num_pools=2) 
        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/') 
        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail') 
        &gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/') 
        &gt;&gt;&gt; len(manager.pools) 
        2 
 
    &quot;&quot;&quot;</span>

    <span class="s1">proxy = </span><span class="s0">None</span>
    <span class="s1">proxy_config = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">num_pools=</span><span class="s5">10</span><span class="s0">, </span><span class="s1">headers=</span><span class="s0">None, </span><span class="s1">**connection_pool_kw):</span>
        <span class="s1">RequestMethods.__init__(self</span><span class="s0">, </span><span class="s1">headers)</span>
        <span class="s1">self.connection_pool_kw = connection_pool_kw</span>
        <span class="s1">self.pools = RecentlyUsedContainer(num_pools</span><span class="s0">, </span><span class="s1">dispose_func=</span><span class="s0">lambda </span><span class="s1">p: p.close())</span>

        <span class="s3"># Locally set the pool classes and keys so other PoolManagers can</span>
        <span class="s3"># override them.</span>
        <span class="s1">self.pool_classes_by_scheme = pool_classes_by_scheme</span>
        <span class="s1">self.key_fn_by_scheme = key_fn_by_scheme.copy()</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_val</span><span class="s0">, </span><span class="s1">exc_tb):</span>
        <span class="s1">self.clear()</span>
        <span class="s3"># Return False to re-raise any potential exceptions</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_new_pool(self</span><span class="s0">, </span><span class="s1">scheme</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">request_context=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and 
        any additional pool keyword arguments. 
 
        If ``request_context`` is provided, it is provided as keyword arguments 
        to the pool class used. This method is used to actually create the 
        connection pools handed out by :meth:`connection_from_url` and 
        companion methods. It is intended to be overridden for customization. 
        &quot;&quot;&quot;</span>
        <span class="s1">pool_cls = self.pool_classes_by_scheme[scheme]</span>
        <span class="s0">if </span><span class="s1">request_context </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">request_context = self.connection_pool_kw.copy()</span>

        <span class="s3"># Although the context has everything necessary to create the pool,</span>
        <span class="s3"># this function has historically only used the scheme, host, and port</span>
        <span class="s3"># in the positional args. When an API change is acceptable these can</span>
        <span class="s3"># be removed.</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;scheme&quot;</span><span class="s0">, </span><span class="s2">&quot;host&quot;</span><span class="s0">, </span><span class="s2">&quot;port&quot;</span><span class="s1">):</span>
            <span class="s1">request_context.pop(key</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">scheme == </span><span class="s2">&quot;http&quot;</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">kw </span><span class="s0">in </span><span class="s1">SSL_KEYWORDS:</span>
                <span class="s1">request_context.pop(kw</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">pool_cls(host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">**request_context)</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Empty our store of pools and direct them all to close. 
 
        This will not affect in-flight connections, but they will not be 
        re-used after completion. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.pools.clear()</span>

    <span class="s0">def </span><span class="s1">connection_from_host(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port=</span><span class="s0">None, </span><span class="s1">scheme=</span><span class="s2">&quot;http&quot;</span><span class="s0">, </span><span class="s1">pool_kwargs=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme. 
 
        If ``port`` isn't given, it will be derived from the ``scheme`` using 
        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is 
        provided, it is merged with the instance's ``connection_pool_kw`` 
        variable and used to create the new connection pool, if one is 
        needed. 
        &quot;&quot;&quot;</span>

        <span class="s0">if not </span><span class="s1">host:</span>
            <span class="s0">raise </span><span class="s1">LocationValueError(</span><span class="s2">&quot;No host specified.&quot;</span><span class="s1">)</span>

        <span class="s1">request_context = self._merge_pool_kwargs(pool_kwargs)</span>
        <span class="s1">request_context[</span><span class="s2">&quot;scheme&quot;</span><span class="s1">] = scheme </span><span class="s0">or </span><span class="s2">&quot;http&quot;</span>
        <span class="s0">if not </span><span class="s1">port:</span>
            <span class="s1">port = port_by_scheme.get(request_context[</span><span class="s2">&quot;scheme&quot;</span><span class="s1">].lower()</span><span class="s0">, </span><span class="s5">80</span><span class="s1">)</span>
        <span class="s1">request_context[</span><span class="s2">&quot;port&quot;</span><span class="s1">] = port</span>
        <span class="s1">request_context[</span><span class="s2">&quot;host&quot;</span><span class="s1">] = host</span>

        <span class="s0">return </span><span class="s1">self.connection_from_context(request_context)</span>

    <span class="s0">def </span><span class="s1">connection_from_context(self</span><span class="s0">, </span><span class="s1">request_context):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context. 
 
        ``request_context`` must at least contain the ``scheme`` key and its 
        value must be a key in ``key_fn_by_scheme`` instance variable. 
        &quot;&quot;&quot;</span>
        <span class="s1">scheme = request_context[</span><span class="s2">&quot;scheme&quot;</span><span class="s1">].lower()</span>
        <span class="s1">pool_key_constructor = self.key_fn_by_scheme.get(scheme)</span>
        <span class="s0">if not </span><span class="s1">pool_key_constructor:</span>
            <span class="s0">raise </span><span class="s1">URLSchemeUnknown(scheme)</span>
        <span class="s1">pool_key = pool_key_constructor(request_context)</span>

        <span class="s0">return </span><span class="s1">self.connection_from_pool_key(pool_key</span><span class="s0">, </span><span class="s1">request_context=request_context)</span>

    <span class="s0">def </span><span class="s1">connection_from_pool_key(self</span><span class="s0">, </span><span class="s1">pool_key</span><span class="s0">, </span><span class="s1">request_context=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key. 
 
        ``pool_key`` should be a namedtuple that only contains immutable 
        objects. At a minimum it must have the ``scheme``, ``host``, and 
        ``port`` fields. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self.pools.lock:</span>
            <span class="s3"># If the scheme, host, or port doesn't match existing open</span>
            <span class="s3"># connections, open a new ConnectionPool.</span>
            <span class="s1">pool = self.pools.get(pool_key)</span>
            <span class="s0">if </span><span class="s1">pool:</span>
                <span class="s0">return </span><span class="s1">pool</span>

            <span class="s3"># Make a fresh ConnectionPool of the desired type</span>
            <span class="s1">scheme = request_context[</span><span class="s2">&quot;scheme&quot;</span><span class="s1">]</span>
            <span class="s1">host = request_context[</span><span class="s2">&quot;host&quot;</span><span class="s1">]</span>
            <span class="s1">port = request_context[</span><span class="s2">&quot;port&quot;</span><span class="s1">]</span>
            <span class="s1">pool = self._new_pool(scheme</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">request_context=request_context)</span>
            <span class="s1">self.pools[pool_key] = pool</span>

        <span class="s0">return </span><span class="s1">pool</span>

    <span class="s0">def </span><span class="s1">connection_from_url(self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">pool_kwargs=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Similar to :func:`urllib3.connectionpool.connection_from_url`. 
 
        If ``pool_kwargs`` is not provided and a new pool needs to be 
        constructed, ``self.connection_pool_kw`` is used to initialize 
        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs`` 
        is provided, it is used instead. Note that if a new pool does not 
        need to be created for the request, the provided ``pool_kwargs`` are 
        not used. 
        &quot;&quot;&quot;</span>
        <span class="s1">u = parse_url(url)</span>
        <span class="s0">return </span><span class="s1">self.connection_from_host(</span>
            <span class="s1">u.host</span><span class="s0">, </span><span class="s1">port=u.port</span><span class="s0">, </span><span class="s1">scheme=u.scheme</span><span class="s0">, </span><span class="s1">pool_kwargs=pool_kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_merge_pool_kwargs(self</span><span class="s0">, </span><span class="s1">override):</span>
        <span class="s4">&quot;&quot;&quot; 
        Merge a dictionary of override values for self.connection_pool_kw. 
 
        This does not modify self.connection_pool_kw and returns a new dict. 
        Any keys in the override dictionary with a value of ``None`` are 
        removed from the merged dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s1">base_pool_kwargs = self.connection_pool_kw.copy()</span>
        <span class="s0">if </span><span class="s1">override:</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">override.items():</span>
                <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s0">del </span><span class="s1">base_pool_kwargs[key]</span>
                    <span class="s0">except </span><span class="s1">KeyError:</span>
                        <span class="s0">pass</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">base_pool_kwargs[key] = value</span>
        <span class="s0">return </span><span class="s1">base_pool_kwargs</span>

    <span class="s0">def </span><span class="s1">_proxy_requires_url_absolute_form(self</span><span class="s0">, </span><span class="s1">parsed_url):</span>
        <span class="s4">&quot;&quot;&quot; 
        Indicates if the proxy requires the complete destination URL in the 
        request.  Normally this is only needed when not using an HTTP CONNECT 
        tunnel. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.proxy </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return False</span>

        <span class="s0">return not </span><span class="s1">connection_requires_http_tunnel(</span>
            <span class="s1">self.proxy</span><span class="s0">, </span><span class="s1">self.proxy_config</span><span class="s0">, </span><span class="s1">parsed_url.scheme</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_validate_proxy_scheme_url_selection(self</span><span class="s0">, </span><span class="s1">url_scheme):</span>
        <span class="s4">&quot;&quot;&quot; 
        Validates that were not attempting to do TLS in TLS connections on 
        Python2 or with unsupported SSL implementations. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.proxy </span><span class="s0">is None or </span><span class="s1">url_scheme != </span><span class="s2">&quot;https&quot;</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">self.proxy.scheme != </span><span class="s2">&quot;https&quot;</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">six.PY2 </span><span class="s0">and not </span><span class="s1">self.proxy_config.use_forwarding_for_https:</span>
            <span class="s0">raise </span><span class="s1">ProxySchemeUnsupported(</span>
                <span class="s2">&quot;Contacting HTTPS destinations through HTTPS proxies &quot;</span>
                <span class="s2">&quot;'via CONNECT tunnels' is not supported in Python 2&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">urlopen(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect=</span><span class="s0">True, </span><span class="s1">**kw):</span>
        <span class="s4">&quot;&quot;&quot; 
        Same as :meth:`urllib3.HTTPConnectionPool.urlopen` 
        with custom cross-host redirect logic and only sends the request-uri 
        portion of the ``url``. 
 
        The given ``url`` parameter must be absolute, such that an appropriate 
        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it. 
        &quot;&quot;&quot;</span>
        <span class="s1">u = parse_url(url)</span>
        <span class="s1">self._validate_proxy_scheme_url_selection(u.scheme)</span>

        <span class="s1">conn = self.connection_from_host(u.host</span><span class="s0">, </span><span class="s1">port=u.port</span><span class="s0">, </span><span class="s1">scheme=u.scheme)</span>

        <span class="s1">kw[</span><span class="s2">&quot;assert_same_host&quot;</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s1">kw[</span><span class="s2">&quot;redirect&quot;</span><span class="s1">] = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s2">&quot;headers&quot; </span><span class="s0">not in </span><span class="s1">kw:</span>
            <span class="s1">kw[</span><span class="s2">&quot;headers&quot;</span><span class="s1">] = self.headers.copy()</span>

        <span class="s0">if </span><span class="s1">self._proxy_requires_url_absolute_form(u):</span>
            <span class="s1">response = conn.urlopen(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">**kw)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">response = conn.urlopen(method</span><span class="s0">, </span><span class="s1">u.request_uri</span><span class="s0">, </span><span class="s1">**kw)</span>

        <span class="s1">redirect_location = redirect </span><span class="s0">and </span><span class="s1">response.get_redirect_location()</span>
        <span class="s0">if not </span><span class="s1">redirect_location:</span>
            <span class="s0">return </span><span class="s1">response</span>

        <span class="s3"># Support relative URLs for redirecting.</span>
        <span class="s1">redirect_location = urljoin(url</span><span class="s0">, </span><span class="s1">redirect_location)</span>

        <span class="s3"># RFC 7231, Section 6.4.4</span>
        <span class="s0">if </span><span class="s1">response.status == </span><span class="s5">303</span><span class="s1">:</span>
            <span class="s1">method = </span><span class="s2">&quot;GET&quot;</span>

        <span class="s1">retries = kw.get(</span><span class="s2">&quot;retries&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(retries</span><span class="s0">, </span><span class="s1">Retry):</span>
            <span class="s1">retries = Retry.from_int(retries</span><span class="s0">, </span><span class="s1">redirect=redirect)</span>

        <span class="s3"># Strip headers marked as unsafe to forward to the redirected location.</span>
        <span class="s3"># Check remove_headers_on_redirect to avoid a potential network call within</span>
        <span class="s3"># conn.is_same_host() which may use socket.gethostbyname() in the future.</span>
        <span class="s0">if </span><span class="s1">retries.remove_headers_on_redirect </span><span class="s0">and not </span><span class="s1">conn.is_same_host(</span>
            <span class="s1">redirect_location</span>
        <span class="s1">):</span>
            <span class="s1">headers = list(six.iterkeys(kw[</span><span class="s2">&quot;headers&quot;</span><span class="s1">]))</span>
            <span class="s0">for </span><span class="s1">header </span><span class="s0">in </span><span class="s1">headers:</span>
                <span class="s0">if </span><span class="s1">header.lower() </span><span class="s0">in </span><span class="s1">retries.remove_headers_on_redirect:</span>
                    <span class="s1">kw[</span><span class="s2">&quot;headers&quot;</span><span class="s1">].pop(header</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">retries = retries.increment(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">response=response</span><span class="s0">, </span><span class="s1">_pool=conn)</span>
        <span class="s0">except </span><span class="s1">MaxRetryError:</span>
            <span class="s0">if </span><span class="s1">retries.raise_on_redirect:</span>
                <span class="s1">response.drain_conn()</span>
                <span class="s0">raise</span>
            <span class="s0">return </span><span class="s1">response</span>

        <span class="s1">kw[</span><span class="s2">&quot;retries&quot;</span><span class="s1">] = retries</span>
        <span class="s1">kw[</span><span class="s2">&quot;redirect&quot;</span><span class="s1">] = redirect</span>

        <span class="s1">log.info(</span><span class="s2">&quot;Redirecting %s -&gt; %s&quot;</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect_location)</span>

        <span class="s1">response.drain_conn()</span>
        <span class="s0">return </span><span class="s1">self.urlopen(method</span><span class="s0">, </span><span class="s1">redirect_location</span><span class="s0">, </span><span class="s1">**kw)</span>


<span class="s0">class </span><span class="s1">ProxyManager(PoolManager):</span>
    <span class="s4">&quot;&quot;&quot; 
    Behaves just like :class:`PoolManager`, but sends all requests through 
    the defined proxy, using the CONNECT method for HTTPS URLs. 
 
    :param proxy_url: 
        The URL of the proxy to be used. 
 
    :param proxy_headers: 
        A dictionary containing headers that will be sent to the proxy. In case 
        of HTTP they are being sent with each request, while in the 
        HTTPS/CONNECT case they are sent only once. Could be used for proxy 
        authentication. 
 
    :param proxy_ssl_context: 
        The proxy SSL context is used to establish the TLS connection to the 
        proxy when using HTTPS proxies. 
 
    :param use_forwarding_for_https: 
        (Defaults to False) If set to True will forward requests to the HTTPS 
        proxy to be made on behalf of the client instead of creating a TLS 
        tunnel via the CONNECT method. **Enabling this flag means that request 
        and response headers and content will be visible from the HTTPS proxy** 
        whereas tunneling keeps request and response headers and content 
        private.  IP address, target hostname, SNI, and port are always visible 
        to an HTTPS proxy even when this flag is disabled. 
 
    Example: 
        &gt;&gt;&gt; proxy = urllib3.ProxyManager('http://localhost:3128/') 
        &gt;&gt;&gt; r1 = proxy.request('GET', 'http://google.com/') 
        &gt;&gt;&gt; r2 = proxy.request('GET', 'http://httpbin.org/') 
        &gt;&gt;&gt; len(proxy.pools) 
        1 
        &gt;&gt;&gt; r3 = proxy.request('GET', 'https://httpbin.org/') 
        &gt;&gt;&gt; r4 = proxy.request('GET', 'https://twitter.com/') 
        &gt;&gt;&gt; len(proxy.pools) 
        3 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">proxy_url</span><span class="s0">,</span>
        <span class="s1">num_pools=</span><span class="s5">10</span><span class="s0">,</span>
        <span class="s1">headers=</span><span class="s0">None,</span>
        <span class="s1">proxy_headers=</span><span class="s0">None,</span>
        <span class="s1">proxy_ssl_context=</span><span class="s0">None,</span>
        <span class="s1">use_forwarding_for_https=</span><span class="s0">False,</span>
        <span class="s1">**connection_pool_kw</span>
    <span class="s1">):</span>

        <span class="s0">if </span><span class="s1">isinstance(proxy_url</span><span class="s0">, </span><span class="s1">HTTPConnectionPool):</span>
            <span class="s1">proxy_url = </span><span class="s2">&quot;%s://%s:%i&quot; </span><span class="s1">% (</span>
                <span class="s1">proxy_url.scheme</span><span class="s0">,</span>
                <span class="s1">proxy_url.host</span><span class="s0">,</span>
                <span class="s1">proxy_url.port</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">proxy = parse_url(proxy_url)</span>

        <span class="s0">if </span><span class="s1">proxy.scheme </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;http&quot;</span><span class="s0">, </span><span class="s2">&quot;https&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ProxySchemeUnknown(proxy.scheme)</span>

        <span class="s0">if not </span><span class="s1">proxy.port:</span>
            <span class="s1">port = port_by_scheme.get(proxy.scheme</span><span class="s0">, </span><span class="s5">80</span><span class="s1">)</span>
            <span class="s1">proxy = proxy._replace(port=port)</span>

        <span class="s1">self.proxy = proxy</span>
        <span class="s1">self.proxy_headers = proxy_headers </span><span class="s0">or </span><span class="s1">{}</span>
        <span class="s1">self.proxy_ssl_context = proxy_ssl_context</span>
        <span class="s1">self.proxy_config = ProxyConfig(proxy_ssl_context</span><span class="s0">, </span><span class="s1">use_forwarding_for_https)</span>

        <span class="s1">connection_pool_kw[</span><span class="s2">&quot;_proxy&quot;</span><span class="s1">] = self.proxy</span>
        <span class="s1">connection_pool_kw[</span><span class="s2">&quot;_proxy_headers&quot;</span><span class="s1">] = self.proxy_headers</span>
        <span class="s1">connection_pool_kw[</span><span class="s2">&quot;_proxy_config&quot;</span><span class="s1">] = self.proxy_config</span>

        <span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).__init__(num_pools</span><span class="s0">, </span><span class="s1">headers</span><span class="s0">, </span><span class="s1">**connection_pool_kw)</span>

    <span class="s0">def </span><span class="s1">connection_from_host(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port=</span><span class="s0">None, </span><span class="s1">scheme=</span><span class="s2">&quot;http&quot;</span><span class="s0">, </span><span class="s1">pool_kwargs=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">scheme == </span><span class="s2">&quot;https&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).connection_from_host(</span>
                <span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">scheme</span><span class="s0">, </span><span class="s1">pool_kwargs=pool_kwargs</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).connection_from_host(</span>
            <span class="s1">self.proxy.host</span><span class="s0">, </span><span class="s1">self.proxy.port</span><span class="s0">, </span><span class="s1">self.proxy.scheme</span><span class="s0">, </span><span class="s1">pool_kwargs=pool_kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_set_proxy_headers(self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">headers=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets headers needed by proxies: specifically, the Accept and Host 
        headers. Only sets headers not provided by the user. 
        &quot;&quot;&quot;</span>
        <span class="s1">headers_ = {</span><span class="s2">&quot;Accept&quot;</span><span class="s1">: </span><span class="s2">&quot;*/*&quot;</span><span class="s1">}</span>

        <span class="s1">netloc = parse_url(url).netloc</span>
        <span class="s0">if </span><span class="s1">netloc:</span>
            <span class="s1">headers_[</span><span class="s2">&quot;Host&quot;</span><span class="s1">] = netloc</span>

        <span class="s0">if </span><span class="s1">headers:</span>
            <span class="s1">headers_.update(headers)</span>
        <span class="s0">return </span><span class="s1">headers_</span>

    <span class="s0">def </span><span class="s1">urlopen(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect=</span><span class="s0">True, </span><span class="s1">**kw):</span>
        <span class="s4">&quot;Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.&quot;</span>
        <span class="s1">u = parse_url(url)</span>
        <span class="s0">if not </span><span class="s1">connection_requires_http_tunnel(self.proxy</span><span class="s0">, </span><span class="s1">self.proxy_config</span><span class="s0">, </span><span class="s1">u.scheme):</span>
            <span class="s3"># For connections using HTTP CONNECT, httplib sets the necessary</span>
            <span class="s3"># headers on the CONNECT to the proxy. If we're not using CONNECT,</span>
            <span class="s3"># we'll definitely need to set 'Host' at the very least.</span>
            <span class="s1">headers = kw.get(</span><span class="s2">&quot;headers&quot;</span><span class="s0">, </span><span class="s1">self.headers)</span>
            <span class="s1">kw[</span><span class="s2">&quot;headers&quot;</span><span class="s1">] = self._set_proxy_headers(url</span><span class="s0">, </span><span class="s1">headers)</span>

        <span class="s0">return </span><span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).urlopen(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect=redirect</span><span class="s0">, </span><span class="s1">**kw)</span>


<span class="s0">def </span><span class="s1">proxy_from_url(url</span><span class="s0">, </span><span class="s1">**kw):</span>
    <span class="s0">return </span><span class="s1">ProxyManager(proxy_url=url</span><span class="s0">, </span><span class="s1">**kw)</span>
</pre>
</body>
</html>