<html>
<head>
<title>join.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
join.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>
<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">int64_t,</span>
    <span class="s0">intp_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint64_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from pandas._libs.algos import groupsort_indexer</span>

<span class="s0">from pandas._libs.dtypes cimport (</span>
    <span class="s0">numeric_object_t,</span>
    <span class="s0">numeric_t,</span>
<span class="s0">)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def inner_join(const intp_t[:] left, const intp_t[:] right,</span>
               <span class="s0">Py_ssize_t max_groups):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, count = 0</span>
        <span class="s0">intp_t[::1] left_sorter, right_sorter</span>
        <span class="s0">intp_t[::1] left_count, right_count</span>
        <span class="s0">intp_t[::1] left_indexer, right_indexer</span>
        <span class="s0">intp_t lc, rc</span>
        <span class="s0">Py_ssize_t left_pos = 0, right_pos = 0, position = 0</span>
        <span class="s0">Py_ssize_t offset</span>

    <span class="s0">left_sorter, left_count = groupsort_indexer(left, max_groups)</span>
    <span class="s0">right_sorter, right_count = groupsort_indexer(right, max_groups)</span>

    <span class="s0">with nogil:</span>
        <span class="s0"># First pass, determine size of result set, do not use the NA group</span>
        <span class="s0">for i in range(1, max_groups + 1):</span>
            <span class="s0">lc = left_count[i]</span>
            <span class="s0">rc = right_count[i]</span>

            <span class="s0">if rc &gt; 0 and lc &gt; 0:</span>
                <span class="s0">count += lc * rc</span>

    <span class="s0">left_indexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(count, dtype=np.intp)</span>

    <span class="s0">with nogil:</span>
        <span class="s0"># exclude the NA group</span>
        <span class="s0">left_pos = left_count[0]</span>
        <span class="s0">right_pos = right_count[0]</span>
        <span class="s0">for i in range(1, max_groups + 1):</span>
            <span class="s0">lc = left_count[i]</span>
            <span class="s0">rc = right_count[i]</span>

            <span class="s0">if rc &gt; 0 and lc &gt; 0:</span>
                <span class="s0">for j in range(lc):</span>
                    <span class="s0">offset = position + j * rc</span>
                    <span class="s0">for k in range(rc):</span>
                        <span class="s0">left_indexer[offset + k] = left_pos + j</span>
                        <span class="s0">right_indexer[offset + k] = right_pos + k</span>
                <span class="s0">position += lc * rc</span>
            <span class="s0">left_pos += lc</span>
            <span class="s0">right_pos += rc</span>

        <span class="s0"># Will overwrite left/right indexer with the result</span>
        <span class="s0">_get_result_indexer(left_sorter, left_indexer)</span>
        <span class="s0">_get_result_indexer(right_sorter, right_indexer)</span>

    <span class="s0">return np.asarray(left_indexer), np.asarray(right_indexer)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def left_outer_join(const intp_t[:] left, const intp_t[:] right,</span>
                    <span class="s0">Py_ssize_t max_groups, bint sort=True):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, count = 0</span>
        <span class="s0">ndarray[intp_t] rev</span>
        <span class="s0">intp_t[::1] left_count, right_count</span>
        <span class="s0">intp_t[::1] left_sorter, right_sorter</span>
        <span class="s0">intp_t[::1] left_indexer, right_indexer</span>
        <span class="s0">intp_t lc, rc</span>
        <span class="s0">Py_ssize_t left_pos = 0, right_pos = 0, position = 0</span>
        <span class="s0">Py_ssize_t offset</span>

    <span class="s0">left_sorter, left_count = groupsort_indexer(left, max_groups)</span>
    <span class="s0">right_sorter, right_count = groupsort_indexer(right, max_groups)</span>

    <span class="s0">with nogil:</span>
        <span class="s0"># First pass, determine size of result set, do not use the NA group</span>
        <span class="s0">for i in range(1, max_groups + 1):</span>
            <span class="s0">if right_count[i] &gt; 0:</span>
                <span class="s0">count += left_count[i] * right_count[i]</span>
            <span class="s0">else:</span>
                <span class="s0">count += left_count[i]</span>

    <span class="s0">left_indexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(count, dtype=np.intp)</span>

    <span class="s0">with nogil:</span>
        <span class="s0"># exclude the NA group</span>
        <span class="s0">left_pos = left_count[0]</span>
        <span class="s0">right_pos = right_count[0]</span>
        <span class="s0">for i in range(1, max_groups + 1):</span>
            <span class="s0">lc = left_count[i]</span>
            <span class="s0">rc = right_count[i]</span>

            <span class="s0">if rc == 0:</span>
                <span class="s0">for j in range(lc):</span>
                    <span class="s0">left_indexer[position + j] = left_pos + j</span>
                    <span class="s0">right_indexer[position + j] = -1</span>
                <span class="s0">position += lc</span>
            <span class="s0">else:</span>
                <span class="s0">for j in range(lc):</span>
                    <span class="s0">offset = position + j * rc</span>
                    <span class="s0">for k in range(rc):</span>
                        <span class="s0">left_indexer[offset + k] = left_pos + j</span>
                        <span class="s0">right_indexer[offset + k] = right_pos + k</span>
                <span class="s0">position += lc * rc</span>
            <span class="s0">left_pos += lc</span>
            <span class="s0">right_pos += rc</span>

        <span class="s0"># Will overwrite left/right indexer with the result</span>
        <span class="s0">_get_result_indexer(left_sorter, left_indexer)</span>
        <span class="s0">_get_result_indexer(right_sorter, right_indexer)</span>

    <span class="s0">if not sort:  # if not asked to sort, revert to original order</span>
        <span class="s0">if len(left) == len(left_indexer):</span>
            <span class="s0"># no multiple matches for any row on the left</span>
            <span class="s0"># this is a short-cut to avoid groupsort_indexer</span>
            <span class="s0"># otherwise, the `else` path also works in this case</span>
            <span class="s0">rev = np.empty(len(left), dtype=np.intp)</span>
            <span class="s0">rev.put(np.asarray(left_sorter), np.arange(len(left)))</span>
        <span class="s0">else:</span>
            <span class="s0">rev, _ = groupsort_indexer(left_indexer, len(left))</span>

        <span class="s0">return np.asarray(left_indexer).take(rev), np.asarray(right_indexer).take(rev)</span>
    <span class="s0">else:</span>
        <span class="s0">return np.asarray(left_indexer), np.asarray(right_indexer)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def full_outer_join(const intp_t[:] left, const intp_t[:] right,</span>
                    <span class="s0">Py_ssize_t max_groups):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, count = 0</span>
        <span class="s0">intp_t[::1] left_sorter, right_sorter</span>
        <span class="s0">intp_t[::1] left_count, right_count</span>
        <span class="s0">intp_t[::1] left_indexer, right_indexer</span>
        <span class="s0">intp_t lc, rc</span>
        <span class="s0">intp_t left_pos = 0, right_pos = 0</span>
        <span class="s0">Py_ssize_t offset, position = 0</span>

    <span class="s0">left_sorter, left_count = groupsort_indexer(left, max_groups)</span>
    <span class="s0">right_sorter, right_count = groupsort_indexer(right, max_groups)</span>

    <span class="s0">with nogil:</span>
        <span class="s0"># First pass, determine size of result set, do not use the NA group</span>
        <span class="s0">for i in range(1, max_groups + 1):</span>
            <span class="s0">lc = left_count[i]</span>
            <span class="s0">rc = right_count[i]</span>

            <span class="s0">if rc &gt; 0 and lc &gt; 0:</span>
                <span class="s0">count += lc * rc</span>
            <span class="s0">else:</span>
                <span class="s0">count += lc + rc</span>

    <span class="s0">left_indexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(count, dtype=np.intp)</span>

    <span class="s0">with nogil:</span>
        <span class="s0"># exclude the NA group</span>
        <span class="s0">left_pos = left_count[0]</span>
        <span class="s0">right_pos = right_count[0]</span>
        <span class="s0">for i in range(1, max_groups + 1):</span>
            <span class="s0">lc = left_count[i]</span>
            <span class="s0">rc = right_count[i]</span>

            <span class="s0">if rc == 0:</span>
                <span class="s0">for j in range(lc):</span>
                    <span class="s0">left_indexer[position + j] = left_pos + j</span>
                    <span class="s0">right_indexer[position + j] = -1</span>
                <span class="s0">position += lc</span>
            <span class="s0">elif lc == 0:</span>
                <span class="s0">for j in range(rc):</span>
                    <span class="s0">left_indexer[position + j] = -1</span>
                    <span class="s0">right_indexer[position + j] = right_pos + j</span>
                <span class="s0">position += rc</span>
            <span class="s0">else:</span>
                <span class="s0">for j in range(lc):</span>
                    <span class="s0">offset = position + j * rc</span>
                    <span class="s0">for k in range(rc):</span>
                        <span class="s0">left_indexer[offset + k] = left_pos + j</span>
                        <span class="s0">right_indexer[offset + k] = right_pos + k</span>
                <span class="s0">position += lc * rc</span>
            <span class="s0">left_pos += lc</span>
            <span class="s0">right_pos += rc</span>

        <span class="s0"># Will overwrite left/right indexer with the result</span>
        <span class="s0">_get_result_indexer(left_sorter, left_indexer)</span>
        <span class="s0">_get_result_indexer(right_sorter, right_indexer)</span>

    <span class="s0">return np.asarray(left_indexer), np.asarray(right_indexer)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef void _get_result_indexer(intp_t[::1] sorter, intp_t[::1] indexer) nogil:</span>
    <span class="s0">&quot;&quot;&quot;NOTE: overwrites indexer with the result to avoid allocating another array&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n, idx</span>

    <span class="s0">if len(sorter) &gt; 0:</span>
        <span class="s0"># cython-only equivalent to</span>
        <span class="s0">#  `res = algos.take_nd(sorter, indexer, fill_value=-1)`</span>
        <span class="s0">n = indexer.shape[0]</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">idx = indexer[i]</span>
            <span class="s0">if idx == -1:</span>
                <span class="s0">indexer[i] = -1</span>
            <span class="s0">else:</span>
                <span class="s0">indexer[i] = sorter[idx]</span>
    <span class="s0">else:</span>
        <span class="s0"># length-0 case</span>
        <span class="s0">indexer[:] = -1</span>


<span class="s0">def ffill_indexer(const intp_t[:] indexer) -&gt; np.ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(indexer)</span>
        <span class="s0">ndarray[intp_t] result</span>
        <span class="s0">intp_t val, last_obs</span>

    <span class="s0">result = np.empty(n, dtype=np.intp)</span>
    <span class="s0">last_obs = -1</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = indexer[i]</span>
        <span class="s0">if val == -1:</span>
            <span class="s0">result[i] = last_obs</span>
        <span class="s0">else:</span>
            <span class="s0">result[i] = val</span>
            <span class="s0">last_obs = val</span>

    <span class="s0">return result</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># left_join_indexer, inner_join_indexer, outer_join_indexer</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0"># Joins on ordered, unique indices</span>

<span class="s0"># right might contain non-unique values</span>

<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def left_join_indexer_unique(</span>
    <span class="s0">ndarray[numeric_object_t] left,</span>
    <span class="s0">ndarray[numeric_object_t] right</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Both left and right are strictly monotonic increasing.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, nleft, nright</span>
        <span class="s0">ndarray[intp_t] indexer</span>
        <span class="s0">numeric_object_t lval, rval</span>

    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">nleft = len(left)</span>
    <span class="s0">nright = len(right)</span>

    <span class="s0">indexer = np.empty(nleft, dtype=np.intp)</span>
    <span class="s0">while True:</span>
        <span class="s0">if i == nleft:</span>
            <span class="s0">break</span>

        <span class="s0">if j == nright:</span>
            <span class="s0">indexer[i] = -1</span>
            <span class="s0">i += 1</span>
            <span class="s0">continue</span>

        <span class="s0">rval = right[j]</span>

        <span class="s0">while i &lt; nleft - 1 and left[i] == rval:</span>
            <span class="s0">indexer[i] = j</span>
            <span class="s0">i += 1</span>

        <span class="s0">if left[i] == right[j]:</span>
            <span class="s0">indexer[i] = j</span>
            <span class="s0">i += 1</span>
            <span class="s0">while i &lt; nleft - 1 and left[i] == rval:</span>
                <span class="s0">indexer[i] = j</span>
                <span class="s0">i += 1</span>
            <span class="s0">j += 1</span>
        <span class="s0">elif left[i] &gt; rval:</span>
            <span class="s0">indexer[i] = -1</span>
            <span class="s0">j += 1</span>
        <span class="s0">else:</span>
            <span class="s0">indexer[i] = -1</span>
            <span class="s0">i += 1</span>
    <span class="s0">return indexer</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def left_join_indexer(ndarray[numeric_object_t] left, ndarray[numeric_object_t] right):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Two-pass algorithm for monotonic indexes. Handles many-to-one merges.</span>

    <span class="s0">Both left and right are monotonic increasing, but at least one of them</span>
    <span class="s0">is non-unique (if both were unique we'd use left_join_indexer_unique).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, nright, nleft, count</span>
        <span class="s0">numeric_object_t lval, rval</span>
        <span class="s0">ndarray[intp_t] lindexer, rindexer</span>
        <span class="s0">ndarray[numeric_object_t] result</span>

    <span class="s0">nleft = len(left)</span>
    <span class="s0">nright = len(right)</span>

    <span class="s0"># First pass is to find the size 'count' of our output indexers.</span>
    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">count = 0</span>
    <span class="s0">if nleft &gt; 0:</span>
        <span class="s0">while i &lt; nleft:</span>
            <span class="s0">if j == nright:</span>
                <span class="s0">count += nleft - i</span>
                <span class="s0">break</span>

            <span class="s0">lval = left[i]</span>
            <span class="s0">rval = right[j]</span>

            <span class="s0">if lval == rval:</span>
                <span class="s0"># This block is identical across</span>
                <span class="s0">#  left_join_indexer, inner_join_indexer, outer_join_indexer</span>
                <span class="s0">count += 1</span>
                <span class="s0">if i &lt; nleft - 1:</span>
                    <span class="s0">if j &lt; nright - 1 and right[j + 1] == rval:</span>
                        <span class="s0">j += 1</span>
                    <span class="s0">else:</span>
                        <span class="s0">i += 1</span>
                        <span class="s0">if left[i] != rval:</span>
                            <span class="s0">j += 1</span>
                <span class="s0">elif j &lt; nright - 1:</span>
                    <span class="s0">j += 1</span>
                    <span class="s0">if lval != right[j]:</span>
                        <span class="s0">i += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># end of the road</span>
                    <span class="s0">break</span>
            <span class="s0">elif lval &lt; rval:</span>
                <span class="s0">count += 1</span>
                <span class="s0">i += 1</span>
            <span class="s0">else:</span>
                <span class="s0">j += 1</span>

    <span class="s0"># do it again now that result size is known</span>

    <span class="s0">lindexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">rindexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">result = np.empty(count, dtype=left.dtype)</span>

    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">count = 0</span>
    <span class="s0">if nleft &gt; 0:</span>
        <span class="s0">while i &lt; nleft:</span>
            <span class="s0">if j == nright:</span>
                <span class="s0">while i &lt; nleft:</span>
                    <span class="s0">lindexer[count] = i</span>
                    <span class="s0">rindexer[count] = -1</span>
                    <span class="s0">result[count] = left[i]</span>
                    <span class="s0">i += 1</span>
                    <span class="s0">count += 1</span>
                <span class="s0">break</span>

            <span class="s0">lval = left[i]</span>
            <span class="s0">rval = right[j]</span>

            <span class="s0">if lval == rval:</span>
                <span class="s0">lindexer[count] = i</span>
                <span class="s0">rindexer[count] = j</span>
                <span class="s0">result[count] = lval</span>
                <span class="s0">count += 1</span>
                <span class="s0">if i &lt; nleft - 1:</span>
                    <span class="s0">if j &lt; nright - 1 and right[j + 1] == rval:</span>
                        <span class="s0">j += 1</span>
                    <span class="s0">else:</span>
                        <span class="s0">i += 1</span>
                        <span class="s0">if left[i] != rval:</span>
                            <span class="s0">j += 1</span>
                <span class="s0">elif j &lt; nright - 1:</span>
                    <span class="s0">j += 1</span>
                    <span class="s0">if lval != right[j]:</span>
                        <span class="s0">i += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># end of the road</span>
                    <span class="s0">break</span>
            <span class="s0">elif lval &lt; rval:</span>
                <span class="s0"># i.e. lval not in right; we keep for left_join_indexer</span>
                <span class="s0">lindexer[count] = i</span>
                <span class="s0">rindexer[count] = -1</span>
                <span class="s0">result[count] = lval</span>
                <span class="s0">count += 1</span>
                <span class="s0">i += 1</span>
            <span class="s0">else:</span>
                <span class="s0"># i.e. rval not in left; we discard for left_join_indexer</span>
                <span class="s0">j += 1</span>

    <span class="s0">return result, lindexer, rindexer</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def inner_join_indexer(ndarray[numeric_object_t] left, ndarray[numeric_object_t] right):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Two-pass algorithm for monotonic indexes. Handles many-to-one merges.</span>

    <span class="s0">Both left and right are monotonic increasing but not necessarily unique.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, nright, nleft, count</span>
        <span class="s0">numeric_object_t lval, rval</span>
        <span class="s0">ndarray[intp_t] lindexer, rindexer</span>
        <span class="s0">ndarray[numeric_object_t] result</span>

    <span class="s0">nleft = len(left)</span>
    <span class="s0">nright = len(right)</span>

    <span class="s0"># First pass is to find the size 'count' of our output indexers.</span>
    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">count = 0</span>
    <span class="s0">if nleft &gt; 0 and nright &gt; 0:</span>
        <span class="s0">while True:</span>
            <span class="s0">if i == nleft:</span>
                <span class="s0">break</span>
            <span class="s0">if j == nright:</span>
                <span class="s0">break</span>

            <span class="s0">lval = left[i]</span>
            <span class="s0">rval = right[j]</span>
            <span class="s0">if lval == rval:</span>
                <span class="s0">count += 1</span>
                <span class="s0">if i &lt; nleft - 1:</span>
                    <span class="s0">if j &lt; nright - 1 and right[j + 1] == rval:</span>
                        <span class="s0">j += 1</span>
                    <span class="s0">else:</span>
                        <span class="s0">i += 1</span>
                        <span class="s0">if left[i] != rval:</span>
                            <span class="s0">j += 1</span>
                <span class="s0">elif j &lt; nright - 1:</span>
                    <span class="s0">j += 1</span>
                    <span class="s0">if lval != right[j]:</span>
                        <span class="s0">i += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># end of the road</span>
                    <span class="s0">break</span>
            <span class="s0">elif lval &lt; rval:</span>
                <span class="s0"># i.e. lval not in right; we discard for inner_indexer</span>
                <span class="s0">i += 1</span>
            <span class="s0">else:</span>
                <span class="s0"># i.e. rval not in left; we discard for inner_indexer</span>
                <span class="s0">j += 1</span>

    <span class="s0"># do it again now that result size is known</span>

    <span class="s0">lindexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">rindexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">result = np.empty(count, dtype=left.dtype)</span>

    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">count = 0</span>
    <span class="s0">if nleft &gt; 0 and nright &gt; 0:</span>
        <span class="s0">while True:</span>
            <span class="s0">if i == nleft:</span>
                <span class="s0">break</span>
            <span class="s0">if j == nright:</span>
                <span class="s0">break</span>

            <span class="s0">lval = left[i]</span>
            <span class="s0">rval = right[j]</span>
            <span class="s0">if lval == rval:</span>
                <span class="s0">lindexer[count] = i</span>
                <span class="s0">rindexer[count] = j</span>
                <span class="s0">result[count] = lval</span>
                <span class="s0">count += 1</span>
                <span class="s0">if i &lt; nleft - 1:</span>
                    <span class="s0">if j &lt; nright - 1 and right[j + 1] == rval:</span>
                        <span class="s0">j += 1</span>
                    <span class="s0">else:</span>
                        <span class="s0">i += 1</span>
                        <span class="s0">if left[i] != rval:</span>
                            <span class="s0">j += 1</span>
                <span class="s0">elif j &lt; nright - 1:</span>
                    <span class="s0">j += 1</span>
                    <span class="s0">if lval != right[j]:</span>
                        <span class="s0">i += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># end of the road</span>
                    <span class="s0">break</span>
            <span class="s0">elif lval &lt; rval:</span>
                <span class="s0"># i.e. lval not in right; we discard for inner_indexer</span>
                <span class="s0">i += 1</span>
            <span class="s0">else:</span>
                <span class="s0"># i.e. rval not in left; we discard for inner_indexer</span>
                <span class="s0">j += 1</span>

    <span class="s0">return result, lindexer, rindexer</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def outer_join_indexer(ndarray[numeric_object_t] left, ndarray[numeric_object_t] right):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Both left and right are monotonic increasing but not necessarily unique.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, nright, nleft, count</span>
        <span class="s0">numeric_object_t lval, rval</span>
        <span class="s0">ndarray[intp_t] lindexer, rindexer</span>
        <span class="s0">ndarray[numeric_object_t] result</span>

    <span class="s0">nleft = len(left)</span>
    <span class="s0">nright = len(right)</span>

    <span class="s0"># First pass is to find the size 'count' of our output indexers.</span>
    <span class="s0"># count will be length of left plus the number of elements of right not in</span>
    <span class="s0"># left (counting duplicates)</span>
    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">count = 0</span>
    <span class="s0">if nleft == 0:</span>
        <span class="s0">count = nright</span>
    <span class="s0">elif nright == 0:</span>
        <span class="s0">count = nleft</span>
    <span class="s0">else:</span>
        <span class="s0">while True:</span>
            <span class="s0">if i == nleft:</span>
                <span class="s0">count += nright - j</span>
                <span class="s0">break</span>
            <span class="s0">if j == nright:</span>
                <span class="s0">count += nleft - i</span>
                <span class="s0">break</span>

            <span class="s0">lval = left[i]</span>
            <span class="s0">rval = right[j]</span>
            <span class="s0">if lval == rval:</span>
                <span class="s0">count += 1</span>
                <span class="s0">if i &lt; nleft - 1:</span>
                    <span class="s0">if j &lt; nright - 1 and right[j + 1] == rval:</span>
                        <span class="s0">j += 1</span>
                    <span class="s0">else:</span>
                        <span class="s0">i += 1</span>
                        <span class="s0">if left[i] != rval:</span>
                            <span class="s0">j += 1</span>
                <span class="s0">elif j &lt; nright - 1:</span>
                    <span class="s0">j += 1</span>
                    <span class="s0">if lval != right[j]:</span>
                        <span class="s0">i += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># end of the road</span>
                    <span class="s0">break</span>
            <span class="s0">elif lval &lt; rval:</span>
                <span class="s0">count += 1</span>
                <span class="s0">i += 1</span>
            <span class="s0">else:</span>
                <span class="s0">count += 1</span>
                <span class="s0">j += 1</span>

    <span class="s0">lindexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">rindexer = np.empty(count, dtype=np.intp)</span>
    <span class="s0">result = np.empty(count, dtype=left.dtype)</span>

    <span class="s0"># do it again, but populate the indexers / result</span>

    <span class="s0">i = 0</span>
    <span class="s0">j = 0</span>
    <span class="s0">count = 0</span>
    <span class="s0">if nleft == 0:</span>
        <span class="s0">for j in range(nright):</span>
            <span class="s0">lindexer[j] = -1</span>
            <span class="s0">rindexer[j] = j</span>
            <span class="s0">result[j] = right[j]</span>
    <span class="s0">elif nright == 0:</span>
        <span class="s0">for i in range(nleft):</span>
            <span class="s0">lindexer[i] = i</span>
            <span class="s0">rindexer[i] = -1</span>
            <span class="s0">result[i] = left[i]</span>
    <span class="s0">else:</span>
        <span class="s0">while True:</span>
            <span class="s0">if i == nleft:</span>
                <span class="s0">while j &lt; nright:</span>
                    <span class="s0">lindexer[count] = -1</span>
                    <span class="s0">rindexer[count] = j</span>
                    <span class="s0">result[count] = right[j]</span>
                    <span class="s0">count += 1</span>
                    <span class="s0">j += 1</span>
                <span class="s0">break</span>
            <span class="s0">if j == nright:</span>
                <span class="s0">while i &lt; nleft:</span>
                    <span class="s0">lindexer[count] = i</span>
                    <span class="s0">rindexer[count] = -1</span>
                    <span class="s0">result[count] = left[i]</span>
                    <span class="s0">count += 1</span>
                    <span class="s0">i += 1</span>
                <span class="s0">break</span>

            <span class="s0">lval = left[i]</span>
            <span class="s0">rval = right[j]</span>

            <span class="s0">if lval == rval:</span>
                <span class="s0">lindexer[count] = i</span>
                <span class="s0">rindexer[count] = j</span>
                <span class="s0">result[count] = lval</span>
                <span class="s0">count += 1</span>
                <span class="s0">if i &lt; nleft - 1:</span>
                    <span class="s0">if j &lt; nright - 1 and right[j + 1] == rval:</span>
                        <span class="s0">j += 1</span>
                    <span class="s0">else:</span>
                        <span class="s0">i += 1</span>
                        <span class="s0">if left[i] != rval:</span>
                            <span class="s0">j += 1</span>
                <span class="s0">elif j &lt; nright - 1:</span>
                    <span class="s0">j += 1</span>
                    <span class="s0">if lval != right[j]:</span>
                        <span class="s0">i += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># end of the road</span>
                    <span class="s0">break</span>
            <span class="s0">elif lval &lt; rval:</span>
                <span class="s0"># i.e. lval not in right; we keep for outer_join_indexer</span>
                <span class="s0">lindexer[count] = i</span>
                <span class="s0">rindexer[count] = -1</span>
                <span class="s0">result[count] = lval</span>
                <span class="s0">count += 1</span>
                <span class="s0">i += 1</span>
            <span class="s0">else:</span>
                <span class="s0"># i.e. rval not in left; we keep for outer_join_indexer</span>
                <span class="s0">lindexer[count] = -1</span>
                <span class="s0">rindexer[count] = j</span>
                <span class="s0">result[count] = rval</span>
                <span class="s0">count += 1</span>
                <span class="s0">j += 1</span>

    <span class="s0">return result, lindexer, rindexer</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># asof_join_by</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">from pandas._libs.hashtable cimport (</span>
    <span class="s0">HashTable,</span>
    <span class="s0">Int64HashTable,</span>
    <span class="s0">PyObjectHashTable,</span>
    <span class="s0">UInt64HashTable,</span>
<span class="s0">)</span>

<span class="s0">ctypedef fused by_t:</span>
    <span class="s0">object</span>
    <span class="s0">int64_t</span>
    <span class="s0">uint64_t</span>


<span class="s0">def asof_join_backward_on_X_by_Y(numeric_t[:] left_values,</span>
                                 <span class="s0">numeric_t[:] right_values,</span>
                                 <span class="s0">by_t[:] left_by_values,</span>
                                 <span class="s0">by_t[:] right_by_values,</span>
                                 <span class="s0">bint allow_exact_matches=True,</span>
                                 <span class="s0">tolerance=None):</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t left_pos, right_pos, left_size, right_size, found_right_pos</span>
        <span class="s0">ndarray[intp_t] left_indexer, right_indexer</span>
        <span class="s0">bint has_tolerance = False</span>
        <span class="s0">numeric_t tolerance_ = 0</span>
        <span class="s0">numeric_t diff = 0</span>
        <span class="s0">HashTable hash_table</span>
        <span class="s0">by_t by_value</span>

    <span class="s0"># if we are using tolerance, set our objects</span>
    <span class="s0">if tolerance is not None:</span>
        <span class="s0">has_tolerance = True</span>
        <span class="s0">tolerance_ = tolerance</span>

    <span class="s0">left_size = len(left_values)</span>
    <span class="s0">right_size = len(right_values)</span>

    <span class="s0">left_indexer = np.empty(left_size, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(left_size, dtype=np.intp)</span>

    <span class="s0">if by_t is object:</span>
        <span class="s0">hash_table = PyObjectHashTable(right_size)</span>
    <span class="s0">elif by_t is int64_t:</span>
        <span class="s0">hash_table = Int64HashTable(right_size)</span>
    <span class="s0">elif by_t is uint64_t:</span>
        <span class="s0">hash_table = UInt64HashTable(right_size)</span>

    <span class="s0">right_pos = 0</span>
    <span class="s0">for left_pos in range(left_size):</span>
        <span class="s0"># restart right_pos if it went negative in a previous iteration</span>
        <span class="s0">if right_pos &lt; 0:</span>
            <span class="s0">right_pos = 0</span>

        <span class="s0"># find last position in right whose value is less than left's</span>
        <span class="s0">if allow_exact_matches:</span>
            <span class="s0">while (right_pos &lt; right_size and</span>
                   <span class="s0">right_values[right_pos] &lt;= left_values[left_pos]):</span>
                <span class="s0">hash_table.set_item(right_by_values[right_pos], right_pos)</span>
                <span class="s0">right_pos += 1</span>
        <span class="s0">else:</span>
            <span class="s0">while (right_pos &lt; right_size and</span>
                   <span class="s0">right_values[right_pos] &lt; left_values[left_pos]):</span>
                <span class="s0">hash_table.set_item(right_by_values[right_pos], right_pos)</span>
                <span class="s0">right_pos += 1</span>
        <span class="s0">right_pos -= 1</span>

        <span class="s0"># save positions as the desired index</span>
        <span class="s0">by_value = left_by_values[left_pos]</span>
        <span class="s0">found_right_pos = (hash_table.get_item(by_value)</span>
                           <span class="s0">if by_value in hash_table else -1)</span>
        <span class="s0">left_indexer[left_pos] = left_pos</span>
        <span class="s0">right_indexer[left_pos] = found_right_pos</span>

        <span class="s0"># if needed, verify that tolerance is met</span>
        <span class="s0">if has_tolerance and found_right_pos != -1:</span>
            <span class="s0">diff = left_values[left_pos] - right_values[found_right_pos]</span>
            <span class="s0">if diff &gt; tolerance_:</span>
                <span class="s0">right_indexer[left_pos] = -1</span>

    <span class="s0">return left_indexer, right_indexer</span>


<span class="s0">def asof_join_forward_on_X_by_Y(numeric_t[:] left_values,</span>
                                <span class="s0">numeric_t[:] right_values,</span>
                                <span class="s0">by_t[:] left_by_values,</span>
                                <span class="s0">by_t[:] right_by_values,</span>
                                <span class="s0">bint allow_exact_matches=1,</span>
                                <span class="s0">tolerance=None):</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t left_pos, right_pos, left_size, right_size, found_right_pos</span>
        <span class="s0">ndarray[intp_t] left_indexer, right_indexer</span>
        <span class="s0">bint has_tolerance = False</span>
        <span class="s0">numeric_t tolerance_ = 0</span>
        <span class="s0">numeric_t diff = 0</span>
        <span class="s0">HashTable hash_table</span>
        <span class="s0">by_t by_value</span>

    <span class="s0"># if we are using tolerance, set our objects</span>
    <span class="s0">if tolerance is not None:</span>
        <span class="s0">has_tolerance = True</span>
        <span class="s0">tolerance_ = tolerance</span>

    <span class="s0">left_size = len(left_values)</span>
    <span class="s0">right_size = len(right_values)</span>

    <span class="s0">left_indexer = np.empty(left_size, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(left_size, dtype=np.intp)</span>

    <span class="s0">if by_t is object:</span>
        <span class="s0">hash_table = PyObjectHashTable(right_size)</span>
    <span class="s0">elif by_t is int64_t:</span>
        <span class="s0">hash_table = Int64HashTable(right_size)</span>
    <span class="s0">elif by_t is uint64_t:</span>
        <span class="s0">hash_table = UInt64HashTable(right_size)</span>

    <span class="s0">right_pos = right_size - 1</span>
    <span class="s0">for left_pos in range(left_size - 1, -1, -1):</span>
        <span class="s0"># restart right_pos if it went over in a previous iteration</span>
        <span class="s0">if right_pos == right_size:</span>
            <span class="s0">right_pos = right_size - 1</span>

        <span class="s0"># find first position in right whose value is greater than left's</span>
        <span class="s0">if allow_exact_matches:</span>
            <span class="s0">while (right_pos &gt;= 0 and</span>
                   <span class="s0">right_values[right_pos] &gt;= left_values[left_pos]):</span>
                <span class="s0">hash_table.set_item(right_by_values[right_pos], right_pos)</span>
                <span class="s0">right_pos -= 1</span>
        <span class="s0">else:</span>
            <span class="s0">while (right_pos &gt;= 0 and</span>
                   <span class="s0">right_values[right_pos] &gt; left_values[left_pos]):</span>
                <span class="s0">hash_table.set_item(right_by_values[right_pos], right_pos)</span>
                <span class="s0">right_pos -= 1</span>
        <span class="s0">right_pos += 1</span>

        <span class="s0"># save positions as the desired index</span>
        <span class="s0">by_value = left_by_values[left_pos]</span>
        <span class="s0">found_right_pos = (hash_table.get_item(by_value)</span>
                           <span class="s0">if by_value in hash_table else -1)</span>
        <span class="s0">left_indexer[left_pos] = left_pos</span>
        <span class="s0">right_indexer[left_pos] = found_right_pos</span>

        <span class="s0"># if needed, verify that tolerance is met</span>
        <span class="s0">if has_tolerance and found_right_pos != -1:</span>
            <span class="s0">diff = right_values[found_right_pos] - left_values[left_pos]</span>
            <span class="s0">if diff &gt; tolerance_:</span>
                <span class="s0">right_indexer[left_pos] = -1</span>

    <span class="s0">return left_indexer, right_indexer</span>


<span class="s0">def asof_join_nearest_on_X_by_Y(numeric_t[:] left_values,</span>
                                <span class="s0">numeric_t[:] right_values,</span>
                                <span class="s0">by_t[:] left_by_values,</span>
                                <span class="s0">by_t[:] right_by_values,</span>
                                <span class="s0">bint allow_exact_matches=True,</span>
                                <span class="s0">tolerance=None):</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t left_size, right_size, i</span>
        <span class="s0">ndarray[intp_t] left_indexer, right_indexer, bli, bri, fli, fri</span>
        <span class="s0">numeric_t bdiff, fdiff</span>

    <span class="s0">left_size = len(left_values)</span>
    <span class="s0">right_size = len(right_values)</span>

    <span class="s0">left_indexer = np.empty(left_size, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(left_size, dtype=np.intp)</span>

    <span class="s0"># search both forward and backward</span>
    <span class="s0">bli, bri = asof_join_backward_on_X_by_Y(</span>
        <span class="s0">left_values,</span>
        <span class="s0">right_values,</span>
        <span class="s0">left_by_values,</span>
        <span class="s0">right_by_values,</span>
        <span class="s0">allow_exact_matches,</span>
        <span class="s0">tolerance,</span>
    <span class="s0">)</span>
    <span class="s0">fli, fri = asof_join_forward_on_X_by_Y(</span>
        <span class="s0">left_values,</span>
        <span class="s0">right_values,</span>
        <span class="s0">left_by_values,</span>
        <span class="s0">right_by_values,</span>
        <span class="s0">allow_exact_matches,</span>
        <span class="s0">tolerance,</span>
    <span class="s0">)</span>

    <span class="s0">for i in range(len(bri)):</span>
        <span class="s0"># choose timestamp from right with smaller difference</span>
        <span class="s0">if bri[i] != -1 and fri[i] != -1:</span>
            <span class="s0">bdiff = left_values[bli[i]] - right_values[bri[i]]</span>
            <span class="s0">fdiff = right_values[fri[i]] - left_values[fli[i]]</span>
            <span class="s0">right_indexer[i] = bri[i] if bdiff &lt;= fdiff else fri[i]</span>
        <span class="s0">else:</span>
            <span class="s0">right_indexer[i] = bri[i] if bri[i] != -1 else fri[i]</span>
        <span class="s0">left_indexer[i] = bli[i]</span>

    <span class="s0">return left_indexer, right_indexer</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># asof_join</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">def asof_join_backward(numeric_t[:] left_values,</span>
                       <span class="s0">numeric_t[:] right_values,</span>
                       <span class="s0">bint allow_exact_matches=True,</span>
                       <span class="s0">tolerance=None):</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t left_pos, right_pos, left_size, right_size</span>
        <span class="s0">ndarray[intp_t] left_indexer, right_indexer</span>
        <span class="s0">bint has_tolerance = False</span>
        <span class="s0">numeric_t tolerance_ = 0</span>
        <span class="s0">numeric_t diff = 0</span>

    <span class="s0"># if we are using tolerance, set our objects</span>
    <span class="s0">if tolerance is not None:</span>
        <span class="s0">has_tolerance = True</span>
        <span class="s0">tolerance_ = tolerance</span>

    <span class="s0">left_size = len(left_values)</span>
    <span class="s0">right_size = len(right_values)</span>

    <span class="s0">left_indexer = np.empty(left_size, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(left_size, dtype=np.intp)</span>

    <span class="s0">right_pos = 0</span>
    <span class="s0">for left_pos in range(left_size):</span>
        <span class="s0"># restart right_pos if it went negative in a previous iteration</span>
        <span class="s0">if right_pos &lt; 0:</span>
            <span class="s0">right_pos = 0</span>

        <span class="s0"># find last position in right whose value is less than left's</span>
        <span class="s0">if allow_exact_matches:</span>
            <span class="s0">while (right_pos &lt; right_size and</span>
                   <span class="s0">right_values[right_pos] &lt;= left_values[left_pos]):</span>
                <span class="s0">right_pos += 1</span>
        <span class="s0">else:</span>
            <span class="s0">while (right_pos &lt; right_size and</span>
                   <span class="s0">right_values[right_pos] &lt; left_values[left_pos]):</span>
                <span class="s0">right_pos += 1</span>
        <span class="s0">right_pos -= 1</span>

        <span class="s0"># save positions as the desired index</span>
        <span class="s0">left_indexer[left_pos] = left_pos</span>
        <span class="s0">right_indexer[left_pos] = right_pos</span>

        <span class="s0"># if needed, verify that tolerance is met</span>
        <span class="s0">if has_tolerance and right_pos != -1:</span>
            <span class="s0">diff = left_values[left_pos] - right_values[right_pos]</span>
            <span class="s0">if diff &gt; tolerance_:</span>
                <span class="s0">right_indexer[left_pos] = -1</span>

    <span class="s0">return left_indexer, right_indexer</span>


<span class="s0">def asof_join_forward(numeric_t[:] left_values,</span>
                      <span class="s0">numeric_t[:] right_values,</span>
                      <span class="s0">bint allow_exact_matches=True,</span>
                      <span class="s0">tolerance=None):</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t left_pos, right_pos, left_size, right_size</span>
        <span class="s0">ndarray[intp_t] left_indexer, right_indexer</span>
        <span class="s0">bint has_tolerance = False</span>
        <span class="s0">numeric_t tolerance_ = 0</span>
        <span class="s0">numeric_t diff = 0</span>

    <span class="s0"># if we are using tolerance, set our objects</span>
    <span class="s0">if tolerance is not None:</span>
        <span class="s0">has_tolerance = True</span>
        <span class="s0">tolerance_ = tolerance</span>

    <span class="s0">left_size = len(left_values)</span>
    <span class="s0">right_size = len(right_values)</span>

    <span class="s0">left_indexer = np.empty(left_size, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(left_size, dtype=np.intp)</span>

    <span class="s0">right_pos = right_size - 1</span>
    <span class="s0">for left_pos in range(left_size - 1, -1, -1):</span>
        <span class="s0"># restart right_pos if it went over in a previous iteration</span>
        <span class="s0">if right_pos == right_size:</span>
            <span class="s0">right_pos = right_size - 1</span>

        <span class="s0"># find first position in right whose value is greater than left's</span>
        <span class="s0">if allow_exact_matches:</span>
            <span class="s0">while (right_pos &gt;= 0 and</span>
                   <span class="s0">right_values[right_pos] &gt;= left_values[left_pos]):</span>
                <span class="s0">right_pos -= 1</span>
        <span class="s0">else:</span>
            <span class="s0">while (right_pos &gt;= 0 and</span>
                   <span class="s0">right_values[right_pos] &gt; left_values[left_pos]):</span>
                <span class="s0">right_pos -= 1</span>
        <span class="s0">right_pos += 1</span>

        <span class="s0"># save positions as the desired index</span>
        <span class="s0">left_indexer[left_pos] = left_pos</span>
        <span class="s0">right_indexer[left_pos] = (right_pos</span>
                                   <span class="s0">if right_pos != right_size else -1)</span>

        <span class="s0"># if needed, verify that tolerance is met</span>
        <span class="s0">if has_tolerance and right_pos != right_size:</span>
            <span class="s0">diff = right_values[right_pos] - left_values[left_pos]</span>
            <span class="s0">if diff &gt; tolerance_:</span>
                <span class="s0">right_indexer[left_pos] = -1</span>

    <span class="s0">return left_indexer, right_indexer</span>


<span class="s0">def asof_join_nearest(numeric_t[:] left_values,</span>
                      <span class="s0">numeric_t[:] right_values,</span>
                      <span class="s0">bint allow_exact_matches=True,</span>
                      <span class="s0">tolerance=None):</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t left_size, i</span>
        <span class="s0">ndarray[intp_t] left_indexer, right_indexer, bli, bri, fli, fri</span>
        <span class="s0">numeric_t bdiff, fdiff</span>

    <span class="s0">left_size = len(left_values)</span>

    <span class="s0">left_indexer = np.empty(left_size, dtype=np.intp)</span>
    <span class="s0">right_indexer = np.empty(left_size, dtype=np.intp)</span>

    <span class="s0"># search both forward and backward</span>
    <span class="s0">bli, bri = asof_join_backward(left_values, right_values,</span>
                                  <span class="s0">allow_exact_matches, tolerance)</span>
    <span class="s0">fli, fri = asof_join_forward(left_values, right_values,</span>
                                 <span class="s0">allow_exact_matches, tolerance)</span>

    <span class="s0">for i in range(len(bri)):</span>
        <span class="s0"># choose timestamp from right with smaller difference</span>
        <span class="s0">if bri[i] != -1 and fri[i] != -1:</span>
            <span class="s0">bdiff = left_values[bli[i]] - right_values[bri[i]]</span>
            <span class="s0">fdiff = right_values[fri[i]] - left_values[fli[i]]</span>
            <span class="s0">right_indexer[i] = bri[i] if bdiff &lt;= fdiff else fri[i]</span>
        <span class="s0">else:</span>
            <span class="s0">right_indexer[i] = bri[i] if bri[i] != -1 else fri[i]</span>
        <span class="s0">left_indexer[i] = bli[i]</span>

    <span class="s0">return left_indexer, right_indexer</span>
</pre>
</body>
</html>