<html>
<head>
<title>strptime.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
strptime.pyx</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Strptime-related classes and functions.</span>
<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">import calendar</span>
<span class="s0">import locale</span>
<span class="s0">import re</span>
<span class="s0">import time</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">date,</span>
    <span class="s0">tzinfo,</span>
<span class="s0">)</span>

<span class="s0">from _thread import allocate_lock as _thread_allocate_lock</span>

<span class="s0">import numpy as np</span>
<span class="s0">import pytz</span>

<span class="s0">from numpy cimport (</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.missing cimport checknull_with_nat_and_na</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">c_nat_strings as nat_strings,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">check_dts_bounds,</span>
    <span class="s0">dtstruct_to_dt64,</span>
    <span class="s0">npy_datetimestruct,</span>
<span class="s0">)</span>


<span class="s0">cdef dict _parse_code_table = {'y': 0,</span>
                               <span class="s0">'Y': 1,</span>
                               <span class="s0">'m': 2,</span>
                               <span class="s0">'B': 3,</span>
                               <span class="s0">'b': 4,</span>
                               <span class="s0">'d': 5,</span>
                               <span class="s0">'H': 6,</span>
                               <span class="s0">'I': 7,</span>
                               <span class="s0">'M': 8,</span>
                               <span class="s0">'S': 9,</span>
                               <span class="s0">'f': 10,</span>
                               <span class="s0">'A': 11,</span>
                               <span class="s0">'a': 12,</span>
                               <span class="s0">'w': 13,</span>
                               <span class="s0">'j': 14,</span>
                               <span class="s0">'U': 15,</span>
                               <span class="s0">'W': 16,</span>
                               <span class="s0">'Z': 17,</span>
                               <span class="s0">'p': 18,  # an additional key, only with I</span>
                               <span class="s0">'z': 19,</span>
                               <span class="s0">'G': 20,</span>
                               <span class="s0">'V': 21,</span>
                               <span class="s0">'u': 22}</span>


<span class="s0">def array_strptime(ndarray[object] values, object fmt, bint exact=True, errors='raise'):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Calculates the datetime structs represented by the passed array of strings</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : ndarray of string-like objects</span>
    <span class="s0">fmt : string-like regex</span>
    <span class="s0">exact : matches must be exact if True, search if False</span>
    <span class="s0">errors : string specifying error handling, {'raise', 'ignore', 'coerce'}</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t[:] iresult</span>
        <span class="s0">object[:] result_timezone</span>
        <span class="s0">int year, month, day, minute, hour, second, weekday, julian</span>
        <span class="s0">int week_of_year, week_of_year_start, parse_code, ordinal</span>
        <span class="s0">int iso_week, iso_year</span>
        <span class="s0">int64_t us, ns</span>
        <span class="s0">object val, group_key, ampm, found, timezone</span>
        <span class="s0">dict found_key</span>
        <span class="s0">bint is_raise = errors=='raise'</span>
        <span class="s0">bint is_ignore = errors=='ignore'</span>
        <span class="s0">bint is_coerce = errors=='coerce'</span>

    <span class="s0">assert is_raise or is_ignore or is_coerce</span>

    <span class="s0">if fmt is not None:</span>
        <span class="s0">if '%W' in fmt or '%U' in fmt:</span>
            <span class="s0">if '%Y' not in fmt and '%y' not in fmt:</span>
                <span class="s0">raise ValueError(&quot;Cannot use '%W' or '%U' without day and year&quot;)</span>
            <span class="s0">if '%A' not in fmt and '%a' not in fmt and '%w' not in fmt:</span>
                <span class="s0">raise ValueError(&quot;Cannot use '%W' or '%U' without day and year&quot;)</span>
        <span class="s0">elif '%Z' in fmt and '%z' in fmt:</span>
            <span class="s0">raise ValueError(&quot;Cannot parse both %Z and %z&quot;)</span>

    <span class="s0">global _TimeRE_cache, _regex_cache</span>
    <span class="s0">with _cache_lock:</span>
        <span class="s0">if _getlang() != _TimeRE_cache.locale_time.lang:</span>
            <span class="s0">_TimeRE_cache = TimeRE()</span>
            <span class="s0">_regex_cache.clear()</span>
        <span class="s0">if len(_regex_cache) &gt; _CACHE_MAX_SIZE:</span>
            <span class="s0">_regex_cache.clear()</span>
        <span class="s0">locale_time = _TimeRE_cache.locale_time</span>
        <span class="s0">format_regex = _regex_cache.get(fmt)</span>
        <span class="s0">if not format_regex:</span>
            <span class="s0">try:</span>
                <span class="s0">format_regex = _TimeRE_cache.compile(fmt)</span>
            <span class="s0"># KeyError raised when a bad format is found; can be specified as</span>
            <span class="s0"># \\, in which case it was a stray % but with a space after it</span>
            <span class="s0">except KeyError, err:</span>
                <span class="s0">bad_directive = err.args[0]</span>
                <span class="s0">if bad_directive == &quot;\\&quot;:</span>
                    <span class="s0">bad_directive = &quot;%&quot;</span>
                <span class="s0">del err</span>
                <span class="s0">raise ValueError(f&quot;'{bad_directive}' is a bad directive &quot;</span>
                                 <span class="s0">f&quot;in format '{fmt}'&quot;)</span>
            <span class="s0"># IndexError only occurs when the format string is &quot;%&quot;</span>
            <span class="s0">except IndexError:</span>
                <span class="s0">raise ValueError(f&quot;stray % in format '{fmt}'&quot;)</span>
            <span class="s0">_regex_cache[fmt] = format_regex</span>

    <span class="s0">result = np.empty(n, dtype='M8[ns]')</span>
    <span class="s0">iresult = result.view('i8')</span>
    <span class="s0">result_timezone = np.empty(n, dtype='object')</span>

    <span class="s0">dts.us = dts.ps = dts.as = 0</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if isinstance(val, str):</span>
            <span class="s0">if val in nat_strings:</span>
                <span class="s0">iresult[i] = NPY_NAT</span>
                <span class="s0">continue</span>
        <span class="s0">else:</span>
            <span class="s0">if checknull_with_nat_and_na(val):</span>
                <span class="s0">iresult[i] = NPY_NAT</span>
                <span class="s0">continue</span>
            <span class="s0">else:</span>
                <span class="s0">val = str(val)</span>

        <span class="s0"># exact matching</span>
        <span class="s0">if exact:</span>
            <span class="s0">found = format_regex.match(val)</span>
            <span class="s0">if not found:</span>
                <span class="s0">if is_coerce:</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">continue</span>
                <span class="s0">raise ValueError(f&quot;time data '{val}' does not match &quot;</span>
                                 <span class="s0">f&quot;format '{fmt}' (match)&quot;)</span>
            <span class="s0">if len(val) != found.end():</span>
                <span class="s0">if is_coerce:</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">continue</span>
                <span class="s0">raise ValueError(f&quot;unconverted data remains: {val[found.end():]}&quot;)</span>

        <span class="s0"># search</span>
        <span class="s0">else:</span>
            <span class="s0">found = format_regex.search(val)</span>
            <span class="s0">if not found:</span>
                <span class="s0">if is_coerce:</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">continue</span>
                <span class="s0">raise ValueError(f&quot;time data {repr(val)} does not match format &quot;</span>
                                 <span class="s0">f&quot;{repr(fmt)} (search)&quot;)</span>

        <span class="s0">iso_year = -1</span>
        <span class="s0">year = 1900</span>
        <span class="s0">month = day = 1</span>
        <span class="s0">hour = minute = second = ns = us = 0</span>
        <span class="s0">timezone = None</span>
        <span class="s0"># Default to -1 to signify that values not known; not critical to have,</span>
        <span class="s0"># though</span>
        <span class="s0">iso_week = week_of_year = -1</span>
        <span class="s0">week_of_year_start = -1</span>
        <span class="s0"># weekday and julian defaulted to -1 so as to signal need to calculate</span>
        <span class="s0"># values</span>
        <span class="s0">weekday = julian = -1</span>
        <span class="s0">found_dict = found.groupdict()</span>
        <span class="s0">for group_key in found_dict.iterkeys():</span>
            <span class="s0"># Directives not explicitly handled below:</span>
            <span class="s0">#   c, x, X</span>
            <span class="s0">#      handled by making out of other directives</span>
            <span class="s0">#   U, W</span>
            <span class="s0">#      worthless without day of the week</span>
            <span class="s0">parse_code = _parse_code_table[group_key]</span>

            <span class="s0">if parse_code == 0:</span>
                <span class="s0">year = int(found_dict['y'])</span>
                <span class="s0"># Open Group specification for strptime() states that a %y</span>
                <span class="s0"># value in the range of [00, 68] is in the century 2000, while</span>
                <span class="s0"># [69,99] is in the century 1900</span>
                <span class="s0">if year &lt;= 68:</span>
                    <span class="s0">year += 2000</span>
                <span class="s0">else:</span>
                    <span class="s0">year += 1900</span>
            <span class="s0">elif parse_code == 1:</span>
                <span class="s0">year = int(found_dict['Y'])</span>
            <span class="s0">elif parse_code == 2:</span>
                <span class="s0">month = int(found_dict['m'])</span>
            <span class="s0"># elif group_key == 'B':</span>
            <span class="s0">elif parse_code == 3:</span>
                <span class="s0">month = locale_time.f_month.index(found_dict['B'].lower())</span>
            <span class="s0"># elif group_key == 'b':</span>
            <span class="s0">elif parse_code == 4:</span>
                <span class="s0">month = locale_time.a_month.index(found_dict['b'].lower())</span>
            <span class="s0"># elif group_key == 'd':</span>
            <span class="s0">elif parse_code == 5:</span>
                <span class="s0">day = int(found_dict['d'])</span>
            <span class="s0"># elif group_key == 'H':</span>
            <span class="s0">elif parse_code == 6:</span>
                <span class="s0">hour = int(found_dict['H'])</span>
            <span class="s0">elif parse_code == 7:</span>
                <span class="s0">hour = int(found_dict['I'])</span>
                <span class="s0">ampm = found_dict.get('p', '').lower()</span>
                <span class="s0"># If there was no AM/PM indicator, we'll treat this like AM</span>
                <span class="s0">if ampm in ('', locale_time.am_pm[0]):</span>
                    <span class="s0"># We're in AM so the hour is correct unless we're</span>
                    <span class="s0"># looking at 12 midnight.</span>
                    <span class="s0"># 12 midnight == 12 AM == hour 0</span>
                    <span class="s0">if hour == 12:</span>
                        <span class="s0">hour = 0</span>
                <span class="s0">elif ampm == locale_time.am_pm[1]:</span>
                    <span class="s0"># We're in PM so we need to add 12 to the hour unless</span>
                    <span class="s0"># we're looking at 12 noon.</span>
                    <span class="s0"># 12 noon == 12 PM == hour 12</span>
                    <span class="s0">if hour != 12:</span>
                        <span class="s0">hour += 12</span>
            <span class="s0">elif parse_code == 8:</span>
                <span class="s0">minute = int(found_dict['M'])</span>
            <span class="s0">elif parse_code == 9:</span>
                <span class="s0">second = int(found_dict['S'])</span>
            <span class="s0">elif parse_code == 10:</span>
                <span class="s0">s = found_dict['f']</span>
                <span class="s0"># Pad to always return nanoseconds</span>
                <span class="s0">s += &quot;0&quot; * (9 - len(s))</span>
                <span class="s0">us = long(s)</span>
                <span class="s0">ns = us % 1000</span>
                <span class="s0">us = us // 1000</span>
            <span class="s0">elif parse_code == 11:</span>
                <span class="s0">weekday = locale_time.f_weekday.index(found_dict['A'].lower())</span>
            <span class="s0">elif parse_code == 12:</span>
                <span class="s0">weekday = locale_time.a_weekday.index(found_dict['a'].lower())</span>
            <span class="s0">elif parse_code == 13:</span>
                <span class="s0">weekday = int(found_dict['w'])</span>
                <span class="s0">if weekday == 0:</span>
                    <span class="s0">weekday = 6</span>
                <span class="s0">else:</span>
                    <span class="s0">weekday -= 1</span>
            <span class="s0">elif parse_code == 14:</span>
                <span class="s0">julian = int(found_dict['j'])</span>
            <span class="s0">elif parse_code == 15 or parse_code == 16:</span>
                <span class="s0">week_of_year = int(found_dict[group_key])</span>
                <span class="s0">if group_key == 'U':</span>
                    <span class="s0"># U starts week on Sunday.</span>
                    <span class="s0">week_of_year_start = 6</span>
                <span class="s0">else:</span>
                    <span class="s0"># W starts week on Monday.</span>
                    <span class="s0">week_of_year_start = 0</span>
            <span class="s0">elif parse_code == 17:</span>
                <span class="s0">timezone = pytz.timezone(found_dict['Z'])</span>
            <span class="s0">elif parse_code == 19:</span>
                <span class="s0">timezone = parse_timezone_directive(found_dict['z'])</span>
            <span class="s0">elif parse_code == 20:</span>
                <span class="s0">iso_year = int(found_dict['G'])</span>
            <span class="s0">elif parse_code == 21:</span>
                <span class="s0">iso_week = int(found_dict['V'])</span>
            <span class="s0">elif parse_code == 22:</span>
                <span class="s0">weekday = int(found_dict['u'])</span>
                <span class="s0">weekday -= 1</span>

        <span class="s0"># don't assume default values for ISO week/year</span>
        <span class="s0">if iso_year != -1:</span>
            <span class="s0">if iso_week == -1 or weekday == -1:</span>
                <span class="s0">raise ValueError(&quot;ISO year directive '%G' must be used with &quot;</span>
                                 <span class="s0">&quot;the ISO week directive '%V' and a weekday &quot;</span>
                                 <span class="s0">&quot;directive '%A', '%a', '%w', or '%u'.&quot;)</span>
            <span class="s0">if julian != -1:</span>
                <span class="s0">raise ValueError(&quot;Day of the year directive '%j' is not &quot;</span>
                                 <span class="s0">&quot;compatible with ISO year directive '%G'. &quot;</span>
                                 <span class="s0">&quot;Use '%Y' instead.&quot;)</span>
        <span class="s0">elif year != -1 and week_of_year == -1 and iso_week != -1:</span>
            <span class="s0">if weekday == -1:</span>
                <span class="s0">raise ValueError(&quot;ISO week directive '%V' must be used with &quot;</span>
                                 <span class="s0">&quot;the ISO year directive '%G' and a weekday &quot;</span>
                                 <span class="s0">&quot;directive '%A', '%a', '%w', or '%u'.&quot;)</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(&quot;ISO week directive '%V' is incompatible with &quot;</span>
                                 <span class="s0">&quot;the year directive '%Y'. Use the ISO year &quot;</span>
                                 <span class="s0">&quot;'%G' instead.&quot;)</span>

        <span class="s0"># If we know the wk of the year and what day of that wk, we can figure</span>
        <span class="s0"># out the Julian day of the year.</span>
        <span class="s0">if julian == -1 and weekday != -1:</span>
            <span class="s0">if week_of_year != -1:</span>
                <span class="s0">week_starts_Mon = week_of_year_start == 0</span>
                <span class="s0">julian = _calc_julian_from_U_or_W(year, week_of_year, weekday,</span>
                                                  <span class="s0">week_starts_Mon)</span>
            <span class="s0">elif iso_year != -1 and iso_week != -1:</span>
                <span class="s0">year, julian = _calc_julian_from_V(iso_year, iso_week,</span>
                                                   <span class="s0">weekday + 1)</span>
        <span class="s0"># Cannot pre-calculate date() since can change in Julian</span>
        <span class="s0"># calculation and thus could have different value for the day of the wk</span>
        <span class="s0"># calculation.</span>
        <span class="s0">try:</span>
            <span class="s0">if julian == -1:</span>
                <span class="s0"># Need to add 1 to result since first day of the year is 1, not</span>
                <span class="s0"># 0.</span>
                <span class="s0">ordinal = date(year, month, day).toordinal()</span>
                <span class="s0">julian = ordinal - date(year, 1, 1).toordinal() + 1</span>
            <span class="s0">else:</span>
                <span class="s0"># Assume that if they bothered to include Julian day it will</span>
                <span class="s0"># be accurate.</span>
                <span class="s0">datetime_result = date.fromordinal(</span>
                    <span class="s0">(julian - 1) + date(year, 1, 1).toordinal())</span>
                <span class="s0">year = datetime_result.year</span>
                <span class="s0">month = datetime_result.month</span>
                <span class="s0">day = datetime_result.day</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">if is_coerce:</span>
                <span class="s0">iresult[i] = NPY_NAT</span>
                <span class="s0">continue</span>
            <span class="s0">raise</span>
        <span class="s0">if weekday == -1:</span>
            <span class="s0">weekday = date(year, month, day).weekday()</span>

        <span class="s0">dts.year = year</span>
        <span class="s0">dts.month = month</span>
        <span class="s0">dts.day = day</span>
        <span class="s0">dts.hour = hour</span>
        <span class="s0">dts.min = minute</span>
        <span class="s0">dts.sec = second</span>
        <span class="s0">dts.us = us</span>
        <span class="s0">dts.ps = ns * 1000</span>

        <span class="s0">iresult[i] = dtstruct_to_dt64(&amp;dts)</span>
        <span class="s0">try:</span>
            <span class="s0">check_dts_bounds(&amp;dts)</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">if is_coerce:</span>
                <span class="s0">iresult[i] = NPY_NAT</span>
                <span class="s0">continue</span>
            <span class="s0">raise</span>

        <span class="s0">result_timezone[i] = timezone</span>

    <span class="s0">return result, result_timezone.base</span>


<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">_getlang, LocaleTime, TimeRE, _calc_julian_from_U_or_W are vendored</span>
<span class="s0">from the standard library, see</span>
<span class="s0">https://github.com/python/cpython/blob/master/Lib/_strptime.py</span>
<span class="s0">The original module-level docstring follows.</span>

<span class="s0">Strptime-related classes and functions.</span>
<span class="s0">CLASSES:</span>
    <span class="s0">LocaleTime -- Discovers and stores locale-specific time information</span>
    <span class="s0">TimeRE -- Creates regexes for pattern matching a string of text containing</span>
                <span class="s0">time information</span>
<span class="s0">FUNCTIONS:</span>
    <span class="s0">_getlang -- Figure out what language is being used for the locale</span>
    <span class="s0">strptime -- Calculates the time struct represented by the passed-in string</span>
<span class="s0">&quot;&quot;&quot;</span>


<span class="s0">def _getlang():</span>
    <span class="s0">&quot;&quot;&quot;Figure out what language is being used for the locale&quot;&quot;&quot;</span>
    <span class="s0">return locale.getlocale(locale.LC_TIME)</span>


<span class="s0">class LocaleTime:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Stores and handles locale-specific information related to time.</span>

    <span class="s0">ATTRIBUTES:</span>
        <span class="s0">f_weekday -- full weekday names (7-item list)</span>
        <span class="s0">a_weekday -- abbreviated weekday names (7-item list)</span>
        <span class="s0">f_month -- full month names (13-item list; dummy value in [0], which</span>
                    <span class="s0">is added by code)</span>
        <span class="s0">a_month -- abbreviated month names (13-item list, dummy value in</span>
                    <span class="s0">[0], which is added by code)</span>
        <span class="s0">am_pm -- AM/PM representation (2-item list)</span>
        <span class="s0">LC_date_time -- format string for date/time representation (string)</span>
        <span class="s0">LC_date -- format string for date representation (string)</span>
        <span class="s0">LC_time -- format string for time representation (string)</span>
        <span class="s0">timezone -- daylight- and non-daylight-savings timezone representation</span>
                    <span class="s0">(2-item list of sets)</span>
        <span class="s0">lang -- Language used by instance (2-item tuple)</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def __init__(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Set all attributes.</span>

        <span class="s0">Order of methods called matters for dependency reasons.</span>

        <span class="s0">The locale language is set at the offset and then checked again before</span>
        <span class="s0">exiting.  This is to make sure that the attributes were not set with a</span>
        <span class="s0">mix of information from more than one locale.  This would most likely</span>
        <span class="s0">happen when using threads where one thread calls a locale-dependent</span>
        <span class="s0">function while another thread changes the locale while the function in</span>
        <span class="s0">the other thread is still running.  Proper coding would call for</span>
        <span class="s0">locks to prevent changing the locale while locale-dependent code is</span>
        <span class="s0">running.  The check here is done in case someone does not think about</span>
        <span class="s0">doing this.</span>

        <span class="s0">Only other possible issue is if someone changed the timezone and did</span>
        <span class="s0">not call tz.tzset .  That is an issue for the programmer, though,</span>
        <span class="s0">since changing the timezone is worthless without that call.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self.lang = _getlang()</span>
        <span class="s0">self.__calc_weekday()</span>
        <span class="s0">self.__calc_month()</span>
        <span class="s0">self.__calc_am_pm()</span>
        <span class="s0">self.__calc_timezone()</span>
        <span class="s0">self.__calc_date_time()</span>
        <span class="s0">if _getlang() != self.lang:</span>
            <span class="s0">raise ValueError(&quot;locale changed during initialization&quot;)</span>

    <span class="s0">def __pad(self, seq, front):</span>
        <span class="s0"># Add '' to seq to either the front (is True), else the back.</span>
        <span class="s0">seq = list(seq)</span>
        <span class="s0">if front:</span>
            <span class="s0">seq.insert(0, '')</span>
        <span class="s0">else:</span>
            <span class="s0">seq.append('')</span>
        <span class="s0">return seq</span>

    <span class="s0">def __calc_weekday(self):</span>
        <span class="s0"># Set self.a_weekday and self.f_weekday using the calendar</span>
        <span class="s0"># module.</span>
        <span class="s0">a_weekday = [calendar.day_abbr[i].lower() for i in range(7)]</span>
        <span class="s0">f_weekday = [calendar.day_name[i].lower() for i in range(7)]</span>
        <span class="s0">self.a_weekday = a_weekday</span>
        <span class="s0">self.f_weekday = f_weekday</span>

    <span class="s0">def __calc_month(self):</span>
        <span class="s0"># Set self.f_month and self.a_month using the calendar module.</span>
        <span class="s0">a_month = [calendar.month_abbr[i].lower() for i in range(13)]</span>
        <span class="s0">f_month = [calendar.month_name[i].lower() for i in range(13)]</span>
        <span class="s0">self.a_month = a_month</span>
        <span class="s0">self.f_month = f_month</span>

    <span class="s0">def __calc_am_pm(self):</span>
        <span class="s0"># Set self.am_pm by using time.strftime().</span>

        <span class="s0"># The magic date (1999,3,17,hour,44,55,2,76,0) is not really that</span>
        <span class="s0"># magical; just happened to have used it everywhere else where a</span>
        <span class="s0"># static date was needed.</span>
        <span class="s0">am_pm = []</span>
        <span class="s0">for hour in (01, 22):</span>
            <span class="s0">time_tuple = time.struct_time(</span>
                <span class="s0">(1999, 3, 17, hour, 44, 55, 2, 76, 0))</span>
            <span class="s0">am_pm.append(time.strftime(&quot;%p&quot;, time_tuple).lower())</span>
        <span class="s0">self.am_pm = am_pm</span>

    <span class="s0">def __calc_date_time(self):</span>
        <span class="s0"># Set self.date_time, self.date, &amp; self.time by using</span>
        <span class="s0"># time.strftime().</span>

        <span class="s0"># Use (1999,3,17,22,44,55,2,76,0) for magic date because the amount of</span>
        <span class="s0"># overloaded numbers is minimized.  The order in which searches for</span>
        <span class="s0"># values within the format string is very important; it eliminates</span>
        <span class="s0"># possible ambiguity for what something represents.</span>
        <span class="s0">time_tuple = time.struct_time((1999, 3, 17, 22, 44, 55, 2, 76, 0))</span>
        <span class="s0">date_time = [None, None, None]</span>
        <span class="s0">date_time[0] = time.strftime(&quot;%c&quot;, time_tuple).lower()</span>
        <span class="s0">date_time[1] = time.strftime(&quot;%x&quot;, time_tuple).lower()</span>
        <span class="s0">date_time[2] = time.strftime(&quot;%X&quot;, time_tuple).lower()</span>
        <span class="s0">replacement_pairs = [('%', '%%'), (self.f_weekday[2], '%A'),</span>
                             <span class="s0">(self.f_month[3], '%B'),</span>
                             <span class="s0">(self.a_weekday[2], '%a'),</span>
                             <span class="s0">(self.a_month[3], '%b'), (self.am_pm[1], '%p'),</span>
                             <span class="s0">('1999', '%Y'), ('99', '%y'), ('22', '%H'),</span>
                             <span class="s0">('44', '%M'), ('55', '%S'), ('76', '%j'),</span>
                             <span class="s0">('17', '%d'), ('03', '%m'), ('3', '%m'),</span>
                             <span class="s0"># '3' needed for when no leading zero.</span>
                             <span class="s0">('2', '%w'), ('10', '%I')]</span>
        <span class="s0">replacement_pairs.extend([(tz, &quot;%Z&quot;) for tz_values in self.timezone</span>
                                  <span class="s0">for tz in tz_values])</span>
        <span class="s0">for offset, directive in ((0, '%c'), (1, '%x'), (2, '%X')):</span>
            <span class="s0">current_format = date_time[offset]</span>
            <span class="s0">for old, new in replacement_pairs:</span>
                <span class="s0"># Must deal with possible lack of locale info</span>
                <span class="s0"># manifesting itself as the empty string (e.g., Swedish's</span>
                <span class="s0"># lack of AM/PM info) or a platform returning a tuple of empty</span>
                <span class="s0"># strings (e.g., MacOS 9 having timezone as ('','')).</span>
                <span class="s0">if old:</span>
                    <span class="s0">current_format = current_format.replace(old, new)</span>
            <span class="s0"># If %W is used, then Sunday, 2005-01-03 will fall on week 0 since</span>
            <span class="s0"># 2005-01-03 occurs before the first Monday of the year.  Otherwise</span>
            <span class="s0"># %U is used.</span>
            <span class="s0">time_tuple = time.struct_time((1999, 1, 3, 1, 1, 1, 6, 3, 0))</span>
            <span class="s0">if '00' in time.strftime(directive, time_tuple):</span>
                <span class="s0">U_W = '%W'</span>
            <span class="s0">else:</span>
                <span class="s0">U_W = '%U'</span>
            <span class="s0">date_time[offset] = current_format.replace('11', U_W)</span>
        <span class="s0">self.LC_date_time = date_time[0]</span>
        <span class="s0">self.LC_date = date_time[1]</span>
        <span class="s0">self.LC_time = date_time[2]</span>

    <span class="s0">def __calc_timezone(self):</span>
        <span class="s0"># Set self.timezone by using time.tzname.</span>
        <span class="s0"># Do not worry about possibility of time.tzname[0] == timetzname[1]</span>
        <span class="s0"># and time.daylight; handle that in strptime .</span>
        <span class="s0">try:</span>
            <span class="s0">time.tzset()</span>
        <span class="s0">except AttributeError:</span>
            <span class="s0">pass</span>
        <span class="s0">no_saving = frozenset([&quot;utc&quot;, &quot;gmt&quot;, time.tzname[0].lower()])</span>
        <span class="s0">if time.daylight:</span>
            <span class="s0">has_saving = frozenset([time.tzname[1].lower()])</span>
        <span class="s0">else:</span>
            <span class="s0">has_saving = frozenset()</span>
        <span class="s0">self.timezone = (no_saving, has_saving)</span>


<span class="s0">class TimeRE(dict):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Handle conversion from format directives to regexes.</span>

    <span class="s0">Creates regexes for pattern matching a string of text containing</span>
    <span class="s0">time information</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def __init__(self, locale_time=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Create keys/values.</span>

        <span class="s0">Order of execution is important for dependency reasons.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if locale_time:</span>
            <span class="s0">self.locale_time = locale_time</span>
        <span class="s0">else:</span>
            <span class="s0">self.locale_time = LocaleTime()</span>
        <span class="s0">self._Z = None</span>
        <span class="s0">base = super()</span>
        <span class="s0">base.__init__({</span>
            <span class="s0"># The &quot; \d&quot; part of the regex is to make %c from ANSI C work</span>
            <span class="s0">'d': r&quot;(?P&lt;d&gt;3[0-1]|[1-2]\d|0[1-9]|[1-9]| [1-9])&quot;,</span>
            <span class="s0">'f': r&quot;(?P&lt;f&gt;[0-9]{1,9})&quot;,</span>
            <span class="s0">'G': r&quot;(?P&lt;G&gt;\d\d\d\d)&quot;,</span>
            <span class="s0">'H': r&quot;(?P&lt;H&gt;2[0-3]|[0-1]\d|\d)&quot;,</span>
            <span class="s0">'I': r&quot;(?P&lt;I&gt;1[0-2]|0[1-9]|[1-9])&quot;,</span>
            <span class="s0">'j': (r&quot;(?P&lt;j&gt;36[0-6]|3[0-5]\d|[1-2]\d\d|0[1-9]\d|00[1-9]|&quot;</span>
                  <span class="s0">r&quot;[1-9]\d|0[1-9]|[1-9])&quot;),</span>
            <span class="s0">'m': r&quot;(?P&lt;m&gt;1[0-2]|0[1-9]|[1-9])&quot;,</span>
            <span class="s0">'M': r&quot;(?P&lt;M&gt;[0-5]\d|\d)&quot;,</span>
            <span class="s0">'S': r&quot;(?P&lt;S&gt;6[0-1]|[0-5]\d|\d)&quot;,</span>
            <span class="s0">'u': r&quot;(?P&lt;u&gt;[1-7])&quot;,</span>
            <span class="s0">'U': r&quot;(?P&lt;U&gt;5[0-3]|[0-4]\d|\d)&quot;,</span>
            <span class="s0">'V': r&quot;(?P&lt;V&gt;5[0-3]|0[1-9]|[1-4]\d|\d)&quot;,</span>
            <span class="s0">'w': r&quot;(?P&lt;w&gt;[0-6])&quot;,</span>
            <span class="s0"># W is set below by using 'U'</span>
            <span class="s0">'y': r&quot;(?P&lt;y&gt;\d\d)&quot;,</span>
            <span class="s0"># TODO: Does 'Y' need to worry about having less or more than</span>
            <span class="s0">#     4 digits?</span>
            <span class="s0">'Y': r&quot;(?P&lt;Y&gt;\d\d\d\d)&quot;,</span>
            <span class="s0">'z': r&quot;(?P&lt;z&gt;[+-]\d\d:?[0-5]\d(:?[0-5]\d(\.\d{1,6})?)?|Z)&quot;,</span>
            <span class="s0">'A': self.__seqToRE(self.locale_time.f_weekday, 'A'),</span>
            <span class="s0">'a': self.__seqToRE(self.locale_time.a_weekday, 'a'),</span>
            <span class="s0">'B': self.__seqToRE(self.locale_time.f_month[1:], 'B'),</span>
            <span class="s0">'b': self.__seqToRE(self.locale_time.a_month[1:], 'b'),</span>
            <span class="s0">'p': self.__seqToRE(self.locale_time.am_pm, 'p'),</span>
            <span class="s0"># 'Z' key is generated lazily via __getitem__</span>
            <span class="s0">'%': '%'})</span>
        <span class="s0">base.__setitem__('W', base.__getitem__('U').replace('U', 'W'))</span>
        <span class="s0">base.__setitem__('c', self.pattern(self.locale_time.LC_date_time))</span>
        <span class="s0">base.__setitem__('x', self.pattern(self.locale_time.LC_date))</span>
        <span class="s0">base.__setitem__('X', self.pattern(self.locale_time.LC_time))</span>

    <span class="s0">def __getitem__(self, key):</span>
        <span class="s0">if key == &quot;Z&quot;:</span>
            <span class="s0"># lazy computation</span>
            <span class="s0">if self._Z is None:</span>
                <span class="s0">self._Z = self.__seqToRE(pytz.all_timezones, 'Z')</span>
            <span class="s0">return self._Z</span>
        <span class="s0">return super().__getitem__(key)</span>

    <span class="s0">def __seqToRE(self, to_convert, directive):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert a list to a regex string for matching a directive.</span>

        <span class="s0">Want possible matching values to be from longest to shortest.  This</span>
        <span class="s0">prevents the possibility of a match occurring for a value that also</span>
        <span class="s0">a substring of a larger value that should have matched (e.g., 'abc'</span>
        <span class="s0">matching when 'abcdef' should have been the match).</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">to_convert = sorted(to_convert, key=len, reverse=True)</span>
        <span class="s0">for value in to_convert:</span>
            <span class="s0">if value != '':</span>
                <span class="s0">break</span>
        <span class="s0">else:</span>
            <span class="s0">return ''</span>
        <span class="s0">regex = '|'.join(re.escape(stuff) for stuff in to_convert)</span>
        <span class="s0">regex = f&quot;(?P&lt;{directive}&gt;{regex})&quot;</span>
        <span class="s0">return regex</span>

    <span class="s0">def pattern(self, format):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return regex pattern for the format string.</span>

        <span class="s0">Need to make sure that any characters that might be interpreted as</span>
        <span class="s0">regex syntax are escaped.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">processed_format = ''</span>
        <span class="s0"># The sub() call escapes all characters that might be misconstrued</span>
        <span class="s0"># as regex syntax.  Cannot use re.escape since we have to deal with</span>
        <span class="s0"># format directives (%m, etc.).</span>
        <span class="s0">regex_chars = re.compile(r&quot;([\\.^$*+?\(\){}\[\]|])&quot;)</span>
        <span class="s0">format = regex_chars.sub(r&quot;\\\1&quot;, format)</span>
        <span class="s0">whitespace_replacement = re.compile(r'\s+')</span>
        <span class="s0">format = whitespace_replacement.sub(r'\\s+', format)</span>
        <span class="s0">while '%' in format:</span>
            <span class="s0">directive_index = format.index('%') +1</span>
            <span class="s0">processed_format = (f&quot;{processed_format}&quot;</span>
                                <span class="s0">f&quot;{format[:directive_index -1]}&quot;</span>
                                <span class="s0">f&quot;{self[format[directive_index]]}&quot;)</span>
            <span class="s0">format = format[directive_index +1:]</span>
        <span class="s0">return f&quot;{processed_format}{format}&quot;</span>

    <span class="s0">def compile(self, format):</span>
        <span class="s0">&quot;&quot;&quot;Return a compiled re object for the format string.&quot;&quot;&quot;</span>
        <span class="s0">return re.compile(self.pattern(format), re.IGNORECASE)</span>


<span class="s0">_cache_lock = _thread_allocate_lock()</span>
<span class="s0"># DO NOT modify _TimeRE_cache or _regex_cache without acquiring the cache lock</span>
<span class="s0"># first!</span>
<span class="s0">_TimeRE_cache = TimeRE()</span>
<span class="s0">_CACHE_MAX_SIZE = 5  # Max number of regexes stored in _regex_cache</span>
<span class="s0">_regex_cache = {}</span>


<span class="s0">cdef int _calc_julian_from_U_or_W(int year, int week_of_year,</span>
                                  <span class="s0">int day_of_week, int week_starts_Mon):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Calculate the Julian day based on the year, week of the year, and day of</span>
    <span class="s0">the week, with week_start_day representing whether the week of the year</span>
    <span class="s0">assumes the week starts on Sunday or Monday (6 or 0).</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">year : int</span>
        <span class="s0">the year</span>
    <span class="s0">week_of_year : int</span>
        <span class="s0">week taken from format U or W</span>
    <span class="s0">week_starts_Mon : int</span>
        <span class="s0">represents whether the week of the year</span>
        <span class="s0">assumes the week starts on Sunday or Monday (6 or 0)</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">int</span>
        <span class="s0">converted julian day</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">int first_weekday, week_0_length, days_to_week</span>

    <span class="s0">first_weekday = date(year, 1, 1).weekday()</span>
    <span class="s0"># If we are dealing with the %U directive (week starts on Sunday), it's</span>
    <span class="s0"># easier to just shift the view to Sunday being the first day of the</span>
    <span class="s0"># week.</span>
    <span class="s0">if not week_starts_Mon:</span>
        <span class="s0">first_weekday = (first_weekday + 1) % 7</span>
        <span class="s0">day_of_week = (day_of_week + 1) % 7</span>

    <span class="s0"># Need to watch out for a week 0 (when the first day of the year is not</span>
    <span class="s0"># the same as that specified by %U or %W).</span>
    <span class="s0">week_0_length = (7 - first_weekday) % 7</span>
    <span class="s0">if week_of_year == 0:</span>
        <span class="s0">return 1 + day_of_week - first_weekday</span>
    <span class="s0">else:</span>
        <span class="s0">days_to_week = week_0_length + (7 * (week_of_year - 1))</span>
        <span class="s0">return 1 + days_to_week + day_of_week</span>


<span class="s0">cdef (int, int) _calc_julian_from_V(int iso_year, int iso_week, int iso_weekday):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Calculate the Julian day based on the ISO 8601 year, week, and weekday.</span>

    <span class="s0">ISO weeks start on Mondays, with week 01 being the week containing 4 Jan.</span>
    <span class="s0">ISO week days range from 1 (Monday) to 7 (Sunday).</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">iso_year : int</span>
        <span class="s0">the year taken from format %G</span>
    <span class="s0">iso_week : int</span>
        <span class="s0">the week taken from format %V</span>
    <span class="s0">iso_weekday : int</span>
        <span class="s0">weekday taken from format %u</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">(int, int)</span>
        <span class="s0">the iso year and the Gregorian ordinal date / julian date</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">int correction, ordinal</span>

    <span class="s0">correction = date(iso_year, 1, 4).isoweekday() + 3</span>
    <span class="s0">ordinal = (iso_week * 7) + iso_weekday - correction</span>
    <span class="s0"># ordinal may be negative or 0 now, which means the date is in the previous</span>
    <span class="s0"># calendar year</span>
    <span class="s0">if ordinal &lt; 1:</span>
        <span class="s0">ordinal += date(iso_year, 1, 1).toordinal()</span>
        <span class="s0">iso_year -= 1</span>
        <span class="s0">ordinal -= date(iso_year, 1, 1).toordinal()</span>
    <span class="s0">return iso_year, ordinal</span>


<span class="s0">cdef tzinfo parse_timezone_directive(str z):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parse the '%z' directive and return a pytz.FixedOffset</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">z : string of the UTC offset</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">pytz.FixedOffset</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This is essentially similar to the cpython implementation</span>
    <span class="s0">https://github.com/python/cpython/blob/master/Lib/_strptime.py#L457-L479</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">int gmtoff_fraction, hours, minutes, seconds, pad_number, microseconds</span>
        <span class="s0">int total_minutes</span>
        <span class="s0">object gmtoff_remainder, gmtoff_remainder_padding</span>

    <span class="s0">if z == 'Z':</span>
        <span class="s0">return pytz.FixedOffset(0)</span>
    <span class="s0">if z[3] == ':':</span>
        <span class="s0">z = z[:3] + z[4:]</span>
        <span class="s0">if len(z) &gt; 5:</span>
            <span class="s0">if z[5] != ':':</span>
                <span class="s0">raise ValueError(f&quot;Inconsistent use of : in {z}&quot;)</span>
            <span class="s0">z = z[:5] + z[6:]</span>
    <span class="s0">hours = int(z[1:3])</span>
    <span class="s0">minutes = int(z[3:5])</span>
    <span class="s0">seconds = int(z[5:7] or 0)</span>

    <span class="s0"># Pad to always return microseconds.</span>
    <span class="s0">gmtoff_remainder = z[8:]</span>
    <span class="s0">pad_number = 6 - len(gmtoff_remainder)</span>
    <span class="s0">gmtoff_remainder_padding = &quot;0&quot; * pad_number</span>
    <span class="s0">microseconds = int(gmtoff_remainder + gmtoff_remainder_padding)</span>

    <span class="s0">total_minutes = ((hours * 60) + minutes + (seconds // 60) +</span>
                     <span class="s0">(microseconds // 60_000_000))</span>
    <span class="s0">total_minutes = -total_minutes if z.startswith(&quot;-&quot;) else total_minutes</span>
    <span class="s0">return pytz.FixedOffset(total_minutes)</span>
</pre>
</body>
</html>