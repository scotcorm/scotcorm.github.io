<html>
<head>
<title>request.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
request.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>

<span class="s0">from </span><span class="s1">.._internal </span><span class="s0">import </span><span class="s1">_wsgi_decoding_dance</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">CombinedMultiDict</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">EnvironHeaders</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">FileStorage</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">ImmutableMultiDict</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">iter_multi_items</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">MultiDict</span>
<span class="s0">from </span><span class="s1">..formparser </span><span class="s0">import </span><span class="s1">default_stream_factory</span>
<span class="s0">from </span><span class="s1">..formparser </span><span class="s0">import </span><span class="s1">FormDataParser</span>
<span class="s0">from </span><span class="s1">..sansio.request </span><span class="s0">import </span><span class="s1">Request </span><span class="s0">as </span><span class="s1">_SansIORequest</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">environ_property</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">_get_server</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_input_stream</span>
<span class="s0">from </span><span class="s1">werkzeug.exceptions </span><span class="s0">import </span><span class="s1">BadRequest</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">import </span><span class="s1">typing_extensions </span><span class="s0">as </span><span class="s1">te</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIApplication</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIEnvironment</span>


<span class="s0">class </span><span class="s1">Request(_SansIORequest):</span>
    <span class="s2">&quot;&quot;&quot;Represents an incoming WSGI HTTP request, with headers and body 
    taken from the WSGI environment. Has properties and methods for 
    using the functionality defined by various HTTP specs. The data in 
    requests object is read-only. 
 
    Text data is assumed to use UTF-8 encoding, which should be true for 
    the vast majority of modern clients. Using an encoding set by the 
    client is unsafe in Python due to extra encodings it provides, such 
    as ``zip``. To change the assumed encoding, subclass and replace 
    :attr:`charset`. 
 
    :param environ: The WSGI environ is generated by the WSGI server and 
        contains information about the server configuration and client 
        request. 
    :param populate_request: Add this request object to the WSGI environ 
        as ``environ['werkzeug.request']``. Can be useful when 
        debugging. 
    :param shallow: Makes reading from :attr:`stream` (and any method 
        that would read from it) raise a :exc:`RuntimeError`. Useful to 
        prevent consuming the form data in middleware, which would make 
        it unavailable to the final application. 
 
    .. versionchanged:: 2.0 
        Combine ``BaseRequest`` and mixins into a single ``Request`` 
        class. Using the old classes is deprecated and will be removed 
        in Werkzeug 2.1. 
 
    .. versionchanged:: 0.5 
        Read-only mode is enforced with immutable classes for all data. 
    &quot;&quot;&quot;</span>

    <span class="s3">#: the maximum content length.  This is forwarded to the form data</span>
    <span class="s3">#: parsing function (:func:`parse_form_data`).  When set and the</span>
    <span class="s3">#: :attr:`form` or :attr:`files` attribute is accessed and the</span>
    <span class="s3">#: parsing fails because more than the specified value is transmitted</span>
    <span class="s3">#: a :exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception is raised.</span>
    <span class="s3">#:</span>
    <span class="s3">#: Have a look at :doc:`/request_data` for more details.</span>
    <span class="s3">#:</span>
    <span class="s3">#: .. versionadded:: 0.5</span>
    <span class="s1">max_content_length: t.Optional[int] = </span><span class="s0">None</span>

    <span class="s3">#: the maximum form field size.  This is forwarded to the form data</span>
    <span class="s3">#: parsing function (:func:`parse_form_data`).  When set and the</span>
    <span class="s3">#: :attr:`form` or :attr:`files` attribute is accessed and the</span>
    <span class="s3">#: data in memory for post data is longer than the specified value a</span>
    <span class="s3">#: :exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception is raised.</span>
    <span class="s3">#:</span>
    <span class="s3">#: Have a look at :doc:`/request_data` for more details.</span>
    <span class="s3">#:</span>
    <span class="s3">#: .. versionadded:: 0.5</span>
    <span class="s1">max_form_memory_size: t.Optional[int] = </span><span class="s0">None</span>

    <span class="s3">#: The form data parser that shoud be used.  Can be replaced to customize</span>
    <span class="s3">#: the form date parsing.</span>
    <span class="s1">form_data_parser_class: t.Type[FormDataParser] = FormDataParser</span>

    <span class="s3">#: Disable the :attr:`data` property to avoid reading from the input</span>
    <span class="s3">#: stream.</span>
    <span class="s3">#:</span>
    <span class="s3">#: .. deprecated:: 2.0</span>
    <span class="s3">#:     Will be removed in Werkzeug 2.1. Create the request with</span>
    <span class="s3">#:     ``shallow=True`` instead.</span>
    <span class="s3">#:</span>
    <span class="s3">#: .. versionadded:: 0.9</span>
    <span class="s1">disable_data_descriptor: t.Optional[bool] = </span><span class="s0">None</span>

    <span class="s3">#: The WSGI environment containing HTTP headers and information from</span>
    <span class="s3">#: the WSGI server.</span>
    <span class="s1">environ: </span><span class="s4">&quot;WSGIEnvironment&quot;</span>

    <span class="s3">#: Set when creating the request object. If ``True``, reading from</span>
    <span class="s3">#: the request body will cause a ``RuntimeException``. Useful to</span>
    <span class="s3">#: prevent modifying the stream from middleware.</span>
    <span class="s1">shallow: bool</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">environ: </span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s0">,</span>
        <span class="s1">populate_request: bool = </span><span class="s0">True,</span>
        <span class="s1">shallow: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">method=environ.get(</span><span class="s4">&quot;REQUEST_METHOD&quot;</span><span class="s0">, </span><span class="s4">&quot;GET&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">scheme=environ.get(</span><span class="s4">&quot;wsgi.url_scheme&quot;</span><span class="s0">, </span><span class="s4">&quot;http&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">server=_get_server(environ)</span><span class="s0">,</span>
            <span class="s1">root_path=_wsgi_decoding_dance(</span>
                <span class="s1">environ.get(</span><span class="s4">&quot;SCRIPT_NAME&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s1">self.charset</span><span class="s0">, </span><span class="s1">self.encoding_errors</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">path=_wsgi_decoding_dance(</span>
                <span class="s1">environ.get(</span><span class="s4">&quot;PATH_INFO&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s1">self.charset</span><span class="s0">, </span><span class="s1">self.encoding_errors</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">query_string=environ.get(</span><span class="s4">&quot;QUERY_STRING&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">).encode(</span><span class="s4">&quot;latin1&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">headers=EnvironHeaders(environ)</span><span class="s0">,</span>
            <span class="s1">remote_addr=environ.get(</span><span class="s4">&quot;REMOTE_ADDR&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self.environ = environ</span>

        <span class="s0">if </span><span class="s1">self.disable_data_descriptor </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;'disable_data_descriptor' is deprecated and will be&quot;</span>
                <span class="s4">&quot; removed in Werkzeug 2.1. Create the request with&quot;</span>
                <span class="s4">&quot; 'shallow=True' instead.&quot;</span><span class="s0">,</span>
                <span class="s1">DeprecationWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">shallow = shallow </span><span class="s0">or </span><span class="s1">self.disable_data_descriptor</span>

        <span class="s1">self.shallow = shallow</span>

        <span class="s0">if </span><span class="s1">populate_request </span><span class="s0">and not </span><span class="s1">shallow:</span>
            <span class="s1">self.environ[</span><span class="s4">&quot;werkzeug.request&quot;</span><span class="s1">] = self</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_values(cls</span><span class="s0">, </span><span class="s1">*args: t.Any</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s4">&quot;Request&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Create a new request object based on the values provided.  If 
        environ is given missing values are filled from there.  This method is 
        useful for small scripts when you need to simulate a request from an URL. 
        Do not use this method for unittesting, there is a full featured client 
        object (:class:`Client`) that allows to create multipart requests, 
        support for cookies etc. 
 
        This accepts the same options as the 
        :class:`~werkzeug.test.EnvironBuilder`. 
 
        .. versionchanged:: 0.5 
           This method now accepts the same arguments as 
           :class:`~werkzeug.test.EnvironBuilder`.  Because of this the 
           `environ` parameter is now called `environ_overrides`. 
 
        :return: request object 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">..test </span><span class="s0">import </span><span class="s1">EnvironBuilder</span>

        <span class="s1">charset = kwargs.pop(</span><span class="s4">&quot;charset&quot;</span><span class="s0">, </span><span class="s1">cls.charset)</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;charset&quot;</span><span class="s1">] = charset</span>
        <span class="s1">builder = EnvironBuilder(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">builder.get_request(cls)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">builder.close()</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">application(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">f: t.Callable[[</span><span class="s4">&quot;Request&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;WSGIApplication&quot;</span><span class="s1">]</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;WSGIApplication&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Decorate a function as responder that accepts the request as 
        the last argument.  This works like the :func:`responder` 
        decorator but the function is passed the request object as the 
        last argument and the request object will be closed 
        automatically:: 
 
            @Request.application 
            def my_wsgi_app(request): 
                return Response('Hello World!') 
 
        As of Werkzeug 0.14 HTTP exceptions are automatically caught and 
        converted to responses instead of failing. 
 
        :param f: the WSGI callable to decorate 
        :return: a new WSGI callable 
        &quot;&quot;&quot;</span>
        <span class="s3">#: return a callable that wraps the -2nd argument with the request</span>
        <span class="s3">#: and calls the function with all the arguments up to that one and</span>
        <span class="s3">#: the request.  The return value is then called with the latest</span>
        <span class="s3">#: two arguments.  This makes it possible to use this decorator for</span>
        <span class="s3">#: both standalone WSGI functions as well as bound methods and</span>
        <span class="s3">#: partially applied functions.</span>
        <span class="s0">from </span><span class="s1">..exceptions </span><span class="s0">import </span><span class="s1">HTTPException</span>

        <span class="s1">@functools.wraps(f)</span>
        <span class="s0">def </span><span class="s1">application(*args):  </span><span class="s3"># type: ignore</span>
            <span class="s1">request = cls(args[-</span><span class="s5">2</span><span class="s1">])</span>
            <span class="s0">with </span><span class="s1">request:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">resp = f(*args[:-</span><span class="s5">2</span><span class="s1">] + (request</span><span class="s0">,</span><span class="s1">))</span>
                <span class="s0">except </span><span class="s1">HTTPException </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s1">resp = e.get_response(args[-</span><span class="s5">2</span><span class="s1">])</span>
                <span class="s0">return </span><span class="s1">resp(*args[-</span><span class="s5">2</span><span class="s1">:])</span>

        <span class="s0">return </span><span class="s1">t.cast(</span><span class="s4">&quot;WSGIApplication&quot;</span><span class="s0">, </span><span class="s1">application)</span>

    <span class="s0">def </span><span class="s1">_get_file_stream(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">total_content_length: t.Optional[int]</span><span class="s0">,</span>
        <span class="s1">content_type: t.Optional[str]</span><span class="s0">,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">content_length: t.Optional[int] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; t.IO[bytes]:</span>
        <span class="s2">&quot;&quot;&quot;Called to get a stream for the file upload. 
 
        This must provide a file-like class with `read()`, `readline()` 
        and `seek()` methods that is both writeable and readable. 
 
        The default implementation returns a temporary file if the total 
        content length is higher than 500KB.  Because many browsers do not 
        provide a content length for the files only the total content 
        length matters. 
 
        :param total_content_length: the total content length of all the 
                                     data in the request combined.  This value 
                                     is guaranteed to be there. 
        :param content_type: the mimetype of the uploaded file. 
        :param filename: the filename of the uploaded file.  May be `None`. 
        :param content_length: the length of this file.  This value is usually 
                               not provided because webbrowsers do not provide 
                               this value. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">default_stream_factory(</span>
            <span class="s1">total_content_length=total_content_length</span><span class="s0">,</span>
            <span class="s1">filename=filename</span><span class="s0">,</span>
            <span class="s1">content_type=content_type</span><span class="s0">,</span>
            <span class="s1">content_length=content_length</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">want_form_data_parsed(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;``True`` if the request method carries content. By default 
        this is true if a ``Content-Type`` is sent. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(self.environ.get(</span><span class="s4">&quot;CONTENT_TYPE&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">make_form_data_parser(self) -&gt; FormDataParser:</span>
        <span class="s2">&quot;&quot;&quot;Creates the form data parser. Instantiates the 
        :attr:`form_data_parser_class` with some parameters. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.form_data_parser_class(</span>
            <span class="s1">self._get_file_stream</span><span class="s0">,</span>
            <span class="s1">self.charset</span><span class="s0">,</span>
            <span class="s1">self.encoding_errors</span><span class="s0">,</span>
            <span class="s1">self.max_form_memory_size</span><span class="s0">,</span>
            <span class="s1">self.max_content_length</span><span class="s0">,</span>
            <span class="s1">self.parameter_storage_class</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_load_form_data(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Method used internally to retrieve submitted data.  After calling 
        this sets `form` and `files` on the request object to multi dicts 
        filled with the incoming form data.  As a matter of fact the input 
        stream will be empty afterwards.  You can also call this method to 
        force the parsing of the form data. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s3"># abort early if we have already consumed the stream</span>
        <span class="s0">if </span><span class="s4">&quot;form&quot; </span><span class="s0">in </span><span class="s1">self.__dict__:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">self.want_form_data_parsed:</span>
            <span class="s1">parser = self.make_form_data_parser()</span>
            <span class="s1">data = parser.parse(</span>
                <span class="s1">self._get_stream_for_parsing()</span><span class="s0">,</span>
                <span class="s1">self.mimetype</span><span class="s0">,</span>
                <span class="s1">self.content_length</span><span class="s0">,</span>
                <span class="s1">self.mimetype_params</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data = (</span>
                <span class="s1">self.stream</span><span class="s0">,</span>
                <span class="s1">self.parameter_storage_class()</span><span class="s0">,</span>
                <span class="s1">self.parameter_storage_class()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s3"># inject the values into the instance dict so that we bypass</span>
        <span class="s3"># our cached_property non-data descriptor.</span>
        <span class="s1">d = self.__dict__</span>
        <span class="s1">d[</span><span class="s4">&quot;stream&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">d[</span><span class="s4">&quot;form&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">d[</span><span class="s4">&quot;files&quot;</span><span class="s1">] = data</span>

    <span class="s0">def </span><span class="s1">_get_stream_for_parsing(self) -&gt; t.IO[bytes]:</span>
        <span class="s2">&quot;&quot;&quot;This is the same as accessing :attr:`stream` with the difference 
        that if it finds cached data from calling :meth:`get_data` first it 
        will create a new stream out of the cached data. 
 
        .. versionadded:: 0.9.3 
        &quot;&quot;&quot;</span>
        <span class="s1">cached_data = getattr(self</span><span class="s0">, </span><span class="s4">&quot;_cached_data&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">cached_data </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">BytesIO(cached_data)</span>
        <span class="s0">return </span><span class="s1">self.stream</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Closes associated resources of this request object.  This 
        closes all file handles explicitly.  You can also use the request 
        object in a with statement which will automatically close it. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">files = self.__dict__.get(</span><span class="s4">&quot;files&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(files </span><span class="s0">or </span><span class="s1">()):</span>
            <span class="s1">value.close()</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s4">&quot;Request&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">tb) -&gt; </span><span class="s0">None</span><span class="s1">:  </span><span class="s3"># type: ignore</span>
        <span class="s1">self.close()</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">stream(self) -&gt; t.IO[bytes]:</span>
        <span class="s2">&quot;&quot;&quot; 
        If the incoming form data was not encoded with a known mimetype 
        the data is stored unmodified in this stream for consumption.  Most 
        of the time it is a better idea to use :attr:`data` which will give 
        you that data as a string.  The stream only returns the data once. 
 
        Unlike :attr:`input_stream` this stream is properly guarded that you 
        can't accidentally read past the length of the input.  Werkzeug will 
        internally always refer to this stream to read data which makes it 
        possible to wrap this object with a stream that does filtering. 
 
        .. versionchanged:: 0.9 
           This stream is now always available but might be consumed by the 
           form parser later on.  Previously the stream was only set if no 
           parsing happened. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.shallow:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s4">&quot;This request was created with 'shallow=True', reading&quot;</span>
                <span class="s4">&quot; from the input stream is disabled.&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">get_input_stream(self.environ)</span>

    <span class="s1">input_stream = environ_property[t.IO[bytes]](</span>
        <span class="s4">&quot;wsgi.input&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;The WSGI input stream. 
 
        In general it's a bad idea to use this one because you can 
        easily read past the boundary.  Use the :attr:`stream` 
        instead.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">data(self) -&gt; bytes:</span>
        <span class="s2">&quot;&quot;&quot; 
        Contains the incoming request data as string in case it came with 
        a mimetype Werkzeug does not handle. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_data(parse_form_data=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@typing.overload</span>
    <span class="s0">def </span><span class="s1">get_data(  </span><span class="s3"># type: ignore</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">cache: bool = </span><span class="s0">True,</span>
        <span class="s1">as_text: </span><span class="s4">&quot;te.Literal[False]&quot; </span><span class="s1">= </span><span class="s0">False,</span>
        <span class="s1">parse_form_data: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; bytes:</span>
        <span class="s1">...</span>

    <span class="s1">@typing.overload</span>
    <span class="s0">def </span><span class="s1">get_data(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">cache: bool = </span><span class="s0">True,</span>
        <span class="s1">as_text: </span><span class="s4">&quot;te.Literal[True]&quot; </span><span class="s1">= ...</span><span class="s0">,</span>
        <span class="s1">parse_form_data: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">get_data(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">cache: bool = </span><span class="s0">True, </span><span class="s1">as_text: bool = </span><span class="s0">False, </span><span class="s1">parse_form_data: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; t.Union[bytes</span><span class="s0">, </span><span class="s1">str]:</span>
        <span class="s2">&quot;&quot;&quot;This reads the buffered incoming data from the client into one 
        bytes object.  By default this is cached but that behavior can be 
        changed by setting `cache` to `False`. 
 
        Usually it's a bad idea to call this method without checking the 
        content length first as a client could send dozens of megabytes or more 
        to cause memory problems on the server. 
 
        Note that if the form data was already parsed this method will not 
        return anything as form data parsing does not cache the data like 
        this method does.  To implicitly invoke form data parsing function 
        set `parse_form_data` to `True`.  When this is done the return value 
        of this method will be an empty string if the form parser handles 
        the data.  This generally is not necessary as if the whole data is 
        cached (which is the default) the form parser will used the cached 
        data to parse the form data.  Please be generally aware of checking 
        the content length first in any case before calling this method 
        to avoid exhausting server memory. 
 
        If `as_text` is set to `True` the return value will be a decoded 
        string. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = getattr(self</span><span class="s0">, </span><span class="s4">&quot;_cached_data&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">parse_form_data:</span>
                <span class="s1">self._load_form_data()</span>
            <span class="s1">rv = self.stream.read()</span>
            <span class="s0">if </span><span class="s1">cache:</span>
                <span class="s1">self._cached_data = rv</span>
        <span class="s0">if </span><span class="s1">as_text:</span>
            <span class="s1">rv = rv.decode(self.charset</span><span class="s0">, </span><span class="s1">self.encoding_errors)</span>
        <span class="s0">return </span><span class="s1">rv  </span><span class="s3"># type: ignore</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">form(self) -&gt; </span><span class="s4">&quot;ImmutableMultiDict[str, str]&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;The form parameters.  By default an 
        :class:`~werkzeug.datastructures.ImmutableMultiDict` 
        is returned from this function.  This can be changed by setting 
        :attr:`parameter_storage_class` to a different type.  This might 
        be necessary if the order of the form data is important. 
 
        Please keep in mind that file uploads will not end up here, but instead 
        in the :attr:`files` attribute. 
 
        .. versionchanged:: 0.9 
 
            Previous to Werkzeug 0.9 this would only contain form data for POST 
            and PUT requests. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._load_form_data()</span>
        <span class="s0">return </span><span class="s1">self.form</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">values(self) -&gt; </span><span class="s4">&quot;CombinedMultiDict[str, str]&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`werkzeug.datastructures.CombinedMultiDict` that 
        combines :attr:`args` and :attr:`form`. 
 
        For GET requests, only ``args`` are present, not ``form``. 
 
        .. versionchanged:: 2.0 
            For GET requests, only ``args`` are present, not ``form``. 
        &quot;&quot;&quot;</span>
        <span class="s1">sources = [self.args]</span>

        <span class="s0">if </span><span class="s1">self.method != </span><span class="s4">&quot;GET&quot;</span><span class="s1">:</span>
            <span class="s3"># GET requests can have a body, and some caching proxies</span>
            <span class="s3"># might not treat that differently than a normal GET</span>
            <span class="s3"># request, allowing form data to &quot;invisibly&quot; affect the</span>
            <span class="s3"># cache without indication in the query string / URL.</span>
            <span class="s1">sources.append(self.form)</span>

        <span class="s1">args = []</span>

        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">sources:</span>
            <span class="s0">if not </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">MultiDict):</span>
                <span class="s1">d = MultiDict(d)</span>

            <span class="s1">args.append(d)</span>

        <span class="s0">return </span><span class="s1">CombinedMultiDict(args)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">files(self) -&gt; </span><span class="s4">&quot;ImmutableMultiDict[str, FileStorage]&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;:class:`~werkzeug.datastructures.MultiDict` object containing 
        all uploaded files.  Each key in :attr:`files` is the name from the 
        ``&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;``.  Each value in :attr:`files` is a 
        Werkzeug :class:`~werkzeug.datastructures.FileStorage` object. 
 
        It basically behaves like a standard file object you know from Python, 
        with the difference that it also has a 
        :meth:`~werkzeug.datastructures.FileStorage.save` function that can 
        store the file on the filesystem. 
 
        Note that :attr:`files` will only contain data if the request method was 
        POST, PUT or PATCH and the ``&lt;form&gt;`` that posted to the request had 
        ``enctype=&quot;multipart/form-data&quot;``.  It will be empty otherwise. 
 
        See the :class:`~werkzeug.datastructures.MultiDict` / 
        :class:`~werkzeug.datastructures.FileStorage` documentation for 
        more details about the used data structure. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._load_form_data()</span>
        <span class="s0">return </span><span class="s1">self.files</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">script_root(self) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Alias for :attr:`self.root_path`. ``environ[&quot;SCRIPT_ROOT&quot;]`` 
        without a trailing slash. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.root_path</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">url_root(self) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Alias for :attr:`root_url`. The URL with scheme, host, and 
        root path. For example, ``https://example.com/app/``. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.root_url</span>

    <span class="s1">remote_user = environ_property[str](</span>
        <span class="s4">&quot;REMOTE_USER&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;If the server supports user authentication, and the 
        script is protected, this attribute contains the username the 
        user has authenticated as.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">is_multithread = environ_property[bool](</span>
        <span class="s4">&quot;wsgi.multithread&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;boolean that is `True` if the application is served by a 
        multithreaded WSGI server.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">is_multiprocess = environ_property[bool](</span>
        <span class="s4">&quot;wsgi.multiprocess&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;boolean that is `True` if the application is served by a 
        WSGI server that spawns multiple processes.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">is_run_once = environ_property[bool](</span>
        <span class="s4">&quot;wsgi.run_once&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;boolean that is `True` if the application will be 
        executed only once in a process lifetime.  This is the case for 
        CGI for example, but it's not guaranteed that the execution only 
        happens one time.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s3"># JSON</span>

    <span class="s3">#: A module or other object that has ``dumps`` and ``loads``</span>
    <span class="s3">#: functions that match the API of the built-in :mod:`json` module.</span>
    <span class="s1">json_module = json</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">json(self) -&gt; t.Optional[t.Any]:</span>
        <span class="s2">&quot;&quot;&quot;The parsed JSON data if :attr:`mimetype` indicates JSON 
        (:mimetype:`application/json`, see :attr:`is_json`). 
 
        Calls :meth:`get_json` with default arguments. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_json()</span>

    <span class="s3"># Cached values for ``(silent=False, silent=True)``. Initialized</span>
    <span class="s3"># with sentinel values.</span>
    <span class="s1">_cached_json: t.Tuple[t.Any</span><span class="s0">, </span><span class="s1">t.Any] = (Ellipsis</span><span class="s0">, </span><span class="s1">Ellipsis)</span>

    <span class="s0">def </span><span class="s1">get_json(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">force: bool = </span><span class="s0">False, </span><span class="s1">silent: bool = </span><span class="s0">False, </span><span class="s1">cache: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Any]:</span>
        <span class="s2">&quot;&quot;&quot;Parse :attr:`data` as JSON. 
 
        If the mimetype does not indicate JSON 
        (:mimetype:`application/json`, see :attr:`is_json`), this 
        returns ``None``. 
 
        If parsing fails, :meth:`on_json_loading_failed` is called and 
        its return value is used as the return value. 
 
        :param force: Ignore the mimetype and always try to parse JSON. 
        :param silent: Silence parsing errors and return ``None`` 
            instead. 
        :param cache: Store the parsed JSON to return for subsequent 
            calls. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">cache </span><span class="s0">and </span><span class="s1">self._cached_json[silent] </span><span class="s0">is not </span><span class="s1">Ellipsis:</span>
            <span class="s0">return </span><span class="s1">self._cached_json[silent]</span>

        <span class="s0">if not </span><span class="s1">(force </span><span class="s0">or </span><span class="s1">self.is_json):</span>
            <span class="s0">return None</span>

        <span class="s1">data = self.get_data(cache=cache)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = self.json_module.loads(data)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">if </span><span class="s1">silent:</span>
                <span class="s1">rv = </span><span class="s0">None</span>

                <span class="s0">if </span><span class="s1">cache:</span>
                    <span class="s1">normal_rv</span><span class="s0">, </span><span class="s1">_ = self._cached_json</span>
                    <span class="s1">self._cached_json = (normal_rv</span><span class="s0">, </span><span class="s1">rv)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rv = self.on_json_loading_failed(e)</span>

                <span class="s0">if </span><span class="s1">cache:</span>
                    <span class="s1">_</span><span class="s0">, </span><span class="s1">silent_rv = self._cached_json</span>
                    <span class="s1">self._cached_json = (rv</span><span class="s0">, </span><span class="s1">silent_rv)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">cache:</span>
                <span class="s1">self._cached_json = (rv</span><span class="s0">, </span><span class="s1">rv)</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">on_json_loading_failed(self</span><span class="s0">, </span><span class="s1">e: ValueError) -&gt; t.Any:</span>
        <span class="s2">&quot;&quot;&quot;Called if :meth:`get_json` parsing fails and isn't silenced. 
        If this method returns a value, it is used as the return value 
        for :meth:`get_json`. The default implementation raises 
        :exc:`~werkzeug.exceptions.BadRequest`. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">BadRequest(</span><span class="s4">f&quot;Failed to decode JSON object: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">StreamOnlyMixin:</span>
    <span class="s2">&quot;&quot;&quot;Mixin to create a ``Request`` that disables the ``data``, 
    ``form``, and ``files`` properties. Only ``stream`` is available. 
 
    .. deprecated:: 2.0 
        Will be removed in Werkzeug 2.1. Create the request with 
        ``shallow=True`` instead. 
 
    .. versionadded:: 0.9 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args: t.Any</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;'StreamOnlyMixin' is deprecated and will be removed in&quot;</span>
            <span class="s4">&quot; Werkzeug 2.1. Create the request with 'shallow=True'&quot;</span>
            <span class="s4">&quot; instead.&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;shallow&quot;</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)  </span><span class="s3"># type: ignore</span>


<span class="s0">class </span><span class="s1">PlainRequest(StreamOnlyMixin</span><span class="s0">, </span><span class="s1">Request):</span>
    <span class="s2">&quot;&quot;&quot;A request object without ``data``, ``form``, and ``files``. 
 
    .. deprecated:: 2.0 
        Will be removed in Werkzeug 2.1. Create the request with 
        ``shallow=True`` instead. 
 
    .. versionadded:: 0.9 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args: t.Any</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;'PlainRequest' is deprecated and will be removed in&quot;</span>
            <span class="s4">&quot; Werkzeug 2.1. Create the request with 'shallow=True'&quot;</span>
            <span class="s4">&quot; instead.&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># Don't show the DeprecationWarning for StreamOnlyMixin.</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>