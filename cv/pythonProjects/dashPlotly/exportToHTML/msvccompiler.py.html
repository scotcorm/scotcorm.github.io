<html>
<head>
<title>msvccompiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
msvccompiler.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.msvccompiler 
 
Contains MSVCCompiler, an implementation of the abstract CCompiler class 
for the Microsoft Visual Studio. 
&quot;&quot;&quot;</span>

<span class="s2"># Written by Perry Stoll</span>
<span class="s2"># hacked by Robin Becker and Thomas Heller to do a better job of</span>
<span class="s2">#   finding DevStudio (through the registry)</span>

<span class="s3">import </span><span class="s1">sys</span><span class="s3">, </span><span class="s1">os</span>
<span class="s3">from </span><span class="s1">distutils.errors </span><span class="s3">import </span><span class="s1">\</span>
     <span class="s1">DistutilsExecError</span><span class="s3">, </span><span class="s1">DistutilsPlatformError</span><span class="s3">, </span><span class="s1">\</span>
     <span class="s1">CompileError</span><span class="s3">, </span><span class="s1">LibError</span><span class="s3">, </span><span class="s1">LinkError</span>
<span class="s3">from </span><span class="s1">distutils.ccompiler </span><span class="s3">import </span><span class="s1">\</span>
     <span class="s1">CCompiler</span><span class="s3">, </span><span class="s1">gen_lib_options</span>
<span class="s3">from </span><span class="s1">distutils </span><span class="s3">import </span><span class="s1">log</span>

<span class="s1">_can_read_reg = </span><span class="s3">False</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">winreg</span>

    <span class="s1">_can_read_reg = </span><span class="s3">True</span>
    <span class="s1">hkey_mod = winreg</span>

    <span class="s1">RegOpenKeyEx = winreg.OpenKeyEx</span>
    <span class="s1">RegEnumKey = winreg.EnumKey</span>
    <span class="s1">RegEnumValue = winreg.EnumValue</span>
    <span class="s1">RegError = winreg.error</span>

<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">import </span><span class="s1">win32api</span>
        <span class="s3">import </span><span class="s1">win32con</span>
        <span class="s1">_can_read_reg = </span><span class="s3">True</span>
        <span class="s1">hkey_mod = win32con</span>

        <span class="s1">RegOpenKeyEx = win32api.RegOpenKeyEx</span>
        <span class="s1">RegEnumKey = win32api.RegEnumKey</span>
        <span class="s1">RegEnumValue = win32api.RegEnumValue</span>
        <span class="s1">RegError = win32api.error</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s1">log.info(</span><span class="s4">&quot;Warning: Can't read registry to find the &quot;</span>
                 <span class="s4">&quot;necessary compiler setting</span><span class="s3">\n</span><span class="s4">&quot;</span>
                 <span class="s4">&quot;Make sure that Python modules winreg, &quot;</span>
                 <span class="s4">&quot;win32api or win32con are installed.&quot;</span><span class="s1">)</span>
        <span class="s3">pass</span>

<span class="s3">if </span><span class="s1">_can_read_reg:</span>
    <span class="s1">HKEYS = (hkey_mod.HKEY_USERS</span><span class="s3">,</span>
             <span class="s1">hkey_mod.HKEY_CURRENT_USER</span><span class="s3">,</span>
             <span class="s1">hkey_mod.HKEY_LOCAL_MACHINE</span><span class="s3">,</span>
             <span class="s1">hkey_mod.HKEY_CLASSES_ROOT)</span>

<span class="s3">def </span><span class="s1">read_keys(base</span><span class="s3">, </span><span class="s1">key):</span>
    <span class="s0">&quot;&quot;&quot;Return list of registry keys.&quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">handle = RegOpenKeyEx(base</span><span class="s3">, </span><span class="s1">key)</span>
    <span class="s3">except </span><span class="s1">RegError:</span>
        <span class="s3">return None</span>
    <span class="s1">L = []</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">k = RegEnumKey(handle</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s3">except </span><span class="s1">RegError:</span>
            <span class="s3">break</span>
        <span class="s1">L.append(k)</span>
        <span class="s1">i += </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s1">L</span>

<span class="s3">def </span><span class="s1">read_values(base</span><span class="s3">, </span><span class="s1">key):</span>
    <span class="s0">&quot;&quot;&quot;Return dict of registry keys and values. 
 
    All names are converted to lowercase. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">handle = RegOpenKeyEx(base</span><span class="s3">, </span><span class="s1">key)</span>
    <span class="s3">except </span><span class="s1">RegError:</span>
        <span class="s3">return None</span>
    <span class="s1">d = {}</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">type = RegEnumValue(handle</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s3">except </span><span class="s1">RegError:</span>
            <span class="s3">break</span>
        <span class="s1">name = name.lower()</span>
        <span class="s1">d[convert_mbcs(name)] = convert_mbcs(value)</span>
        <span class="s1">i += </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s1">d</span>

<span class="s3">def </span><span class="s1">convert_mbcs(s):</span>
    <span class="s1">dec = getattr(s</span><span class="s3">, </span><span class="s4">&quot;decode&quot;</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">dec </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">s = dec(</span><span class="s4">&quot;mbcs&quot;</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">UnicodeError:</span>
            <span class="s3">pass</span>
    <span class="s3">return </span><span class="s1">s</span>

<span class="s3">class </span><span class="s1">MacroExpander:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">version):</span>
        <span class="s1">self.macros = {}</span>
        <span class="s1">self.load_macros(version)</span>

    <span class="s3">def </span><span class="s1">set_macro(self</span><span class="s3">, </span><span class="s1">macro</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">HKEYS:</span>
            <span class="s1">d = read_values(base</span><span class="s3">, </span><span class="s1">path)</span>
            <span class="s3">if </span><span class="s1">d:</span>
                <span class="s1">self.macros[</span><span class="s4">&quot;$(%s)&quot; </span><span class="s1">% macro] = d[key]</span>
                <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">load_macros(self</span><span class="s3">, </span><span class="s1">version):</span>
        <span class="s1">vsbase = </span><span class="s4">r&quot;Software\Microsoft\VisualStudio\%0.1f&quot; </span><span class="s1">% version</span>
        <span class="s1">self.set_macro(</span><span class="s4">&quot;VCInstallDir&quot;</span><span class="s3">, </span><span class="s1">vsbase + </span><span class="s4">r&quot;\Setup\VC&quot;</span><span class="s3">, </span><span class="s4">&quot;productdir&quot;</span><span class="s1">)</span>
        <span class="s1">self.set_macro(</span><span class="s4">&quot;VSInstallDir&quot;</span><span class="s3">, </span><span class="s1">vsbase + </span><span class="s4">r&quot;\Setup\VS&quot;</span><span class="s3">, </span><span class="s4">&quot;productdir&quot;</span><span class="s1">)</span>
        <span class="s1">net = </span><span class="s4">r&quot;Software\Microsoft\.NETFramework&quot;</span>
        <span class="s1">self.set_macro(</span><span class="s4">&quot;FrameworkDir&quot;</span><span class="s3">, </span><span class="s1">net</span><span class="s3">, </span><span class="s4">&quot;installroot&quot;</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">version &gt; </span><span class="s5">7.0</span><span class="s1">:</span>
                <span class="s1">self.set_macro(</span><span class="s4">&quot;FrameworkSDKDir&quot;</span><span class="s3">, </span><span class="s1">net</span><span class="s3">, </span><span class="s4">&quot;sdkinstallrootv1.1&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.set_macro(</span><span class="s4">&quot;FrameworkSDKDir&quot;</span><span class="s3">, </span><span class="s1">net</span><span class="s3">, </span><span class="s4">&quot;sdkinstallroot&quot;</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">exc: </span><span class="s2">#</span>
            <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span>
            <span class="s4">&quot;&quot;&quot;Python was built with Visual Studio 2003; 
extensions must be built with a compiler than can generate compatible binaries. 
Visual Studio 2003 was not found on this system. If you have Cygwin installed, 
you can try compiling with MingW32, by passing &quot;-c mingw32&quot; to setup.py.&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">p = </span><span class="s4">r&quot;Software\Microsoft\NET Framework Setup\Product&quot;</span>
        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">HKEYS:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">h = RegOpenKeyEx(base</span><span class="s3">, </span><span class="s1">p)</span>
            <span class="s3">except </span><span class="s1">RegError:</span>
                <span class="s3">continue</span>
            <span class="s1">key = RegEnumKey(h</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">d = read_values(base</span><span class="s3">, </span><span class="s4">r&quot;%s\%s&quot; </span><span class="s1">% (p</span><span class="s3">, </span><span class="s1">key))</span>
            <span class="s1">self.macros[</span><span class="s4">&quot;$(FrameworkVersion)&quot;</span><span class="s1">] = d[</span><span class="s4">&quot;version&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">sub(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.macros.items():</span>
            <span class="s1">s = s.replace(k</span><span class="s3">, </span><span class="s1">v)</span>
        <span class="s3">return </span><span class="s1">s</span>

<span class="s3">def </span><span class="s1">get_build_version():</span>
    <span class="s0">&quot;&quot;&quot;Return the version of MSVC that was used to build Python. 
 
    For Python 2.3 and up, the version number is included in 
    sys.version.  For earlier versions, assume the compiler is MSVC 6. 
    &quot;&quot;&quot;</span>
    <span class="s1">prefix = </span><span class="s4">&quot;MSC v.&quot;</span>
    <span class="s1">i = sys.version.find(prefix)</span>
    <span class="s3">if </span><span class="s1">i == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s5">6</span>
    <span class="s1">i = i + len(prefix)</span>
    <span class="s1">s</span><span class="s3">, </span><span class="s1">rest = sys.version[i:].split(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">majorVersion = int(s[:-</span><span class="s5">2</span><span class="s1">]) - </span><span class="s5">6</span>
    <span class="s3">if </span><span class="s1">majorVersion &gt;= </span><span class="s5">13</span><span class="s1">:</span>
        <span class="s2"># v13 was skipped and should be v14</span>
        <span class="s1">majorVersion += </span><span class="s5">1</span>
    <span class="s1">minorVersion = int(s[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]) / </span><span class="s5">10.0</span>
    <span class="s2"># I don't think paths are affected by minor version in version 6</span>
    <span class="s3">if </span><span class="s1">majorVersion == </span><span class="s5">6</span><span class="s1">:</span>
        <span class="s1">minorVersion = </span><span class="s5">0</span>
    <span class="s3">if </span><span class="s1">majorVersion &gt;= </span><span class="s5">6</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">majorVersion + minorVersion</span>
    <span class="s2"># else we don't know what version of the compiler this is</span>
    <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">get_build_architecture():</span>
    <span class="s0">&quot;&quot;&quot;Return the processor architecture. 
 
    Possible results are &quot;Intel&quot; or &quot;AMD64&quot;. 
    &quot;&quot;&quot;</span>

    <span class="s1">prefix = </span><span class="s4">&quot; bit (&quot;</span>
    <span class="s1">i = sys.version.find(prefix)</span>
    <span class="s3">if </span><span class="s1">i == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">&quot;Intel&quot;</span>
    <span class="s1">j = sys.version.find(</span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s1">i)</span>
    <span class="s3">return </span><span class="s1">sys.version[i+len(prefix):j]</span>

<span class="s3">def </span><span class="s1">normalize_and_reduce_paths(paths):</span>
    <span class="s0">&quot;&quot;&quot;Return a list of normalized paths with duplicates removed. 
 
    The current order of paths is maintained. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Paths are normalized so things like:  /a and /a/ aren't both preserved.</span>
    <span class="s1">reduced_paths = []</span>
    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">paths:</span>
        <span class="s1">np = os.path.normpath(p)</span>
        <span class="s2"># XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.</span>
        <span class="s3">if </span><span class="s1">np </span><span class="s3">not in </span><span class="s1">reduced_paths:</span>
            <span class="s1">reduced_paths.append(np)</span>
    <span class="s3">return </span><span class="s1">reduced_paths</span>


<span class="s3">class </span><span class="s1">MSVCCompiler(CCompiler) :</span>
    <span class="s0">&quot;&quot;&quot;Concrete class that implements an interface to Microsoft Visual C++, 
       as defined by the CCompiler abstract class.&quot;&quot;&quot;</span>

    <span class="s1">compiler_type = </span><span class="s4">'msvc'</span>

    <span class="s2"># Just set this so CCompiler's constructor doesn't barf.  We currently</span>
    <span class="s2"># don't use the 'set_executables()' bureaucracy provided by CCompiler,</span>
    <span class="s2"># as it really isn't necessary for this sort of single-compiler class.</span>
    <span class="s2"># Would be nice to have a consistent interface with UnixCCompiler,</span>
    <span class="s2"># though, so it's worth thinking about.</span>
    <span class="s1">executables = {}</span>

    <span class="s2"># Private class data (need to distinguish C from C++ source for compiler)</span>
    <span class="s1">_c_extensions = [</span><span class="s4">'.c'</span><span class="s1">]</span>
    <span class="s1">_cpp_extensions = [</span><span class="s4">'.cc'</span><span class="s3">, </span><span class="s4">'.cpp'</span><span class="s3">, </span><span class="s4">'.cxx'</span><span class="s1">]</span>
    <span class="s1">_rc_extensions = [</span><span class="s4">'.rc'</span><span class="s1">]</span>
    <span class="s1">_mc_extensions = [</span><span class="s4">'.mc'</span><span class="s1">]</span>

    <span class="s2"># Needed for the filename generation methods provided by the</span>
    <span class="s2"># base class, CCompiler.</span>
    <span class="s1">src_extensions = (_c_extensions + _cpp_extensions +</span>
                      <span class="s1">_rc_extensions + _mc_extensions)</span>
    <span class="s1">res_extension = </span><span class="s4">'.res'</span>
    <span class="s1">obj_extension = </span><span class="s4">'.obj'</span>
    <span class="s1">static_lib_extension = </span><span class="s4">'.lib'</span>
    <span class="s1">shared_lib_extension = </span><span class="s4">'.dll'</span>
    <span class="s1">static_lib_format = shared_lib_format = </span><span class="s4">'%s%s'</span>
    <span class="s1">exe_extension = </span><span class="s4">'.exe'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">force=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">CCompiler.__init__ (self</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">dry_run</span><span class="s3">, </span><span class="s1">force)</span>
        <span class="s1">self.__version = get_build_version()</span>
        <span class="s1">self.__arch = get_build_architecture()</span>
        <span class="s3">if </span><span class="s1">self.__arch == </span><span class="s4">&quot;Intel&quot;</span><span class="s1">:</span>
            <span class="s2"># x86</span>
            <span class="s3">if </span><span class="s1">self.__version &gt;= </span><span class="s5">7</span><span class="s1">:</span>
                <span class="s1">self.__root = </span><span class="s4">r&quot;Software\Microsoft\VisualStudio&quot;</span>
                <span class="s1">self.__macros = MacroExpander(self.__version)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.__root = </span><span class="s4">r&quot;Software\Microsoft\Devstudio&quot;</span>
            <span class="s1">self.__product = </span><span class="s4">&quot;Visual Studio version %s&quot; </span><span class="s1">% self.__version</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Win64. Assume this was built with the platform SDK</span>
            <span class="s1">self.__product = </span><span class="s4">&quot;Microsoft SDK compiler %s&quot; </span><span class="s1">% (self.__version + </span><span class="s5">6</span><span class="s1">)</span>

        <span class="s1">self.initialized = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">initialize(self):</span>
        <span class="s1">self.__paths = []</span>
        <span class="s3">if </span><span class="s4">&quot;DISTUTILS_USE_SDK&quot; </span><span class="s3">in </span><span class="s1">os.environ </span><span class="s3">and </span><span class="s4">&quot;MSSdk&quot; </span><span class="s3">in </span><span class="s1">os.environ </span><span class="s3">and </span><span class="s1">self.find_exe(</span><span class="s4">&quot;cl.exe&quot;</span><span class="s1">):</span>
            <span class="s2"># Assume that the SDK set up everything alright; don't try to be</span>
            <span class="s2"># smarter</span>
            <span class="s1">self.cc = </span><span class="s4">&quot;cl.exe&quot;</span>
            <span class="s1">self.linker = </span><span class="s4">&quot;link.exe&quot;</span>
            <span class="s1">self.lib = </span><span class="s4">&quot;lib.exe&quot;</span>
            <span class="s1">self.rc = </span><span class="s4">&quot;rc.exe&quot;</span>
            <span class="s1">self.mc = </span><span class="s4">&quot;mc.exe&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.__paths = self.get_msvc_paths(</span><span class="s4">&quot;path&quot;</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s1">len(self.__paths) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s4">&quot;Python was built with %s, &quot;</span>
                       <span class="s4">&quot;and extensions need to be built with the same &quot;</span>
                       <span class="s4">&quot;version of the compiler, but it isn't installed.&quot;</span>
                       <span class="s1">% self.__product)</span>

            <span class="s1">self.cc = self.find_exe(</span><span class="s4">&quot;cl.exe&quot;</span><span class="s1">)</span>
            <span class="s1">self.linker = self.find_exe(</span><span class="s4">&quot;link.exe&quot;</span><span class="s1">)</span>
            <span class="s1">self.lib = self.find_exe(</span><span class="s4">&quot;lib.exe&quot;</span><span class="s1">)</span>
            <span class="s1">self.rc = self.find_exe(</span><span class="s4">&quot;rc.exe&quot;</span><span class="s1">)   </span><span class="s2"># resource compiler</span>
            <span class="s1">self.mc = self.find_exe(</span><span class="s4">&quot;mc.exe&quot;</span><span class="s1">)   </span><span class="s2"># message compiler</span>
            <span class="s1">self.set_path_env_var(</span><span class="s4">'lib'</span><span class="s1">)</span>
            <span class="s1">self.set_path_env_var(</span><span class="s4">'include'</span><span class="s1">)</span>

        <span class="s2"># extend the MSVC path with the current path</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">os.environ[</span><span class="s4">'path'</span><span class="s1">].split(</span><span class="s4">';'</span><span class="s1">):</span>
                <span class="s1">self.__paths.append(p)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">pass</span>
        <span class="s1">self.__paths = normalize_and_reduce_paths(self.__paths)</span>
        <span class="s1">os.environ[</span><span class="s4">'path'</span><span class="s1">] = </span><span class="s4">&quot;;&quot;</span><span class="s1">.join(self.__paths)</span>

        <span class="s1">self.preprocess_options = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.__arch == </span><span class="s4">&quot;Intel&quot;</span><span class="s1">:</span>
            <span class="s1">self.compile_options = [ </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/O2'</span><span class="s3">, </span><span class="s4">'/MD'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">, </span><span class="s4">'/GX' </span><span class="s3">,</span>
                                     <span class="s4">'/DNDEBUG'</span><span class="s1">]</span>
            <span class="s1">self.compile_options_debug = [</span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/Od'</span><span class="s3">, </span><span class="s4">'/MDd'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">, </span><span class="s4">'/GX'</span><span class="s3">,</span>
                                          <span class="s4">'/Z7'</span><span class="s3">, </span><span class="s4">'/D_DEBUG'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Win64</span>
            <span class="s1">self.compile_options = [ </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/O2'</span><span class="s3">, </span><span class="s4">'/MD'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">, </span><span class="s4">'/GS-' </span><span class="s3">,</span>
                                     <span class="s4">'/DNDEBUG'</span><span class="s1">]</span>
            <span class="s1">self.compile_options_debug = [</span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/Od'</span><span class="s3">, </span><span class="s4">'/MDd'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">, </span><span class="s4">'/GS-'</span><span class="s3">,</span>
                                          <span class="s4">'/Z7'</span><span class="s3">, </span><span class="s4">'/D_DEBUG'</span><span class="s1">]</span>

        <span class="s1">self.ldflags_shared = [</span><span class="s4">'/DLL'</span><span class="s3">, </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/INCREMENTAL:NO'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">self.__version &gt;= </span><span class="s5">7</span><span class="s1">:</span>
            <span class="s1">self.ldflags_shared_debug = [</span>
                <span class="s4">'/DLL'</span><span class="s3">, </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/INCREMENTAL:no'</span><span class="s3">, </span><span class="s4">'/DEBUG'</span>
                <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.ldflags_shared_debug = [</span>
                <span class="s4">'/DLL'</span><span class="s3">, </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/INCREMENTAL:no'</span><span class="s3">, </span><span class="s4">'/pdb:None'</span><span class="s3">, </span><span class="s4">'/DEBUG'</span>
                <span class="s1">]</span>
        <span class="s1">self.ldflags_static = [ </span><span class="s4">'/nologo'</span><span class="s1">]</span>

        <span class="s1">self.initialized = </span><span class="s3">True</span>

    <span class="s2"># -- Worker methods ------------------------------------------------</span>

    <span class="s3">def </span><span class="s1">object_filenames(self</span><span class="s3">,</span>
                         <span class="s1">source_filenames</span><span class="s3">,</span>
                         <span class="s1">strip_dir=</span><span class="s5">0</span><span class="s3">,</span>
                         <span class="s1">output_dir=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s2"># Copied from ccompiler.py, extended to return .res as 'object'-file</span>
        <span class="s2"># for .rc input file</span>
        <span class="s3">if </span><span class="s1">output_dir </span><span class="s3">is None</span><span class="s1">: output_dir = </span><span class="s4">''</span>
        <span class="s1">obj_names = []</span>
        <span class="s3">for </span><span class="s1">src_name </span><span class="s3">in </span><span class="s1">source_filenames:</span>
            <span class="s1">(base</span><span class="s3">, </span><span class="s1">ext) = os.path.splitext (src_name)</span>
            <span class="s1">base = os.path.splitdrive(base)[</span><span class="s5">1</span><span class="s1">] </span><span class="s2"># Chop off the drive</span>
            <span class="s1">base = base[os.path.isabs(base):]  </span><span class="s2"># If abs, chop off leading /</span>
            <span class="s3">if </span><span class="s1">ext </span><span class="s3">not in </span><span class="s1">self.src_extensions:</span>
                <span class="s2"># Better to raise an exception instead of silently continuing</span>
                <span class="s2"># and later complain about sources and targets having</span>
                <span class="s2"># different lengths</span>
                <span class="s3">raise </span><span class="s1">CompileError (</span><span class="s4">&quot;Don't know how to compile %s&quot; </span><span class="s1">% src_name)</span>
            <span class="s3">if </span><span class="s1">strip_dir:</span>
                <span class="s1">base = os.path.basename (base)</span>
            <span class="s3">if </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._rc_extensions:</span>
                <span class="s1">obj_names.append (os.path.join (output_dir</span><span class="s3">,</span>
                                                <span class="s1">base + self.res_extension))</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._mc_extensions:</span>
                <span class="s1">obj_names.append (os.path.join (output_dir</span><span class="s3">,</span>
                                                <span class="s1">base + self.res_extension))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">obj_names.append (os.path.join (output_dir</span><span class="s3">,</span>
                                                <span class="s1">base + self.obj_extension))</span>
        <span class="s3">return </span><span class="s1">obj_names</span>


    <span class="s3">def </span><span class="s1">compile(self</span><span class="s3">, </span><span class="s1">sources</span><span class="s3">,</span>
                <span class="s1">output_dir=</span><span class="s3">None, </span><span class="s1">macros=</span><span class="s3">None, </span><span class="s1">include_dirs=</span><span class="s3">None, </span><span class="s1">debug=</span><span class="s5">0</span><span class="s3">,</span>
                <span class="s1">extra_preargs=</span><span class="s3">None, </span><span class="s1">extra_postargs=</span><span class="s3">None, </span><span class="s1">depends=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">compile_info = self._setup_compile(output_dir</span><span class="s3">, </span><span class="s1">macros</span><span class="s3">, </span><span class="s1">include_dirs</span><span class="s3">,</span>
                                           <span class="s1">sources</span><span class="s3">, </span><span class="s1">depends</span><span class="s3">, </span><span class="s1">extra_postargs)</span>
        <span class="s1">macros</span><span class="s3">, </span><span class="s1">objects</span><span class="s3">, </span><span class="s1">extra_postargs</span><span class="s3">, </span><span class="s1">pp_opts</span><span class="s3">, </span><span class="s1">build = compile_info</span>

        <span class="s1">compile_opts = extra_preargs </span><span class="s3">or </span><span class="s1">[]</span>
        <span class="s1">compile_opts.append (</span><span class="s4">'/c'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">debug:</span>
            <span class="s1">compile_opts.extend(self.compile_options_debug)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">compile_opts.extend(self.compile_options)</span>

        <span class="s3">for </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">objects:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">src</span><span class="s3">, </span><span class="s1">ext = build[obj]</span>
            <span class="s3">except </span><span class="s1">KeyError:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">debug:</span>
                <span class="s2"># pass the full pathname to MSVC in debug mode,</span>
                <span class="s2"># this allows the debugger to find the source file</span>
                <span class="s2"># without asking the user to browse for it</span>
                <span class="s1">src = os.path.abspath(src)</span>

            <span class="s3">if </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._c_extensions:</span>
                <span class="s1">input_opt = </span><span class="s4">&quot;/Tc&quot; </span><span class="s1">+ src</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._cpp_extensions:</span>
                <span class="s1">input_opt = </span><span class="s4">&quot;/Tp&quot; </span><span class="s1">+ src</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._rc_extensions:</span>
                <span class="s2"># compile .RC to .RES file</span>
                <span class="s1">input_opt = src</span>
                <span class="s1">output_opt = </span><span class="s4">&quot;/fo&quot; </span><span class="s1">+ obj</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.spawn([self.rc] + pp_opts +</span>
                               <span class="s1">[output_opt] + [input_opt])</span>
                <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                    <span class="s3">raise </span><span class="s1">CompileError(msg)</span>
                <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._mc_extensions:</span>
                <span class="s2"># Compile .MC to .RC file to .RES file.</span>
                <span class="s2">#   * '-h dir' specifies the directory for the</span>
                <span class="s2">#     generated include file</span>
                <span class="s2">#   * '-r dir' specifies the target directory of the</span>
                <span class="s2">#     generated RC file and the binary message resource</span>
                <span class="s2">#     it includes</span>
                <span class="s2">#</span>
                <span class="s2"># For now (since there are no options to change this),</span>
                <span class="s2"># we use the source-directory for the include file and</span>
                <span class="s2"># the build directory for the RC file and message</span>
                <span class="s2"># resources. This works at least for win32all.</span>
                <span class="s1">h_dir = os.path.dirname(src)</span>
                <span class="s1">rc_dir = os.path.dirname(obj)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s2"># first compile .MC to .RC and .H file</span>
                    <span class="s1">self.spawn([self.mc] +</span>
                               <span class="s1">[</span><span class="s4">'-h'</span><span class="s3">, </span><span class="s1">h_dir</span><span class="s3">, </span><span class="s4">'-r'</span><span class="s3">, </span><span class="s1">rc_dir] + [src])</span>
                    <span class="s1">base</span><span class="s3">, </span><span class="s1">_ = os.path.splitext (os.path.basename (src))</span>
                    <span class="s1">rc_file = os.path.join (rc_dir</span><span class="s3">, </span><span class="s1">base + </span><span class="s4">'.rc'</span><span class="s1">)</span>
                    <span class="s2"># then compile .RC to .RES file</span>
                    <span class="s1">self.spawn([self.rc] +</span>
                               <span class="s1">[</span><span class="s4">&quot;/fo&quot; </span><span class="s1">+ obj] + [rc_file])</span>

                <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                    <span class="s3">raise </span><span class="s1">CompileError(msg)</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># how to handle this file?</span>
                <span class="s3">raise </span><span class="s1">CompileError(</span><span class="s4">&quot;Don't know how to compile %s to %s&quot;</span>
                                   <span class="s1">% (src</span><span class="s3">, </span><span class="s1">obj))</span>

            <span class="s1">output_opt = </span><span class="s4">&quot;/Fo&quot; </span><span class="s1">+ obj</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.spawn([self.cc] + compile_opts + pp_opts +</span>
                           <span class="s1">[input_opt</span><span class="s3">, </span><span class="s1">output_opt] +</span>
                           <span class="s1">extra_postargs)</span>
            <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">raise </span><span class="s1">CompileError(msg)</span>

        <span class="s3">return </span><span class="s1">objects</span>


    <span class="s3">def </span><span class="s1">create_static_lib(self</span><span class="s3">,</span>
                          <span class="s1">objects</span><span class="s3">,</span>
                          <span class="s1">output_libname</span><span class="s3">,</span>
                          <span class="s1">output_dir=</span><span class="s3">None,</span>
                          <span class="s1">debug=</span><span class="s5">0</span><span class="s3">,</span>
                          <span class="s1">target_lang=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">(objects</span><span class="s3">, </span><span class="s1">output_dir) = self._fix_object_args(objects</span><span class="s3">, </span><span class="s1">output_dir)</span>
        <span class="s1">output_filename = self.library_filename(output_libname</span><span class="s3">,</span>
                                                <span class="s1">output_dir=output_dir)</span>

        <span class="s3">if </span><span class="s1">self._need_link(objects</span><span class="s3">, </span><span class="s1">output_filename):</span>
            <span class="s1">lib_args = objects + [</span><span class="s4">'/OUT:' </span><span class="s1">+ output_filename]</span>
            <span class="s3">if </span><span class="s1">debug:</span>
                <span class="s3">pass </span><span class="s2"># XXX what goes here?</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.spawn([self.lib] + lib_args)</span>
            <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">raise </span><span class="s1">LibError(msg)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;skipping %s (up-to-date)&quot;</span><span class="s3">, </span><span class="s1">output_filename)</span>


    <span class="s3">def </span><span class="s1">link(self</span><span class="s3">,</span>
             <span class="s1">target_desc</span><span class="s3">,</span>
             <span class="s1">objects</span><span class="s3">,</span>
             <span class="s1">output_filename</span><span class="s3">,</span>
             <span class="s1">output_dir=</span><span class="s3">None,</span>
             <span class="s1">libraries=</span><span class="s3">None,</span>
             <span class="s1">library_dirs=</span><span class="s3">None,</span>
             <span class="s1">runtime_library_dirs=</span><span class="s3">None,</span>
             <span class="s1">export_symbols=</span><span class="s3">None,</span>
             <span class="s1">debug=</span><span class="s5">0</span><span class="s3">,</span>
             <span class="s1">extra_preargs=</span><span class="s3">None,</span>
             <span class="s1">extra_postargs=</span><span class="s3">None,</span>
             <span class="s1">build_temp=</span><span class="s3">None,</span>
             <span class="s1">target_lang=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">(objects</span><span class="s3">, </span><span class="s1">output_dir) = self._fix_object_args(objects</span><span class="s3">, </span><span class="s1">output_dir)</span>
        <span class="s1">fixed_args = self._fix_lib_args(libraries</span><span class="s3">, </span><span class="s1">library_dirs</span><span class="s3">,</span>
                                        <span class="s1">runtime_library_dirs)</span>
        <span class="s1">(libraries</span><span class="s3">, </span><span class="s1">library_dirs</span><span class="s3">, </span><span class="s1">runtime_library_dirs) = fixed_args</span>

        <span class="s3">if </span><span class="s1">runtime_library_dirs:</span>
            <span class="s1">self.warn (</span><span class="s4">&quot;I don't know what to do with 'runtime_library_dirs': &quot;</span>
                       <span class="s1">+ str (runtime_library_dirs))</span>

        <span class="s1">lib_opts = gen_lib_options(self</span><span class="s3">,</span>
                                   <span class="s1">library_dirs</span><span class="s3">, </span><span class="s1">runtime_library_dirs</span><span class="s3">,</span>
                                   <span class="s1">libraries)</span>
        <span class="s3">if </span><span class="s1">output_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">output_filename = os.path.join(output_dir</span><span class="s3">, </span><span class="s1">output_filename)</span>

        <span class="s3">if </span><span class="s1">self._need_link(objects</span><span class="s3">, </span><span class="s1">output_filename):</span>
            <span class="s3">if </span><span class="s1">target_desc == CCompiler.EXECUTABLE:</span>
                <span class="s3">if </span><span class="s1">debug:</span>
                    <span class="s1">ldflags = self.ldflags_shared_debug[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ldflags = self.ldflags_shared[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">debug:</span>
                    <span class="s1">ldflags = self.ldflags_shared_debug</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ldflags = self.ldflags_shared</span>

            <span class="s1">export_opts = []</span>
            <span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">(export_symbols </span><span class="s3">or </span><span class="s1">[]):</span>
                <span class="s1">export_opts.append(</span><span class="s4">&quot;/EXPORT:&quot; </span><span class="s1">+ sym)</span>

            <span class="s1">ld_args = (ldflags + lib_opts + export_opts +</span>
                       <span class="s1">objects + [</span><span class="s4">'/OUT:' </span><span class="s1">+ output_filename])</span>

            <span class="s2"># The MSVC linker generates .lib and .exp files, which cannot be</span>
            <span class="s2"># suppressed by any linker switches. The .lib files may even be</span>
            <span class="s2"># needed! Make sure they are generated in the temporary build</span>
            <span class="s2"># directory. Since they have different names for debug and release</span>
            <span class="s2"># builds, they can go into the same directory.</span>
            <span class="s3">if </span><span class="s1">export_symbols </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">(dll_name</span><span class="s3">, </span><span class="s1">dll_ext) = os.path.splitext(</span>
                    <span class="s1">os.path.basename(output_filename))</span>
                <span class="s1">implib_file = os.path.join(</span>
                    <span class="s1">os.path.dirname(objects[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">,</span>
                    <span class="s1">self.library_filename(dll_name))</span>
                <span class="s1">ld_args.append (</span><span class="s4">'/IMPLIB:' </span><span class="s1">+ implib_file)</span>

            <span class="s3">if </span><span class="s1">extra_preargs:</span>
                <span class="s1">ld_args[:</span><span class="s5">0</span><span class="s1">] = extra_preargs</span>
            <span class="s3">if </span><span class="s1">extra_postargs:</span>
                <span class="s1">ld_args.extend(extra_postargs)</span>

            <span class="s1">self.mkpath(os.path.dirname(output_filename))</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.spawn([self.linker] + ld_args)</span>
            <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">raise </span><span class="s1">LinkError(msg)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;skipping %s (up-to-date)&quot;</span><span class="s3">, </span><span class="s1">output_filename)</span>


    <span class="s2"># -- Miscellaneous methods -----------------------------------------</span>
    <span class="s2"># These are all used by the 'gen_lib_options() function, in</span>
    <span class="s2"># ccompiler.py.</span>

    <span class="s3">def </span><span class="s1">library_dir_option(self</span><span class="s3">, </span><span class="s1">dir):</span>
        <span class="s3">return </span><span class="s4">&quot;/LIBPATH:&quot; </span><span class="s1">+ dir</span>

    <span class="s3">def </span><span class="s1">runtime_library_dir_option(self</span><span class="s3">, </span><span class="s1">dir):</span>
        <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span>
              <span class="s4">&quot;don't know how to set runtime library search path for MSVC++&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">library_option(self</span><span class="s3">, </span><span class="s1">lib):</span>
        <span class="s3">return </span><span class="s1">self.library_filename(lib)</span>


    <span class="s3">def </span><span class="s1">find_library_file(self</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">debug=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2"># Prefer a debugging library if found (and requested), but deal</span>
        <span class="s2"># with it if we don't have one.</span>
        <span class="s3">if </span><span class="s1">debug:</span>
            <span class="s1">try_names = [lib + </span><span class="s4">&quot;_d&quot;</span><span class="s3">, </span><span class="s1">lib]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">try_names = [lib]</span>
        <span class="s3">for </span><span class="s1">dir </span><span class="s3">in </span><span class="s1">dirs:</span>
            <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">try_names:</span>
                <span class="s1">libfile = os.path.join(dir</span><span class="s3">, </span><span class="s1">self.library_filename (name))</span>
                <span class="s3">if </span><span class="s1">os.path.exists(libfile):</span>
                    <span class="s3">return </span><span class="s1">libfile</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Oops, didn't find it in *any* of 'dirs'</span>
            <span class="s3">return None</span>

    <span class="s2"># Helper methods for using the MSVC registry settings</span>

    <span class="s3">def </span><span class="s1">find_exe(self</span><span class="s3">, </span><span class="s1">exe):</span>
        <span class="s0">&quot;&quot;&quot;Return path to an MSVC executable program. 
 
        Tries to find the program in several places: first, one of the 
        MSVC program search paths from the registry; next, the directories 
        in the PATH environment variable.  If any of those work, return an 
        absolute path that is known to exist.  If none of them work, just 
        return the original program name, 'exe'. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">self.__paths:</span>
            <span class="s1">fn = os.path.join(os.path.abspath(p)</span><span class="s3">, </span><span class="s1">exe)</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(fn):</span>
                <span class="s3">return </span><span class="s1">fn</span>

        <span class="s2"># didn't find it; try existing path</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">os.environ[</span><span class="s4">'Path'</span><span class="s1">].split(</span><span class="s4">';'</span><span class="s1">):</span>
            <span class="s1">fn = os.path.join(os.path.abspath(p)</span><span class="s3">,</span><span class="s1">exe)</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(fn):</span>
                <span class="s3">return </span><span class="s1">fn</span>

        <span class="s3">return </span><span class="s1">exe</span>

    <span class="s3">def </span><span class="s1">get_msvc_paths(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">platform=</span><span class="s4">'x86'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of devstudio directories (include, lib or path). 
 
        Return a list of strings.  The list will be empty if unable to 
        access the registry or appropriate registry keys not found. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">_can_read_reg:</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s1">path = path + </span><span class="s4">&quot; dirs&quot;</span>
        <span class="s3">if </span><span class="s1">self.__version &gt;= </span><span class="s5">7</span><span class="s1">:</span>
            <span class="s1">key = (</span><span class="s4">r&quot;%s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directories&quot;</span>
                   <span class="s1">% (self.__root</span><span class="s3">, </span><span class="s1">self.__version))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">key = (</span><span class="s4">r&quot;%s\6.0\Build System\Components\Platforms&quot;</span>
                   <span class="s4">r&quot;\Win32 (%s)\Directories&quot; </span><span class="s1">% (self.__root</span><span class="s3">, </span><span class="s1">platform))</span>

        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">HKEYS:</span>
            <span class="s1">d = read_values(base</span><span class="s3">, </span><span class="s1">key)</span>
            <span class="s3">if </span><span class="s1">d:</span>
                <span class="s3">if </span><span class="s1">self.__version &gt;= </span><span class="s5">7</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self.__macros.sub(d[path]).split(</span><span class="s4">&quot;;&quot;</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">d[path].split(</span><span class="s4">&quot;;&quot;</span><span class="s1">)</span>
        <span class="s2"># MSVC 6 seems to create the registry entries we need only when</span>
        <span class="s2"># the GUI is run.</span>
        <span class="s3">if </span><span class="s1">self.__version == </span><span class="s5">6</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">HKEYS:</span>
                <span class="s3">if </span><span class="s1">read_values(base</span><span class="s3">, </span><span class="s4">r&quot;%s\6.0&quot; </span><span class="s1">% self.__root) </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self.warn(</span><span class="s4">&quot;It seems you have Visual Studio 6 installed, &quot;</span>
                        <span class="s4">&quot;but the expected registry settings are not present.</span><span class="s3">\n</span><span class="s4">&quot;</span>
                        <span class="s4">&quot;You must at least run the Visual Studio GUI once &quot;</span>
                        <span class="s4">&quot;so that these entries are created.&quot;</span><span class="s1">)</span>
                    <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">set_path_env_var(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot;Set environment variable 'name' to an MSVC path type value. 
 
        This is equivalent to a SET command prior to execution of spawned 
        commands. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">name == </span><span class="s4">&quot;lib&quot;</span><span class="s1">:</span>
            <span class="s1">p = self.get_msvc_paths(</span><span class="s4">&quot;library&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">p = self.get_msvc_paths(name)</span>
        <span class="s3">if </span><span class="s1">p:</span>
            <span class="s1">os.environ[name] = </span><span class="s4">';'</span><span class="s1">.join(p)</span>


<span class="s3">if </span><span class="s1">get_build_version() &gt;= </span><span class="s5">8.0</span><span class="s1">:</span>
    <span class="s1">log.debug(</span><span class="s4">&quot;Importing new compiler from distutils.msvc9compiler&quot;</span><span class="s1">)</span>
    <span class="s1">OldMSVCCompiler = MSVCCompiler</span>
    <span class="s3">from </span><span class="s1">distutils.msvc9compiler </span><span class="s3">import </span><span class="s1">MSVCCompiler</span>
    <span class="s2"># get_build_architecture not really relevant now we support cross-compile</span>
    <span class="s3">from </span><span class="s1">distutils.msvc9compiler </span><span class="s3">import </span><span class="s1">MacroExpander</span>
</pre>
</body>
</html>