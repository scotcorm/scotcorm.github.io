<html>
<head>
<title>linalg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
linalg.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">._dtypes </span><span class="s0">import </span><span class="s1">_floating_dtypes</span><span class="s0">, </span><span class="s1">_numeric_dtypes</span>
<span class="s0">from </span><span class="s1">._array_object </span><span class="s0">import </span><span class="s1">Array</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">._typing </span><span class="s0">import </span><span class="s1">Literal</span><span class="s0">, </span><span class="s1">Optional</span><span class="s0">, </span><span class="s1">Sequence</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Union</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NamedTuple</span>

<span class="s0">import </span><span class="s1">numpy.linalg</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">class </span><span class="s1">EighResult(NamedTuple):</span>
    <span class="s1">eigenvalues: Array</span>
    <span class="s1">eigenvectors: Array</span>

<span class="s0">class </span><span class="s1">QRResult(NamedTuple):</span>
    <span class="s1">Q: Array</span>
    <span class="s1">R: Array</span>

<span class="s0">class </span><span class="s1">SlogdetResult(NamedTuple):</span>
    <span class="s1">sign: Array</span>
    <span class="s1">logabsdet: Array</span>

<span class="s0">class </span><span class="s1">SVDResult(NamedTuple):</span>
    <span class="s1">U: Array</span>
    <span class="s1">S: Array</span>
    <span class="s1">Vh: Array</span>

<span class="s2"># Note: the inclusion of the upper keyword is different from</span>
<span class="s2"># np.linalg.cholesky, which does not have it.</span>
<span class="s0">def </span><span class="s1">cholesky(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">upper: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.cholesky &lt;numpy.linalg.cholesky&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.cholesky.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in cholesky'</span><span class="s1">)</span>
    <span class="s1">L = np.linalg.cholesky(x._array)</span>
    <span class="s0">if </span><span class="s1">upper:</span>
        <span class="s0">return </span><span class="s1">Array._new(L).mT</span>
    <span class="s0">return </span><span class="s1">Array._new(L)</span>

<span class="s2"># Note: cross is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">cross(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis: int = -</span><span class="s5">1</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.cross &lt;numpy.cross&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only numeric dtypes are allowed in cross'</span><span class="s1">)</span>
    <span class="s2"># Note: this is different from np.cross(), which broadcasts</span>
    <span class="s0">if </span><span class="s1">x1.shape != x2.shape:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'x1 and x2 must have the same shape'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x1.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'cross() requires arrays of dimension at least 1'</span><span class="s1">)</span>
    <span class="s2"># Note: this is different from np.cross(), which allows dimension 2</span>
    <span class="s0">if </span><span class="s1">x1.shape[axis] != </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'cross() dimension must equal 3'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.cross(x1._array</span><span class="s0">, </span><span class="s1">x2._array</span><span class="s0">, </span><span class="s1">axis=axis))</span>

<span class="s0">def </span><span class="s1">det(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.det &lt;numpy.linalg.det&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.det.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in det'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.linalg.det(x._array))</span>

<span class="s2"># Note: diagonal is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">diagonal(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">offset: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.diagonal &lt;numpy.diagonal&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: diagonal always operates on the last two axes, whereas np.diagonal</span>
    <span class="s2"># operates on the first two axes by default</span>
    <span class="s0">return </span><span class="s1">Array._new(np.diagonal(x._array</span><span class="s0">, </span><span class="s1">offset=offset</span><span class="s0">, </span><span class="s1">axis1=-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">axis2=-</span><span class="s5">1</span><span class="s1">))</span>


<span class="s2"># Note: the keyword argument name upper is different from np.linalg.eigh</span>
<span class="s0">def </span><span class="s1">eigh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; EighResult:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.eigh &lt;numpy.linalg.eigh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.eigh.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in eigh'</span><span class="s1">)</span>

    <span class="s2"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s2"># np.eigh, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">EighResult(*map(Array._new</span><span class="s0">, </span><span class="s1">np.linalg.eigh(x._array)))</span>


<span class="s2"># Note: the keyword argument name upper is different from np.linalg.eigvalsh</span>
<span class="s0">def </span><span class="s1">eigvalsh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.eigvalsh &lt;numpy.linalg.eigvalsh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.eigvalsh.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in eigvalsh'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(np.linalg.eigvalsh(x._array))</span>

<span class="s0">def </span><span class="s1">inv(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.inv &lt;numpy.linalg.inv&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.inv.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in inv'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(np.linalg.inv(x._array))</span>


<span class="s2"># Note: matmul is the numpy top-level namespace but not in np.linalg</span>
<span class="s0">def </span><span class="s1">matmul(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.matmul &lt;numpy.matmul&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to numeric dtypes only is different from</span>
    <span class="s2"># np.matmul.</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only numeric dtypes are allowed in matmul'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(np.matmul(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s2"># Note: the name here is different from norm(). The array API norm is split</span>
<span class="s2"># into matrix_norm and vector_norm().</span>

<span class="s2"># The type for ord should be Optional[Union[int, float, Literal[np.inf,</span>
<span class="s2"># -np.inf, 'fro', 'nuc']]], but Literal does not support floating-point</span>
<span class="s2"># literals.</span>
<span class="s0">def </span><span class="s1">matrix_norm(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">keepdims: bool = </span><span class="s0">False, </span><span class="s1">ord: Optional[Union[int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">Literal[</span><span class="s4">'fro'</span><span class="s0">, </span><span class="s4">'nuc'</span><span class="s1">]]] = </span><span class="s4">'fro'</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.norm &lt;numpy.linalg.norm&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.norm.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in matrix_norm'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(np.linalg.norm(x._array</span><span class="s0">, </span><span class="s1">axis=(-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">keepdims=keepdims</span><span class="s0">, </span><span class="s1">ord=ord))</span>


<span class="s0">def </span><span class="s1">matrix_power(x: Array</span><span class="s0">, </span><span class="s1">n: int</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.matrix_power &lt;numpy.matrix_power&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.matrix_power.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed for the first argument of matrix_power'</span><span class="s1">)</span>

    <span class="s2"># np.matrix_power already checks if n is an integer</span>
    <span class="s0">return </span><span class="s1">Array._new(np.linalg.matrix_power(x._array</span><span class="s0">, </span><span class="s1">n))</span>

<span class="s2"># Note: the keyword argument name rtol is different from np.linalg.matrix_rank</span>
<span class="s0">def </span><span class="s1">matrix_rank(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">rtol: Optional[Union[float</span><span class="s0">, </span><span class="s1">Array]] = </span><span class="s0">None</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.matrix_rank &lt;numpy.matrix_rank&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: this is different from np.linalg.matrix_rank, which supports 1</span>
    <span class="s2"># dimensional arrays.</span>
    <span class="s0">if </span><span class="s1">x.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">np.linalg.LinAlgError(</span><span class="s4">&quot;1-dimensional array given. Array must be at least two-dimensional&quot;</span><span class="s1">)</span>
    <span class="s1">S = np.linalg.svd(x._array</span><span class="s0">, </span><span class="s1">compute_uv=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">tol = S.max(axis=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">) * max(x.shape[-</span><span class="s5">2</span><span class="s1">:]) * np.finfo(S.dtype).eps</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(rtol</span><span class="s0">, </span><span class="s1">Array):</span>
            <span class="s1">rtol = rtol._array</span>
        <span class="s2"># Note: this is different from np.linalg.matrix_rank, which does not multiply</span>
        <span class="s2"># the tolerance by the largest singular value.</span>
        <span class="s1">tol = S.max(axis=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)*np.asarray(rtol)[...</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
    <span class="s0">return </span><span class="s1">Array._new(np.count_nonzero(S &gt; tol</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>


<span class="s2"># Note: this function is new in the array API spec. Unlike transpose, it only</span>
<span class="s2"># transposes the last two axes.</span>
<span class="s0">def </span><span class="s1">matrix_transpose(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s0">if </span><span class="s1">x.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;x must be at least 2-dimensional for matrix_transpose&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.swapaxes(x._array</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">))</span>

<span class="s2"># Note: outer is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">outer(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.outer &lt;numpy.outer&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to numeric dtypes only is different from</span>
    <span class="s2"># np.outer.</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only numeric dtypes are allowed in outer'</span><span class="s1">)</span>

    <span class="s2"># Note: the restriction to only 1-dim arrays is different from np.outer</span>
    <span class="s0">if </span><span class="s1">x1.ndim != </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">x2.ndim != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'The input arrays to outer must be 1-dimensional'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(np.outer(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>

<span class="s2"># Note: the keyword argument name rtol is different from np.linalg.pinv</span>
<span class="s0">def </span><span class="s1">pinv(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">rtol: Optional[Union[float</span><span class="s0">, </span><span class="s1">Array]] = </span><span class="s0">None</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.pinv &lt;numpy.linalg.pinv&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.pinv.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in pinv'</span><span class="s1">)</span>

    <span class="s2"># Note: this is different from np.linalg.pinv, which does not multiply the</span>
    <span class="s2"># default tolerance by max(M, N).</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">rtol = max(x.shape[-</span><span class="s5">2</span><span class="s1">:]) * np.finfo(x.dtype).eps</span>
    <span class="s0">return </span><span class="s1">Array._new(np.linalg.pinv(x._array</span><span class="s0">, </span><span class="s1">rcond=rtol))</span>

<span class="s0">def </span><span class="s1">qr(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">mode: Literal[</span><span class="s4">'reduced'</span><span class="s0">, </span><span class="s4">'complete'</span><span class="s1">] = </span><span class="s4">'reduced'</span><span class="s1">) -&gt; QRResult:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.qr &lt;numpy.linalg.qr&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.qr.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in qr'</span><span class="s1">)</span>

    <span class="s2"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s2"># np.linalg.qr, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">QRResult(*map(Array._new</span><span class="s0">, </span><span class="s1">np.linalg.qr(x._array</span><span class="s0">, </span><span class="s1">mode=mode)))</span>

<span class="s0">def </span><span class="s1">slogdet(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; SlogdetResult:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.slogdet &lt;numpy.linalg.slogdet&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.slogdet.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in slogdet'</span><span class="s1">)</span>

    <span class="s2"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s2"># np.linalg.slogdet, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">SlogdetResult(*map(Array._new</span><span class="s0">, </span><span class="s1">np.linalg.slogdet(x._array)))</span>

<span class="s2"># Note: unlike np.linalg.solve, the array API solve() only accepts x2 as a</span>
<span class="s2"># vector when it is exactly 1-dimensional. All other cases treat x2 as a stack</span>
<span class="s2"># of matrices. The np.linalg.solve behavior of allowing stacks of both</span>
<span class="s2"># matrices and vectors is ambiguous c.f.</span>
<span class="s2"># https://github.com/numpy/numpy/issues/15349 and</span>
<span class="s2"># https://github.com/data-apis/array-api/issues/285.</span>

<span class="s2"># To workaround this, the below is the code from np.linalg.solve except</span>
<span class="s2"># only calling solve1 in the exactly 1D case.</span>
<span class="s0">def </span><span class="s1">_solve(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s0">from </span><span class="s1">..linalg.linalg </span><span class="s0">import </span><span class="s1">(_makearray</span><span class="s0">, </span><span class="s1">_assert_stacked_2d</span><span class="s0">,</span>
                                 <span class="s1">_assert_stacked_square</span><span class="s0">, </span><span class="s1">_commonType</span><span class="s0">,</span>
                                 <span class="s1">isComplexType</span><span class="s0">, </span><span class="s1">get_linalg_error_extobj</span><span class="s0">,</span>
                                 <span class="s1">_raise_linalgerror_singular)</span>
    <span class="s0">from </span><span class="s1">..linalg </span><span class="s0">import </span><span class="s1">_umath_linalg</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">_ = _makearray(a)</span>
    <span class="s1">_assert_stacked_2d(a)</span>
    <span class="s1">_assert_stacked_square(a)</span>
    <span class="s1">b</span><span class="s0">, </span><span class="s1">wrap = _makearray(b)</span>
    <span class="s1">t</span><span class="s0">, </span><span class="s1">result_t = _commonType(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s2"># This part is different from np.linalg.solve</span>
    <span class="s0">if </span><span class="s1">b.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">gufunc = _umath_linalg.solve1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">gufunc = _umath_linalg.solve</span>

    <span class="s2"># This does nothing currently but is left in because it will be relevant</span>
    <span class="s2"># when complex dtype support is added to the spec in 2022.</span>
    <span class="s1">signature = </span><span class="s4">'DD-&gt;D' </span><span class="s0">if </span><span class="s1">isComplexType(t) </span><span class="s0">else </span><span class="s4">'dd-&gt;d'</span>
    <span class="s1">extobj = get_linalg_error_extobj(_raise_linalgerror_singular)</span>
    <span class="s1">r = gufunc(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">signature=signature</span><span class="s0">, </span><span class="s1">extobj=extobj)</span>

    <span class="s0">return </span><span class="s1">wrap(r.astype(result_t</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">))</span>

<span class="s0">def </span><span class="s1">solve(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.solve &lt;numpy.linalg.solve&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.solve.</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in solve'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(_solve(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>

<span class="s0">def </span><span class="s1">svd(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">full_matrices: bool = </span><span class="s0">True</span><span class="s1">) -&gt; SVDResult:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.svd &lt;numpy.linalg.svd&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.svd.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in svd'</span><span class="s1">)</span>

    <span class="s2"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s2"># np.svd, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">SVDResult(*map(Array._new</span><span class="s0">, </span><span class="s1">np.linalg.svd(x._array</span><span class="s0">, </span><span class="s1">full_matrices=full_matrices)))</span>

<span class="s2"># Note: svdvals is not in NumPy (but it is in SciPy). It is equivalent to</span>
<span class="s2"># np.linalg.svd(compute_uv=False).</span>
<span class="s0">def </span><span class="s1">svdvals(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Union[Array</span><span class="s0">, </span><span class="s1">Tuple[Array</span><span class="s0">, </span><span class="s1">...]]:</span>
    <span class="s0">return </span><span class="s1">Array._new(np.linalg.svd(x._array</span><span class="s0">, </span><span class="s1">compute_uv=</span><span class="s0">False</span><span class="s1">))</span>

<span class="s2"># Note: tensordot is the numpy top-level namespace but not in np.linalg</span>

<span class="s2"># Note: axes must be a tuple, unlike np.tensordot where it can be an array or array-like.</span>
<span class="s0">def </span><span class="s1">tensordot(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axes: Union[int</span><span class="s0">, </span><span class="s1">Tuple[Sequence[int]</span><span class="s0">, </span><span class="s1">Sequence[int]]] = </span><span class="s5">2</span><span class="s1">) -&gt; Array:</span>
    <span class="s2"># Note: the restriction to numeric dtypes only is different from</span>
    <span class="s2"># np.tensordot.</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only numeric dtypes are allowed in tensordot'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">Array._new(np.tensordot(x1._array</span><span class="s0">, </span><span class="s1">x2._array</span><span class="s0">, </span><span class="s1">axes=axes))</span>

<span class="s2"># Note: trace is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">trace(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">offset: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.trace &lt;numpy.trace&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: trace always operates on the last two axes, whereas np.trace</span>
    <span class="s2"># operates on the first two axes by default</span>
    <span class="s0">return </span><span class="s1">Array._new(np.asarray(np.trace(x._array</span><span class="s0">, </span><span class="s1">offset=offset</span><span class="s0">, </span><span class="s1">axis1=-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">axis2=-</span><span class="s5">1</span><span class="s1">)))</span>

<span class="s2"># Note: vecdot is not in NumPy</span>
<span class="s0">def </span><span class="s1">vecdot(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis: int = -</span><span class="s5">1</span><span class="s1">) -&gt; Array:</span>
    <span class="s0">return </span><span class="s1">tensordot(x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">axes=((axis</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(axis</span><span class="s0">,</span><span class="s1">)))</span>


<span class="s2"># Note: the name here is different from norm(). The array API norm is split</span>
<span class="s2"># into matrix_norm and vector_norm().</span>

<span class="s2"># The type for ord should be Optional[Union[int, float, Literal[np.inf,</span>
<span class="s2"># -np.inf]]] but Literal does not support floating-point literals.</span>
<span class="s0">def </span><span class="s1">vector_norm(x: Array</span><span class="s0">, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis: Optional[Union[int</span><span class="s0">, </span><span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int]]] = </span><span class="s0">None, </span><span class="s1">keepdims: bool = </span><span class="s0">False, </span><span class="s1">ord: Optional[Union[int</span><span class="s0">, </span><span class="s1">float]] = </span><span class="s5">2</span><span class="s1">) -&gt; Array:</span>
    <span class="s3">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.norm &lt;numpy.linalg.norm&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s2"># np.linalg.norm.</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Only floating-point dtypes are allowed in norm'</span><span class="s1">)</span>

    <span class="s1">a = x._array</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">a = a.flatten()</span>
        <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s0">elif </span><span class="s1">isinstance(axis</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s2"># Note: The axis argument supports any number of axes, whereas norm()</span>
        <span class="s2"># only supports a single axis for vector norm.</span>
        <span class="s1">rest = tuple(i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(a.ndim) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">axis)</span>
        <span class="s1">newshape = axis + rest</span>
        <span class="s1">a = np.transpose(a</span><span class="s0">, </span><span class="s1">newshape).reshape((np.prod([a.shape[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axis])</span><span class="s0">, </span><span class="s1">*[a.shape[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rest]))</span>
        <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s0">return </span><span class="s1">Array._new(np.linalg.norm(a</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">keepdims=keepdims</span><span class="s0">, </span><span class="s1">ord=ord))</span>


<span class="s1">__all__ = [</span><span class="s4">'cholesky'</span><span class="s0">, </span><span class="s4">'cross'</span><span class="s0">, </span><span class="s4">'det'</span><span class="s0">, </span><span class="s4">'diagonal'</span><span class="s0">, </span><span class="s4">'eigh'</span><span class="s0">, </span><span class="s4">'eigvalsh'</span><span class="s0">, </span><span class="s4">'inv'</span><span class="s0">, </span><span class="s4">'matmul'</span><span class="s0">, </span><span class="s4">'matrix_norm'</span><span class="s0">, </span><span class="s4">'matrix_power'</span><span class="s0">, </span><span class="s4">'matrix_rank'</span><span class="s0">, </span><span class="s4">'matrix_transpose'</span><span class="s0">, </span><span class="s4">'outer'</span><span class="s0">, </span><span class="s4">'pinv'</span><span class="s0">, </span><span class="s4">'qr'</span><span class="s0">, </span><span class="s4">'slogdet'</span><span class="s0">, </span><span class="s4">'solve'</span><span class="s0">, </span><span class="s4">'svd'</span><span class="s0">, </span><span class="s4">'svdvals'</span><span class="s0">, </span><span class="s4">'tensordot'</span><span class="s0">, </span><span class="s4">'trace'</span><span class="s0">, </span><span class="s4">'vecdot'</span><span class="s0">, </span><span class="s4">'vector_norm'</span><span class="s1">]</span>
</pre>
</body>
</html>