<html>
<head>
<title>meta.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
meta.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Functions that expose information about templates that might be 
interesting for introspection. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">.compiler </span><span class="s2">import </span><span class="s1">CodeGenerator</span>
<span class="s2">from </span><span class="s1">.compiler </span><span class="s2">import </span><span class="s1">Frame</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>


<span class="s2">class </span><span class="s1">TrackingCodeGenerator(CodeGenerator):</span>
    <span class="s0">&quot;&quot;&quot;We abuse the code generator for introspection.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(environment</span><span class="s2">, </span><span class="s3">&quot;&lt;introspection&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;introspection&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.undeclared_identifiers: t.Set[str] = set()</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">x: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Don't write.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">enter_frame(self</span><span class="s2">, </span><span class="s1">frame: Frame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Remember all undeclared identifiers.&quot;&quot;&quot;</span>
        <span class="s1">super().enter_frame(frame)</span>

        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">(action</span><span class="s2">, </span><span class="s1">param) </span><span class="s2">in </span><span class="s1">frame.symbols.loads.items():</span>
            <span class="s2">if </span><span class="s1">action == </span><span class="s3">&quot;resolve&quot; </span><span class="s2">and </span><span class="s1">param </span><span class="s2">not in </span><span class="s1">self.environment.globals:</span>
                <span class="s1">self.undeclared_identifiers.add(param)</span>


<span class="s2">def </span><span class="s1">find_undeclared_variables(ast: nodes.Template) -&gt; t.Set[str]:</span>
    <span class="s0">&quot;&quot;&quot;Returns a set of all variables in the AST that will be looked up from 
    the context at runtime.  Because at compile time it's not known which 
    variables will be used depending on the path the execution takes at 
    runtime, all variables are returned. 
 
    &gt;&gt;&gt; from jinja2 import Environment, meta 
    &gt;&gt;&gt; env = Environment() 
    &gt;&gt;&gt; ast = env.parse('{% set foo = 42 %}{{ bar + foo }}') 
    &gt;&gt;&gt; meta.find_undeclared_variables(ast) == {'bar'} 
    True 
 
    .. admonition:: Implementation 
 
       Internally the code generator is used for finding undeclared variables. 
       This is good to know because the code generator might raise a 
       :exc:`TemplateAssertionError` during compilation and as a matter of 
       fact this function can currently raise that exception as well. 
    &quot;&quot;&quot;</span>
    <span class="s1">codegen = TrackingCodeGenerator(ast.environment)  </span><span class="s4"># type: ignore</span>
    <span class="s1">codegen.visit(ast)</span>
    <span class="s2">return </span><span class="s1">codegen.undeclared_identifiers</span>


<span class="s1">_ref_types = (nodes.Extends</span><span class="s2">, </span><span class="s1">nodes.FromImport</span><span class="s2">, </span><span class="s1">nodes.Import</span><span class="s2">, </span><span class="s1">nodes.Include)</span>
<span class="s1">_RefType = t.Union[nodes.Extends</span><span class="s2">, </span><span class="s1">nodes.FromImport</span><span class="s2">, </span><span class="s1">nodes.Import</span><span class="s2">, </span><span class="s1">nodes.Include]</span>


<span class="s2">def </span><span class="s1">find_referenced_templates(ast: nodes.Template) -&gt; t.Iterator[t.Optional[str]]:</span>
    <span class="s0">&quot;&quot;&quot;Finds all the referenced templates from the AST.  This will return an 
    iterator over all the hardcoded template extensions, inclusions and 
    imports.  If dynamic inheritance or inclusion is used, `None` will be 
    yielded. 
 
    &gt;&gt;&gt; from jinja2 import Environment, meta 
    &gt;&gt;&gt; env = Environment() 
    &gt;&gt;&gt; ast = env.parse('{% extends &quot;layout.html&quot; %}{% include helper %}') 
    &gt;&gt;&gt; list(meta.find_referenced_templates(ast)) 
    ['layout.html', None] 
 
    This function is useful for dependency tracking.  For example if you want 
    to rebuild parts of the website after a layout template has changed. 
    &quot;&quot;&quot;</span>
    <span class="s1">template_name: t.Any</span>

    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">ast.find_all(_ref_types):</span>
        <span class="s1">template: nodes.Expr = node.template  </span><span class="s4"># type: ignore</span>

        <span class="s2">if not </span><span class="s1">isinstance(template</span><span class="s2">, </span><span class="s1">nodes.Const):</span>
            <span class="s4"># a tuple with some non consts in there</span>
            <span class="s2">if </span><span class="s1">isinstance(template</span><span class="s2">, </span><span class="s1">(nodes.Tuple</span><span class="s2">, </span><span class="s1">nodes.List)):</span>
                <span class="s2">for </span><span class="s1">template_name </span><span class="s2">in </span><span class="s1">template.items:</span>
                    <span class="s4"># something const, only yield the strings and ignore</span>
                    <span class="s4"># non-string consts that really just make no sense</span>
                    <span class="s2">if </span><span class="s1">isinstance(template_name</span><span class="s2">, </span><span class="s1">nodes.Const):</span>
                        <span class="s2">if </span><span class="s1">isinstance(template_name.value</span><span class="s2">, </span><span class="s1">str):</span>
                            <span class="s2">yield </span><span class="s1">template_name.value</span>
                    <span class="s4"># something dynamic in there</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">yield None</span>
            <span class="s4"># something dynamic we don't know about here</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield None</span>
            <span class="s2">continue</span>
        <span class="s4"># constant is a basestring, direct template name</span>
        <span class="s2">if </span><span class="s1">isinstance(template.value</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">yield </span><span class="s1">template.value</span>
        <span class="s4"># a tuple or list (latter *should* not happen) made of consts,</span>
        <span class="s4"># yield the consts that are strings.  We could warn here for</span>
        <span class="s4"># non string values</span>
        <span class="s2">elif </span><span class="s1">isinstance(node</span><span class="s2">, </span><span class="s1">nodes.Include) </span><span class="s2">and </span><span class="s1">isinstance(</span>
            <span class="s1">template.value</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">template_name </span><span class="s2">in </span><span class="s1">template.value:</span>
                <span class="s2">if </span><span class="s1">isinstance(template_name</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s2">yield </span><span class="s1">template_name</span>
        <span class="s4"># something else we don't care about, we could warn here</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield None</span>
</pre>
</body>
</html>