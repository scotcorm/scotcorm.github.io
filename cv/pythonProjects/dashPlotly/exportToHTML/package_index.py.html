<html>
<head>
<title>package_index.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
package_index.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;PyPI and direct package downloading&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">socket</span>
<span class="s2">import </span><span class="s1">base64</span>
<span class="s2">import </span><span class="s1">hashlib</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">configparser</span>
<span class="s2">import </span><span class="s1">html</span>
<span class="s2">import </span><span class="s1">http.client</span>
<span class="s2">import </span><span class="s1">urllib.parse</span>
<span class="s2">import </span><span class="s1">urllib.request</span>
<span class="s2">import </span><span class="s1">urllib.error</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span>

<span class="s2">import </span><span class="s1">setuptools</span>
<span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CHECKOUT_DIST</span><span class="s2">, </span><span class="s1">Distribution</span><span class="s2">, </span><span class="s1">BINARY_DIST</span><span class="s2">, </span><span class="s1">normalize_path</span><span class="s2">, </span><span class="s1">SOURCE_DIST</span><span class="s2">,</span>
    <span class="s1">Environment</span><span class="s2">, </span><span class="s1">find_distributions</span><span class="s2">, </span><span class="s1">safe_name</span><span class="s2">, </span><span class="s1">safe_version</span><span class="s2">,</span>
    <span class="s1">to_filename</span><span class="s2">, </span><span class="s1">Requirement</span><span class="s2">, </span><span class="s1">DEVELOP_DIST</span><span class="s2">, </span><span class="s1">EGG_DIST</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">ssl_support</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsError</span>
<span class="s2">from </span><span class="s1">fnmatch </span><span class="s2">import </span><span class="s1">translate</span>
<span class="s2">from </span><span class="s1">setuptools.wheel </span><span class="s2">import </span><span class="s1">Wheel</span>
<span class="s2">from </span><span class="s1">setuptools.extern.more_itertools </span><span class="s2">import </span><span class="s1">unique_everseen</span>


<span class="s1">EGG_FRAGMENT = re.compile(</span><span class="s3">r'^egg=([-A-Za-z0-9_.+!]+)$'</span><span class="s1">)</span>
<span class="s1">HREF = re.compile(</span><span class="s3">r&quot;&quot;&quot;href\s*=\s*['&quot;]?([^'&quot;&gt; ]+)&quot;&quot;&quot;</span><span class="s2">, </span><span class="s1">re.I)</span>
<span class="s1">PYPI_MD5 = re.compile(</span>
    <span class="s3">r'&lt;a href=&quot;([^&quot;#]+)&quot;&gt;([^&lt;]+)&lt;/a&gt;\n\s+\(&lt;a (?:title=&quot;MD5 hash&quot;\n\s+)'</span>
    <span class="s3">r'href=&quot;[^?]+\?:action=show_md5&amp;amp;digest=([0-9a-f]{32})&quot;&gt;md5&lt;/a&gt;\)'</span>
<span class="s1">)</span>
<span class="s1">URL_SCHEME = re.compile(</span><span class="s3">'([-+.a-z0-9]{2,}):'</span><span class="s2">, </span><span class="s1">re.I).match</span>
<span class="s1">EXTENSIONS = </span><span class="s3">&quot;.tar.gz .tar.bz2 .tar .zip .tgz&quot;</span><span class="s1">.split()</span>

<span class="s1">__all__ = [</span>
    <span class="s3">'PackageIndex'</span><span class="s2">, </span><span class="s3">'distros_for_url'</span><span class="s2">, </span><span class="s3">'parse_bdist_wininst'</span><span class="s2">,</span>
    <span class="s3">'interpret_distro_name'</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">_SOCKET_TIMEOUT = </span><span class="s4">15</span>

<span class="s1">_tmpl = </span><span class="s3">&quot;setuptools/{setuptools.__version__} Python-urllib/{py_major}&quot;</span>
<span class="s1">user_agent = _tmpl.format(</span>
    <span class="s1">py_major=</span><span class="s3">'{}.{}'</span><span class="s1">.format(*sys.version_info)</span><span class="s2">, </span><span class="s1">setuptools=setuptools)</span>


<span class="s2">def </span><span class="s1">parse_requirement_arg(spec):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">Requirement.parse(spec)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s2">raise </span><span class="s1">DistutilsError(</span>
            <span class="s3">&quot;Not a URL, existing file, or requirement spec: %r&quot; </span><span class="s1">% (spec</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">def </span><span class="s1">parse_bdist_wininst(name):</span>
    <span class="s0">&quot;&quot;&quot;Return (base,pyversion) or (None,None) for possible .exe name&quot;&quot;&quot;</span>

    <span class="s1">lower = name.lower()</span>
    <span class="s1">base</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">plat = </span><span class="s2">None, None, None</span>

    <span class="s2">if </span><span class="s1">lower.endswith(</span><span class="s3">'.exe'</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">lower.endswith(</span><span class="s3">'.win32.exe'</span><span class="s1">):</span>
            <span class="s1">base = name[:-</span><span class="s4">10</span><span class="s1">]</span>
            <span class="s1">plat = </span><span class="s3">'win32'</span>
        <span class="s2">elif </span><span class="s1">lower.startswith(</span><span class="s3">'.win32-py'</span><span class="s2">, </span><span class="s1">-</span><span class="s4">16</span><span class="s1">):</span>
            <span class="s1">py_ver = name[-</span><span class="s4">7</span><span class="s1">:-</span><span class="s4">4</span><span class="s1">]</span>
            <span class="s1">base = name[:-</span><span class="s4">16</span><span class="s1">]</span>
            <span class="s1">plat = </span><span class="s3">'win32'</span>
        <span class="s2">elif </span><span class="s1">lower.endswith(</span><span class="s3">'.win-amd64.exe'</span><span class="s1">):</span>
            <span class="s1">base = name[:-</span><span class="s4">14</span><span class="s1">]</span>
            <span class="s1">plat = </span><span class="s3">'win-amd64'</span>
        <span class="s2">elif </span><span class="s1">lower.startswith(</span><span class="s3">'.win-amd64-py'</span><span class="s2">, </span><span class="s1">-</span><span class="s4">20</span><span class="s1">):</span>
            <span class="s1">py_ver = name[-</span><span class="s4">7</span><span class="s1">:-</span><span class="s4">4</span><span class="s1">]</span>
            <span class="s1">base = name[:-</span><span class="s4">20</span><span class="s1">]</span>
            <span class="s1">plat = </span><span class="s3">'win-amd64'</span>
    <span class="s2">return </span><span class="s1">base</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">plat</span>


<span class="s2">def </span><span class="s1">egg_info_for_url(url):</span>
    <span class="s1">parts = urllib.parse.urlparse(url)</span>
    <span class="s1">scheme</span><span class="s2">, </span><span class="s1">server</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">fragment = parts</span>
    <span class="s1">base = urllib.parse.unquote(path.split(</span><span class="s3">'/'</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">server == </span><span class="s3">'sourceforge.net' </span><span class="s2">and </span><span class="s1">base == </span><span class="s3">'download'</span><span class="s1">:  </span><span class="s5"># XXX Yuck</span>
        <span class="s1">base = urllib.parse.unquote(path.split(</span><span class="s3">'/'</span><span class="s1">)[-</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s3">'#' </span><span class="s2">in </span><span class="s1">base:</span>
        <span class="s1">base</span><span class="s2">, </span><span class="s1">fragment = base.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fragment</span>


<span class="s2">def </span><span class="s1">distros_for_url(url</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Yield egg or source distribution objects that might be found at a URL&quot;&quot;&quot;</span>
    <span class="s1">base</span><span class="s2">, </span><span class="s1">fragment = egg_info_for_url(url)</span>
    <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">distros_for_location(url</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">metadata):</span>
        <span class="s2">yield </span><span class="s1">dist</span>
    <span class="s2">if </span><span class="s1">fragment:</span>
        <span class="s1">match = EGG_FRAGMENT.match(fragment)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">interpret_distro_name(</span>
                <span class="s1">url</span><span class="s2">, </span><span class="s1">match.group(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">precedence=CHECKOUT_DIST</span>
            <span class="s1">):</span>
                <span class="s2">yield </span><span class="s1">dist</span>


<span class="s2">def </span><span class="s1">distros_for_location(location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Yield egg or source distribution objects based on basename&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.egg.zip'</span><span class="s1">):</span>
        <span class="s1">basename = basename[:-</span><span class="s4">4</span><span class="s1">]  </span><span class="s5"># strip the .zip</span>
    <span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.egg'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'-' </span><span class="s2">in </span><span class="s1">basename:</span>
        <span class="s5"># only one, unambiguous interpretation</span>
        <span class="s2">return </span><span class="s1">[Distribution.from_location(location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata)]</span>
    <span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.whl'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'-' </span><span class="s2">in </span><span class="s1">basename:</span>
        <span class="s1">wheel = Wheel(basename)</span>
        <span class="s2">if not </span><span class="s1">wheel.is_compatible():</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[Distribution(</span>
            <span class="s1">location=location</span><span class="s2">,</span>
            <span class="s1">project_name=wheel.project_name</span><span class="s2">,</span>
            <span class="s1">version=wheel.version</span><span class="s2">,</span>
            <span class="s5"># Increase priority over eggs.</span>
            <span class="s1">precedence=EGG_DIST + </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">)]</span>
    <span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.exe'</span><span class="s1">):</span>
        <span class="s1">win_base</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">platform = parse_bdist_wininst(basename)</span>
        <span class="s2">if </span><span class="s1">win_base </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">interpret_distro_name(</span>
                <span class="s1">location</span><span class="s2">, </span><span class="s1">win_base</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">BINARY_DIST</span><span class="s2">, </span><span class="s1">platform</span>
            <span class="s1">)</span>
    <span class="s5"># Try source distro extensions (.zip, .tgz, etc.)</span>
    <span class="s5">#</span>
    <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">EXTENSIONS:</span>
        <span class="s2">if </span><span class="s1">basename.endswith(ext):</span>
            <span class="s1">basename = basename[:-len(ext)]</span>
            <span class="s2">return </span><span class="s1">interpret_distro_name(location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata)</span>
    <span class="s2">return </span><span class="s1">[]  </span><span class="s5"># no extension matched</span>


<span class="s2">def </span><span class="s1">distros_for_filename(filename</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Yield possible egg or source distribution objects based on a filename&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">distros_for_location(</span>
        <span class="s1">normalize_path(filename)</span><span class="s2">, </span><span class="s1">os.path.basename(filename)</span><span class="s2">, </span><span class="s1">metadata</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">interpret_distro_name(</span>
        <span class="s1">location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">py_version=</span><span class="s2">None, </span><span class="s1">precedence=SOURCE_DIST</span><span class="s2">,</span>
        <span class="s1">platform=</span><span class="s2">None</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Generate alternative interpretations of a source distro name 
 
    Note: if `location` is a filesystem filename, you should call 
    ``pkg_resources.normalize_path()`` on it before passing it to this 
    routine! 
    &quot;&quot;&quot;</span>
    <span class="s5"># Generate alternative interpretations of a source distro name</span>
    <span class="s5"># Because some packages are ambiguous as to name/versions split</span>
    <span class="s5"># e.g. &quot;adns-python-1.1.0&quot;, &quot;egenix-mx-commercial&quot;, etc.</span>
    <span class="s5"># So, we generate each possible interpretation (e.g. &quot;adns, python-1.1.0&quot;</span>
    <span class="s5"># &quot;adns-python, 1.1.0&quot;, and &quot;adns-python-1.1.0, no version&quot;).  In practice,</span>
    <span class="s5"># the spurious interpretations should be ignored, because in the event</span>
    <span class="s5"># there's also an &quot;adns&quot; package, the spurious &quot;python-1.1.0&quot; version will</span>
    <span class="s5"># compare lower than any numeric version number, and is therefore unlikely</span>
    <span class="s5"># to match a request for it.  It's still a potential problem, though, and</span>
    <span class="s5"># in the long run PyPI and the distutils should go for &quot;safe&quot; names and</span>
    <span class="s5"># versions in distribution archive names (sdist and bdist).</span>

    <span class="s1">parts = basename.split(</span><span class="s3">'-'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">py_version </span><span class="s2">and </span><span class="s1">any(re.match(</span><span class="s3">r'py\d\.\d$'</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">parts[</span><span class="s4">2</span><span class="s1">:]):</span>
        <span class="s5"># it is a bdist_dumb, not an sdist -- bail out</span>
        <span class="s2">return</span>

    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(parts) + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">yield </span><span class="s1">Distribution(</span>
            <span class="s1">location</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">.join(parts[:p])</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">.join(parts[p:])</span><span class="s2">,</span>
            <span class="s1">py_version=py_version</span><span class="s2">, </span><span class="s1">precedence=precedence</span><span class="s2">,</span>
            <span class="s1">platform=platform</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">unique_values(func):</span>
    <span class="s0">&quot;&quot;&quot; 
    Wrap a function returning an iterable such that the resulting iterable 
    only ever yields unique items. 
    &quot;&quot;&quot;</span>

    <span class="s1">@wraps(func)</span>
    <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">unique_everseen(func(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>

    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s1">REL = re.compile(</span><span class="s3">r&quot;&quot;&quot;&lt;([^&gt;]*\srel\s*=\s*['&quot;]?([^'&quot;&gt;]+)[^&gt;]*)&gt;&quot;&quot;&quot;</span><span class="s2">, </span><span class="s1">re.I)</span>
<span class="s5"># this line is here to fix emacs' cruddy broken syntax highlighting</span>


<span class="s1">@unique_values</span>
<span class="s2">def </span><span class="s1">find_external_links(url</span><span class="s2">, </span><span class="s1">page):</span>
    <span class="s0">&quot;&quot;&quot;Find rel=&quot;homepage&quot; and rel=&quot;download&quot; links in `page`, yielding URLs&quot;&quot;&quot;</span>

    <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">REL.finditer(page):</span>
        <span class="s1">tag</span><span class="s2">, </span><span class="s1">rel = match.groups()</span>
        <span class="s1">rels = set(map(str.strip</span><span class="s2">, </span><span class="s1">rel.lower().split(</span><span class="s3">','</span><span class="s1">)))</span>
        <span class="s2">if </span><span class="s3">'homepage' </span><span class="s2">in </span><span class="s1">rels </span><span class="s2">or </span><span class="s3">'download' </span><span class="s2">in </span><span class="s1">rels:</span>
            <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">HREF.finditer(tag):</span>
                <span class="s2">yield </span><span class="s1">urllib.parse.urljoin(url</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s4">1</span><span class="s1">)))</span>

    <span class="s2">for </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;&lt;th&gt;Home Page&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;th&gt;Download URL&quot;</span><span class="s1">):</span>
        <span class="s1">pos = page.find(tag)</span>
        <span class="s2">if </span><span class="s1">pos != -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">match = HREF.search(page</span><span class="s2">, </span><span class="s1">pos)</span>
            <span class="s2">if </span><span class="s1">match:</span>
                <span class="s2">yield </span><span class="s1">urllib.parse.urljoin(url</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s4">1</span><span class="s1">)))</span>


<span class="s2">class </span><span class="s1">ContentChecker:</span>
    <span class="s0">&quot;&quot;&quot; 
    A null content checker that defines the interface for checking content 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">feed(self</span><span class="s2">, </span><span class="s1">block):</span>
        <span class="s0">&quot;&quot;&quot; 
        Feed a block of data to the hash. 
        &quot;&quot;&quot;</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">is_valid(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check the hash. Return False if validation fails. 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">report(self</span><span class="s2">, </span><span class="s1">reporter</span><span class="s2">, </span><span class="s1">template):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call reporter with information about the checker (hash name) 
        substituted into the template. 
        &quot;&quot;&quot;</span>
        <span class="s2">return</span>


<span class="s2">class </span><span class="s1">HashChecker(ContentChecker):</span>
    <span class="s1">pattern = re.compile(</span>
        <span class="s3">r'(?P&lt;hash_name&gt;sha1|sha224|sha384|sha256|sha512|md5)='</span>
        <span class="s3">r'(?P&lt;expected&gt;[a-f0-9]+)'</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">hash_name</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">self.hash_name = hash_name</span>
        <span class="s1">self.hash = hashlib.new(hash_name)</span>
        <span class="s1">self.expected = expected</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_url(cls</span><span class="s2">, </span><span class="s1">url):</span>
        <span class="s0">&quot;Construct a (possibly null) ContentChecker from a URL&quot;</span>
        <span class="s1">fragment = urllib.parse.urlparse(url)[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">fragment:</span>
            <span class="s2">return </span><span class="s1">ContentChecker()</span>
        <span class="s1">match = cls.pattern.search(fragment)</span>
        <span class="s2">if not </span><span class="s1">match:</span>
            <span class="s2">return </span><span class="s1">ContentChecker()</span>
        <span class="s2">return </span><span class="s1">cls(**match.groupdict())</span>

    <span class="s2">def </span><span class="s1">feed(self</span><span class="s2">, </span><span class="s1">block):</span>
        <span class="s1">self.hash.update(block)</span>

    <span class="s2">def </span><span class="s1">is_valid(self):</span>
        <span class="s2">return </span><span class="s1">self.hash.hexdigest() == self.expected</span>

    <span class="s2">def </span><span class="s1">report(self</span><span class="s2">, </span><span class="s1">reporter</span><span class="s2">, </span><span class="s1">template):</span>
        <span class="s1">msg = template % self.hash_name</span>
        <span class="s2">return </span><span class="s1">reporter(msg)</span>


<span class="s2">class </span><span class="s1">PackageIndex(Environment):</span>
    <span class="s0">&quot;&quot;&quot;A distribution index that scans web pages for download URLs&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">index_url=</span><span class="s3">&quot;https://pypi.org/simple/&quot;</span><span class="s2">, </span><span class="s1">hosts=(</span><span class="s3">'*'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ca_bundle=</span><span class="s2">None, </span><span class="s1">verify_ssl=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">Environment.__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw)</span>
        <span class="s1">self.index_url = index_url + </span><span class="s3">&quot;/&quot; </span><span class="s1">[:</span><span class="s2">not </span><span class="s1">index_url.endswith(</span><span class="s3">'/'</span><span class="s1">)]</span>
        <span class="s1">self.scanned_urls = {}</span>
        <span class="s1">self.fetched_urls = {}</span>
        <span class="s1">self.package_pages = {}</span>
        <span class="s1">self.allows = re.compile(</span><span class="s3">'|'</span><span class="s1">.join(map(translate</span><span class="s2">, </span><span class="s1">hosts))).match</span>
        <span class="s1">self.to_scan = []</span>
        <span class="s1">use_ssl = (</span>
            <span class="s1">verify_ssl</span>
            <span class="s2">and </span><span class="s1">ssl_support.is_available</span>
            <span class="s2">and </span><span class="s1">(ca_bundle </span><span class="s2">or </span><span class="s1">ssl_support.find_ca_bundle())</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">use_ssl:</span>
            <span class="s1">self.opener = ssl_support.opener_for(ca_bundle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.opener = urllib.request.urlopen</span>

    <span class="s5"># FIXME: 'PackageIndex.process_url' is too complex (14)</span>
    <span class="s2">def </span><span class="s1">process_url(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">retrieve=</span><span class="s2">False</span><span class="s1">):  </span><span class="s5"># noqa: C901</span>
        <span class="s0">&quot;&quot;&quot;Evaluate a URL as a possible download, and maybe retrieve it&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">url </span><span class="s2">in </span><span class="s1">self.scanned_urls </span><span class="s2">and not </span><span class="s1">retrieve:</span>
            <span class="s2">return</span>
        <span class="s1">self.scanned_urls[url] = </span><span class="s2">True</span>
        <span class="s2">if not </span><span class="s1">URL_SCHEME(url):</span>
            <span class="s1">self.process_filename(url)</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dists = list(distros_for_url(url))</span>
            <span class="s2">if </span><span class="s1">dists:</span>
                <span class="s2">if not </span><span class="s1">self.url_ok(url):</span>
                    <span class="s2">return</span>
                <span class="s1">self.debug(</span><span class="s3">&quot;Found link: %s&quot;</span><span class="s2">, </span><span class="s1">url)</span>

        <span class="s2">if </span><span class="s1">dists </span><span class="s2">or not </span><span class="s1">retrieve </span><span class="s2">or </span><span class="s1">url </span><span class="s2">in </span><span class="s1">self.fetched_urls:</span>
            <span class="s1">list(map(self.add</span><span class="s2">, </span><span class="s1">dists))</span>
            <span class="s2">return  </span><span class="s5"># don't need the actual page</span>

        <span class="s2">if not </span><span class="s1">self.url_ok(url):</span>
            <span class="s1">self.fetched_urls[url] = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s1">self.info(</span><span class="s3">&quot;Reading %s&quot;</span><span class="s2">, </span><span class="s1">url)</span>
        <span class="s1">self.fetched_urls[url] = </span><span class="s2">True  </span><span class="s5"># prevent multiple fetch attempts</span>
        <span class="s1">tmpl = </span><span class="s3">&quot;Download error on %s: %%s -- Some packages may not be found!&quot;</span>
        <span class="s1">f = self.open_url(url</span><span class="s2">, </span><span class="s1">tmpl % url)</span>
        <span class="s2">if </span><span class="s1">f </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">urllib.error.HTTPError) </span><span class="s2">and </span><span class="s1">f.code == </span><span class="s4">401</span><span class="s1">:</span>
            <span class="s1">self.info(</span><span class="s3">&quot;Authentication error: %s&quot; </span><span class="s1">% f.msg)</span>
        <span class="s1">self.fetched_urls[f.url] = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s3">'html' </span><span class="s2">not in </span><span class="s1">f.headers.get(</span><span class="s3">'content-type'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).lower():</span>
            <span class="s1">f.close()  </span><span class="s5"># not html, we can't process it</span>
            <span class="s2">return</span>

        <span class="s1">base = f.url  </span><span class="s5"># handle redirects</span>
        <span class="s1">page = f.read()</span>
        <span class="s2">if not </span><span class="s1">isinstance(page</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s5"># In Python 3 and got bytes but want str.</span>
            <span class="s2">if </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">urllib.error.HTTPError):</span>
                <span class="s5"># Errors have no charset, assume latin1:</span>
                <span class="s1">charset = </span><span class="s3">'latin-1'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">charset = f.headers.get_param(</span><span class="s3">'charset'</span><span class="s1">) </span><span class="s2">or </span><span class="s3">'latin-1'</span>
            <span class="s1">page = page.decode(charset</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">f.close()</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">HREF.finditer(page):</span>
            <span class="s1">link = urllib.parse.urljoin(base</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s4">1</span><span class="s1">)))</span>
            <span class="s1">self.process_url(link)</span>
        <span class="s2">if </span><span class="s1">url.startswith(self.index_url) </span><span class="s2">and </span><span class="s1">getattr(f</span><span class="s2">, </span><span class="s3">'code'</span><span class="s2">, None</span><span class="s1">) != </span><span class="s4">404</span><span class="s1">:</span>
            <span class="s1">page = self.process_index(url</span><span class="s2">, </span><span class="s1">page)</span>

    <span class="s2">def </span><span class="s1">process_filename(self</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">nested=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5"># process filenames or directories</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(fn):</span>
            <span class="s1">self.warn(</span><span class="s3">&quot;Not found: %s&quot;</span><span class="s2">, </span><span class="s1">fn)</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">os.path.isdir(fn) </span><span class="s2">and not </span><span class="s1">nested:</span>
            <span class="s1">path = os.path.realpath(fn)</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">os.listdir(path):</span>
                <span class="s1">self.process_filename(os.path.join(path</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">dists = distros_for_filename(fn)</span>
        <span class="s2">if </span><span class="s1">dists:</span>
            <span class="s1">self.debug(</span><span class="s3">&quot;Found: %s&quot;</span><span class="s2">, </span><span class="s1">fn)</span>
            <span class="s1">list(map(self.add</span><span class="s2">, </span><span class="s1">dists))</span>

    <span class="s2">def </span><span class="s1">url_ok(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">fatal=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">s = URL_SCHEME(url)</span>
        <span class="s1">is_file = s </span><span class="s2">and </span><span class="s1">s.group(</span><span class="s4">1</span><span class="s1">).lower() == </span><span class="s3">'file'</span>
        <span class="s2">if </span><span class="s1">is_file </span><span class="s2">or </span><span class="s1">self.allows(urllib.parse.urlparse(url)[</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s2">return True</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">Note: Bypassing %s (disallowed host; see &quot;</span>
            <span class="s3">&quot;http://bit.ly/2hrImnY for details).</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fatal:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(msg % url)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.warn(msg</span><span class="s2">, </span><span class="s1">url)</span>

    <span class="s2">def </span><span class="s1">scan_egg_links(self</span><span class="s2">, </span><span class="s1">search_path):</span>
        <span class="s1">dirs = filter(os.path.isdir</span><span class="s2">, </span><span class="s1">search_path)</span>
        <span class="s1">egg_links = (</span>
            <span class="s1">(path</span><span class="s2">, </span><span class="s1">entry)</span>
            <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">dirs</span>
            <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">os.listdir(path)</span>
            <span class="s2">if </span><span class="s1">entry.endswith(</span><span class="s3">'.egg-link'</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">list(itertools.starmap(self.scan_egg_link</span><span class="s2">, </span><span class="s1">egg_links))</span>

    <span class="s2">def </span><span class="s1">scan_egg_link(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">entry):</span>
        <span class="s2">with </span><span class="s1">open(os.path.join(path</span><span class="s2">, </span><span class="s1">entry)) </span><span class="s2">as </span><span class="s1">raw_lines:</span>
            <span class="s5"># filter non-empty lines</span>
            <span class="s1">lines = list(filter(</span><span class="s2">None, </span><span class="s1">map(str.strip</span><span class="s2">, </span><span class="s1">raw_lines)))</span>

        <span class="s2">if </span><span class="s1">len(lines) != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s5"># format is not recognized; punt</span>
            <span class="s2">return</span>

        <span class="s1">egg_path</span><span class="s2">, </span><span class="s1">setup_path = lines</span>

        <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">find_distributions(os.path.join(path</span><span class="s2">, </span><span class="s1">egg_path)):</span>
            <span class="s1">dist.location = os.path.join(path</span><span class="s2">, </span><span class="s1">*lines)</span>
            <span class="s1">dist.precedence = SOURCE_DIST</span>
            <span class="s1">self.add(dist)</span>

    <span class="s2">def </span><span class="s1">_scan(self</span><span class="s2">, </span><span class="s1">link):</span>
        <span class="s5"># Process a URL to see if it's for a package page</span>
        <span class="s1">NO_MATCH_SENTINEL = </span><span class="s2">None, None</span>
        <span class="s2">if not </span><span class="s1">link.startswith(self.index_url):</span>
            <span class="s2">return </span><span class="s1">NO_MATCH_SENTINEL</span>

        <span class="s1">parts = list(map(</span>
            <span class="s1">urllib.parse.unquote</span><span class="s2">, </span><span class="s1">link[len(self.index_url):].split(</span><span class="s3">'/'</span><span class="s1">)</span>
        <span class="s1">))</span>
        <span class="s2">if </span><span class="s1">len(parts) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s3">'#' </span><span class="s2">in </span><span class="s1">parts[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">NO_MATCH_SENTINEL</span>

        <span class="s5"># it's a package page, sanitize and index it</span>
        <span class="s1">pkg = safe_name(parts[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">ver = safe_version(parts[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">self.package_pages.setdefault(pkg.lower()</span><span class="s2">, </span><span class="s1">{})[link] = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">to_filename(pkg)</span><span class="s2">, </span><span class="s1">to_filename(ver)</span>

    <span class="s2">def </span><span class="s1">process_index(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">page):</span>
        <span class="s0">&quot;&quot;&quot;Process the contents of a PyPI page&quot;&quot;&quot;</span>

        <span class="s5"># process an index page into the package-page index</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">HREF.finditer(page):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._scan(urllib.parse.urljoin(url</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s4">1</span><span class="s1">))))</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>

        <span class="s1">pkg</span><span class="s2">, </span><span class="s1">ver = self._scan(url)  </span><span class="s5"># ensure this page is in the page index</span>
        <span class="s2">if not </span><span class="s1">pkg:</span>
            <span class="s2">return </span><span class="s3">&quot;&quot;  </span><span class="s5"># no sense double-scanning non-package pages</span>

        <span class="s5"># process individual package page</span>
        <span class="s2">for </span><span class="s1">new_url </span><span class="s2">in </span><span class="s1">find_external_links(url</span><span class="s2">, </span><span class="s1">page):</span>
            <span class="s5"># Process the found URL</span>
            <span class="s1">base</span><span class="s2">, </span><span class="s1">frag = egg_info_for_url(new_url)</span>
            <span class="s2">if </span><span class="s1">base.endswith(</span><span class="s3">'.py'</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">frag:</span>
                <span class="s2">if </span><span class="s1">ver:</span>
                    <span class="s1">new_url += </span><span class="s3">'#egg=%s-%s' </span><span class="s1">% (pkg</span><span class="s2">, </span><span class="s1">ver)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.need_version_info(url)</span>
            <span class="s1">self.scan_url(new_url)</span>

        <span class="s2">return </span><span class="s1">PYPI_MD5.sub(</span>
            <span class="s2">lambda </span><span class="s1">m: </span><span class="s3">'&lt;a href=&quot;%s#md5=%s&quot;&gt;%s&lt;/a&gt;' </span><span class="s1">% m.group(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">page</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">need_version_info(self</span><span class="s2">, </span><span class="s1">url):</span>
        <span class="s1">self.scan_all(</span>
            <span class="s3">&quot;Page at %s links to .py file(s) without version info; an index &quot;</span>
            <span class="s3">&quot;scan is required.&quot;</span><span class="s2">, </span><span class="s1">url</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">scan_all(self</span><span class="s2">, </span><span class="s1">msg=</span><span class="s2">None, </span><span class="s1">*args):</span>
        <span class="s2">if </span><span class="s1">self.index_url </span><span class="s2">not in </span><span class="s1">self.fetched_urls:</span>
            <span class="s2">if </span><span class="s1">msg:</span>
                <span class="s1">self.warn(msg</span><span class="s2">, </span><span class="s1">*args)</span>
            <span class="s1">self.info(</span>
                <span class="s3">&quot;Scanning index of all packages (this may take a while)&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self.scan_url(self.index_url)</span>

    <span class="s2">def </span><span class="s1">find_packages(self</span><span class="s2">, </span><span class="s1">requirement):</span>
        <span class="s1">self.scan_url(self.index_url + requirement.unsafe_name + </span><span class="s3">'/'</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">self.package_pages.get(requirement.key):</span>
            <span class="s5"># Fall back to safe version of the name</span>
            <span class="s1">self.scan_url(self.index_url + requirement.project_name + </span><span class="s3">'/'</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">self.package_pages.get(requirement.key):</span>
            <span class="s5"># We couldn't find the target package, so search the index page too</span>
            <span class="s1">self.not_found_in_index(requirement)</span>

        <span class="s2">for </span><span class="s1">url </span><span class="s2">in </span><span class="s1">list(self.package_pages.get(requirement.key</span><span class="s2">, </span><span class="s1">())):</span>
            <span class="s5"># scan each page that might be related to the desired package</span>
            <span class="s1">self.scan_url(url)</span>

    <span class="s2">def </span><span class="s1">obtain(self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">installer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.prescan()</span>
        <span class="s1">self.find_packages(requirement)</span>
        <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">self[requirement.key]:</span>
            <span class="s2">if </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">requirement:</span>
                <span class="s2">return </span><span class="s1">dist</span>
            <span class="s1">self.debug(</span><span class="s3">&quot;%s does not match %s&quot;</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">dist)</span>
        <span class="s2">return </span><span class="s1">super(PackageIndex</span><span class="s2">, </span><span class="s1">self).obtain(requirement</span><span class="s2">, </span><span class="s1">installer)</span>

    <span class="s2">def </span><span class="s1">check_hash(self</span><span class="s2">, </span><span class="s1">checker</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">tfp):</span>
        <span class="s0">&quot;&quot;&quot; 
        checker is a ContentChecker 
        &quot;&quot;&quot;</span>
        <span class="s1">checker.report(</span>
            <span class="s1">self.debug</span><span class="s2">,</span>
            <span class="s3">&quot;Validating %%s checksum for %s&quot; </span><span class="s1">% filename)</span>
        <span class="s2">if not </span><span class="s1">checker.is_valid():</span>
            <span class="s1">tfp.close()</span>
            <span class="s1">os.unlink(filename)</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                <span class="s3">&quot;%s validation failed for %s; &quot;</span>
                <span class="s3">&quot;possible download problem?&quot;</span>
                <span class="s1">% (checker.hash.name</span><span class="s2">, </span><span class="s1">os.path.basename(filename))</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_find_links(self</span><span class="s2">, </span><span class="s1">urls):</span>
        <span class="s0">&quot;&quot;&quot;Add `urls` to the list that will be prescanned for searches&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">url </span><span class="s2">in </span><span class="s1">urls:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self.to_scan </span><span class="s2">is None  </span><span class="s5"># if we have already &quot;gone online&quot;</span>
                <span class="s2">or not </span><span class="s1">URL_SCHEME(url)  </span><span class="s5"># or it's a local file/directory</span>
                <span class="s2">or </span><span class="s1">url.startswith(</span><span class="s3">'file:'</span><span class="s1">)</span>
                <span class="s2">or </span><span class="s1">list(distros_for_url(url))  </span><span class="s5"># or a direct package link</span>
            <span class="s1">):</span>
                <span class="s5"># then go ahead and process it now</span>
                <span class="s1">self.scan_url(url)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># otherwise, defer retrieval till later</span>
                <span class="s1">self.to_scan.append(url)</span>

    <span class="s2">def </span><span class="s1">prescan(self):</span>
        <span class="s0">&quot;&quot;&quot;Scan urls scheduled for prescanning (e.g. --find-links)&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.to_scan:</span>
            <span class="s1">list(map(self.scan_url</span><span class="s2">, </span><span class="s1">self.to_scan))</span>
        <span class="s1">self.to_scan = </span><span class="s2">None  </span><span class="s5"># from now on, go ahead and process immediately</span>

    <span class="s2">def </span><span class="s1">not_found_in_index(self</span><span class="s2">, </span><span class="s1">requirement):</span>
        <span class="s2">if </span><span class="s1">self[requirement.key]:  </span><span class="s5"># we've seen at least one distro</span>
            <span class="s1">meth</span><span class="s2">, </span><span class="s1">msg = self.info</span><span class="s2">, </span><span class="s3">&quot;Couldn't retrieve index page for %r&quot;</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># no distros seen for this name, might be misspelled</span>
            <span class="s1">meth</span><span class="s2">, </span><span class="s1">msg = (</span>
                <span class="s1">self.warn</span><span class="s2">,</span>
                <span class="s3">&quot;Couldn't find index page for %r (maybe misspelled?)&quot;</span><span class="s1">)</span>
        <span class="s1">meth(msg</span><span class="s2">, </span><span class="s1">requirement.unsafe_name)</span>
        <span class="s1">self.scan_all()</span>

    <span class="s2">def </span><span class="s1">download(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">tmpdir):</span>
        <span class="s0">&quot;&quot;&quot;Locate and/or download `spec` to `tmpdir`, returning a local path 
 
        `spec` may be a ``Requirement`` object, or a string containing a URL, 
        an existing local filename, or a project/version requirement spec 
        (i.e. the string form of a ``Requirement`` object).  If it is the URL 
        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one 
        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is 
        automatically created alongside the downloaded file. 
 
        If `spec` is a ``Requirement`` object or a string containing a 
        project/version requirement spec, this method returns the location of 
        a matching distribution (possibly after downloading it to `tmpdir`). 
        If `spec` is a locally existing file or directory name, it is simply 
        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath 
        of `tmpdir`, and the local filename is returned.  Various errors may be 
        raised if a problem occurs during downloading. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(spec</span><span class="s2">, </span><span class="s1">Requirement):</span>
            <span class="s1">scheme = URL_SCHEME(spec)</span>
            <span class="s2">if </span><span class="s1">scheme:</span>
                <span class="s5"># It's a url, download it to tmpdir</span>
                <span class="s1">found = self._download_url(scheme.group(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">tmpdir)</span>
                <span class="s1">base</span><span class="s2">, </span><span class="s1">fragment = egg_info_for_url(spec)</span>
                <span class="s2">if </span><span class="s1">base.endswith(</span><span class="s3">'.py'</span><span class="s1">):</span>
                    <span class="s1">found = self.gen_setup(found</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">, </span><span class="s1">tmpdir)</span>
                <span class="s2">return </span><span class="s1">found</span>
            <span class="s2">elif </span><span class="s1">os.path.exists(spec):</span>
                <span class="s5"># Existing file or directory, just return it</span>
                <span class="s2">return </span><span class="s1">spec</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">spec = parse_requirement_arg(spec)</span>
        <span class="s2">return </span><span class="s1">getattr(self.fetch_distribution(spec</span><span class="s2">, </span><span class="s1">tmpdir)</span><span class="s2">, </span><span class="s3">'location'</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">fetch_distribution(  </span><span class="s5"># noqa: C901  # is too complex (14)  # FIXME</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">force_scan=</span><span class="s2">False, </span><span class="s1">source=</span><span class="s2">False,</span>
            <span class="s1">develop_ok=</span><span class="s2">False, </span><span class="s1">local_index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Obtain a distribution suitable for fulfilling `requirement` 
 
        `requirement` must be a ``pkg_resources.Requirement`` instance. 
        If necessary, or if the `force_scan` flag is set, the requirement is 
        searched for in the (online) package index as well as the locally 
        installed packages.  If a distribution matching `requirement` is found, 
        the returned distribution's ``location`` is the value you would have 
        gotten from calling the ``download()`` method with the matching 
        distribution's URL or filename.  If no matching distribution is found, 
        ``None`` is returned. 
 
        If the `source` flag is set, only source distributions and source 
        checkout links will be considered.  Unless the `develop_ok` flag is 
        set, development and system eggs (i.e., those using the ``.egg-info`` 
        format) will be ignored. 
        &quot;&quot;&quot;</span>
        <span class="s5"># process a Requirement</span>
        <span class="s1">self.info(</span><span class="s3">&quot;Searching for %s&quot;</span><span class="s2">, </span><span class="s1">requirement)</span>
        <span class="s1">skipped = {}</span>
        <span class="s1">dist = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">find(req</span><span class="s2">, </span><span class="s1">env=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">env </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">env = self</span>
            <span class="s5"># Find a matching distribution; may be called more than once</span>

            <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">env[req.key]:</span>

                <span class="s2">if </span><span class="s1">dist.precedence == DEVELOP_DIST </span><span class="s2">and not </span><span class="s1">develop_ok:</span>
                    <span class="s2">if </span><span class="s1">dist </span><span class="s2">not in </span><span class="s1">skipped:</span>
                        <span class="s1">self.warn(</span>
                            <span class="s3">&quot;Skipping development or system egg: %s&quot;</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">,</span>
                        <span class="s1">)</span>
                        <span class="s1">skipped[dist] = </span><span class="s4">1</span>
                    <span class="s2">continue</span>

                <span class="s1">test = (</span>
                    <span class="s1">dist </span><span class="s2">in </span><span class="s1">req</span>
                    <span class="s2">and </span><span class="s1">(dist.precedence &lt;= SOURCE_DIST </span><span class="s2">or not </span><span class="s1">source)</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">test:</span>
                    <span class="s1">loc = self.download(dist.location</span><span class="s2">, </span><span class="s1">tmpdir)</span>
                    <span class="s1">dist.download_location = loc</span>
                    <span class="s2">if </span><span class="s1">os.path.exists(dist.download_location):</span>
                        <span class="s2">return </span><span class="s1">dist</span>

        <span class="s2">if </span><span class="s1">force_scan:</span>
            <span class="s1">self.prescan()</span>
            <span class="s1">self.find_packages(requirement)</span>
            <span class="s1">dist = find(requirement)</span>

        <span class="s2">if not </span><span class="s1">dist </span><span class="s2">and </span><span class="s1">local_index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">dist = find(requirement</span><span class="s2">, </span><span class="s1">local_index)</span>

        <span class="s2">if </span><span class="s1">dist </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.to_scan </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.prescan()</span>
            <span class="s1">dist = find(requirement)</span>

        <span class="s2">if </span><span class="s1">dist </span><span class="s2">is None and not </span><span class="s1">force_scan:</span>
            <span class="s1">self.find_packages(requirement)</span>
            <span class="s1">dist = find(requirement)</span>

        <span class="s2">if </span><span class="s1">dist </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.warn(</span>
                <span class="s3">&quot;No local packages or working download links found for %s%s&quot;</span><span class="s2">,</span>
                <span class="s1">(source </span><span class="s2">and </span><span class="s3">&quot;a source distribution of &quot; </span><span class="s2">or </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">requirement</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.info(</span><span class="s3">&quot;Best match: %s&quot;</span><span class="s2">, </span><span class="s1">dist)</span>
            <span class="s2">return </span><span class="s1">dist.clone(location=dist.download_location)</span>

    <span class="s2">def </span><span class="s1">fetch(self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">force_scan=</span><span class="s2">False, </span><span class="s1">source=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Obtain a file suitable for fulfilling `requirement` 
 
        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For 
        backward compatibility, this routine is identical but returns the 
        ``location`` of the downloaded distribution instead of a distribution 
        object. 
        &quot;&quot;&quot;</span>
        <span class="s1">dist = self.fetch_distribution(requirement</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">force_scan</span><span class="s2">, </span><span class="s1">source)</span>
        <span class="s2">if </span><span class="s1">dist </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">dist.location</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">gen_setup(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">, </span><span class="s1">tmpdir):</span>
        <span class="s1">match = EGG_FRAGMENT.match(fragment)</span>
        <span class="s1">dists = match </span><span class="s2">and </span><span class="s1">[</span>
            <span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in</span>
            <span class="s1">interpret_distro_name(filename</span><span class="s2">, </span><span class="s1">match.group(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">if </span><span class="s1">d.version</span>
        <span class="s1">] </span><span class="s2">or </span><span class="s1">[]</span>

        <span class="s2">if </span><span class="s1">len(dists) == </span><span class="s4">1</span><span class="s1">:  </span><span class="s5"># unambiguous ``#egg`` fragment</span>
            <span class="s1">basename = os.path.basename(filename)</span>

            <span class="s5"># Make sure the file has been downloaded to the temp dir.</span>
            <span class="s2">if </span><span class="s1">os.path.dirname(filename) != tmpdir:</span>
                <span class="s1">dst = os.path.join(tmpdir</span><span class="s2">, </span><span class="s1">basename)</span>
                <span class="s2">from </span><span class="s1">setuptools.command.easy_install </span><span class="s2">import </span><span class="s1">samefile</span>
                <span class="s2">if not </span><span class="s1">samefile(filename</span><span class="s2">, </span><span class="s1">dst):</span>
                    <span class="s1">shutil.copy2(filename</span><span class="s2">, </span><span class="s1">dst)</span>
                    <span class="s1">filename = dst</span>

            <span class="s2">with </span><span class="s1">open(os.path.join(tmpdir</span><span class="s2">, </span><span class="s3">'setup.py'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">file:</span>
                <span class="s1">file.write(</span>
                    <span class="s3">&quot;from setuptools import setup</span><span class="s2">\n</span><span class="s3">&quot;</span>
                    <span class="s3">&quot;setup(name=%r, version=%r, py_modules=[%r])</span><span class="s2">\n</span><span class="s3">&quot;</span>
                    <span class="s1">% (</span>
                        <span class="s1">dists[</span><span class="s4">0</span><span class="s1">].project_name</span><span class="s2">, </span><span class="s1">dists[</span><span class="s4">0</span><span class="s1">].version</span><span class="s2">,</span>
                        <span class="s1">os.path.splitext(basename)[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">filename</span>

        <span class="s2">elif </span><span class="s1">match:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                <span class="s3">&quot;Can't unambiguously interpret project/version identifier %r; &quot;</span>
                <span class="s3">&quot;any dashes in the name or version should be escaped using &quot;</span>
                <span class="s3">&quot;underscores. %r&quot; </span><span class="s1">% (fragment</span><span class="s2">, </span><span class="s1">dists)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                <span class="s3">&quot;Can't process plain .py files without an '#egg=name-version'&quot;</span>
                <span class="s3">&quot; suffix to enable automatic setup script generation.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">dl_blocksize = </span><span class="s4">8192</span>

    <span class="s2">def </span><span class="s1">_download_to(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s1">self.info(</span><span class="s3">&quot;Downloading %s&quot;</span><span class="s2">, </span><span class="s1">url)</span>
        <span class="s5"># Download the file</span>
        <span class="s1">fp = </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">checker = HashChecker.from_url(url)</span>
            <span class="s1">fp = self.open_url(url)</span>
            <span class="s2">if </span><span class="s1">isinstance(fp</span><span class="s2">, </span><span class="s1">urllib.error.HTTPError):</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                    <span class="s3">&quot;Can't download %s: %s %s&quot; </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">fp.code</span><span class="s2">, </span><span class="s1">fp.msg)</span>
                <span class="s1">)</span>
            <span class="s1">headers = fp.info()</span>
            <span class="s1">blocknum = </span><span class="s4">0</span>
            <span class="s1">bs = self.dl_blocksize</span>
            <span class="s1">size = -</span><span class="s4">1</span>
            <span class="s2">if </span><span class="s3">&quot;content-length&quot; </span><span class="s2">in </span><span class="s1">headers:</span>
                <span class="s5"># Some servers return multiple Content-Length headers :(</span>
                <span class="s1">sizes = headers.get_all(</span><span class="s3">'Content-Length'</span><span class="s1">)</span>
                <span class="s1">size = max(map(int</span><span class="s2">, </span><span class="s1">sizes))</span>
                <span class="s1">self.reporthook(url</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">blocknum</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">size)</span>
            <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">tfp:</span>
                <span class="s2">while True</span><span class="s1">:</span>
                    <span class="s1">block = fp.read(bs)</span>
                    <span class="s2">if </span><span class="s1">block:</span>
                        <span class="s1">checker.feed(block)</span>
                        <span class="s1">tfp.write(block)</span>
                        <span class="s1">blocknum += </span><span class="s4">1</span>
                        <span class="s1">self.reporthook(url</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">blocknum</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">size)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">break</span>
                <span class="s1">self.check_hash(checker</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">tfp)</span>
            <span class="s2">return </span><span class="s1">headers</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">fp:</span>
                <span class="s1">fp.close()</span>

    <span class="s2">def </span><span class="s1">reporthook(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">blocknum</span><span class="s2">, </span><span class="s1">blksize</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s2">pass  </span><span class="s5"># no-op</span>

    <span class="s5"># FIXME:</span>
    <span class="s2">def </span><span class="s1">open_url(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">warning=</span><span class="s2">None</span><span class="s1">):  </span><span class="s5"># noqa: C901  # is too complex (12)</span>
        <span class="s2">if </span><span class="s1">url.startswith(</span><span class="s3">'file:'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">local_open(url)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">open_with_auth(url</span><span class="s2">, </span><span class="s1">self.opener)</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">http.client.InvalidURL) </span><span class="s2">as </span><span class="s1">v:</span>
            <span class="s1">msg = </span><span class="s3">' '</span><span class="s1">.join([str(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">v.args])</span>
            <span class="s2">if </span><span class="s1">warning:</span>
                <span class="s1">self.warn(warning</span><span class="s2">, </span><span class="s1">msg)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">'%s %s' </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">msg)) </span><span class="s2">from </span><span class="s1">v</span>
        <span class="s2">except </span><span class="s1">urllib.error.HTTPError </span><span class="s2">as </span><span class="s1">v:</span>
            <span class="s2">return </span><span class="s1">v</span>
        <span class="s2">except </span><span class="s1">urllib.error.URLError </span><span class="s2">as </span><span class="s1">v:</span>
            <span class="s2">if </span><span class="s1">warning:</span>
                <span class="s1">self.warn(warning</span><span class="s2">, </span><span class="s1">v.reason)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">&quot;Download error for %s: %s&quot;</span>
                                     <span class="s1">% (url</span><span class="s2">, </span><span class="s1">v.reason)) </span><span class="s2">from </span><span class="s1">v</span>
        <span class="s2">except </span><span class="s1">http.client.BadStatusLine </span><span class="s2">as </span><span class="s1">v:</span>
            <span class="s2">if </span><span class="s1">warning:</span>
                <span class="s1">self.warn(warning</span><span class="s2">, </span><span class="s1">v.line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                    <span class="s3">'%s returned a bad status line. The server might be '</span>
                    <span class="s3">'down, %s' </span><span class="s1">%</span>
                    <span class="s1">(url</span><span class="s2">, </span><span class="s1">v.line)</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">v</span>
        <span class="s2">except </span><span class="s1">(http.client.HTTPException</span><span class="s2">, </span><span class="s1">socket.error) </span><span class="s2">as </span><span class="s1">v:</span>
            <span class="s2">if </span><span class="s1">warning:</span>
                <span class="s1">self.warn(warning</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">&quot;Download error for %s: %s&quot;</span>
                                     <span class="s1">% (url</span><span class="s2">, </span><span class="s1">v)) </span><span class="s2">from </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">_download_url(self</span><span class="s2">, </span><span class="s1">scheme</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">tmpdir):</span>
        <span class="s5"># Determine download filename</span>
        <span class="s5">#</span>
        <span class="s1">name</span><span class="s2">, </span><span class="s1">fragment = egg_info_for_url(url)</span>
        <span class="s2">if </span><span class="s1">name:</span>
            <span class="s2">while </span><span class="s3">'..' </span><span class="s2">in </span><span class="s1">name:</span>
                <span class="s1">name = name.replace(</span><span class="s3">'..'</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">).replace(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">&quot;__downloaded__&quot;  </span><span class="s5"># default if URL has no path contents</span>

        <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'.egg.zip'</span><span class="s1">):</span>
            <span class="s1">name = name[:-</span><span class="s4">4</span><span class="s1">]  </span><span class="s5"># strip the extra .zip before download</span>

        <span class="s1">filename = os.path.join(tmpdir</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s5"># Download the file</span>
        <span class="s5">#</span>
        <span class="s2">if </span><span class="s1">scheme == </span><span class="s3">'svn' </span><span class="s2">or </span><span class="s1">scheme.startswith(</span><span class="s3">'svn+'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._download_svn(url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">elif </span><span class="s1">scheme == </span><span class="s3">'git' </span><span class="s2">or </span><span class="s1">scheme.startswith(</span><span class="s3">'git+'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._download_git(url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">elif </span><span class="s1">scheme.startswith(</span><span class="s3">'hg+'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._download_hg(url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">elif </span><span class="s1">scheme == </span><span class="s3">'file'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">urllib.request.url2pathname(urllib.parse.urlparse(url)[</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.url_ok(url</span><span class="s2">, True</span><span class="s1">)  </span><span class="s5"># raises error if not allowed</span>
            <span class="s2">return </span><span class="s1">self._attempt_download(url</span><span class="s2">, </span><span class="s1">filename)</span>

    <span class="s2">def </span><span class="s1">scan_url(self</span><span class="s2">, </span><span class="s1">url):</span>
        <span class="s1">self.process_url(url</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_attempt_download(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s1">headers = self._download_to(url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">if </span><span class="s3">'html' </span><span class="s2">in </span><span class="s1">headers.get(</span><span class="s3">'content-type'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).lower():</span>
            <span class="s2">return </span><span class="s1">self._download_html(url</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">_download_html(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s1">file = open(filename)</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">file:</span>
            <span class="s2">if </span><span class="s1">line.strip():</span>
                <span class="s5"># Check for a subversion index page</span>
                <span class="s2">if </span><span class="s1">re.search(</span><span class="s3">r'&lt;title&gt;([^- ]+ - )?Revision \d+:'</span><span class="s2">, </span><span class="s1">line):</span>
                    <span class="s5"># it's a subversion index page:</span>
                    <span class="s1">file.close()</span>
                    <span class="s1">os.unlink(filename)</span>
                    <span class="s2">return </span><span class="s1">self._download_svn(url</span><span class="s2">, </span><span class="s1">filename)</span>
                <span class="s2">break  </span><span class="s5"># not an index page</span>
        <span class="s1">file.close()</span>
        <span class="s1">os.unlink(filename)</span>
        <span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">&quot;Unexpected HTML page found at &quot; </span><span class="s1">+ url)</span>

    <span class="s2">def </span><span class="s1">_download_svn(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s1">warnings.warn(</span><span class="s3">&quot;SVN download support is deprecated&quot;</span><span class="s2">, </span><span class="s1">UserWarning)</span>
        <span class="s1">url = url.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]  </span><span class="s5"># remove any fragment for svn's sake</span>
        <span class="s1">creds = </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">url.lower().startswith(</span><span class="s3">'svn:'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'@' </span><span class="s2">in </span><span class="s1">url:</span>
            <span class="s1">scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">f = urllib.parse.urlparse(url)</span>
            <span class="s2">if not </span><span class="s1">netloc </span><span class="s2">and </span><span class="s1">path.startswith(</span><span class="s3">'//'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'/' </span><span class="s2">in </span><span class="s1">path[</span><span class="s4">2</span><span class="s1">:]:</span>
                <span class="s1">netloc</span><span class="s2">, </span><span class="s1">path = path[</span><span class="s4">2</span><span class="s1">:].split(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">auth</span><span class="s2">, </span><span class="s1">host = _splituser(netloc)</span>
                <span class="s2">if </span><span class="s1">auth:</span>
                    <span class="s2">if </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">auth:</span>
                        <span class="s1">user</span><span class="s2">, </span><span class="s1">pw = auth.split(</span><span class="s3">':'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s1">creds = </span><span class="s3">&quot; --username=%s --password=%s&quot; </span><span class="s1">% (user</span><span class="s2">, </span><span class="s1">pw)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">creds = </span><span class="s3">&quot; --username=&quot; </span><span class="s1">+ auth</span>
                    <span class="s1">netloc = host</span>
                    <span class="s1">parts = scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">f</span>
                    <span class="s1">url = urllib.parse.urlunparse(parts)</span>
        <span class="s1">self.info(</span><span class="s3">&quot;Doing subversion checkout from %s to %s&quot;</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">os.system(</span><span class="s3">&quot;svn checkout%s -q %s %s&quot; </span><span class="s1">% (creds</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename))</span>
        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_vcs_split_rev_from_url(url</span><span class="s2">, </span><span class="s1">pop_prefix=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = urllib.parse.urlsplit(url)</span>

        <span class="s1">scheme = scheme.split(</span><span class="s3">'+'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s5"># Some fragment identification fails</span>
        <span class="s1">path = path.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">rev = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s3">'@' </span><span class="s2">in </span><span class="s1">path:</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">rev = path.rsplit(</span><span class="s3">'@'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># Also, discard fragment</span>
        <span class="s1">url = urllib.parse.urlunsplit((scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>

        <span class="s2">return </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev</span>

    <span class="s2">def </span><span class="s1">_download_git(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s1">filename = filename.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">url</span><span class="s2">, </span><span class="s1">rev = self._vcs_split_rev_from_url(url</span><span class="s2">, </span><span class="s1">pop_prefix=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">self.info(</span><span class="s3">&quot;Doing git clone from %s to %s&quot;</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">os.system(</span><span class="s3">&quot;git clone --quiet %s %s&quot; </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">filename))</span>

        <span class="s2">if </span><span class="s1">rev </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.info(</span><span class="s3">&quot;Checking out %s&quot;</span><span class="s2">, </span><span class="s1">rev)</span>
            <span class="s1">os.system(</span><span class="s3">&quot;git -C %s checkout --quiet %s&quot; </span><span class="s1">% (</span>
                <span class="s1">filename</span><span class="s2">,</span>
                <span class="s1">rev</span><span class="s2">,</span>
            <span class="s1">))</span>

        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">_download_hg(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s1">filename = filename.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">url</span><span class="s2">, </span><span class="s1">rev = self._vcs_split_rev_from_url(url</span><span class="s2">, </span><span class="s1">pop_prefix=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">self.info(</span><span class="s3">&quot;Doing hg clone from %s to %s&quot;</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">os.system(</span><span class="s3">&quot;hg clone --quiet %s %s&quot; </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">filename))</span>

        <span class="s2">if </span><span class="s1">rev </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.info(</span><span class="s3">&quot;Updating to %s&quot;</span><span class="s2">, </span><span class="s1">rev)</span>
            <span class="s1">os.system(</span><span class="s3">&quot;hg --cwd %s up -C -r %s -q&quot; </span><span class="s1">% (</span>
                <span class="s1">filename</span><span class="s2">,</span>
                <span class="s1">rev</span><span class="s2">,</span>
            <span class="s1">))</span>

        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">debug(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">log.debug(msg</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">info(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">log.info(msg</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">warn(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">log.warn(msg</span><span class="s2">, </span><span class="s1">*args)</span>


<span class="s5"># This pattern matches a character entity reference (a decimal numeric</span>
<span class="s5"># references, a hexadecimal numeric reference, or a named reference).</span>
<span class="s1">entity_sub = re.compile(</span><span class="s3">r'&amp;(#(\d+|x[\da-fA-F]+)|[\w.:-]+);?'</span><span class="s1">).sub</span>


<span class="s2">def </span><span class="s1">decode_entity(match):</span>
    <span class="s1">what = match.group(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">html.unescape(what)</span>


<span class="s2">def </span><span class="s1">htmldecode(text):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decode HTML entities in the given text. 
 
    &gt;&gt;&gt; htmldecode( 
    ...     'https://../package_name-0.1.2.tar.gz' 
    ...     '?tokena=A&amp;amp;tokenb=B&quot;&gt;package_name-0.1.2.tar.gz') 
    'https://../package_name-0.1.2.tar.gz?tokena=A&amp;tokenb=B&quot;&gt;package_name-0.1.2.tar.gz' 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">entity_sub(decode_entity</span><span class="s2">, </span><span class="s1">text)</span>


<span class="s2">def </span><span class="s1">socket_timeout(timeout=</span><span class="s4">15</span><span class="s1">):</span>
    <span class="s2">def </span><span class="s1">_socket_timeout(func):</span>
        <span class="s2">def </span><span class="s1">_socket_timeout(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s1">old_timeout = socket.getdefaulttimeout()</span>
            <span class="s1">socket.setdefaulttimeout(timeout)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">socket.setdefaulttimeout(old_timeout)</span>

        <span class="s2">return </span><span class="s1">_socket_timeout</span>

    <span class="s2">return </span><span class="s1">_socket_timeout</span>


<span class="s2">def </span><span class="s1">_encode_auth(auth):</span>
    <span class="s0">&quot;&quot;&quot; 
    Encode auth from a URL suitable for an HTTP header. 
    &gt;&gt;&gt; str(_encode_auth('username%3Apassword')) 
    'dXNlcm5hbWU6cGFzc3dvcmQ=' 
 
    Long auth strings should not cause a newline to be inserted. 
    &gt;&gt;&gt; long_auth = 'username:' + 'password'*10 
    &gt;&gt;&gt; chr(10) in str(_encode_auth(long_auth)) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s1">auth_s = urllib.parse.unquote(auth)</span>
    <span class="s5"># convert to bytes</span>
    <span class="s1">auth_bytes = auth_s.encode()</span>
    <span class="s1">encoded_bytes = base64.b64encode(auth_bytes)</span>
    <span class="s5"># convert back to a string</span>
    <span class="s1">encoded = encoded_bytes.decode()</span>
    <span class="s5"># strip the trailing carriage return</span>
    <span class="s2">return </span><span class="s1">encoded.replace(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Credential:</span>
    <span class="s0">&quot;&quot;&quot; 
    A username/password pair. Use like a namedtuple. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">username</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s1">self.username = username</span>
        <span class="s1">self.password = password</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">yield </span><span class="s1">self.username</span>
        <span class="s2">yield </span><span class="s1">self.password</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">'%(username)s:%(password)s' </span><span class="s1">% vars(self)</span>


<span class="s2">class </span><span class="s1">PyPIConfig(configparser.RawConfigParser):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load from ~/.pypirc 
        &quot;&quot;&quot;</span>
        <span class="s1">defaults = dict.fromkeys([</span><span class="s3">'username'</span><span class="s2">, </span><span class="s3">'password'</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">configparser.RawConfigParser.__init__(self</span><span class="s2">, </span><span class="s1">defaults)</span>

        <span class="s1">rc = os.path.join(os.path.expanduser(</span><span class="s3">'~'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'.pypirc'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(rc):</span>
            <span class="s1">self.read(rc)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">creds_by_repository(self):</span>
        <span class="s1">sections_with_repositories = [</span>
            <span class="s1">section </span><span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">self.sections()</span>
            <span class="s2">if </span><span class="s1">self.get(section</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">).strip()</span>
        <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">dict(map(self._get_repo_cred</span><span class="s2">, </span><span class="s1">sections_with_repositories))</span>

    <span class="s2">def </span><span class="s1">_get_repo_cred(self</span><span class="s2">, </span><span class="s1">section):</span>
        <span class="s1">repo = self.get(section</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">).strip()</span>
        <span class="s2">return </span><span class="s1">repo</span><span class="s2">, </span><span class="s1">Credential(</span>
            <span class="s1">self.get(section</span><span class="s2">, </span><span class="s3">'username'</span><span class="s1">).strip()</span><span class="s2">,</span>
            <span class="s1">self.get(section</span><span class="s2">, </span><span class="s3">'password'</span><span class="s1">).strip()</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">find_credential(self</span><span class="s2">, </span><span class="s1">url):</span>
        <span class="s0">&quot;&quot;&quot; 
        If the URL indicated appears to be a repository defined in this 
        config, return the credential for that repository. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">repository</span><span class="s2">, </span><span class="s1">cred </span><span class="s2">in </span><span class="s1">self.creds_by_repository.items():</span>
            <span class="s2">if </span><span class="s1">url.startswith(repository):</span>
                <span class="s2">return </span><span class="s1">cred</span>


<span class="s2">def </span><span class="s1">open_with_auth(url</span><span class="s2">, </span><span class="s1">opener=urllib.request.urlopen):</span>
    <span class="s0">&quot;&quot;&quot;Open a urllib2 request, handling HTTP authentication&quot;&quot;&quot;</span>

    <span class="s1">parsed = urllib.parse.urlparse(url)</span>
    <span class="s1">scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = parsed</span>

    <span class="s5"># Double scheme does not raise on macOS as revealed by a</span>
    <span class="s5"># failing test. We would expect &quot;nonnumeric port&quot;. Refs #20.</span>
    <span class="s2">if </span><span class="s1">netloc.endswith(</span><span class="s3">':'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">http.client.InvalidURL(</span><span class="s3">&quot;nonnumeric port: ''&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'http'</span><span class="s2">, </span><span class="s3">'https'</span><span class="s1">):</span>
        <span class="s1">auth</span><span class="s2">, </span><span class="s1">address = _splituser(netloc)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">auth = </span><span class="s2">None</span>

    <span class="s2">if not </span><span class="s1">auth:</span>
        <span class="s1">cred = PyPIConfig().find_credential(url)</span>
        <span class="s2">if </span><span class="s1">cred:</span>
            <span class="s1">auth = str(cred)</span>
            <span class="s1">info = cred.username</span><span class="s2">, </span><span class="s1">url</span>
            <span class="s1">log.info(</span><span class="s3">'Authenticating as %s for %s (from .pypirc)'</span><span class="s2">, </span><span class="s1">*info)</span>

    <span class="s2">if </span><span class="s1">auth:</span>
        <span class="s1">auth = </span><span class="s3">&quot;Basic &quot; </span><span class="s1">+ _encode_auth(auth)</span>
        <span class="s1">parts = scheme</span><span class="s2">, </span><span class="s1">address</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag</span>
        <span class="s1">new_url = urllib.parse.urlunparse(parts)</span>
        <span class="s1">request = urllib.request.Request(new_url)</span>
        <span class="s1">request.add_header(</span><span class="s3">&quot;Authorization&quot;</span><span class="s2">, </span><span class="s1">auth)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">request = urllib.request.Request(url)</span>

    <span class="s1">request.add_header(</span><span class="s3">'User-Agent'</span><span class="s2">, </span><span class="s1">user_agent)</span>
    <span class="s1">fp = opener(request)</span>

    <span class="s2">if </span><span class="s1">auth:</span>
        <span class="s5"># Put authentication info back into request URL if same host,</span>
        <span class="s5"># so that links found on the page will work</span>
        <span class="s1">s2</span><span class="s2">, </span><span class="s1">h2</span><span class="s2">, </span><span class="s1">path2</span><span class="s2">, </span><span class="s1">param2</span><span class="s2">, </span><span class="s1">query2</span><span class="s2">, </span><span class="s1">frag2 = urllib.parse.urlparse(fp.url)</span>
        <span class="s2">if </span><span class="s1">s2 == scheme </span><span class="s2">and </span><span class="s1">h2 == address:</span>
            <span class="s1">parts = s2</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path2</span><span class="s2">, </span><span class="s1">param2</span><span class="s2">, </span><span class="s1">query2</span><span class="s2">, </span><span class="s1">frag2</span>
            <span class="s1">fp.url = urllib.parse.urlunparse(parts)</span>

    <span class="s2">return </span><span class="s1">fp</span>


<span class="s5"># copy of urllib.parse._splituser from Python 3.8</span>
<span class="s2">def </span><span class="s1">_splituser(host):</span>
    <span class="s0">&quot;&quot;&quot;splituser('user[:passwd]@host[:port]') 
    --&gt; 'user[:passwd]', 'host[:port]'.&quot;&quot;&quot;</span>
    <span class="s1">user</span><span class="s2">, </span><span class="s1">delim</span><span class="s2">, </span><span class="s1">host = host.rpartition(</span><span class="s3">'@'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(user </span><span class="s2">if </span><span class="s1">delim </span><span class="s2">else None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">host</span>


<span class="s5"># adding a timeout to avoid freezing package_index</span>
<span class="s1">open_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth)</span>


<span class="s2">def </span><span class="s1">fix_sf_url(url):</span>
    <span class="s2">return </span><span class="s1">url  </span><span class="s5"># backward compatibility</span>


<span class="s2">def </span><span class="s1">local_open(url):</span>
    <span class="s0">&quot;&quot;&quot;Read a local path, with special support for directories&quot;&quot;&quot;</span>
    <span class="s1">scheme</span><span class="s2">, </span><span class="s1">server</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">param</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = urllib.parse.urlparse(url)</span>
    <span class="s1">filename = urllib.request.url2pathname(path)</span>
    <span class="s2">if </span><span class="s1">os.path.isfile(filename):</span>
        <span class="s2">return </span><span class="s1">urllib.request.urlopen(url)</span>
    <span class="s2">elif </span><span class="s1">path.endswith(</span><span class="s3">'/'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">os.path.isdir(filename):</span>
        <span class="s1">files = []</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">os.listdir(filename):</span>
            <span class="s1">filepath = os.path.join(filename</span><span class="s2">, </span><span class="s1">f)</span>
            <span class="s2">if </span><span class="s1">f == </span><span class="s3">'index.html'</span><span class="s1">:</span>
                <span class="s2">with </span><span class="s1">open(filepath</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp:</span>
                    <span class="s1">body = fp.read()</span>
                <span class="s2">break</span>
            <span class="s2">elif </span><span class="s1">os.path.isdir(filepath):</span>
                <span class="s1">f += </span><span class="s3">'/'</span>
            <span class="s1">files.append(</span><span class="s3">'&lt;a href=&quot;{name}&quot;&gt;{name}&lt;/a&gt;'</span><span class="s1">.format(name=f))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tmpl = (</span>
                <span class="s3">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;{url}&lt;/title&gt;&quot;</span>
                <span class="s3">&quot;&lt;/head&gt;&lt;body&gt;{files}&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="s1">)</span>
            <span class="s1">body = tmpl.format(url=url</span><span class="s2">, </span><span class="s1">files=</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(files))</span>
        <span class="s1">status</span><span class="s2">, </span><span class="s1">message = </span><span class="s4">200</span><span class="s2">, </span><span class="s3">&quot;OK&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">status</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">body = </span><span class="s4">404</span><span class="s2">, </span><span class="s3">&quot;Path not found&quot;</span><span class="s2">, </span><span class="s3">&quot;Not found&quot;</span>

    <span class="s1">headers = {</span><span class="s3">'content-type'</span><span class="s1">: </span><span class="s3">'text/html'</span><span class="s1">}</span>
    <span class="s1">body_stream = io.StringIO(body)</span>
    <span class="s2">return </span><span class="s1">urllib.error.HTTPError(url</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">body_stream)</span>
</pre>
</body>
</html>