<html>
<head>
<title>stride_tricks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
stride_tricks.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Utilities that manipulate strides to achieve desirable effects. 
 
An explanation of strides can be found in the &quot;ndarray.rst&quot; file in the 
NumPy reference guide. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.core.numeric </span><span class="s2">import </span><span class="s1">normalize_axis_tuple</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">array_function_dispatch</span><span class="s2">, </span><span class="s1">set_module</span>

<span class="s1">__all__ = [</span><span class="s3">'broadcast_to'</span><span class="s2">, </span><span class="s3">'broadcast_arrays'</span><span class="s2">, </span><span class="s3">'broadcast_shapes'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">DummyArray:</span>
    <span class="s0">&quot;&quot;&quot;Dummy object that just exists to hang __array_interface__ dictionaries 
    and possibly keep alive a reference to a base array. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">interface</span><span class="s2">, </span><span class="s1">base=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.__array_interface__ = interface</span>
        <span class="s1">self.base = base</span>


<span class="s2">def </span><span class="s1">_maybe_view_as_subclass(original_array</span><span class="s2">, </span><span class="s1">new_array):</span>
    <span class="s2">if </span><span class="s1">type(original_array) </span><span class="s2">is not </span><span class="s1">type(new_array):</span>
        <span class="s4"># if input was an ndarray subclass and subclasses were OK,</span>
        <span class="s4"># then view the result as that subclass.</span>
        <span class="s1">new_array = new_array.view(type=type(original_array))</span>
        <span class="s4"># Since we have done something akin to a view from original_array, we</span>
        <span class="s4"># should let the subclass finalize (if it has it implemented, i.e., is</span>
        <span class="s4"># not None).</span>
        <span class="s2">if </span><span class="s1">new_array.__array_finalize__:</span>
            <span class="s1">new_array.__array_finalize__(original_array)</span>
    <span class="s2">return </span><span class="s1">new_array</span>


<span class="s2">def </span><span class="s1">as_strided(x</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None, </span><span class="s1">strides=</span><span class="s2">None, </span><span class="s1">subok=</span><span class="s2">False, </span><span class="s1">writeable=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a view into the array with the given shape and strides. 
 
    .. warning:: This function has to be used with extreme care, see notes. 
 
    Parameters 
    ---------- 
    x : ndarray 
        Array to create a new. 
    shape : sequence of int, optional 
        The shape of the new array. Defaults to ``x.shape``. 
    strides : sequence of int, optional 
        The strides of the new array. Defaults to ``x.strides``. 
    subok : bool, optional 
        .. versionadded:: 1.10 
 
        If True, subclasses are preserved. 
    writeable : bool, optional 
        .. versionadded:: 1.12 
 
        If set to False, the returned array will always be readonly. 
        Otherwise it will be writable if the original array was. It 
        is advisable to set this to False if possible (see Notes). 
 
    Returns 
    ------- 
    view : ndarray 
 
    See also 
    -------- 
    broadcast_to : broadcast an array to a given shape. 
    reshape : reshape an array. 
    lib.stride_tricks.sliding_window_view : 
        userfriendly and safe function for the creation of sliding window views. 
 
    Notes 
    ----- 
    ``as_strided`` creates a view into the array given the exact strides 
    and shape. This means it manipulates the internal data structure of 
    ndarray and, if done incorrectly, the array elements can point to 
    invalid memory and can corrupt results or crash your program. 
    It is advisable to always use the original ``x.strides`` when 
    calculating new strides to avoid reliance on a contiguous memory 
    layout. 
 
    Furthermore, arrays created with this function often contain self 
    overlapping memory, so that two elements are identical. 
    Vectorized write operations on such arrays will typically be 
    unpredictable. They may even give different results for small, large, 
    or transposed arrays. 
    Since writing to these arrays has to be tested and done with great 
    care, you may want to use ``writeable=False`` to avoid accidental write 
    operations. 
 
    For these reasons it is advisable to avoid ``as_strided`` when 
    possible. 
    &quot;&quot;&quot;</span>
    <span class="s4"># first convert input to array, possibly keeping subclass</span>
    <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=subok)</span>
    <span class="s1">interface = dict(x.__array_interface__)</span>
    <span class="s2">if </span><span class="s1">shape </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">interface[</span><span class="s3">'shape'</span><span class="s1">] = tuple(shape)</span>
    <span class="s2">if </span><span class="s1">strides </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">interface[</span><span class="s3">'strides'</span><span class="s1">] = tuple(strides)</span>

    <span class="s1">array = np.asarray(DummyArray(interface</span><span class="s2">, </span><span class="s1">base=x))</span>
    <span class="s4"># The route via `__interface__` does not preserve structured</span>
    <span class="s4"># dtypes. Since dtype should remain unchanged, we set it explicitly.</span>
    <span class="s1">array.dtype = x.dtype</span>

    <span class="s1">view = _maybe_view_as_subclass(x</span><span class="s2">, </span><span class="s1">array)</span>

    <span class="s2">if </span><span class="s1">view.flags.writeable </span><span class="s2">and not </span><span class="s1">writeable:</span>
        <span class="s1">view.flags.writeable = </span><span class="s2">False</span>

    <span class="s2">return </span><span class="s1">view</span>


<span class="s2">def </span><span class="s1">_sliding_window_view_dispatcher(x</span><span class="s2">, </span><span class="s1">window_shape</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
                                    <span class="s1">subok=</span><span class="s2">None, </span><span class="s1">writeable=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_sliding_window_view_dispatcher)</span>
<span class="s2">def </span><span class="s1">sliding_window_view(x</span><span class="s2">, </span><span class="s1">window_shape</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
                        <span class="s1">subok=</span><span class="s2">False, </span><span class="s1">writeable=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a sliding window view into the array with the given window shape. 
 
    Also known as rolling or moving window, the window slides across all 
    dimensions of the array and extracts subsets of the array at all window 
    positions. 
     
    .. versionadded:: 1.20.0 
 
    Parameters 
    ---------- 
    x : array_like 
        Array to create the sliding window view from. 
    window_shape : int or tuple of int 
        Size of window over each axis that takes part in the sliding window. 
        If `axis` is not present, must have same length as the number of input 
        array dimensions. Single integers `i` are treated as if they were the 
        tuple `(i,)`. 
    axis : int or tuple of int, optional 
        Axis or axes along which the sliding window is applied. 
        By default, the sliding window is applied to all axes and 
        `window_shape[i]` will refer to axis `i` of `x`. 
        If `axis` is given as a `tuple of int`, `window_shape[i]` will refer to 
        the axis `axis[i]` of `x`. 
        Single integers `i` are treated as if they were the tuple `(i,)`. 
    subok : bool, optional 
        If True, sub-classes will be passed-through, otherwise the returned 
        array will be forced to be a base-class array (default). 
    writeable : bool, optional 
        When true, allow writing to the returned view. The default is false, 
        as this should be used with caution: the returned view contains the 
        same memory location multiple times, so writing to one location will 
        cause others to change. 
 
    Returns 
    ------- 
    view : ndarray 
        Sliding window view of the array. The sliding window dimensions are 
        inserted at the end, and the original dimensions are trimmed as 
        required by the size of the sliding window. 
        That is, ``view.shape = x_shape_trimmed + window_shape``, where 
        ``x_shape_trimmed`` is ``x.shape`` with every entry reduced by one less 
        than the corresponding window size. 
 
    See Also 
    -------- 
    lib.stride_tricks.as_strided: A lower-level and less safe routine for 
        creating arbitrary views from custom shape and strides. 
    broadcast_to: broadcast an array to a given shape. 
 
    Notes 
    ----- 
    For many applications using a sliding window view can be convenient, but 
    potentially very slow. Often specialized solutions exist, for example: 
 
    - `scipy.signal.fftconvolve` 
 
    - filtering functions in `scipy.ndimage` 
 
    - moving window functions provided by 
      `bottleneck &lt;https://github.com/pydata/bottleneck&gt;`_. 
 
    As a rough estimate, a sliding window approach with an input size of `N` 
    and a window size of `W` will scale as `O(N*W)` where frequently a special 
    algorithm can achieve `O(N)`. That means that the sliding window variant 
    for a window size of 100 can be a 100 times slower than a more specialized 
    version. 
 
    Nevertheless, for small window sizes, when no custom algorithm exists, or 
    as a prototyping and developing tool, this function can be a good solution. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.arange(6) 
    &gt;&gt;&gt; x.shape 
    (6,) 
    &gt;&gt;&gt; v = sliding_window_view(x, 3) 
    &gt;&gt;&gt; v.shape 
    (4, 3) 
    &gt;&gt;&gt; v 
    array([[0, 1, 2], 
           [1, 2, 3], 
           [2, 3, 4], 
           [3, 4, 5]]) 
 
    This also works in more dimensions, e.g. 
 
    &gt;&gt;&gt; i, j = np.ogrid[:3, :4] 
    &gt;&gt;&gt; x = 10*i + j 
    &gt;&gt;&gt; x.shape 
    (3, 4) 
    &gt;&gt;&gt; x 
    array([[ 0,  1,  2,  3], 
           [10, 11, 12, 13], 
           [20, 21, 22, 23]]) 
    &gt;&gt;&gt; shape = (2,2) 
    &gt;&gt;&gt; v = sliding_window_view(x, shape) 
    &gt;&gt;&gt; v.shape 
    (2, 3, 2, 2) 
    &gt;&gt;&gt; v 
    array([[[[ 0,  1], 
             [10, 11]], 
            [[ 1,  2], 
             [11, 12]], 
            [[ 2,  3], 
             [12, 13]]], 
           [[[10, 11], 
             [20, 21]], 
            [[11, 12], 
             [21, 22]], 
            [[12, 13], 
             [22, 23]]]]) 
 
    The axis can be specified explicitly: 
 
    &gt;&gt;&gt; v = sliding_window_view(x, 3, 0) 
    &gt;&gt;&gt; v.shape 
    (1, 4, 3) 
    &gt;&gt;&gt; v 
    array([[[ 0, 10, 20], 
            [ 1, 11, 21], 
            [ 2, 12, 22], 
            [ 3, 13, 23]]]) 
 
    The same axis can be used several times. In that case, every use reduces 
    the corresponding original dimension: 
 
    &gt;&gt;&gt; v = sliding_window_view(x, (2, 3), (1, 1)) 
    &gt;&gt;&gt; v.shape 
    (3, 1, 2, 3) 
    &gt;&gt;&gt; v 
    array([[[[ 0,  1,  2], 
             [ 1,  2,  3]]], 
           [[[10, 11, 12], 
             [11, 12, 13]]], 
           [[[20, 21, 22], 
             [21, 22, 23]]]]) 
 
    Combining with stepped slicing (`::step`), this can be used to take sliding 
    views which skip elements: 
 
    &gt;&gt;&gt; x = np.arange(7) 
    &gt;&gt;&gt; sliding_window_view(x, 5)[:, ::2] 
    array([[0, 2, 4], 
           [1, 3, 5], 
           [2, 4, 6]]) 
 
    or views which move by multiple elements 
 
    &gt;&gt;&gt; x = np.arange(7) 
    &gt;&gt;&gt; sliding_window_view(x, 3)[::2, :] 
    array([[0, 1, 2], 
           [2, 3, 4], 
           [4, 5, 6]]) 
 
    A common application of `sliding_window_view` is the calculation of running 
    statistics. The simplest example is the 
    `moving average &lt;https://en.wikipedia.org/wiki/Moving_average&gt;`_: 
 
    &gt;&gt;&gt; x = np.arange(6) 
    &gt;&gt;&gt; x.shape 
    (6,) 
    &gt;&gt;&gt; v = sliding_window_view(x, 3) 
    &gt;&gt;&gt; v.shape 
    (4, 3) 
    &gt;&gt;&gt; v 
    array([[0, 1, 2], 
           [1, 2, 3], 
           [2, 3, 4], 
           [3, 4, 5]]) 
    &gt;&gt;&gt; moving_average = v.mean(axis=-1) 
    &gt;&gt;&gt; moving_average 
    array([1., 2., 3., 4.]) 
 
    Note that a sliding window approach is often **not** optimal (see Notes). 
    &quot;&quot;&quot;</span>
    <span class="s1">window_shape = (tuple(window_shape)</span>
                    <span class="s2">if </span><span class="s1">np.iterable(window_shape)</span>
                    <span class="s2">else </span><span class="s1">(window_shape</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s4"># first convert input to array, possibly keeping subclass</span>
    <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=subok)</span>

    <span class="s1">window_shape_array = np.array(window_shape)</span>
    <span class="s2">if </span><span class="s1">np.any(window_shape_array &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'`window_shape` cannot contain negative values'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">axis = tuple(range(x.ndim))</span>
        <span class="s2">if </span><span class="s1">len(window_shape) != len(axis):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Since axis is `None`, must provide '</span>
                             <span class="s3">f'window_shape for all dimensions of `x`; '</span>
                             <span class="s3">f'got </span><span class="s2">{</span><span class="s1">len(window_shape)</span><span class="s2">} </span><span class="s3">window_shape elements '</span>
                             <span class="s3">f'and `x.ndim` is </span><span class="s2">{</span><span class="s1">x.ndim</span><span class="s2">}</span><span class="s3">.'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">axis = normalize_axis_tuple(axis</span><span class="s2">, </span><span class="s1">x.ndim</span><span class="s2">, </span><span class="s1">allow_duplicate=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(window_shape) != len(axis):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Must provide matching length window_shape and '</span>
                             <span class="s3">f'axis; got </span><span class="s2">{</span><span class="s1">len(window_shape)</span><span class="s2">} </span><span class="s3">window_shape '</span>
                             <span class="s3">f'elements and </span><span class="s2">{</span><span class="s1">len(axis)</span><span class="s2">} </span><span class="s3">axes elements.'</span><span class="s1">)</span>

    <span class="s1">out_strides = x.strides + tuple(x.strides[ax] </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axis)</span>

    <span class="s4"># note: same axis can be windowed repeatedly</span>
    <span class="s1">x_shape_trimmed = list(x.shape)</span>
    <span class="s2">for </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">zip(axis</span><span class="s2">, </span><span class="s1">window_shape):</span>
        <span class="s2">if </span><span class="s1">x_shape_trimmed[ax] &lt; dim:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'window shape cannot be larger than input array shape'</span><span class="s1">)</span>
        <span class="s1">x_shape_trimmed[ax] -= dim - </span><span class="s5">1</span>
    <span class="s1">out_shape = tuple(x_shape_trimmed) + window_shape</span>
    <span class="s2">return </span><span class="s1">as_strided(x</span><span class="s2">, </span><span class="s1">strides=out_strides</span><span class="s2">, </span><span class="s1">shape=out_shape</span><span class="s2">,</span>
                      <span class="s1">subok=subok</span><span class="s2">, </span><span class="s1">writeable=writeable)</span>


<span class="s2">def </span><span class="s1">_broadcast_to(array</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">, </span><span class="s1">readonly):</span>
    <span class="s1">shape = tuple(shape) </span><span class="s2">if </span><span class="s1">np.iterable(shape) </span><span class="s2">else </span><span class="s1">(shape</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">array = np.array(array</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=subok)</span>
    <span class="s2">if not </span><span class="s1">shape </span><span class="s2">and </span><span class="s1">array.shape:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'cannot broadcast a non-scalar to a scalar array'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">any(size &lt; </span><span class="s5">0 </span><span class="s2">for </span><span class="s1">size </span><span class="s2">in </span><span class="s1">shape):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'all elements of broadcast shape must be non-'</span>
                         <span class="s3">'negative'</span><span class="s1">)</span>
    <span class="s1">extras = []</span>
    <span class="s1">it = np.nditer(</span>
        <span class="s1">(array</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">flags=[</span><span class="s3">'multi_index'</span><span class="s2">, </span><span class="s3">'refs_ok'</span><span class="s2">, </span><span class="s3">'zerosize_ok'</span><span class="s1">] + extras</span><span class="s2">,</span>
        <span class="s1">op_flags=[</span><span class="s3">'readonly'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">itershape=shape</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'C'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">it:</span>
        <span class="s4"># never really has writebackifcopy semantics</span>
        <span class="s1">broadcast = it.itviews[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">result = _maybe_view_as_subclass(array</span><span class="s2">, </span><span class="s1">broadcast)</span>
    <span class="s4"># In a future version this will go away</span>
    <span class="s2">if not </span><span class="s1">readonly </span><span class="s2">and </span><span class="s1">array.flags._writeable_no_warn:</span>
        <span class="s1">result.flags.writeable = </span><span class="s2">True</span>
        <span class="s1">result.flags._warn_on_write = </span><span class="s2">True</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_broadcast_to_dispatcher(array</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(array</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_broadcast_to_dispatcher</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">broadcast_to(array</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Broadcast an array to a new shape. 
 
    Parameters 
    ---------- 
    array : array_like 
        The array to broadcast. 
    shape : tuple or int 
        The shape of the desired array. A single integer ``i`` is interpreted 
        as ``(i,)``. 
    subok : bool, optional 
        If True, then sub-classes will be passed-through, otherwise 
        the returned array will be forced to be a base-class array (default). 
 
    Returns 
    ------- 
    broadcast : array 
        A readonly view on the original array with the given shape. It is 
        typically not contiguous. Furthermore, more than one element of a 
        broadcasted array may refer to a single memory location. 
 
    Raises 
    ------ 
    ValueError 
        If the array is not compatible with the new shape according to NumPy's 
        broadcasting rules. 
 
    See Also 
    -------- 
    broadcast 
    broadcast_arrays 
    broadcast_shapes 
 
    Notes 
    ----- 
    .. versionadded:: 1.10.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([1, 2, 3]) 
    &gt;&gt;&gt; np.broadcast_to(x, (3, 3)) 
    array([[1, 2, 3], 
           [1, 2, 3], 
           [1, 2, 3]]) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_broadcast_to(array</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">subok=subok</span><span class="s2">, </span><span class="s1">readonly=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_broadcast_shape(*args):</span>
    <span class="s0">&quot;&quot;&quot;Returns the shape of the arrays that would result from broadcasting the 
    supplied arrays against each other. 
    &quot;&quot;&quot;</span>
    <span class="s4"># use the old-iterator because np.nditer does not handle size 0 arrays</span>
    <span class="s4"># consistently</span>
    <span class="s1">b = np.broadcast(*args[:</span><span class="s5">32</span><span class="s1">])</span>
    <span class="s4"># unfortunately, it cannot handle 32 or more arguments directly</span>
    <span class="s2">for </span><span class="s1">pos </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">32</span><span class="s2">, </span><span class="s1">len(args)</span><span class="s2">, </span><span class="s5">31</span><span class="s1">):</span>
        <span class="s4"># ironically, np.broadcast does not properly handle np.broadcast</span>
        <span class="s4"># objects (it treats them as scalars)</span>
        <span class="s4"># use broadcasting to avoid allocating the full array</span>
        <span class="s1">b = broadcast_to(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b.shape)</span>
        <span class="s1">b = np.broadcast(b</span><span class="s2">, </span><span class="s1">*args[pos:(pos + </span><span class="s5">31</span><span class="s1">)])</span>
    <span class="s2">return </span><span class="s1">b.shape</span>


<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">broadcast_shapes(*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Broadcast the input shapes into a single shape. 
 
    :ref:`Learn more about broadcasting here &lt;basics.broadcasting&gt;`. 
 
    .. versionadded:: 1.20.0 
 
    Parameters 
    ---------- 
    `*args` : tuples of ints, or ints 
        The shapes to be broadcast against each other. 
 
    Returns 
    ------- 
    tuple 
        Broadcasted shape. 
 
    Raises 
    ------ 
    ValueError 
        If the shapes are not compatible and cannot be broadcast according 
        to NumPy's broadcasting rules. 
 
    See Also 
    -------- 
    broadcast 
    broadcast_arrays 
    broadcast_to 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.broadcast_shapes((1, 2), (3, 1), (3, 2)) 
    (3, 2) 
 
    &gt;&gt;&gt; np.broadcast_shapes((6, 7), (5, 6, 1), (7,), (5, 1, 7)) 
    (5, 6, 7) 
    &quot;&quot;&quot;</span>
    <span class="s1">arrays = [np.empty(x</span><span class="s2">, </span><span class="s1">dtype=[]) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args]</span>
    <span class="s2">return </span><span class="s1">_broadcast_shape(*arrays)</span>


<span class="s2">def </span><span class="s1">_broadcast_arrays_dispatcher(*args</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">args</span>


<span class="s1">@array_function_dispatch(_broadcast_arrays_dispatcher</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">broadcast_arrays(*args</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Broadcast any number of arrays against each other. 
 
    Parameters 
    ---------- 
    `*args` : array_likes 
        The arrays to broadcast. 
 
    subok : bool, optional 
        If True, then sub-classes will be passed-through, otherwise 
        the returned arrays will be forced to be a base-class array (default). 
 
    Returns 
    ------- 
    broadcasted : list of arrays 
        These arrays are views on the original arrays.  They are typically 
        not contiguous.  Furthermore, more than one element of a 
        broadcasted array may refer to a single memory location. If you need 
        to write to the arrays, make copies first. While you can set the 
        ``writable`` flag True, writing to a single output value may end up 
        changing more than one location in the output array. 
 
        .. deprecated:: 1.17 
            The output is currently marked so that if written to, a deprecation 
            warning will be emitted. A future version will set the 
            ``writable`` flag False so writing to it will raise an error. 
 
    See Also 
    -------- 
    broadcast 
    broadcast_to 
    broadcast_shapes 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([[1,2,3]]) 
    &gt;&gt;&gt; y = np.array([[4],[5]]) 
    &gt;&gt;&gt; np.broadcast_arrays(x, y) 
    [array([[1, 2, 3], 
           [1, 2, 3]]), array([[4, 4, 4], 
           [5, 5, 5]])] 
 
    Here is a useful idiom for getting contiguous copies instead of 
    non-contiguous views. 
 
    &gt;&gt;&gt; [np.array(a) for a in np.broadcast_arrays(x, y)] 
    [array([[1, 2, 3], 
           [1, 2, 3]]), array([[4, 4, 4], 
           [5, 5, 5]])] 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># nditer is not used here to avoid the limit of 32 arrays.</span>
    <span class="s4"># Otherwise, something like the following one-liner would suffice:</span>
    <span class="s4"># return np.nditer(args, flags=['multi_index', 'zerosize_ok'],</span>
    <span class="s4">#                  order='C').itviews</span>

    <span class="s1">args = [np.array(_m</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=subok) </span><span class="s2">for </span><span class="s1">_m </span><span class="s2">in </span><span class="s1">args]</span>

    <span class="s1">shape = _broadcast_shape(*args)</span>

    <span class="s2">if </span><span class="s1">all(array.shape == shape </span><span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">args):</span>
        <span class="s4"># Common case where nothing needs to be broadcasted.</span>
        <span class="s2">return </span><span class="s1">args</span>

    <span class="s2">return </span><span class="s1">[_broadcast_to(array</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">subok=subok</span><span class="s2">, </span><span class="s1">readonly=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">args]</span>
</pre>
</body>
</html>