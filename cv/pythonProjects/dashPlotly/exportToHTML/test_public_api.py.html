<html>
<head>
<title>test_public_api.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_public_api.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">sysconfig</span>
<span class="s0">import </span><span class="s1">subprocess</span>
<span class="s0">import </span><span class="s1">pkgutil</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">importlib</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">numpy</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">ctypes</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">ctypes = </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">check_dir(module</span><span class="s0">, </span><span class="s1">module_name=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Returns a mapping of all objects with the wrong __module__ attribute.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">module_name </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">module_name = module.__name__</span>
    <span class="s1">results = {}</span>
    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(module):</span>
        <span class="s1">item = getattr(module</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s0">if </span><span class="s1">(hasattr(item</span><span class="s0">, </span><span class="s3">'__module__'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">hasattr(item</span><span class="s0">, </span><span class="s3">'__name__'</span><span class="s1">)</span>
                <span class="s0">and </span><span class="s1">item.__module__ != module_name):</span>
            <span class="s1">results[name] = item.__module__ + </span><span class="s3">'.' </span><span class="s1">+ item.__name__</span>
    <span class="s0">return </span><span class="s1">results</span>


<span class="s0">def </span><span class="s1">test_numpy_namespace():</span>
    <span class="s4"># None of these objects are publicly documented to be part of the main</span>
    <span class="s4"># NumPy namespace (some are useful though, others need to be cleaned up)</span>
    <span class="s1">undocumented = {</span>
        <span class="s3">'Tester'</span><span class="s1">: </span><span class="s3">'numpy.testing._private.nosetester.NoseTester'</span><span class="s0">,</span>
        <span class="s3">'_add_newdoc_ufunc'</span><span class="s1">: </span><span class="s3">'numpy.core._multiarray_umath._add_newdoc_ufunc'</span><span class="s0">,</span>
        <span class="s3">'add_docstring'</span><span class="s1">: </span><span class="s3">'numpy.core._multiarray_umath.add_docstring'</span><span class="s0">,</span>
        <span class="s3">'add_newdoc'</span><span class="s1">: </span><span class="s3">'numpy.core.function_base.add_newdoc'</span><span class="s0">,</span>
        <span class="s3">'add_newdoc_ufunc'</span><span class="s1">: </span><span class="s3">'numpy.core._multiarray_umath._add_newdoc_ufunc'</span><span class="s0">,</span>
        <span class="s3">'byte_bounds'</span><span class="s1">: </span><span class="s3">'numpy.lib.utils.byte_bounds'</span><span class="s0">,</span>
        <span class="s3">'compare_chararrays'</span><span class="s1">: </span><span class="s3">'numpy.core._multiarray_umath.compare_chararrays'</span><span class="s0">,</span>
        <span class="s3">'deprecate'</span><span class="s1">: </span><span class="s3">'numpy.lib.utils.deprecate'</span><span class="s0">,</span>
        <span class="s3">'deprecate_with_doc'</span><span class="s1">: </span><span class="s3">'numpy.lib.utils.deprecate_with_doc'</span><span class="s0">,</span>
        <span class="s3">'disp'</span><span class="s1">: </span><span class="s3">'numpy.lib.function_base.disp'</span><span class="s0">,</span>
        <span class="s3">'fastCopyAndTranspose'</span><span class="s1">: </span><span class="s3">'numpy.core._multiarray_umath._fastCopyAndTranspose'</span><span class="s0">,</span>
        <span class="s3">'get_array_wrap'</span><span class="s1">: </span><span class="s3">'numpy.lib.shape_base.get_array_wrap'</span><span class="s0">,</span>
        <span class="s3">'get_include'</span><span class="s1">: </span><span class="s3">'numpy.lib.utils.get_include'</span><span class="s0">,</span>
        <span class="s3">'recfromcsv'</span><span class="s1">: </span><span class="s3">'numpy.lib.npyio.recfromcsv'</span><span class="s0">,</span>
        <span class="s3">'recfromtxt'</span><span class="s1">: </span><span class="s3">'numpy.lib.npyio.recfromtxt'</span><span class="s0">,</span>
        <span class="s3">'safe_eval'</span><span class="s1">: </span><span class="s3">'numpy.lib.utils.safe_eval'</span><span class="s0">,</span>
        <span class="s3">'set_string_function'</span><span class="s1">: </span><span class="s3">'numpy.core.arrayprint.set_string_function'</span><span class="s0">,</span>
        <span class="s3">'show_config'</span><span class="s1">: </span><span class="s3">'numpy.__config__.show'</span><span class="s0">,</span>
        <span class="s3">'who'</span><span class="s1">: </span><span class="s3">'numpy.lib.utils.who'</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s4"># We override dir to not show these members</span>
    <span class="s1">allowlist = undocumented</span>
    <span class="s1">bad_results = check_dir(np)</span>
    <span class="s4"># pytest gives better error messages with the builtin assert than with</span>
    <span class="s4"># assert_equal</span>
    <span class="s0">assert </span><span class="s1">bad_results == allowlist</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'name'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'testing'</span><span class="s0">, </span><span class="s3">'Tester'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_import_lazy_import(name):</span>
    <span class="s2">&quot;&quot;&quot;Make sure we can actually use the modules we lazy load. 
 
    While not exported as part of the public API, it was accessible.  With the 
    use of __getattr__ and __dir__, this isn't always true It can happen that 
    an infinite recursion may happen. 
 
    This is the only way I found that would force the failure to appear on the 
    badly implemented code. 
 
    We also test for the presence of the lazily imported modules in dir 
 
    &quot;&quot;&quot;</span>
    <span class="s1">exe = (sys.executable</span><span class="s0">, </span><span class="s3">'-c'</span><span class="s0">, </span><span class="s3">&quot;import numpy; numpy.&quot; </span><span class="s1">+ name)</span>
    <span class="s1">result = subprocess.check_output(exe)</span>
    <span class="s0">assert not </span><span class="s1">result</span>

    <span class="s4"># Make sure they are still in the __dir__</span>
    <span class="s0">assert </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(np)</span>


<span class="s0">def </span><span class="s1">test_dir_testing():</span>
    <span class="s2">&quot;&quot;&quot;Assert that output of dir has only one &quot;testing/tester&quot; 
    attribute without duplicate&quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">len(dir(np)) == len(set(dir(np)))</span>


<span class="s0">def </span><span class="s1">test_numpy_linalg():</span>
    <span class="s1">bad_results = check_dir(np.linalg)</span>
    <span class="s0">assert </span><span class="s1">bad_results == {}</span>


<span class="s0">def </span><span class="s1">test_numpy_fft():</span>
    <span class="s1">bad_results = check_dir(np.fft)</span>
    <span class="s0">assert </span><span class="s1">bad_results == {}</span>


<span class="s1">@pytest.mark.skipif(ctypes </span><span class="s0">is None,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;ctypes not available in this python&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_NPY_NO_EXPORT():</span>
    <span class="s1">cdll = ctypes.CDLL(np.core._multiarray_tests.__file__)</span>
    <span class="s4"># Make sure an arbitrary NPY_NO_EXPORT function is actually hidden</span>
    <span class="s1">f = getattr(cdll</span><span class="s0">, </span><span class="s3">'test_not_exported'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">f </span><span class="s0">is None, </span><span class="s1">(</span><span class="s3">&quot;'test_not_exported' is mistakenly exported, &quot;</span>
                      <span class="s3">&quot;NPY_NO_EXPORT does not work&quot;</span><span class="s1">)</span>


<span class="s4"># Historically NumPy has not used leading underscores for private submodules</span>
<span class="s4"># much.  This has resulted in lots of things that look like public modules</span>
<span class="s4"># (i.e. things that can be imported as `import numpy.somesubmodule.somefile`),</span>
<span class="s4"># but were never intended to be public.  The PUBLIC_MODULES list contains</span>
<span class="s4"># modules that are either public because they were meant to be, or because they</span>
<span class="s4"># contain public functions/objects that aren't present in any other namespace</span>
<span class="s4"># for whatever reason and therefore should be treated as public.</span>
<span class="s4">#</span>
<span class="s4"># The PRIVATE_BUT_PRESENT_MODULES list contains modules that look public (lack</span>
<span class="s4"># of underscores) but should not be used.  For many of those modules the</span>
<span class="s4"># current status is fine.  For others it may make sense to work on making them</span>
<span class="s4"># private, to clean up our public API and avoid confusion.</span>
<span class="s1">PUBLIC_MODULES = [</span><span class="s3">'numpy.' </span><span class="s1">+ s </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">[</span>
    <span class="s3">&quot;array_api&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;array_api.linalg&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ctypeslib&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.cpuinfo&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.exec_command&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.misc_util&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.log&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.system_info&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;doc&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;doc.constants&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;doc.ufuncs&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;fft&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.format&quot;</span><span class="s0">,  </span><span class="s4"># was this meant to be public?</span>
    <span class="s3">&quot;lib.mixins&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.recfunctions&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.scimath&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.stride_tricks&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;linalg&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma.extras&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma.mrecords&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;matlib&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.chebyshev&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.hermite&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.hermite_e&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.laguerre&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.legendre&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.polynomial&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;random&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;testing&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;typing&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;typing.mypy_plugin&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;version&quot;</span><span class="s0">,</span>
<span class="s1">]]</span>


<span class="s1">PUBLIC_ALIASED_MODULES = [</span>
    <span class="s3">&quot;numpy.char&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.emath&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.rec&quot;</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s1">PRIVATE_BUT_PRESENT_MODULES = [</span><span class="s3">'numpy.' </span><span class="s1">+ s </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">[</span>
    <span class="s3">&quot;compat&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;compat.py3k&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;conftest&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.arrayprint&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.defchararray&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.einsumfunc&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.fromnumeric&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.function_base&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.getlimits&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.memmap&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.multiarray&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.numeric&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.numerictypes&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.overrides&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.records&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.shape_base&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.umath&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;core.umath_tests&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.armccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.ccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">'distutils.ccompiler_opt'</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.autodist&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.bdist_rpm&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.build&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.build_clib&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.build_ext&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.build_py&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.build_scripts&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.build_src&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.config&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.config_compiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.develop&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.egg_info&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.install&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.install_clib&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.install_data&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.install_headers&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.command.sdist&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.conv_template&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.core&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.extension&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.absoft&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.arm&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.compaq&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.environment&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.g95&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.gnu&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.hpux&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.ibm&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.intel&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.lahey&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.mips&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.nag&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.none&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.pathf95&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.pg&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.nv&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.sun&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.vast&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.fcompiler.fujitsu&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.from_template&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.intelccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.lib2def&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.line_endings&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.mingw32ccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.msvccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.npy_pkg_config&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.numpy_distribution&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.pathccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;distutils.unixccompiler&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;dual&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.auxfuncs&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.capi_maps&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.cb_rules&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.cfuncs&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.common_rules&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.crackfortran&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.diagnose&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.f2py2e&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.f2py_testing&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.f90mod_rules&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.func2subr&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.rules&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.symbolic&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;f2py.use_rules&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;fft.helper&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.arraypad&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.arraysetops&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.arrayterator&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.function_base&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.histograms&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.index_tricks&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.nanfunctions&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.npyio&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.polynomial&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.shape_base&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.twodim_base&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.type_check&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.ufunclike&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;lib.user_array&quot;</span><span class="s0">,  </span><span class="s4"># note: not in np.lib, but probably should just be deleted</span>
    <span class="s3">&quot;lib.utils&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;linalg.lapack_lite&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;linalg.linalg&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma.bench&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma.core&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma.testutils&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ma.timer_comparison&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;matrixlib&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;matrixlib.defmatrix&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;polynomial.polyutils&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;random.mtrand&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;random.bit_generator&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;testing.print_coercion_tables&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;testing.utils&quot;</span><span class="s0">,</span>
<span class="s1">]]</span>


<span class="s0">def </span><span class="s1">is_unexpected(name):</span>
    <span class="s2">&quot;&quot;&quot;Check if this needs to be considered.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s3">'._' </span><span class="s0">in </span><span class="s1">name </span><span class="s0">or </span><span class="s3">'.tests' </span><span class="s0">in </span><span class="s1">name </span><span class="s0">or </span><span class="s3">'.setup' </span><span class="s0">in </span><span class="s1">name:</span>
        <span class="s0">return False</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">PUBLIC_MODULES:</span>
        <span class="s0">return False</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">PUBLIC_ALIASED_MODULES:</span>
        <span class="s0">return False</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">PRIVATE_BUT_PRESENT_MODULES:</span>
        <span class="s0">return False</span>

    <span class="s0">return True</span>


<span class="s4"># These are present in a directory with an __init__.py but cannot be imported</span>
<span class="s4"># code_generators/ isn't installed, but present for an inplace build</span>
<span class="s1">SKIP_LIST = [</span>
    <span class="s3">&quot;numpy.core.code_generators&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.code_generators.genapi&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.code_generators.generate_umath&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.code_generators.ufunc_docstrings&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.code_generators.generate_numpy_api&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.code_generators.generate_ufunc_api&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.code_generators.numpy_api&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.cversions&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.core.generate_numpy_api&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;numpy.distutils.msvc9compiler&quot;</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_all_modules_are_expected():</span>
    <span class="s2">&quot;&quot;&quot; 
    Test that we don't add anything that looks like a new public module by 
    accident.  Check is based on filenames. 
    &quot;&quot;&quot;</span>

    <span class="s1">modnames = []</span>
    <span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">modname</span><span class="s0">, </span><span class="s1">ispkg </span><span class="s0">in </span><span class="s1">pkgutil.walk_packages(path=np.__path__</span><span class="s0">,</span>
                                                   <span class="s1">prefix=np.__name__ + </span><span class="s3">'.'</span><span class="s0">,</span>
                                                   <span class="s1">onerror=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">is_unexpected(modname) </span><span class="s0">and </span><span class="s1">modname </span><span class="s0">not in </span><span class="s1">SKIP_LIST:</span>
            <span class="s4"># We have a name that is new.  If that's on purpose, add it to</span>
            <span class="s4"># PUBLIC_MODULES.  We don't expect to have to add anything to</span>
            <span class="s4"># PRIVATE_BUT_PRESENT_MODULES.  Use an underscore in the name!</span>
            <span class="s1">modnames.append(modname)</span>

    <span class="s0">if </span><span class="s1">modnames:</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">f'Found unexpected modules: </span><span class="s0">{</span><span class="s1">modnames</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>


<span class="s4"># Stuff that clearly shouldn't be in the API and is detected by the next test</span>
<span class="s4"># below</span>
<span class="s1">SKIP_LIST_2 = [</span>
    <span class="s3">'numpy.math'</span><span class="s0">,</span>
    <span class="s3">'numpy.distutils.log.sys'</span><span class="s0">,</span>
    <span class="s3">'numpy.doc.constants.re'</span><span class="s0">,</span>
    <span class="s3">'numpy.doc.constants.textwrap'</span><span class="s0">,</span>
    <span class="s3">'numpy.lib.emath'</span><span class="s0">,</span>
    <span class="s3">'numpy.lib.math'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.char'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.rec'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.emath'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.math'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.linalg'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.fft'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.random'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.ctypeslib'</span><span class="s0">,</span>
    <span class="s3">'numpy.matlib.ma'</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_all_modules_are_expected_2():</span>
    <span class="s2">&quot;&quot;&quot; 
    Method checking all objects. The pkgutil-based method in 
    `test_all_modules_are_expected` does not catch imports into a namespace, 
    only filenames.  So this test is more thorough, and checks this like: 
 
        import .lib.scimath as emath 
 
    To check if something in a module is (effectively) public, one can check if 
    there's anything in that namespace that's a public function/object but is 
    not exposed in a higher-level namespace.  For example for a `numpy.lib` 
    submodule:: 
 
        mod = np.lib.mixins 
        for obj in mod.__all__: 
            if obj in np.__all__: 
                continue 
            elif obj in np.lib.__all__: 
                continue 
 
            else: 
                print(obj) 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">find_unexpected_members(mod_name):</span>
        <span class="s1">members = []</span>
        <span class="s1">module = importlib.import_module(mod_name)</span>
        <span class="s0">if </span><span class="s1">hasattr(module</span><span class="s0">, </span><span class="s3">'__all__'</span><span class="s1">):</span>
            <span class="s1">objnames = module.__all__</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">objnames = dir(module)</span>

        <span class="s0">for </span><span class="s1">objname </span><span class="s0">in </span><span class="s1">objnames:</span>
            <span class="s0">if not </span><span class="s1">objname.startswith(</span><span class="s3">'_'</span><span class="s1">):</span>
                <span class="s1">fullobjname = mod_name + </span><span class="s3">'.' </span><span class="s1">+ objname</span>
                <span class="s0">if </span><span class="s1">isinstance(getattr(module</span><span class="s0">, </span><span class="s1">objname)</span><span class="s0">, </span><span class="s1">types.ModuleType):</span>
                    <span class="s0">if </span><span class="s1">is_unexpected(fullobjname):</span>
                        <span class="s0">if </span><span class="s1">fullobjname </span><span class="s0">not in </span><span class="s1">SKIP_LIST_2:</span>
                            <span class="s1">members.append(fullobjname)</span>

        <span class="s0">return </span><span class="s1">members</span>

    <span class="s1">unexpected_members = find_unexpected_members(</span><span class="s3">&quot;numpy&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">modname </span><span class="s0">in </span><span class="s1">PUBLIC_MODULES:</span>
        <span class="s1">unexpected_members.extend(find_unexpected_members(modname))</span>

    <span class="s0">if </span><span class="s1">unexpected_members:</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Found unexpected object(s) that look like &quot;</span>
                             <span class="s3">&quot;modules: {}&quot;</span><span class="s1">.format(unexpected_members))</span>


<span class="s0">def </span><span class="s1">test_api_importable():</span>
    <span class="s2">&quot;&quot;&quot; 
    Check that all submodules listed higher up in this file can be imported 
 
    Note that if a PRIVATE_BUT_PRESENT_MODULES entry goes missing, it may 
    simply need to be removed from the list (deprecation may or may not be 
    needed - apply common sense). 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">check_importable(module_name):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">importlib.import_module(module_name)</span>
        <span class="s0">except </span><span class="s1">(ImportError</span><span class="s0">, </span><span class="s1">AttributeError):</span>
            <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s1">module_names = []</span>
    <span class="s0">for </span><span class="s1">module_name </span><span class="s0">in </span><span class="s1">PUBLIC_MODULES:</span>
        <span class="s0">if not </span><span class="s1">check_importable(module_name):</span>
            <span class="s1">module_names.append(module_name)</span>

    <span class="s0">if </span><span class="s1">module_names:</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Modules in the public API that cannot be &quot;</span>
                             <span class="s3">&quot;imported: {}&quot;</span><span class="s1">.format(module_names))</span>

    <span class="s0">for </span><span class="s1">module_name </span><span class="s0">in </span><span class="s1">PUBLIC_ALIASED_MODULES:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">eval(module_name)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">module_names.append(module_name)</span>

    <span class="s0">if </span><span class="s1">module_names:</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Modules in the public API that were not &quot;</span>
                             <span class="s3">&quot;found: {}&quot;</span><span class="s1">.format(module_names))</span>

    <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
        <span class="s1">warnings.filterwarnings(</span><span class="s3">'always'</span><span class="s0">, </span><span class="s1">category=DeprecationWarning)</span>
        <span class="s1">warnings.filterwarnings(</span><span class="s3">'always'</span><span class="s0">, </span><span class="s1">category=ImportWarning)</span>
        <span class="s0">for </span><span class="s1">module_name </span><span class="s0">in </span><span class="s1">PRIVATE_BUT_PRESENT_MODULES:</span>
            <span class="s0">if not </span><span class="s1">check_importable(module_name):</span>
                <span class="s1">module_names.append(module_name)</span>

    <span class="s0">if </span><span class="s1">module_names:</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Modules that are not really public but looked &quot;</span>
                             <span class="s3">&quot;public and can not be imported: &quot;</span>
                             <span class="s3">&quot;{}&quot;</span><span class="s1">.format(module_names))</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">sysconfig.get_config_var(</span><span class="s3">&quot;Py_DEBUG&quot;</span><span class="s1">) </span><span class="s0">is not None,</span>
    <span class="s1">reason=(</span>
        <span class="s3">&quot;NumPy possibly built with `USE_DEBUG=True ./tools/travis-test.sh`, &quot;</span>
        <span class="s3">&quot;which does not expose the `array_api` entry point. &quot;</span>
        <span class="s3">&quot;See https://github.com/numpy/numpy/pull/19800&quot;</span>
    <span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_array_api_entry_point():</span>
    <span class="s2">&quot;&quot;&quot; 
    Entry point for Array API implementation can be found with importlib and 
    returns the numpy.array_api namespace. 
    &quot;&quot;&quot;</span>
    <span class="s1">eps = importlib.metadata.entry_points()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">xp_eps = eps.select(group=</span><span class="s3">&quot;array_api&quot;</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s4"># The select interface for entry_points was introduced in py3.10,</span>
        <span class="s4"># deprecating its dict interface. We fallback to dict keys for finding</span>
        <span class="s4"># Array API entry points so that running this test in &lt;=3.9 will</span>
        <span class="s4"># still work - see https://github.com/numpy/numpy/pull/19800.</span>
        <span class="s1">xp_eps = eps.get(</span><span class="s3">&quot;array_api&quot;</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">assert </span><span class="s1">len(xp_eps) &gt; </span><span class="s5">0</span><span class="s0">, </span><span class="s3">&quot;No entry points for 'array_api' found&quot;</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">ep = next(ep </span><span class="s0">for </span><span class="s1">ep </span><span class="s0">in </span><span class="s1">xp_eps </span><span class="s0">if </span><span class="s1">ep.name == </span><span class="s3">&quot;numpy&quot;</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;'numpy' not in array_api entry points&quot;</span><span class="s1">) </span><span class="s0">from None</span>

    <span class="s1">xp = ep.load()</span>
    <span class="s1">msg = (</span>
        <span class="s3">f&quot;numpy entry point value '</span><span class="s0">{</span><span class="s1">ep.value</span><span class="s0">}</span><span class="s3">' &quot;</span>
        <span class="s3">&quot;does not point to our Array API implementation&quot;</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">xp </span><span class="s0">is </span><span class="s1">numpy.array_api</span><span class="s0">, </span><span class="s1">msg</span>
</pre>
</body>
</html>