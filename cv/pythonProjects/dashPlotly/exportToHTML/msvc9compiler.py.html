<html>
<head>
<title>msvc9compiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
msvc9compiler.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.msvc9compiler 
 
Contains MSVCCompiler, an implementation of the abstract CCompiler class 
for the Microsoft Visual Studio 2008. 
 
The module is compatible with VS 2005 and VS 2008. You can find legacy support 
for older versions of VS in distutils.msvccompiler. 
&quot;&quot;&quot;</span>

<span class="s2"># Written by Perry Stoll</span>
<span class="s2"># hacked by Robin Becker and Thomas Heller to do a better job of</span>
<span class="s2">#   finding DevStudio (through the registry)</span>
<span class="s2"># ported to VS2005 and VS 2008 by Christian Heimes</span>

<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">subprocess</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">re</span>

<span class="s3">from </span><span class="s1">distutils.errors </span><span class="s3">import </span><span class="s1">DistutilsExecError</span><span class="s3">, </span><span class="s1">DistutilsPlatformError</span><span class="s3">, </span><span class="s1">\</span>
                             <span class="s1">CompileError</span><span class="s3">, </span><span class="s1">LibError</span><span class="s3">, </span><span class="s1">LinkError</span>
<span class="s3">from </span><span class="s1">distutils.ccompiler </span><span class="s3">import </span><span class="s1">CCompiler</span><span class="s3">, </span><span class="s1">gen_lib_options</span>
<span class="s3">from </span><span class="s1">distutils </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s1">distutils.util </span><span class="s3">import </span><span class="s1">get_platform</span>

<span class="s3">import </span><span class="s1">winreg</span>

<span class="s1">RegOpenKeyEx = winreg.OpenKeyEx</span>
<span class="s1">RegEnumKey = winreg.EnumKey</span>
<span class="s1">RegEnumValue = winreg.EnumValue</span>
<span class="s1">RegError = winreg.error</span>

<span class="s1">HKEYS = (winreg.HKEY_USERS</span><span class="s3">,</span>
         <span class="s1">winreg.HKEY_CURRENT_USER</span><span class="s3">,</span>
         <span class="s1">winreg.HKEY_LOCAL_MACHINE</span><span class="s3">,</span>
         <span class="s1">winreg.HKEY_CLASSES_ROOT)</span>

<span class="s1">NATIVE_WIN64 = (sys.platform == </span><span class="s4">'win32' </span><span class="s3">and </span><span class="s1">sys.maxsize &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32</span><span class="s1">)</span>
<span class="s3">if </span><span class="s1">NATIVE_WIN64:</span>
    <span class="s2"># Visual C++ is a 32-bit application, so we need to look in</span>
    <span class="s2"># the corresponding registry branch, if we're running a</span>
    <span class="s2"># 64-bit Python on Win64</span>
    <span class="s1">VS_BASE = </span><span class="s4">r&quot;Software\Wow6432Node\Microsoft\VisualStudio\%0.1f&quot;</span>
    <span class="s1">WINSDK_BASE = </span><span class="s4">r&quot;Software\Wow6432Node\Microsoft\Microsoft SDKs\Windows&quot;</span>
    <span class="s1">NET_BASE = </span><span class="s4">r&quot;Software\Wow6432Node\Microsoft\.NETFramework&quot;</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">VS_BASE = </span><span class="s4">r&quot;Software\Microsoft\VisualStudio\%0.1f&quot;</span>
    <span class="s1">WINSDK_BASE = </span><span class="s4">r&quot;Software\Microsoft\Microsoft SDKs\Windows&quot;</span>
    <span class="s1">NET_BASE = </span><span class="s4">r&quot;Software\Microsoft\.NETFramework&quot;</span>

<span class="s2"># A map keyed by get_platform() return values to values accepted by</span>
<span class="s2"># 'vcvarsall.bat'.  Note a cross-compile may combine these (eg, 'x86_amd64' is</span>
<span class="s2"># the param to cross-compile on x86 targeting amd64.)</span>
<span class="s1">PLAT_TO_VCVARS = {</span>
    <span class="s4">'win32' </span><span class="s1">: </span><span class="s4">'x86'</span><span class="s3">,</span>
    <span class="s4">'win-amd64' </span><span class="s1">: </span><span class="s4">'amd64'</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s3">class </span><span class="s1">Reg:</span>
    <span class="s0">&quot;&quot;&quot;Helper class to read values from the registry 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">get_value(cls</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">HKEYS:</span>
            <span class="s1">d = cls.read_values(base</span><span class="s3">, </span><span class="s1">path)</span>
            <span class="s3">if </span><span class="s1">d </span><span class="s3">and </span><span class="s1">key </span><span class="s3">in </span><span class="s1">d:</span>
                <span class="s3">return </span><span class="s1">d[key]</span>
        <span class="s3">raise </span><span class="s1">KeyError(key)</span>
    <span class="s1">get_value = classmethod(get_value)</span>

    <span class="s3">def </span><span class="s1">read_keys(cls</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot;Return list of registry keys.&quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">handle = RegOpenKeyEx(base</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s3">except </span><span class="s1">RegError:</span>
            <span class="s3">return None</span>
        <span class="s1">L = []</span>
        <span class="s1">i = </span><span class="s5">0</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">k = RegEnumKey(handle</span><span class="s3">, </span><span class="s1">i)</span>
            <span class="s3">except </span><span class="s1">RegError:</span>
                <span class="s3">break</span>
            <span class="s1">L.append(k)</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">L</span>
    <span class="s1">read_keys = classmethod(read_keys)</span>

    <span class="s3">def </span><span class="s1">read_values(cls</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot;Return dict of registry keys and values. 
 
        All names are converted to lowercase. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">handle = RegOpenKeyEx(base</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s3">except </span><span class="s1">RegError:</span>
            <span class="s3">return None</span>
        <span class="s1">d = {}</span>
        <span class="s1">i = </span><span class="s5">0</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">type = RegEnumValue(handle</span><span class="s3">, </span><span class="s1">i)</span>
            <span class="s3">except </span><span class="s1">RegError:</span>
                <span class="s3">break</span>
            <span class="s1">name = name.lower()</span>
            <span class="s1">d[cls.convert_mbcs(name)] = cls.convert_mbcs(value)</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">d</span>
    <span class="s1">read_values = classmethod(read_values)</span>

    <span class="s3">def </span><span class="s1">convert_mbcs(s):</span>
        <span class="s1">dec = getattr(s</span><span class="s3">, </span><span class="s4">&quot;decode&quot;</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">dec </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">s = dec(</span><span class="s4">&quot;mbcs&quot;</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">UnicodeError:</span>
                <span class="s3">pass</span>
        <span class="s3">return </span><span class="s1">s</span>
    <span class="s1">convert_mbcs = staticmethod(convert_mbcs)</span>

<span class="s3">class </span><span class="s1">MacroExpander:</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">version):</span>
        <span class="s1">self.macros = {}</span>
        <span class="s1">self.vsbase = VS_BASE % version</span>
        <span class="s1">self.load_macros(version)</span>

    <span class="s3">def </span><span class="s1">set_macro(self</span><span class="s3">, </span><span class="s1">macro</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">self.macros[</span><span class="s4">&quot;$(%s)&quot; </span><span class="s1">% macro] = Reg.get_value(path</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s3">def </span><span class="s1">load_macros(self</span><span class="s3">, </span><span class="s1">version):</span>
        <span class="s1">self.set_macro(</span><span class="s4">&quot;VCInstallDir&quot;</span><span class="s3">, </span><span class="s1">self.vsbase + </span><span class="s4">r&quot;\Setup\VC&quot;</span><span class="s3">, </span><span class="s4">&quot;productdir&quot;</span><span class="s1">)</span>
        <span class="s1">self.set_macro(</span><span class="s4">&quot;VSInstallDir&quot;</span><span class="s3">, </span><span class="s1">self.vsbase + </span><span class="s4">r&quot;\Setup\VS&quot;</span><span class="s3">, </span><span class="s4">&quot;productdir&quot;</span><span class="s1">)</span>
        <span class="s1">self.set_macro(</span><span class="s4">&quot;FrameworkDir&quot;</span><span class="s3">, </span><span class="s1">NET_BASE</span><span class="s3">, </span><span class="s4">&quot;installroot&quot;</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">version &gt;= </span><span class="s5">8.0</span><span class="s1">:</span>
                <span class="s1">self.set_macro(</span><span class="s4">&quot;FrameworkSDKDir&quot;</span><span class="s3">, </span><span class="s1">NET_BASE</span><span class="s3">,</span>
                               <span class="s4">&quot;sdkinstallrootv2.0&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">KeyError(</span><span class="s4">&quot;sdkinstallrootv2.0&quot;</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span>
            <span class="s4">&quot;&quot;&quot;Python was built with Visual Studio 2008; 
extensions must be built with a compiler than can generate compatible binaries. 
Visual Studio 2008 was not found on this system. If you have Cygwin installed, 
you can try compiling with MingW32, by passing &quot;-c mingw32&quot; to setup.py.&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">version &gt;= </span><span class="s5">9.0</span><span class="s1">:</span>
            <span class="s1">self.set_macro(</span><span class="s4">&quot;FrameworkVersion&quot;</span><span class="s3">, </span><span class="s1">self.vsbase</span><span class="s3">, </span><span class="s4">&quot;clr version&quot;</span><span class="s1">)</span>
            <span class="s1">self.set_macro(</span><span class="s4">&quot;WindowsSdkDir&quot;</span><span class="s3">, </span><span class="s1">WINSDK_BASE</span><span class="s3">, </span><span class="s4">&quot;currentinstallfolder&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">p = </span><span class="s4">r&quot;Software\Microsoft\NET Framework Setup\Product&quot;</span>
            <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">HKEYS:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">h = RegOpenKeyEx(base</span><span class="s3">, </span><span class="s1">p)</span>
                <span class="s3">except </span><span class="s1">RegError:</span>
                    <span class="s3">continue</span>
                <span class="s1">key = RegEnumKey(h</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">d = Reg.get_value(base</span><span class="s3">, </span><span class="s4">r&quot;%s\%s&quot; </span><span class="s1">% (p</span><span class="s3">, </span><span class="s1">key))</span>
                <span class="s1">self.macros[</span><span class="s4">&quot;$(FrameworkVersion)&quot;</span><span class="s1">] = d[</span><span class="s4">&quot;version&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">sub(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.macros.items():</span>
            <span class="s1">s = s.replace(k</span><span class="s3">, </span><span class="s1">v)</span>
        <span class="s3">return </span><span class="s1">s</span>

<span class="s3">def </span><span class="s1">get_build_version():</span>
    <span class="s0">&quot;&quot;&quot;Return the version of MSVC that was used to build Python. 
 
    For Python 2.3 and up, the version number is included in 
    sys.version.  For earlier versions, assume the compiler is MSVC 6. 
    &quot;&quot;&quot;</span>
    <span class="s1">prefix = </span><span class="s4">&quot;MSC v.&quot;</span>
    <span class="s1">i = sys.version.find(prefix)</span>
    <span class="s3">if </span><span class="s1">i == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s5">6</span>
    <span class="s1">i = i + len(prefix)</span>
    <span class="s1">s</span><span class="s3">, </span><span class="s1">rest = sys.version[i:].split(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">majorVersion = int(s[:-</span><span class="s5">2</span><span class="s1">]) - </span><span class="s5">6</span>
    <span class="s3">if </span><span class="s1">majorVersion &gt;= </span><span class="s5">13</span><span class="s1">:</span>
        <span class="s2"># v13 was skipped and should be v14</span>
        <span class="s1">majorVersion += </span><span class="s5">1</span>
    <span class="s1">minorVersion = int(s[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]) / </span><span class="s5">10.0</span>
    <span class="s2"># I don't think paths are affected by minor version in version 6</span>
    <span class="s3">if </span><span class="s1">majorVersion == </span><span class="s5">6</span><span class="s1">:</span>
        <span class="s1">minorVersion = </span><span class="s5">0</span>
    <span class="s3">if </span><span class="s1">majorVersion &gt;= </span><span class="s5">6</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">majorVersion + minorVersion</span>
    <span class="s2"># else we don't know what version of the compiler this is</span>
    <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">normalize_and_reduce_paths(paths):</span>
    <span class="s0">&quot;&quot;&quot;Return a list of normalized paths with duplicates removed. 
 
    The current order of paths is maintained. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Paths are normalized so things like:  /a and /a/ aren't both preserved.</span>
    <span class="s1">reduced_paths = []</span>
    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">paths:</span>
        <span class="s1">np = os.path.normpath(p)</span>
        <span class="s2"># XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.</span>
        <span class="s3">if </span><span class="s1">np </span><span class="s3">not in </span><span class="s1">reduced_paths:</span>
            <span class="s1">reduced_paths.append(np)</span>
    <span class="s3">return </span><span class="s1">reduced_paths</span>

<span class="s3">def </span><span class="s1">removeDuplicates(variable):</span>
    <span class="s0">&quot;&quot;&quot;Remove duplicate values of an environment variable. 
    &quot;&quot;&quot;</span>
    <span class="s1">oldList = variable.split(os.pathsep)</span>
    <span class="s1">newList = []</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">oldList:</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s3">not in </span><span class="s1">newList:</span>
            <span class="s1">newList.append(i)</span>
    <span class="s1">newVariable = os.pathsep.join(newList)</span>
    <span class="s3">return </span><span class="s1">newVariable</span>

<span class="s3">def </span><span class="s1">find_vcvarsall(version):</span>
    <span class="s0">&quot;&quot;&quot;Find the vcvarsall.bat file 
 
    At first it tries to find the productdir of VS 2008 in the registry. If 
    that fails it falls back to the VS90COMNTOOLS env var. 
    &quot;&quot;&quot;</span>
    <span class="s1">vsbase = VS_BASE % version</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">productdir = Reg.get_value(</span><span class="s4">r&quot;%s\Setup\VC&quot; </span><span class="s1">% vsbase</span><span class="s3">,</span>
                                   <span class="s4">&quot;productdir&quot;</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">log.debug(</span><span class="s4">&quot;Unable to find productdir in registry&quot;</span><span class="s1">)</span>
        <span class="s1">productdir = </span><span class="s3">None</span>

    <span class="s3">if not </span><span class="s1">productdir </span><span class="s3">or not </span><span class="s1">os.path.isdir(productdir):</span>
        <span class="s1">toolskey = </span><span class="s4">&quot;VS%0.f0COMNTOOLS&quot; </span><span class="s1">% version</span>
        <span class="s1">toolsdir = os.environ.get(toolskey</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">toolsdir </span><span class="s3">and </span><span class="s1">os.path.isdir(toolsdir):</span>
            <span class="s1">productdir = os.path.join(toolsdir</span><span class="s3">, </span><span class="s1">os.pardir</span><span class="s3">, </span><span class="s1">os.pardir</span><span class="s3">, </span><span class="s4">&quot;VC&quot;</span><span class="s1">)</span>
            <span class="s1">productdir = os.path.abspath(productdir)</span>
            <span class="s3">if not </span><span class="s1">os.path.isdir(productdir):</span>
                <span class="s1">log.debug(</span><span class="s4">&quot;%s is not a valid directory&quot; </span><span class="s1">% productdir)</span>
                <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;Env var %s is not set or invalid&quot; </span><span class="s1">% toolskey)</span>
    <span class="s3">if not </span><span class="s1">productdir:</span>
        <span class="s1">log.debug(</span><span class="s4">&quot;No productdir found&quot;</span><span class="s1">)</span>
        <span class="s3">return None</span>
    <span class="s1">vcvarsall = os.path.join(productdir</span><span class="s3">, </span><span class="s4">&quot;vcvarsall.bat&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">os.path.isfile(vcvarsall):</span>
        <span class="s3">return </span><span class="s1">vcvarsall</span>
    <span class="s1">log.debug(</span><span class="s4">&quot;Unable to find vcvarsall.bat&quot;</span><span class="s1">)</span>
    <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">query_vcvarsall(version</span><span class="s3">, </span><span class="s1">arch=</span><span class="s4">&quot;x86&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Launch vcvarsall.bat and read the settings from its environment 
    &quot;&quot;&quot;</span>
    <span class="s1">vcvarsall = find_vcvarsall(version)</span>
    <span class="s1">interesting = {</span><span class="s4">&quot;include&quot;</span><span class="s3">, </span><span class="s4">&quot;lib&quot;</span><span class="s3">, </span><span class="s4">&quot;libpath&quot;</span><span class="s3">, </span><span class="s4">&quot;path&quot;</span><span class="s1">}</span>
    <span class="s1">result = {}</span>

    <span class="s3">if </span><span class="s1">vcvarsall </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s4">&quot;Unable to find vcvarsall.bat&quot;</span><span class="s1">)</span>
    <span class="s1">log.debug(</span><span class="s4">&quot;Calling 'vcvarsall.bat %s' (version=%s)&quot;</span><span class="s3">, </span><span class="s1">arch</span><span class="s3">, </span><span class="s1">version)</span>
    <span class="s1">popen = subprocess.Popen(</span><span class="s4">'&quot;%s&quot; %s &amp; set' </span><span class="s1">% (vcvarsall</span><span class="s3">, </span><span class="s1">arch)</span><span class="s3">,</span>
                             <span class="s1">stdout=subprocess.PIPE</span><span class="s3">,</span>
                             <span class="s1">stderr=subprocess.PIPE)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = popen.communicate()</span>
        <span class="s3">if </span><span class="s1">popen.wait() != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">DistutilsPlatformError(stderr.decode(</span><span class="s4">&quot;mbcs&quot;</span><span class="s1">))</span>

        <span class="s1">stdout = stdout.decode(</span><span class="s4">&quot;mbcs&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">stdout.split(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">):</span>
            <span class="s1">line = Reg.convert_mbcs(line)</span>
            <span class="s3">if </span><span class="s4">'=' </span><span class="s3">not in </span><span class="s1">line:</span>
                <span class="s3">continue</span>
            <span class="s1">line = line.strip()</span>
            <span class="s1">key</span><span class="s3">, </span><span class="s1">value = line.split(</span><span class="s4">'='</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">key = key.lower()</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">interesting:</span>
                <span class="s3">if </span><span class="s1">value.endswith(os.pathsep):</span>
                    <span class="s1">value = value[:-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">result[key] = removeDuplicates(value)</span>

    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s1">popen.stdout.close()</span>
        <span class="s1">popen.stderr.close()</span>

    <span class="s3">if </span><span class="s1">len(result) != len(interesting):</span>
        <span class="s3">raise </span><span class="s1">ValueError(str(list(result.keys())))</span>

    <span class="s3">return </span><span class="s1">result</span>

<span class="s2"># More globals</span>
<span class="s1">VERSION = get_build_version()</span>
<span class="s3">if </span><span class="s1">VERSION &lt; </span><span class="s5">8.0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s4">&quot;VC %0.1f is not supported by this module&quot; </span><span class="s1">% VERSION)</span>
<span class="s2"># MACROS = MacroExpander(VERSION)</span>

<span class="s3">class </span><span class="s1">MSVCCompiler(CCompiler) :</span>
    <span class="s0">&quot;&quot;&quot;Concrete class that implements an interface to Microsoft Visual C++, 
       as defined by the CCompiler abstract class.&quot;&quot;&quot;</span>

    <span class="s1">compiler_type = </span><span class="s4">'msvc'</span>

    <span class="s2"># Just set this so CCompiler's constructor doesn't barf.  We currently</span>
    <span class="s2"># don't use the 'set_executables()' bureaucracy provided by CCompiler,</span>
    <span class="s2"># as it really isn't necessary for this sort of single-compiler class.</span>
    <span class="s2"># Would be nice to have a consistent interface with UnixCCompiler,</span>
    <span class="s2"># though, so it's worth thinking about.</span>
    <span class="s1">executables = {}</span>

    <span class="s2"># Private class data (need to distinguish C from C++ source for compiler)</span>
    <span class="s1">_c_extensions = [</span><span class="s4">'.c'</span><span class="s1">]</span>
    <span class="s1">_cpp_extensions = [</span><span class="s4">'.cc'</span><span class="s3">, </span><span class="s4">'.cpp'</span><span class="s3">, </span><span class="s4">'.cxx'</span><span class="s1">]</span>
    <span class="s1">_rc_extensions = [</span><span class="s4">'.rc'</span><span class="s1">]</span>
    <span class="s1">_mc_extensions = [</span><span class="s4">'.mc'</span><span class="s1">]</span>

    <span class="s2"># Needed for the filename generation methods provided by the</span>
    <span class="s2"># base class, CCompiler.</span>
    <span class="s1">src_extensions = (_c_extensions + _cpp_extensions +</span>
                      <span class="s1">_rc_extensions + _mc_extensions)</span>
    <span class="s1">res_extension = </span><span class="s4">'.res'</span>
    <span class="s1">obj_extension = </span><span class="s4">'.obj'</span>
    <span class="s1">static_lib_extension = </span><span class="s4">'.lib'</span>
    <span class="s1">shared_lib_extension = </span><span class="s4">'.dll'</span>
    <span class="s1">static_lib_format = shared_lib_format = </span><span class="s4">'%s%s'</span>
    <span class="s1">exe_extension = </span><span class="s4">'.exe'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">force=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">CCompiler.__init__ (self</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">dry_run</span><span class="s3">, </span><span class="s1">force)</span>
        <span class="s1">self.__version = VERSION</span>
        <span class="s1">self.__root = </span><span class="s4">r&quot;Software\Microsoft\VisualStudio&quot;</span>
        <span class="s2"># self.__macros = MACROS</span>
        <span class="s1">self.__paths = []</span>
        <span class="s2"># target platform (.plat_name is consistent with 'bdist')</span>
        <span class="s1">self.plat_name = </span><span class="s3">None</span>
        <span class="s1">self.__arch = </span><span class="s3">None </span><span class="s2"># deprecated name</span>
        <span class="s1">self.initialized = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">initialize(self</span><span class="s3">, </span><span class="s1">plat_name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2"># multi-init means we would need to check platform same each time...</span>
        <span class="s3">assert not </span><span class="s1">self.initialized</span><span class="s3">, </span><span class="s4">&quot;don't init multiple times&quot;</span>
        <span class="s3">if </span><span class="s1">plat_name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">plat_name = get_platform()</span>
        <span class="s2"># sanity check for platforms to prevent obscure errors later.</span>
        <span class="s1">ok_plats = </span><span class="s4">'win32'</span><span class="s3">, </span><span class="s4">'win-amd64'</span>
        <span class="s3">if </span><span class="s1">plat_name </span><span class="s3">not in </span><span class="s1">ok_plats:</span>
            <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s4">&quot;--plat-name must be one of %s&quot; </span><span class="s1">%</span>
                                         <span class="s1">(ok_plats</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s4">&quot;DISTUTILS_USE_SDK&quot; </span><span class="s3">in </span><span class="s1">os.environ </span><span class="s3">and </span><span class="s4">&quot;MSSdk&quot; </span><span class="s3">in </span><span class="s1">os.environ </span><span class="s3">and </span><span class="s1">self.find_exe(</span><span class="s4">&quot;cl.exe&quot;</span><span class="s1">):</span>
            <span class="s2"># Assume that the SDK set up everything alright; don't try to be</span>
            <span class="s2"># smarter</span>
            <span class="s1">self.cc = </span><span class="s4">&quot;cl.exe&quot;</span>
            <span class="s1">self.linker = </span><span class="s4">&quot;link.exe&quot;</span>
            <span class="s1">self.lib = </span><span class="s4">&quot;lib.exe&quot;</span>
            <span class="s1">self.rc = </span><span class="s4">&quot;rc.exe&quot;</span>
            <span class="s1">self.mc = </span><span class="s4">&quot;mc.exe&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># On x86, 'vcvars32.bat amd64' creates an env that doesn't work;</span>
            <span class="s2"># to cross compile, you use 'x86_amd64'.</span>
            <span class="s2"># On AMD64, 'vcvars32.bat amd64' is a native build env; to cross</span>
            <span class="s2"># compile use 'x86' (ie, it runs the x86 compiler directly)</span>
            <span class="s3">if </span><span class="s1">plat_name == get_platform() </span><span class="s3">or </span><span class="s1">plat_name == </span><span class="s4">'win32'</span><span class="s1">:</span>
                <span class="s2"># native build or cross-compile to win32</span>
                <span class="s1">plat_spec = PLAT_TO_VCVARS[plat_name]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># cross compile from win32 -&gt; some 64bit</span>
                <span class="s1">plat_spec = PLAT_TO_VCVARS[get_platform()] + </span><span class="s4">'_' </span><span class="s1">+ \</span>
                            <span class="s1">PLAT_TO_VCVARS[plat_name]</span>

            <span class="s1">vc_env = query_vcvarsall(VERSION</span><span class="s3">, </span><span class="s1">plat_spec)</span>

            <span class="s1">self.__paths = vc_env[</span><span class="s4">'path'</span><span class="s1">].split(os.pathsep)</span>
            <span class="s1">os.environ[</span><span class="s4">'lib'</span><span class="s1">] = vc_env[</span><span class="s4">'lib'</span><span class="s1">]</span>
            <span class="s1">os.environ[</span><span class="s4">'include'</span><span class="s1">] = vc_env[</span><span class="s4">'include'</span><span class="s1">]</span>

            <span class="s3">if </span><span class="s1">len(self.__paths) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s4">&quot;Python was built with %s, &quot;</span>
                       <span class="s4">&quot;and extensions need to be built with the same &quot;</span>
                       <span class="s4">&quot;version of the compiler, but it isn't installed.&quot;</span>
                       <span class="s1">% self.__product)</span>

            <span class="s1">self.cc = self.find_exe(</span><span class="s4">&quot;cl.exe&quot;</span><span class="s1">)</span>
            <span class="s1">self.linker = self.find_exe(</span><span class="s4">&quot;link.exe&quot;</span><span class="s1">)</span>
            <span class="s1">self.lib = self.find_exe(</span><span class="s4">&quot;lib.exe&quot;</span><span class="s1">)</span>
            <span class="s1">self.rc = self.find_exe(</span><span class="s4">&quot;rc.exe&quot;</span><span class="s1">)   </span><span class="s2"># resource compiler</span>
            <span class="s1">self.mc = self.find_exe(</span><span class="s4">&quot;mc.exe&quot;</span><span class="s1">)   </span><span class="s2"># message compiler</span>
            <span class="s2">#self.set_path_env_var('lib')</span>
            <span class="s2">#self.set_path_env_var('include')</span>

        <span class="s2"># extend the MSVC path with the current path</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">os.environ[</span><span class="s4">'path'</span><span class="s1">].split(</span><span class="s4">';'</span><span class="s1">):</span>
                <span class="s1">self.__paths.append(p)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">pass</span>
        <span class="s1">self.__paths = normalize_and_reduce_paths(self.__paths)</span>
        <span class="s1">os.environ[</span><span class="s4">'path'</span><span class="s1">] = </span><span class="s4">&quot;;&quot;</span><span class="s1">.join(self.__paths)</span>

        <span class="s1">self.preprocess_options = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.__arch == </span><span class="s4">&quot;x86&quot;</span><span class="s1">:</span>
            <span class="s1">self.compile_options = [ </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/O2'</span><span class="s3">, </span><span class="s4">'/MD'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">,</span>
                                     <span class="s4">'/DNDEBUG'</span><span class="s1">]</span>
            <span class="s1">self.compile_options_debug = [</span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/Od'</span><span class="s3">, </span><span class="s4">'/MDd'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">,</span>
                                          <span class="s4">'/Z7'</span><span class="s3">, </span><span class="s4">'/D_DEBUG'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Win64</span>
            <span class="s1">self.compile_options = [ </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/O2'</span><span class="s3">, </span><span class="s4">'/MD'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">, </span><span class="s4">'/GS-' </span><span class="s3">,</span>
                                     <span class="s4">'/DNDEBUG'</span><span class="s1">]</span>
            <span class="s1">self.compile_options_debug = [</span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/Od'</span><span class="s3">, </span><span class="s4">'/MDd'</span><span class="s3">, </span><span class="s4">'/W3'</span><span class="s3">, </span><span class="s4">'/GS-'</span><span class="s3">,</span>
                                          <span class="s4">'/Z7'</span><span class="s3">, </span><span class="s4">'/D_DEBUG'</span><span class="s1">]</span>

        <span class="s1">self.ldflags_shared = [</span><span class="s4">'/DLL'</span><span class="s3">, </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/INCREMENTAL:NO'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">self.__version &gt;= </span><span class="s5">7</span><span class="s1">:</span>
            <span class="s1">self.ldflags_shared_debug = [</span>
                <span class="s4">'/DLL'</span><span class="s3">, </span><span class="s4">'/nologo'</span><span class="s3">, </span><span class="s4">'/INCREMENTAL:no'</span><span class="s3">, </span><span class="s4">'/DEBUG'</span>
                <span class="s1">]</span>
        <span class="s1">self.ldflags_static = [ </span><span class="s4">'/nologo'</span><span class="s1">]</span>

        <span class="s1">self.initialized = </span><span class="s3">True</span>

    <span class="s2"># -- Worker methods ------------------------------------------------</span>

    <span class="s3">def </span><span class="s1">object_filenames(self</span><span class="s3">,</span>
                         <span class="s1">source_filenames</span><span class="s3">,</span>
                         <span class="s1">strip_dir=</span><span class="s5">0</span><span class="s3">,</span>
                         <span class="s1">output_dir=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s2"># Copied from ccompiler.py, extended to return .res as 'object'-file</span>
        <span class="s2"># for .rc input file</span>
        <span class="s3">if </span><span class="s1">output_dir </span><span class="s3">is None</span><span class="s1">: output_dir = </span><span class="s4">''</span>
        <span class="s1">obj_names = []</span>
        <span class="s3">for </span><span class="s1">src_name </span><span class="s3">in </span><span class="s1">source_filenames:</span>
            <span class="s1">(base</span><span class="s3">, </span><span class="s1">ext) = os.path.splitext (src_name)</span>
            <span class="s1">base = os.path.splitdrive(base)[</span><span class="s5">1</span><span class="s1">] </span><span class="s2"># Chop off the drive</span>
            <span class="s1">base = base[os.path.isabs(base):]  </span><span class="s2"># If abs, chop off leading /</span>
            <span class="s3">if </span><span class="s1">ext </span><span class="s3">not in </span><span class="s1">self.src_extensions:</span>
                <span class="s2"># Better to raise an exception instead of silently continuing</span>
                <span class="s2"># and later complain about sources and targets having</span>
                <span class="s2"># different lengths</span>
                <span class="s3">raise </span><span class="s1">CompileError (</span><span class="s4">&quot;Don't know how to compile %s&quot; </span><span class="s1">% src_name)</span>
            <span class="s3">if </span><span class="s1">strip_dir:</span>
                <span class="s1">base = os.path.basename (base)</span>
            <span class="s3">if </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._rc_extensions:</span>
                <span class="s1">obj_names.append (os.path.join (output_dir</span><span class="s3">,</span>
                                                <span class="s1">base + self.res_extension))</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._mc_extensions:</span>
                <span class="s1">obj_names.append (os.path.join (output_dir</span><span class="s3">,</span>
                                                <span class="s1">base + self.res_extension))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">obj_names.append (os.path.join (output_dir</span><span class="s3">,</span>
                                                <span class="s1">base + self.obj_extension))</span>
        <span class="s3">return </span><span class="s1">obj_names</span>


    <span class="s3">def </span><span class="s1">compile(self</span><span class="s3">, </span><span class="s1">sources</span><span class="s3">,</span>
                <span class="s1">output_dir=</span><span class="s3">None, </span><span class="s1">macros=</span><span class="s3">None, </span><span class="s1">include_dirs=</span><span class="s3">None, </span><span class="s1">debug=</span><span class="s5">0</span><span class="s3">,</span>
                <span class="s1">extra_preargs=</span><span class="s3">None, </span><span class="s1">extra_postargs=</span><span class="s3">None, </span><span class="s1">depends=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">compile_info = self._setup_compile(output_dir</span><span class="s3">, </span><span class="s1">macros</span><span class="s3">, </span><span class="s1">include_dirs</span><span class="s3">,</span>
                                           <span class="s1">sources</span><span class="s3">, </span><span class="s1">depends</span><span class="s3">, </span><span class="s1">extra_postargs)</span>
        <span class="s1">macros</span><span class="s3">, </span><span class="s1">objects</span><span class="s3">, </span><span class="s1">extra_postargs</span><span class="s3">, </span><span class="s1">pp_opts</span><span class="s3">, </span><span class="s1">build = compile_info</span>

        <span class="s1">compile_opts = extra_preargs </span><span class="s3">or </span><span class="s1">[]</span>
        <span class="s1">compile_opts.append (</span><span class="s4">'/c'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">debug:</span>
            <span class="s1">compile_opts.extend(self.compile_options_debug)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">compile_opts.extend(self.compile_options)</span>

        <span class="s3">for </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">objects:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">src</span><span class="s3">, </span><span class="s1">ext = build[obj]</span>
            <span class="s3">except </span><span class="s1">KeyError:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">debug:</span>
                <span class="s2"># pass the full pathname to MSVC in debug mode,</span>
                <span class="s2"># this allows the debugger to find the source file</span>
                <span class="s2"># without asking the user to browse for it</span>
                <span class="s1">src = os.path.abspath(src)</span>

            <span class="s3">if </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._c_extensions:</span>
                <span class="s1">input_opt = </span><span class="s4">&quot;/Tc&quot; </span><span class="s1">+ src</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._cpp_extensions:</span>
                <span class="s1">input_opt = </span><span class="s4">&quot;/Tp&quot; </span><span class="s1">+ src</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._rc_extensions:</span>
                <span class="s2"># compile .RC to .RES file</span>
                <span class="s1">input_opt = src</span>
                <span class="s1">output_opt = </span><span class="s4">&quot;/fo&quot; </span><span class="s1">+ obj</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.spawn([self.rc] + pp_opts +</span>
                               <span class="s1">[output_opt] + [input_opt])</span>
                <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                    <span class="s3">raise </span><span class="s1">CompileError(msg)</span>
                <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">self._mc_extensions:</span>
                <span class="s2"># Compile .MC to .RC file to .RES file.</span>
                <span class="s2">#   * '-h dir' specifies the directory for the</span>
                <span class="s2">#     generated include file</span>
                <span class="s2">#   * '-r dir' specifies the target directory of the</span>
                <span class="s2">#     generated RC file and the binary message resource</span>
                <span class="s2">#     it includes</span>
                <span class="s2">#</span>
                <span class="s2"># For now (since there are no options to change this),</span>
                <span class="s2"># we use the source-directory for the include file and</span>
                <span class="s2"># the build directory for the RC file and message</span>
                <span class="s2"># resources. This works at least for win32all.</span>
                <span class="s1">h_dir = os.path.dirname(src)</span>
                <span class="s1">rc_dir = os.path.dirname(obj)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s2"># first compile .MC to .RC and .H file</span>
                    <span class="s1">self.spawn([self.mc] +</span>
                               <span class="s1">[</span><span class="s4">'-h'</span><span class="s3">, </span><span class="s1">h_dir</span><span class="s3">, </span><span class="s4">'-r'</span><span class="s3">, </span><span class="s1">rc_dir] + [src])</span>
                    <span class="s1">base</span><span class="s3">, </span><span class="s1">_ = os.path.splitext (os.path.basename (src))</span>
                    <span class="s1">rc_file = os.path.join (rc_dir</span><span class="s3">, </span><span class="s1">base + </span><span class="s4">'.rc'</span><span class="s1">)</span>
                    <span class="s2"># then compile .RC to .RES file</span>
                    <span class="s1">self.spawn([self.rc] +</span>
                               <span class="s1">[</span><span class="s4">&quot;/fo&quot; </span><span class="s1">+ obj] + [rc_file])</span>

                <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                    <span class="s3">raise </span><span class="s1">CompileError(msg)</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># how to handle this file?</span>
                <span class="s3">raise </span><span class="s1">CompileError(</span><span class="s4">&quot;Don't know how to compile %s to %s&quot;</span>
                                   <span class="s1">% (src</span><span class="s3">, </span><span class="s1">obj))</span>

            <span class="s1">output_opt = </span><span class="s4">&quot;/Fo&quot; </span><span class="s1">+ obj</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.spawn([self.cc] + compile_opts + pp_opts +</span>
                           <span class="s1">[input_opt</span><span class="s3">, </span><span class="s1">output_opt] +</span>
                           <span class="s1">extra_postargs)</span>
            <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">raise </span><span class="s1">CompileError(msg)</span>

        <span class="s3">return </span><span class="s1">objects</span>


    <span class="s3">def </span><span class="s1">create_static_lib(self</span><span class="s3">,</span>
                          <span class="s1">objects</span><span class="s3">,</span>
                          <span class="s1">output_libname</span><span class="s3">,</span>
                          <span class="s1">output_dir=</span><span class="s3">None,</span>
                          <span class="s1">debug=</span><span class="s5">0</span><span class="s3">,</span>
                          <span class="s1">target_lang=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">(objects</span><span class="s3">, </span><span class="s1">output_dir) = self._fix_object_args(objects</span><span class="s3">, </span><span class="s1">output_dir)</span>
        <span class="s1">output_filename = self.library_filename(output_libname</span><span class="s3">,</span>
                                                <span class="s1">output_dir=output_dir)</span>

        <span class="s3">if </span><span class="s1">self._need_link(objects</span><span class="s3">, </span><span class="s1">output_filename):</span>
            <span class="s1">lib_args = objects + [</span><span class="s4">'/OUT:' </span><span class="s1">+ output_filename]</span>
            <span class="s3">if </span><span class="s1">debug:</span>
                <span class="s3">pass </span><span class="s2"># XXX what goes here?</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.spawn([self.lib] + lib_args)</span>
            <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">raise </span><span class="s1">LibError(msg)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;skipping %s (up-to-date)&quot;</span><span class="s3">, </span><span class="s1">output_filename)</span>


    <span class="s3">def </span><span class="s1">link(self</span><span class="s3">,</span>
             <span class="s1">target_desc</span><span class="s3">,</span>
             <span class="s1">objects</span><span class="s3">,</span>
             <span class="s1">output_filename</span><span class="s3">,</span>
             <span class="s1">output_dir=</span><span class="s3">None,</span>
             <span class="s1">libraries=</span><span class="s3">None,</span>
             <span class="s1">library_dirs=</span><span class="s3">None,</span>
             <span class="s1">runtime_library_dirs=</span><span class="s3">None,</span>
             <span class="s1">export_symbols=</span><span class="s3">None,</span>
             <span class="s1">debug=</span><span class="s5">0</span><span class="s3">,</span>
             <span class="s1">extra_preargs=</span><span class="s3">None,</span>
             <span class="s1">extra_postargs=</span><span class="s3">None,</span>
             <span class="s1">build_temp=</span><span class="s3">None,</span>
             <span class="s1">target_lang=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">(objects</span><span class="s3">, </span><span class="s1">output_dir) = self._fix_object_args(objects</span><span class="s3">, </span><span class="s1">output_dir)</span>
        <span class="s1">fixed_args = self._fix_lib_args(libraries</span><span class="s3">, </span><span class="s1">library_dirs</span><span class="s3">,</span>
                                        <span class="s1">runtime_library_dirs)</span>
        <span class="s1">(libraries</span><span class="s3">, </span><span class="s1">library_dirs</span><span class="s3">, </span><span class="s1">runtime_library_dirs) = fixed_args</span>

        <span class="s3">if </span><span class="s1">runtime_library_dirs:</span>
            <span class="s1">self.warn (</span><span class="s4">&quot;I don't know what to do with 'runtime_library_dirs': &quot;</span>
                       <span class="s1">+ str (runtime_library_dirs))</span>

        <span class="s1">lib_opts = gen_lib_options(self</span><span class="s3">,</span>
                                   <span class="s1">library_dirs</span><span class="s3">, </span><span class="s1">runtime_library_dirs</span><span class="s3">,</span>
                                   <span class="s1">libraries)</span>
        <span class="s3">if </span><span class="s1">output_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">output_filename = os.path.join(output_dir</span><span class="s3">, </span><span class="s1">output_filename)</span>

        <span class="s3">if </span><span class="s1">self._need_link(objects</span><span class="s3">, </span><span class="s1">output_filename):</span>
            <span class="s3">if </span><span class="s1">target_desc == CCompiler.EXECUTABLE:</span>
                <span class="s3">if </span><span class="s1">debug:</span>
                    <span class="s1">ldflags = self.ldflags_shared_debug[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ldflags = self.ldflags_shared[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">debug:</span>
                    <span class="s1">ldflags = self.ldflags_shared_debug</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ldflags = self.ldflags_shared</span>

            <span class="s1">export_opts = []</span>
            <span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">(export_symbols </span><span class="s3">or </span><span class="s1">[]):</span>
                <span class="s1">export_opts.append(</span><span class="s4">&quot;/EXPORT:&quot; </span><span class="s1">+ sym)</span>

            <span class="s1">ld_args = (ldflags + lib_opts + export_opts +</span>
                       <span class="s1">objects + [</span><span class="s4">'/OUT:' </span><span class="s1">+ output_filename])</span>

            <span class="s2"># The MSVC linker generates .lib and .exp files, which cannot be</span>
            <span class="s2"># suppressed by any linker switches. The .lib files may even be</span>
            <span class="s2"># needed! Make sure they are generated in the temporary build</span>
            <span class="s2"># directory. Since they have different names for debug and release</span>
            <span class="s2"># builds, they can go into the same directory.</span>
            <span class="s1">build_temp = os.path.dirname(objects[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">export_symbols </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">(dll_name</span><span class="s3">, </span><span class="s1">dll_ext) = os.path.splitext(</span>
                    <span class="s1">os.path.basename(output_filename))</span>
                <span class="s1">implib_file = os.path.join(</span>
                    <span class="s1">build_temp</span><span class="s3">,</span>
                    <span class="s1">self.library_filename(dll_name))</span>
                <span class="s1">ld_args.append (</span><span class="s4">'/IMPLIB:' </span><span class="s1">+ implib_file)</span>

            <span class="s1">self.manifest_setup_ldargs(output_filename</span><span class="s3">, </span><span class="s1">build_temp</span><span class="s3">, </span><span class="s1">ld_args)</span>

            <span class="s3">if </span><span class="s1">extra_preargs:</span>
                <span class="s1">ld_args[:</span><span class="s5">0</span><span class="s1">] = extra_preargs</span>
            <span class="s3">if </span><span class="s1">extra_postargs:</span>
                <span class="s1">ld_args.extend(extra_postargs)</span>

            <span class="s1">self.mkpath(os.path.dirname(output_filename))</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.spawn([self.linker] + ld_args)</span>
            <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">raise </span><span class="s1">LinkError(msg)</span>

            <span class="s2"># embed the manifest</span>
            <span class="s2"># XXX - this is somewhat fragile - if mt.exe fails, distutils</span>
            <span class="s2"># will still consider the DLL up-to-date, but it will not have a</span>
            <span class="s2"># manifest.  Maybe we should link to a temp file?  OTOH, that</span>
            <span class="s2"># implies a build environment error that shouldn't go undetected.</span>
            <span class="s1">mfinfo = self.manifest_get_embed_info(target_desc</span><span class="s3">, </span><span class="s1">ld_args)</span>
            <span class="s3">if </span><span class="s1">mfinfo </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">mffilename</span><span class="s3">, </span><span class="s1">mfid = mfinfo</span>
                <span class="s1">out_arg = </span><span class="s4">'-outputresource:%s;%s' </span><span class="s1">% (output_filename</span><span class="s3">, </span><span class="s1">mfid)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.spawn([</span><span class="s4">'mt.exe'</span><span class="s3">, </span><span class="s4">'-nologo'</span><span class="s3">, </span><span class="s4">'-manifest'</span><span class="s3">,</span>
                                <span class="s1">mffilename</span><span class="s3">, </span><span class="s1">out_arg])</span>
                <span class="s3">except </span><span class="s1">DistutilsExecError </span><span class="s3">as </span><span class="s1">msg:</span>
                    <span class="s3">raise </span><span class="s1">LinkError(msg)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;skipping %s (up-to-date)&quot;</span><span class="s3">, </span><span class="s1">output_filename)</span>

    <span class="s3">def </span><span class="s1">manifest_setup_ldargs(self</span><span class="s3">, </span><span class="s1">output_filename</span><span class="s3">, </span><span class="s1">build_temp</span><span class="s3">, </span><span class="s1">ld_args):</span>
        <span class="s2"># If we need a manifest at all, an embedded manifest is recommended.</span>
        <span class="s2"># See MSDN article titled</span>
        <span class="s2"># &quot;How to: Embed a Manifest Inside a C/C++ Application&quot;</span>
        <span class="s2"># (currently at http://msdn2.microsoft.com/en-us/library/ms235591(VS.80).aspx)</span>
        <span class="s2"># Ask the linker to generate the manifest in the temp dir, so</span>
        <span class="s2"># we can check it, and possibly embed it, later.</span>
        <span class="s1">temp_manifest = os.path.join(</span>
                <span class="s1">build_temp</span><span class="s3">,</span>
                <span class="s1">os.path.basename(output_filename) + </span><span class="s4">&quot;.manifest&quot;</span><span class="s1">)</span>
        <span class="s1">ld_args.append(</span><span class="s4">'/MANIFESTFILE:' </span><span class="s1">+ temp_manifest)</span>

    <span class="s3">def </span><span class="s1">manifest_get_embed_info(self</span><span class="s3">, </span><span class="s1">target_desc</span><span class="s3">, </span><span class="s1">ld_args):</span>
        <span class="s2"># If a manifest should be embedded, return a tuple of</span>
        <span class="s2"># (manifest_filename, resource_id).  Returns None if no manifest</span>
        <span class="s2"># should be embedded.  See http://bugs.python.org/issue7833 for why</span>
        <span class="s2"># we want to avoid any manifest for extension modules if we can)</span>
        <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">ld_args:</span>
            <span class="s3">if </span><span class="s1">arg.startswith(</span><span class="s4">&quot;/MANIFESTFILE:&quot;</span><span class="s1">):</span>
                <span class="s1">temp_manifest = arg.split(</span><span class="s4">&quot;:&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">break</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># no /MANIFESTFILE so nothing to do.</span>
            <span class="s3">return None</span>
        <span class="s3">if </span><span class="s1">target_desc == CCompiler.EXECUTABLE:</span>
            <span class="s2"># by default, executables always get the manifest with the</span>
            <span class="s2"># CRT referenced.</span>
            <span class="s1">mfid = </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Extension modules try and avoid any manifest if possible.</span>
            <span class="s1">mfid = </span><span class="s5">2</span>
            <span class="s1">temp_manifest = self._remove_visual_c_ref(temp_manifest)</span>
        <span class="s3">if </span><span class="s1">temp_manifest </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">temp_manifest</span><span class="s3">, </span><span class="s1">mfid</span>

    <span class="s3">def </span><span class="s1">_remove_visual_c_ref(self</span><span class="s3">, </span><span class="s1">manifest_file):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s2"># Remove references to the Visual C runtime, so they will</span>
            <span class="s2"># fall through to the Visual C dependency of Python.exe.</span>
            <span class="s2"># This way, when installed for a restricted user (e.g.</span>
            <span class="s2"># runtimes are not in WinSxS folder, but in Python's own</span>
            <span class="s2"># folder), the runtimes do not need to be in every folder</span>
            <span class="s2"># with .pyd's.</span>
            <span class="s2"># Returns either the filename of the modified manifest or</span>
            <span class="s2"># None if no manifest should be embedded.</span>
            <span class="s1">manifest_f = open(manifest_file)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">manifest_buf = manifest_f.read()</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">manifest_f.close()</span>
            <span class="s1">pattern = re.compile(</span>
                <span class="s4">r&quot;&quot;&quot;&lt;assemblyIdentity.*?name=(&quot;|')Microsoft\.&quot;&quot;&quot;</span><span class="s1">\</span>
                <span class="s4">r&quot;&quot;&quot;VC\d{2}\.CRT(&quot;|').*?(/&gt;|&lt;/assemblyIdentity&gt;)&quot;&quot;&quot;</span><span class="s3">,</span>
                <span class="s1">re.DOTALL)</span>
            <span class="s1">manifest_buf = re.sub(pattern</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">manifest_buf)</span>
            <span class="s1">pattern = </span><span class="s4">r&quot;&lt;dependentAssembly&gt;\s*&lt;/dependentAssembly&gt;&quot;</span>
            <span class="s1">manifest_buf = re.sub(pattern</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">manifest_buf)</span>
            <span class="s2"># Now see if any other assemblies are referenced - if not, we</span>
            <span class="s2"># don't want a manifest embedded.</span>
            <span class="s1">pattern = re.compile(</span>
                <span class="s4">r&quot;&quot;&quot;&lt;assemblyIdentity.*?name=(?:&quot;|')(.+?)(?:&quot;|')&quot;&quot;&quot;</span>
                <span class="s4">r&quot;&quot;&quot;.*?(?:/&gt;|&lt;/assemblyIdentity&gt;)&quot;&quot;&quot;</span><span class="s3">, </span><span class="s1">re.DOTALL)</span>
            <span class="s3">if </span><span class="s1">re.search(pattern</span><span class="s3">, </span><span class="s1">manifest_buf) </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return None</span>

            <span class="s1">manifest_f = open(manifest_file</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">manifest_f.write(manifest_buf)</span>
                <span class="s3">return </span><span class="s1">manifest_file</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">manifest_f.close()</span>
        <span class="s3">except </span><span class="s1">OSError:</span>
            <span class="s3">pass</span>

    <span class="s2"># -- Miscellaneous methods -----------------------------------------</span>
    <span class="s2"># These are all used by the 'gen_lib_options() function, in</span>
    <span class="s2"># ccompiler.py.</span>

    <span class="s3">def </span><span class="s1">library_dir_option(self</span><span class="s3">, </span><span class="s1">dir):</span>
        <span class="s3">return </span><span class="s4">&quot;/LIBPATH:&quot; </span><span class="s1">+ dir</span>

    <span class="s3">def </span><span class="s1">runtime_library_dir_option(self</span><span class="s3">, </span><span class="s1">dir):</span>
        <span class="s3">raise </span><span class="s1">DistutilsPlatformError(</span>
              <span class="s4">&quot;don't know how to set runtime library search path for MSVC++&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">library_option(self</span><span class="s3">, </span><span class="s1">lib):</span>
        <span class="s3">return </span><span class="s1">self.library_filename(lib)</span>


    <span class="s3">def </span><span class="s1">find_library_file(self</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">debug=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2"># Prefer a debugging library if found (and requested), but deal</span>
        <span class="s2"># with it if we don't have one.</span>
        <span class="s3">if </span><span class="s1">debug:</span>
            <span class="s1">try_names = [lib + </span><span class="s4">&quot;_d&quot;</span><span class="s3">, </span><span class="s1">lib]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">try_names = [lib]</span>
        <span class="s3">for </span><span class="s1">dir </span><span class="s3">in </span><span class="s1">dirs:</span>
            <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">try_names:</span>
                <span class="s1">libfile = os.path.join(dir</span><span class="s3">, </span><span class="s1">self.library_filename (name))</span>
                <span class="s3">if </span><span class="s1">os.path.exists(libfile):</span>
                    <span class="s3">return </span><span class="s1">libfile</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Oops, didn't find it in *any* of 'dirs'</span>
            <span class="s3">return None</span>

    <span class="s2"># Helper methods for using the MSVC registry settings</span>

    <span class="s3">def </span><span class="s1">find_exe(self</span><span class="s3">, </span><span class="s1">exe):</span>
        <span class="s0">&quot;&quot;&quot;Return path to an MSVC executable program. 
 
        Tries to find the program in several places: first, one of the 
        MSVC program search paths from the registry; next, the directories 
        in the PATH environment variable.  If any of those work, return an 
        absolute path that is known to exist.  If none of them work, just 
        return the original program name, 'exe'. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">self.__paths:</span>
            <span class="s1">fn = os.path.join(os.path.abspath(p)</span><span class="s3">, </span><span class="s1">exe)</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(fn):</span>
                <span class="s3">return </span><span class="s1">fn</span>

        <span class="s2"># didn't find it; try existing path</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">os.environ[</span><span class="s4">'Path'</span><span class="s1">].split(</span><span class="s4">';'</span><span class="s1">):</span>
            <span class="s1">fn = os.path.join(os.path.abspath(p)</span><span class="s3">,</span><span class="s1">exe)</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(fn):</span>
                <span class="s3">return </span><span class="s1">fn</span>

        <span class="s3">return </span><span class="s1">exe</span>
</pre>
</body>
</html>