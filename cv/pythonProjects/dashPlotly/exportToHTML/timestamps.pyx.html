<html>
<head>
<title>timestamps.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
timestamps.pyx</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">_Timestamp is a c-defined subclass of datetime.datetime</span>

<span class="s0">_Timestamp is PITA. Because we inherit from datetime, which has very specific</span>
<span class="s0">construction requirements, we need to do object instantiation in python</span>
<span class="s0">(see Timestamp class below). This will serve as a C extension type that</span>
<span class="s0">shadows the python class, where we do any heavy lifting.</span>
<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">import warnings</span>

<span class="s0">cimport cython</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">int8_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from cpython.datetime cimport (  # alias bc `tzinfo` is a kwarg below</span>
    <span class="s0">PyDate_Check,</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
    <span class="s0">PyTZInfo_Check,</span>
    <span class="s0">datetime,</span>
    <span class="s0">time,</span>
    <span class="s0">tzinfo as tzinfo_type,</span>
<span class="s0">)</span>
<span class="s0">from cpython.object cimport (</span>
    <span class="s0">Py_EQ,</span>
    <span class="s0">Py_GE,</span>
    <span class="s0">Py_GT,</span>
    <span class="s0">Py_LE,</span>
    <span class="s0">Py_LT,</span>
    <span class="s0">Py_NE,</span>
    <span class="s0">PyObject_RichCompare,</span>
    <span class="s0">PyObject_RichCompareBool,</span>
<span class="s0">)</span>

<span class="s0">PyDateTime_IMPORT</span>

<span class="s0">from pandas._libs.tslibs cimport ccalendar</span>
<span class="s0">from pandas._libs.tslibs.base cimport ABCTimestamp</span>
<span class="s0">from pandas._libs.tslibs.conversion cimport (</span>
    <span class="s0">_TSObject,</span>
    <span class="s0">convert_datetime_to_tsobject,</span>
    <span class="s0">convert_to_tsobject,</span>
    <span class="s0">normalize_i8_stamp,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.util cimport (</span>
    <span class="s0">is_array,</span>
    <span class="s0">is_datetime64_object,</span>
    <span class="s0">is_float_object,</span>
    <span class="s0">is_integer_object,</span>
    <span class="s0">is_timedelta64_object,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.fields import (</span>
    <span class="s0">RoundTo,</span>
    <span class="s0">get_date_name_field,</span>
    <span class="s0">get_start_end_field,</span>
    <span class="s0">round_nsint64,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">c_NaT as NaT,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">check_dts_bounds,</span>
    <span class="s0">cmp_scalar,</span>
    <span class="s0">dt64_to_dtstruct,</span>
    <span class="s0">npy_datetimestruct,</span>
    <span class="s0">pydatetime_to_dt64,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime</span>

<span class="s0">from pandas._libs.tslibs.offsets cimport (</span>
    <span class="s0">is_offset_object,</span>
    <span class="s0">to_offset,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.timedeltas cimport (</span>
    <span class="s0">delta_to_nanoseconds,</span>
    <span class="s0">is_any_td_scalar,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.timedeltas import Timedelta</span>

<span class="s0">from pandas._libs.tslibs.timezones cimport (</span>
    <span class="s0">get_timezone,</span>
    <span class="s0">is_utc,</span>
    <span class="s0">maybe_get_tz,</span>
    <span class="s0">treat_tz_as_pytz,</span>
    <span class="s0">tz_compare,</span>
    <span class="s0">utc_pytz as UTC,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.tzconversion cimport (</span>
    <span class="s0">tz_convert_from_utc_single,</span>
    <span class="s0">tz_localize_to_utc_single,</span>
<span class="s0">)</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Constants</span>
<span class="s0">_zero_time = time(0, 0)</span>
<span class="s0">_no_input = object()</span>

<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">cdef inline object create_timestamp_from_ts(int64_t value,</span>
                                            <span class="s0">npy_datetimestruct dts,</span>
                                            <span class="s0">tzinfo tz, object freq, bint fold):</span>
    <span class="s0">&quot;&quot;&quot; convenience routine to construct a Timestamp from its parts &quot;&quot;&quot;</span>
    <span class="s0">cdef _Timestamp ts_base</span>
    <span class="s0">ts_base = _Timestamp.__new__(Timestamp, dts.year, dts.month,</span>
                                 <span class="s0">dts.day, dts.hour, dts.min,</span>
                                 <span class="s0">dts.sec, dts.us, tz, fold=fold)</span>
    <span class="s0">ts_base.value = value</span>
    <span class="s0">ts_base._freq = freq</span>
    <span class="s0">ts_base.nanosecond = dts.ps // 1000</span>

    <span class="s0">return ts_base</span>


<span class="s0">def _unpickle_timestamp(value, freq, tz):</span>
    <span class="s0"># GH#41949 dont warn on unpickle if we have a freq</span>
    <span class="s0">ts = Timestamp(value, tz=tz)</span>
    <span class="s0">ts._set_freq(freq)</span>
    <span class="s0">return ts</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">def integer_op_not_supported(obj):</span>
    <span class="s0"># GH#22535 add/sub of integers and int-arrays is no longer allowed</span>
    <span class="s0"># Note we return rather than raise the exception so we can raise in</span>
    <span class="s0">#  the caller; mypy finds this more palatable.</span>
    <span class="s0">cls = type(obj).__name__</span>

    <span class="s0"># GH#30886 using an fstring raises SystemError</span>
    <span class="s0">int_addsub_msg = (</span>
        <span class="s0">f&quot;Addition/subtraction of integers and integer-arrays with {cls} is &quot;</span>
        <span class="s0">&quot;no longer supported.  Instead of adding/subtracting `n`, &quot;</span>
        <span class="s0">&quot;use `n * obj.freq`&quot;</span>
    <span class="s0">)</span>
    <span class="s0">return TypeError(int_addsub_msg)</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cdef class _Timestamp(ABCTimestamp):</span>

    <span class="s0"># higher than np.ndarray and np.matrix</span>
    <span class="s0">__array_priority__ = 100</span>
    <span class="s0">dayofweek = _Timestamp.day_of_week</span>
    <span class="s0">dayofyear = _Timestamp.day_of_year</span>

    <span class="s0">cpdef void _set_freq(self, freq):</span>
        <span class="s0"># set the ._freq attribute without going through the constructor,</span>
        <span class="s0">#  which would issue a warning</span>
        <span class="s0"># Caller is responsible for validation</span>
        <span class="s0">self._freq = freq</span>

    <span class="s0">@property</span>
    <span class="s0">def freq(self):</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;Timestamp.freq is deprecated and will be removed in a future version.&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return self._freq</span>

    <span class="s0">def __hash__(_Timestamp self):</span>
        <span class="s0">if self.nanosecond:</span>
            <span class="s0">return hash(self.value)</span>
        <span class="s0">if self.fold:</span>
            <span class="s0">return datetime.__hash__(self.replace(fold=0))</span>
        <span class="s0">return datetime.__hash__(self)</span>

    <span class="s0">def __richcmp__(_Timestamp self, object other, int op):</span>
        <span class="s0">cdef:</span>
            <span class="s0">_Timestamp ots</span>
            <span class="s0">int ndim</span>

        <span class="s0">if isinstance(other, _Timestamp):</span>
            <span class="s0">ots = other</span>
        <span class="s0">elif other is NaT:</span>
            <span class="s0">return op == Py_NE</span>
        <span class="s0">elif PyDateTime_Check(other) or is_datetime64_object(other):</span>
            <span class="s0">if self.nanosecond == 0 and PyDateTime_Check(other):</span>
                <span class="s0">val = self.to_pydatetime()</span>
                <span class="s0">return PyObject_RichCompareBool(val, other, op)</span>

            <span class="s0">try:</span>
                <span class="s0">ots = type(self)(other)</span>
            <span class="s0">except ValueError:</span>
                <span class="s0">if is_datetime64_object(other):</span>
                    <span class="s0"># cast non-nano dt64 to pydatetime</span>
                    <span class="s0">other = other.astype(object)</span>
                <span class="s0">return self._compare_outside_nanorange(other, op)</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0"># avoid recursion error GH#15183</span>
            <span class="s0">if other.dtype.kind == &quot;M&quot;:</span>
                <span class="s0">if self.tz is None:</span>
                    <span class="s0">return PyObject_RichCompare(self.asm8, other, op)</span>
                <span class="s0">elif op == Py_NE:</span>
                    <span class="s0">return np.ones(other.shape, dtype=np.bool_)</span>
                <span class="s0">elif op == Py_EQ:</span>
                    <span class="s0">return np.zeros(other.shape, dtype=np.bool_)</span>
                <span class="s0">raise TypeError(</span>
                    <span class="s0">&quot;Cannot compare tz-naive and tz-aware timestamps&quot;</span>
                <span class="s0">)</span>
            <span class="s0">elif other.dtype.kind == &quot;O&quot;:</span>
                <span class="s0"># Operate element-wise</span>
                <span class="s0">return np.array(</span>
                    <span class="s0">[PyObject_RichCompare(self, x, op) for x in other],</span>
                    <span class="s0">dtype=bool,</span>
                <span class="s0">)</span>
            <span class="s0">elif op == Py_NE:</span>
                <span class="s0">return np.ones(other.shape, dtype=np.bool_)</span>
            <span class="s0">elif op == Py_EQ:</span>
                <span class="s0">return np.zeros(other.shape, dtype=np.bool_)</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">elif PyDate_Check(other):</span>
            <span class="s0"># returning NotImplemented defers to the `date` implementation</span>
            <span class="s0">#  which incorrectly drops tz and normalizes to midnight</span>
            <span class="s0">#  before comparing</span>
            <span class="s0"># We follow the stdlib datetime behavior of never being equal</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;Comparison of Timestamp with datetime.date is deprecated in &quot;</span>
                <span class="s0">&quot;order to match the standard library behavior. &quot;</span>
                <span class="s0">&quot;In a future version these will be considered non-comparable. &quot;</span>
                <span class="s0">&quot;Use 'ts == pd.Timestamp(date)' or 'ts.date() == date' instead.&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=1,</span>
            <span class="s0">)</span>
            <span class="s0">return NotImplemented</span>
        <span class="s0">else:</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">if not self._can_compare(ots):</span>
            <span class="s0">if op == Py_NE or op == Py_EQ:</span>
                <span class="s0">return NotImplemented</span>
            <span class="s0">raise TypeError(</span>
                <span class="s0">&quot;Cannot compare tz-naive and tz-aware timestamps&quot;</span>
            <span class="s0">)</span>
        <span class="s0">return cmp_scalar(self.value, ots.value, op)</span>

    <span class="s0">cdef bint _compare_outside_nanorange(_Timestamp self, datetime other,</span>
                                         <span class="s0">int op) except -1:</span>
        <span class="s0">cdef:</span>
            <span class="s0">datetime dtval = self.to_pydatetime(warn=False)</span>

        <span class="s0">if not self._can_compare(other):</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">if self.nanosecond == 0:</span>
            <span class="s0">return PyObject_RichCompareBool(dtval, other, op)</span>

        <span class="s0"># otherwise we have dtval &lt; self</span>
        <span class="s0">if op == Py_NE:</span>
            <span class="s0">return True</span>
        <span class="s0">if op == Py_EQ:</span>
            <span class="s0">return False</span>
        <span class="s0">if op == Py_LE or op == Py_LT:</span>
            <span class="s0">return self.year &lt;= other.year</span>
        <span class="s0">if op == Py_GE or op == Py_GT:</span>
            <span class="s0">return self.year &gt;= other.year</span>

    <span class="s0">cdef bint _can_compare(self, datetime other):</span>
        <span class="s0">if self.tzinfo is not None:</span>
            <span class="s0">return other.tzinfo is not None</span>
        <span class="s0">return other.tzinfo is None</span>

    <span class="s0">def __add__(self, other):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t nanos = 0</span>

        <span class="s0">if is_any_td_scalar(other):</span>
            <span class="s0">nanos = delta_to_nanoseconds(other)</span>
            <span class="s0">result = type(self)(self.value + nanos, tz=self.tzinfo)</span>
            <span class="s0">if result is not NaT:</span>
                <span class="s0">result._set_freq(self._freq)  # avoid warning in constructor</span>
            <span class="s0">return result</span>

        <span class="s0">elif is_integer_object(other):</span>
            <span class="s0">raise integer_op_not_supported(self)</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0">if other.dtype.kind in ['i', 'u']:</span>
                <span class="s0">raise integer_op_not_supported(self)</span>
            <span class="s0">if other.dtype.kind == &quot;m&quot;:</span>
                <span class="s0">if self.tz is None:</span>
                    <span class="s0">return self.asm8 + other</span>
                <span class="s0">return np.asarray(</span>
                    <span class="s0">[self + other[n] for n in range(len(other))],</span>
                    <span class="s0">dtype=object,</span>
                <span class="s0">)</span>

        <span class="s0">elif not isinstance(self, _Timestamp):</span>
            <span class="s0"># cython semantics, args have been switched and this is __radd__</span>
            <span class="s0">return other.__add__(self)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __sub__(self, other):</span>

        <span class="s0">if is_any_td_scalar(other) or is_integer_object(other):</span>
            <span class="s0">neg_other = -other</span>
            <span class="s0">return self + neg_other</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0">if other.dtype.kind in ['i', 'u']:</span>
                <span class="s0">raise integer_op_not_supported(self)</span>
            <span class="s0">if other.dtype.kind == &quot;m&quot;:</span>
                <span class="s0">if self.tz is None:</span>
                    <span class="s0">return self.asm8 - other</span>
                <span class="s0">return np.asarray(</span>
                    <span class="s0">[self - other[n] for n in range(len(other))],</span>
                    <span class="s0">dtype=object,</span>
                <span class="s0">)</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">if other is NaT:</span>
            <span class="s0">return NaT</span>

        <span class="s0"># coerce if necessary if we are a Timestamp-like</span>
        <span class="s0">if (PyDateTime_Check(self)</span>
                <span class="s0">and (PyDateTime_Check(other) or is_datetime64_object(other))):</span>
            <span class="s0"># both_timestamps is to determine whether Timedelta(self - other)</span>
            <span class="s0"># should raise the OOB error, or fall back returning a timedelta.</span>
            <span class="s0">both_timestamps = (isinstance(other, _Timestamp) and</span>
                               <span class="s0">isinstance(self, _Timestamp))</span>
            <span class="s0">if isinstance(self, _Timestamp):</span>
                <span class="s0">other = type(self)(other)</span>
            <span class="s0">else:</span>
                <span class="s0">self = type(other)(self)</span>

            <span class="s0">if (self.tzinfo is None) ^ (other.tzinfo is None):</span>
                <span class="s0">raise TypeError(</span>
                    <span class="s0">&quot;Cannot subtract tz-naive and tz-aware datetime-like objects.&quot;</span>
                <span class="s0">)</span>

            <span class="s0"># scalar Timestamp/datetime - Timestamp/datetime -&gt; yields a</span>
            <span class="s0"># Timedelta</span>
            <span class="s0">try:</span>
                <span class="s0">return Timedelta(self.value - other.value)</span>
            <span class="s0">except (OverflowError, OutOfBoundsDatetime) as err:</span>
                <span class="s0">if isinstance(other, _Timestamp):</span>
                    <span class="s0">if both_timestamps:</span>
                        <span class="s0">raise OutOfBoundsDatetime(</span>
                            <span class="s0">&quot;Result is too large for pandas.Timedelta. Convert inputs &quot;</span>
                            <span class="s0">&quot;to datetime.datetime with 'Timestamp.to_pydatetime()' &quot;</span>
                            <span class="s0">&quot;before subtracting.&quot;</span>
                        <span class="s0">) from err</span>
                <span class="s0"># We get here in stata tests, fall back to stdlib datetime</span>
                <span class="s0">#  method and return stdlib timedelta object</span>
                <span class="s0">pass</span>
        <span class="s0">elif is_datetime64_object(self):</span>
            <span class="s0"># GH#28286 cython semantics for __rsub__, `other` is actually</span>
            <span class="s0">#  the Timestamp</span>
            <span class="s0">return type(other)(self) - other</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0"># -----------------------------------------------------------------</span>

    <span class="s0">cdef int64_t _maybe_convert_value_to_local(self):</span>
        <span class="s0">&quot;&quot;&quot;Convert UTC i8 value to local i8 value if tz exists&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t val</span>
            <span class="s0">tzinfo own_tz = self.tzinfo</span>
            <span class="s0">npy_datetimestruct dts</span>

        <span class="s0">if own_tz is not None and not is_utc(own_tz):</span>
            <span class="s0">val = pydatetime_to_dt64(self, &amp;dts) + self.nanosecond</span>
        <span class="s0">else:</span>
            <span class="s0">val = self.value</span>
        <span class="s0">return val</span>

    <span class="s0">cdef bint _get_start_end_field(self, str field, freq):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t val</span>
            <span class="s0">dict kwds</span>
            <span class="s0">ndarray[uint8_t, cast=True] out</span>
            <span class="s0">int month_kw</span>

        <span class="s0">if freq:</span>
            <span class="s0">kwds = freq.kwds</span>
            <span class="s0">month_kw = kwds.get('startingMonth', kwds.get('month', 12))</span>
            <span class="s0">freqstr = self._freqstr</span>
        <span class="s0">else:</span>
            <span class="s0">month_kw = 12</span>
            <span class="s0">freqstr = None</span>

        <span class="s0">val = self._maybe_convert_value_to_local()</span>
        <span class="s0">out = get_start_end_field(np.array([val], dtype=np.int64),</span>
                                  <span class="s0">field, freqstr, month_kw)</span>
        <span class="s0">return out[0]</span>

    <span class="s0">cdef _warn_on_field_deprecation(self, freq, str field):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Warn if the removal of .freq change the value of start/end properties.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">bint needs = False</span>

        <span class="s0">if freq is not None:</span>
            <span class="s0">kwds = freq.kwds</span>
            <span class="s0">month_kw = kwds.get(&quot;startingMonth&quot;, kwds.get(&quot;month&quot;, 12))</span>
            <span class="s0">freqstr = self._freqstr</span>
            <span class="s0">if month_kw != 12:</span>
                <span class="s0">needs = True</span>
            <span class="s0">if freqstr.startswith(&quot;B&quot;):</span>
                <span class="s0">needs = True</span>

            <span class="s0">if needs:</span>
                <span class="s0">warnings.warn(</span>
                    <span class="s0">&quot;Timestamp.freq is deprecated and will be removed in a future &quot;</span>
                    <span class="s0">&quot;version. When you have a freq, use &quot;</span>
                    <span class="s0">f&quot;freq.{field}(timestamp) instead.&quot;,</span>
                    <span class="s0">FutureWarning,</span>
                    <span class="s0">stacklevel=1,</span>
                <span class="s0">)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_month_start(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if date is first day of month.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_month_start</span>
        <span class="s0">False</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 1, 1)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_month_start</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._freq is None:</span>
            <span class="s0"># fast-path for non-business frequencies</span>
            <span class="s0">return self.day == 1</span>
        <span class="s0">self._warn_on_field_deprecation(self._freq, &quot;is_month_start&quot;)</span>
        <span class="s0">return self._get_start_end_field(&quot;is_month_start&quot;, self._freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_month_end(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if date is last day of month.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_month_end</span>
        <span class="s0">False</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 12, 31)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_month_end</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._freq is None:</span>
            <span class="s0"># fast-path for non-business frequencies</span>
            <span class="s0">return self.day == self.days_in_month</span>
        <span class="s0">self._warn_on_field_deprecation(self._freq, &quot;is_month_end&quot;)</span>
        <span class="s0">return self._get_start_end_field(&quot;is_month_end&quot;, self._freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_quarter_start(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if date is first day of the quarter.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_quarter_start</span>
        <span class="s0">False</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 4, 1)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_quarter_start</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._freq is None:</span>
            <span class="s0"># fast-path for non-business frequencies</span>
            <span class="s0">return self.day == 1 and self.month % 3 == 1</span>
        <span class="s0">self._warn_on_field_deprecation(self._freq, &quot;is_quarter_start&quot;)</span>
        <span class="s0">return self._get_start_end_field(&quot;is_quarter_start&quot;, self._freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_quarter_end(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if date is last day of the quarter.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_quarter_end</span>
        <span class="s0">False</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 31)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_quarter_end</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._freq is None:</span>
            <span class="s0"># fast-path for non-business frequencies</span>
            <span class="s0">return (self.month % 3) == 0 and self.day == self.days_in_month</span>
        <span class="s0">self._warn_on_field_deprecation(self._freq, &quot;is_quarter_end&quot;)</span>
        <span class="s0">return self._get_start_end_field(&quot;is_quarter_end&quot;, self._freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_year_start(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if date is first day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_year_start</span>
        <span class="s0">False</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 1, 1)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_year_start</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._freq is None:</span>
            <span class="s0"># fast-path for non-business frequencies</span>
            <span class="s0">return self.day == self.month == 1</span>
        <span class="s0">self._warn_on_field_deprecation(self._freq, &quot;is_year_start&quot;)</span>
        <span class="s0">return self._get_start_end_field(&quot;is_year_start&quot;, self._freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_year_end(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if date is last day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_year_end</span>
        <span class="s0">False</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 12, 31)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_year_end</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._freq is None:</span>
            <span class="s0"># fast-path for non-business frequencies</span>
            <span class="s0">return self.month == 12 and self.day == 31</span>
        <span class="s0">self._warn_on_field_deprecation(self._freq, &quot;is_year_end&quot;)</span>
        <span class="s0">return self._get_start_end_field(&quot;is_year_end&quot;, self._freq)</span>

    <span class="s0">cdef _get_date_name_field(self, str field, object locale):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t val</span>
            <span class="s0">object[:] out</span>

        <span class="s0">val = self._maybe_convert_value_to_local()</span>
        <span class="s0">out = get_date_name_field(np.array([val], dtype=np.int64),</span>
                                  <span class="s0">field, locale=locale)</span>
        <span class="s0">return out[0]</span>

    <span class="s0">def day_name(self, locale=None) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day name of the Timestamp with specified locale.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">locale : str, default None (English locale)</span>
            <span class="s0">Locale determining the language in which to return the day name.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.day_name()</span>
        <span class="s0">'Saturday'</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.day_name()</span>
        <span class="s0">nan</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._get_date_name_field(&quot;day_name&quot;, locale)</span>

    <span class="s0">def month_name(self, locale=None) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the month name of the Timestamp with specified locale.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">locale : str, default None (English locale)</span>
            <span class="s0">Locale determining the language in which to return the month name.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.month_name()</span>
        <span class="s0">'March'</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.month_name()</span>
        <span class="s0">nan</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._get_date_name_field(&quot;month_name&quot;, locale)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_leap_year(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if year is a leap year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.is_leap_year</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return bool(ccalendar.is_leapyear(self.year))</span>

    <span class="s0">@property</span>
    <span class="s0">def day_of_week(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return day of the week.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.day_of_week</span>
        <span class="s0">5</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.weekday()</span>

    <span class="s0">@property</span>
    <span class="s0">def day_of_year(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.day_of_year</span>
        <span class="s0">74</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return ccalendar.get_day_of_year(self.year, self.month, self.day)</span>

    <span class="s0">@property</span>
    <span class="s0">def quarter(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the quarter of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.quarter</span>
        <span class="s0">1</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return ((self.month - 1) // 3) + 1</span>

    <span class="s0">@property</span>
    <span class="s0">def week(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the week number of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.week</span>
        <span class="s0">11</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return ccalendar.get_week_of_year(self.year, self.month, self.day)</span>

    <span class="s0">@property</span>
    <span class="s0">def days_in_month(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the number of days in the month.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14)</span>
        <span class="s0">&gt;&gt;&gt; ts.days_in_month</span>
        <span class="s0">31</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return ccalendar.get_days_in_month(self.year, self.month)</span>

    <span class="s0"># -----------------------------------------------------------------</span>
    <span class="s0"># Transformation Methods</span>

    <span class="s0">def normalize(self) -&gt; &quot;Timestamp&quot;:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Normalize Timestamp to midnight, preserving tz information.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14, 15, 30)</span>
        <span class="s0">&gt;&gt;&gt; ts.normalize()</span>
        <span class="s0">Timestamp('2020-03-14 00:00:00')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">local_val = self._maybe_convert_value_to_local()</span>
            <span class="s0">int64_t normalized</span>

        <span class="s0">normalized = normalize_i8_stamp(local_val)</span>
        <span class="s0">return Timestamp(normalized).tz_localize(self.tzinfo)</span>

    <span class="s0"># -----------------------------------------------------------------</span>
    <span class="s0"># Pickle Methods</span>

    <span class="s0">def __reduce_ex__(self, protocol):</span>
        <span class="s0"># python 3.6 compat</span>
        <span class="s0"># https://bugs.python.org/issue28730</span>
        <span class="s0"># now __reduce_ex__ is defined and higher priority than __reduce__</span>
        <span class="s0">return self.__reduce__()</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">self.value = state[0]</span>
        <span class="s0">self._freq = state[1]</span>
        <span class="s0">self.tzinfo = state[2]</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">object_state = self.value, self._freq, self.tzinfo</span>
        <span class="s0">return (_unpickle_timestamp, object_state)</span>

    <span class="s0"># -----------------------------------------------------------------</span>
    <span class="s0"># Rendering Methods</span>

    <span class="s0">def isoformat(self, sep: str = &quot;T&quot;, timespec: str = &quot;auto&quot;) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the time formatted according to ISO 8610.</span>

        <span class="s0">The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmmnnn'.</span>
        <span class="s0">By default, the fractional part is omitted if self.microsecond == 0</span>
        <span class="s0">and self.nanosecond == 0.</span>

        <span class="s0">If self.tzinfo is not None, the UTC offset is also attached, giving</span>
        <span class="s0">giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmmnnn+HH:MM'.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">sep : str, default 'T'</span>
            <span class="s0">String used as the separator between the date and time.</span>

        <span class="s0">timespec : str, default 'auto'</span>
            <span class="s0">Specifies the number of additional terms of the time to include.</span>
            <span class="s0">The valid values are 'auto', 'hours', 'minutes', 'seconds',</span>
            <span class="s0">'milliseconds', 'microseconds', and 'nanoseconds'.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.isoformat()</span>
        <span class="s0">'2020-03-14T15:32:52.192548651'</span>
        <span class="s0">&gt;&gt;&gt; ts.isoformat(timespec='microseconds')</span>
        <span class="s0">'2020-03-14T15:32:52.192548'</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base_ts = &quot;microseconds&quot; if timespec == &quot;nanoseconds&quot; else timespec</span>
        <span class="s0">base = super(_Timestamp, self).isoformat(sep=sep, timespec=base_ts)</span>
        <span class="s0">if self.nanosecond == 0 and timespec != &quot;nanoseconds&quot;:</span>
            <span class="s0">return base</span>

        <span class="s0">if self.tzinfo is not None:</span>
            <span class="s0">base1, base2 = base[:-6], base[-6:]</span>
        <span class="s0">else:</span>
            <span class="s0">base1, base2 = base, &quot;&quot;</span>

        <span class="s0">if timespec == &quot;nanoseconds&quot; or (timespec == &quot;auto&quot; and self.nanosecond):</span>
            <span class="s0">if self.microsecond:</span>
                <span class="s0">base1 += f&quot;{self.nanosecond:03d}&quot;</span>
            <span class="s0">else:</span>
                <span class="s0">base1 += f&quot;.{self.nanosecond:09d}&quot;</span>

        <span class="s0">return base1 + base2</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">stamp = self._repr_base</span>
        <span class="s0">zone = None</span>

        <span class="s0">try:</span>
            <span class="s0">stamp += self.strftime('%z')</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">year2000 = self.replace(year=2000)</span>
            <span class="s0">stamp += year2000.strftime('%z')</span>

        <span class="s0">if self.tzinfo:</span>
            <span class="s0">zone = get_timezone(self.tzinfo)</span>
        <span class="s0">try:</span>
            <span class="s0">stamp += zone.strftime(' %%Z')</span>
        <span class="s0">except AttributeError:</span>
            <span class="s0"># e.g. tzlocal has no `strftime`</span>
            <span class="s0">pass</span>

        <span class="s0">tz = f&quot;, tz='{zone}'&quot; if zone is not None else &quot;&quot;</span>
        <span class="s0">freq = &quot;&quot; if self._freq is None else f&quot;, freq='{self._freqstr}'&quot;</span>

        <span class="s0">return f&quot;Timestamp('{stamp}'{tz}{freq})&quot;</span>

    <span class="s0">@property</span>
    <span class="s0">def _repr_base(self) -&gt; str:</span>
        <span class="s0">return f&quot;{self._date_repr} {self._time_repr}&quot;</span>

    <span class="s0">@property</span>
    <span class="s0">def _date_repr(self) -&gt; str:</span>
        <span class="s0"># Ideal here would be self.strftime(&quot;%Y-%m-%d&quot;), but</span>
        <span class="s0"># the datetime strftime() methods require year &gt;= 1900</span>
        <span class="s0">return f'{self.year}-{self.month:02d}-{self.day:02d}'</span>

    <span class="s0">@property</span>
    <span class="s0">def _time_repr(self) -&gt; str:</span>
        <span class="s0">result = f'{self.hour:02d}:{self.minute:02d}:{self.second:02d}'</span>

        <span class="s0">if self.nanosecond != 0:</span>
            <span class="s0">result += f'.{self.nanosecond + 1000 * self.microsecond:09d}'</span>
        <span class="s0">elif self.microsecond != 0:</span>
            <span class="s0">result += f'.{self.microsecond:06d}'</span>

        <span class="s0">return result</span>

    <span class="s0">@property</span>
    <span class="s0">def _short_repr(self) -&gt; str:</span>
        <span class="s0"># format a Timestamp with only _date_repr if possible</span>
        <span class="s0"># otherwise _repr_base</span>
        <span class="s0">if (self.hour == 0 and</span>
                <span class="s0">self.minute == 0 and</span>
                <span class="s0">self.second == 0 and</span>
                <span class="s0">self.microsecond == 0 and</span>
                <span class="s0">self.nanosecond == 0):</span>
            <span class="s0">return self._date_repr</span>
        <span class="s0">return self._repr_base</span>

    <span class="s0"># -----------------------------------------------------------------</span>
    <span class="s0"># Conversion Methods</span>

    <span class="s0">@property</span>
    <span class="s0">def asm8(self) -&gt; np.datetime64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return numpy datetime64 format in nanoseconds.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(2020, 3, 14, 15)</span>
        <span class="s0">&gt;&gt;&gt; ts.asm8</span>
        <span class="s0">numpy.datetime64('2020-03-14T15:00:00.000000000')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return np.datetime64(self.value, 'ns')</span>

    <span class="s0">def timestamp(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return POSIX timestamp as float.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548')</span>
        <span class="s0">&gt;&gt;&gt; ts.timestamp()</span>
        <span class="s0">1584199972.192548</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># GH 17329</span>
        <span class="s0"># Note: Naive timestamps will not match datetime.stdlib</span>
        <span class="s0">return round(self.value / 1e9, 6)</span>

    <span class="s0">cpdef datetime to_pydatetime(_Timestamp self, bint warn=True):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert a Timestamp object to a native Python datetime object.</span>

        <span class="s0">If warn=True, issue a warning if nanoseconds is nonzero.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548')</span>
        <span class="s0">&gt;&gt;&gt; ts.to_pydatetime()</span>
        <span class="s0">datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.to_pydatetime()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.nanosecond != 0 and warn:</span>
            <span class="s0">warnings.warn(&quot;Discarding nonzero nanoseconds in conversion.&quot;,</span>
                          <span class="s0">UserWarning, stacklevel=2)</span>

        <span class="s0">return datetime(self.year, self.month, self.day,</span>
                        <span class="s0">self.hour, self.minute, self.second,</span>
                        <span class="s0">self.microsecond, self.tzinfo, fold=self.fold)</span>

    <span class="s0">cpdef to_datetime64(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a numpy.datetime64 object with 'ns' precision.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return np.datetime64(self.value, &quot;ns&quot;)</span>

    <span class="s0">def to_numpy(self, dtype=None, copy=False) -&gt; np.datetime64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert the Timestamp to a NumPy datetime64.</span>

        <span class="s0">.. versionadded:: 0.25.0</span>

        <span class="s0">This is an alias method for `Timestamp.to_datetime64()`. The dtype and</span>
        <span class="s0">copy parameters are available here only for compatibility. Their values</span>
        <span class="s0">will not affect the return value.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">numpy.datetime64</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">DatetimeIndex.to_numpy : Similar method for DatetimeIndex.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.to_numpy()</span>
        <span class="s0">numpy.datetime64('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.to_numpy()</span>
        <span class="s0">numpy.datetime64('NaT')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if dtype is not None or copy is not False:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;Timestamp.to_numpy dtype and copy arguments are ignored.&quot;</span>
            <span class="s0">)</span>
        <span class="s0">return self.to_datetime64()</span>

    <span class="s0">def to_period(self, freq=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return an period of which this timestamp is an observation.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; # Year end frequency</span>
        <span class="s0">&gt;&gt;&gt; ts.to_period(freq='Y')</span>
        <span class="s0">Period('2020', 'A-DEC')</span>

        <span class="s0">&gt;&gt;&gt; # Month end frequency</span>
        <span class="s0">&gt;&gt;&gt; ts.to_period(freq='M')</span>
        <span class="s0">Period('2020-03', 'M')</span>

        <span class="s0">&gt;&gt;&gt; # Weekly frequency</span>
        <span class="s0">&gt;&gt;&gt; ts.to_period(freq='W')</span>
        <span class="s0">Period('2020-03-09/2020-03-15', 'W-SUN')</span>

        <span class="s0">&gt;&gt;&gt; # Quarter end frequency</span>
        <span class="s0">&gt;&gt;&gt; ts.to_period(freq='Q')</span>
        <span class="s0">Period('2020Q1', 'Q-DEC')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">from pandas import Period</span>

        <span class="s0">if self.tz is not None:</span>
            <span class="s0"># GH#21333</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;Converting to Period representation will drop timezone information.&quot;,</span>
                <span class="s0">UserWarning,</span>
            <span class="s0">)</span>

        <span class="s0">if freq is None:</span>
            <span class="s0">freq = self._freq</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;In a future version, calling 'Timestamp.to_period()' without &quot;</span>
                <span class="s0">&quot;passing a 'freq' will raise an exception.&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=2,</span>
            <span class="s0">)</span>

        <span class="s0">return Period(self, freq=freq)</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0"># Python front end to C extension type _Timestamp</span>
<span class="s0"># This serves as the box for datetime64</span>


<span class="s0">class Timestamp(_Timestamp):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Pandas replacement for python datetime.datetime object.</span>

    <span class="s0">Timestamp is the pandas equivalent of python's Datetime</span>
    <span class="s0">and is interchangeable with it in most cases. It's the type used</span>
    <span class="s0">for the entries that make up a DatetimeIndex, and other timeseries</span>
    <span class="s0">oriented data structures in pandas.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">ts_input : datetime-like, str, int, float</span>
        <span class="s0">Value to be converted to Timestamp.</span>
    <span class="s0">freq : str, DateOffset</span>
        <span class="s0">Offset which Timestamp will have.</span>
    <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
        <span class="s0">Time zone for time which Timestamp will have.</span>
    <span class="s0">unit : str</span>
        <span class="s0">Unit used for conversion if ts_input is of type int or float. The</span>
        <span class="s0">valid values are 'D', 'h', 'm', 's', 'ms', 'us', and 'ns'. For</span>
        <span class="s0">example, 's' means seconds and 'ms' means milliseconds.</span>
    <span class="s0">year, month, day : int</span>
    <span class="s0">hour, minute, second, microsecond : int, optional, default 0</span>
    <span class="s0">nanosecond : int, optional, default 0</span>
    <span class="s0">tzinfo : datetime.tzinfo, optional, default None</span>
    <span class="s0">fold : {0, 1}, default None, keyword-only</span>
        <span class="s0">Due to daylight saving time, one wall clock time can occur twice</span>
        <span class="s0">when shifting from summer to winter time; fold describes whether the</span>
        <span class="s0">datetime-like corresponds  to the first (0) or the second time (1)</span>
        <span class="s0">the wall clock hits the ambiguous time.</span>

        <span class="s0">.. versionadded:: 1.1.0</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">There are essentially three calling conventions for the constructor. The</span>
    <span class="s0">primary form accepts four parameters. They can be passed by position or</span>
    <span class="s0">keyword.</span>

    <span class="s0">The other two forms mimic the parameters from ``datetime.datetime``. They</span>
    <span class="s0">can be passed by either position or keyword, but not both mixed together.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">Using the primary calling convention:</span>

    <span class="s0">This converts a datetime-like string</span>

    <span class="s0">&gt;&gt;&gt; pd.Timestamp('2017-01-01T12')</span>
    <span class="s0">Timestamp('2017-01-01 12:00:00')</span>

    <span class="s0">This converts a float representing a Unix epoch in units of seconds</span>

    <span class="s0">&gt;&gt;&gt; pd.Timestamp(1513393355.5, unit='s')</span>
    <span class="s0">Timestamp('2017-12-16 03:02:35.500000')</span>

    <span class="s0">This converts an int representing a Unix-epoch in units of seconds</span>
    <span class="s0">and for a particular timezone</span>

    <span class="s0">&gt;&gt;&gt; pd.Timestamp(1513393355, unit='s', tz='US/Pacific')</span>
    <span class="s0">Timestamp('2017-12-15 19:02:35-0800', tz='US/Pacific')</span>

    <span class="s0">Using the other two forms that mimic the API for ``datetime.datetime``:</span>

    <span class="s0">&gt;&gt;&gt; pd.Timestamp(2017, 1, 1, 12)</span>
    <span class="s0">Timestamp('2017-01-01 12:00:00')</span>

    <span class="s0">&gt;&gt;&gt; pd.Timestamp(year=2017, month=1, day=1, hour=12)</span>
    <span class="s0">Timestamp('2017-01-01 12:00:00')</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def fromordinal(cls, ordinal, freq=None, tz=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.fromordinal(ordinal, freq=None, tz=None)</span>

        <span class="s0">Passed an ordinal, translate and convert to a ts.</span>
        <span class="s0">Note: by definition there cannot be any tz info on the ordinal itself.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">ordinal : int</span>
            <span class="s0">Date corresponding to a proleptic Gregorian ordinal.</span>
        <span class="s0">freq : str, DateOffset</span>
            <span class="s0">Offset to apply to the Timestamp.</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for the Timestamp.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.fromordinal(737425)</span>
        <span class="s0">Timestamp('2020-01-01 00:00:00')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return cls(datetime.fromordinal(ordinal),</span>
                   <span class="s0">freq=freq, tz=tz)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def now(cls, tz=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.now(tz=None)</span>

        <span class="s0">Return new Timestamp object representing current time local to</span>
        <span class="s0">tz.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str or timezone object, default None</span>
            <span class="s0">Timezone to localize to.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.now()  # doctest: +SKIP</span>
        <span class="s0">Timestamp('2020-11-16 22:06:16.378782')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.now()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(tz, str):</span>
            <span class="s0">tz = maybe_get_tz(tz)</span>
        <span class="s0">return cls(datetime.now(tz))</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def today(cls, tz=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.today(cls, tz=None)</span>

        <span class="s0">Return the current time in the local timezone.  This differs</span>
        <span class="s0">from datetime.today() in that it can be localized to a</span>
        <span class="s0">passed timezone.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str or timezone object, default None</span>
            <span class="s0">Timezone to localize to.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.today()    # doctest: +SKIP</span>
        <span class="s0">Timestamp('2020-11-16 22:37:39.969883')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.today()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return cls.now(tz)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def utcnow(cls):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.utcnow()</span>

        <span class="s0">Return a new Timestamp representing UTC day and time.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.utcnow()   # doctest: +SKIP</span>
        <span class="s0">Timestamp('2020-11-16 22:50:18.092888+0000', tz='UTC')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return cls.now(UTC)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def utcfromtimestamp(cls, ts):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.utcfromtimestamp(ts)</span>

        <span class="s0">Construct a naive UTC datetime from a POSIX timestamp.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.utcfromtimestamp(1584199972)</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># GH#22451</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;The behavior of Timestamp.utcfromtimestamp is deprecated, in a &quot;</span>
            <span class="s0">&quot;future version will return a timezone-aware Timestamp with UTC &quot;</span>
            <span class="s0">&quot;timezone. To keep the old behavior, use &quot;</span>
            <span class="s0">&quot;Timestamp.utcfromtimestamp(ts).tz_localize(None). &quot;</span>
            <span class="s0">&quot;To get the future behavior, use Timestamp.fromtimestamp(ts, 'UTC')&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return cls(datetime.utcfromtimestamp(ts))</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def fromtimestamp(cls, ts, tz=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.fromtimestamp(ts)</span>

        <span class="s0">Transform timestamp[, tz] to tz's local time from POSIX timestamp.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.fromtimestamp(1584199972)</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>

        <span class="s0">Note that the output may change depending on your local time.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">tz = maybe_get_tz(tz)</span>
        <span class="s0">return cls(datetime.fromtimestamp(ts, tz))</span>

    <span class="s0">def strftime(self, format):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.strftime(format)</span>

        <span class="s0">Return a string representing the given POSIX timestamp</span>
        <span class="s0">controlled by an explicit format string.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">format : str</span>
            <span class="s0">Format string to convert Timestamp to string.</span>
            <span class="s0">See strftime documentation for more information on the format string:</span>
            <span class="s0">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.strftime('%Y-%m-%d %X')</span>
        <span class="s0">'2020-03-14 15:32:52'</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return datetime.strftime(self, format)</span>

    <span class="s0"># Issue 25016.</span>
    <span class="s0">@classmethod</span>
    <span class="s0">def strptime(cls, date_string, format):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.strptime(string, format)</span>

        <span class="s0">Function is not implemented. Use pd.to_datetime().</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">raise NotImplementedError(</span>
            <span class="s0">&quot;Timestamp.strptime() is not implemented. &quot;</span>
            <span class="s0">&quot;Use to_datetime() to parse date strings.&quot;</span>
        <span class="s0">)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def combine(cls, date, time):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.combine(date, time)</span>

        <span class="s0">Combine date, time into datetime with same date and time fields.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; from datetime import date, time</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.combine(date(2020, 3, 14), time(15, 30, 15))</span>
        <span class="s0">Timestamp('2020-03-14 15:30:15')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return cls(datetime.combine(date, time))</span>

    <span class="s0">def __new__(</span>
        <span class="s0">cls,</span>
        <span class="s0">object ts_input=_no_input,</span>
        <span class="s0">object freq=None,</span>
        <span class="s0">tz=None,</span>
        <span class="s0">unit=None,</span>
        <span class="s0">year=None,</span>
        <span class="s0">month=None,</span>
        <span class="s0">day=None,</span>
        <span class="s0">hour=None,</span>
        <span class="s0">minute=None,</span>
        <span class="s0">second=None,</span>
        <span class="s0">microsecond=None,</span>
        <span class="s0">nanosecond=None,</span>
        <span class="s0">tzinfo_type tzinfo=None,</span>
        <span class="s0">*,</span>
        <span class="s0">fold=None,</span>
    <span class="s0">):</span>
        <span class="s0"># The parameter list folds together legacy parameter names (the first</span>
        <span class="s0"># four) and positional and keyword parameter names from pydatetime.</span>
        <span class="s0">#</span>
        <span class="s0"># There are three calling forms:</span>
        <span class="s0">#</span>
        <span class="s0"># - In the legacy form, the first parameter, ts_input, is required</span>
        <span class="s0">#   and may be datetime-like, str, int, or float. The second</span>
        <span class="s0">#   parameter, offset, is optional and may be str or DateOffset.</span>
        <span class="s0">#</span>
        <span class="s0"># - ints in the first, second, and third arguments indicate</span>
        <span class="s0">#   pydatetime positional arguments. Only the first 8 arguments</span>
        <span class="s0">#   (standing in for year, month, day, hour, minute, second,</span>
        <span class="s0">#   microsecond, tzinfo) may be non-None. As a shortcut, we just</span>
        <span class="s0">#   check that the second argument is an int.</span>
        <span class="s0">#</span>
        <span class="s0"># - Nones for the first four (legacy) arguments indicate pydatetime</span>
        <span class="s0">#   keyword arguments. year, month, and day are required. As a</span>
        <span class="s0">#   shortcut, we just check that the first argument was not passed.</span>
        <span class="s0">#</span>
        <span class="s0"># Mixing pydatetime positional and keyword arguments is forbidden!</span>

        <span class="s0">cdef:</span>
            <span class="s0">_TSObject ts</span>
            <span class="s0">tzinfo_type tzobj</span>

        <span class="s0">_date_attributes = [year, month, day, hour, minute, second,</span>
                            <span class="s0">microsecond, nanosecond]</span>

        <span class="s0">if tzinfo is not None:</span>
            <span class="s0"># GH#17690 tzinfo must be a datetime.tzinfo object, ensured</span>
            <span class="s0">#  by the cython annotation.</span>
            <span class="s0">if tz is not None:</span>
                <span class="s0">raise ValueError('Can provide at most one of tz, tzinfo')</span>

            <span class="s0"># User passed tzinfo instead of tz; avoid silently ignoring</span>
            <span class="s0">tz, tzinfo = tzinfo, None</span>

        <span class="s0"># Allow fold only for unambiguous input</span>
        <span class="s0">if fold is not None:</span>
            <span class="s0">if fold not in [0, 1]:</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;Valid values for the fold argument are None, 0, or 1.&quot;</span>
                <span class="s0">)</span>

            <span class="s0">if (ts_input is not _no_input and not (</span>
                    <span class="s0">PyDateTime_Check(ts_input) and</span>
                    <span class="s0">getattr(ts_input, 'tzinfo', None) is None)):</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;Cannot pass fold with possibly unambiguous input: int, &quot;</span>
                    <span class="s0">&quot;float, numpy.datetime64, str, or timezone-aware &quot;</span>
                    <span class="s0">&quot;datetime-like. Pass naive datetime-like or build &quot;</span>
                    <span class="s0">&quot;Timestamp from components.&quot;</span>
                <span class="s0">)</span>

            <span class="s0">if tz is not None and PyTZInfo_Check(tz) and treat_tz_as_pytz(tz):</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;pytz timezones do not support fold. Please use dateutil &quot;</span>
                    <span class="s0">&quot;timezones.&quot;</span>
                <span class="s0">)</span>

            <span class="s0">if hasattr(ts_input, 'fold'):</span>
                <span class="s0">ts_input = ts_input.replace(fold=fold)</span>

        <span class="s0"># GH 30543 if pd.Timestamp already passed, return it</span>
        <span class="s0"># check that only ts_input is passed</span>
        <span class="s0"># checking verbosely, because cython doesn't optimize</span>
        <span class="s0"># list comprehensions (as of cython 0.29.x)</span>
        <span class="s0">if (isinstance(ts_input, _Timestamp) and freq is None and</span>
                <span class="s0">tz is None and unit is None and year is None and</span>
                <span class="s0">month is None and day is None and hour is None and</span>
                <span class="s0">minute is None and second is None and</span>
                <span class="s0">microsecond is None and nanosecond is None and</span>
                <span class="s0">tzinfo is None):</span>
            <span class="s0">return ts_input</span>
        <span class="s0">elif isinstance(ts_input, str):</span>
            <span class="s0"># User passed a date string to parse.</span>
            <span class="s0"># Check that the user didn't also pass a date attribute kwarg.</span>
            <span class="s0">if any(arg is not None for arg in _date_attributes):</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;Cannot pass a date attribute keyword &quot;</span>
                    <span class="s0">&quot;argument when passing a date string&quot;</span>
                <span class="s0">)</span>

        <span class="s0">elif ts_input is _no_input:</span>
            <span class="s0"># GH 31200</span>
            <span class="s0"># When year, month or day is not given, we call the datetime</span>
            <span class="s0"># constructor to make sure we get the same error message</span>
            <span class="s0"># since Timestamp inherits datetime</span>
            <span class="s0">datetime_kwargs = {</span>
                <span class="s0">&quot;hour&quot;: hour or 0,</span>
                <span class="s0">&quot;minute&quot;: minute or 0,</span>
                <span class="s0">&quot;second&quot;: second or 0,</span>
                <span class="s0">&quot;microsecond&quot;: microsecond or 0,</span>
                <span class="s0">&quot;fold&quot;: fold or 0</span>
            <span class="s0">}</span>
            <span class="s0">if year is not None:</span>
                <span class="s0">datetime_kwargs[&quot;year&quot;] = year</span>
            <span class="s0">if month is not None:</span>
                <span class="s0">datetime_kwargs[&quot;month&quot;] = month</span>
            <span class="s0">if day is not None:</span>
                <span class="s0">datetime_kwargs[&quot;day&quot;] = day</span>

            <span class="s0">ts_input = datetime(**datetime_kwargs)</span>

        <span class="s0">elif is_integer_object(freq):</span>
            <span class="s0"># User passed positional arguments:</span>
            <span class="s0"># Timestamp(year, month, day[, hour[, minute[, second[,</span>
            <span class="s0"># microsecond[, nanosecond[, tzinfo]]]]]])</span>
            <span class="s0">ts_input = datetime(ts_input, freq, tz, unit or 0,</span>
                                <span class="s0">year or 0, month or 0, day or 0, fold=fold or 0)</span>
            <span class="s0">nanosecond = hour</span>
            <span class="s0">tz = minute</span>
            <span class="s0">freq = None</span>
            <span class="s0">unit = None</span>

        <span class="s0">if getattr(ts_input, 'tzinfo', None) is not None and tz is not None:</span>
            <span class="s0">raise ValueError(&quot;Cannot pass a datetime or Timestamp with tzinfo with &quot;</span>
                             <span class="s0">&quot;the tz parameter. Use tz_convert instead.&quot;)</span>

        <span class="s0">tzobj = maybe_get_tz(tz)</span>
        <span class="s0">if tzobj is not None and is_datetime64_object(ts_input):</span>
            <span class="s0"># GH#24559, GH#42288 In the future we will treat datetime64 as</span>
            <span class="s0">#  wall-time (consistent with DatetimeIndex)</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;In a future version, when passing a np.datetime64 object and &quot;</span>
                <span class="s0">&quot;a timezone to Timestamp, the datetime64 will be interpreted &quot;</span>
                <span class="s0">&quot;as a wall time, not a UTC time.  To interpret as a UTC time, &quot;</span>
                <span class="s0">&quot;use `Timestamp(dt64).tz_localize('UTC').tz_convert(tz)`&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=1,</span>
            <span class="s0">)</span>
            <span class="s0"># Once this deprecation is enforced, we can do</span>
            <span class="s0">#  return Timestamp(ts_input).tz_localize(tzobj)</span>
        <span class="s0">ts = convert_to_tsobject(ts_input, tzobj, unit, 0, 0, nanosecond or 0)</span>

        <span class="s0">if ts.value == NPY_NAT:</span>
            <span class="s0">return NaT</span>

        <span class="s0">if freq is None:</span>
            <span class="s0"># GH 22311: Try to extract the frequency of a given Timestamp input</span>
            <span class="s0">freq = getattr(ts_input, '_freq', None)</span>
        <span class="s0">else:</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;The 'freq' argument in Timestamp is deprecated and will be &quot;</span>
                <span class="s0">&quot;removed in a future version.&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=1,</span>
            <span class="s0">)</span>
            <span class="s0">if not is_offset_object(freq):</span>
                <span class="s0">freq = to_offset(freq)</span>

        <span class="s0">return create_timestamp_from_ts(ts.value, ts.dts, ts.tzinfo, freq, ts.fold)</span>

    <span class="s0">def _round(self, freq, mode, ambiguous='raise', nonexistent='raise'):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t nanos = to_offset(freq).nanos</span>

        <span class="s0">if self.tz is not None:</span>
            <span class="s0">value = self.tz_localize(None).value</span>
        <span class="s0">else:</span>
            <span class="s0">value = self.value</span>

        <span class="s0">value = np.array([value], dtype=np.int64)</span>

        <span class="s0"># Will only ever contain 1 element for timestamp</span>
        <span class="s0">r = round_nsint64(value, mode, nanos)[0]</span>
        <span class="s0">result = Timestamp(r, unit='ns')</span>
        <span class="s0">if self.tz is not None:</span>
            <span class="s0">result = result.tz_localize(</span>
                <span class="s0">self.tz, ambiguous=ambiguous, nonexistent=nonexistent</span>
            <span class="s0">)</span>
        <span class="s0">return result</span>

    <span class="s0">def round(self, freq, ambiguous='raise', nonexistent='raise'):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Round the Timestamp to the specified resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the rounding resolution.</span>
        <span class="s0">ambiguous : bool or {'raise', 'NaT'}, default 'raise'</span>
            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : {'raise', 'shift_forward', 'shift_backward, 'NaT', \</span>
<span class="s0">timedelta}, default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">a new Timestamp rounded to the given resolution of `freq`</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">If the Timestamp has a timezone, rounding will take place relative to the</span>
        <span class="s0">local (&quot;wall&quot;) time and re-localized to the same timezone. When rounding</span>
        <span class="s0">near daylight savings time, use ``nonexistent`` and ``ambiguous`` to</span>
        <span class="s0">control the re-localization behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">A timestamp can be rounded using multiple frequency units:</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='H') # hour</span>
        <span class="s0">Timestamp('2020-03-14 16:00:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='T') # minute</span>
        <span class="s0">Timestamp('2020-03-14 15:33:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='S') # seconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='L') # milliseconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.193000')</span>

        <span class="s0">``freq`` can also be a multiple of a single unit, like '5T' (i.e.  5 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='5T')</span>
        <span class="s0">Timestamp('2020-03-14 15:35:00')</span>

        <span class="s0">or a combination of multiple units, like '1H30T' (i.e. 1 hour and 30 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='1H30T')</span>
        <span class="s0">Timestamp('2020-03-14 15:00:00')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.round()</span>
        <span class="s0">NaT</span>

        <span class="s0">When rounding near a daylight savings time transition, use ``ambiguous`` or</span>
        <span class="s0">``nonexistent`` to control how the timestamp should be re-localized.</span>

        <span class="s0">&gt;&gt;&gt; ts_tz = pd.Timestamp(&quot;2021-10-31 01:30:00&quot;).tz_localize(&quot;Europe/Amsterdam&quot;)</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.round(&quot;H&quot;, ambiguous=False)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0100', tz='Europe/Amsterdam')</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.round(&quot;H&quot;, ambiguous=True)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0200', tz='Europe/Amsterdam')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._round(</span>
            <span class="s0">freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent</span>
        <span class="s0">)</span>

    <span class="s0">def floor(self, freq, ambiguous='raise', nonexistent='raise'):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a new Timestamp floored to this resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the flooring resolution.</span>
        <span class="s0">ambiguous : bool or {'raise', 'NaT'}, default 'raise'</span>
            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : {'raise', 'shift_forward', 'shift_backward, 'NaT', \</span>
<span class="s0">timedelta}, default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">If the Timestamp has a timezone, flooring will take place relative to the</span>
        <span class="s0">local (&quot;wall&quot;) time and re-localized to the same timezone. When flooring</span>
        <span class="s0">near daylight savings time, use ``nonexistent`` and ``ambiguous`` to</span>
        <span class="s0">control the re-localization behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">A timestamp can be floored using multiple frequency units:</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='H') # hour</span>
        <span class="s0">Timestamp('2020-03-14 15:00:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='T') # minute</span>
        <span class="s0">Timestamp('2020-03-14 15:32:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='S') # seconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='N') # nanoseconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651')</span>

        <span class="s0">``freq`` can also be a multiple of a single unit, like '5T' (i.e.  5 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='5T')</span>
        <span class="s0">Timestamp('2020-03-14 15:30:00')</span>

        <span class="s0">or a combination of multiple units, like '1H30T' (i.e. 1 hour and 30 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='1H30T')</span>
        <span class="s0">Timestamp('2020-03-14 15:00:00')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.floor()</span>
        <span class="s0">NaT</span>

        <span class="s0">When rounding near a daylight savings time transition, use ``ambiguous`` or</span>
        <span class="s0">``nonexistent`` to control how the timestamp should be re-localized.</span>

        <span class="s0">&gt;&gt;&gt; ts_tz = pd.Timestamp(&quot;2021-10-31 03:30:00&quot;).tz_localize(&quot;Europe/Amsterdam&quot;)</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.floor(&quot;2H&quot;, ambiguous=False)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0100', tz='Europe/Amsterdam')</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.floor(&quot;2H&quot;, ambiguous=True)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0200', tz='Europe/Amsterdam')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)</span>

    <span class="s0">def ceil(self, freq, ambiguous='raise', nonexistent='raise'):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a new Timestamp ceiled to this resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the ceiling resolution.</span>
        <span class="s0">ambiguous : bool or {'raise', 'NaT'}, default 'raise'</span>
            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : {'raise', 'shift_forward', 'shift_backward, 'NaT', \</span>
<span class="s0">timedelta}, default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">If the Timestamp has a timezone, ceiling will take place relative to the</span>
        <span class="s0">local (&quot;wall&quot;) time and re-localized to the same timezone. When ceiling</span>
        <span class="s0">near daylight savings time, use ``nonexistent`` and ``ambiguous`` to</span>
        <span class="s0">control the re-localization behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">A timestamp can be ceiled using multiple frequency units:</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='H') # hour</span>
        <span class="s0">Timestamp('2020-03-14 16:00:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='T') # minute</span>
        <span class="s0">Timestamp('2020-03-14 15:33:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='S') # seconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:53')</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='U') # microseconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192549')</span>

        <span class="s0">``freq`` can also be a multiple of a single unit, like '5T' (i.e.  5 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='5T')</span>
        <span class="s0">Timestamp('2020-03-14 15:35:00')</span>

        <span class="s0">or a combination of multiple units, like '1H30T' (i.e. 1 hour and 30 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='1H30T')</span>
        <span class="s0">Timestamp('2020-03-14 16:30:00')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.ceil()</span>
        <span class="s0">NaT</span>

        <span class="s0">When rounding near a daylight savings time transition, use ``ambiguous`` or</span>
        <span class="s0">``nonexistent`` to control how the timestamp should be re-localized.</span>

        <span class="s0">&gt;&gt;&gt; ts_tz = pd.Timestamp(&quot;2021-10-31 01:30:00&quot;).tz_localize(&quot;Europe/Amsterdam&quot;)</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.ceil(&quot;H&quot;, ambiguous=False)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0100', tz='Europe/Amsterdam')</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.ceil(&quot;H&quot;, ambiguous=True)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0200', tz='Europe/Amsterdam')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)</span>

    <span class="s0">@property</span>
    <span class="s0">def tz(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Alias for tzinfo.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp(1584226800, unit='s', tz='Europe/Stockholm')</span>
        <span class="s0">&gt;&gt;&gt; ts.tz</span>
        <span class="s0">&lt;DstTzInfo 'Europe/Stockholm' CET+1:00:00 STD&gt;</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.tzinfo</span>

    <span class="s0">@tz.setter</span>
    <span class="s0">def tz(self, value):</span>
        <span class="s0"># GH 3746: Prevent localizing or converting the index by setting tz</span>
        <span class="s0">raise AttributeError(</span>
            <span class="s0">&quot;Cannot directly set timezone. &quot;</span>
            <span class="s0">&quot;Use tz_localize() or tz_convert() as appropriate&quot;</span>
        <span class="s0">)</span>

    <span class="s0">@property</span>
    <span class="s0">def _freqstr(self):</span>
        <span class="s0">return getattr(self._freq, &quot;freqstr&quot;, self._freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def freqstr(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the total number of days in the month.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;Timestamp.freqstr is deprecated and will be removed in a future version.&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return self._freqstr</span>

    <span class="s0">def tz_localize(self, tz, ambiguous='raise', nonexistent='raise'):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert naive Timestamp to local time zone, or remove</span>
        <span class="s0">timezone from timezone-aware Timestamp.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for time which Timestamp will be converted to.</span>
            <span class="s0">None will remove timezone holding local time.</span>

        <span class="s0">ambiguous : bool, 'NaT', default 'raise'</span>
            <span class="s0">When clocks moved backward due to DST, ambiguous times may arise.</span>
            <span class="s0">For example in Central European Time (UTC+01), when going from</span>
            <span class="s0">03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at</span>
            <span class="s0">00:30:00 UTC and at 01:30:00 UTC. In such a situation, the</span>
            <span class="s0">`ambiguous` parameter dictates how ambiguous times should be</span>
            <span class="s0">handled.</span>

            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : 'shift_forward', 'shift_backward, 'NaT', timedelta, \</span>
<span class="s0">default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">localized : Timestamp</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">TypeError</span>
            <span class="s0">If the Timestamp is tz-aware and tz is not None.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a naive timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651')</span>

        <span class="s0">Add 'Europe/Stockholm' as timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts.tz_localize(tz='Europe/Stockholm')</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0100', tz='Europe/Stockholm')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.tz_localize()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if ambiguous == 'infer':</span>
            <span class="s0">raise ValueError('Cannot infer offset with only one time.')</span>

        <span class="s0">nonexistent_options = ('raise', 'NaT', 'shift_forward', 'shift_backward')</span>
        <span class="s0">if nonexistent not in nonexistent_options and not PyDelta_Check(nonexistent):</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;The nonexistent argument must be one of 'raise', &quot;</span>
                <span class="s0">&quot;'NaT', 'shift_forward', 'shift_backward' or a timedelta object&quot;</span>
            <span class="s0">)</span>

        <span class="s0">if self.tzinfo is None:</span>
            <span class="s0"># tz naive, localize</span>
            <span class="s0">tz = maybe_get_tz(tz)</span>
            <span class="s0">if not isinstance(ambiguous, str):</span>
                <span class="s0">ambiguous = [ambiguous]</span>
            <span class="s0">value = tz_localize_to_utc_single(self.value, tz,</span>
                                              <span class="s0">ambiguous=ambiguous,</span>
                                              <span class="s0">nonexistent=nonexistent)</span>
            <span class="s0">out = Timestamp(value, tz=tz)</span>
            <span class="s0">if out is not NaT:</span>
                <span class="s0">out._set_freq(self._freq)  # avoid warning in constructor</span>
            <span class="s0">return out</span>
        <span class="s0">else:</span>
            <span class="s0">if tz is None:</span>
                <span class="s0"># reset tz</span>
                <span class="s0">value = tz_convert_from_utc_single(self.value, self.tz)</span>
                <span class="s0">out = Timestamp(value, tz=tz)</span>
                <span class="s0">if out is not NaT:</span>
                    <span class="s0">out._set_freq(self._freq)  # avoid warning in constructor</span>
                <span class="s0">return out</span>
            <span class="s0">else:</span>
                <span class="s0">raise TypeError(</span>
                    <span class="s0">&quot;Cannot localize tz-aware Timestamp, use tz_convert for conversions&quot;</span>
                <span class="s0">)</span>

    <span class="s0">def tz_convert(self, tz):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert timezone-aware Timestamp to another time zone.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for time which Timestamp will be converted to.</span>
            <span class="s0">None will remove timezone holding UTC time.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">converted : Timestamp</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">TypeError</span>
            <span class="s0">If Timestamp is tz-naive.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object with UTC timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651', tz='UTC')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Change to Tokyo timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts.tz_convert(tz='Asia/Tokyo')</span>
        <span class="s0">Timestamp('2020-03-15 00:32:52.192548651+0900', tz='Asia/Tokyo')</span>

        <span class="s0">Can also use ``astimezone``:</span>

        <span class="s0">&gt;&gt;&gt; ts.astimezone(tz='Asia/Tokyo')</span>
        <span class="s0">Timestamp('2020-03-15 00:32:52.192548651+0900', tz='Asia/Tokyo')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.tz_convert(tz='Asia/Tokyo')</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.tzinfo is None:</span>
            <span class="s0"># tz naive, use tz_localize</span>
            <span class="s0">raise TypeError(</span>
                <span class="s0">&quot;Cannot convert tz-naive Timestamp, use tz_localize to localize&quot;</span>
            <span class="s0">)</span>
        <span class="s0">else:</span>
            <span class="s0"># Same UTC timestamp, different time zone</span>
            <span class="s0">out = Timestamp(self.value, tz=tz)</span>
            <span class="s0">if out is not NaT:</span>
                <span class="s0">out._set_freq(self._freq)  # avoid warning in constructor</span>
            <span class="s0">return out</span>

    <span class="s0">astimezone = tz_convert</span>

    <span class="s0">def replace(</span>
        <span class="s0">self,</span>
        <span class="s0">year=None,</span>
        <span class="s0">month=None,</span>
        <span class="s0">day=None,</span>
        <span class="s0">hour=None,</span>
        <span class="s0">minute=None,</span>
        <span class="s0">second=None,</span>
        <span class="s0">microsecond=None,</span>
        <span class="s0">nanosecond=None,</span>
        <span class="s0">tzinfo=object,</span>
        <span class="s0">fold=None,</span>
    <span class="s0">):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Implements datetime.replace, handles nanoseconds.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">year : int, optional</span>
        <span class="s0">month : int, optional</span>
        <span class="s0">day : int, optional</span>
        <span class="s0">hour : int, optional</span>
        <span class="s0">minute : int, optional</span>
        <span class="s0">second : int, optional</span>
        <span class="s0">microsecond : int, optional</span>
        <span class="s0">nanosecond : int, optional</span>
        <span class="s0">tzinfo : tz-convertible, optional</span>
        <span class="s0">fold : int, optional</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">Timestamp with fields replaced</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651', tz='UTC')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Replace year and the hour:</span>

        <span class="s0">&gt;&gt;&gt; ts.replace(year=1999, hour=10)</span>
        <span class="s0">Timestamp('1999-03-14 10:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Replace timezone (not a conversion):</span>

        <span class="s0">&gt;&gt;&gt; import pytz</span>
        <span class="s0">&gt;&gt;&gt; ts.replace(tzinfo=pytz.timezone('US/Pacific'))</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651-0700', tz='US/Pacific')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.replace(tzinfo=pytz.timezone('US/Pacific'))</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;</span>

        <span class="s0">cdef:</span>
            <span class="s0">npy_datetimestruct dts</span>
            <span class="s0">int64_t value</span>
            <span class="s0">object k, v</span>
            <span class="s0">datetime ts_input</span>
            <span class="s0">tzinfo_type tzobj</span>

        <span class="s0"># set to naive if needed</span>
        <span class="s0">tzobj = self.tzinfo</span>
        <span class="s0">value = self.value</span>

        <span class="s0"># GH 37610. Preserve fold when replacing.</span>
        <span class="s0">if fold is None:</span>
            <span class="s0">fold = self.fold</span>

        <span class="s0">if tzobj is not None:</span>
            <span class="s0">value = tz_convert_from_utc_single(value, tzobj)</span>

        <span class="s0"># setup components</span>
        <span class="s0">dt64_to_dtstruct(value, &amp;dts)</span>
        <span class="s0">dts.ps = self.nanosecond * 1000</span>

        <span class="s0"># replace</span>
        <span class="s0">def validate(k, v):</span>
            <span class="s0">&quot;&quot;&quot; validate integers &quot;&quot;&quot;</span>
            <span class="s0">if not is_integer_object(v):</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">f&quot;value must be an integer, received {type(v)} for {k}&quot;</span>
                <span class="s0">)</span>
            <span class="s0">return v</span>

        <span class="s0">if year is not None:</span>
            <span class="s0">dts.year = validate('year', year)</span>
        <span class="s0">if month is not None:</span>
            <span class="s0">dts.month = validate('month', month)</span>
        <span class="s0">if day is not None:</span>
            <span class="s0">dts.day = validate('day', day)</span>
        <span class="s0">if hour is not None:</span>
            <span class="s0">dts.hour = validate('hour', hour)</span>
        <span class="s0">if minute is not None:</span>
            <span class="s0">dts.min = validate('minute', minute)</span>
        <span class="s0">if second is not None:</span>
            <span class="s0">dts.sec = validate('second', second)</span>
        <span class="s0">if microsecond is not None:</span>
            <span class="s0">dts.us = validate('microsecond', microsecond)</span>
        <span class="s0">if nanosecond is not None:</span>
            <span class="s0">dts.ps = validate('nanosecond', nanosecond) * 1000</span>
        <span class="s0">if tzinfo is not object:</span>
            <span class="s0">tzobj = tzinfo</span>

        <span class="s0"># reconstruct &amp; check bounds</span>
        <span class="s0">if tzobj is not None and treat_tz_as_pytz(tzobj):</span>
            <span class="s0"># replacing across a DST boundary may induce a new tzinfo object</span>
            <span class="s0"># see GH#18319</span>
            <span class="s0">ts_input = tzobj.localize(datetime(dts.year, dts.month, dts.day,</span>
                                               <span class="s0">dts.hour, dts.min, dts.sec,</span>
                                               <span class="s0">dts.us),</span>
                                      <span class="s0">is_dst=not bool(fold))</span>
            <span class="s0">tzobj = ts_input.tzinfo</span>
        <span class="s0">else:</span>
            <span class="s0">kwargs = {'year': dts.year, 'month': dts.month, 'day': dts.day,</span>
                      <span class="s0">'hour': dts.hour, 'minute': dts.min, 'second': dts.sec,</span>
                      <span class="s0">'microsecond': dts.us, 'tzinfo': tzobj,</span>
                      <span class="s0">'fold': fold}</span>
            <span class="s0">ts_input = datetime(**kwargs)</span>

        <span class="s0">ts = convert_datetime_to_tsobject(ts_input, tzobj)</span>
        <span class="s0">value = ts.value + (dts.ps // 1000)</span>
        <span class="s0">if value != NPY_NAT:</span>
            <span class="s0">check_dts_bounds(&amp;dts)</span>

        <span class="s0">return create_timestamp_from_ts(value, dts, tzobj, self._freq, fold)</span>

    <span class="s0">def to_julian_date(self) -&gt; np.float64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert TimeStamp to a Julian Date.</span>
        <span class="s0">0 Julian date is noon January 1, 4713 BC.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52')</span>
        <span class="s0">&gt;&gt;&gt; ts.to_julian_date()</span>
        <span class="s0">2458923.147824074</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">year = self.year</span>
        <span class="s0">month = self.month</span>
        <span class="s0">day = self.day</span>
        <span class="s0">if month &lt;= 2:</span>
            <span class="s0">year -= 1</span>
            <span class="s0">month += 12</span>
        <span class="s0">return (day +</span>
                <span class="s0">np.fix((153 * month - 457) / 5) +</span>
                <span class="s0">365 * year +</span>
                <span class="s0">np.floor(year / 4) -</span>
                <span class="s0">np.floor(year / 100) +</span>
                <span class="s0">np.floor(year / 400) +</span>
                <span class="s0">1721118.5 +</span>
                <span class="s0">(self.hour +</span>
                 <span class="s0">self.minute / 60.0 +</span>
                 <span class="s0">self.second / 3600.0 +</span>
                 <span class="s0">self.microsecond / 3600.0 / 1e+6 +</span>
                 <span class="s0">self.nanosecond / 3600.0 / 1e+9</span>
                 <span class="s0">) / 24.0)</span>

    <span class="s0">def isoweekday(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day of the week represented by the date.</span>
        <span class="s0">Monday == 1 ... Sunday == 7.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return super().isoweekday()</span>

    <span class="s0">def weekday(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day of the week represented by the date.</span>
        <span class="s0">Monday == 0 ... Sunday == 6.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return super().weekday()</span>


<span class="s0"># Aliases</span>
<span class="s0">Timestamp.weekofyear = Timestamp.week</span>
<span class="s0">Timestamp.daysinmonth = Timestamp.days_in_month</span>

<span class="s0"># Add the min and max fields at the class level</span>
<span class="s0">cdef int64_t _NS_UPPER_BOUND = np.iinfo(np.int64).max</span>
<span class="s0">cdef int64_t _NS_LOWER_BOUND = NPY_NAT + 1</span>

<span class="s0"># Resolution is in nanoseconds</span>
<span class="s0">Timestamp.min = Timestamp(_NS_LOWER_BOUND)</span>
<span class="s0">Timestamp.max = Timestamp(_NS_UPPER_BOUND)</span>
<span class="s0">Timestamp.resolution = Timedelta(nanoseconds=1)  # GH#21336, GH#21365</span>
</pre>
</body>
</html>