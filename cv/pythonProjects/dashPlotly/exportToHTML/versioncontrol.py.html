<html>
<head>
<title>versioncontrol.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
versioncontrol.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Handles all VCS (version control) support&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">urllib.parse</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pip._internal.cli.spinners </span><span class="s2">import </span><span class="s1">SpinnerInterface</span>
<span class="s2">from </span><span class="s1">pip._internal.exceptions </span><span class="s2">import </span><span class="s1">BadCommand</span><span class="s2">, </span><span class="s1">InstallationError</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.misc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">HiddenText</span><span class="s2">,</span>
    <span class="s1">ask_path_exists</span><span class="s2">,</span>
    <span class="s1">backup_dir</span><span class="s2">,</span>
    <span class="s1">display_path</span><span class="s2">,</span>
    <span class="s1">hide_url</span><span class="s2">,</span>
    <span class="s1">hide_value</span><span class="s2">,</span>
    <span class="s1">is_installable_dir</span><span class="s2">,</span>
    <span class="s1">rmtree</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.subprocess </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CommandArgs</span><span class="s2">,</span>
    <span class="s1">call_subprocess</span><span class="s2">,</span>
    <span class="s1">format_command_args</span><span class="s2">,</span>
    <span class="s1">make_command</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.urls </span><span class="s2">import </span><span class="s1">get_url_scheme</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s3"># Literal was introduced in Python 3.8.</span>
    <span class="s3">#</span>
    <span class="s3"># TODO: Remove `if TYPE_CHECKING` when dropping support for Python 3.7.</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span>


<span class="s1">__all__ = [</span><span class="s4">&quot;vcs&quot;</span><span class="s1">]</span>


<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">AuthInfo = Tuple[Optional[str]</span><span class="s2">, </span><span class="s1">Optional[str]]</span>


<span class="s2">def </span><span class="s1">is_url(name: str) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return true if the name looks like a URL. 
    &quot;&quot;&quot;</span>
    <span class="s1">scheme = get_url_scheme(name)</span>
    <span class="s2">if </span><span class="s1">scheme </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;http&quot;</span><span class="s2">, </span><span class="s4">&quot;https&quot;</span><span class="s2">, </span><span class="s4">&quot;file&quot;</span><span class="s2">, </span><span class="s4">&quot;ftp&quot;</span><span class="s1">] + vcs.all_schemes</span>


<span class="s2">def </span><span class="s1">make_vcs_requirement_url(</span>
    <span class="s1">repo_url: str</span><span class="s2">, </span><span class="s1">rev: str</span><span class="s2">, </span><span class="s1">project_name: str</span><span class="s2">, </span><span class="s1">subdir: Optional[str] = </span><span class="s2">None</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the URL for a VCS requirement. 
 
    Args: 
      repo_url: the remote VCS url, with any needed VCS prefix (e.g. &quot;git+&quot;). 
      project_name: the (unescaped) project name. 
    &quot;&quot;&quot;</span>
    <span class="s1">egg_project_name = project_name.replace(</span><span class="s4">&quot;-&quot;</span><span class="s2">, </span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>
    <span class="s1">req = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">repo_url</span><span class="s2">}</span><span class="s4">@</span><span class="s2">{</span><span class="s1">rev</span><span class="s2">}</span><span class="s4">#egg=</span><span class="s2">{</span><span class="s1">egg_project_name</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s2">if </span><span class="s1">subdir:</span>
        <span class="s1">req += </span><span class="s4">f&quot;&amp;subdirectory=</span><span class="s2">{</span><span class="s1">subdir</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">return </span><span class="s1">req</span>


<span class="s2">def </span><span class="s1">find_path_to_project_root_from_repo_root(</span>
    <span class="s1">location: str</span><span class="s2">, </span><span class="s1">repo_root: str</span>
<span class="s1">) -&gt; Optional[str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the the Python project's root by searching up the filesystem from 
    `location`. Return the path to project root relative to `repo_root`. 
    Return None if the project root is `repo_root`, or cannot be found. 
    &quot;&quot;&quot;</span>
    <span class="s3"># find project root.</span>
    <span class="s1">orig_location = location</span>
    <span class="s2">while not </span><span class="s1">is_installable_dir(location):</span>
        <span class="s1">last_location = location</span>
        <span class="s1">location = os.path.dirname(location)</span>
        <span class="s2">if </span><span class="s1">location == last_location:</span>
            <span class="s3"># We've traversed up to the root of the filesystem without</span>
            <span class="s3"># finding a Python project.</span>
            <span class="s1">logger.warning(</span>
                <span class="s4">&quot;Could not find a Python project for directory %s (tried all &quot;</span>
                <span class="s4">&quot;parent directories)&quot;</span><span class="s2">,</span>
                <span class="s1">orig_location</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">os.path.samefile(repo_root</span><span class="s2">, </span><span class="s1">location):</span>
        <span class="s2">return None</span>

    <span class="s2">return </span><span class="s1">os.path.relpath(location</span><span class="s2">, </span><span class="s1">repo_root)</span>


<span class="s2">class </span><span class="s1">RemoteNotFoundError(Exception):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">RemoteNotValidError(Exception):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">url: str):</span>
        <span class="s1">super().__init__(url)</span>
        <span class="s1">self.url = url</span>


<span class="s2">class </span><span class="s1">RevOptions:</span>

    <span class="s0">&quot;&quot;&quot; 
    Encapsulates a VCS-specific revision to install, along with any VCS 
    install options. 
 
    Instances of this class should be treated as if immutable. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">vc_class: Type[</span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">rev: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">extra_args: Optional[CommandArgs] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Args: 
          vc_class: a VersionControl subclass. 
          rev: the name of the revision to install. 
          extra_args: a list of extra options. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">extra_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">extra_args = []</span>

        <span class="s1">self.extra_args = extra_args</span>
        <span class="s1">self.rev = rev</span>
        <span class="s1">self.vc_class = vc_class</span>
        <span class="s1">self.branch_name: Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;RevOptions </span><span class="s2">{</span><span class="s1">self.vc_class.name</span><span class="s2">}</span><span class="s4">: rev=</span><span class="s2">{</span><span class="s1">self.rev</span><span class="s2">!r}</span><span class="s4">&gt;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">arg_rev(self) -&gt; Optional[str]:</span>
        <span class="s2">if </span><span class="s1">self.rev </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.vc_class.default_arg_rev</span>

        <span class="s2">return </span><span class="s1">self.rev</span>

    <span class="s2">def </span><span class="s1">to_args(self) -&gt; CommandArgs:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the VCS-specific command arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">args: CommandArgs = []</span>
        <span class="s1">rev = self.arg_rev</span>
        <span class="s2">if </span><span class="s1">rev </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">args += self.vc_class.get_base_rev_args(rev)</span>
        <span class="s1">args += self.extra_args</span>

        <span class="s2">return </span><span class="s1">args</span>

    <span class="s2">def </span><span class="s1">to_display(self) -&gt; str:</span>
        <span class="s2">if not </span><span class="s1">self.rev:</span>
            <span class="s2">return </span><span class="s4">&quot;&quot;</span>

        <span class="s2">return </span><span class="s4">f&quot; (to revision </span><span class="s2">{</span><span class="s1">self.rev</span><span class="s2">}</span><span class="s4">)&quot;</span>

    <span class="s2">def </span><span class="s1">make_new(self</span><span class="s2">, </span><span class="s1">rev: str) -&gt; </span><span class="s4">&quot;RevOptions&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Make a copy of the current instance, but with a new rev. 
 
        Args: 
          rev: the name of the revision for the new object. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.vc_class.make_rev_options(rev</span><span class="s2">, </span><span class="s1">extra_args=self.extra_args)</span>


<span class="s2">class </span><span class="s1">VcsSupport:</span>
    <span class="s1">_registry: Dict[str</span><span class="s2">, </span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">] = {}</span>
    <span class="s1">schemes = [</span><span class="s4">&quot;ssh&quot;</span><span class="s2">, </span><span class="s4">&quot;git&quot;</span><span class="s2">, </span><span class="s4">&quot;hg&quot;</span><span class="s2">, </span><span class="s4">&quot;bzr&quot;</span><span class="s2">, </span><span class="s4">&quot;sftp&quot;</span><span class="s2">, </span><span class="s4">&quot;svn&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># Register more schemes with urlparse for various version control</span>
        <span class="s3"># systems</span>
        <span class="s1">urllib.parse.uses_netloc.extend(self.schemes)</span>
        <span class="s1">super().__init__()</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[str]:</span>
        <span class="s2">return </span><span class="s1">self._registry.__iter__()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">backends(self) -&gt; List[</span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">list(self._registry.values())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dirnames(self) -&gt; List[str]:</span>
        <span class="s2">return </span><span class="s1">[backend.dirname </span><span class="s2">for </span><span class="s1">backend </span><span class="s2">in </span><span class="s1">self.backends]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_schemes(self) -&gt; List[str]:</span>
        <span class="s1">schemes: List[str] = []</span>
        <span class="s2">for </span><span class="s1">backend </span><span class="s2">in </span><span class="s1">self.backends:</span>
            <span class="s1">schemes.extend(backend.schemes)</span>
        <span class="s2">return </span><span class="s1">schemes</span>

    <span class="s2">def </span><span class="s1">register(self</span><span class="s2">, </span><span class="s1">cls: Type[</span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">hasattr(cls</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s1">logger.warning(</span><span class="s4">&quot;Cannot register VCS %s&quot;</span><span class="s2">, </span><span class="s1">cls.__name__)</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">cls.name </span><span class="s2">not in </span><span class="s1">self._registry:</span>
            <span class="s1">self._registry[cls.name] = cls()</span>
            <span class="s1">logger.debug(</span><span class="s4">&quot;Registered VCS backend: %s&quot;</span><span class="s2">, </span><span class="s1">cls.name)</span>

    <span class="s2">def </span><span class="s1">unregister(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._registry:</span>
            <span class="s2">del </span><span class="s1">self._registry[name]</span>

    <span class="s2">def </span><span class="s1">get_backend_for_dir(self</span><span class="s2">, </span><span class="s1">location: str) -&gt; Optional[</span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a VersionControl object if a repository of that type is found 
        at the given directory. 
        &quot;&quot;&quot;</span>
        <span class="s1">vcs_backends = {}</span>
        <span class="s2">for </span><span class="s1">vcs_backend </span><span class="s2">in </span><span class="s1">self._registry.values():</span>
            <span class="s1">repo_path = vcs_backend.get_repository_root(location)</span>
            <span class="s2">if not </span><span class="s1">repo_path:</span>
                <span class="s2">continue</span>
            <span class="s1">logger.debug(</span><span class="s4">&quot;Determine that %s uses VCS: %s&quot;</span><span class="s2">, </span><span class="s1">location</span><span class="s2">, </span><span class="s1">vcs_backend.name)</span>
            <span class="s1">vcs_backends[repo_path] = vcs_backend</span>

        <span class="s2">if not </span><span class="s1">vcs_backends:</span>
            <span class="s2">return None</span>

        <span class="s3"># Choose the VCS in the inner-most directory. Since all repository</span>
        <span class="s3"># roots found here would be either `location` or one of its</span>
        <span class="s3"># parents, the longest path should have the most path components,</span>
        <span class="s3"># i.e. the backend representing the inner-most repository.</span>
        <span class="s1">inner_most_repo_path = max(vcs_backends</span><span class="s2">, </span><span class="s1">key=len)</span>
        <span class="s2">return </span><span class="s1">vcs_backends[inner_most_repo_path]</span>

    <span class="s2">def </span><span class="s1">get_backend_for_scheme(self</span><span class="s2">, </span><span class="s1">scheme: str) -&gt; Optional[</span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a VersionControl object or None. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">vcs_backend </span><span class="s2">in </span><span class="s1">self._registry.values():</span>
            <span class="s2">if </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">vcs_backend.schemes:</span>
                <span class="s2">return </span><span class="s1">vcs_backend</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">get_backend(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; Optional[</span><span class="s4">&quot;VersionControl&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a VersionControl object or None. 
        &quot;&quot;&quot;</span>
        <span class="s1">name = name.lower()</span>
        <span class="s2">return </span><span class="s1">self._registry.get(name)</span>


<span class="s1">vcs = VcsSupport()</span>


<span class="s2">class </span><span class="s1">VersionControl:</span>
    <span class="s1">name = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">dirname = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">repo_name = </span><span class="s4">&quot;&quot;</span>
    <span class="s3"># List of supported schemes for this Version Control</span>
    <span class="s1">schemes: Tuple[str</span><span class="s2">, </span><span class="s1">...] = ()</span>
    <span class="s3"># Iterable of environment variable names to pass to call_subprocess().</span>
    <span class="s1">unset_environ: Tuple[str</span><span class="s2">, </span><span class="s1">...] = ()</span>
    <span class="s1">default_arg_rev: Optional[str] = </span><span class="s2">None</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">should_add_vcs_url_prefix(cls</span><span class="s2">, </span><span class="s1">remote_url: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the vcs prefix (e.g. &quot;git+&quot;) should be added to a 
        repository's remote url when used in a requirement. 
        &quot;&quot;&quot;</span>
        <span class="s2">return not </span><span class="s1">remote_url.lower().startswith(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls.name</span><span class="s2">}</span><span class="s4">:&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_subdirectory(cls</span><span class="s2">, </span><span class="s1">location: str) -&gt; Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the path to Python project root, relative to the repo root. 
        Return None if the project root is in the repo root. 
        &quot;&quot;&quot;</span>
        <span class="s2">return None</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_requirement_revision(cls</span><span class="s2">, </span><span class="s1">repo_dir: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the revision string that should be used in a requirement. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls.get_revision(repo_dir)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_src_requirement(cls</span><span class="s2">, </span><span class="s1">repo_dir: str</span><span class="s2">, </span><span class="s1">project_name: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the requirement string to use to redownload the files 
        currently at the given repository directory. 
 
        Args: 
          project_name: the (unescaped) project name. 
 
        The return value has a form similar to the following: 
 
            {repository_url}@{revision}#egg={project_name} 
        &quot;&quot;&quot;</span>
        <span class="s1">repo_url = cls.get_remote_url(repo_dir)</span>

        <span class="s2">if </span><span class="s1">cls.should_add_vcs_url_prefix(repo_url):</span>
            <span class="s1">repo_url = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls.name</span><span class="s2">}</span><span class="s4">+</span><span class="s2">{</span><span class="s1">repo_url</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s1">revision = cls.get_requirement_revision(repo_dir)</span>
        <span class="s1">subdir = cls.get_subdirectory(repo_dir)</span>
        <span class="s1">req = make_vcs_requirement_url(repo_url</span><span class="s2">, </span><span class="s1">revision</span><span class="s2">, </span><span class="s1">project_name</span><span class="s2">, </span><span class="s1">subdir=subdir)</span>

        <span class="s2">return </span><span class="s1">req</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">get_base_rev_args(rev: str) -&gt; List[str]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the base revision arguments for a vcs command. 
 
        Args: 
          rev: the name of a revision to install.  Cannot be None. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">is_immutable_rev_checkout(self</span><span class="s2">, </span><span class="s1">url: str</span><span class="s2">, </span><span class="s1">dest: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the commit hash checked out at dest matches 
        the revision in url. 
 
        Always return False, if the VCS does not support immutable commit 
        hashes. 
 
        This method does not check if there are local uncommitted changes 
        in dest after checkout, as pip currently has no use case for that. 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">make_rev_options(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">rev: Optional[str] = </span><span class="s2">None, </span><span class="s1">extra_args: Optional[CommandArgs] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; RevOptions:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a RevOptions object. 
 
        Args: 
          rev: the name of a revision to install. 
          extra_args: a list of extra options. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">RevOptions(cls</span><span class="s2">, </span><span class="s1">rev</span><span class="s2">, </span><span class="s1">extra_args=extra_args)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_is_local_repository(cls</span><span class="s2">, </span><span class="s1">repo: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        posix absolute paths start with os.path.sep, 
        win32 ones start with drive (like c:\\folder) 
        &quot;&quot;&quot;</span>
        <span class="s1">drive</span><span class="s2">, </span><span class="s1">tail = os.path.splitdrive(repo)</span>
        <span class="s2">return </span><span class="s1">repo.startswith(os.path.sep) </span><span class="s2">or </span><span class="s1">bool(drive)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_netloc_and_auth(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">netloc: str</span><span class="s2">, </span><span class="s1">scheme: str</span>
    <span class="s1">) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">Tuple[Optional[str]</span><span class="s2">, </span><span class="s1">Optional[str]]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse the repository URL's netloc, and return the new netloc to use 
        along with auth information. 
 
        Args: 
          netloc: the original repository URL netloc. 
          scheme: the repository URL's scheme without the vcs prefix. 
 
        This is mainly for the Subversion class to override, so that auth 
        information can be provided via the --username and --password options 
        instead of through the URL.  For other subclasses like Git without 
        such an option, auth information must stay in the URL. 
 
        Returns: (netloc, (username, password)). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, None</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_url_rev_and_auth(cls</span><span class="s2">, </span><span class="s1">url: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">Optional[str]</span><span class="s2">, </span><span class="s1">AuthInfo]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse the repository URL to use, and return the URL, revision, 
        and auth info to use. 
 
        Returns: (url, rev, (username, password)). 
        &quot;&quot;&quot;</span>
        <span class="s1">scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = urllib.parse.urlsplit(url)</span>
        <span class="s2">if </span><span class="s4">&quot;+&quot; </span><span class="s2">not in </span><span class="s1">scheme:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Sorry, {!r} is a malformed VCS url. &quot;</span>
                <span class="s4">&quot;The format is &lt;vcs&gt;+&lt;protocol&gt;://&lt;url&gt;, &quot;</span>
                <span class="s4">&quot;e.g. svn+http://myrepo/svn/MyApp#egg=MyApp&quot;</span><span class="s1">.format(url)</span>
            <span class="s1">)</span>
        <span class="s3"># Remove the vcs prefix.</span>
        <span class="s1">scheme = scheme.split(</span><span class="s4">&quot;+&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">netloc</span><span class="s2">, </span><span class="s1">user_pass = cls.get_netloc_and_auth(netloc</span><span class="s2">, </span><span class="s1">scheme)</span>
        <span class="s1">rev = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s4">&quot;@&quot; </span><span class="s2">in </span><span class="s1">path:</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">rev = path.rsplit(</span><span class="s4">&quot;@&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">rev:</span>
                <span class="s2">raise </span><span class="s1">InstallationError(</span>
                    <span class="s4">&quot;The URL {!r} has an empty revision (after @) &quot;</span>
                    <span class="s4">&quot;which is not supported. Include a revision after @ &quot;</span>
                    <span class="s4">&quot;or remove @ from the URL.&quot;</span><span class="s1">.format(url)</span>
                <span class="s1">)</span>
        <span class="s1">url = urllib.parse.urlunsplit((scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev</span><span class="s2">, </span><span class="s1">user_pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">make_rev_args(</span>
        <span class="s1">username: Optional[str]</span><span class="s2">, </span><span class="s1">password: Optional[HiddenText]</span>
    <span class="s1">) -&gt; CommandArgs:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the RevOptions &quot;extra arguments&quot; to use in obtain(). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">get_url_rev_options(self</span><span class="s2">, </span><span class="s1">url: HiddenText) -&gt; Tuple[HiddenText</span><span class="s2">, </span><span class="s1">RevOptions]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the URL and RevOptions object to use in obtain(), 
        as a tuple (url, rev_options). 
        &quot;&quot;&quot;</span>
        <span class="s1">secret_url</span><span class="s2">, </span><span class="s1">rev</span><span class="s2">, </span><span class="s1">user_pass = self.get_url_rev_and_auth(url.secret)</span>
        <span class="s1">username</span><span class="s2">, </span><span class="s1">secret_password = user_pass</span>
        <span class="s1">password: Optional[HiddenText] = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">secret_password </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">password = hide_value(secret_password)</span>
        <span class="s1">extra_args = self.make_rev_args(username</span><span class="s2">, </span><span class="s1">password)</span>
        <span class="s1">rev_options = self.make_rev_options(rev</span><span class="s2">, </span><span class="s1">extra_args=extra_args)</span>

        <span class="s2">return </span><span class="s1">hide_url(secret_url)</span><span class="s2">, </span><span class="s1">rev_options</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">normalize_url(url: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize a URL for comparison by unquoting it and removing any 
        trailing slash. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">urllib.parse.unquote(url).rstrip(</span><span class="s4">&quot;/&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">compare_urls(cls</span><span class="s2">, </span><span class="s1">url1: str</span><span class="s2">, </span><span class="s1">url2: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Compare two repo URLs for identity, ignoring incidental differences. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls.normalize_url(url1) == cls.normalize_url(url2)</span>

    <span class="s2">def </span><span class="s1">fetch_new(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dest: str</span><span class="s2">, </span><span class="s1">url: HiddenText</span><span class="s2">, </span><span class="s1">rev_options: RevOptions</span><span class="s2">, </span><span class="s1">verbosity: int</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Fetch a revision from a repository, in the case that this is the 
        first fetch from the repository. 
 
        Args: 
          dest: the directory to fetch the repository to. 
          rev_options: a RevOptions object. 
          verbosity: verbosity level. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">switch(self</span><span class="s2">, </span><span class="s1">dest: str</span><span class="s2">, </span><span class="s1">url: HiddenText</span><span class="s2">, </span><span class="s1">rev_options: RevOptions) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch the repo at ``dest`` to point to ``URL``. 
 
        Args: 
          rev_options: a RevOptions object. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">dest: str</span><span class="s2">, </span><span class="s1">url: HiddenText</span><span class="s2">, </span><span class="s1">rev_options: RevOptions) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Update an already-existing repo to the given ``rev_options``. 
 
        Args: 
          rev_options: a RevOptions object. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_commit_id_equal(cls</span><span class="s2">, </span><span class="s1">dest: str</span><span class="s2">, </span><span class="s1">name: Optional[str]) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the id of the current commit equals the given name. 
 
        Args: 
          dest: the repository directory. 
          name: a string name. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">obtain(self</span><span class="s2">, </span><span class="s1">dest: str</span><span class="s2">, </span><span class="s1">url: HiddenText</span><span class="s2">, </span><span class="s1">verbosity: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Install or update in editable mode the package represented by this 
        VersionControl object. 
 
        :param dest: the repository directory in which to install or update. 
        :param url: the repository URL starting with a vcs prefix. 
        :param verbosity: verbosity level. 
        &quot;&quot;&quot;</span>
        <span class="s1">url</span><span class="s2">, </span><span class="s1">rev_options = self.get_url_rev_options(url)</span>

        <span class="s2">if not </span><span class="s1">os.path.exists(dest):</span>
            <span class="s1">self.fetch_new(dest</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev_options</span><span class="s2">, </span><span class="s1">verbosity=verbosity)</span>
            <span class="s2">return</span>

        <span class="s1">rev_display = rev_options.to_display()</span>
        <span class="s2">if </span><span class="s1">self.is_repository_directory(dest):</span>
            <span class="s1">existing_url = self.get_remote_url(dest)</span>
            <span class="s2">if </span><span class="s1">self.compare_urls(existing_url</span><span class="s2">, </span><span class="s1">url.secret):</span>
                <span class="s1">logger.debug(</span>
                    <span class="s4">&quot;%s in %s exists, and has correct URL (%s)&quot;</span><span class="s2">,</span>
                    <span class="s1">self.repo_name.title()</span><span class="s2">,</span>
                    <span class="s1">display_path(dest)</span><span class="s2">,</span>
                    <span class="s1">url</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">self.is_commit_id_equal(dest</span><span class="s2">, </span><span class="s1">rev_options.rev):</span>
                    <span class="s1">logger.info(</span>
                        <span class="s4">&quot;Updating %s %s%s&quot;</span><span class="s2">,</span>
                        <span class="s1">display_path(dest)</span><span class="s2">,</span>
                        <span class="s1">self.repo_name</span><span class="s2">,</span>
                        <span class="s1">rev_display</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s1">self.update(dest</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev_options)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">logger.info(</span><span class="s4">&quot;Skipping because already up-to-date.&quot;</span><span class="s1">)</span>
                <span class="s2">return</span>

            <span class="s1">logger.warning(</span>
                <span class="s4">&quot;%s %s in %s exists with URL %s&quot;</span><span class="s2">,</span>
                <span class="s1">self.name</span><span class="s2">,</span>
                <span class="s1">self.repo_name</span><span class="s2">,</span>
                <span class="s1">display_path(dest)</span><span class="s2">,</span>
                <span class="s1">existing_url</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">prompt = (</span><span class="s4">&quot;(s)witch, (i)gnore, (w)ipe, (b)ackup &quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">&quot;s&quot;</span><span class="s2">, </span><span class="s4">&quot;i&quot;</span><span class="s2">, </span><span class="s4">&quot;w&quot;</span><span class="s2">, </span><span class="s4">&quot;b&quot;</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">logger.warning(</span>
                <span class="s4">&quot;Directory %s already exists, and is not a %s %s.&quot;</span><span class="s2">,</span>
                <span class="s1">dest</span><span class="s2">,</span>
                <span class="s1">self.name</span><span class="s2">,</span>
                <span class="s1">self.repo_name</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s3"># https://github.com/python/mypy/issues/1174</span>
            <span class="s1">prompt = (</span><span class="s4">&quot;(i)gnore, (w)ipe, (b)ackup &quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s2">, </span><span class="s4">&quot;w&quot;</span><span class="s2">, </span><span class="s4">&quot;b&quot;</span><span class="s1">))  </span><span class="s3"># type: ignore</span>

        <span class="s1">logger.warning(</span>
            <span class="s4">&quot;The plan is to install the %s repository %s&quot;</span><span class="s2">,</span>
            <span class="s1">self.name</span><span class="s2">,</span>
            <span class="s1">url</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">response = ask_path_exists(</span><span class="s4">&quot;What to do?  {}&quot;</span><span class="s1">.format(prompt[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">prompt[</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">response == </span><span class="s4">&quot;a&quot;</span><span class="s1">:</span>
            <span class="s1">sys.exit(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">response == </span><span class="s4">&quot;w&quot;</span><span class="s1">:</span>
            <span class="s1">logger.warning(</span><span class="s4">&quot;Deleting %s&quot;</span><span class="s2">, </span><span class="s1">display_path(dest))</span>
            <span class="s1">rmtree(dest)</span>
            <span class="s1">self.fetch_new(dest</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev_options</span><span class="s2">, </span><span class="s1">verbosity=verbosity)</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">response == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s1">dest_dir = backup_dir(dest)</span>
            <span class="s1">logger.warning(</span><span class="s4">&quot;Backing up %s to %s&quot;</span><span class="s2">, </span><span class="s1">display_path(dest)</span><span class="s2">, </span><span class="s1">dest_dir)</span>
            <span class="s1">shutil.move(dest</span><span class="s2">, </span><span class="s1">dest_dir)</span>
            <span class="s1">self.fetch_new(dest</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev_options</span><span class="s2">, </span><span class="s1">verbosity=verbosity)</span>
            <span class="s2">return</span>

        <span class="s3"># Do nothing if the response is &quot;i&quot;.</span>
        <span class="s2">if </span><span class="s1">response == </span><span class="s4">&quot;s&quot;</span><span class="s1">:</span>
            <span class="s1">logger.info(</span>
                <span class="s4">&quot;Switching %s %s to %s%s&quot;</span><span class="s2">,</span>
                <span class="s1">self.repo_name</span><span class="s2">,</span>
                <span class="s1">display_path(dest)</span><span class="s2">,</span>
                <span class="s1">url</span><span class="s2">,</span>
                <span class="s1">rev_display</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.switch(dest</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev_options)</span>

    <span class="s2">def </span><span class="s1">unpack(self</span><span class="s2">, </span><span class="s1">location: str</span><span class="s2">, </span><span class="s1">url: HiddenText</span><span class="s2">, </span><span class="s1">verbosity: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Clean up current location and download the url repository 
        (and vcs infos) into location 
 
        :param url: the repository URL starting with a vcs prefix. 
        :param verbosity: verbosity level. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">os.path.exists(location):</span>
            <span class="s1">rmtree(location)</span>
        <span class="s1">self.obtain(location</span><span class="s2">, </span><span class="s1">url=url</span><span class="s2">, </span><span class="s1">verbosity=verbosity)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_remote_url(cls</span><span class="s2">, </span><span class="s1">location: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the url used at location 
 
        Raises RemoteNotFoundError if the repository does not have a remote 
        url configured. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_revision(cls</span><span class="s2">, </span><span class="s1">location: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the current commit id of the files at the given location. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">run_command(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">cmd: Union[List[str]</span><span class="s2">, </span><span class="s1">CommandArgs]</span><span class="s2">,</span>
        <span class="s1">show_stdout: bool = </span><span class="s2">True,</span>
        <span class="s1">cwd: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">on_returncode: </span><span class="s4">'Literal[&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;]' </span><span class="s1">= </span><span class="s4">&quot;raise&quot;</span><span class="s2">,</span>
        <span class="s1">extra_ok_returncodes: Optional[Iterable[int]] = </span><span class="s2">None,</span>
        <span class="s1">command_desc: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">extra_environ: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">Any]] = </span><span class="s2">None,</span>
        <span class="s1">spinner: Optional[SpinnerInterface] = </span><span class="s2">None,</span>
        <span class="s1">log_failed_cmd: bool = </span><span class="s2">True,</span>
        <span class="s1">stdout_only: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Run a VCS subcommand 
        This is simply a wrapper around call_subprocess that adds the VCS 
        command name, and checks that the VCS is available 
        &quot;&quot;&quot;</span>
        <span class="s1">cmd = make_command(cls.name</span><span class="s2">, </span><span class="s1">*cmd)</span>
        <span class="s2">if </span><span class="s1">command_desc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">command_desc = format_command_args(cmd)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">call_subprocess(</span>
                <span class="s1">cmd</span><span class="s2">,</span>
                <span class="s1">show_stdout</span><span class="s2">,</span>
                <span class="s1">cwd</span><span class="s2">,</span>
                <span class="s1">on_returncode=on_returncode</span><span class="s2">,</span>
                <span class="s1">extra_ok_returncodes=extra_ok_returncodes</span><span class="s2">,</span>
                <span class="s1">command_desc=command_desc</span><span class="s2">,</span>
                <span class="s1">extra_environ=extra_environ</span><span class="s2">,</span>
                <span class="s1">unset_environ=cls.unset_environ</span><span class="s2">,</span>
                <span class="s1">spinner=spinner</span><span class="s2">,</span>
                <span class="s1">log_failed_cmd=log_failed_cmd</span><span class="s2">,</span>
                <span class="s1">stdout_only=stdout_only</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">FileNotFoundError:</span>
            <span class="s3"># errno.ENOENT = no such file or directory</span>
            <span class="s3"># In other words, the VCS executable isn't available</span>
            <span class="s2">raise </span><span class="s1">BadCommand(</span>
                <span class="s4">f&quot;Cannot find command </span><span class="s2">{</span><span class="s1">cls.name</span><span class="s2">!r} </span><span class="s4">- do you have &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls.name</span><span class="s2">!r} </span><span class="s4">installed and in your PATH?&quot;</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">PermissionError:</span>
            <span class="s3"># errno.EACCES = Permission denied</span>
            <span class="s3"># This error occurs, for instance, when the command is installed</span>
            <span class="s3"># only for another user. So, the current user don't have</span>
            <span class="s3"># permission to call the other user command.</span>
            <span class="s2">raise </span><span class="s1">BadCommand(</span>
                <span class="s4">f&quot;No permission to execute </span><span class="s2">{</span><span class="s1">cls.name</span><span class="s2">!r} </span><span class="s4">- install it &quot;</span>
                <span class="s4">f&quot;locally, globally (ask admin), or check your PATH. &quot;</span>
                <span class="s4">f&quot;See possible solutions at &quot;</span>
                <span class="s4">f&quot;https://pip.pypa.io/en/latest/reference/pip_freeze/&quot;</span>
                <span class="s4">f&quot;#fixing-permission-denied.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_repository_directory(cls</span><span class="s2">, </span><span class="s1">path: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether a directory path is a repository directory. 
        &quot;&quot;&quot;</span>
        <span class="s1">logger.debug(</span><span class="s4">&quot;Checking in %s for %s (%s)...&quot;</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">cls.dirname</span><span class="s2">, </span><span class="s1">cls.name)</span>
        <span class="s2">return </span><span class="s1">os.path.exists(os.path.join(path</span><span class="s2">, </span><span class="s1">cls.dirname))</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_repository_root(cls</span><span class="s2">, </span><span class="s1">location: str) -&gt; Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the &quot;root&quot; (top-level) directory controlled by the vcs, 
        or `None` if the directory is not in any. 
 
        It is meant to be overridden to implement smarter detection 
        mechanisms for specific vcs. 
 
        This can do more than is_repository_directory() alone. For 
        example, the Git override checks that Git is actually available. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">cls.is_repository_directory(location):</span>
            <span class="s2">return </span><span class="s1">location</span>
        <span class="s2">return None</span>
</pre>
</body>
</html>