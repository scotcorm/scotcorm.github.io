<html>
<head>
<title>test_array_coercion.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_array_coercion.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for array coercion, mainly through testing `np.array` results directly. 
Note that other such tests exist e.g. in `test_api.py` and many corner-cases 
are tested (sometimes indirectly) elsewhere. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">param</span>

<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.core._rational_tests </span><span class="s2">import </span><span class="s1">rational</span>
<span class="s2">from </span><span class="s1">numpy.core._multiarray_umath </span><span class="s2">import </span><span class="s1">_discover_array_parameters</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_array_equal</span><span class="s2">, </span><span class="s1">assert_warns</span><span class="s2">, </span><span class="s1">IS_PYPY)</span>


<span class="s2">def </span><span class="s1">arraylikes():</span>
    <span class="s0">&quot;&quot;&quot; 
    Generator for functions converting an array into various array-likes. 
    If full is True (default) includes array-likes not capable of handling 
    all dtypes 
    &quot;&quot;&quot;</span>
    <span class="s3"># base array:</span>
    <span class="s2">def </span><span class="s1">ndarray(a):</span>
        <span class="s2">return </span><span class="s1">a</span>

    <span class="s2">yield </span><span class="s1">param(ndarray</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;ndarray&quot;</span><span class="s1">)</span>

    <span class="s3"># subclass:</span>
    <span class="s2">class </span><span class="s1">MyArr(np.ndarray):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">subclass(a):</span>
        <span class="s2">return </span><span class="s1">a.view(MyArr)</span>

    <span class="s2">yield </span><span class="s1">subclass</span>

    <span class="s2">class </span><span class="s1">_SequenceLike():</span>
        <span class="s3"># We are giving a warning that array-like's were also expected to be</span>
        <span class="s3"># sequence-like in `np.array([array_like])`, this can be removed</span>
        <span class="s3"># when the deprecation exired (started NumPy 1.20)</span>
        <span class="s2">def </span><span class="s1">__len__(self):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span>

        <span class="s2">def </span><span class="s1">__getitem__(self):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span>

    <span class="s3"># Array-interface</span>
    <span class="s2">class </span><span class="s1">ArrayDunder(_SequenceLike):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a):</span>
            <span class="s1">self.a = a</span>

        <span class="s2">def </span><span class="s1">__array__(self</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.a</span>

    <span class="s2">yield </span><span class="s1">param(ArrayDunder</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;__array__&quot;</span><span class="s1">)</span>

    <span class="s3"># memory-view</span>
    <span class="s2">yield </span><span class="s1">param(memoryview</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;memoryview&quot;</span><span class="s1">)</span>

    <span class="s3"># Array-interface</span>
    <span class="s2">class </span><span class="s1">ArrayInterface(_SequenceLike):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a):</span>
            <span class="s1">self.a = a  </span><span class="s3"># need to hold on to keep interface valid</span>
            <span class="s1">self.__array_interface__ = a.__array_interface__</span>

    <span class="s2">yield </span><span class="s1">param(ArrayInterface</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;__array_interface__&quot;</span><span class="s1">)</span>

    <span class="s3"># Array-Struct</span>
    <span class="s2">class </span><span class="s1">ArrayStruct(_SequenceLike):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a):</span>
            <span class="s1">self.a = a  </span><span class="s3"># need to hold on to keep struct valid</span>
            <span class="s1">self.__array_struct__ = a.__array_struct__</span>

    <span class="s2">yield </span><span class="s1">param(ArrayStruct</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;__array_struct__&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">scalar_instances(times=</span><span class="s2">True, </span><span class="s1">extended_precision=</span><span class="s2">True, </span><span class="s1">user_dtype=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s3"># Hard-coded list of scalar instances.</span>
    <span class="s3"># Floats:</span>
    <span class="s2">yield </span><span class="s1">param(np.sqrt(np.float16(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;float16&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.sqrt(np.float32(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;float32&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.sqrt(np.float64(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">extended_precision:</span>
        <span class="s2">yield </span><span class="s1">param(np.sqrt(np.longdouble(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;longdouble&quot;</span><span class="s1">)</span>

    <span class="s3"># Complex:</span>
    <span class="s2">yield </span><span class="s1">param(np.sqrt(np.complex64(</span><span class="s5">2</span><span class="s1">+</span><span class="s5">3j</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;complex64&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.sqrt(np.complex128(</span><span class="s5">2</span><span class="s1">+</span><span class="s5">3j</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;complex128&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">extended_precision:</span>
        <span class="s2">yield </span><span class="s1">param(np.sqrt(np.longcomplex(</span><span class="s5">2</span><span class="s1">+</span><span class="s5">3j</span><span class="s1">))</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;clongdouble&quot;</span><span class="s1">)</span>

    <span class="s3"># Bool:</span>
    <span class="s3"># XFAIL: Bool should be added, but has some bad properties when it</span>
    <span class="s3"># comes to strings, see also gh-9875</span>
    <span class="s3"># yield param(np.bool_(0), id=&quot;bool&quot;)</span>

    <span class="s3"># Integers:</span>
    <span class="s2">yield </span><span class="s1">param(np.int8(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;int8&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.int16(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;int16&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.int32(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;int32&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.int64(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s2">yield </span><span class="s1">param(np.uint8(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;uint8&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.uint16(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;uint16&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.uint32(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;uint32&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.uint64(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;uint64&quot;</span><span class="s1">)</span>

    <span class="s3"># Rational:</span>
    <span class="s2">if </span><span class="s1">user_dtype:</span>
        <span class="s2">yield </span><span class="s1">param(rational(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;rational&quot;</span><span class="s1">)</span>

    <span class="s3"># Cannot create a structured void scalar directly:</span>
    <span class="s1">structured = np.array([(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)]</span><span class="s2">, </span><span class="s4">&quot;i,i&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">isinstance(structured</span><span class="s2">, </span><span class="s1">np.void)</span>
    <span class="s2">assert </span><span class="s1">structured.dtype == np.dtype(</span><span class="s4">&quot;i,i&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(structured</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;structured&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">times:</span>
        <span class="s3"># Datetimes and timedelta</span>
        <span class="s2">yield </span><span class="s1">param(np.timedelta64(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[generic]&quot;</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">param(np.timedelta64(</span><span class="s5">23</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[s]&quot;</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">param(np.timedelta64(</span><span class="s4">&quot;NaT&quot;</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[s](NaT)&quot;</span><span class="s1">)</span>

        <span class="s2">yield </span><span class="s1">param(np.datetime64(</span><span class="s4">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;datetime64[generic](NaT)&quot;</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">param(np.datetime64(</span><span class="s4">&quot;2020-06-07 12:43&quot;</span><span class="s2">, </span><span class="s4">&quot;ms&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;datetime64[ms]&quot;</span><span class="s1">)</span>

    <span class="s3"># Strings and unstructured void:</span>
    <span class="s2">yield </span><span class="s1">param(np.bytes_(</span><span class="s6">b&quot;1234&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;bytes&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.unicode_(</span><span class="s4">&quot;2345&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;unicode&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">param(np.void(</span><span class="s6">b&quot;4321&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;unstructured_void&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">is_parametric_dtype(dtype):</span>
    <span class="s0">&quot;&quot;&quot;Returns True if the the dtype is a parametric legacy dtype (itemsize 
    is 0, or a datetime without units) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.itemsize == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">np.timedelta64)):</span>
        <span class="s2">if </span><span class="s1">dtype.name.endswith(</span><span class="s4">&quot;64&quot;</span><span class="s1">):</span>
            <span class="s3"># Generic time units</span>
            <span class="s2">return True</span>
    <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">TestStringDiscovery:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;obj&quot;</span><span class="s2">,</span>
            <span class="s1">[object()</span><span class="s2">, </span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">**</span><span class="s5">43</span><span class="s2">, None, </span><span class="s4">&quot;string&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">ids=[</span><span class="s4">&quot;object&quot;</span><span class="s2">, </span><span class="s4">&quot;1.2&quot;</span><span class="s2">, </span><span class="s4">&quot;10**43&quot;</span><span class="s2">, </span><span class="s4">&quot;None&quot;</span><span class="s2">, </span><span class="s4">&quot;string&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_basic_stringlength(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s1">length = len(str(obj))</span>
        <span class="s1">expected = np.dtype(</span><span class="s4">f&quot;S</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">np.array(obj</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S&quot;</span><span class="s1">).dtype == expected</span>
        <span class="s2">assert </span><span class="s1">np.array([obj]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S&quot;</span><span class="s1">).dtype == expected</span>

        <span class="s3"># A nested array is also discovered correctly</span>
        <span class="s1">arr = np.array(obj</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.array(arr</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S&quot;</span><span class="s1">).dtype == expected</span>
        <span class="s3"># Check that .astype() behaves identical</span>
        <span class="s2">assert </span><span class="s1">arr.astype(</span><span class="s4">&quot;S&quot;</span><span class="s1">).dtype == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;obj&quot;</span><span class="s2">,</span>
            <span class="s1">[object()</span><span class="s2">, </span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">**</span><span class="s5">43</span><span class="s2">, None, </span><span class="s4">&quot;string&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">ids=[</span><span class="s4">&quot;object&quot;</span><span class="s2">, </span><span class="s4">&quot;1.2&quot;</span><span class="s2">, </span><span class="s4">&quot;10**43&quot;</span><span class="s2">, </span><span class="s4">&quot;None&quot;</span><span class="s2">, </span><span class="s4">&quot;string&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_nested_arrays_stringlength(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s1">length = len(str(obj))</span>
        <span class="s1">expected = np.dtype(</span><span class="s4">f&quot;S</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">arr = np.array(obj</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.array([arr</span><span class="s2">, </span><span class="s1">arr]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S&quot;</span><span class="s1">).dtype == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;arraylike&quot;</span><span class="s2">, </span><span class="s1">arraylikes())</span>
    <span class="s2">def </span><span class="s1">test_unpack_first_level(self</span><span class="s2">, </span><span class="s1">arraylike):</span>
        <span class="s3"># We unpack exactly one level of array likes</span>
        <span class="s1">obj = np.array([</span><span class="s2">None</span><span class="s1">])</span>
        <span class="s1">obj[</span><span class="s5">0</span><span class="s1">] = np.array(</span><span class="s5">1.2</span><span class="s1">)</span>
        <span class="s3"># the length of the included item, not of the float dtype</span>
        <span class="s1">length = len(str(obj[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">expected = np.dtype(</span><span class="s4">f&quot;S</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s1">obj = arraylike(obj)</span>
        <span class="s3"># casting to string usually calls str(obj)</span>
        <span class="s1">arr = np.array([obj]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.dtype == expected</span>


<span class="s2">class </span><span class="s1">TestScalarDiscovery:</span>
    <span class="s2">def </span><span class="s1">test_void_special_case(self):</span>
        <span class="s3"># Void dtypes with structures discover tuples as elements</span>
        <span class="s1">arr = np.array((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;i,i,i&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == ()</span>
        <span class="s1">arr = np.array([(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;i,i,i&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_char_special_case(self):</span>
        <span class="s1">arr = np.array(</span><span class="s4">&quot;string&quot;</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">6</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.dtype.char == </span><span class="s4">&quot;c&quot;</span>
        <span class="s1">arr = np.array([</span><span class="s4">&quot;string&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.dtype.char == </span><span class="s4">&quot;c&quot;</span>

    <span class="s2">def </span><span class="s1">test_char_special_case_deep(self):</span>
        <span class="s3"># Check that the character special case errors correctly if the</span>
        <span class="s3"># array is too deep:</span>
        <span class="s1">nested = [</span><span class="s4">&quot;string&quot;</span><span class="s1">]  </span><span class="s3"># 2 dimensions (due to string being sequence)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(np.MAXDIMS - </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">nested = [nested]</span>

        <span class="s1">arr = np.array(nested</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">'c'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">) * (np.MAXDIMS - </span><span class="s5">1</span><span class="s1">) + (</span><span class="s5">6</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.array([nested]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_unknown_object(self):</span>
        <span class="s1">arr = np.array(object())</span>
        <span class="s2">assert </span><span class="s1">arr.shape == ()</span>
        <span class="s2">assert </span><span class="s1">arr.dtype == np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scalar&quot;</span><span class="s2">, </span><span class="s1">scalar_instances())</span>
    <span class="s2">def </span><span class="s1">test_scalar(self</span><span class="s2">, </span><span class="s1">scalar):</span>
        <span class="s1">arr = np.array(scalar)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == ()</span>
        <span class="s2">assert </span><span class="s1">arr.dtype == scalar.dtype</span>

        <span class="s1">arr = np.array([[scalar</span><span class="s2">, </span><span class="s1">scalar]])</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.dtype == scalar.dtype</span>

    <span class="s3"># Additionally to string this test also runs into a corner case</span>
    <span class="s3"># with datetime promotion (the difference is the promotion order).</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:Promotion of numbers:FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_scalar_promotion(self):</span>
        <span class="s2">for </span><span class="s1">sc1</span><span class="s2">, </span><span class="s1">sc2 </span><span class="s2">in </span><span class="s1">product(scalar_instances()</span><span class="s2">, </span><span class="s1">scalar_instances()):</span>
            <span class="s1">sc1</span><span class="s2">, </span><span class="s1">sc2 = sc1.values[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sc2.values[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3"># test all combinations:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">arr = np.array([sc1</span><span class="s2">, </span><span class="s1">sc2])</span>
            <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                <span class="s3"># The promotion between two times can fail</span>
                <span class="s3"># XFAIL (ValueError): Some object casts are currently undefined</span>
                <span class="s2">continue</span>
            <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">2</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">dt1</span><span class="s2">, </span><span class="s1">dt2 = sc1.dtype</span><span class="s2">, </span><span class="s1">sc2.dtype</span>
                <span class="s1">expected_dtype = np.promote_types(dt1</span><span class="s2">, </span><span class="s1">dt2)</span>
                <span class="s2">assert </span><span class="s1">arr.dtype == expected_dtype</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s3"># Will currently always go to object dtype</span>
                <span class="s2">assert </span><span class="s1">arr.dtype == np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scalar&quot;</span><span class="s2">, </span><span class="s1">scalar_instances())</span>
    <span class="s2">def </span><span class="s1">test_scalar_coercion(self</span><span class="s2">, </span><span class="s1">scalar):</span>
        <span class="s3"># This tests various scalar coercion paths, mainly for the numerical</span>
        <span class="s3"># types.  It includes some paths not directly related to `np.array`</span>
        <span class="s2">if </span><span class="s1">isinstance(scalar</span><span class="s2">, </span><span class="s1">np.inexact):</span>
            <span class="s3"># Ensure we have a full-precision number if available</span>
            <span class="s1">scalar = type(scalar)((scalar * </span><span class="s5">2</span><span class="s1">)**</span><span class="s5">0.5</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">type(scalar) </span><span class="s2">is </span><span class="s1">rational:</span>
            <span class="s3"># Rational generally fails due to a missing cast. In the future</span>
            <span class="s3"># object casts should automatically be defined based on `setitem`.</span>
            <span class="s1">pytest.xfail(</span><span class="s4">&quot;Rational to object cast is undefined currently.&quot;</span><span class="s1">)</span>

        <span class="s3"># Use casting from object:</span>
        <span class="s1">arr = np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=object).astype(scalar.dtype)</span>

        <span class="s3"># Test various ways to create an array containing this scalar:</span>
        <span class="s1">arr1 = np.array(scalar).reshape(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">arr2 = np.array([scalar])</span>
        <span class="s1">arr3 = np.empty(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=scalar.dtype)</span>
        <span class="s1">arr3[</span><span class="s5">0</span><span class="s1">] = scalar</span>
        <span class="s1">arr4 = np.empty(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=scalar.dtype)</span>
        <span class="s1">arr4[:] = [scalar]</span>
        <span class="s3"># All of these methods should yield the same results</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">arr1)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">arr2)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">arr3)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">arr4)</span>

    <span class="s1">@pytest.mark.xfail(IS_PYPY</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">&quot;`int(np.complex128(3))` fails on PyPy&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore::numpy.ComplexWarning&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;cast_to&quot;</span><span class="s2">, </span><span class="s1">scalar_instances())</span>
    <span class="s2">def </span><span class="s1">test_scalar_coercion_same_as_cast_and_assignment(self</span><span class="s2">, </span><span class="s1">cast_to):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that in most cases: 
           * `np.array(scalar, dtype=dtype)` 
           * `np.empty((), dtype=dtype)[()] = scalar` 
           * `np.array(scalar).astype(dtype)` 
        should behave the same.  The only exceptions are paramteric dtypes 
        (mainly datetime/timedelta without unit) and void without fields. 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype = cast_to.dtype  </span><span class="s3"># use to parametrize only the target dtype</span>

        <span class="s2">for </span><span class="s1">scalar </span><span class="s2">in </span><span class="s1">scalar_instances(times=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s1">scalar = scalar.values[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">dtype.type == np.void:</span>
               <span class="s2">if </span><span class="s1">scalar.dtype.fields </span><span class="s2">is not None and </span><span class="s1">dtype.fields </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s3"># Here, coercion to &quot;V6&quot; works, but the cast fails.</span>
                    <span class="s3"># Since the types are identical, SETITEM takes care of</span>
                    <span class="s3"># this, but has different rules than the cast.</span>
                    <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
                        <span class="s1">np.array(scalar).astype(dtype)</span>
                    <span class="s1">np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                    <span class="s1">np.array([scalar]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                    <span class="s2">continue</span>

            <span class="s3"># The main test, we first try to use casting and if it succeeds</span>
            <span class="s3"># continue below testing that things are the same, otherwise</span>
            <span class="s3"># test that the alternative paths at least also fail.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">cast = np.array(scalar).astype(dtype)</span>
            <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">RuntimeError):</span>
                <span class="s3"># coercion should also raise (error type may change)</span>
                <span class="s2">with </span><span class="s1">pytest.raises(Exception):</span>
                    <span class="s1">np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

                <span class="s2">if </span><span class="s1">(isinstance(scalar</span><span class="s2">, </span><span class="s1">rational) </span><span class="s2">and</span>
                        <span class="s1">np.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.signedinteger)):</span>
                    <span class="s2">return</span>

                <span class="s2">with </span><span class="s1">pytest.raises(Exception):</span>
                    <span class="s1">np.array([scalar]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                <span class="s3"># assignment should also raise</span>
                <span class="s1">res = np.zeros(()</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                <span class="s2">with </span><span class="s1">pytest.raises(Exception):</span>
                    <span class="s1">res[()] = scalar</span>

                <span class="s2">return</span>

            <span class="s3"># Non error path:</span>
            <span class="s1">arr = np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">cast)</span>
            <span class="s3"># assignment behaves the same</span>
            <span class="s1">ass = np.zeros(()</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">ass[()] = scalar</span>
            <span class="s1">assert_array_equal(ass</span><span class="s2">, </span><span class="s1">cast)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pyscalar&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10.32</span><span class="s2">, </span><span class="s5">10.14j</span><span class="s2">, </span><span class="s5">10</span><span class="s1">**</span><span class="s5">100</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_pyscalar_subclasses(self</span><span class="s2">, </span><span class="s1">pyscalar):</span>
        <span class="s0">&quot;&quot;&quot;NumPy arrays are read/write which means that anything but invariant 
        behaviour is on thin ice.  However, we currently are happy to discover 
        subclasses of Python float, int, complex the same as the base classes. 
        This should potentially be deprecated. 
        &quot;&quot;&quot;</span>
        <span class="s2">class </span><span class="s1">MyScalar(type(pyscalar)):</span>
            <span class="s2">pass</span>

        <span class="s1">res = np.array(MyScalar(pyscalar))</span>
        <span class="s1">expected = np.array(pyscalar)</span>
        <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype_char&quot;</span><span class="s2">, </span><span class="s1">np.typecodes[</span><span class="s4">&quot;All&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_default_dtype_instance(self</span><span class="s2">, </span><span class="s1">dtype_char):</span>
        <span class="s2">if </span><span class="s1">dtype_char </span><span class="s2">in </span><span class="s4">&quot;SU&quot;</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(dtype_char + </span><span class="s4">&quot;1&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">dtype_char == </span><span class="s4">&quot;V&quot;</span><span class="s1">:</span>
            <span class="s3"># Legacy behaviour was to use V8. The reason was float64 being the</span>
            <span class="s3"># default dtype and that having 8 bytes.</span>
            <span class="s1">dtype = np.dtype(</span><span class="s4">&quot;V8&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(dtype_char)</span>

        <span class="s1">discovered_dtype</span><span class="s2">, </span><span class="s1">_ = _discover_array_parameters([]</span><span class="s2">, </span><span class="s1">type(dtype))</span>

        <span class="s2">assert </span><span class="s1">discovered_dtype == dtype</span>
        <span class="s2">assert </span><span class="s1">discovered_dtype.itemsize == dtype.itemsize</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">np.typecodes[</span><span class="s4">&quot;Integer&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_scalar_to_int_coerce_does_not_cast(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s0">&quot;&quot;&quot; 
        Signed integers are currently different in that they do not cast other 
        NumPy scalar, but instead use scalar.__int__(). The hardcoded 
        exception to this rule is `np.array(scalar, dtype=integer)`. 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype = np.dtype(dtype)</span>
        <span class="s1">invalid_int = np.ulonglong(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">float_nan = np.float64(np.nan)</span>

        <span class="s2">for </span><span class="s1">scalar </span><span class="s2">in </span><span class="s1">[float_nan</span><span class="s2">, </span><span class="s1">invalid_int]:</span>
            <span class="s3"># This is a special case using casting logic and thus not failing:</span>
            <span class="s1">coerced = np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">cast = np.array(scalar).astype(dtype)</span>
            <span class="s1">assert_array_equal(coerced</span><span class="s2">, </span><span class="s1">cast)</span>

            <span class="s3"># However these fail:</span>
            <span class="s2">with </span><span class="s1">pytest.raises((ValueError</span><span class="s2">, </span><span class="s1">OverflowError)):</span>
                <span class="s1">np.array([scalar]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s2">with </span><span class="s1">pytest.raises((ValueError</span><span class="s2">, </span><span class="s1">OverflowError)):</span>
                <span class="s1">cast[()] = scalar</span>


<span class="s2">class </span><span class="s1">TestTimeScalars:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[np.int64</span><span class="s2">, </span><span class="s1">np.float32])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scalar&quot;</span><span class="s2">,</span>
            <span class="s1">[param(np.timedelta64(</span><span class="s4">&quot;NaT&quot;</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[s](NaT)&quot;</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">param(np.timedelta64(</span><span class="s5">123</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[s]&quot;</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">param(np.datetime64(</span><span class="s4">&quot;NaT&quot;</span><span class="s2">, </span><span class="s4">&quot;generic&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;datetime64[generic](NaT)&quot;</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">param(np.datetime64(</span><span class="s5">1</span><span class="s2">, </span><span class="s4">&quot;D&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;datetime64[D]&quot;</span><span class="s1">)]</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_coercion_basic(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">scalar):</span>
        <span class="s3"># Note the `[scalar]` is there because np.array(scalar) uses stricter</span>
        <span class="s3"># `scalar.__int__()` rules for backward compatibility right now.</span>
        <span class="s1">arr = np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">cast = np.array(scalar).astype(dtype)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">cast)</span>

        <span class="s1">ass = np.ones(()</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
                <span class="s3"># raises, as would np.array([scalar], dtype=dtype), this is</span>
                <span class="s3"># conversion from times, but behaviour of integers.</span>
                <span class="s1">ass[()] = scalar</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ass[()] = scalar</span>
            <span class="s1">assert_array_equal(ass</span><span class="s2">, </span><span class="s1">cast)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[np.int64</span><span class="s2">, </span><span class="s1">np.float32])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scalar&quot;</span><span class="s2">,</span>
            <span class="s1">[param(np.timedelta64(</span><span class="s5">123</span><span class="s2">, </span><span class="s4">&quot;ns&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">param(np.timedelta64(</span><span class="s5">12</span><span class="s2">, </span><span class="s4">&quot;generic&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;timedelta64[generic]&quot;</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_coercion_timedelta_convert_to_number(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">scalar):</span>
        <span class="s3"># Only &quot;ns&quot; and &quot;generic&quot; timedeltas can be converted to numbers</span>
        <span class="s3"># so these are slightly special.</span>
        <span class="s1">arr = np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">cast = np.array(scalar).astype(dtype)</span>
        <span class="s1">ass = np.ones(()</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">ass[()] = scalar  </span><span class="s3"># raises, as would np.array([scalar], dtype=dtype)</span>

        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">cast)</span>
        <span class="s1">assert_array_equal(cast</span><span class="s2">, </span><span class="s1">cast)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;S6&quot;</span><span class="s2">, </span><span class="s4">&quot;U6&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize([</span><span class="s4">&quot;val&quot;</span><span class="s2">, </span><span class="s4">&quot;unit&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[param(</span><span class="s5">123</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;[s]&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">param(</span><span class="s5">123</span><span class="s2">, </span><span class="s4">&quot;D&quot;</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;[D]&quot;</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_coercion_assignment_datetime(self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s3"># String from datetime64 assignment is currently special cased to</span>
        <span class="s3"># never use casting.  This is because casting will error in this</span>
        <span class="s3"># case, and traditionally in most cases the behaviour is maintained</span>
        <span class="s3"># like this.  (`np.array(scalar, dtype=&quot;U6&quot;)` would have failed before)</span>
        <span class="s3"># TODO: This discrepancy _should_ be resolved, either by relaxing the</span>
        <span class="s3">#       cast, or by deprecating the first part.</span>
        <span class="s1">scalar = np.datetime64(val</span><span class="s2">, </span><span class="s1">unit)</span>
        <span class="s1">dtype = np.dtype(dtype)</span>
        <span class="s1">cut_string = dtype.type(str(scalar)[:</span><span class="s5">6</span><span class="s1">])</span>

        <span class="s1">arr = np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">assert </span><span class="s1">arr[()] == cut_string</span>
        <span class="s1">ass = np.ones(()</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">ass[()] = scalar</span>
        <span class="s2">assert </span><span class="s1">ass[()] == cut_string</span>

        <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s3"># However, unlike the above assignment using `str(scalar)[:6]`</span>
            <span class="s3"># due to being handled by the string DType and not be casting</span>
            <span class="s3"># the explicit cast fails:</span>
            <span class="s1">np.array(scalar).astype(dtype)</span>


    <span class="s1">@pytest.mark.parametrize([</span><span class="s4">&quot;val&quot;</span><span class="s2">, </span><span class="s4">&quot;unit&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[param(</span><span class="s5">123</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;[s]&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">param(</span><span class="s5">123</span><span class="s2">, </span><span class="s4">&quot;D&quot;</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">&quot;[D]&quot;</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_coercion_assignment_timedelta(self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s1">scalar = np.timedelta64(val</span><span class="s2">, </span><span class="s1">unit)</span>

        <span class="s3"># Unlike datetime64, timedelta allows the unsafe cast:</span>
        <span class="s1">np.array(scalar</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S6&quot;</span><span class="s1">)</span>
        <span class="s1">cast = np.array(scalar).astype(</span><span class="s4">&quot;S6&quot;</span><span class="s1">)</span>
        <span class="s1">ass = np.ones(()</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;S6&quot;</span><span class="s1">)</span>
        <span class="s1">ass[()] = scalar</span>
        <span class="s1">expected = scalar.astype(</span><span class="s4">&quot;S&quot;</span><span class="s1">)[:</span><span class="s5">6</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">cast[()] == expected</span>
        <span class="s2">assert </span><span class="s1">ass[()] == expected</span>

<span class="s2">class </span><span class="s1">TestNested:</span>
    <span class="s2">def </span><span class="s1">test_nested_simple(self):</span>
        <span class="s1">initial = [</span><span class="s5">1.2</span><span class="s1">]</span>
        <span class="s1">nested = initial</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(np.MAXDIMS - </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">nested = [nested]</span>

        <span class="s1">arr = np.array(nested</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">) * np.MAXDIMS</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.array([nested]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>

        <span class="s3"># We discover object automatically at this time:</span>
        <span class="s2">with </span><span class="s1">assert_warns(np.VisibleDeprecationWarning):</span>
            <span class="s1">arr = np.array([nested])</span>
        <span class="s2">assert </span><span class="s1">arr.dtype == np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">) * np.MAXDIMS</span>
        <span class="s2">assert </span><span class="s1">arr.item() </span><span class="s2">is </span><span class="s1">initial</span>

    <span class="s2">def </span><span class="s1">test_pathological_self_containing(self):</span>
        <span class="s3"># Test that this also works for two nested sequences</span>
        <span class="s1">l = []</span>
        <span class="s1">l.append(l)</span>
        <span class="s1">arr = np.array([l</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">l]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">3</span><span class="s2">,</span><span class="s1">) + (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">) * (np.MAXDIMS - </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3"># Also check a ragged case:</span>
        <span class="s1">arr = np.array([l</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">l]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;arraylike&quot;</span><span class="s2">, </span><span class="s1">arraylikes())</span>
    <span class="s2">def </span><span class="s1">test_nested_arraylikes(self</span><span class="s2">, </span><span class="s1">arraylike):</span>
        <span class="s3"># We try storing an array like into an array, but the array-like</span>
        <span class="s3"># will have too many dimensions.  This means the shape discovery</span>
        <span class="s3"># decides that the array-like must be treated as an object (a special</span>
        <span class="s3"># case of ragged discovery).  The result will be an array with one</span>
        <span class="s3"># dimension less than the maximum dimensions, and the array being</span>
        <span class="s3"># assigned to it (which does work for object or if `float(arraylike)`</span>
        <span class="s3"># works).</span>
        <span class="s1">initial = arraylike(np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>

        <span class="s1">nested = initial</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(np.MAXDIMS - </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">nested = [nested]</span>

        <span class="s2">with </span><span class="s1">pytest.warns(DeprecationWarning):</span>
            <span class="s3"># It will refuse to assign the array into</span>
            <span class="s1">np.array(nested</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>

        <span class="s3"># If this is object, we end up assigning a (1, 1) array into (1,)</span>
        <span class="s3"># (due to running out of dimensions), this is currently supported but</span>
        <span class="s3"># a special case which is not ideal.</span>
        <span class="s1">arr = np.array(nested</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">) * np.MAXDIMS</span>
        <span class="s2">assert </span><span class="s1">arr.item() == np.array(initial).item()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;arraylike&quot;</span><span class="s2">, </span><span class="s1">arraylikes())</span>
    <span class="s2">def </span><span class="s1">test_uneven_depth_ragged(self</span><span class="s2">, </span><span class="s1">arraylike):</span>
        <span class="s1">arr = np.arange(</span><span class="s5">4</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">arr = arraylike(arr)</span>

        <span class="s3"># Array is ragged in the second dimension already:</span>
        <span class="s1">out = np.array([arr</span><span class="s2">, </span><span class="s1">[arr]]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">out.shape == (</span><span class="s5">2</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">out[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">arr</span>
        <span class="s2">assert </span><span class="s1">type(out[</span><span class="s5">1</span><span class="s1">]) </span><span class="s2">is </span><span class="s1">list</span>

        <span class="s3"># Array is ragged in the third dimension:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s3"># This is a broadcast error during assignment, because</span>
            <span class="s3"># the array shape would be (2, 2, 2) but `arr[0, 0] = arr` fails.</span>
            <span class="s1">np.array([arr</span><span class="s2">, </span><span class="s1">[arr</span><span class="s2">, </span><span class="s1">arr]]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

    <span class="s2">def </span><span class="s1">test_empty_sequence(self):</span>
        <span class="s1">arr = np.array([[]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]]]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">arr.shape == (</span><span class="s5">3</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s3"># The empty sequence stops further dimension discovery, so the</span>
        <span class="s3"># result shape will be (0,) which leads to an error during:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.array([[]</span><span class="s2">, </span><span class="s1">np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

    <span class="s2">def </span><span class="s1">test_array_of_different_depths(self):</span>
        <span class="s3"># When multiple arrays (or array-likes) are included in a</span>
        <span class="s3"># sequences and have different depth, we currently discover</span>
        <span class="s3"># as many dimensions as they share. (see also gh-17224)</span>
        <span class="s1">arr = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">mismatch_first_dim = np.zeros((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">mismatch_second_dim = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape = _discover_array_parameters(</span>
            <span class="s1">[arr</span><span class="s2">, </span><span class="s1">mismatch_second_dim]</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">shape == (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>

        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape = _discover_array_parameters(</span>
            <span class="s1">[arr</span><span class="s2">, </span><span class="s1">mismatch_first_dim]</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">shape == (</span><span class="s5">2</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s3"># The second case is currently supported because the arrays</span>
        <span class="s3"># can be stored as objects:</span>
        <span class="s1">res = np.asarray([arr</span><span class="s2">, </span><span class="s1">mismatch_first_dim]</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">arr</span>
        <span class="s2">assert </span><span class="s1">res[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">is </span><span class="s1">mismatch_first_dim</span>


<span class="s2">class </span><span class="s1">TestBadSequences:</span>
    <span class="s3"># These are tests for bad objects passed into `np.array`, in general</span>
    <span class="s3"># these have undefined behaviour.  In the old code they partially worked</span>
    <span class="s3"># when now they will fail.  We could (and maybe should) create a copy</span>
    <span class="s3"># of all sequences to be safe against bad-actors.</span>

    <span class="s2">def </span><span class="s1">test_growing_list(self):</span>
        <span class="s3"># List to coerce, `mylist` will append to it during coercion</span>
        <span class="s1">obj = []</span>
        <span class="s2">class </span><span class="s1">mylist(list):</span>
            <span class="s2">def </span><span class="s1">__len__(self):</span>
                <span class="s1">obj.append([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
                <span class="s2">return </span><span class="s1">super().__len__()</span>

        <span class="s1">obj.append(mylist([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]))</span>

        <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s1">np.array(obj)</span>

    <span class="s3"># Note: We do not test a shrinking list.  These do very evil things</span>
    <span class="s3">#       and the only way to fix them would be to copy all sequences.</span>
    <span class="s3">#       (which may be a real option in the future).</span>

    <span class="s2">def </span><span class="s1">test_mutated_list(self):</span>
        <span class="s3"># List to coerce, `mylist` will mutate the first element</span>
        <span class="s1">obj = []</span>
        <span class="s2">class </span><span class="s1">mylist(list):</span>
            <span class="s2">def </span><span class="s1">__len__(self):</span>
                <span class="s1">obj[</span><span class="s5">0</span><span class="s1">] = [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]  </span><span class="s3"># replace with a different list.</span>
                <span class="s2">return </span><span class="s1">super().__len__()</span>

        <span class="s1">obj.append([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">obj.append(mylist([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]))</span>
        <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s1">np.array(obj)</span>

    <span class="s2">def </span><span class="s1">test_replace_0d_array(self):</span>
        <span class="s3"># List to coerce, `mylist` will mutate the first element</span>
        <span class="s1">obj = []</span>
        <span class="s2">class </span><span class="s1">baditem:</span>
            <span class="s2">def </span><span class="s1">__len__(self):</span>
                <span class="s1">obj[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">2  </span><span class="s3"># replace with a different list.</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;not actually a sequence!&quot;</span><span class="s1">)</span>

            <span class="s2">def </span><span class="s1">__getitem__(self):</span>
                <span class="s2">pass</span>

        <span class="s3"># Runs into a corner case in the new code, the `array(2)` is cached</span>
        <span class="s3"># so replacing it invalidates the cache.</span>
        <span class="s1">obj.append([np.array(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">baditem()])</span>
        <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s1">np.array(obj)</span>


<span class="s2">class </span><span class="s1">TestArrayLikes:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;arraylike&quot;</span><span class="s2">, </span><span class="s1">arraylikes())</span>
    <span class="s2">def </span><span class="s1">test_0d_object_special_case(self</span><span class="s2">, </span><span class="s1">arraylike):</span>
        <span class="s1">arr = np.array(</span><span class="s5">0.</span><span class="s1">)</span>
        <span class="s1">obj = arraylike(arr)</span>
        <span class="s3"># A single array-like is always converted:</span>
        <span class="s1">res = np.array(obj</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">res)</span>

        <span class="s3"># But a single 0-D nested array-like never:</span>
        <span class="s1">res = np.array([obj]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">test_0d_generic_special_case(self):</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">def </span><span class="s1">__float__(self):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;e.g. quantities raise on this&quot;</span><span class="s1">)</span>

        <span class="s1">arr = np.array(</span><span class="s5">0.</span><span class="s1">)</span>
        <span class="s1">obj = arr.view(ArraySubclass)</span>
        <span class="s1">res = np.array(obj)</span>
        <span class="s3"># The subclass is simply cast:</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">res)</span>

        <span class="s3"># If the 0-D array-like is included, __float__ is currently</span>
        <span class="s3"># guaranteed to be used.  We may want to change that, quantities</span>
        <span class="s3"># and masked arrays half make use of this.</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.array([obj])</span>

        <span class="s3"># The same holds for memoryview:</span>
        <span class="s1">obj = memoryview(arr)</span>
        <span class="s1">res = np.array(obj)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s2">, </span><span class="s1">res)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s3"># The error type does not matter much here.</span>
            <span class="s1">np.array([obj])</span>

    <span class="s2">def </span><span class="s1">test_arraylike_classes(self):</span>
        <span class="s3"># The classes of array-likes should generally be acceptable to be</span>
        <span class="s3"># stored inside a numpy (object) array.  This tests all of the</span>
        <span class="s3"># special attributes (since all are checked during coercion).</span>
        <span class="s1">arr = np.array(np.int64)</span>
        <span class="s2">assert </span><span class="s1">arr[()] </span><span class="s2">is </span><span class="s1">np.int64</span>
        <span class="s1">arr = np.array([np.int64])</span>
        <span class="s2">assert </span><span class="s1">arr[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">np.int64</span>

        <span class="s3"># This also works for properties/unbound methods:</span>
        <span class="s2">class </span><span class="s1">ArrayLike:</span>
            <span class="s1">@property</span>
            <span class="s2">def </span><span class="s1">__array_interface__(self):</span>
                <span class="s2">pass</span>

            <span class="s1">@property</span>
            <span class="s2">def </span><span class="s1">__array_struct__(self):</span>
                <span class="s2">pass</span>

            <span class="s2">def </span><span class="s1">__array__(self):</span>
                <span class="s2">pass</span>

        <span class="s1">arr = np.array(ArrayLike)</span>
        <span class="s2">assert </span><span class="s1">arr[()] </span><span class="s2">is </span><span class="s1">ArrayLike</span>
        <span class="s1">arr = np.array([ArrayLike])</span>
        <span class="s2">assert </span><span class="s1">arr[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">ArrayLike</span>

    <span class="s1">@pytest.mark.skipif(</span>
            <span class="s1">np.dtype(np.intp).itemsize &lt; </span><span class="s5">8</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">&quot;Needs 64bit platform&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_too_large_array_error_paths(self):</span>
        <span class="s0">&quot;&quot;&quot;Test the error paths, including for memory leaks&quot;&quot;&quot;</span>
        <span class="s1">arr = np.array(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;uint8&quot;</span><span class="s1">)</span>
        <span class="s3"># Guarantees that a contiguous copy won't work:</span>
        <span class="s1">arr = np.broadcast_to(arr</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">62</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">):</span>
            <span class="s3"># repeat, to ensure caching cannot have an effect:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(MemoryError):</span>
                <span class="s1">np.array(arr)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(MemoryError):</span>
                <span class="s1">np.array([arr])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;attribute&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">&quot;__array_interface__&quot;</span><span class="s2">, </span><span class="s4">&quot;__array__&quot;</span><span class="s2">, </span><span class="s4">&quot;__array_struct__&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;error&quot;</span><span class="s2">, </span><span class="s1">[RecursionError</span><span class="s2">, </span><span class="s1">MemoryError])</span>
    <span class="s2">def </span><span class="s1">test_bad_array_like_attributes(self</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">error):</span>
        <span class="s3"># RecursionError and MemoryError are considered fatal. All errors</span>
        <span class="s3"># (except AttributeError) should probably be raised in the future,</span>
        <span class="s3"># but shapely made use of it, so it will require a deprecation.</span>

        <span class="s2">class </span><span class="s1">BadInterface:</span>
            <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
                <span class="s2">if </span><span class="s1">attr == attribute:</span>
                    <span class="s2">raise </span><span class="s1">error</span>
                <span class="s1">super().__getattr__(attr)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(error):</span>
            <span class="s1">np.array(BadInterface())</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;error&quot;</span><span class="s2">, </span><span class="s1">[RecursionError</span><span class="s2">, </span><span class="s1">MemoryError])</span>
    <span class="s2">def </span><span class="s1">test_bad_array_like_bad_length(self</span><span class="s2">, </span><span class="s1">error):</span>
        <span class="s3"># RecursionError and MemoryError are considered &quot;critical&quot; in</span>
        <span class="s3"># sequences. We could expand this more generally though. (NumPy 1.20)</span>
        <span class="s2">class </span><span class="s1">BadSequence:</span>
            <span class="s2">def </span><span class="s1">__len__(self):</span>
                <span class="s2">raise </span><span class="s1">error</span>
            <span class="s2">def </span><span class="s1">__getitem__(self):</span>
                <span class="s3"># must have getitem to be a Sequence</span>
                <span class="s2">return </span><span class="s5">1</span>

        <span class="s2">with </span><span class="s1">pytest.raises(error):</span>
            <span class="s1">np.array(BadSequence())</span>

</pre>
</body>
</html>