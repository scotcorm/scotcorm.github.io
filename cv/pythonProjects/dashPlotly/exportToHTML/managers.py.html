<html>
<head>
<title>managers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
managers.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">TypeVar</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">internals </span><span class="s0">as </span><span class="s1">libinternals</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.internals </span><span class="s0">import </span><span class="s1">BlockPlacement</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s0">,</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">Shape</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
    <span class="s1">type_t</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">PerformanceWarning</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>
<span class="s0">from </span><span class="s1">pandas.util._validators </span><span class="s0">import </span><span class="s1">validate_bool_kwarg</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s0">import </span><span class="s1">infer_dtype_from_scalar</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s0">,</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s0">,</span>
    <span class="s1">is_dtype_equal</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s0">,</span>
    <span class="s1">ABCSeries</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array_equals</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">pandas.core.algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays._mixins </span><span class="s0">import </span><span class="s1">NDArrayBackedExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.sparse </span><span class="s0">import </span><span class="s1">SparseDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s0">,</span>
    <span class="s1">extract_array</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexers </span><span class="s0">import </span><span class="s1">maybe_convert_indices</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Float64Index</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">ensure_index</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.internals.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataManager</span><span class="s0">,</span>
    <span class="s1">SingleDataManager</span><span class="s0">,</span>
    <span class="s1">interleaved_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.internals.blocks </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Block</span><span class="s0">,</span>
    <span class="s1">DatetimeTZBlock</span><span class="s0">,</span>
    <span class="s1">NumpyBlock</span><span class="s0">,</span>
    <span class="s1">ensure_block_shape</span><span class="s0">,</span>
    <span class="s1">extend_blocks</span><span class="s0">,</span>
    <span class="s1">get_block_type</span><span class="s0">,</span>
    <span class="s1">new_block</span><span class="s0">,</span>
    <span class="s1">new_block_2d</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.internals.ops </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">blockwise_all</span><span class="s0">,</span>
    <span class="s1">operate_blockwise</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">T = TypeVar(</span><span class="s2">&quot;T&quot;</span><span class="s0">, </span><span class="s1">bound=</span><span class="s2">&quot;BaseBlockManager&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">BaseBlockManager(DataManager):</span>
    <span class="s3">&quot;&quot;&quot; 
    Core internal data structure to implement DataFrame, Series, etc. 
 
    Manage a bunch of labeled 2D mixed-type ndarrays. Essentially it's a 
    lightweight blocked set of labeled data to be manipulated by the DataFrame 
    public API class 
 
    Attributes 
    ---------- 
    shape 
    ndim 
    axes 
    values 
    items 
 
    Methods 
    ------- 
    set_axis(axis, new_labels) 
    copy(deep=True) 
 
    get_dtypes 
 
    apply(func, axes, block_filter_fn) 
 
    get_bool_data 
    get_numeric_data 
 
    get_slice(slice_like, axis) 
    get(label) 
    iget(loc) 
 
    take(indexer, axis) 
    reindex_axis(new_labels, axis) 
    reindex_indexer(new_labels, indexer, axis) 
 
    delete(label) 
    insert(loc, label, value) 
    set(label, value) 
 
    Parameters 
    ---------- 
    blocks: Sequence of Block 
    axes: Sequence of Index 
    verify_integrity: bool, default True 
 
    Notes 
    ----- 
    This is *not* a public API class 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">_blknos: npt.NDArray[np.intp]</span>
    <span class="s1">_blklocs: npt.NDArray[np.intp]</span>
    <span class="s1">blocks: tuple[Block</span><span class="s0">, </span><span class="s1">...]</span>
    <span class="s1">axes: list[Index]</span>

    <span class="s1">ndim: int</span>
    <span class="s1">_known_consolidated: bool</span>
    <span class="s1">_is_consolidated: bool</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">blocks</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">verify_integrity: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_blocks(cls: type_t[T]</span><span class="s0">, </span><span class="s1">blocks: list[Block]</span><span class="s0">, </span><span class="s1">axes: list[Index]) -&gt; T:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">blknos(self) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Suppose we want to find the array corresponding to our i'th column. 
 
        blknos[i] identifies the block from self.blocks that contains this column. 
 
        blklocs[i] identifies the column of interest within 
        self.blocks[self.blknos[i]] 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._blknos </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># Note: these can be altered by other BlockManager methods.</span>
            <span class="s1">self._rebuild_blknos_and_blklocs()</span>

        <span class="s0">return </span><span class="s1">self._blknos</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">blklocs(self) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s3">&quot;&quot;&quot; 
        See blknos.__doc__ 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._blklocs </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># Note: these can be altered by other BlockManager methods.</span>
            <span class="s1">self._rebuild_blknos_and_blklocs()</span>

        <span class="s0">return </span><span class="s1">self._blklocs</span>

    <span class="s0">def </span><span class="s1">make_empty(self: T</span><span class="s0">, </span><span class="s1">axes=</span><span class="s0">None</span><span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot;return an empty BlockManager with the items axis of len 0&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">axes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">axes = [Index([])] + self.axes[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s4"># preserve dtype if possible</span>
        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">SingleBlockManager)  </span><span class="s4"># for mypy</span>
            <span class="s1">blk = self.blocks[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">arr = blk.values[:</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">nb = blk.make_block_same_class(arr</span><span class="s0">, </span><span class="s1">placement=bp)</span>
            <span class="s1">blocks = [nb]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">blocks = []</span>
        <span class="s0">return </span><span class="s1">type(self).from_blocks(blocks</span><span class="s0">, </span><span class="s1">axes)</span>

    <span class="s0">def </span><span class="s1">__nonzero__(self) -&gt; bool:</span>
        <span class="s0">return True</span>

    <span class="s4"># Python3 compat</span>
    <span class="s1">__bool__ = __nonzero__</span>

    <span class="s0">def </span><span class="s1">_normalize_axis(self</span><span class="s0">, </span><span class="s1">axis: int) -&gt; int:</span>
        <span class="s4"># switch axis to follow BlockManager logic</span>
        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">axis = </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">axis == </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">0</span>
        <span class="s0">return </span><span class="s1">axis</span>

    <span class="s0">def </span><span class="s1">set_axis(self</span><span class="s0">, </span><span class="s1">axis: int</span><span class="s0">, </span><span class="s1">new_labels: Index) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4"># Caller is responsible for ensuring we have an Index object.</span>
        <span class="s1">self._validate_set_axis(axis</span><span class="s0">, </span><span class="s1">new_labels)</span>
        <span class="s1">self.axes[axis] = new_labels</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_single_block(self) -&gt; bool:</span>
        <span class="s4"># Assumes we are 2D; overridden by SingleBlockManager</span>
        <span class="s0">return </span><span class="s1">len(self.blocks) == </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">items(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.axes[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">get_dtypes(self):</span>
        <span class="s1">dtypes = np.array([blk.dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks])</span>
        <span class="s0">return </span><span class="s1">dtypes.take(self.blknos)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">arrays(self) -&gt; list[ArrayLike]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Quick access to the backing arrays of the Blocks. 
 
        Only for compatibility with ArrayManager for testing convenience. 
        Not to be used in actual code, and return value is not the same as the 
        ArrayManager method (list of 1D arrays vs iterator of 2D ndarrays / 1D EAs). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">[blk.values </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks]</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">output = type(self).__name__</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(self.axes):</span>
            <span class="s0">if </span><span class="s1">i == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">output += </span><span class="s2">f&quot;</span><span class="s0">\n</span><span class="s2">Items: </span><span class="s0">{</span><span class="s1">ax</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">output += </span><span class="s2">f&quot;</span><span class="s0">\n</span><span class="s2">Axis </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">: </span><span class="s0">{</span><span class="s1">ax</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s1">output += </span><span class="s2">f&quot;</span><span class="s0">\n{</span><span class="s1">block</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s0">return </span><span class="s1">output</span>

    <span class="s0">def </span><span class="s1">apply(</span>
        <span class="s1">self: T</span><span class="s0">,</span>
        <span class="s1">f</span><span class="s0">,</span>
        <span class="s1">align_keys: list[str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">ignore_failures: bool = </span><span class="s0">False,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Iterate over the blocks, collect and create a new BlockManager. 
 
        Parameters 
        ---------- 
        f : str or callable 
            Name of the Block method to apply. 
        align_keys: List[str] or None, default None 
        ignore_failures: bool, default False 
        **kwargs 
            Keywords to pass to `f` 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s2">&quot;filter&quot; </span><span class="s0">not in </span><span class="s1">kwargs</span>

        <span class="s1">align_keys = align_keys </span><span class="s0">or </span><span class="s1">[]</span>
        <span class="s1">result_blocks: list[Block] = []</span>
        <span class="s4"># fillna: Series/DataFrame is responsible for making sure value is aligned</span>

        <span class="s1">aligned_args = {k: kwargs[k] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">align_keys}</span>

        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self.blocks:</span>

            <span class="s0">if </span><span class="s1">aligned_args:</span>

                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">aligned_args.items():</span>
                    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">(ABCSeries</span><span class="s0">, </span><span class="s1">ABCDataFrame)):</span>
                        <span class="s4"># The caller is responsible for ensuring that</span>
                        <span class="s4">#  obj.axes[-1].equals(self.items)</span>
                        <span class="s0">if </span><span class="s1">obj.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                            <span class="s1">kwargs[k] = obj.iloc[b.mgr_locs.indexer]._values</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">kwargs[k] = obj.iloc[:</span><span class="s0">, </span><span class="s1">b.mgr_locs.indexer]._values</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s4"># otherwise we have an ndarray</span>
                        <span class="s1">kwargs[k] = obj[b.mgr_locs.indexer]</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">callable(f):</span>
                    <span class="s1">applied = b.apply(f</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">applied = getattr(b</span><span class="s0">, </span><span class="s1">f)(**kwargs)</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">NotImplementedError):</span>
                <span class="s0">if not </span><span class="s1">ignore_failures:</span>
                    <span class="s0">raise</span>
                <span class="s0">continue</span>
            <span class="s1">result_blocks = extend_blocks(applied</span><span class="s0">, </span><span class="s1">result_blocks)</span>

        <span class="s0">if </span><span class="s1">ignore_failures:</span>
            <span class="s0">return </span><span class="s1">self._combine(result_blocks)</span>

        <span class="s1">out = type(self).from_blocks(result_blocks</span><span class="s0">, </span><span class="s1">self.axes)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">where(self: T</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">cond</span><span class="s0">, </span><span class="s1">align: bool) -&gt; T:</span>
        <span class="s0">if </span><span class="s1">align:</span>
            <span class="s1">align_keys = [</span><span class="s2">&quot;other&quot;</span><span class="s0">, </span><span class="s2">&quot;cond&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">align_keys = [</span><span class="s2">&quot;cond&quot;</span><span class="s1">]</span>
            <span class="s1">other = extract_array(other</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self.apply(</span>
            <span class="s2">&quot;where&quot;</span><span class="s0">,</span>
            <span class="s1">align_keys=align_keys</span><span class="s0">,</span>
            <span class="s1">other=other</span><span class="s0">,</span>
            <span class="s1">cond=cond</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">setitem(self: T</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">value) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Set values with indexer. 
 
        For SingleBlockManager, this backs s[indexer] = value 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;setitem&quot;</span><span class="s0">, </span><span class="s1">indexer=indexer</span><span class="s0">, </span><span class="s1">value=value)</span>

    <span class="s0">def </span><span class="s1">putmask(self</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">new</span><span class="s0">, </span><span class="s1">align: bool = </span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">align:</span>
            <span class="s1">align_keys = [</span><span class="s2">&quot;new&quot;</span><span class="s0">, </span><span class="s2">&quot;mask&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">align_keys = [</span><span class="s2">&quot;mask&quot;</span><span class="s1">]</span>
            <span class="s1">new = extract_array(new</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self.apply(</span>
            <span class="s2">&quot;putmask&quot;</span><span class="s0">,</span>
            <span class="s1">align_keys=align_keys</span><span class="s0">,</span>
            <span class="s1">mask=mask</span><span class="s0">,</span>
            <span class="s1">new=new</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">diff(self: T</span><span class="s0">, </span><span class="s1">n: int</span><span class="s0">, </span><span class="s1">axis: int) -&gt; T:</span>
        <span class="s1">axis = self._normalize_axis(axis)</span>
        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;diff&quot;</span><span class="s0">, </span><span class="s1">n=n</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">interpolate(self: T</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; T:</span>
        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;interpolate&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">shift(self: T</span><span class="s0">, </span><span class="s1">periods: int</span><span class="s0">, </span><span class="s1">axis: int</span><span class="s0">, </span><span class="s1">fill_value) -&gt; T:</span>
        <span class="s1">axis = self._normalize_axis(axis)</span>
        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">fill_value = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">axis == </span><span class="s5">0</span>
            <span class="s0">and </span><span class="s1">self.ndim == </span><span class="s5">2</span>
            <span class="s0">and </span><span class="s1">(</span>
                <span class="s1">self.nblocks &gt; </span><span class="s5">1</span>
                <span class="s0">or </span><span class="s1">(</span>
                    <span class="s4"># If we only have one block and we know that we can't</span>
                    <span class="s4">#  keep the same dtype (i.e. the _can_hold_element check)</span>
                    <span class="s4">#  then we can go through the reindex_indexer path</span>
                    <span class="s4">#  (and avoid casting logic in the Block method).</span>
                    <span class="s4">#  The exception to this (until 2.0) is datetimelike</span>
                    <span class="s4">#  dtypes with integers, which cast.</span>
                    <span class="s0">not </span><span class="s1">self.blocks[</span><span class="s5">0</span><span class="s1">]._can_hold_element(fill_value)</span>
                    <span class="s4"># TODO(2.0): remove special case for integer-with-datetimelike</span>
                    <span class="s4">#  once deprecation is enforced</span>
                    <span class="s0">and not </span><span class="s1">(</span>
                        <span class="s1">lib.is_integer(fill_value)</span>
                        <span class="s0">and </span><span class="s1">needs_i8_conversion(self.blocks[</span><span class="s5">0</span><span class="s1">].dtype)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s4"># GH#35488 we need to watch out for multi-block cases</span>
            <span class="s4"># We only get here with fill_value not-lib.no_default</span>
            <span class="s1">ncols = self.shape[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">nper = abs(periods)</span>
            <span class="s1">nper = min(nper</span><span class="s0">, </span><span class="s1">ncols)</span>
            <span class="s0">if </span><span class="s1">periods &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">indexer = np.array(</span>
                    <span class="s1">[-</span><span class="s5">1</span><span class="s1">] * nper + list(range(ncols - periods))</span><span class="s0">, </span><span class="s1">dtype=np.intp</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">indexer = np.array(</span>
                    <span class="s1">list(range(nper</span><span class="s0">, </span><span class="s1">ncols)) + [-</span><span class="s5">1</span><span class="s1">] * nper</span><span class="s0">, </span><span class="s1">dtype=np.intp</span>
                <span class="s1">)</span>
            <span class="s1">result = self.reindex_indexer(</span>
                <span class="s1">self.items</span><span class="s0">,</span>
                <span class="s1">indexer</span><span class="s0">,</span>
                <span class="s1">axis=</span><span class="s5">0</span><span class="s0">,</span>
                <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
                <span class="s1">allow_dups=</span><span class="s0">True,</span>
                <span class="s1">consolidate=</span><span class="s0">False,</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;shift&quot;</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>

    <span class="s0">def </span><span class="s1">fillna(self: T</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">limit</span><span class="s0">, </span><span class="s1">inplace: bool</span><span class="s0">, </span><span class="s1">downcast) -&gt; T:</span>
        <span class="s0">return </span><span class="s1">self.apply(</span>
            <span class="s2">&quot;fillna&quot;</span><span class="s0">, </span><span class="s1">value=value</span><span class="s0">, </span><span class="s1">limit=limit</span><span class="s0">, </span><span class="s1">inplace=inplace</span><span class="s0">, </span><span class="s1">downcast=downcast</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">astype(self: T</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False, </span><span class="s1">errors: str = </span><span class="s2">&quot;raise&quot;</span><span class="s1">) -&gt; T:</span>
        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;astype&quot;</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">copy=copy</span><span class="s0">, </span><span class="s1">errors=errors)</span>

    <span class="s0">def </span><span class="s1">convert(</span>
        <span class="s1">self: T</span><span class="s0">,</span>
        <span class="s1">copy: bool = </span><span class="s0">True,</span>
        <span class="s1">datetime: bool = </span><span class="s0">True,</span>
        <span class="s1">numeric: bool = </span><span class="s0">True,</span>
        <span class="s1">timedelta: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; T:</span>
        <span class="s0">return </span><span class="s1">self.apply(</span>
            <span class="s2">&quot;convert&quot;</span><span class="s0">,</span>
            <span class="s1">copy=copy</span><span class="s0">,</span>
            <span class="s1">datetime=datetime</span><span class="s0">,</span>
            <span class="s1">numeric=numeric</span><span class="s0">,</span>
            <span class="s1">timedelta=timedelta</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">replace(self: T</span><span class="s0">, </span><span class="s1">to_replace</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">inplace: bool) -&gt; T:</span>
        <span class="s1">inplace = validate_bool_kwarg(inplace</span><span class="s0">, </span><span class="s2">&quot;inplace&quot;</span><span class="s1">)</span>
        <span class="s4"># NDFrame.replace ensures the not-is_list_likes here</span>
        <span class="s0">assert not </span><span class="s1">is_list_like(to_replace)</span>
        <span class="s0">assert not </span><span class="s1">is_list_like(value)</span>
        <span class="s0">return </span><span class="s1">self.apply(</span>
            <span class="s2">&quot;replace&quot;</span><span class="s0">, </span><span class="s1">to_replace=to_replace</span><span class="s0">, </span><span class="s1">value=value</span><span class="s0">, </span><span class="s1">inplace=inplace</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">replace_regex(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;_replace_regex&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">replace_list(</span>
        <span class="s1">self: T</span><span class="s0">,</span>
        <span class="s1">src_list: list[Any]</span><span class="s0">,</span>
        <span class="s1">dest_list: list[Any]</span><span class="s0">,</span>
        <span class="s1">inplace: bool = </span><span class="s0">False,</span>
        <span class="s1">regex: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot;do a list replace&quot;&quot;&quot;</span>
        <span class="s1">inplace = validate_bool_kwarg(inplace</span><span class="s0">, </span><span class="s2">&quot;inplace&quot;</span><span class="s1">)</span>

        <span class="s1">bm = self.apply(</span>
            <span class="s2">&quot;replace_list&quot;</span><span class="s0">,</span>
            <span class="s1">src_list=src_list</span><span class="s0">,</span>
            <span class="s1">dest_list=dest_list</span><span class="s0">,</span>
            <span class="s1">inplace=inplace</span><span class="s0">,</span>
            <span class="s1">regex=regex</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">bm._consolidate_inplace()</span>
        <span class="s0">return </span><span class="s1">bm</span>

    <span class="s0">def </span><span class="s1">to_native_types(self: T</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert values to native types (strings / python objects) that are used 
        in formatting (repr / csv). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.apply(</span><span class="s2">&quot;to_native_types&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_numeric_mixed_type(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">all(block.is_numeric </span><span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self.blocks)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">any_extension_types(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Whether any of the blocks in this manager are extension blocks&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">any(block.is_extension </span><span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self.blocks)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_view(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;return a boolean if we are a single block and are a view&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(self.blocks) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.blocks[</span><span class="s5">0</span><span class="s1">].is_view</span>

        <span class="s4"># It is technically possible to figure out which blocks are views</span>
        <span class="s4"># e.g. [ b.values.base is not None for b in self.blocks ]</span>
        <span class="s4"># but then we have the case of possibly some blocks being a view</span>
        <span class="s4"># and some blocks not. setting in theory is possible on the non-view</span>
        <span class="s4"># blocks w/o causing a SettingWithCopy raise/warn. But this is a bit</span>
        <span class="s4"># complicated</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_get_data_subset(self: T</span><span class="s0">, </span><span class="s1">predicate: Callable) -&gt; T:</span>
        <span class="s1">blocks = [blk </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks </span><span class="s0">if </span><span class="s1">predicate(blk.values)]</span>
        <span class="s0">return </span><span class="s1">self._combine(blocks</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_bool_data(self: T</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Select blocks that are bool-dtype and columns from object-dtype blocks 
        that are all-bool. 
 
        Parameters 
        ---------- 
        copy : bool, default False 
            Whether to copy the blocks 
        &quot;&quot;&quot;</span>

        <span class="s1">new_blocks = []</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s0">if </span><span class="s1">blk.dtype == bool:</span>
                <span class="s1">new_blocks.append(blk)</span>

            <span class="s0">elif </span><span class="s1">blk.is_object:</span>
                <span class="s1">nbs = blk._split()</span>
                <span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">nbs:</span>
                    <span class="s0">if </span><span class="s1">nb.is_bool:</span>
                        <span class="s1">new_blocks.append(nb)</span>

        <span class="s0">return </span><span class="s1">self._combine(new_blocks</span><span class="s0">, </span><span class="s1">copy)</span>

    <span class="s0">def </span><span class="s1">get_numeric_data(self: T</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        copy : bool, default False 
            Whether to copy the blocks 
        &quot;&quot;&quot;</span>
        <span class="s1">numeric_blocks = [blk </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks </span><span class="s0">if </span><span class="s1">blk.is_numeric]</span>
        <span class="s0">if </span><span class="s1">len(numeric_blocks) == len(self.blocks):</span>
            <span class="s4"># Avoid somewhat expensive _combine</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self.copy(deep=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">self._combine(numeric_blocks</span><span class="s0">, </span><span class="s1">copy)</span>

    <span class="s0">def </span><span class="s1">_combine(</span>
        <span class="s1">self: T</span><span class="s0">, </span><span class="s1">blocks: list[Block]</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True, </span><span class="s1">index: Index | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot;return a new manager with the blocks&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(blocks) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s4"># retain our own Index dtype</span>
                <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axes = [self.items[:</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">axes = [self.items[:</span><span class="s5">0</span><span class="s1">]] + self.axes[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s0">return </span><span class="s1">self.make_empty(axes)</span>
            <span class="s0">return </span><span class="s1">self.make_empty()</span>

        <span class="s4"># FIXME: optimization potential</span>
        <span class="s1">indexer = np.sort(np.concatenate([b.mgr_locs.as_array </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks]))</span>
        <span class="s1">inv_indexer = lib.get_reverse_indexer(indexer</span><span class="s0">, </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s1">new_blocks: list[Block] = []</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks:</span>
            <span class="s1">b = b.copy(deep=copy)</span>
            <span class="s1">b.mgr_locs = BlockPlacement(inv_indexer[b.mgr_locs.indexer])</span>
            <span class="s1">new_blocks.append(b)</span>

        <span class="s1">axes = list(self.axes)</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">axes[-</span><span class="s5">1</span><span class="s1">] = index</span>
        <span class="s1">axes[</span><span class="s5">0</span><span class="s1">] = self.items.take(indexer)</span>

        <span class="s0">return </span><span class="s1">type(self).from_blocks(new_blocks</span><span class="s0">, </span><span class="s1">axes)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nblocks(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self.blocks)</span>

    <span class="s0">def </span><span class="s1">copy(self: T</span><span class="s0">, </span><span class="s1">deep=</span><span class="s0">True</span><span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Make deep or shallow copy of BlockManager 
 
        Parameters 
        ---------- 
        deep : bool or string, default True 
            If False, return shallow copy (do not copy data) 
            If 'all', copy data and a deep copy of the index 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s4"># this preserves the notion of view copying of axes</span>
        <span class="s0">if </span><span class="s1">deep:</span>
            <span class="s4"># hit in e.g. tests.io.json.test_pandas</span>

            <span class="s0">def </span><span class="s1">copy_func(ax):</span>
                <span class="s0">return </span><span class="s1">ax.copy(deep=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">if </span><span class="s1">deep == </span><span class="s2">&quot;all&quot; </span><span class="s0">else </span><span class="s1">ax.view()</span>

            <span class="s1">new_axes = [copy_func(ax) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self.axes]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_axes = list(self.axes)</span>

        <span class="s1">res = self.apply(</span><span class="s2">&quot;copy&quot;</span><span class="s0">, </span><span class="s1">deep=deep)</span>

        <span class="s1">res.axes = new_axes</span>

        <span class="s0">if </span><span class="s1">self.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># Avoid needing to re-compute these</span>
            <span class="s1">blknos = self._blknos</span>
            <span class="s0">if </span><span class="s1">blknos </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">res._blknos = blknos.copy()</span>
                <span class="s1">res._blklocs = self._blklocs.copy()</span>

        <span class="s0">if </span><span class="s1">deep:</span>
            <span class="s1">res._consolidate_inplace()</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">consolidate(self: T) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Join together blocks having same dtype 
 
        Returns 
        ------- 
        y : BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_consolidated():</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">bm = type(self)(self.blocks</span><span class="s0">, </span><span class="s1">self.axes</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">bm._is_consolidated = </span><span class="s0">False</span>
        <span class="s1">bm._consolidate_inplace()</span>
        <span class="s0">return </span><span class="s1">bm</span>

    <span class="s0">def </span><span class="s1">reindex_indexer(</span>
        <span class="s1">self: T</span><span class="s0">,</span>
        <span class="s1">new_axis: Index</span><span class="s0">,</span>
        <span class="s1">indexer</span><span class="s0">,</span>
        <span class="s1">axis: int</span><span class="s0">,</span>
        <span class="s1">fill_value=</span><span class="s0">None,</span>
        <span class="s1">allow_dups: bool = </span><span class="s0">False,</span>
        <span class="s1">copy: bool = </span><span class="s0">True,</span>
        <span class="s1">consolidate: bool = </span><span class="s0">True,</span>
        <span class="s1">only_slice: bool = </span><span class="s0">False,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">use_na_proxy: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        new_axis : Index 
        indexer : ndarray of int64 or None 
        axis : int 
        fill_value : object, default None 
        allow_dups : bool, default False 
        copy : bool, default True 
        consolidate: bool, default True 
            Whether to consolidate inplace before reindexing. 
        only_slice : bool, default False 
            Whether to take views, not copies, along columns. 
        use_na_proxy : bool, default False 
            Whether to use a np.void ndarray for newly introduced columns. 
 
        pandas-indexer with -1's only. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">new_axis </span><span class="s0">is </span><span class="s1">self.axes[axis] </span><span class="s0">and not </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self</span>

            <span class="s1">result = self.copy(deep=copy)</span>
            <span class="s1">result.axes = list(self.axes)</span>
            <span class="s1">result.axes[axis] = new_axis</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s1">consolidate:</span>
            <span class="s1">self._consolidate_inplace()</span>

        <span class="s4"># some axes don't allow reindexing with dups</span>
        <span class="s0">if not </span><span class="s1">allow_dups:</span>
            <span class="s1">self.axes[axis]._validate_can_reindex(indexer)</span>

        <span class="s0">if </span><span class="s1">axis &gt;= self.ndim:</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s2">&quot;Requested axis not found in manager&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">new_blocks = self._slice_take_blocks_ax0(</span>
                <span class="s1">indexer</span><span class="s0">,</span>
                <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
                <span class="s1">only_slice=only_slice</span><span class="s0">,</span>
                <span class="s1">use_na_proxy=use_na_proxy</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_blocks = [</span>
                <span class="s1">blk.take_nd(</span>
                    <span class="s1">indexer</span><span class="s0">,</span>
                    <span class="s1">axis=</span><span class="s5">1</span><span class="s0">,</span>
                    <span class="s1">fill_value=(</span>
                        <span class="s1">fill_value </span><span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is not None else </span><span class="s1">blk.fill_value</span>
                    <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks</span>
            <span class="s1">]</span>

        <span class="s1">new_axes = list(self.axes)</span>
        <span class="s1">new_axes[axis] = new_axis</span>

        <span class="s1">new_mgr = type(self).from_blocks(new_blocks</span><span class="s0">, </span><span class="s1">new_axes)</span>
        <span class="s0">if </span><span class="s1">axis == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># We can avoid the need to rebuild these</span>
            <span class="s1">new_mgr._blknos = self.blknos.copy()</span>
            <span class="s1">new_mgr._blklocs = self.blklocs.copy()</span>
        <span class="s0">return </span><span class="s1">new_mgr</span>

    <span class="s0">def </span><span class="s1">_slice_take_blocks_ax0(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">slice_or_indexer: slice | np.ndarray</span><span class="s0">,</span>
        <span class="s1">fill_value=lib.no_default</span><span class="s0">,</span>
        <span class="s1">only_slice: bool = </span><span class="s0">False,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">use_na_proxy: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Slice/take blocks along axis=0. 
 
        Overloaded for SingleBlock 
 
        Parameters 
        ---------- 
        slice_or_indexer : slice or np.ndarray[int64] 
        fill_value : scalar, default lib.no_default 
        only_slice : bool, default False 
            If True, we always return views on existing arrays, never copies. 
            This is used when called from ops.blockwise.operate_blockwise. 
        use_na_proxy : bool, default False 
            Whether to use a np.void ndarray for newly introduced columns. 
 
        Returns 
        ------- 
        new_blocks : list of Block 
        &quot;&quot;&quot;</span>
        <span class="s1">allow_fill = fill_value </span><span class="s0">is not </span><span class="s1">lib.no_default</span>

        <span class="s1">sl_type</span><span class="s0">, </span><span class="s1">slobj</span><span class="s0">, </span><span class="s1">sllen = _preprocess_slice_or_indexer(</span>
            <span class="s1">slice_or_indexer</span><span class="s0">, </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">allow_fill=allow_fill</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.is_single_block:</span>
            <span class="s1">blk = self.blocks[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">sl_type == </span><span class="s2">&quot;slice&quot;</span><span class="s1">:</span>
                <span class="s4"># GH#32959 EABlock would fail since we can't make 0-width</span>
                <span class="s4"># TODO(EA2D): special casing unnecessary with 2D EAs</span>
                <span class="s0">if </span><span class="s1">sllen == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">[]</span>
                <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">sllen))</span>
                <span class="s0">return </span><span class="s1">[blk.getitem_block_columns(slobj</span><span class="s0">, </span><span class="s1">new_mgr_locs=bp)]</span>
            <span class="s0">elif not </span><span class="s1">allow_fill </span><span class="s0">or </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">fill_value </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">fill_value = blk.fill_value</span>

                <span class="s0">if not </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">only_slice:</span>
                    <span class="s4"># GH#33597 slice instead of take, so we get</span>
                    <span class="s4">#  views instead of copies</span>
                    <span class="s1">blocks = [</span>
                        <span class="s1">blk.getitem_block_columns(</span>
                            <span class="s1">slice(ml</span><span class="s0">, </span><span class="s1">ml + </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">new_mgr_locs=BlockPlacement(i)</span>
                        <span class="s1">)</span>
                        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ml </span><span class="s0">in </span><span class="s1">enumerate(slobj)</span>
                    <span class="s1">]</span>
                    <span class="s4"># We have</span>
                    <span class="s4">#  all(np.shares_memory(nb.values, blk.values) for nb in blocks)</span>
                    <span class="s0">return </span><span class="s1">blocks</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">sllen))</span>
                    <span class="s0">return </span><span class="s1">[</span>
                        <span class="s1">blk.take_nd(</span>
                            <span class="s1">slobj</span><span class="s0">,</span>
                            <span class="s1">axis=</span><span class="s5">0</span><span class="s0">,</span>
                            <span class="s1">new_mgr_locs=bp</span><span class="s0">,</span>
                            <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">]</span>

        <span class="s0">if </span><span class="s1">sl_type == </span><span class="s2">&quot;slice&quot;</span><span class="s1">:</span>
            <span class="s1">blknos = self.blknos[slobj]</span>
            <span class="s1">blklocs = self.blklocs[slobj]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">blknos = algos.take_nd(</span>
                <span class="s1">self.blknos</span><span class="s0">, </span><span class="s1">slobj</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">allow_fill=allow_fill</span>
            <span class="s1">)</span>
            <span class="s1">blklocs = algos.take_nd(</span>
                <span class="s1">self.blklocs</span><span class="s0">, </span><span class="s1">slobj</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">allow_fill=allow_fill</span>
            <span class="s1">)</span>

        <span class="s4"># When filling blknos, make sure blknos is updated before appending to</span>
        <span class="s4"># blocks list, that way new blkno is exactly len(blocks).</span>
        <span class="s1">blocks = []</span>
        <span class="s1">group = </span><span class="s0">not </span><span class="s1">only_slice</span>
        <span class="s0">for </span><span class="s1">blkno</span><span class="s0">, </span><span class="s1">mgr_locs </span><span class="s0">in </span><span class="s1">libinternals.get_blkno_placements(blknos</span><span class="s0">, </span><span class="s1">group=group):</span>
            <span class="s0">if </span><span class="s1">blkno == -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># If we've got here, fill_value was not lib.no_default</span>

                <span class="s1">blocks.append(</span>
                    <span class="s1">self._make_na_block(</span>
                        <span class="s1">placement=mgr_locs</span><span class="s0">,</span>
                        <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
                        <span class="s1">use_na_proxy=use_na_proxy</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">blk = self.blocks[blkno]</span>

                <span class="s4"># Otherwise, slicing along items axis is necessary.</span>
                <span class="s0">if not </span><span class="s1">blk._can_consolidate </span><span class="s0">and not </span><span class="s1">blk._validate_ndim:</span>
                    <span class="s4"># i.e. we dont go through here for DatetimeTZBlock</span>
                    <span class="s4"># A non-consolidatable block, it's easy, because there's</span>
                    <span class="s4"># only one item and each mgr loc is a copy of that single</span>
                    <span class="s4"># item.</span>
                    <span class="s0">for </span><span class="s1">mgr_loc </span><span class="s0">in </span><span class="s1">mgr_locs:</span>
                        <span class="s1">newblk = blk.copy(deep=</span><span class="s0">False</span><span class="s1">)</span>
                        <span class="s1">newblk.mgr_locs = BlockPlacement(slice(mgr_loc</span><span class="s0">, </span><span class="s1">mgr_loc + </span><span class="s5">1</span><span class="s1">))</span>
                        <span class="s1">blocks.append(newblk)</span>

                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s4"># GH#32779 to avoid the performance penalty of copying,</span>
                    <span class="s4">#  we may try to only slice</span>
                    <span class="s1">taker = blklocs[mgr_locs.indexer]</span>
                    <span class="s1">max_len = max(len(mgr_locs)</span><span class="s0">, </span><span class="s1">taker.max() + </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">only_slice:</span>
                        <span class="s1">taker = lib.maybe_indices_to_slice(taker</span><span class="s0">, </span><span class="s1">max_len)</span>

                    <span class="s0">if </span><span class="s1">isinstance(taker</span><span class="s0">, </span><span class="s1">slice):</span>
                        <span class="s1">nb = blk.getitem_block_columns(taker</span><span class="s0">, </span><span class="s1">new_mgr_locs=mgr_locs)</span>
                        <span class="s1">blocks.append(nb)</span>
                    <span class="s0">elif </span><span class="s1">only_slice:</span>
                        <span class="s4"># GH#33597 slice instead of take, so we get</span>
                        <span class="s4">#  views instead of copies</span>
                        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ml </span><span class="s0">in </span><span class="s1">zip(taker</span><span class="s0">, </span><span class="s1">mgr_locs):</span>
                            <span class="s1">slc = slice(i</span><span class="s0">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">)</span>
                            <span class="s1">bp = BlockPlacement(ml)</span>
                            <span class="s1">nb = blk.getitem_block_columns(slc</span><span class="s0">, </span><span class="s1">new_mgr_locs=bp)</span>
                            <span class="s4"># We have np.shares_memory(nb.values, blk.values)</span>
                            <span class="s1">blocks.append(nb)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">nb = blk.take_nd(taker</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">new_mgr_locs=mgr_locs)</span>
                        <span class="s1">blocks.append(nb)</span>

        <span class="s0">return </span><span class="s1">blocks</span>

    <span class="s0">def </span><span class="s1">_make_na_block(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">placement: BlockPlacement</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None, </span><span class="s1">use_na_proxy: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; Block:</span>
        <span class="s4"># Note: we only get here with self.ndim == 2</span>

        <span class="s0">if </span><span class="s1">use_na_proxy:</span>
            <span class="s0">assert </span><span class="s1">fill_value </span><span class="s0">is None</span>
            <span class="s1">shape = (len(placement)</span><span class="s0">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">vals = np.empty(shape</span><span class="s0">, </span><span class="s1">dtype=np.void)</span>
            <span class="s1">nb = NumpyBlock(vals</span><span class="s0">, </span><span class="s1">placement</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">nb</span>

        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fill_value = np.nan</span>
        <span class="s1">block_shape = list(self.shape)</span>
        <span class="s1">block_shape[</span><span class="s5">0</span><span class="s1">] = len(placement)</span>

        <span class="s1">dtype</span><span class="s0">, </span><span class="s1">fill_value = infer_dtype_from_scalar(fill_value)</span>
        <span class="s4"># error: Argument &quot;dtype&quot; to &quot;empty&quot; has incompatible type &quot;Union[dtype,</span>
        <span class="s4"># ExtensionDtype]&quot;; expected &quot;Union[dtype, None, type, _SupportsDtype, str,</span>
        <span class="s4"># Tuple[Any, int], Tuple[Any, Union[int, Sequence[int]]], List[Any], _DtypeDict,</span>
        <span class="s4"># Tuple[Any, Any]]&quot;</span>
        <span class="s1">block_values = np.empty(block_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">block_values.fill(fill_value)</span>
        <span class="s0">return </span><span class="s1">new_block_2d(block_values</span><span class="s0">, </span><span class="s1">placement=placement)</span>

    <span class="s0">def </span><span class="s1">take(self: T</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">1</span><span class="s0">, </span><span class="s1">verify: bool = </span><span class="s0">True</span><span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Take items along any axis. 
 
        indexer : np.ndarray or slice 
        axis : int, default 1 
        verify : bool, default True 
            Check that all entries are between 0 and len(self) - 1, inclusive. 
            Pass verify=False if this check has been done by the caller. 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s4"># We have 6 tests that get here with a slice</span>
        <span class="s1">indexer = (</span>
            <span class="s1">np.arange(indexer.start</span><span class="s0">, </span><span class="s1">indexer.stop</span><span class="s0">, </span><span class="s1">indexer.step</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s0">if </span><span class="s1">isinstance(indexer</span><span class="s0">, </span><span class="s1">slice)</span>
            <span class="s0">else </span><span class="s1">np.asanyarray(indexer</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>

        <span class="s1">n = self.shape[axis]</span>
        <span class="s1">indexer = maybe_convert_indices(indexer</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">verify=verify)</span>

        <span class="s1">new_labels = self.axes[axis].take(indexer)</span>
        <span class="s0">return </span><span class="s1">self.reindex_indexer(</span>
            <span class="s1">new_axis=new_labels</span><span class="s0">,</span>
            <span class="s1">indexer=indexer</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
            <span class="s1">allow_dups=</span><span class="s0">True,</span>
            <span class="s1">consolidate=</span><span class="s0">False,</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">BlockManager(libinternals.BlockManager</span><span class="s0">, </span><span class="s1">BaseBlockManager):</span>
    <span class="s3">&quot;&quot;&quot; 
    BaseBlockManager that holds 2D blocks. 
    &quot;&quot;&quot;</span>

    <span class="s1">ndim = </span><span class="s5">2</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Constructors</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">blocks: Sequence[Block]</span><span class="s0">,</span>
        <span class="s1">axes: Sequence[Index]</span><span class="s0">,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s0">True,</span>
    <span class="s1">):</span>

        <span class="s0">if </span><span class="s1">verify_integrity:</span>
            <span class="s4"># Assertion disabled for performance</span>
            <span class="s4"># assert all(isinstance(x, Index) for x in axes)</span>

            <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks:</span>
                <span class="s0">if </span><span class="s1">self.ndim != block.ndim:</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(</span>
                        <span class="s2">f&quot;Number of Block dimensions (</span><span class="s0">{</span><span class="s1">block.ndim</span><span class="s0">}</span><span class="s2">) must equal &quot;</span>
                        <span class="s2">f&quot;number of axes (</span><span class="s0">{</span><span class="s1">self.ndim</span><span class="s0">}</span><span class="s2">)&quot;</span>
                    <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(block</span><span class="s0">, </span><span class="s1">DatetimeTZBlock) </span><span class="s0">and </span><span class="s1">block.values.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4"># TODO(2.0): remove once fastparquet no longer needs this</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s2">&quot;In a future version, the BlockManager constructor &quot;</span>
                        <span class="s2">&quot;will assume that a DatetimeTZBlock with block.ndim==2 &quot;</span>
                        <span class="s2">&quot;has block.values.ndim == 2.&quot;</span><span class="s0">,</span>
                        <span class="s1">DeprecationWarning</span><span class="s0">,</span>
                        <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                    <span class="s1">)</span>

                    <span class="s4"># error: Incompatible types in assignment (expression has type</span>
                    <span class="s4"># &quot;Union[ExtensionArray, ndarray]&quot;, variable has type</span>
                    <span class="s4"># &quot;DatetimeArray&quot;)</span>
                    <span class="s1">block.values = ensure_block_shape(  </span><span class="s4"># type: ignore[assignment]</span>
                        <span class="s1">block.values</span><span class="s0">, </span><span class="s1">self.ndim</span>
                    <span class="s1">)</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">block._cache.clear()</span>
                    <span class="s0">except </span><span class="s1">AttributeError:</span>
                        <span class="s4"># _cache not initialized</span>
                        <span class="s0">pass</span>

            <span class="s1">self._verify_integrity()</span>

    <span class="s0">def </span><span class="s1">_verify_integrity(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">mgr_shape = self.shape</span>
        <span class="s1">tot_items = sum(len(x.mgr_locs) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.blocks)</span>
        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s0">if </span><span class="s1">block.shape[</span><span class="s5">1</span><span class="s1">:] != mgr_shape[</span><span class="s5">1</span><span class="s1">:]:</span>
                <span class="s0">raise </span><span class="s1">construction_error(tot_items</span><span class="s0">, </span><span class="s1">block.shape[</span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">self.axes)</span>
        <span class="s0">if </span><span class="s1">len(self.items) != tot_items:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span>
                <span class="s2">&quot;Number of manager items must equal union of &quot;</span>
                <span class="s2">f&quot;block items</span><span class="s0">\n</span><span class="s2"># manager items: </span><span class="s0">{</span><span class="s1">len(self.items)</span><span class="s0">}</span><span class="s2">, # &quot;</span>
                <span class="s2">f&quot;tot_items: </span><span class="s0">{</span><span class="s1">tot_items</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_blocks(cls</span><span class="s0">, </span><span class="s1">blocks: list[Block]</span><span class="s0">, </span><span class="s1">axes: list[Index]) -&gt; BlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Constructor for BlockManager and SingleBlockManager with same signature. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cls(blocks</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Indexing</span>

    <span class="s0">def </span><span class="s1">fast_xs(self</span><span class="s0">, </span><span class="s1">loc: int) -&gt; ArrayLike:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the array corresponding to `frame.iloc[loc]`. 
 
        Parameters 
        ---------- 
        loc : int 
 
        Returns 
        ------- 
        np.ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(self.blocks) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.blocks[</span><span class="s5">0</span><span class="s1">].iget((slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">loc))</span>

        <span class="s1">dtype = interleaved_dtype([blk.dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks])</span>

        <span class="s1">n = len(self)</span>
        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">cls = dtype.construct_array_type()</span>
            <span class="s1">result = cls._empty((n</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = np.empty(n</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">result = ensure_wrapped_if_datetimelike(result)</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s4"># Such assignment may incorrectly coerce NaT to None</span>
            <span class="s4"># result[blk.mgr_locs] = blk._slice((slice(None), loc))</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">rl </span><span class="s0">in </span><span class="s1">enumerate(blk.mgr_locs):</span>
                <span class="s1">result[rl] = blk.iget((i</span><span class="s0">, </span><span class="s1">loc))</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">iget(self</span><span class="s0">, </span><span class="s1">i: int) -&gt; SingleBlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the data as a SingleBlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s1">block = self.blocks[self.blknos[i]]</span>
        <span class="s1">values = block.iget(self.blklocs[i])</span>

        <span class="s4"># shortcut for select a single-dim from a 2-dim BM</span>
        <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">len(values)))</span>
        <span class="s1">nb = type(block)(values</span><span class="s0">, </span><span class="s1">placement=bp</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">SingleBlockManager(nb</span><span class="s0">, </span><span class="s1">self.axes[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">iget_values(self</span><span class="s0">, </span><span class="s1">i: int) -&gt; ArrayLike:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the data for column i as the values (ndarray or ExtensionArray). 
        &quot;&quot;&quot;</span>
        <span class="s1">block = self.blocks[self.blknos[i]]</span>
        <span class="s1">values = block.iget(self.blklocs[i])</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">column_arrays(self) -&gt; list[np.ndarray]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Used in the JSON C code to access column arrays. 
        This optimizes compared to using `iget_values` by converting each 
        &quot;&quot;&quot;</span>
        <span class="s4"># This is an optimized equivalent to</span>
        <span class="s4">#  result = [self.iget_values(i) for i in range(len(self.items))]</span>
        <span class="s1">result: list[np.ndarray | </span><span class="s0">None</span><span class="s1">] = [</span><span class="s0">None</span><span class="s1">] * len(self.items)</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s1">mgr_locs = blk._mgr_locs</span>
            <span class="s1">values = blk.values_for_json()</span>
            <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># TODO(EA2D): special casing not needed with 2D EAs</span>
                <span class="s1">result[mgr_locs[</span><span class="s5">0</span><span class="s1">]] = values</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">enumerate(mgr_locs):</span>
                    <span class="s1">result[loc] = values[i]</span>

        <span class="s4"># error: Incompatible return value type (got &quot;List[None]&quot;,</span>
        <span class="s4"># expected &quot;List[ndarray[Any, Any]]&quot;)</span>
        <span class="s0">return </span><span class="s1">result  </span><span class="s4"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">iset(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">loc: int | slice | np.ndarray</span><span class="s0">, </span><span class="s1">value: ArrayLike</span><span class="s0">, </span><span class="s1">inplace: bool = </span><span class="s0">False</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set new item in-place. Does not consolidate. Adds new Block if not 
        contained in the current set of items 
        &quot;&quot;&quot;</span>

        <span class="s4"># FIXME: refactor, clearly separate broadcasting &amp; zip-like assignment</span>
        <span class="s4">#        can prob also fix the various if tests for sparse/categorical</span>
        <span class="s0">if </span><span class="s1">self._blklocs </span><span class="s0">is None and </span><span class="s1">self.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self._rebuild_blknos_and_blklocs()</span>

        <span class="s4"># Note: we exclude DTA/TDA here</span>
        <span class="s1">value_is_extension_type = is_1d_only_ea_dtype(value.dtype)</span>
        <span class="s0">if not </span><span class="s1">value_is_extension_type:</span>
            <span class="s0">if </span><span class="s1">value.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">value = value.T</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value = ensure_block_shape(value</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">value.shape[</span><span class="s5">1</span><span class="s1">:] != self.shape[</span><span class="s5">1</span><span class="s1">:]:</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s2">&quot;Shape of new values must be compatible with manager shape&quot;</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">lib.is_integer(loc):</span>
            <span class="s4"># We have 6 tests where loc is _not_ an int.</span>
            <span class="s4"># In this case, get_blkno_placements will yield only one tuple,</span>
            <span class="s4">#  containing (self._blknos[loc], BlockPlacement(slice(0, 1, 1)))</span>

            <span class="s4"># Check if we can use _iset_single fastpath</span>
            <span class="s1">loc = cast(int</span><span class="s0">, </span><span class="s1">loc)</span>
            <span class="s1">blkno = self.blknos[loc]</span>
            <span class="s1">blk = self.blocks[blkno]</span>
            <span class="s0">if </span><span class="s1">len(blk._mgr_locs) == </span><span class="s5">1</span><span class="s1">:  </span><span class="s4"># TODO: fastest way to check this?</span>
                <span class="s0">return </span><span class="s1">self._iset_single(</span>
                    <span class="s1">loc</span><span class="s0">,</span>
                    <span class="s1">value</span><span class="s0">,</span>
                    <span class="s1">inplace=inplace</span><span class="s0">,</span>
                    <span class="s1">blkno=blkno</span><span class="s0">,</span>
                    <span class="s1">blk=blk</span><span class="s0">,</span>
                <span class="s1">)</span>

            <span class="s4"># error: Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;List[Union[int, slice, ndarray]]&quot;, variable has type &quot;Union[int,</span>
            <span class="s4"># slice, ndarray]&quot;)</span>
            <span class="s1">loc = [loc]  </span><span class="s4"># type: ignore[assignment]</span>

        <span class="s4"># categorical/sparse/datetimetz</span>
        <span class="s0">if </span><span class="s1">value_is_extension_type:</span>

            <span class="s0">def </span><span class="s1">value_getitem(placement):</span>
                <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">else</span><span class="s1">:</span>

            <span class="s0">def </span><span class="s1">value_getitem(placement):</span>
                <span class="s0">return </span><span class="s1">value[placement.indexer]</span>

        <span class="s4"># Accessing public blknos ensures the public versions are initialized</span>
        <span class="s1">blknos = self.blknos[loc]</span>
        <span class="s1">blklocs = self.blklocs[loc].copy()</span>

        <span class="s1">unfit_mgr_locs = []</span>
        <span class="s1">unfit_val_locs = []</span>
        <span class="s1">removed_blknos = []</span>
        <span class="s0">for </span><span class="s1">blkno_l</span><span class="s0">, </span><span class="s1">val_locs </span><span class="s0">in </span><span class="s1">libinternals.get_blkno_placements(blknos</span><span class="s0">, </span><span class="s1">group=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">blk = self.blocks[blkno_l]</span>
            <span class="s1">blk_locs = blklocs[val_locs.indexer]</span>
            <span class="s0">if </span><span class="s1">inplace </span><span class="s0">and </span><span class="s1">blk.should_store(value):</span>
                <span class="s1">blk.set_inplace(blk_locs</span><span class="s0">, </span><span class="s1">value_getitem(val_locs))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">unfit_mgr_locs.append(blk.mgr_locs.as_array[blk_locs])</span>
                <span class="s1">unfit_val_locs.append(val_locs)</span>

                <span class="s4"># If all block items are unfit, schedule the block for removal.</span>
                <span class="s0">if </span><span class="s1">len(val_locs) == len(blk.mgr_locs):</span>
                    <span class="s1">removed_blknos.append(blkno_l)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">blk.delete(blk_locs)</span>
                    <span class="s1">self._blklocs[blk.mgr_locs.indexer] = np.arange(len(blk))</span>

        <span class="s0">if </span><span class="s1">len(removed_blknos):</span>
            <span class="s4"># Remove blocks &amp; update blknos accordingly</span>
            <span class="s1">is_deleted = np.zeros(self.nblocks</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
            <span class="s1">is_deleted[removed_blknos] = </span><span class="s0">True</span>

            <span class="s1">new_blknos = np.empty(self.nblocks</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s1">new_blknos.fill(-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">new_blknos[~is_deleted] = np.arange(self.nblocks - len(removed_blknos))</span>
            <span class="s1">self._blknos = new_blknos[self._blknos]</span>
            <span class="s1">self.blocks = tuple(</span>
                <span class="s1">blk </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">enumerate(self.blocks) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">set(removed_blknos)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">unfit_val_locs:</span>
            <span class="s1">unfit_idxr = np.concatenate(unfit_mgr_locs)</span>
            <span class="s1">unfit_count = len(unfit_idxr)</span>

            <span class="s1">new_blocks: list[Block] = []</span>
            <span class="s0">if </span><span class="s1">value_is_extension_type:</span>
                <span class="s4"># This code (ab-)uses the fact that EA blocks contain only</span>
                <span class="s4"># one item.</span>
                <span class="s4"># TODO(EA2D): special casing unnecessary with 2D EAs</span>
                <span class="s1">new_blocks.extend(</span>
                    <span class="s1">new_block_2d(</span>
                        <span class="s1">values=value</span><span class="s0">,</span>
                        <span class="s1">placement=BlockPlacement(slice(mgr_loc</span><span class="s0">, </span><span class="s1">mgr_loc + </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s0">for </span><span class="s1">mgr_loc </span><span class="s0">in </span><span class="s1">unfit_idxr</span>
                <span class="s1">)</span>

                <span class="s1">self._blknos[unfit_idxr] = np.arange(unfit_count) + len(self.blocks)</span>
                <span class="s1">self._blklocs[unfit_idxr] = </span><span class="s5">0</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># unfit_val_locs contains BlockPlacement objects</span>
                <span class="s1">unfit_val_items = unfit_val_locs[</span><span class="s5">0</span><span class="s1">].append(unfit_val_locs[</span><span class="s5">1</span><span class="s1">:])</span>

                <span class="s1">new_blocks.append(</span>
                    <span class="s1">new_block_2d(</span>
                        <span class="s1">values=value_getitem(unfit_val_items)</span><span class="s0">,</span>
                        <span class="s1">placement=BlockPlacement(unfit_idxr)</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

                <span class="s1">self._blknos[unfit_idxr] = len(self.blocks)</span>
                <span class="s1">self._blklocs[unfit_idxr] = np.arange(unfit_count)</span>

            <span class="s1">self.blocks += tuple(new_blocks)</span>

            <span class="s4"># Newly created block's dtype may already be present.</span>
            <span class="s1">self._known_consolidated = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">_iset_single(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">value: ArrayLike</span><span class="s0">, </span><span class="s1">inplace: bool</span><span class="s0">, </span><span class="s1">blkno: int</span><span class="s0">, </span><span class="s1">blk: Block</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Fastpath for iset when we are only setting a single position and 
        the Block currently in that position is itself single-column. 
 
        In this case we can swap out the entire Block and blklocs and blknos 
        are unaffected. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Caller is responsible for verifying value.shape</span>

        <span class="s0">if </span><span class="s1">inplace </span><span class="s0">and </span><span class="s1">blk.should_store(value):</span>
            <span class="s1">iloc = self.blklocs[loc]</span>
            <span class="s1">blk.set_inplace(slice(iloc</span><span class="s0">, </span><span class="s1">iloc + </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">return</span>

        <span class="s1">nb = new_block_2d(value</span><span class="s0">, </span><span class="s1">placement=blk._mgr_locs)</span>
        <span class="s1">old_blocks = self.blocks</span>
        <span class="s1">new_blocks = old_blocks[:blkno] + (nb</span><span class="s0">,</span><span class="s1">) + old_blocks[blkno + </span><span class="s5">1 </span><span class="s1">:]</span>
        <span class="s1">self.blocks = new_blocks</span>
        <span class="s0">return</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">item: Hashable</span><span class="s0">, </span><span class="s1">value: ArrayLike) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Insert item at selected position. 
 
        Parameters 
        ---------- 
        loc : int 
        item : hashable 
        value : np.ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s4"># insert to the axis; this could possibly raise a TypeError</span>
        <span class="s1">new_axis = self.items.insert(loc</span><span class="s0">, </span><span class="s1">item)</span>

        <span class="s0">if </span><span class="s1">value.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">value = value.T</span>
            <span class="s0">if </span><span class="s1">len(value) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;Expected a 1D array, got an array with shape </span><span class="s0">{</span><span class="s1">value.T.shape</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">value = ensure_block_shape(value</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

        <span class="s1">bp = BlockPlacement(slice(loc</span><span class="s0">, </span><span class="s1">loc + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">block = new_block_2d(values=value</span><span class="s0">, </span><span class="s1">placement=bp)</span>

        <span class="s0">if not </span><span class="s1">len(self.blocks):</span>
            <span class="s4"># Fastpath</span>
            <span class="s1">self._blklocs = np.array([</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s1">self._blknos = np.array([</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._insert_update_mgr_locs(loc)</span>
            <span class="s1">self._insert_update_blklocs_and_blknos(loc)</span>

        <span class="s1">self.axes[</span><span class="s5">0</span><span class="s1">] = new_axis</span>
        <span class="s1">self.blocks += (block</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">self._known_consolidated = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">sum(</span><span class="s0">not </span><span class="s1">block.is_extension </span><span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self.blocks) &gt; </span><span class="s5">100</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;DataFrame is highly fragmented.  This is usually the result &quot;</span>
                <span class="s2">&quot;of calling `frame.insert` many times, which has poor performance.  &quot;</span>
                <span class="s2">&quot;Consider joining all columns at once using pd.concat(axis=1) &quot;</span>
                <span class="s2">&quot;instead. To get a de-fragmented frame, use `newframe = frame.copy()`&quot;</span><span class="s0">,</span>
                <span class="s1">PerformanceWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_insert_update_mgr_locs(self</span><span class="s0">, </span><span class="s1">loc) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        When inserting a new Block at location 'loc', we increment 
        all of the mgr_locs of blocks above that by one. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">blkno</span><span class="s0">, </span><span class="s1">count </span><span class="s0">in </span><span class="s1">_fast_count_smallints(self.blknos[loc:]):</span>
            <span class="s4"># .620 this way, .326 of which is in increment_above</span>
            <span class="s1">blk = self.blocks[blkno]</span>
            <span class="s1">blk._mgr_locs = blk._mgr_locs.increment_above(loc)</span>

    <span class="s0">def </span><span class="s1">_insert_update_blklocs_and_blknos(self</span><span class="s0">, </span><span class="s1">loc) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        When inserting a new Block at location 'loc', we update our 
        _blklocs and _blknos. 
        &quot;&quot;&quot;</span>

        <span class="s4"># Accessing public blklocs ensures the public versions are initialized</span>
        <span class="s0">if </span><span class="s1">loc == self.blklocs.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s4"># np.append is a lot faster, let's use it if we can.</span>
            <span class="s1">self._blklocs = np.append(self._blklocs</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">self._blknos = np.append(self._blknos</span><span class="s0">, </span><span class="s1">len(self.blocks))</span>
        <span class="s0">elif </span><span class="s1">loc == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># np.append is a lot faster, let's use it if we can.</span>
            <span class="s1">self._blklocs = np.append(self._blklocs[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self._blknos = np.append(self._blknos[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">len(self.blocks))[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_blklocs</span><span class="s0">, </span><span class="s1">new_blknos = libinternals.update_blklocs_and_blknos(</span>
                <span class="s1">self.blklocs</span><span class="s0">, </span><span class="s1">self.blknos</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">len(self.blocks)</span>
            <span class="s1">)</span>
            <span class="s1">self._blklocs = new_blklocs</span>
            <span class="s1">self._blknos = new_blknos</span>

    <span class="s0">def </span><span class="s1">idelete(self</span><span class="s0">, </span><span class="s1">indexer) -&gt; BlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Delete selected locations, returning a new BlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_deleted = np.zeros(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">is_deleted[indexer] = </span><span class="s0">True</span>
        <span class="s1">taker = (~is_deleted).nonzero()[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">nbs = self._slice_take_blocks_ax0(taker</span><span class="s0">, </span><span class="s1">only_slice=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">new_columns = self.items[~is_deleted]</span>
        <span class="s1">axes = [new_columns</span><span class="s0">, </span><span class="s1">self.axes[</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s0">return </span><span class="s1">type(self)(tuple(nbs)</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Block-wise Operation</span>

    <span class="s0">def </span><span class="s1">grouped_reduce(self: T</span><span class="s0">, </span><span class="s1">func: Callable</span><span class="s0">, </span><span class="s1">ignore_failures: bool = </span><span class="s0">False</span><span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply grouped reduction function blockwise, returning a new BlockManager. 
 
        Parameters 
        ---------- 
        func : grouped reduction function 
        ignore_failures : bool, default False 
            Whether to drop blocks where func raises TypeError. 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s1">result_blocks: list[Block] = []</span>
        <span class="s1">dropped_any = </span><span class="s0">False</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s0">if </span><span class="s1">blk.is_object:</span>
                <span class="s4"># split on object-dtype blocks bc some columns may raise</span>
                <span class="s4">#  while others do not.</span>
                <span class="s0">for </span><span class="s1">sb </span><span class="s0">in </span><span class="s1">blk._split():</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">applied = sb.apply(func)</span>
                    <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">NotImplementedError):</span>
                        <span class="s0">if not </span><span class="s1">ignore_failures:</span>
                            <span class="s0">raise</span>
                        <span class="s1">dropped_any = </span><span class="s0">True</span>
                        <span class="s0">continue</span>
                    <span class="s1">result_blocks = extend_blocks(applied</span><span class="s0">, </span><span class="s1">result_blocks)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">applied = blk.apply(func)</span>
                <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">NotImplementedError):</span>
                    <span class="s0">if not </span><span class="s1">ignore_failures:</span>
                        <span class="s0">raise</span>
                    <span class="s1">dropped_any = </span><span class="s0">True</span>
                    <span class="s0">continue</span>
                <span class="s1">result_blocks = extend_blocks(applied</span><span class="s0">, </span><span class="s1">result_blocks)</span>

        <span class="s0">if </span><span class="s1">len(result_blocks) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">index = Index([</span><span class="s0">None</span><span class="s1">])  </span><span class="s4"># placeholder</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">index = Index(range(result_blocks[</span><span class="s5">0</span><span class="s1">].values.shape[-</span><span class="s5">1</span><span class="s1">]))</span>

        <span class="s0">if </span><span class="s1">dropped_any:</span>
            <span class="s4"># faster to skip _combine if we haven't dropped any blocks</span>
            <span class="s0">return </span><span class="s1">self._combine(result_blocks</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False, </span><span class="s1">index=index)</span>

        <span class="s0">return </span><span class="s1">type(self).from_blocks(result_blocks</span><span class="s0">, </span><span class="s1">[self.axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index])</span>

    <span class="s0">def </span><span class="s1">reduce(</span>
        <span class="s1">self: T</span><span class="s0">, </span><span class="s1">func: Callable</span><span class="s0">, </span><span class="s1">ignore_failures: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; tuple[T</span><span class="s0">, </span><span class="s1">np.ndarray]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply reduction function blockwise, returning a single-row BlockManager. 
 
        Parameters 
        ---------- 
        func : reduction function 
        ignore_failures : bool, default False 
            Whether to drop blocks where func raises TypeError. 
 
        Returns 
        ------- 
        BlockManager 
        np.ndarray 
            Indexer of mgr_locs that are retained. 
        &quot;&quot;&quot;</span>
        <span class="s4"># If 2D, we assume that we're operating column-wise</span>
        <span class="s0">assert </span><span class="s1">self.ndim == </span><span class="s5">2</span>

        <span class="s1">res_blocks: list[Block] = []</span>
        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s1">nbs = blk.reduce(func</span><span class="s0">, </span><span class="s1">ignore_failures)</span>
            <span class="s1">res_blocks.extend(nbs)</span>

        <span class="s1">index = Index([</span><span class="s0">None</span><span class="s1">])  </span><span class="s4"># placeholder</span>
        <span class="s0">if </span><span class="s1">ignore_failures:</span>
            <span class="s0">if </span><span class="s1">res_blocks:</span>
                <span class="s1">indexer = np.concatenate([blk.mgr_locs.as_array </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">res_blocks])</span>
                <span class="s1">new_mgr = self._combine(res_blocks</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False, </span><span class="s1">index=index)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">indexer = []</span>
                <span class="s1">new_mgr = type(self).from_blocks([]</span><span class="s0">, </span><span class="s1">[self.items[:</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">indexer = np.arange(self.shape[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">new_mgr = type(self).from_blocks(res_blocks</span><span class="s0">, </span><span class="s1">[self.items</span><span class="s0">, </span><span class="s1">index])</span>
        <span class="s0">return </span><span class="s1">new_mgr</span><span class="s0">, </span><span class="s1">indexer</span>

    <span class="s0">def </span><span class="s1">operate_blockwise(self</span><span class="s0">, </span><span class="s1">other: BlockManager</span><span class="s0">, </span><span class="s1">array_op) -&gt; BlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply array_op blockwise with another (aligned) BlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">operate_blockwise(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">array_op)</span>

    <span class="s0">def </span><span class="s1">_equal_values(self: BlockManager</span><span class="s0">, </span><span class="s1">other: BlockManager) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Used in .equals defined in base class. Only check the column values 
        assuming shape and indexes have already been checked. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">blockwise_all(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">array_equals)</span>

    <span class="s0">def </span><span class="s1">quantile(</span>
        <span class="s1">self: T</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">qs: Float64Index</span><span class="s0">,</span>
        <span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">interpolation=</span><span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
    <span class="s1">) -&gt; T:</span>
        <span class="s3">&quot;&quot;&quot; 
        Iterate over blocks applying quantile reduction. 
        This routine is intended for reduction type operations and 
        will do inference on the generated blocks. 
 
        Parameters 
        ---------- 
        axis: reduction axis, default 0 
        consolidate: bool, default True. Join together blocks having same 
            dtype 
        interpolation : type of interpolation, default 'linear' 
        qs : list of the quantiles to be computed 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s4"># Series dispatches to DataFrame for quantile, which allows us to</span>
        <span class="s4">#  simplify some of the code here and in the blocks</span>
        <span class="s0">assert </span><span class="s1">self.ndim &gt;= </span><span class="s5">2</span>
        <span class="s0">assert </span><span class="s1">is_list_like(qs)  </span><span class="s4"># caller is responsible for this</span>
        <span class="s0">assert </span><span class="s1">axis == </span><span class="s5">1  </span><span class="s4"># only ever called this way</span>

        <span class="s1">new_axes = list(self.axes)</span>
        <span class="s1">new_axes[</span><span class="s5">1</span><span class="s1">] = Float64Index(qs)</span>

        <span class="s1">blocks = [</span>
            <span class="s1">blk.quantile(axis=axis</span><span class="s0">, </span><span class="s1">qs=qs</span><span class="s0">, </span><span class="s1">interpolation=interpolation)</span>
            <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks</span>
        <span class="s1">]</span>

        <span class="s0">return </span><span class="s1">type(self)(blocks</span><span class="s0">, </span><span class="s1">new_axes)</span>

    <span class="s4"># ----------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">unstack(self</span><span class="s0">, </span><span class="s1">unstacker</span><span class="s0">, </span><span class="s1">fill_value) -&gt; BlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a BlockManager with all blocks unstacked. 
 
        Parameters 
        ---------- 
        unstacker : reshape._Unstacker 
        fill_value : Any 
            fill_value for newly introduced missing values. 
 
        Returns 
        ------- 
        unstacked : BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s1">new_columns = unstacker.get_new_columns(self.items)</span>
        <span class="s1">new_index = unstacker.new_index</span>

        <span class="s1">allow_fill = </span><span class="s0">not </span><span class="s1">unstacker.mask_all</span>
        <span class="s0">if </span><span class="s1">allow_fill:</span>
            <span class="s4"># calculating the full mask once and passing it to Block._unstack is</span>
            <span class="s4">#  faster than letting calculating it in each repeated call</span>
            <span class="s1">new_mask2D = (~unstacker.mask).reshape(*unstacker.full_shape)</span>
            <span class="s1">needs_masking = new_mask2D.any(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">needs_masking = np.zeros(unstacker.full_shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s1">new_blocks: list[Block] = []</span>
        <span class="s1">columns_mask: list[np.ndarray] = []</span>

        <span class="s0">if </span><span class="s1">len(self.items) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">factor = </span><span class="s5">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fac = len(new_columns) / len(self.items)</span>
            <span class="s0">assert </span><span class="s1">fac == int(fac)</span>
            <span class="s1">factor = int(fac)</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s1">mgr_locs = blk.mgr_locs</span>
            <span class="s1">new_placement = mgr_locs.tile_for_unstack(factor)</span>

            <span class="s1">blocks</span><span class="s0">, </span><span class="s1">mask = blk._unstack(</span>
                <span class="s1">unstacker</span><span class="s0">,</span>
                <span class="s1">fill_value</span><span class="s0">,</span>
                <span class="s1">new_placement=new_placement</span><span class="s0">,</span>
                <span class="s1">needs_masking=needs_masking</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">new_blocks.extend(blocks)</span>
            <span class="s1">columns_mask.extend(mask)</span>

            <span class="s4"># Block._unstack should ensure this holds,</span>
            <span class="s0">assert </span><span class="s1">mask.sum() == sum(len(nb._mgr_locs) </span><span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">blocks)</span>
            <span class="s4"># In turn this ensures that in the BlockManager call below</span>
            <span class="s4">#  we have len(new_columns) == sum(x.shape[0] for x in new_blocks)</span>
            <span class="s4">#  which suffices to allow us to pass verify_inegrity=False</span>

        <span class="s1">new_columns = new_columns[columns_mask]</span>

        <span class="s1">bm = BlockManager(new_blocks</span><span class="s0">, </span><span class="s1">[new_columns</span><span class="s0">, </span><span class="s1">new_index]</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">bm</span>

    <span class="s0">def </span><span class="s1">to_dict(self</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a dict of str(dtype) -&gt; BlockManager 
 
        Parameters 
        ---------- 
        copy : bool, default True 
 
        Returns 
        ------- 
        values : a dict of dtype -&gt; BlockManager 
        &quot;&quot;&quot;</span>

        <span class="s1">bd: dict[str</span><span class="s0">, </span><span class="s1">list[Block]] = {}</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s1">bd.setdefault(str(b.dtype)</span><span class="s0">, </span><span class="s1">[]).append(b)</span>

        <span class="s4"># TODO(EA2D): the combine will be unnecessary with 2D EAs</span>
        <span class="s0">return </span><span class="s1">{dtype: self._combine(blocks</span><span class="s0">, </span><span class="s1">copy=copy) </span><span class="s0">for </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">blocks </span><span class="s0">in </span><span class="s1">bd.items()}</span>

    <span class="s0">def </span><span class="s1">as_array(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dtype: np.dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">na_value=lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert the blockmanager data into an numpy array. 
 
        Parameters 
        ---------- 
        dtype : np.dtype or None, default None 
            Data type of the return array. 
        copy : bool, default False 
            If True then guarantee that a copy is returned. A value of 
            False does not guarantee that the underlying data is not 
            copied. 
        na_value : object, default lib.no_default 
            Value to be used as the missing value sentinel. 
 
        Returns 
        ------- 
        arr : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(self.blocks) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">arr = np.empty(self.shape</span><span class="s0">, </span><span class="s1">dtype=float)</span>
            <span class="s0">return </span><span class="s1">arr.transpose()</span>

        <span class="s4"># We want to copy when na_value is provided to avoid</span>
        <span class="s4"># mutating the original object</span>
        <span class="s1">copy = copy </span><span class="s0">or </span><span class="s1">na_value </span><span class="s0">is not </span><span class="s1">lib.no_default</span>

        <span class="s0">if </span><span class="s1">self.is_single_block:</span>
            <span class="s1">blk = self.blocks[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">blk.is_extension:</span>
                <span class="s4"># Avoid implicit conversion of extension blocks to object</span>

                <span class="s4"># error: Item &quot;ndarray&quot; of &quot;Union[ndarray, ExtensionArray]&quot; has no</span>
                <span class="s4"># attribute &quot;to_numpy&quot;</span>
                <span class="s1">arr = blk.values.to_numpy(  </span><span class="s4"># type: ignore[union-attr]</span>
                    <span class="s1">dtype=dtype</span><span class="s0">,</span>
                    <span class="s1">na_value=na_value</span><span class="s0">,</span>
                <span class="s1">).reshape(blk.shape)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">arr = np.asarray(blk.get_values())</span>
                <span class="s0">if </span><span class="s1">dtype:</span>
                    <span class="s1">arr = arr.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">arr = self._interleave(dtype=dtype</span><span class="s0">, </span><span class="s1">na_value=na_value)</span>
            <span class="s4"># The underlying data was copied within _interleave</span>
            <span class="s1">copy = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">copy:</span>
            <span class="s1">arr = arr.copy()</span>

        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is not </span><span class="s1">lib.no_default:</span>
            <span class="s1">arr[isna(arr)] = na_value</span>

        <span class="s0">return </span><span class="s1">arr.transpose()</span>

    <span class="s0">def </span><span class="s1">_interleave(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dtype: np.dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">na_value=lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return ndarray from blocks with specified item order 
        Items must be contained in the blocks 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">dtype:</span>
            <span class="s4"># Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;Optional[Union[dtype[Any], ExtensionDtype]]&quot;, variable has</span>
            <span class="s4"># type &quot;Optional[dtype[Any]]&quot;)</span>
            <span class="s1">dtype = interleaved_dtype(  </span><span class="s4"># type: ignore[assignment]</span>
                <span class="s1">[blk.dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks]</span>
            <span class="s1">)</span>

        <span class="s4"># TODO: https://github.com/pandas-dev/pandas/issues/22791</span>
        <span class="s4"># Give EAs some input on what happens here. Sparse needs this.</span>
        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">SparseDtype):</span>
            <span class="s1">dtype = dtype.subtype</span>
            <span class="s1">dtype = cast(np.dtype</span><span class="s0">, </span><span class="s1">dtype)</span>
        <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">dtype = np.dtype(</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">is_dtype_equal(dtype</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">dtype = np.dtype(</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span>

        <span class="s1">result = np.empty(self.shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">itemmask = np.zeros(self.shape[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">dtype == np.dtype(</span><span class="s2">&quot;object&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s4"># much more performant than using to_numpy below</span>
            <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
                <span class="s1">rl = blk.mgr_locs</span>
                <span class="s1">arr = blk.get_values(dtype)</span>
                <span class="s1">result[rl.indexer] = arr</span>
                <span class="s1">itemmask[rl.indexer] = </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks:</span>
            <span class="s1">rl = blk.mgr_locs</span>
            <span class="s0">if </span><span class="s1">blk.is_extension:</span>
                <span class="s4"># Avoid implicit conversion of extension blocks to object</span>

                <span class="s4"># error: Item &quot;ndarray&quot; of &quot;Union[ndarray, ExtensionArray]&quot; has no</span>
                <span class="s4"># attribute &quot;to_numpy&quot;</span>
                <span class="s1">arr = blk.values.to_numpy(  </span><span class="s4"># type: ignore[union-attr]</span>
                    <span class="s1">dtype=dtype</span><span class="s0">,</span>
                    <span class="s1">na_value=na_value</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">arr = blk.get_values(dtype)</span>
            <span class="s1">result[rl.indexer] = arr</span>
            <span class="s1">itemmask[rl.indexer] = </span><span class="s5">1</span>

        <span class="s0">if not </span><span class="s1">itemmask.all():</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s2">&quot;Some items were not contained in blocks&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Consolidation</span>

    <span class="s0">def </span><span class="s1">is_consolidated(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return True if more than one block with the same dtype 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self._known_consolidated:</span>
            <span class="s1">self._consolidate_check()</span>
        <span class="s0">return </span><span class="s1">self._is_consolidated</span>

    <span class="s0">def </span><span class="s1">_consolidate_check(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(self.blocks) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># fastpath</span>
            <span class="s1">self._is_consolidated = </span><span class="s0">True</span>
            <span class="s1">self._known_consolidated = </span><span class="s0">True</span>
            <span class="s0">return</span>
        <span class="s1">dtypes = [blk.dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self.blocks </span><span class="s0">if </span><span class="s1">blk._can_consolidate]</span>
        <span class="s1">self._is_consolidated = len(dtypes) == len(set(dtypes))</span>
        <span class="s1">self._known_consolidated = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_consolidate_inplace(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">self.is_consolidated():</span>
            <span class="s1">self.blocks = tuple(_consolidate(self.blocks))</span>
            <span class="s1">self._is_consolidated = </span><span class="s0">True</span>
            <span class="s1">self._known_consolidated = </span><span class="s0">True</span>
            <span class="s1">self._rebuild_blknos_and_blklocs()</span>


<span class="s0">class </span><span class="s1">SingleBlockManager(BaseBlockManager</span><span class="s0">, </span><span class="s1">SingleDataManager):</span>
    <span class="s3">&quot;&quot;&quot;manage a single block with&quot;&quot;&quot;</span>

    <span class="s1">ndim = </span><span class="s5">1</span>
    <span class="s1">_is_consolidated = </span><span class="s0">True</span>
    <span class="s1">_known_consolidated = </span><span class="s0">True</span>
    <span class="s1">__slots__ = ()</span>
    <span class="s1">is_single_block = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">block: Block</span><span class="s0">,</span>
        <span class="s1">axis: Index</span><span class="s0">,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s0">False,</span>
        <span class="s1">fastpath=lib.no_default</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4"># Assertions disabled for performance</span>
        <span class="s4"># assert isinstance(block, Block), type(block)</span>
        <span class="s4"># assert isinstance(axis, Index), type(axis)</span>

        <span class="s0">if </span><span class="s1">fastpath </span><span class="s0">is not </span><span class="s1">lib.no_default:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;The `fastpath` keyword is deprecated and will be removed &quot;</span>
                <span class="s2">&quot;in a future version.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">self.axes = [axis]</span>
        <span class="s1">self.blocks = (block</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_blocks(cls</span><span class="s0">, </span><span class="s1">blocks: list[Block]</span><span class="s0">, </span><span class="s1">axes: list[Index]) -&gt; SingleBlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Constructor for BlockManager and SingleBlockManager with same signature. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len(blocks) == </span><span class="s5">1</span>
        <span class="s0">assert </span><span class="s1">len(axes) == </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">cls(blocks[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_array(cls</span><span class="s0">, </span><span class="s1">array: ArrayLike</span><span class="s0">, </span><span class="s1">index: Index) -&gt; SingleBlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Constructor for if we have an array that is not yet a Block. 
        &quot;&quot;&quot;</span>
        <span class="s1">block = new_block(array</span><span class="s0">, </span><span class="s1">placement=slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">len(index))</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">cls(block</span><span class="s0">, </span><span class="s1">index)</span>

    <span class="s0">def </span><span class="s1">to_2d_mgr(self</span><span class="s0">, </span><span class="s1">columns: Index) -&gt; BlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Manager analogue of Series.to_frame 
        &quot;&quot;&quot;</span>
        <span class="s1">blk = self.blocks[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">arr = ensure_block_shape(blk.values</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">bp = BlockPlacement(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">new_blk = type(blk)(arr</span><span class="s0">, </span><span class="s1">placement=bp</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">axes = [columns</span><span class="s0">, </span><span class="s1">self.axes[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s0">return </span><span class="s1">BlockManager([new_blk]</span><span class="s0">, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">block_values = [b.values </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self.blocks]</span>
        <span class="s1">block_items = [self.items[b.mgr_locs.indexer] </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self.blocks]</span>
        <span class="s1">axes_array = list(self.axes)</span>

        <span class="s1">extra_state = {</span>
            <span class="s2">&quot;0.14.1&quot;</span><span class="s1">: {</span>
                <span class="s2">&quot;axes&quot;</span><span class="s1">: axes_array</span><span class="s0">,</span>
                <span class="s2">&quot;blocks&quot;</span><span class="s1">: [</span>
                    <span class="s1">{</span><span class="s2">&quot;values&quot;</span><span class="s1">: b.values</span><span class="s0">, </span><span class="s2">&quot;mgr_locs&quot;</span><span class="s1">: b.mgr_locs.indexer}</span>
                    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self.blocks</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s4"># First three elements of the state are to maintain forward</span>
        <span class="s4"># compatibility with 0.13.1.</span>
        <span class="s0">return </span><span class="s1">axes_array</span><span class="s0">, </span><span class="s1">block_values</span><span class="s0">, </span><span class="s1">block_items</span><span class="s0">, </span><span class="s1">extra_state</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s0">def </span><span class="s1">unpickle_block(values</span><span class="s0">, </span><span class="s1">mgr_locs</span><span class="s0">, </span><span class="s1">ndim: int) -&gt; Block:</span>
            <span class="s4"># TODO(EA2D): ndim would be unnecessary with 2D EAs</span>
            <span class="s4"># older pickles may store e.g. DatetimeIndex instead of DatetimeArray</span>
            <span class="s1">values = extract_array(values</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">new_block(values</span><span class="s0">, </span><span class="s1">placement=mgr_locs</span><span class="s0">, </span><span class="s1">ndim=ndim)</span>

        <span class="s0">if </span><span class="s1">isinstance(state</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">len(state) &gt;= </span><span class="s5">4 </span><span class="s0">and </span><span class="s2">&quot;0.14.1&quot; </span><span class="s0">in </span><span class="s1">state[</span><span class="s5">3</span><span class="s1">]:</span>
            <span class="s1">state = state[</span><span class="s5">3</span><span class="s1">][</span><span class="s2">&quot;0.14.1&quot;</span><span class="s1">]</span>
            <span class="s1">self.axes = [ensure_index(ax) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">state[</span><span class="s2">&quot;axes&quot;</span><span class="s1">]]</span>
            <span class="s1">ndim = len(self.axes)</span>
            <span class="s1">self.blocks = tuple(</span>
                <span class="s1">unpickle_block(b[</span><span class="s2">&quot;values&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b[</span><span class="s2">&quot;mgr_locs&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=ndim)</span>
                <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">state[</span><span class="s2">&quot;blocks&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;pre-0.14.1 pickles are no longer supported&quot;</span><span class="s1">)</span>

        <span class="s1">self._post_setstate()</span>

    <span class="s0">def </span><span class="s1">_post_setstate(self):</span>
        <span class="s0">pass</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_block(self) -&gt; Block:</span>
        <span class="s0">return </span><span class="s1">self.blocks[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_blknos(self):</span>
        <span class="s3">&quot;&quot;&quot;compat with BlockManager&quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_blklocs(self):</span>
        <span class="s3">&quot;&quot;&quot;compat with BlockManager&quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">getitem_mgr(self</span><span class="s0">, </span><span class="s1">indexer) -&gt; SingleBlockManager:</span>
        <span class="s4"># similar to get_slice, but not restricted to slice indexer</span>
        <span class="s1">blk = self._block</span>
        <span class="s1">array = blk._slice(indexer)</span>
        <span class="s0">if </span><span class="s1">array.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># This will be caught by Series._get_values</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;dimension-expanding indexing not allowed&quot;</span><span class="s1">)</span>

        <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">len(array)))</span>
        <span class="s1">block = type(blk)(array</span><span class="s0">, </span><span class="s1">placement=bp</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">new_idx = self.index[indexer]</span>
        <span class="s0">return </span><span class="s1">type(self)(block</span><span class="s0">, </span><span class="s1">new_idx)</span>

    <span class="s0">def </span><span class="s1">get_slice(self</span><span class="s0">, </span><span class="s1">slobj: slice</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; SingleBlockManager:</span>
        <span class="s4"># Assertion disabled for performance</span>
        <span class="s4"># assert isinstance(slobj, slice), type(slobj)</span>
        <span class="s0">if </span><span class="s1">axis &gt;= self.ndim:</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s2">&quot;Requested axis not found in manager&quot;</span><span class="s1">)</span>

        <span class="s1">blk = self._block</span>
        <span class="s1">array = blk._slice(slobj)</span>
        <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">len(array)))</span>
        <span class="s1">block = type(blk)(array</span><span class="s0">, </span><span class="s1">placement=bp</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">new_index = self.index._getitem_slice(slobj)</span>
        <span class="s0">return </span><span class="s1">type(self)(block</span><span class="s0">, </span><span class="s1">new_index)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">index(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.axes[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; DtypeObj:</span>
        <span class="s0">return </span><span class="s1">self._block.dtype</span>

    <span class="s0">def </span><span class="s1">get_dtypes(self) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">np.array([self._block.dtype])</span>

    <span class="s0">def </span><span class="s1">external_values(self):</span>
        <span class="s3">&quot;&quot;&quot;The array that Series.values returns&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._block.external_values()</span>

    <span class="s0">def </span><span class="s1">internal_values(self):</span>
        <span class="s3">&quot;&quot;&quot;The array that Series._values returns&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._block.values</span>

    <span class="s0">def </span><span class="s1">array_values(self):</span>
        <span class="s3">&quot;&quot;&quot;The array that Series.array returns&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._block.array_values</span>

    <span class="s0">def </span><span class="s1">get_numeric_data(self</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">self._block.is_numeric:</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self.copy()</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">self.make_empty()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_can_hold_na(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self._block._can_hold_na</span>

    <span class="s0">def </span><span class="s1">idelete(self</span><span class="s0">, </span><span class="s1">indexer) -&gt; SingleBlockManager:</span>
        <span class="s3">&quot;&quot;&quot; 
        Delete single location from SingleBlockManager. 
 
        Ensures that self.blocks doesn't become empty. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._block.delete(indexer)</span>
        <span class="s1">self.axes[</span><span class="s5">0</span><span class="s1">] = self.axes[</span><span class="s5">0</span><span class="s1">].delete(indexer)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">fast_xs(self</span><span class="s0">, </span><span class="s1">loc):</span>
        <span class="s3">&quot;&quot;&quot; 
        fast path for getting a cross-section 
        return a view of the data 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Use series._values[loc] instead&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_values(self</span><span class="s0">, </span><span class="s1">values: ArrayLike):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the values of the single block in place. 
 
        Use at your own risk! This does not check if the passed values are 
        valid for the current Block/SingleBlockManager (length, dtype, etc). 
        &quot;&quot;&quot;</span>
        <span class="s1">self.blocks[</span><span class="s5">0</span><span class="s1">].values = values</span>
        <span class="s1">self.blocks[</span><span class="s5">0</span><span class="s1">]._mgr_locs = BlockPlacement(slice(len(values)))</span>

    <span class="s0">def </span><span class="s1">_equal_values(self: T</span><span class="s0">, </span><span class="s1">other: T) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Used in .equals defined in base class. Only check the column values 
        assuming shape and indexes have already been checked. 
        &quot;&quot;&quot;</span>
        <span class="s4"># For SingleBlockManager (i.e.Series)</span>
        <span class="s0">if </span><span class="s1">other.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return False</span>
        <span class="s1">left = self.blocks[</span><span class="s5">0</span><span class="s1">].values</span>
        <span class="s1">right = other.blocks[</span><span class="s5">0</span><span class="s1">].values</span>
        <span class="s0">return </span><span class="s1">array_equals(left</span><span class="s0">, </span><span class="s1">right)</span>


<span class="s4"># --------------------------------------------------------------------</span>
<span class="s4"># Constructor Helpers</span>


<span class="s0">def </span><span class="s1">create_block_manager_from_blocks(</span>
    <span class="s1">blocks: list[Block]</span><span class="s0">,</span>
    <span class="s1">axes: list[Index]</span><span class="s0">,</span>
    <span class="s1">consolidate: bool = </span><span class="s0">True,</span>
    <span class="s1">verify_integrity: bool = </span><span class="s0">True,</span>
<span class="s1">) -&gt; BlockManager:</span>
    <span class="s4"># If verify_integrity=False, then caller is responsible for checking</span>
    <span class="s4">#  all(x.shape[-1] == len(axes[1]) for x in blocks)</span>
    <span class="s4">#  sum(x.shape[0] for x in blocks) == len(axes[0])</span>
    <span class="s4">#  set(x for for blk in blocks for x in blk.mgr_locs) == set(range(len(axes[0])))</span>
    <span class="s4">#  all(blk.ndim == 2 for blk in blocks)</span>
    <span class="s4"># This allows us to safely pass verify_integrity=False</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">mgr = BlockManager(blocks</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">verify_integrity=verify_integrity)</span>

    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">arrays = [blk.values </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks]</span>
        <span class="s1">tot_items = sum(arr.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrays)</span>
        <span class="s0">raise </span><span class="s1">construction_error(tot_items</span><span class="s0">, </span><span class="s1">arrays[</span><span class="s5">0</span><span class="s1">].shape[</span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">err)</span>

    <span class="s0">if </span><span class="s1">consolidate:</span>
        <span class="s1">mgr._consolidate_inplace()</span>
    <span class="s0">return </span><span class="s1">mgr</span>


<span class="s0">def </span><span class="s1">create_block_manager_from_column_arrays(</span>
    <span class="s1">arrays: list[ArrayLike]</span><span class="s0">,</span>
    <span class="s1">axes: list[Index]</span><span class="s0">,</span>
    <span class="s1">consolidate: bool = </span><span class="s0">True,</span>
<span class="s1">) -&gt; BlockManager:</span>
    <span class="s4"># Assertions disabled for performance (caller is responsible for verifying)</span>
    <span class="s4"># assert isinstance(axes, list)</span>
    <span class="s4"># assert all(isinstance(x, Index) for x in axes)</span>
    <span class="s4"># assert all(isinstance(x, (np.ndarray, ExtensionArray)) for x in arrays)</span>
    <span class="s4"># assert all(type(x) is not PandasArray for x in arrays)</span>
    <span class="s4"># assert all(x.ndim == 1 for x in arrays)</span>
    <span class="s4"># assert all(len(x) == len(axes[1]) for x in arrays)</span>
    <span class="s4"># assert len(arrays) == len(axes[0])</span>
    <span class="s4"># These last three are sufficient to allow us to safely pass</span>
    <span class="s4">#  verify_integrity=False below.</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">blocks = _form_blocks(arrays</span><span class="s0">, </span><span class="s1">consolidate)</span>
        <span class="s1">mgr = BlockManager(blocks</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">construction_error(len(arrays)</span><span class="s0">, </span><span class="s1">arrays[</span><span class="s5">0</span><span class="s1">].shape</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">e)</span>
    <span class="s0">if </span><span class="s1">consolidate:</span>
        <span class="s1">mgr._consolidate_inplace()</span>
    <span class="s0">return </span><span class="s1">mgr</span>


<span class="s0">def </span><span class="s1">construction_error(</span>
    <span class="s1">tot_items: int</span><span class="s0">,</span>
    <span class="s1">block_shape: Shape</span><span class="s0">,</span>
    <span class="s1">axes: list[Index]</span><span class="s0">,</span>
    <span class="s1">e: ValueError | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;raise a helpful message about our construction&quot;&quot;&quot;</span>
    <span class="s1">passed = tuple(map(int</span><span class="s0">, </span><span class="s1">[tot_items] + list(block_shape)))</span>
    <span class="s4"># Correcting the user facing error message during dataframe construction</span>
    <span class="s0">if </span><span class="s1">len(passed) &lt;= </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">passed = passed[::-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">implied = tuple(len(ax) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes)</span>
    <span class="s4"># Correcting the user facing error message during dataframe construction</span>
    <span class="s0">if </span><span class="s1">len(implied) &lt;= </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">implied = implied[::-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s4"># We return the exception object instead of raising it so that we</span>
    <span class="s4">#  can raise it in the caller; mypy plays better with that</span>
    <span class="s0">if </span><span class="s1">passed == implied </span><span class="s0">and </span><span class="s1">e </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">e</span>
    <span class="s0">if </span><span class="s1">block_shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">ValueError(</span><span class="s2">&quot;Empty data passed with indices specified.&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">ValueError(</span><span class="s2">f&quot;Shape of passed values is </span><span class="s0">{</span><span class="s1">passed</span><span class="s0">}</span><span class="s2">, indices imply </span><span class="s0">{</span><span class="s1">implied</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>


<span class="s4"># -----------------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">_grouping_func(tup: tuple[int</span><span class="s0">, </span><span class="s1">ArrayLike]) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">bool</span><span class="s0">, </span><span class="s1">DtypeObj]:</span>
    <span class="s4"># compat for numpy&lt;1.21, in which comparing a np.dtype with an ExtensionDtype</span>
    <span class="s4"># raises instead of returning False. Once earlier numpy versions are dropped,</span>
    <span class="s4"># this can be simplified to `return tup[1].dtype`</span>
    <span class="s1">dtype = tup[</span><span class="s5">1</span><span class="s1">].dtype</span>

    <span class="s0">if </span><span class="s1">is_1d_only_ea_dtype(dtype):</span>
        <span class="s4"># We know these won't be consolidated, so don't need to group these.</span>
        <span class="s4"># This avoids expensive comparisons of CategoricalDtype objects</span>
        <span class="s1">sep = id(dtype)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">sep = </span><span class="s5">0</span>

    <span class="s0">return </span><span class="s1">sep</span><span class="s0">, </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">np.dtype)</span><span class="s0">, </span><span class="s1">dtype</span>


<span class="s0">def </span><span class="s1">_form_blocks(arrays: list[ArrayLike]</span><span class="s0">, </span><span class="s1">consolidate: bool) -&gt; list[Block]:</span>
    <span class="s1">tuples = list(enumerate(arrays))</span>

    <span class="s0">if not </span><span class="s1">consolidate:</span>
        <span class="s1">nbs = _tuples_to_blocks_no_consolidate(tuples)</span>
        <span class="s0">return </span><span class="s1">nbs</span>

    <span class="s4"># group by dtype</span>
    <span class="s1">grouper = itertools.groupby(tuples</span><span class="s0">, </span><span class="s1">_grouping_func)</span>

    <span class="s1">nbs = []</span>
    <span class="s0">for </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">dtype)</span><span class="s0">, </span><span class="s1">tup_block </span><span class="s0">in </span><span class="s1">grouper:</span>
        <span class="s1">block_type = get_block_type(dtype)</span>

        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s1">is_dtlike = dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s2">&quot;M&quot;</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">issubclass(dtype.type</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes)):</span>
                <span class="s1">dtype = np.dtype(object)</span>

            <span class="s1">values</span><span class="s0">, </span><span class="s1">placement = _stack_arrays(list(tup_block)</span><span class="s0">, </span><span class="s1">dtype)</span>
            <span class="s0">if </span><span class="s1">is_dtlike:</span>
                <span class="s1">values = ensure_wrapped_if_datetimelike(values)</span>
            <span class="s1">blk = block_type(values</span><span class="s0">, </span><span class="s1">placement=BlockPlacement(placement)</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">nbs.append(blk)</span>

        <span class="s0">elif </span><span class="s1">is_1d_only_ea_dtype(dtype):</span>
            <span class="s1">dtype_blocks = [</span>
                <span class="s1">block_type(x[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">placement=BlockPlacement(x[</span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup_block</span>
            <span class="s1">]</span>
            <span class="s1">nbs.extend(dtype_blocks)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dtype_blocks = [</span>
                <span class="s1">block_type(</span>
                    <span class="s1">ensure_block_shape(x[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">placement=BlockPlacement(x[</span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup_block</span>
            <span class="s1">]</span>
            <span class="s1">nbs.extend(dtype_blocks)</span>
    <span class="s0">return </span><span class="s1">nbs</span>


<span class="s0">def </span><span class="s1">_tuples_to_blocks_no_consolidate(tuples) -&gt; list[Block]:</span>
    <span class="s4"># tuples produced within _form_blocks are of the form (placement, array)</span>
    <span class="s0">return </span><span class="s1">[</span>
        <span class="s1">new_block_2d(ensure_block_shape(x[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">placement=BlockPlacement(x[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tuples</span>
    <span class="s1">]</span>


<span class="s0">def </span><span class="s1">_stack_arrays(tuples</span><span class="s0">, </span><span class="s1">dtype: np.dtype):</span>

    <span class="s1">placement</span><span class="s0">, </span><span class="s1">arrays = zip(*tuples)</span>

    <span class="s1">first = arrays[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">shape = (len(arrays)</span><span class="s0">,</span><span class="s1">) + first.shape</span>

    <span class="s1">stacked = np.empty(shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">enumerate(arrays):</span>
        <span class="s1">stacked[i] = arr</span>

    <span class="s0">return </span><span class="s1">stacked</span><span class="s0">, </span><span class="s1">placement</span>


<span class="s0">def </span><span class="s1">_consolidate(blocks: tuple[Block</span><span class="s0">, </span><span class="s1">...]) -&gt; list[Block]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Merge blocks having same dtype, exclude non-consolidating blocks 
    &quot;&quot;&quot;</span>
    <span class="s4"># sort by _can_consolidate, dtype</span>
    <span class="s1">gkey = </span><span class="s0">lambda </span><span class="s1">x: x._consolidate_key</span>
    <span class="s1">grouper = itertools.groupby(sorted(blocks</span><span class="s0">, </span><span class="s1">key=gkey)</span><span class="s0">, </span><span class="s1">gkey)</span>

    <span class="s1">new_blocks: list[Block] = []</span>
    <span class="s0">for </span><span class="s1">(_can_consolidate</span><span class="s0">, </span><span class="s1">dtype)</span><span class="s0">, </span><span class="s1">group_blocks </span><span class="s0">in </span><span class="s1">grouper:</span>
        <span class="s1">merged_blocks = _merge_blocks(</span>
            <span class="s1">list(group_blocks)</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">can_consolidate=_can_consolidate</span>
        <span class="s1">)</span>
        <span class="s1">new_blocks = extend_blocks(merged_blocks</span><span class="s0">, </span><span class="s1">new_blocks)</span>
    <span class="s0">return </span><span class="s1">new_blocks</span>


<span class="s0">def </span><span class="s1">_merge_blocks(</span>
    <span class="s1">blocks: list[Block]</span><span class="s0">, </span><span class="s1">dtype: DtypeObj</span><span class="s0">, </span><span class="s1">can_consolidate: bool</span>
<span class="s1">) -&gt; list[Block]:</span>

    <span class="s0">if </span><span class="s1">len(blocks) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">blocks</span>

    <span class="s0">if </span><span class="s1">can_consolidate:</span>

        <span class="s4"># TODO: optimization potential in case all mgrs contain slices and</span>
        <span class="s4"># combination of those slices is a slice, too.</span>
        <span class="s1">new_mgr_locs = np.concatenate([b.mgr_locs.as_array </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks])</span>

        <span class="s1">new_values: ArrayLike</span>

        <span class="s0">if </span><span class="s1">isinstance(blocks[</span><span class="s5">0</span><span class="s1">].dtype</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s4"># error: List comprehension has incompatible type List[Union[ndarray,</span>
            <span class="s4"># ExtensionArray]]; expected List[Union[complex, generic,</span>
            <span class="s4"># Sequence[Union[int, float, complex, str, bytes, generic]],</span>
            <span class="s4"># Sequence[Sequence[Any]], SupportsArray]]</span>
            <span class="s1">new_values = np.vstack([b.values </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks])  </span><span class="s4"># type: ignore[misc]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">bvals = [blk.values </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks]</span>
            <span class="s1">bvals2 = cast(Sequence[NDArrayBackedExtensionArray]</span><span class="s0">, </span><span class="s1">bvals)</span>
            <span class="s1">new_values = bvals2[</span><span class="s5">0</span><span class="s1">]._concat_same_type(bvals2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">argsort = np.argsort(new_mgr_locs)</span>
        <span class="s1">new_values = new_values[argsort]</span>
        <span class="s1">new_mgr_locs = new_mgr_locs[argsort]</span>

        <span class="s1">bp = BlockPlacement(new_mgr_locs)</span>
        <span class="s0">return </span><span class="s1">[new_block_2d(new_values</span><span class="s0">, </span><span class="s1">placement=bp)]</span>

    <span class="s4"># can't consolidate --&gt; no merge</span>
    <span class="s0">return </span><span class="s1">blocks</span>


<span class="s0">def </span><span class="s1">_fast_count_smallints(arr: npt.NDArray[np.intp]):</span>
    <span class="s3">&quot;&quot;&quot;Faster version of set(arr) for sequences of small numbers.&quot;&quot;&quot;</span>
    <span class="s1">counts = np.bincount(arr)</span>
    <span class="s1">nz = counts.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s4"># Note: list(zip(...) outperforms list(np.c_[nz, counts[nz]]) here,</span>
    <span class="s4">#  in one benchmark by a factor of 11</span>
    <span class="s0">return </span><span class="s1">zip(nz</span><span class="s0">, </span><span class="s1">counts[nz])</span>


<span class="s0">def </span><span class="s1">_preprocess_slice_or_indexer(</span>
    <span class="s1">slice_or_indexer: slice | np.ndarray</span><span class="s0">, </span><span class="s1">length: int</span><span class="s0">, </span><span class="s1">allow_fill: bool</span>
<span class="s1">):</span>
    <span class="s0">if </span><span class="s1">isinstance(slice_or_indexer</span><span class="s0">, </span><span class="s1">slice):</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s2">&quot;slice&quot;</span><span class="s0">,</span>
            <span class="s1">slice_or_indexer</span><span class="s0">,</span>
            <span class="s1">libinternals.slice_len(slice_or_indexer</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s0">not </span><span class="s1">isinstance(slice_or_indexer</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
            <span class="s0">or </span><span class="s1">slice_or_indexer.dtype.kind != </span><span class="s2">&quot;i&quot;</span>
        <span class="s1">):</span>
            <span class="s1">dtype = getattr(slice_or_indexer</span><span class="s0">, </span><span class="s2">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(type(slice_or_indexer)</span><span class="s0">, </span><span class="s1">dtype)</span>

        <span class="s1">indexer = ensure_platform_int(slice_or_indexer)</span>
        <span class="s0">if not </span><span class="s1">allow_fill:</span>
            <span class="s1">indexer = maybe_convert_indices(indexer</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s0">return </span><span class="s2">&quot;fancy&quot;</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">len(indexer)</span>
</pre>
</body>
</html>