<html>
<head>
<title>khash_python.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #0f9795;}
.s6 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
khash_python.h</font>
</center></td></tr></table>
<pre><span class="s0">#include </span><span class="s1">&lt;string.h&gt;</span>
<span class="s0">#include </span><span class="s1">&lt;Python.h&gt;</span>


<span class="s2">// use numpy's definitions for complex</span>
<span class="s0">#include </span><span class="s1">&lt;numpy/arrayobject.h&gt;</span>
<span class="s0">typedef </span><span class="s1">npy_complex64 khcomplex64_t;</span>
<span class="s0">typedef </span><span class="s1">npy_complex128 khcomplex128_t;</span>



<span class="s2">// khash should report usage to tracemalloc</span>
<span class="s0">#if </span><span class="s1">PY_VERSION_HEX &gt;= </span><span class="s3">0x03060000</span>
<span class="s0">#include </span><span class="s1">&lt;pymem.h&gt;</span>
<span class="s0">#if </span><span class="s1">PY_VERSION_HEX &lt; </span><span class="s3">0x03070000</span>
<span class="s0">#define </span><span class="s1">PyTraceMalloc_Track _PyTraceMalloc_Track</span>
<span class="s0">#define </span><span class="s1">PyTraceMalloc_Untrack _PyTraceMalloc_Untrack</span>
<span class="s0">#endif</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">PyTraceMalloc_Track(...)</span>
<span class="s0">#define </span><span class="s1">PyTraceMalloc_Untrack(...)</span>
<span class="s0">#endif</span>


<span class="s0">static const int </span><span class="s1">KHASH_TRACE_DOMAIN = </span><span class="s3">424242</span><span class="s1">;</span>
<span class="s0">void </span><span class="s1">*traced_malloc(size_t size){</span>
    <span class="s0">void </span><span class="s1">* ptr = malloc(size);</span>
    <span class="s0">if</span><span class="s1">(ptr!=NULL){</span>
        <span class="s1">PyTraceMalloc_Track(KHASH_TRACE_DOMAIN, (uintptr_t)ptr, size);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">ptr;</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">*traced_calloc(size_t num, size_t size){</span>
    <span class="s0">void </span><span class="s1">* ptr = calloc(num, size);</span>
    <span class="s0">if</span><span class="s1">(ptr!=NULL){</span>
        <span class="s1">PyTraceMalloc_Track(KHASH_TRACE_DOMAIN, (uintptr_t)ptr, num*size);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">ptr;</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">*traced_realloc(</span><span class="s0">void</span><span class="s1">* old_ptr, size_t size){</span>
    <span class="s0">void </span><span class="s1">* ptr = realloc(old_ptr, size);</span>
    <span class="s0">if</span><span class="s1">(ptr!=NULL){</span>
        <span class="s0">if</span><span class="s1">(old_ptr != ptr){</span>
            <span class="s1">PyTraceMalloc_Untrack(KHASH_TRACE_DOMAIN, (uintptr_t)old_ptr);</span>
        <span class="s1">}</span>
        <span class="s1">PyTraceMalloc_Track(KHASH_TRACE_DOMAIN, (uintptr_t)ptr, size);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">ptr;</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">traced_free(</span><span class="s0">void</span><span class="s1">* ptr){</span>
    <span class="s0">if</span><span class="s1">(ptr!=NULL){</span>
        <span class="s1">PyTraceMalloc_Untrack(KHASH_TRACE_DOMAIN, (uintptr_t)ptr);</span>
    <span class="s1">}</span>
    <span class="s1">free(ptr);</span>
<span class="s1">}</span>


<span class="s0">#define </span><span class="s1">KHASH_MALLOC traced_malloc</span>
<span class="s0">#define </span><span class="s1">KHASH_REALLOC traced_realloc</span>
<span class="s0">#define </span><span class="s1">KHASH_CALLOC traced_calloc</span>
<span class="s0">#define </span><span class="s1">KHASH_FREE traced_free</span>
<span class="s0">#include </span><span class="s4">&quot;khash.h&quot;</span>

<span class="s2">// Previously we were using the built in cpython hash function for doubles</span>
<span class="s2">// python 2.7 https://github.com/python/cpython/blob/2.7/Objects/object.c#L1021</span>
<span class="s2">// python 3.5 https://github.com/python/cpython/blob/3.5/Python/pyhash.c#L85</span>

<span class="s2">// The python 3 hash function has the invariant hash(x) == hash(int(x)) == hash(decimal(x))</span>
<span class="s2">// and the size of hash may be different by platform / version (long in py2, Py_ssize_t in py3).</span>
<span class="s2">// We don't need those invariants because types will be cast before hashing, and if Py_ssize_t</span>
<span class="s2">// is 64 bits the truncation causes collision issues.  Given all that, we use our own</span>
<span class="s2">// simple hash, viewing the double bytes as an int64 and using khash's default</span>
<span class="s2">// hash for 64 bit integers.</span>
<span class="s2">// GH 13436 showed that _Py_HashDouble doesn't work well with khash</span>
<span class="s2">// GH 28303 showed, that the simple xoring-version isn't good enough</span>
<span class="s2">// See GH 36729 for evaluation of the currently used murmur2-hash version</span>
<span class="s2">// An interesting alternative to expensive murmur2-hash would be to change</span>
<span class="s2">// the probing strategy and use e.g. the probing strategy from CPython's</span>
<span class="s2">// implementation of dicts, which shines for smaller sizes but is more</span>
<span class="s2">// predisposed to superlinear running times (see GH 36729 for comparison)</span>


<span class="s1">khuint64_t PANDAS_INLINE asuint64(</span><span class="s0">double </span><span class="s1">key) {</span>
    <span class="s1">khuint64_t val;</span>
    <span class="s1">memcpy(&amp;val, &amp;key, </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">));</span>
    <span class="s0">return </span><span class="s1">val;</span>
<span class="s1">}</span>

<span class="s1">khuint32_t PANDAS_INLINE asuint32(</span><span class="s0">float </span><span class="s1">key) {</span>
    <span class="s1">khuint32_t val;</span>
    <span class="s1">memcpy(&amp;val, &amp;key, </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">float</span><span class="s1">));</span>
    <span class="s0">return </span><span class="s1">val;</span>
<span class="s1">}</span>

<span class="s0">#define </span><span class="s1">ZERO_HASH </span><span class="s3">0</span>
<span class="s0">#define </span><span class="s1">NAN_HASH  </span><span class="s3">0</span>

<span class="s1">khuint32_t PANDAS_INLINE kh_float64_hash_func(</span><span class="s0">double </span><span class="s1">val){</span>
    <span class="s2">// 0.0 and -0.0 should have the same hash:</span>
    <span class="s0">if </span><span class="s1">(val == </span><span class="s3">0.0</span><span class="s1">){</span>
        <span class="s0">return </span><span class="s1">ZERO_HASH;</span>
    <span class="s1">}</span>
    <span class="s2">// all nans should have the same hash:</span>
    <span class="s0">if </span><span class="s1">( val!=val ){</span>
        <span class="s0">return </span><span class="s1">NAN_HASH;</span>
    <span class="s1">}</span>
    <span class="s1">khuint64_t as_int = asuint64(val);</span>
    <span class="s0">return </span><span class="s1">murmur2_64to32(as_int);</span>
<span class="s1">}</span>

<span class="s1">khuint32_t PANDAS_INLINE kh_float32_hash_func(</span><span class="s0">float </span><span class="s1">val){</span>
    <span class="s2">// 0.0 and -0.0 should have the same hash:</span>
    <span class="s0">if </span><span class="s1">(val == </span><span class="s3">0</span><span class="s1">.</span><span class="s3">0</span><span class="s1">f){</span>
        <span class="s0">return </span><span class="s1">ZERO_HASH;</span>
    <span class="s1">}</span>
    <span class="s2">// all nans should have the same hash:</span>
    <span class="s0">if </span><span class="s1">( val!=val ){</span>
        <span class="s0">return </span><span class="s1">NAN_HASH;</span>
    <span class="s1">}</span>
    <span class="s1">khuint32_t as_int = asuint32(val);</span>
    <span class="s0">return </span><span class="s1">murmur2_32to32(as_int);</span>
<span class="s1">}</span>

<span class="s0">#define </span><span class="s1">kh_floats_hash_equal(a, b) ((a) == (b) || ((b) != (b) &amp;&amp; (a) != (a)))</span>

<span class="s0">#define </span><span class="s1">KHASH_MAP_INIT_FLOAT64(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khfloat64_t, khval_t, </span><span class="s3">1</span><span class="s1">, kh_float64_hash_func, kh_floats_hash_equal)</span>

<span class="s1">KHASH_MAP_INIT_FLOAT64(float64, size_t)</span>

<span class="s0">#define </span><span class="s1">KHASH_MAP_INIT_FLOAT32(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khfloat32_t, khval_t, </span><span class="s3">1</span><span class="s1">, kh_float32_hash_func, kh_floats_hash_equal)</span>

<span class="s1">KHASH_MAP_INIT_FLOAT32(float32, size_t)</span>

<span class="s1">khint32_t PANDAS_INLINE kh_complex128_hash_func(khcomplex128_t val){</span>
    <span class="s0">return </span><span class="s1">kh_float64_hash_func(val.real)^kh_float64_hash_func(val.imag);</span>
<span class="s1">}</span>
<span class="s1">khint32_t PANDAS_INLINE kh_complex64_hash_func(khcomplex64_t val){</span>
    <span class="s0">return </span><span class="s1">kh_float32_hash_func(val.real)^kh_float32_hash_func(val.imag);</span>
<span class="s1">}</span>

<span class="s0">#define </span><span class="s1">kh_complex_hash_equal(a, b) \</span>
  <span class="s1">(kh_floats_hash_equal(a.real, b.real) &amp;&amp; kh_floats_hash_equal(a.imag, b.imag))</span>


<span class="s0">#define </span><span class="s1">KHASH_MAP_INIT_COMPLEX64(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khcomplex64_t, khval_t, </span><span class="s3">1</span><span class="s1">, kh_complex64_hash_func, kh_complex_hash_equal)</span>

<span class="s1">KHASH_MAP_INIT_COMPLEX64(complex64, size_t)</span>


<span class="s0">#define </span><span class="s1">KHASH_MAP_INIT_COMPLEX128(name, khval_t)								\</span>
	<span class="s1">KHASH_INIT(name, khcomplex128_t, khval_t, </span><span class="s3">1</span><span class="s1">, kh_complex128_hash_func, kh_complex_hash_equal)</span>

<span class="s1">KHASH_MAP_INIT_COMPLEX128(complex128, size_t)</span>


<span class="s0">#define </span><span class="s1">kh_exist_complex64(h, k) (kh_exist(h, k))</span>
<span class="s0">#define </span><span class="s1">kh_exist_complex128(h, k) (kh_exist(h, k))</span>


<span class="s2">// NaN-floats should be in the same equivalency class, see GH 22119</span>
<span class="s0">int </span><span class="s1">PANDAS_INLINE floatobject_cmp(PyFloatObject* a, PyFloatObject* b){</span>
    <span class="s0">return </span><span class="s1">(</span>
             <span class="s1">Py_IS_NAN(PyFloat_AS_DOUBLE(a)) &amp;&amp;</span>
             <span class="s1">Py_IS_NAN(PyFloat_AS_DOUBLE(b))</span>
           <span class="s1">)</span>
           <span class="s1">||</span>
           <span class="s1">( PyFloat_AS_DOUBLE(a) == PyFloat_AS_DOUBLE(b) );</span>
<span class="s1">}</span>


<span class="s2">// NaNs should be in the same equivalency class, see GH 41836</span>
<span class="s2">// PyObject_RichCompareBool for complexobjects has a different behavior</span>
<span class="s2">// needs to be replaced</span>
<span class="s0">int </span><span class="s1">PANDAS_INLINE complexobject_cmp(PyComplexObject* a, PyComplexObject* b){</span>
    <span class="s0">return </span><span class="s1">(</span>
                <span class="s1">Py_IS_NAN(a</span><span class="s5">-&gt;</span><span class="s1">cval.real) &amp;&amp;</span>
                <span class="s1">Py_IS_NAN(b</span><span class="s5">-&gt;</span><span class="s1">cval.real) &amp;&amp;</span>
                <span class="s1">Py_IS_NAN(a</span><span class="s5">-&gt;</span><span class="s1">cval.imag) &amp;&amp;</span>
                <span class="s1">Py_IS_NAN(b</span><span class="s5">-&gt;</span><span class="s1">cval.imag)</span>
           <span class="s1">)</span>
           <span class="s1">||</span>
           <span class="s1">(</span>
                <span class="s1">Py_IS_NAN(a</span><span class="s5">-&gt;</span><span class="s1">cval.real) &amp;&amp;</span>
                <span class="s1">Py_IS_NAN(b</span><span class="s5">-&gt;</span><span class="s1">cval.real) &amp;&amp;</span>
                <span class="s1">a</span><span class="s5">-&gt;</span><span class="s1">cval.imag == b</span><span class="s5">-&gt;</span><span class="s1">cval.imag</span>
           <span class="s1">)</span>
           <span class="s1">||</span>
           <span class="s1">(</span>
                <span class="s1">a</span><span class="s5">-&gt;</span><span class="s1">cval.real == b</span><span class="s5">-&gt;</span><span class="s1">cval.real &amp;&amp;</span>
                <span class="s1">Py_IS_NAN(a</span><span class="s5">-&gt;</span><span class="s1">cval.imag) &amp;&amp;</span>
                <span class="s1">Py_IS_NAN(b</span><span class="s5">-&gt;</span><span class="s1">cval.imag)</span>
           <span class="s1">)</span>
           <span class="s1">||</span>
           <span class="s1">(</span>
                <span class="s1">a</span><span class="s5">-&gt;</span><span class="s1">cval.real == b</span><span class="s5">-&gt;</span><span class="s1">cval.real &amp;&amp;</span>
                <span class="s1">a</span><span class="s5">-&gt;</span><span class="s1">cval.imag == b</span><span class="s5">-&gt;</span><span class="s1">cval.imag</span>
           <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">int </span><span class="s1">PANDAS_INLINE pyobject_cmp(PyObject* a, PyObject* b);</span>


<span class="s2">// replacing PyObject_RichCompareBool (NaN!=NaN) with pyobject_cmp (NaN==NaN),</span>
<span class="s2">// which treats NaNs as equivalent</span>
<span class="s2">// see GH 41836</span>
<span class="s0">int </span><span class="s1">PANDAS_INLINE tupleobject_cmp(PyTupleObject* a, PyTupleObject* b){</span>
    <span class="s1">Py_ssize_t i;</span>

    <span class="s0">if </span><span class="s1">(Py_SIZE(a) != Py_SIZE(b)) {</span>
        <span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; Py_SIZE(a); ++i) {</span>
        <span class="s0">if </span><span class="s1">(!pyobject_cmp(PyTuple_GET_ITEM(a, i), PyTuple_GET_ITEM(b, i))) {</span>
            <span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s3">1</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s0">int </span><span class="s1">PANDAS_INLINE pyobject_cmp(PyObject* a, PyObject* b) {</span>
    <span class="s0">if </span><span class="s1">(a == b) {</span>
        <span class="s0">return </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(Py_TYPE(a) == Py_TYPE(b)) {</span>
        <span class="s2">// special handling for some built-in types which could have NaNs</span>
        <span class="s2">// as we would like to have them equivalent, but the usual</span>
        <span class="s2">// PyObject_RichCompareBool would return False</span>
        <span class="s0">if </span><span class="s1">(PyFloat_CheckExact(a)) {</span>
            <span class="s0">return </span><span class="s1">floatobject_cmp((PyFloatObject*)a, (PyFloatObject*)b);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(PyComplex_CheckExact(a)) {</span>
            <span class="s0">return </span><span class="s1">complexobject_cmp((PyComplexObject*)a, (PyComplexObject*)b);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(PyTuple_CheckExact(a)) {</span>
            <span class="s0">return </span><span class="s1">tupleobject_cmp((PyTupleObject*)a, (PyTupleObject*)b);</span>
        <span class="s1">}</span>
        <span class="s2">// frozenset isn't yet supported</span>
    <span class="s1">}</span>

	<span class="s0">int </span><span class="s1">result = PyObject_RichCompareBool(a, b, Py_EQ);</span>
	<span class="s0">if </span><span class="s1">(result &lt; </span><span class="s3">0</span><span class="s1">) {</span>
		<span class="s1">PyErr_Clear();</span>
		<span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s1">Py_hash_t PANDAS_INLINE _Pandas_HashDouble(</span><span class="s0">double </span><span class="s1">val) {</span>
    <span class="s2">//Since Python3.10, nan is no longer has hash 0</span>
    <span class="s0">if </span><span class="s1">(Py_IS_NAN(val)) {</span>
        <span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s0">#if </span><span class="s1">PY_VERSION_HEX &lt; </span><span class="s3">0x030A0000</span>
    <span class="s0">return </span><span class="s1">_Py_HashDouble(val);</span>
<span class="s0">#else</span>
    <span class="s0">return </span><span class="s1">_Py_HashDouble(NULL, val);</span>
<span class="s0">#endif</span>
<span class="s1">}</span>


<span class="s1">Py_hash_t PANDAS_INLINE floatobject_hash(PyFloatObject* key) {</span>
    <span class="s0">return </span><span class="s1">_Pandas_HashDouble(PyFloat_AS_DOUBLE(key));</span>
<span class="s1">}</span>


<span class="s0">#define </span><span class="s1">_PandasHASH_IMAG </span><span class="s3">1000003</span><span class="s1">UL</span>

<span class="s2">// replaces _Py_HashDouble with _Pandas_HashDouble</span>
<span class="s1">Py_hash_t PANDAS_INLINE complexobject_hash(PyComplexObject* key) {</span>
    <span class="s1">Py_uhash_t realhash = (Py_uhash_t)_Pandas_HashDouble(key</span><span class="s5">-&gt;</span><span class="s1">cval.real);</span>
    <span class="s1">Py_uhash_t imaghash = (Py_uhash_t)_Pandas_HashDouble(key</span><span class="s5">-&gt;</span><span class="s1">cval.imag);</span>
    <span class="s0">if </span><span class="s1">(realhash == (Py_uhash_t)-</span><span class="s3">1 </span><span class="s1">|| imaghash == (Py_uhash_t)-</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">Py_uhash_t combined = realhash + _PandasHASH_IMAG * imaghash;</span>
    <span class="s0">if </span><span class="s1">(combined == (Py_uhash_t)-</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">-</span><span class="s3">2</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">(Py_hash_t)combined;</span>
<span class="s1">}</span>


<span class="s1">khuint32_t PANDAS_INLINE kh_python_hash_func(PyObject* key);</span>

<span class="s2">//we could use any hashing algorithm, this is the original CPython's for tuples</span>

<span class="s0">#if </span><span class="s1">SIZEOF_PY_UHASH_T &gt; </span><span class="s3">4</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXPRIME_1 ((Py_uhash_t)</span><span class="s3">11400714785074694791</span><span class="s1">ULL)</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXPRIME_2 ((Py_uhash_t)</span><span class="s3">14029467366897019727</span><span class="s1">ULL)</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXPRIME_5 ((Py_uhash_t)</span><span class="s3">2870177450012600261</span><span class="s1">ULL)</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXROTATE(x) ((x &lt;&lt; </span><span class="s3">31</span><span class="s1">) | (x &gt;&gt; </span><span class="s3">33</span><span class="s1">))  </span><span class="s2">/* Rotate left 31 bits */</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXPRIME_1 ((Py_uhash_t)</span><span class="s3">2654435761</span><span class="s1">UL)</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXPRIME_2 ((Py_uhash_t)</span><span class="s3">2246822519</span><span class="s1">UL)</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXPRIME_5 ((Py_uhash_t)</span><span class="s3">374761393</span><span class="s1">UL)</span>
<span class="s0">#define </span><span class="s1">_PandasHASH_XXROTATE(x) ((x &lt;&lt; </span><span class="s3">13</span><span class="s1">) | (x &gt;&gt; </span><span class="s3">19</span><span class="s1">))  </span><span class="s2">/* Rotate left 13 bits */</span>
<span class="s0">#endif</span>

<span class="s1">Py_hash_t PANDAS_INLINE tupleobject_hash(PyTupleObject* key) {</span>
    <span class="s1">Py_ssize_t i, len = Py_SIZE(key);</span>
    <span class="s1">PyObject **item = key</span><span class="s5">-&gt;</span><span class="s1">ob_item;</span>

    <span class="s1">Py_uhash_t acc = _PandasHASH_XXPRIME_5;</span>
    <span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; len; i++) {</span>
        <span class="s1">Py_uhash_t lane = kh_python_hash_func(item[i]);</span>
        <span class="s0">if </span><span class="s1">(lane == (Py_uhash_t)-</span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">acc += lane * _PandasHASH_XXPRIME_2;</span>
        <span class="s1">acc = _PandasHASH_XXROTATE(acc);</span>
        <span class="s1">acc *= _PandasHASH_XXPRIME_1;</span>
    <span class="s1">}</span>

    <span class="s2">/* Add input length, mangled to keep the historical value of hash(()). */</span>
    <span class="s1">acc += len ^ (_PandasHASH_XXPRIME_5 ^ </span><span class="s3">3527539</span><span class="s1">UL);</span>

    <span class="s0">if </span><span class="s1">(acc == (Py_uhash_t)-</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s3">1546275796</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">acc;</span>
<span class="s1">}</span>


<span class="s1">khuint32_t PANDAS_INLINE kh_python_hash_func(PyObject* key) {</span>
    <span class="s1">Py_hash_t hash;</span>
    <span class="s2">// For PyObject_Hash holds:</span>
    <span class="s2">//    hash(0.0) == 0 == hash(-0.0)</span>
    <span class="s2">//    yet for different nan-objects different hash-values</span>
    <span class="s2">//    are possible</span>
    <span class="s0">if </span><span class="s1">(PyFloat_CheckExact(key)) {</span>
        <span class="s2">// we cannot use kh_float64_hash_func</span>
        <span class="s2">// because float(k) == k holds for any int-object k</span>
        <span class="s2">// and kh_float64_hash_func doesn't respect it</span>
        <span class="s1">hash = floatobject_hash((PyFloatObject*)key);</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(PyComplex_CheckExact(key)) {</span>
        <span class="s2">// we cannot use kh_complex128_hash_func</span>
        <span class="s2">// because complex(k,0) == k holds for any int-object k</span>
        <span class="s2">// and kh_complex128_hash_func doesn't respect it</span>
        <span class="s1">hash = complexobject_hash((PyComplexObject*)key);</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(PyTuple_CheckExact(key)) {</span>
        <span class="s1">hash = tupleobject_hash((PyTupleObject*)key);</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">hash = PyObject_Hash(key);</span>
    <span class="s1">}</span>

	<span class="s0">if </span><span class="s1">(hash == -</span><span class="s3">1</span><span class="s1">) {</span>
		<span class="s1">PyErr_Clear();</span>
		<span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
	<span class="s1">}</span>
    <span class="s0">#if </span><span class="s1">SIZEOF_PY_HASH_T == </span><span class="s3">4</span>
        <span class="s2">// it is already 32bit value</span>
        <span class="s0">return </span><span class="s1">hash;</span>
    <span class="s0">#else</span>
        <span class="s2">// for 64bit builds,</span>
        <span class="s2">// we need information of the upper 32bits as well</span>
        <span class="s2">// see GH 37615</span>
        <span class="s1">khuint64_t as_uint = (khuint64_t) hash;</span>
        <span class="s2">// uints avoid undefined behavior of signed ints</span>
        <span class="s0">return </span><span class="s1">(as_uint&gt;&gt;</span><span class="s3">32</span><span class="s1">)^as_uint;</span>
    <span class="s0">#endif</span>
<span class="s1">}</span>


<span class="s0">#define </span><span class="s1">kh_python_hash_equal(a, b) (pyobject_cmp(a, b))</span>


<span class="s2">// Python object</span>

<span class="s0">typedef </span><span class="s1">PyObject* kh_pyobject_t;</span>

<span class="s0">#define </span><span class="s1">KHASH_MAP_INIT_PYOBJECT(name, khval_t)							\</span>
	<span class="s1">KHASH_INIT(name, kh_pyobject_t, khval_t, </span><span class="s3">1</span><span class="s1">,						\</span>
			   <span class="s1">kh_python_hash_func, kh_python_hash_equal)</span>

<span class="s1">KHASH_MAP_INIT_PYOBJECT(pymap, Py_ssize_t)</span>

<span class="s0">#define </span><span class="s1">KHASH_SET_INIT_PYOBJECT(name)                                  \</span>
	<span class="s1">KHASH_INIT(name, kh_pyobject_t, </span><span class="s0">char</span><span class="s1">, </span><span class="s3">0</span><span class="s1">,     \</span>
			   <span class="s1">kh_python_hash_func, kh_python_hash_equal)</span>

<span class="s1">KHASH_SET_INIT_PYOBJECT(pyset)</span>

<span class="s0">#define </span><span class="s1">kh_exist_pymap(h, k) (kh_exist(h, k))</span>
<span class="s0">#define </span><span class="s1">kh_exist_pyset(h, k) (kh_exist(h, k))</span>

<span class="s1">KHASH_MAP_INIT_STR(strbox, kh_pyobject_t)</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
	<span class="s1">kh_str_t *table;</span>
	<span class="s0">int </span><span class="s1">starts[</span><span class="s3">256</span><span class="s1">];</span>
<span class="s1">} kh_str_starts_t;</span>

<span class="s0">typedef </span><span class="s1">kh_str_starts_t* p_kh_str_starts_t;</span>

<span class="s1">p_kh_str_starts_t PANDAS_INLINE kh_init_str_starts(</span><span class="s0">void</span><span class="s1">) {</span>
	<span class="s1">kh_str_starts_t *result = (kh_str_starts_t*)KHASH_CALLOC(</span><span class="s3">1</span><span class="s1">, </span><span class="s0">sizeof</span><span class="s1">(kh_str_starts_t));</span>
	<span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">table = kh_init_str();</span>
	<span class="s0">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">khuint_t PANDAS_INLINE kh_put_str_starts_item(kh_str_starts_t* table, </span><span class="s0">char</span><span class="s1">* key, </span><span class="s0">int</span><span class="s1">* ret) {</span>
    <span class="s1">khuint_t result = kh_put_str(table</span><span class="s5">-&gt;</span><span class="s1">table, key, ret);</span>
	<span class="s0">if </span><span class="s1">(*ret != </span><span class="s3">0</span><span class="s1">) {</span>
		<span class="s1">table</span><span class="s5">-&gt;</span><span class="s1">starts[(</span><span class="s0">unsigned char</span><span class="s1">)key[</span><span class="s3">0</span><span class="s1">]] = </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s1">}</span>
    <span class="s0">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">khuint_t PANDAS_INLINE kh_get_str_starts_item(</span><span class="s0">const </span><span class="s1">kh_str_starts_t* table, </span><span class="s0">const char</span><span class="s1">* key) {</span>
    <span class="s0">unsigned char </span><span class="s1">ch = *key;</span>
	<span class="s0">if </span><span class="s1">(table</span><span class="s5">-&gt;</span><span class="s1">starts[ch]) {</span>
		<span class="s0">if </span><span class="s1">(ch == </span><span class="s4">'</span><span class="s6">\0</span><span class="s4">' </span><span class="s1">|| kh_get_str(table</span><span class="s5">-&gt;</span><span class="s1">table, key) != table</span><span class="s5">-&gt;</span><span class="s1">table</span><span class="s5">-&gt;</span><span class="s1">n_buckets) </span><span class="s0">return </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s1">}</span>
    <span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">PANDAS_INLINE kh_destroy_str_starts(kh_str_starts_t* table) {</span>
	<span class="s1">kh_destroy_str(table</span><span class="s5">-&gt;</span><span class="s1">table);</span>
	<span class="s1">KHASH_FREE(table);</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">PANDAS_INLINE kh_resize_str_starts(kh_str_starts_t* table, khuint_t val) {</span>
	<span class="s1">kh_resize_str(table</span><span class="s5">-&gt;</span><span class="s1">table, val);</span>
<span class="s1">}</span>

<span class="s2">// utility function: given the number of elements</span>
<span class="s2">// returns number of necessary buckets</span>
<span class="s1">khuint_t PANDAS_INLINE kh_needed_n_buckets(khuint_t n_elements){</span>
    <span class="s1">khuint_t candidate = n_elements;</span>
    <span class="s1">kroundup32(candidate);</span>
    <span class="s1">khuint_t upper_bound = (khuint_t)(candidate * __ac_HASH_UPPER + </span><span class="s3">0.5</span><span class="s1">);</span>
    <span class="s0">return </span><span class="s1">(upper_bound &lt; n_elements) ? </span><span class="s3">2</span><span class="s1">*candidate : candidate;</span>

<span class="s1">}</span>
</pre>
</body>
</html>