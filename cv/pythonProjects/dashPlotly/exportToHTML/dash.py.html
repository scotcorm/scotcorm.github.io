<html>
<head>
<title>dash.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dash.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">importlib</span>
<span class="s0">from </span><span class="s1">importlib.machinery </span><span class="s0">import </span><span class="s1">ModuleSpec</span>
<span class="s0">import </span><span class="s1">pkgutil</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">mimetypes</span>
<span class="s0">import </span><span class="s1">hashlib</span>
<span class="s0">import </span><span class="s1">base64</span>
<span class="s0">from </span><span class="s1">urllib.parse </span><span class="s0">import </span><span class="s1">urlparse</span>

<span class="s0">import </span><span class="s1">flask</span>
<span class="s0">from </span><span class="s1">flask_compress </span><span class="s0">import </span><span class="s1">Compress</span>
<span class="s0">from </span><span class="s1">werkzeug.debug.tbtools </span><span class="s0">import </span><span class="s1">get_current_traceback</span>
<span class="s0">from </span><span class="s1">pkg_resources </span><span class="s0">import </span><span class="s1">get_distribution</span><span class="s0">, </span><span class="s1">parse_version</span>
<span class="s0">from </span><span class="s1">dash </span><span class="s0">import </span><span class="s1">dcc</span>
<span class="s0">from </span><span class="s1">dash </span><span class="s0">import </span><span class="s1">html</span>
<span class="s0">from </span><span class="s1">dash </span><span class="s0">import </span><span class="s1">dash_table</span>

<span class="s0">from </span><span class="s1">.fingerprint </span><span class="s0">import </span><span class="s1">build_fingerprint</span><span class="s0">, </span><span class="s1">check_fingerprint</span>
<span class="s0">from </span><span class="s1">.resources </span><span class="s0">import </span><span class="s1">Scripts</span><span class="s0">, </span><span class="s1">Css</span>
<span class="s0">from </span><span class="s1">.dependencies </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">handle_grouped_callback_args</span><span class="s0">,</span>
    <span class="s1">Output</span><span class="s0">,</span>
    <span class="s1">State</span><span class="s0">,</span>
    <span class="s1">Input</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.development.base_component </span><span class="s0">import </span><span class="s1">ComponentRegistry</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">PreventUpdate</span><span class="s0">,</span>
    <span class="s1">InvalidResourceError</span><span class="s0">,</span>
    <span class="s1">ProxyError</span><span class="s0">,</span>
    <span class="s1">DuplicateCallback</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.version </span><span class="s0">import </span><span class="s1">__version__</span>
<span class="s0">from </span><span class="s1">._configs </span><span class="s0">import </span><span class="s1">get_combined_config</span><span class="s0">, </span><span class="s1">pathname_configs</span>
<span class="s0">from </span><span class="s1">._utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">AttributeDict</span><span class="s0">,</span>
    <span class="s1">format_tag</span><span class="s0">,</span>
    <span class="s1">generate_hash</span><span class="s0">,</span>
    <span class="s1">get_asset_path</span><span class="s0">,</span>
    <span class="s1">get_relative_path</span><span class="s0">,</span>
    <span class="s1">inputs_to_dict</span><span class="s0">,</span>
    <span class="s1">inputs_to_vals</span><span class="s0">,</span>
    <span class="s1">interpolate_str</span><span class="s0">,</span>
    <span class="s1">patch_collections_abc</span><span class="s0">,</span>
    <span class="s1">split_callback_id</span><span class="s0">,</span>
    <span class="s1">strip_relative_path</span><span class="s0">,</span>
    <span class="s1">to_json</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_callback</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_dash_renderer</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_validate</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_watch</span>
<span class="s0">from </span><span class="s1">._grouping </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">flatten_grouping</span><span class="s0">,</span>
    <span class="s1">map_grouping</span><span class="s0">,</span>
    <span class="s1">grouping_len</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">_flask_compress_version = parse_version(get_distribution(</span><span class="s2">&quot;flask-compress&quot;</span><span class="s1">).version)</span>

<span class="s3"># Add explicit mapping for map files</span>
<span class="s1">mimetypes.add_type(</span><span class="s2">&quot;application/json&quot;</span><span class="s0">, </span><span class="s2">&quot;.map&quot;</span><span class="s0">, True</span><span class="s1">)</span>

<span class="s1">_default_index = </span><span class="s2">&quot;&quot;&quot;&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
    &lt;head&gt; 
        {%metas%} 
        &lt;title&gt;{%title%}&lt;/title&gt; 
        {%favicon%} 
        {%css%} 
    &lt;/head&gt; 
    &lt;body&gt; 
        {%app_entry%} 
        &lt;footer&gt; 
            {%config%} 
            {%scripts%} 
            {%renderer%} 
        &lt;/footer&gt; 
    &lt;/body&gt; 
&lt;/html&gt;&quot;&quot;&quot;</span>

<span class="s1">_app_entry = </span><span class="s2">&quot;&quot;&quot; 
&lt;div id=&quot;react-entry-point&quot;&gt; 
    &lt;div class=&quot;_dash-loading&quot;&gt; 
        Loading... 
    &lt;/div&gt; 
&lt;/div&gt; 
&quot;&quot;&quot;</span>

<span class="s1">_re_index_entry = </span><span class="s2">&quot;{%app_entry%}&quot;</span><span class="s0">, </span><span class="s2">&quot;{%app_entry%}&quot;</span>
<span class="s1">_re_index_config = </span><span class="s2">&quot;{%config%}&quot;</span><span class="s0">, </span><span class="s2">&quot;{%config%}&quot;</span>
<span class="s1">_re_index_scripts = </span><span class="s2">&quot;{%scripts%}&quot;</span><span class="s0">, </span><span class="s2">&quot;{%scripts%}&quot;</span>

<span class="s1">_re_index_entry_id = </span><span class="s2">'id=&quot;react-entry-point&quot;'</span><span class="s0">, </span><span class="s2">&quot;#react-entry-point&quot;</span>
<span class="s1">_re_index_config_id = </span><span class="s2">'id=&quot;_dash-config&quot;'</span><span class="s0">, </span><span class="s2">&quot;#_dash-config&quot;</span>
<span class="s1">_re_index_scripts_id = </span><span class="s2">'src=&quot;[^&quot;]*dash[-_]renderer[^&quot;]*&quot;'</span><span class="s0">, </span><span class="s2">&quot;dash-renderer&quot;</span>
<span class="s1">_re_renderer_scripts_id = </span><span class="s2">'id=&quot;_dash-renderer'</span><span class="s0">, </span><span class="s2">&quot;new DashRenderer&quot;</span>


<span class="s0">class </span><span class="s1">_NoUpdate:</span>
    <span class="s3"># pylint: disable=too-few-public-methods</span>
    <span class="s0">pass</span>


<span class="s3"># Singleton signal to not update an output, alternative to PreventUpdate</span>
<span class="s1">no_update = _callback.NoUpdate()  </span><span class="s3"># pylint: disable=protected-access</span>


<span class="s3"># pylint: disable=too-many-instance-attributes</span>
<span class="s3"># pylint: disable=too-many-arguments, too-many-locals</span>
<span class="s0">class </span><span class="s1">Dash:</span>
    <span class="s4">&quot;&quot;&quot;Dash is a framework for building analytical web applications. 
    No JavaScript required. 
 
    If a parameter can be set by an environment variable, that is listed as: 
        env: ``DASH_****`` 
    Values provided here take precedence over environment variables. 
 
    :param name: The name Flask should use for your app. Even if you provide 
        your own ``server``, ``name`` will be used to help find assets. 
        Typically ``__name__`` (the magic global var, not a string) is the 
        best value to use. Default ``'__main__'``, env: ``DASH_APP_NAME`` 
    :type name: string 
 
    :param server: Sets the Flask server for your app. There are three options: 
        ``True`` (default): Dash will create a new server 
        ``False``: The server will be added later via ``app.init_app(server)`` 
            where ``server`` is a ``flask.Flask`` instance. 
        ``flask.Flask``: use this pre-existing Flask server. 
    :type server: boolean or flask.Flask 
 
    :param assets_folder: a path, relative to the current working directory, 
        for extra files to be used in the browser. Default ``'assets'``. 
        All .js and .css files will be loaded immediately unless excluded by 
        ``assets_ignore``, and other files such as images will be served if 
        requested. 
    :type assets_folder: string 
 
    :param assets_url_path: The local urls for assets will be: 
        ``requests_pathname_prefix + assets_url_path + '/' + asset_path`` 
        where ``asset_path`` is the path to a file inside ``assets_folder``. 
        Default ``'assets'``. 
    :type asset_url_path: string 
 
    :param assets_ignore: A regex, as a string to pass to ``re.compile``, for 
        assets to omit from immediate loading. Ignored files will still be 
        served if specifically requested. You cannot use this to prevent access 
        to sensitive files. 
    :type assets_ignore: string 
 
    :param assets_external_path: an absolute URL from which to load assets. 
        Use with ``serve_locally=False``. assets_external_path is joined 
        with assets_url_path to determine the absolute url to the 
        asset folder. Dash can still find js and css to automatically load 
        if you also keep local copies in your assets folder that Dash can index, 
        but external serving can improve performance and reduce load on 
        the Dash server. 
        env: ``DASH_ASSETS_EXTERNAL_PATH`` 
    :type assets_external_path: string 
 
    :param include_assets_files: Default ``True``, set to ``False`` to prevent 
        immediate loading of any assets. Assets will still be served if 
        specifically requested. You cannot use this to prevent access 
        to sensitive files. env: ``DASH_INCLUDE_ASSETS_FILES`` 
    :type include_assets_files: boolean 
 
    :param url_base_pathname: A local URL prefix to use app-wide. 
        Default ``'/'``. Both `requests_pathname_prefix` and 
        `routes_pathname_prefix` default to `url_base_pathname`. 
        env: ``DASH_URL_BASE_PATHNAME`` 
    :type url_base_pathname: string 
 
    :param requests_pathname_prefix: A local URL prefix for file requests. 
        Defaults to `url_base_pathname`, and must end with 
        `routes_pathname_prefix`. env: ``DASH_REQUESTS_PATHNAME_PREFIX`` 
    :type requests_pathname_prefix: string 
 
    :param routes_pathname_prefix: A local URL prefix for JSON requests. 
        Defaults to ``url_base_pathname``, and must start and end 
        with ``'/'``. env: ``DASH_ROUTES_PATHNAME_PREFIX`` 
    :type routes_pathname_prefix: string 
 
    :param serve_locally: If ``True`` (default), assets and dependencies 
        (Dash and Component js and css) will be served from local URLs. 
        If ``False`` we will use CDN links where available. 
    :type serve_locally: boolean 
 
    :param compress: Use gzip to compress files and data served by Flask. 
        Default ``False`` 
    :type compress: boolean 
 
    :param meta_tags: html &lt;meta&gt; tags to be added to the index page. 
        Each dict should have the attributes and values for one tag, eg: 
        ``{'name': 'description', 'content': 'My App'}`` 
    :type meta_tags: list of dicts 
 
    :param index_string: Override the standard Dash index page. 
        Must contain the correct insertion markers to interpolate various 
        content into it depending on the app config and components used. 
        See https://dash.plotly.com/external-resources for details. 
    :type index_string: string 
 
    :param external_scripts: Additional JS files to load with the page. 
        Each entry can be a string (the URL) or a dict with ``src`` (the URL) 
        and optionally other ``&lt;script&gt;`` tag attributes such as ``integrity`` 
        and ``crossorigin``. 
    :type external_scripts: list of strings or dicts 
 
    :param external_stylesheets: Additional CSS files to load with the page. 
        Each entry can be a string (the URL) or a dict with ``href`` (the URL) 
        and optionally other ``&lt;link&gt;`` tag attributes such as ``rel``, 
        ``integrity`` and ``crossorigin``. 
    :type external_stylesheets: list of strings or dicts 
 
    :param suppress_callback_exceptions: Default ``False``: check callbacks to 
        ensure referenced IDs exist and props are valid. Set to ``True`` 
        if your layout is dynamic, to bypass these checks. 
        env: ``DASH_SUPPRESS_CALLBACK_EXCEPTIONS`` 
    :type suppress_callback_exceptions: boolean 
 
    :param prevent_initial_callbacks: Default ``False``: Sets the default value 
        of ``prevent_initial_call`` for all callbacks added to the app. 
        Normally all callbacks are fired when the associated outputs are first 
        added to the page. You can disable this for individual callbacks by 
        setting ``prevent_initial_call`` in their definitions, or set it 
        ``True`` here in which case you must explicitly set it ``False`` for 
        those callbacks you wish to have an initial call. This setting has no 
        effect on triggering callbacks when their inputs change later on. 
 
    :param show_undo_redo: Default ``False``, set to ``True`` to enable undo 
        and redo buttons for stepping through the history of the app state. 
    :type show_undo_redo: boolean 
 
    :param extra_hot_reload_paths: A list of paths to watch for changes, in 
        addition to assets and known Python and JS code, if hot reloading is 
        enabled. 
    :type extra_hot_reload_paths: list of strings 
 
    :param plugins: Extend Dash functionality by passing a list of objects 
        with a ``plug`` method, taking a single argument: this app, which will 
        be called after the Flask server is attached. 
    :type plugins: list of objects 
 
    :param title: Default ``Dash``. Configures the document.title 
    (the text that appears in a browser tab). 
 
    :param update_title: Default ``Updating...``. Configures the document.title 
    (the text that appears in a browser tab) text when a callback is being run. 
    Set to None or '' if you don't want the document.title to change or if you 
    want to control the document.title through a separate component or 
    clientside callback. 
 
    :param long_callback_manager: Long callback manager instance to support the 
    ``@app.long_callback`` decorator. Currently an instance of one of 
    ``DiskcacheLongCallbackManager`` or ``CeleryLongCallbackManager`` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s0">None,</span>
        <span class="s1">server=</span><span class="s0">True,</span>
        <span class="s1">assets_folder=</span><span class="s2">&quot;assets&quot;</span><span class="s0">,</span>
        <span class="s1">assets_url_path=</span><span class="s2">&quot;assets&quot;</span><span class="s0">,</span>
        <span class="s1">assets_ignore=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">assets_external_path=</span><span class="s0">None,</span>
        <span class="s1">eager_loading=</span><span class="s0">False,</span>
        <span class="s1">include_assets_files=</span><span class="s0">True,</span>
        <span class="s1">url_base_pathname=</span><span class="s0">None,</span>
        <span class="s1">requests_pathname_prefix=</span><span class="s0">None,</span>
        <span class="s1">routes_pathname_prefix=</span><span class="s0">None,</span>
        <span class="s1">serve_locally=</span><span class="s0">True,</span>
        <span class="s1">compress=</span><span class="s0">None,</span>
        <span class="s1">meta_tags=</span><span class="s0">None,</span>
        <span class="s1">index_string=_default_index</span><span class="s0">,</span>
        <span class="s1">external_scripts=</span><span class="s0">None,</span>
        <span class="s1">external_stylesheets=</span><span class="s0">None,</span>
        <span class="s1">suppress_callback_exceptions=</span><span class="s0">None,</span>
        <span class="s1">prevent_initial_callbacks=</span><span class="s0">False,</span>
        <span class="s1">show_undo_redo=</span><span class="s0">False,</span>
        <span class="s1">extra_hot_reload_paths=</span><span class="s0">None,</span>
        <span class="s1">plugins=</span><span class="s0">None,</span>
        <span class="s1">title=</span><span class="s2">&quot;Dash&quot;</span><span class="s0">,</span>
        <span class="s1">update_title=</span><span class="s2">&quot;Updating...&quot;</span><span class="s0">,</span>
        <span class="s1">long_callback_manager=</span><span class="s0">None,</span>
        <span class="s1">**obsolete</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">_validate.check_obsolete(obsolete)</span>

        <span class="s3"># We have 3 cases: server is either True (we create the server), False</span>
        <span class="s3"># (defer server creation) or a Flask app instance (we use their server)</span>
        <span class="s0">if </span><span class="s1">isinstance(server</span><span class="s0">, </span><span class="s1">flask.Flask):</span>
            <span class="s1">self.server = server</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">name = getattr(server</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;__main__&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(server</span><span class="s0">, </span><span class="s1">bool):</span>
            <span class="s1">name = name </span><span class="s0">if </span><span class="s1">name </span><span class="s0">else </span><span class="s2">&quot;__main__&quot;</span>
            <span class="s1">self.server = flask.Flask(name) </span><span class="s0">if </span><span class="s1">server </span><span class="s0">else None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;server must be a Flask app or a boolean&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">self.server </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">hasattr(self.server.config</span><span class="s0">, </span><span class="s2">&quot;COMPRESS_ALGORITHM&quot;</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">_flask_compress_version &gt;= parse_version(</span><span class="s2">&quot;1.6.0&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s3"># flask-compress==1.6.0 changed default to ['br', 'gzip']</span>
            <span class="s3"># and non-overridable default compression with Brotli is</span>
            <span class="s3"># causing performance issues</span>
            <span class="s1">self.server.config[</span><span class="s2">&quot;COMPRESS_ALGORITHM&quot;</span><span class="s1">] = [</span><span class="s2">&quot;gzip&quot;</span><span class="s1">]</span>

        <span class="s1">base_prefix</span><span class="s0">, </span><span class="s1">routes_prefix</span><span class="s0">, </span><span class="s1">requests_prefix = pathname_configs(</span>
            <span class="s1">url_base_pathname</span><span class="s0">, </span><span class="s1">routes_pathname_prefix</span><span class="s0">, </span><span class="s1">requests_pathname_prefix</span>
        <span class="s1">)</span>

        <span class="s1">self.config = AttributeDict(</span>
            <span class="s1">name=name</span><span class="s0">,</span>
            <span class="s1">assets_folder=os.path.join(</span>
                <span class="s1">flask.helpers.get_root_path(name)</span><span class="s0">, </span><span class="s1">assets_folder</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">assets_url_path=assets_url_path</span><span class="s0">,</span>
            <span class="s1">assets_ignore=assets_ignore</span><span class="s0">,</span>
            <span class="s1">assets_external_path=get_combined_config(</span>
                <span class="s2">&quot;assets_external_path&quot;</span><span class="s0">, </span><span class="s1">assets_external_path</span><span class="s0">, </span><span class="s2">&quot;&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">eager_loading=eager_loading</span><span class="s0">,</span>
            <span class="s1">include_assets_files=get_combined_config(</span>
                <span class="s2">&quot;include_assets_files&quot;</span><span class="s0">, </span><span class="s1">include_assets_files</span><span class="s0">, True</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">url_base_pathname=base_prefix</span><span class="s0">,</span>
            <span class="s1">routes_pathname_prefix=routes_prefix</span><span class="s0">,</span>
            <span class="s1">requests_pathname_prefix=requests_prefix</span><span class="s0">,</span>
            <span class="s1">serve_locally=serve_locally</span><span class="s0">,</span>
            <span class="s1">compress=get_combined_config(</span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s1">compress</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">meta_tags=meta_tags </span><span class="s0">or </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">external_scripts=external_scripts </span><span class="s0">or </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">external_stylesheets=external_stylesheets </span><span class="s0">or </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">suppress_callback_exceptions=get_combined_config(</span>
                <span class="s2">&quot;suppress_callback_exceptions&quot;</span><span class="s0">, </span><span class="s1">suppress_callback_exceptions</span><span class="s0">, False</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">prevent_initial_callbacks=prevent_initial_callbacks</span><span class="s0">,</span>
            <span class="s1">show_undo_redo=show_undo_redo</span><span class="s0">,</span>
            <span class="s1">extra_hot_reload_paths=extra_hot_reload_paths </span><span class="s0">or </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">title=title</span><span class="s0">,</span>
            <span class="s1">update_title=update_title</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self.config.set_read_only(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;name&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;assets_folder&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;assets_url_path&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;eager_loading&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;serve_locally&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;compress&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;Read-only: can only be set in the Dash constructor&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self.config.finalize(</span>
            <span class="s2">&quot;Invalid config key. Some settings are only available &quot;</span>
            <span class="s2">&quot;via the Dash constructor&quot;</span>
        <span class="s1">)</span>

        <span class="s3"># keep title as a class property for backwards compatibility</span>
        <span class="s1">self.title = title</span>

        <span class="s3"># list of dependencies - this one is used by the back end for dispatching</span>
        <span class="s1">self.callback_map = {}</span>
        <span class="s3"># same deps as a list to catch duplicate outputs, and to send to the front end</span>
        <span class="s1">self._callback_list = []</span>

        <span class="s3"># list of inline scripts</span>
        <span class="s1">self._inline_scripts = []</span>

        <span class="s3"># index_string has special setter so can't go in config</span>
        <span class="s1">self._index_string = </span><span class="s2">&quot;&quot;</span>
        <span class="s1">self.index_string = index_string</span>
        <span class="s1">self._favicon = </span><span class="s0">None</span>

        <span class="s3"># default renderer string</span>
        <span class="s1">self.renderer = </span><span class="s2">&quot;var renderer = new DashRenderer();&quot;</span>

        <span class="s3"># static files from the packages</span>
        <span class="s1">self.css = Css(serve_locally)</span>
        <span class="s1">self.scripts = Scripts(serve_locally</span><span class="s0">, </span><span class="s1">eager_loading)</span>

        <span class="s1">self.registered_paths = collections.defaultdict(set)</span>

        <span class="s3"># urls</span>
        <span class="s1">self.routes = []</span>

        <span class="s1">self._layout = </span><span class="s0">None</span>
        <span class="s1">self._layout_is_function = </span><span class="s0">False</span>
        <span class="s1">self.validation_layout = </span><span class="s0">None</span>
        <span class="s1">self._extra_components = []</span>

        <span class="s1">self._setup_dev_tools()</span>
        <span class="s1">self._hot_reload = AttributeDict(</span>
            <span class="s1">hash=</span><span class="s0">None,</span>
            <span class="s1">hard=</span><span class="s0">False,</span>
            <span class="s1">lock=threading.RLock()</span><span class="s0">,</span>
            <span class="s1">watch_thread=</span><span class="s0">None,</span>
            <span class="s1">changed_assets=[]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self._assets_files = []</span>
        <span class="s1">self._long_callback_count = </span><span class="s5">0</span>
        <span class="s1">self._long_callback_manager = long_callback_manager</span>

        <span class="s1">self.logger = logging.getLogger(name)</span>
        <span class="s1">self.logger.addHandler(logging.StreamHandler(stream=sys.stdout))</span>

        <span class="s0">if </span><span class="s1">isinstance(plugins</span><span class="s0">, </span><span class="s1">patch_collections_abc(</span><span class="s2">&quot;Iterable&quot;</span><span class="s1">)):</span>
            <span class="s0">for </span><span class="s1">plugin </span><span class="s0">in </span><span class="s1">plugins:</span>
                <span class="s1">plugin.plug(self)</span>

        <span class="s0">if </span><span class="s1">self.server </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.init_app()</span>

        <span class="s1">self.logger.setLevel(logging.INFO)</span>

    <span class="s0">def </span><span class="s1">init_app(self</span><span class="s0">, </span><span class="s1">app=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s4">&quot;&quot;&quot;Initialize the parts of Dash that require a flask app.&quot;&quot;&quot;</span>

        <span class="s1">self.config.update(kwargs)</span>
        <span class="s1">self.config.set_read_only(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;url_base_pathname&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;routes_pathname_prefix&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;requests_pathname_prefix&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;Read-only: can only be set in the Dash constructor or during init_app()&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">config = self.config</span>

        <span class="s0">if </span><span class="s1">app </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.server = app</span>

        <span class="s1">assets_blueprint_name = </span><span class="s2">&quot;{}{}&quot;</span><span class="s1">.format(</span>
            <span class="s1">config.routes_pathname_prefix.replace(</span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;dash_assets&quot;</span>
        <span class="s1">)</span>

        <span class="s1">self.server.register_blueprint(</span>
            <span class="s1">flask.Blueprint(</span>
                <span class="s1">assets_blueprint_name</span><span class="s0">,</span>
                <span class="s1">config.name</span><span class="s0">,</span>
                <span class="s1">static_folder=self.config.assets_folder</span><span class="s0">,</span>
                <span class="s1">static_url_path=</span><span class="s2">&quot;{}{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">config.routes_pathname_prefix</span><span class="s0">,</span>
                    <span class="s1">self.config.assets_url_path.lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">config.compress:</span>
            <span class="s3"># gzip</span>
            <span class="s1">Compress(self.server)</span>

        <span class="s1">@self.server.errorhandler(PreventUpdate)</span>
        <span class="s0">def </span><span class="s1">_handle_error(_):</span>
            <span class="s4">&quot;&quot;&quot;Handle a halted callback and return an empty 204 response.&quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s5">204</span>

        <span class="s1">self.server.before_first_request(self._setup_server)</span>

        <span class="s3"># add a handler for components suites errors to return 404</span>
        <span class="s1">self.server.errorhandler(InvalidResourceError)(self._invalid_resources_handler)</span>

        <span class="s1">self._add_url(</span>
            <span class="s2">&quot;_dash-component-suites/&lt;string:package_name&gt;/&lt;path:fingerprinted_path&gt;&quot;</span><span class="s0">,</span>
            <span class="s1">self.serve_component_suites</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;_dash-layout&quot;</span><span class="s0">, </span><span class="s1">self.serve_layout)</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;_dash-dependencies&quot;</span><span class="s0">, </span><span class="s1">self.dependencies)</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;_dash-update-component&quot;</span><span class="s0">, </span><span class="s1">self.dispatch</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;POST&quot;</span><span class="s1">])</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;_reload-hash&quot;</span><span class="s0">, </span><span class="s1">self.serve_reload_hash)</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;_favicon.ico&quot;</span><span class="s0">, </span><span class="s1">self._serve_default_favicon)</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">self.index)</span>

        <span class="s3"># catch-all for front-end routes, used by dcc.Location</span>
        <span class="s1">self._add_url(</span><span class="s2">&quot;&lt;path:path&gt;&quot;</span><span class="s0">, </span><span class="s1">self.index)</span>

    <span class="s0">def </span><span class="s1">_add_url(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">view_func</span><span class="s0">, </span><span class="s1">methods=(</span><span class="s2">&quot;GET&quot;</span><span class="s0">,</span><span class="s1">)):</span>
        <span class="s1">full_name = self.config.routes_pathname_prefix + name</span>

        <span class="s1">self.server.add_url_rule(</span>
            <span class="s1">full_name</span><span class="s0">, </span><span class="s1">view_func=view_func</span><span class="s0">, </span><span class="s1">endpoint=full_name</span><span class="s0">, </span><span class="s1">methods=list(methods)</span>
        <span class="s1">)</span>

        <span class="s3"># record the url in Dash.routes so that it can be accessed later</span>
        <span class="s3"># e.g. for adding authentication with flask_login</span>
        <span class="s1">self.routes.append(full_name)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">layout(self):</span>
        <span class="s0">return </span><span class="s1">self._layout</span>

    <span class="s0">def </span><span class="s1">_layout_value(self):</span>
        <span class="s1">layout = self._layout() </span><span class="s0">if </span><span class="s1">self._layout_is_function </span><span class="s0">else </span><span class="s1">self._layout</span>

        <span class="s3"># Add any extra components</span>
        <span class="s0">if </span><span class="s1">self._extra_components:</span>
            <span class="s1">layout = html.Div(children=[layout] + self._extra_components)</span>

        <span class="s0">return </span><span class="s1">layout</span>

    <span class="s1">@layout.setter</span>
    <span class="s0">def </span><span class="s1">layout(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">_validate.validate_layout_type(value)</span>
        <span class="s1">self._layout_is_function = isinstance(value</span><span class="s0">, </span><span class="s1">patch_collections_abc(</span><span class="s2">&quot;Callable&quot;</span><span class="s1">))</span>
        <span class="s1">self._layout = value</span>

        <span class="s3"># for using flask.has_request_context() to deliver a full layout for</span>
        <span class="s3"># validation inside a layout function - track if a user might be doing this.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">self._layout_is_function</span>
            <span class="s0">and not </span><span class="s1">self.validation_layout</span>
            <span class="s0">and not </span><span class="s1">self.config.suppress_callback_exceptions</span>
        <span class="s1">):</span>

            <span class="s0">def </span><span class="s1">simple_clone(c</span><span class="s0">, </span><span class="s1">children=</span><span class="s0">None</span><span class="s1">):</span>
                <span class="s1">cls = type(c)</span>
                <span class="s3"># in Py3 we can use the __init__ signature to reduce to just</span>
                <span class="s3"># required args and id; in Py2 this doesn't work so we just</span>
                <span class="s3"># empty out children.</span>
                <span class="s1">sig = getattr(cls.__init__</span><span class="s0">, </span><span class="s2">&quot;__signature__&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">props = {</span>
                    <span class="s1">p: getattr(c</span><span class="s0">, </span><span class="s1">p)</span>
                    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">c._prop_names  </span><span class="s3"># pylint: disable=protected-access</span>
                    <span class="s0">if </span><span class="s1">hasattr(c</span><span class="s0">, </span><span class="s1">p)</span>
                    <span class="s0">and </span><span class="s1">(</span>
                        <span class="s1">p == </span><span class="s2">&quot;id&quot; </span><span class="s0">or not </span><span class="s1">sig </span><span class="s0">or </span><span class="s1">sig.parameters[p].default == c.REQUIRED</span>
                    <span class="s1">)</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">props.get(</span><span class="s2">&quot;children&quot;</span><span class="s0">, </span><span class="s1">children):</span>
                    <span class="s1">props[</span><span class="s2">&quot;children&quot;</span><span class="s1">] = children </span><span class="s0">or </span><span class="s1">[]</span>
                <span class="s0">return </span><span class="s1">cls(**props)</span>

            <span class="s1">layout_value = self._layout_value()</span>
            <span class="s1">_validate.validate_layout(value</span><span class="s0">, </span><span class="s1">layout_value)</span>
            <span class="s1">self.validation_layout = simple_clone(</span>
                <span class="s3"># pylint: disable=protected-access</span>
                <span class="s1">layout_value</span><span class="s0">,</span>
                <span class="s1">[simple_clone(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">layout_value._traverse_ids()]</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">index_string(self):</span>
        <span class="s0">return </span><span class="s1">self._index_string</span>

    <span class="s1">@index_string.setter</span>
    <span class="s0">def </span><span class="s1">index_string(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">checks = (_re_index_entry</span><span class="s0">, </span><span class="s1">_re_index_config</span><span class="s0">, </span><span class="s1">_re_index_scripts)</span>
        <span class="s1">_validate.validate_index(</span><span class="s2">&quot;index string&quot;</span><span class="s0">, </span><span class="s1">checks</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s1">self._index_string = value</span>

    <span class="s0">def </span><span class="s1">serve_layout(self):</span>
        <span class="s1">layout = self._layout_value()</span>

        <span class="s3"># TODO - Set browser cache limit - pass hash into frontend</span>
        <span class="s0">return </span><span class="s1">flask.Response(</span>
            <span class="s1">to_json(layout)</span><span class="s0">,</span>
            <span class="s1">mimetype=</span><span class="s2">&quot;application/json&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_config(self):</span>
        <span class="s3"># pieces of config needed by the front end</span>
        <span class="s1">config = {</span>
            <span class="s2">&quot;url_base_pathname&quot;</span><span class="s1">: self.config.url_base_pathname</span><span class="s0">,</span>
            <span class="s2">&quot;requests_pathname_prefix&quot;</span><span class="s1">: self.config.requests_pathname_prefix</span><span class="s0">,</span>
            <span class="s2">&quot;ui&quot;</span><span class="s1">: self._dev_tools.ui</span><span class="s0">,</span>
            <span class="s2">&quot;props_check&quot;</span><span class="s1">: self._dev_tools.props_check</span><span class="s0">,</span>
            <span class="s2">&quot;show_undo_redo&quot;</span><span class="s1">: self.config.show_undo_redo</span><span class="s0">,</span>
            <span class="s2">&quot;suppress_callback_exceptions&quot;</span><span class="s1">: self.config.suppress_callback_exceptions</span><span class="s0">,</span>
            <span class="s2">&quot;update_title&quot;</span><span class="s1">: self.config.update_title</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">self._dev_tools.hot_reload:</span>
            <span class="s1">config[</span><span class="s2">&quot;hot_reload&quot;</span><span class="s1">] = {</span>
                <span class="s3"># convert from seconds to msec as used by js `setInterval`</span>
                <span class="s2">&quot;interval&quot;</span><span class="s1">: int(self._dev_tools.hot_reload_interval * </span><span class="s5">1000</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;max_retry&quot;</span><span class="s1">: self._dev_tools.hot_reload_max_retry</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">self.validation_layout </span><span class="s0">and not </span><span class="s1">self.config.suppress_callback_exceptions:</span>
            <span class="s1">validation_layout = self.validation_layout</span>

            <span class="s3"># Add extra components</span>
            <span class="s0">if </span><span class="s1">self._extra_components:</span>
                <span class="s1">validation_layout = html.Div(</span>
                    <span class="s1">children=[validation_layout] + self._extra_components</span>
                <span class="s1">)</span>

            <span class="s1">config[</span><span class="s2">&quot;validation_layout&quot;</span><span class="s1">] = validation_layout</span>

        <span class="s0">return </span><span class="s1">config</span>

    <span class="s0">def </span><span class="s1">serve_reload_hash(self):</span>
        <span class="s1">_reload = self._hot_reload</span>
        <span class="s0">with </span><span class="s1">_reload.lock:</span>
            <span class="s1">hard = _reload.hard</span>
            <span class="s1">changed = _reload.changed_assets</span>
            <span class="s1">_hash = _reload.hash</span>
            <span class="s1">_reload.hard = </span><span class="s0">False</span>
            <span class="s1">_reload.changed_assets = []</span>

        <span class="s0">return </span><span class="s1">flask.jsonify(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;reloadHash&quot;</span><span class="s1">: _hash</span><span class="s0">,</span>
                <span class="s2">&quot;hard&quot;</span><span class="s1">: hard</span><span class="s0">,</span>
                <span class="s2">&quot;packages&quot;</span><span class="s1">: list(self.registered_paths.keys())</span><span class="s0">,</span>
                <span class="s2">&quot;files&quot;</span><span class="s1">: list(changed)</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_collect_and_register_resources(self</span><span class="s0">, </span><span class="s1">resources):</span>
        <span class="s3"># now needs the app context.</span>
        <span class="s3"># template in the necessary component suite JS bundles</span>
        <span class="s3"># add the version number of the package as a query parameter</span>
        <span class="s3"># for cache busting</span>
        <span class="s0">def </span><span class="s1">_relative_url_path(relative_package_path=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">namespace=</span><span class="s2">&quot;&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">any(</span>
                <span class="s1">relative_package_path.startswith(x + </span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;dcc&quot;</span><span class="s0">, </span><span class="s2">&quot;html&quot;</span><span class="s0">, </span><span class="s2">&quot;dash_table&quot;</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s1">relative_package_path = relative_package_path.replace(</span><span class="s2">&quot;dash.&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">version = importlib.import_module(</span>
                    <span class="s2">&quot;{}.{}&quot;</span><span class="s1">.format(namespace</span><span class="s0">, </span><span class="s1">os.path.split(relative_package_path)[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">).__version__</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">version = importlib.import_module(namespace).__version__</span>

            <span class="s1">module_path = os.path.join(</span>
                <span class="s1">os.path.dirname(sys.modules[namespace].__file__)</span><span class="s0">, </span><span class="s1">relative_package_path</span>
            <span class="s1">)</span>

            <span class="s1">modified = int(os.stat(module_path).st_mtime)</span>

            <span class="s0">return </span><span class="s2">&quot;{}_dash-component-suites/{}/{}&quot;</span><span class="s1">.format(</span>
                <span class="s1">self.config.requests_pathname_prefix</span><span class="s0">,</span>
                <span class="s1">namespace</span><span class="s0">,</span>
                <span class="s1">build_fingerprint(relative_package_path</span><span class="s0">, </span><span class="s1">version</span><span class="s0">, </span><span class="s1">modified)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">srcs = []</span>
        <span class="s0">for </span><span class="s1">resource </span><span class="s0">in </span><span class="s1">resources:</span>
            <span class="s1">is_dynamic_resource = resource.get(</span><span class="s2">&quot;dynamic&quot;</span><span class="s0">, False</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s2">&quot;relative_package_path&quot; </span><span class="s0">in </span><span class="s1">resource:</span>
                <span class="s1">paths = resource[</span><span class="s2">&quot;relative_package_path&quot;</span><span class="s1">]</span>
                <span class="s1">paths = [paths] </span><span class="s0">if </span><span class="s1">isinstance(paths</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">else </span><span class="s1">paths</span>

                <span class="s0">for </span><span class="s1">rel_path </span><span class="s0">in </span><span class="s1">paths:</span>
                    <span class="s0">if </span><span class="s1">any(x </span><span class="s0">in </span><span class="s1">rel_path </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;dcc&quot;</span><span class="s0">, </span><span class="s2">&quot;html&quot;</span><span class="s0">, </span><span class="s2">&quot;dash_table&quot;</span><span class="s1">]):</span>
                        <span class="s1">rel_path = rel_path.replace(</span><span class="s2">&quot;dash.&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>

                    <span class="s1">self.registered_paths[resource[</span><span class="s2">&quot;namespace&quot;</span><span class="s1">]].add(rel_path)</span>

                    <span class="s0">if not </span><span class="s1">is_dynamic_resource:</span>
                        <span class="s1">srcs.append(</span>
                            <span class="s1">_relative_url_path(</span>
                                <span class="s1">relative_package_path=rel_path</span><span class="s0">,</span>
                                <span class="s1">namespace=resource[</span><span class="s2">&quot;namespace&quot;</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
            <span class="s0">elif </span><span class="s2">&quot;external_url&quot; </span><span class="s0">in </span><span class="s1">resource:</span>
                <span class="s0">if not </span><span class="s1">is_dynamic_resource:</span>
                    <span class="s0">if </span><span class="s1">isinstance(resource[</span><span class="s2">&quot;external_url&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str):</span>
                        <span class="s1">srcs.append(resource[</span><span class="s2">&quot;external_url&quot;</span><span class="s1">])</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">srcs += resource[</span><span class="s2">&quot;external_url&quot;</span><span class="s1">]</span>
            <span class="s0">elif </span><span class="s2">&quot;absolute_path&quot; </span><span class="s0">in </span><span class="s1">resource:</span>
                <span class="s0">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Serving files from absolute_path isn't supported yet&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s2">&quot;asset_path&quot; </span><span class="s0">in </span><span class="s1">resource:</span>
                <span class="s1">static_url = self.get_asset_url(resource[</span><span class="s2">&quot;asset_path&quot;</span><span class="s1">])</span>
                <span class="s3"># Add a cache-busting query param</span>
                <span class="s1">static_url += </span><span class="s2">&quot;?m={}&quot;</span><span class="s1">.format(resource[</span><span class="s2">&quot;ts&quot;</span><span class="s1">])</span>
                <span class="s1">srcs.append(static_url)</span>
        <span class="s0">return </span><span class="s1">srcs</span>

    <span class="s0">def </span><span class="s1">_generate_css_dist_html(self):</span>
        <span class="s1">external_links = self.config.external_stylesheets</span>
        <span class="s1">links = self._collect_and_register_resources(self.css.get_all_css())</span>

        <span class="s0">return </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s1">format_tag(</span><span class="s2">&quot;link&quot;</span><span class="s0">, </span><span class="s1">link</span><span class="s0">, </span><span class="s1">opened=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(link</span><span class="s0">, </span><span class="s1">dict)</span>
                <span class="s0">else </span><span class="s2">f'&lt;link rel=&quot;stylesheet&quot; href=&quot;</span><span class="s0">{</span><span class="s1">link</span><span class="s0">}</span><span class="s2">&quot;&gt;'</span>
                <span class="s0">for </span><span class="s1">link </span><span class="s0">in </span><span class="s1">(external_links + links)</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_generate_scripts_html(self):</span>
        <span class="s3"># Dash renderer has dependencies like React which need to be rendered</span>
        <span class="s3"># before every other script. However, the dash renderer bundle</span>
        <span class="s3"># itself needs to be rendered after all of the component's</span>
        <span class="s3"># scripts have rendered.</span>
        <span class="s3"># The rest of the scripts can just be loaded after React but before</span>
        <span class="s3"># dash renderer.</span>
        <span class="s3"># pylint: disable=protected-access</span>

        <span class="s1">mode = </span><span class="s2">&quot;dev&quot; </span><span class="s0">if </span><span class="s1">self._dev_tools[</span><span class="s2">&quot;props_check&quot;</span><span class="s1">] </span><span class="s0">is True else </span><span class="s2">&quot;prod&quot;</span>

        <span class="s1">deps = []</span>
        <span class="s0">for </span><span class="s1">js_dist_dependency </span><span class="s0">in </span><span class="s1">_dash_renderer._js_dist_dependencies:</span>
            <span class="s1">dep = {}</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">js_dist_dependency.items():</span>
                <span class="s1">dep[key] = value[mode] </span><span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">else </span><span class="s1">value</span>

            <span class="s1">deps.append(dep)</span>

        <span class="s1">dev = self._dev_tools.serve_dev_bundles</span>
        <span class="s1">srcs = (</span>
            <span class="s1">self._collect_and_register_resources(</span>
                <span class="s1">self.scripts._resources._filter_resources(deps</span><span class="s0">, </span><span class="s1">dev_bundles=dev)</span>
            <span class="s1">)</span>
            <span class="s1">+ self.config.external_scripts</span>
            <span class="s1">+ self._collect_and_register_resources(</span>
                <span class="s1">self.scripts.get_all_scripts(dev_bundles=dev)</span>
                <span class="s1">+ self.scripts._resources._filter_resources(</span>
                    <span class="s1">_dash_renderer._js_dist</span><span class="s0">, </span><span class="s1">dev_bundles=dev</span>
                <span class="s1">)</span>
                <span class="s1">+ self.scripts._resources._filter_resources(</span>
                    <span class="s1">dcc._js_dist</span><span class="s0">, </span><span class="s1">dev_bundles=dev</span>
                <span class="s1">)</span>
                <span class="s1">+ self.scripts._resources._filter_resources(</span>
                    <span class="s1">html._js_dist</span><span class="s0">, </span><span class="s1">dev_bundles=dev</span>
                <span class="s1">)</span>
                <span class="s1">+ self.scripts._resources._filter_resources(</span>
                    <span class="s1">dash_table._js_dist</span><span class="s0">, </span><span class="s1">dev_bundles=dev</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">self._inline_scripts.extend(_callback.GLOBAL_INLINE_SCRIPTS)</span>
        <span class="s1">_callback.GLOBAL_INLINE_SCRIPTS.clear()</span>

        <span class="s0">return </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s1">format_tag(</span><span class="s2">&quot;script&quot;</span><span class="s0">, </span><span class="s1">src)</span>
                <span class="s0">if </span><span class="s1">isinstance(src</span><span class="s0">, </span><span class="s1">dict)</span>
                <span class="s0">else </span><span class="s2">'&lt;script src=&quot;{}&quot;&gt;&lt;/script&gt;'</span><span class="s1">.format(src)</span>
                <span class="s0">for </span><span class="s1">src </span><span class="s0">in </span><span class="s1">srcs</span>
            <span class="s1">]</span>
            <span class="s1">+ [</span><span class="s2">&quot;&lt;script&gt;{}&lt;/script&gt;&quot;</span><span class="s1">.format(src) </span><span class="s0">for </span><span class="s1">src </span><span class="s0">in </span><span class="s1">self._inline_scripts]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_generate_config_html(self):</span>
        <span class="s0">return </span><span class="s2">'&lt;script id=&quot;_dash-config&quot; type=&quot;application/json&quot;&gt;{}&lt;/script&gt;'</span><span class="s1">.format(</span>
            <span class="s1">to_json(self._config())</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_generate_renderer(self):</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s2">'&lt;script id=&quot;_dash-renderer&quot; type=&quot;application/javascript&quot;&gt;'</span>
            <span class="s2">&quot;{}&quot;</span>
            <span class="s2">&quot;&lt;/script&gt;&quot;</span>
        <span class="s1">).format(self.renderer)</span>

    <span class="s0">def </span><span class="s1">_generate_meta_html(self):</span>
        <span class="s1">meta_tags = self.config.meta_tags</span>
        <span class="s1">has_ie_compat = any(</span>
            <span class="s1">x.get(</span><span class="s2">&quot;http-equiv&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">) == </span><span class="s2">&quot;X-UA-Compatible&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">meta_tags</span>
        <span class="s1">)</span>
        <span class="s1">has_charset = any(</span><span class="s2">&quot;charset&quot; </span><span class="s0">in </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">meta_tags)</span>

        <span class="s1">tags = []</span>
        <span class="s0">if not </span><span class="s1">has_ie_compat:</span>
            <span class="s1">tags.append(</span><span class="s2">'&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;'</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">has_charset:</span>
            <span class="s1">tags.append(</span><span class="s2">'&lt;meta charset=&quot;UTF-8&quot;&gt;'</span><span class="s1">)</span>

        <span class="s1">tags += [format_tag(</span><span class="s2">&quot;meta&quot;</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">opened=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">meta_tags]</span>

        <span class="s0">return </span><span class="s2">&quot;</span><span class="s0">\n      </span><span class="s2">&quot;</span><span class="s1">.join(tags)</span>

    <span class="s3"># Serve the JS bundles for each package</span>
    <span class="s0">def </span><span class="s1">serve_component_suites(self</span><span class="s0">, </span><span class="s1">package_name</span><span class="s0">, </span><span class="s1">fingerprinted_path):</span>
        <span class="s1">path_in_pkg</span><span class="s0">, </span><span class="s1">has_fingerprint = check_fingerprint(fingerprinted_path)</span>

        <span class="s1">_validate.validate_js_path(self.registered_paths</span><span class="s0">, </span><span class="s1">package_name</span><span class="s0">, </span><span class="s1">path_in_pkg)</span>

        <span class="s1">extension = </span><span class="s2">&quot;.&quot; </span><span class="s1">+ path_in_pkg.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">mimetype = mimetypes.types_map.get(extension</span><span class="s0">, </span><span class="s2">&quot;application/octet-stream&quot;</span><span class="s1">)</span>

        <span class="s1">package = sys.modules[package_name]</span>
        <span class="s1">self.logger.debug(</span>
            <span class="s2">&quot;serving -- package: %s[%s] resource: %s =&gt; location: %s&quot;</span><span class="s0">,</span>
            <span class="s1">package_name</span><span class="s0">,</span>
            <span class="s1">package.__version__</span><span class="s0">,</span>
            <span class="s1">path_in_pkg</span><span class="s0">,</span>
            <span class="s1">package.__path__</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">response = flask.Response(</span>
            <span class="s1">pkgutil.get_data(package_name</span><span class="s0">, </span><span class="s1">path_in_pkg)</span><span class="s0">, </span><span class="s1">mimetype=mimetype</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">has_fingerprint:</span>
            <span class="s3"># Fingerprinted resources are good forever (1 year)</span>
            <span class="s3"># No need for ETag as the fingerprint changes with each build</span>
            <span class="s1">response.cache_control.max_age = </span><span class="s5">31536000  </span><span class="s3"># 1 year</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Non-fingerprinted resources are given an ETag that</span>
            <span class="s3"># will be used / check on future requests</span>
            <span class="s1">response.add_etag()</span>
            <span class="s1">tag = response.get_etag()[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">request_etag = flask.request.headers.get(</span><span class="s2">&quot;If-None-Match&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s2">'&quot;{}&quot;'</span><span class="s1">.format(tag) == request_etag:</span>
                <span class="s1">response = flask.Response(</span><span class="s0">None, </span><span class="s1">status=</span><span class="s5">304</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">response</span>

    <span class="s0">def </span><span class="s1">index(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):  </span><span class="s3"># pylint: disable=unused-argument</span>
        <span class="s1">scripts = self._generate_scripts_html()</span>
        <span class="s1">css = self._generate_css_dist_html()</span>
        <span class="s1">config = self._generate_config_html()</span>
        <span class="s1">metas = self._generate_meta_html()</span>
        <span class="s1">renderer = self._generate_renderer()</span>

        <span class="s3"># use self.title instead of app.config.title for backwards compatibility</span>
        <span class="s1">title = self.title</span>

        <span class="s0">if </span><span class="s1">self._favicon:</span>
            <span class="s1">favicon_mod_time = os.path.getmtime(</span>
                <span class="s1">os.path.join(self.config.assets_folder</span><span class="s0">, </span><span class="s1">self._favicon)</span>
            <span class="s1">)</span>
            <span class="s1">favicon_url = self.get_asset_url(self._favicon) + </span><span class="s2">&quot;?m={}&quot;</span><span class="s1">.format(</span>
                <span class="s1">favicon_mod_time</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">favicon_url = </span><span class="s2">&quot;{}_favicon.ico?v={}&quot;</span><span class="s1">.format(</span>
                <span class="s1">self.config.requests_pathname_prefix</span><span class="s0">, </span><span class="s1">__version__</span>
            <span class="s1">)</span>

        <span class="s1">favicon = format_tag(</span>
            <span class="s2">&quot;link&quot;</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;rel&quot;</span><span class="s1">: </span><span class="s2">&quot;icon&quot;</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;image/x-icon&quot;</span><span class="s0">, </span><span class="s2">&quot;href&quot;</span><span class="s1">: favicon_url}</span><span class="s0">,</span>
            <span class="s1">opened=</span><span class="s0">True,</span>
        <span class="s1">)</span>

        <span class="s1">index = self.interpolate_index(</span>
            <span class="s1">metas=metas</span><span class="s0">,</span>
            <span class="s1">title=title</span><span class="s0">,</span>
            <span class="s1">css=css</span><span class="s0">,</span>
            <span class="s1">config=config</span><span class="s0">,</span>
            <span class="s1">scripts=scripts</span><span class="s0">,</span>
            <span class="s1">app_entry=_app_entry</span><span class="s0">,</span>
            <span class="s1">favicon=favicon</span><span class="s0">,</span>
            <span class="s1">renderer=renderer</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">checks = (</span>
            <span class="s1">_re_index_entry_id</span><span class="s0">,</span>
            <span class="s1">_re_index_config_id</span><span class="s0">,</span>
            <span class="s1">_re_index_scripts_id</span><span class="s0">,</span>
            <span class="s1">_re_renderer_scripts_id</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">_validate.validate_index(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">checks</span><span class="s0">, </span><span class="s1">index)</span>
        <span class="s0">return </span><span class="s1">index</span>

    <span class="s0">def </span><span class="s1">interpolate_index(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">metas=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">title=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">css=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">config=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">scripts=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">app_entry=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">favicon=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">renderer=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Called to create the initial HTML string that is loaded on page. 
        Override this method to provide you own custom HTML. 
 
        :Example: 
 
            class MyDash(dash.Dash): 
                def interpolate_index(self, **kwargs): 
                    return '''&lt;!DOCTYPE html&gt; 
                    &lt;html&gt; 
                        &lt;head&gt; 
                            &lt;title&gt;My App&lt;/title&gt; 
                        &lt;/head&gt; 
                        &lt;body&gt; 
                            &lt;div id=&quot;custom-header&quot;&gt;My custom header&lt;/div&gt; 
                            {app_entry} 
                            {config} 
                            {scripts} 
                            {renderer} 
                            &lt;div id=&quot;custom-footer&quot;&gt;My custom footer&lt;/div&gt; 
                        &lt;/body&gt; 
                    &lt;/html&gt;'''.format(app_entry=kwargs.get('app_entry'), 
                                      config=kwargs.get('config'), 
                                      scripts=kwargs.get('scripts'), 
                                      renderer=kwargs.get('renderer')) 
 
        :param metas: Collected &amp; formatted meta tags. 
        :param title: The title of the app. 
        :param css: Collected &amp; formatted css dependencies as &lt;link&gt; tags. 
        :param config: Configs needed by dash-renderer. 
        :param scripts: Collected &amp; formatted scripts tags. 
        :param renderer: A script tag that instantiates the DashRenderer. 
        :param app_entry: Where the app will render. 
        :param favicon: A favicon &lt;link&gt; tag if found in assets folder. 
        :return: The interpolated HTML string for the index. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">interpolate_str(</span>
            <span class="s1">self.index_string</span><span class="s0">,</span>
            <span class="s1">metas=metas</span><span class="s0">,</span>
            <span class="s1">title=title</span><span class="s0">,</span>
            <span class="s1">css=css</span><span class="s0">,</span>
            <span class="s1">config=config</span><span class="s0">,</span>
            <span class="s1">scripts=scripts</span><span class="s0">,</span>
            <span class="s1">favicon=favicon</span><span class="s0">,</span>
            <span class="s1">renderer=renderer</span><span class="s0">,</span>
            <span class="s1">app_entry=app_entry</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">dependencies(self):</span>
        <span class="s0">return </span><span class="s1">flask.jsonify(self._callback_list)</span>

    <span class="s0">def </span><span class="s1">clientside_callback(self</span><span class="s0">, </span><span class="s1">clientside_function</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s4">&quot;&quot;&quot;Create a callback that updates the output by calling a clientside 
        (JavaScript) function instead of a Python function. 
 
        Unlike `@app.callback`, `clientside_callback` is not a decorator: 
        it takes either a 
        `dash.dependencies.ClientsideFunction(namespace, function_name)` 
        argument that describes which JavaScript function to call 
        (Dash will look for the JavaScript function at 
        `window.dash_clientside[namespace][function_name]`), or it may take 
        a string argument that contains the clientside function source. 
 
        For example, when using a `dash.dependencies.ClientsideFunction`: 
        ``` 
        app.clientside_callback( 
            ClientsideFunction('my_clientside_library', 'my_function'), 
            Output('my-div' 'children'), 
            [Input('my-input', 'value'), 
             Input('another-input', 'value')] 
        ) 
        ``` 
 
        With this signature, Dash's front-end will call 
        `window.dash_clientside.my_clientside_library.my_function` with the 
        current values of the `value` properties of the components `my-input` 
        and `another-input` whenever those values change. 
 
        Include a JavaScript file by including it your `assets/` folder. The 
        file can be named anything but you'll need to assign the function's 
        namespace to the `window.dash_clientside` namespace. For example, 
        this file might look: 
        ``` 
        window.dash_clientside = window.dash_clientside || {}; 
        window.dash_clientside.my_clientside_library = { 
            my_function: function(input_value_1, input_value_2) { 
                return ( 
                    parseFloat(input_value_1, 10) + 
                    parseFloat(input_value_2, 10) 
                ); 
            } 
        } 
        ``` 
 
        Alternatively, you can pass the JavaScript source directly to 
        `clientside_callback`. In this case, the same example would look like: 
        ``` 
        app.clientside_callback( 
            ''' 
            function(input_value_1, input_value_2) { 
                return ( 
                    parseFloat(input_value_1, 10) + 
                    parseFloat(input_value_2, 10) 
                ); 
            } 
            ''', 
            Output('my-div' 'children'), 
            [Input('my-input', 'value'), 
             Input('another-input', 'value')] 
        ) 
        ``` 
 
        The last, optional argument `prevent_initial_call` causes the callback 
        not to fire when its outputs are first added to the page. Defaults to 
        `False` unless `prevent_initial_callbacks=True` at the app level. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_callback.register_clientside_callback(</span>
            <span class="s1">self._callback_list</span><span class="s0">,</span>
            <span class="s1">self.callback_map</span><span class="s0">,</span>
            <span class="s1">self.config.prevent_initial_callbacks</span><span class="s0">,</span>
            <span class="s1">self._inline_scripts</span><span class="s0">,</span>
            <span class="s1">clientside_function</span><span class="s0">,</span>
            <span class="s1">*args</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">callback(self</span><span class="s0">, </span><span class="s1">*_args</span><span class="s0">, </span><span class="s1">**_kwargs):</span>
        <span class="s4">&quot;&quot;&quot; 
        Normally used as a decorator, `@app.callback` provides a server-side 
        callback relating the values of one or more `Output` items to one or 
        more `Input` items which will trigger the callback when they change, 
        and optionally `State` items which provide additional information but 
        do not trigger the callback directly. 
 
        The last, optional argument `prevent_initial_call` causes the callback 
        not to fire when its outputs are first added to the page. Defaults to 
        `False` unless `prevent_initial_callbacks=True` at the app level. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_callback.register_callback(</span>
            <span class="s1">self._callback_list</span><span class="s0">,</span>
            <span class="s1">self.callback_map</span><span class="s0">,</span>
            <span class="s1">self.config.prevent_initial_callbacks</span><span class="s0">,</span>
            <span class="s1">*_args</span><span class="s0">,</span>
            <span class="s1">**_kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">long_callback(self</span><span class="s0">, </span><span class="s1">*_args</span><span class="s0">, </span><span class="s1">**_kwargs):  </span><span class="s3"># pylint: disable=too-many-statements</span>
        <span class="s4">&quot;&quot;&quot; 
        Normally used as a decorator, `@app.long_callback` is an alternative to 
        `@app.callback` designed for callbacks that take a long time to run, 
        without locking up the Dash app or timing out. 
 
        `@long_callback` is designed to support multiple callback managers. 
        Two long callback managers are currently implemented: 
 
            - A diskcache manager (`DiskcacheLongCallbackManager`) that runs callback 
              logic in a separate process and stores the results to disk using the 
              diskcache library. This is the easiest backend to use for local 
              development. 
            - A Celery manager (`CeleryLongCallbackManager`) that runs callback logic 
              in a celery worker and returns results to the Dash app through a Celery 
              broker like RabbitMQ or Redis. 
 
        The following arguments may include any valid arguments to `@app.callback`. 
        In addition, `@app.long_callback` supports the following optional 
        keyword arguments: 
 
        :Keyword Arguments: 
            :param manager: 
                A long callback manager instance. Currently an instance of one of 
                `DiskcacheLongCallbackManager` or `CeleryLongCallbackManager`. 
                Defaults to the `long_callback_manager` instance provided to the 
                `dash.Dash constructor`. 
            :param running: 
                A list of 3-element tuples. The first element of each tuple should be 
                an `Output` dependency object referencing a property of a component in 
                the app layout. The second element is the value that the property 
                should be set to while the callback is running, and the third element 
                is the value the property should be set to when the callback completes. 
            :param cancel: 
                A list of `Input` dependency objects that reference a property of a 
                component in the app's layout.  When the value of this property changes 
                while a callback is running, the callback is canceled. 
                Note that the value of the property is not significant, any change in 
                value will result in the cancellation of the running job (if any). 
            :param progress: 
                An `Output` dependency grouping that references properties of 
                components in the app's layout. When provided, the decorated function 
                will be called with an extra argument as the first argument to the 
                function.  This argument, is a function handle that the decorated 
                function should call in order to provide updates to the app on its 
                current progress. This function accepts a single argument, which 
                correspond to the grouping of properties specified in the provided 
                `Output` dependency grouping 
            :param progress_default: 
                A grouping of values that should be assigned to the components 
                specified by the `progress` argument when the callback is not in 
                progress. If `progress_default` is not provided, all the dependency 
                properties specified in `progress` will be set to `None` when the 
                callback is not running. 
            :param cache_args_to_ignore: 
                Arguments to ignore when caching is enabled. If callback is configured 
                with keyword arguments (Input/State provided in a dict), 
                this should be a list of argument names as strings. Otherwise, 
                this should be a list of argument indices as integers. 
        &quot;&quot;&quot;</span>
        <span class="s3"># pylint: disable-next=import-outside-toplevel</span>
        <span class="s0">from </span><span class="s1">dash._callback_context </span><span class="s0">import </span><span class="s1">callback_context</span>

        <span class="s3"># pylint: disable-next=import-outside-toplevel</span>
        <span class="s0">from </span><span class="s1">dash.exceptions </span><span class="s0">import </span><span class="s1">WildcardInLongCallback</span>

        <span class="s3"># Get long callback manager</span>
        <span class="s1">callback_manager = _kwargs.pop(</span><span class="s2">&quot;manager&quot;</span><span class="s0">, </span><span class="s1">self._long_callback_manager)</span>
        <span class="s0">if </span><span class="s1">callback_manager </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;The @app.long_callback decorator requires a long callback manager</span><span class="s0">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;instance.  This may be provided to the app using the </span><span class="s0">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;long_callback_manager argument to the dash.Dash constructor, or</span><span class="s0">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;it may be provided to the @app.long_callback decorator as the </span><span class="s0">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;manager argument&quot;</span>
            <span class="s1">)</span>

        <span class="s3"># Extract special long_callback kwargs</span>
        <span class="s1">running = _kwargs.pop(</span><span class="s2">&quot;running&quot;</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s1">cancel = _kwargs.pop(</span><span class="s2">&quot;cancel&quot;</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s1">progress = _kwargs.pop(</span><span class="s2">&quot;progress&quot;</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s1">progress_default = _kwargs.pop(</span><span class="s2">&quot;progress_default&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">interval_time = _kwargs.pop(</span><span class="s2">&quot;interval&quot;</span><span class="s0">, </span><span class="s5">1000</span><span class="s1">)</span>
        <span class="s1">cache_args_to_ignore = _kwargs.pop(</span><span class="s2">&quot;cache_args_to_ignore&quot;</span><span class="s0">, </span><span class="s1">[])</span>

        <span class="s3"># Parse remaining args just like app.callback</span>
        <span class="s1">(</span>
            <span class="s1">output</span><span class="s0">,</span>
            <span class="s1">flat_inputs</span><span class="s0">,</span>
            <span class="s1">flat_state</span><span class="s0">,</span>
            <span class="s1">inputs_state_indices</span><span class="s0">,</span>
            <span class="s1">prevent_initial_call</span><span class="s0">,</span>
        <span class="s1">) = handle_grouped_callback_args(_args</span><span class="s0">, </span><span class="s1">_kwargs)</span>
        <span class="s1">inputs_and_state = flat_inputs + flat_state</span>
        <span class="s1">args_deps = map_grouping(</span><span class="s0">lambda </span><span class="s1">i: inputs_and_state[i]</span><span class="s0">, </span><span class="s1">inputs_state_indices)</span>

        <span class="s3"># Disallow wildcard dependencies</span>
        <span class="s0">for </span><span class="s1">deps </span><span class="s0">in </span><span class="s1">[output</span><span class="s0">, </span><span class="s1">flat_inputs</span><span class="s0">, </span><span class="s1">flat_state]:</span>
            <span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">flatten_grouping(deps):</span>
                <span class="s0">if </span><span class="s1">dep.has_wildcard():</span>
                    <span class="s0">raise </span><span class="s1">WildcardInLongCallback(</span>
                        <span class="s2">f&quot;&quot;&quot;</span>
                        <span class="s2">@app.long_callback does not support dependencies with</span>
                        <span class="s2">pattern-matching ids</span>
                            <span class="s2">Received: </span><span class="s0">{</span><span class="s1">repr(dep)</span><span class="s0">}\n</span><span class="s2">&quot;&quot;&quot;</span>
                    <span class="s1">)</span>

        <span class="s3"># Get unique id for this long_callback definition.  This increment is not</span>
        <span class="s3"># thread safe, but it doesn't need to be because callback definitions</span>
        <span class="s3"># happen on the main thread before the app starts</span>
        <span class="s1">self._long_callback_count += </span><span class="s5">1</span>
        <span class="s1">long_callback_id = self._long_callback_count</span>

        <span class="s3"># Create Interval and Store for long callback and add them to the app's</span>
        <span class="s3"># _extra_components list</span>
        <span class="s1">interval_id = </span><span class="s2">f&quot;_long_callback_interval_</span><span class="s0">{</span><span class="s1">long_callback_id</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">interval_component = dcc.Interval(</span>
            <span class="s1">id=interval_id</span><span class="s0">, </span><span class="s1">interval=interval_time</span><span class="s0">, </span><span class="s1">disabled=prevent_initial_call</span>
        <span class="s1">)</span>
        <span class="s1">store_id = </span><span class="s2">f&quot;_long_callback_store_</span><span class="s0">{</span><span class="s1">long_callback_id</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">store_component = dcc.Store(id=store_id</span><span class="s0">, </span><span class="s1">data={})</span>
        <span class="s1">self._extra_components.extend([interval_component</span><span class="s0">, </span><span class="s1">store_component])</span>

        <span class="s3"># Compute full component plus property name for the cancel dependencies</span>
        <span class="s1">cancel_prop_ids = tuple(</span>
            <span class="s2">&quot;.&quot;</span><span class="s1">.join([dep.component_id</span><span class="s0">, </span><span class="s1">dep.component_property]) </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">cancel</span>
        <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">wrapper(fn):</span>
            <span class="s1">background_fn = callback_manager.make_job_fn(fn</span><span class="s0">, </span><span class="s1">bool(progress)</span><span class="s0">, </span><span class="s1">args_deps)</span>

            <span class="s0">def </span><span class="s1">callback(_triggers</span><span class="s0">, </span><span class="s1">user_store_data</span><span class="s0">, </span><span class="s1">user_callback_args):</span>
                <span class="s3"># Build result cache key from inputs</span>
                <span class="s1">pending_key = callback_manager.build_cache_key(</span>
                    <span class="s1">fn</span><span class="s0">, </span><span class="s1">user_callback_args</span><span class="s0">, </span><span class="s1">cache_args_to_ignore</span>
                <span class="s1">)</span>
                <span class="s1">current_key = user_store_data.get(</span><span class="s2">&quot;current_key&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">pending_job = user_store_data.get(</span><span class="s2">&quot;pending_job&quot;</span><span class="s0">, None</span><span class="s1">)</span>

                <span class="s1">should_cancel = pending_key == current_key </span><span class="s0">or </span><span class="s1">any(</span>
                    <span class="s1">trigger[</span><span class="s2">&quot;prop_id&quot;</span><span class="s1">] </span><span class="s0">in </span><span class="s1">cancel_prop_ids</span>
                    <span class="s0">for </span><span class="s1">trigger </span><span class="s0">in </span><span class="s1">callback_context.triggered</span>
                <span class="s1">)</span>

                <span class="s3"># Compute grouping of values to set the progress component's to</span>
                <span class="s3"># when cleared</span>
                <span class="s0">if </span><span class="s1">progress_default </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">clear_progress = (</span>
                        <span class="s1">map_grouping(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s0">None, </span><span class="s1">progress) </span><span class="s0">if </span><span class="s1">progress </span><span class="s0">else </span><span class="s1">()</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">clear_progress = progress_default</span>

                <span class="s0">if </span><span class="s1">should_cancel:</span>
                    <span class="s1">user_store_data[</span><span class="s2">&quot;current_key&quot;</span><span class="s1">] = </span><span class="s0">None</span>
                    <span class="s1">user_store_data[</span><span class="s2">&quot;pending_key&quot;</span><span class="s1">] = </span><span class="s0">None</span>
                    <span class="s1">user_store_data[</span><span class="s2">&quot;pending_job&quot;</span><span class="s1">] = </span><span class="s0">None</span>

                    <span class="s1">callback_manager.terminate_job(pending_job)</span>

                    <span class="s0">return </span><span class="s1">dict(</span>
                        <span class="s1">user_callback_output=map_grouping(</span><span class="s0">lambda </span><span class="s1">x: no_update</span><span class="s0">, </span><span class="s1">output)</span><span class="s0">,</span>
                        <span class="s1">interval_disabled=</span><span class="s0">True,</span>
                        <span class="s1">in_progress=[val </span><span class="s0">for </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">val) </span><span class="s0">in </span><span class="s1">running]</span><span class="s0">,</span>
                        <span class="s1">progress=clear_progress</span><span class="s0">,</span>
                        <span class="s1">user_store_data=user_store_data</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s3"># Look up progress value if a job is in progress</span>
                <span class="s0">if </span><span class="s1">pending_job:</span>
                    <span class="s1">progress_value = callback_manager.get_progress(pending_key)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">progress_value = </span><span class="s0">None</span>

                <span class="s0">if </span><span class="s1">callback_manager.result_ready(pending_key):</span>
                    <span class="s1">result = callback_manager.get_result(pending_key</span><span class="s0">, </span><span class="s1">pending_job)</span>
                    <span class="s3"># Set current key (hash of data stored in client)</span>
                    <span class="s3"># to pending key (hash of data requested by client)</span>
                    <span class="s1">user_store_data[</span><span class="s2">&quot;current_key&quot;</span><span class="s1">] = pending_key</span>

                    <span class="s3"># Disable interval if this value was pulled from cache.</span>
                    <span class="s3"># If this value was the result of a background calculation, don't</span>
                    <span class="s3"># disable yet. If no other calculations are in progress,</span>
                    <span class="s3"># interval will be disabled in should_cancel logic above</span>
                    <span class="s3"># the next time the interval fires.</span>
                    <span class="s1">interval_disabled = pending_job </span><span class="s0">is None</span>
                    <span class="s0">return </span><span class="s1">dict(</span>
                        <span class="s1">user_callback_output=result</span><span class="s0">,</span>
                        <span class="s1">interval_disabled=interval_disabled</span><span class="s0">,</span>
                        <span class="s1">in_progress=[val </span><span class="s0">for </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">val) </span><span class="s0">in </span><span class="s1">running]</span><span class="s0">,</span>
                        <span class="s1">progress=clear_progress</span><span class="s0">,</span>
                        <span class="s1">user_store_data=user_store_data</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">progress_value:</span>
                    <span class="s0">return </span><span class="s1">dict(</span>
                        <span class="s1">user_callback_output=map_grouping(</span><span class="s0">lambda </span><span class="s1">x: no_update</span><span class="s0">, </span><span class="s1">output)</span><span class="s0">,</span>
                        <span class="s1">interval_disabled=</span><span class="s0">False,</span>
                        <span class="s1">in_progress=[val </span><span class="s0">for </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">_) </span><span class="s0">in </span><span class="s1">running]</span><span class="s0">,</span>
                        <span class="s1">progress=progress_value </span><span class="s0">or </span><span class="s1">{}</span><span class="s0">,</span>
                        <span class="s1">user_store_data=user_store_data</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s3"># Check if there is a running calculation that can now</span>
                <span class="s3"># be canceled</span>
                <span class="s1">old_pending_key = user_store_data.get(</span><span class="s2">&quot;pending_key&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">old_pending_key</span>
                    <span class="s0">and </span><span class="s1">old_pending_key != pending_key</span>
                    <span class="s0">and </span><span class="s1">callback_manager.job_running(pending_job)</span>
                <span class="s1">):</span>
                    <span class="s1">callback_manager.terminate_job(pending_job)</span>

                <span class="s1">user_store_data[</span><span class="s2">&quot;pending_key&quot;</span><span class="s1">] = pending_key</span>
                <span class="s1">callback_manager.terminate_unhealthy_job(pending_job)</span>
                <span class="s0">if not </span><span class="s1">callback_manager.job_running(pending_job):</span>
                    <span class="s1">user_store_data[</span><span class="s2">&quot;pending_job&quot;</span><span class="s1">] = callback_manager.call_job_fn(</span>
                        <span class="s1">pending_key</span><span class="s0">, </span><span class="s1">background_fn</span><span class="s0">, </span><span class="s1">user_callback_args</span>
                    <span class="s1">)</span>

                <span class="s0">return </span><span class="s1">dict(</span>
                    <span class="s1">user_callback_output=map_grouping(</span><span class="s0">lambda </span><span class="s1">x: no_update</span><span class="s0">, </span><span class="s1">output)</span><span class="s0">,</span>
                    <span class="s1">interval_disabled=</span><span class="s0">False,</span>
                    <span class="s1">in_progress=[val </span><span class="s0">for </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">_) </span><span class="s0">in </span><span class="s1">running]</span><span class="s0">,</span>
                    <span class="s1">progress=clear_progress</span><span class="s0">,</span>
                    <span class="s1">user_store_data=user_store_data</span><span class="s0">,</span>
                <span class="s1">)</span>

            <span class="s0">return </span><span class="s1">self.callback(</span>
                <span class="s1">inputs=dict(</span>
                    <span class="s1">_triggers=dict(</span>
                        <span class="s1">n_intervals=Input(interval_id</span><span class="s0">, </span><span class="s2">&quot;n_intervals&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">cancel=cancel</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">user_store_data=State(store_id</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">user_callback_args=args_deps</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">output=dict(</span>
                    <span class="s1">user_callback_output=output</span><span class="s0">,</span>
                    <span class="s1">interval_disabled=Output(interval_id</span><span class="s0">, </span><span class="s2">&quot;disabled&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">in_progress=[dep </span><span class="s0">for </span><span class="s1">(dep</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_) </span><span class="s0">in </span><span class="s1">running]</span><span class="s0">,</span>
                    <span class="s1">progress=progress</span><span class="s0">,</span>
                    <span class="s1">user_store_data=Output(store_id</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">prevent_initial_call=prevent_initial_call</span><span class="s0">,</span>
            <span class="s1">)(callback)</span>

        <span class="s0">return </span><span class="s1">wrapper</span>

    <span class="s0">def </span><span class="s1">dispatch(self):</span>
        <span class="s1">body = flask.request.get_json()</span>
        <span class="s1">flask.g.inputs_list = inputs = body.get(  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
            <span class="s2">&quot;inputs&quot;</span><span class="s0">, </span><span class="s1">[]</span>
        <span class="s1">)</span>
        <span class="s1">flask.g.states_list = state = body.get(  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
            <span class="s2">&quot;state&quot;</span><span class="s0">, </span><span class="s1">[]</span>
        <span class="s1">)</span>
        <span class="s1">output = body[</span><span class="s2">&quot;output&quot;</span><span class="s1">]</span>
        <span class="s1">outputs_list = body.get(</span><span class="s2">&quot;outputs&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">split_callback_id(output)</span>
        <span class="s1">flask.g.outputs_list = outputs_list  </span><span class="s3"># pylint: disable=assigning-non-slot</span>

        <span class="s1">flask.g.input_values = (  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
            <span class="s1">input_values</span>
        <span class="s1">) = inputs_to_dict(inputs)</span>
        <span class="s1">flask.g.state_values = inputs_to_dict(  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
            <span class="s1">state</span>
        <span class="s1">)</span>
        <span class="s1">changed_props = body.get(</span><span class="s2">&quot;changedPropIds&quot;</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">flask.g.triggered_inputs = [  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
            <span class="s1">{</span><span class="s2">&quot;prop_id&quot;</span><span class="s1">: x</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: input_values.get(x)} </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">changed_props</span>
        <span class="s1">]</span>

        <span class="s1">response = (</span>
            <span class="s1">flask.g.dash_response  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
        <span class="s1">) = flask.Response(mimetype=</span><span class="s2">&quot;application/json&quot;</span><span class="s1">)</span>

        <span class="s1">args = inputs_to_vals(inputs + state)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">cb = self.callback_map[output]</span>
            <span class="s1">func = cb[</span><span class="s2">&quot;callback&quot;</span><span class="s1">]</span>

            <span class="s3"># Add args_grouping</span>
            <span class="s1">inputs_state_indices = cb[</span><span class="s2">&quot;inputs_state_indices&quot;</span><span class="s1">]</span>
            <span class="s1">inputs_state = inputs + state</span>
            <span class="s1">args_grouping = map_grouping(</span>
                <span class="s0">lambda </span><span class="s1">ind: inputs_state[ind]</span><span class="s0">, </span><span class="s1">inputs_state_indices</span>
            <span class="s1">)</span>
            <span class="s1">flask.g.args_grouping = args_grouping  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
            <span class="s1">flask.g.using_args_grouping = (  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
                <span class="s0">not </span><span class="s1">isinstance(inputs_state_indices</span><span class="s0">, </span><span class="s1">int)</span>
                <span class="s0">and </span><span class="s1">(</span>
                    <span class="s1">inputs_state_indices</span>
                    <span class="s1">!= list(range(grouping_len(inputs_state_indices)))</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s3"># Add outputs_grouping</span>
            <span class="s1">outputs_indices = cb[</span><span class="s2">&quot;outputs_indices&quot;</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">isinstance(outputs_list</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">flat_outputs = [outputs_list]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">flat_outputs = outputs_list</span>

            <span class="s1">outputs_grouping = map_grouping(</span>
                <span class="s0">lambda </span><span class="s1">ind: flat_outputs[ind]</span><span class="s0">, </span><span class="s1">outputs_indices</span>
            <span class="s1">)</span>
            <span class="s1">flask.g.outputs_grouping = (  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
                <span class="s1">outputs_grouping</span>
            <span class="s1">)</span>
            <span class="s1">flask.g.using_outputs_grouping = (  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
                <span class="s0">not </span><span class="s1">isinstance(outputs_indices</span><span class="s0">, </span><span class="s1">int)</span>
                <span class="s0">and </span><span class="s1">outputs_indices != list(range(grouping_len(outputs_indices)))</span>
            <span class="s1">)</span>

        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">missing_callback_function:</span>
            <span class="s1">msg = </span><span class="s2">&quot;Callback function not found for output '{}', perhaps you forgot to prepend the '@'?&quot;</span>
            <span class="s0">raise </span><span class="s1">KeyError(msg.format(output)) </span><span class="s0">from </span><span class="s1">missing_callback_function</span>
        <span class="s1">response.set_data(func(*args</span><span class="s0">, </span><span class="s1">outputs_list=outputs_list))</span>
        <span class="s0">return </span><span class="s1">response</span>

    <span class="s0">def </span><span class="s1">_setup_server(self):</span>
        <span class="s3"># Apply _force_eager_loading overrides from modules</span>
        <span class="s1">eager_loading = self.config.eager_loading</span>
        <span class="s0">for </span><span class="s1">module_name </span><span class="s0">in </span><span class="s1">ComponentRegistry.registry:</span>
            <span class="s1">module = sys.modules[module_name]</span>
            <span class="s1">eager = getattr(module</span><span class="s0">, </span><span class="s2">&quot;_force_eager_loading&quot;</span><span class="s0">, False</span><span class="s1">)</span>
            <span class="s1">eager_loading = eager_loading </span><span class="s0">or </span><span class="s1">eager</span>

        <span class="s3"># Update eager_loading settings</span>
        <span class="s1">self.scripts.config.eager_loading = eager_loading</span>

        <span class="s0">if </span><span class="s1">self.config.include_assets_files:</span>
            <span class="s1">self._walk_assets_directory()</span>

        <span class="s1">_validate.validate_layout(self.layout</span><span class="s0">, </span><span class="s1">self._layout_value())</span>

        <span class="s1">self._generate_scripts_html()</span>
        <span class="s1">self._generate_css_dist_html()</span>

        <span class="s3"># Copy over global callback data structures assigned with `dash.callback`</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">list(_callback.GLOBAL_CALLBACK_MAP):</span>

            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.callback_map:</span>
                <span class="s0">raise </span><span class="s1">DuplicateCallback(</span>
                    <span class="s2">&quot;The callback `{}` provided with `dash.callback` was already &quot;</span><span class="s1">.format(</span>
                        <span class="s1">k</span>
                    <span class="s1">)</span>
                    <span class="s1">+ </span><span class="s2">&quot;assigned with `app.callback`.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">self.callback_map[k] = _callback.GLOBAL_CALLBACK_MAP.pop(k)</span>

        <span class="s1">self._callback_list.extend(_callback.GLOBAL_CALLBACK_LIST)</span>
        <span class="s1">_callback.GLOBAL_CALLBACK_LIST.clear()</span>

    <span class="s0">def </span><span class="s1">_add_assets_resource(self</span><span class="s0">, </span><span class="s1">url_path</span><span class="s0">, </span><span class="s1">file_path):</span>
        <span class="s1">res = {</span><span class="s2">&quot;asset_path&quot;</span><span class="s1">: url_path</span><span class="s0">, </span><span class="s2">&quot;filepath&quot;</span><span class="s1">: file_path}</span>
        <span class="s0">if </span><span class="s1">self.config.assets_external_path:</span>
            <span class="s1">res[</span><span class="s2">&quot;external_url&quot;</span><span class="s1">] = self.get_asset_url(url_path.lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">))</span>
        <span class="s1">self._assets_files.append(file_path)</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">_walk_assets_directory(self):</span>
        <span class="s1">walk_dir = self.config.assets_folder</span>
        <span class="s1">slash_splitter = re.compile(</span><span class="s2">r&quot;[\\/]+&quot;</span><span class="s1">)</span>
        <span class="s1">ignore_str = self.config.assets_ignore</span>
        <span class="s1">ignore_filter = re.compile(ignore_str) </span><span class="s0">if </span><span class="s1">ignore_str </span><span class="s0">else None</span>

        <span class="s0">for </span><span class="s1">current</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">files </span><span class="s0">in </span><span class="s1">sorted(os.walk(walk_dir)):</span>
            <span class="s0">if </span><span class="s1">current == walk_dir:</span>
                <span class="s1">base = </span><span class="s2">&quot;&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">s = current.replace(walk_dir</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).lstrip(</span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s1">).lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s1">splitted = slash_splitter.split(s)</span>
                <span class="s0">if </span><span class="s1">len(splitted) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">base = </span><span class="s2">&quot;/&quot;</span><span class="s1">.join(slash_splitter.split(s))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">base = splitted[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">ignore_filter:</span>
                <span class="s1">files_gen = (x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">files </span><span class="s0">if not </span><span class="s1">ignore_filter.search(x))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">files_gen = files</span>

            <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">sorted(files_gen):</span>
                <span class="s1">path = </span><span class="s2">&quot;/&quot;</span><span class="s1">.join([base</span><span class="s0">, </span><span class="s1">f]) </span><span class="s0">if </span><span class="s1">base </span><span class="s0">else </span><span class="s1">f</span>

                <span class="s1">full = os.path.join(current</span><span class="s0">, </span><span class="s1">f)</span>

                <span class="s0">if </span><span class="s1">f.endswith(</span><span class="s2">&quot;js&quot;</span><span class="s1">):</span>
                    <span class="s1">self.scripts.append_script(self._add_assets_resource(path</span><span class="s0">, </span><span class="s1">full))</span>
                <span class="s0">elif </span><span class="s1">f.endswith(</span><span class="s2">&quot;css&quot;</span><span class="s1">):</span>
                    <span class="s1">self.css.append_css(self._add_assets_resource(path</span><span class="s0">, </span><span class="s1">full))</span>
                <span class="s0">elif </span><span class="s1">f == </span><span class="s2">&quot;favicon.ico&quot;</span><span class="s1">:</span>
                    <span class="s1">self._favicon = path</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_invalid_resources_handler(err):</span>
        <span class="s0">return </span><span class="s1">err.args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">404</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_serve_default_favicon():</span>
        <span class="s0">return </span><span class="s1">flask.Response(</span>
            <span class="s1">pkgutil.get_data(</span><span class="s2">&quot;dash&quot;</span><span class="s0">, </span><span class="s2">&quot;favicon.ico&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">content_type=</span><span class="s2">&quot;image/x-icon&quot;</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">csp_hashes(self</span><span class="s0">, </span><span class="s1">hash_algorithm=</span><span class="s2">&quot;sha256&quot;</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Calculates CSP hashes (sha + base64) of all inline scripts, such that 
        one of the biggest benefits of CSP (disallowing general inline scripts) 
        can be utilized together with Dash clientside callbacks (inline scripts). 
 
        Calculate these hashes after all inline callbacks are defined, 
        and add them to your CSP headers before starting the server, for example 
        with the flask-talisman package from PyPI: 
 
        flask_talisman.Talisman(app.server, content_security_policy={ 
            &quot;default-src&quot;: &quot;'self'&quot;, 
            &quot;script-src&quot;: [&quot;'self'&quot;] + app.csp_hashes() 
        }) 
 
        :param hash_algorithm: One of the recognized CSP hash algorithms ('sha256', 'sha384', 'sha512'). 
        :return: List of CSP hash strings of all inline scripts. 
        &quot;&quot;&quot;</span>

        <span class="s1">HASH_ALGORITHMS = [</span><span class="s2">&quot;sha256&quot;</span><span class="s0">, </span><span class="s2">&quot;sha384&quot;</span><span class="s0">, </span><span class="s2">&quot;sha512&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">hash_algorithm </span><span class="s0">not in </span><span class="s1">HASH_ALGORITHMS:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Possible CSP hash algorithms: &quot; </span><span class="s1">+ </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(HASH_ALGORITHMS)</span>
            <span class="s1">)</span>

        <span class="s1">method = getattr(hashlib</span><span class="s0">, </span><span class="s1">hash_algorithm)</span>

        <span class="s1">self._inline_scripts.extend(_callback.GLOBAL_INLINE_SCRIPTS)</span>
        <span class="s1">_callback.GLOBAL_INLINE_SCRIPTS.clear()</span>

        <span class="s0">return </span><span class="s1">[</span>
            <span class="s2">&quot;'{hash_algorithm}-{base64_hash}'&quot;</span><span class="s1">.format(</span>
                <span class="s1">hash_algorithm=hash_algorithm</span><span class="s0">,</span>
                <span class="s1">base64_hash=base64.b64encode(</span>
                    <span class="s1">method(script.encode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">)).digest()</span>
                <span class="s1">).decode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">script </span><span class="s0">in </span><span class="s1">(self._inline_scripts + [self.renderer])</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">get_asset_url(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s0">if </span><span class="s1">self.config.assets_external_path:</span>
            <span class="s1">prefix = self.config.assets_external_path</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">prefix = self.config.requests_pathname_prefix</span>

        <span class="s1">asset = get_asset_path(prefix</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">self.config.assets_url_path.lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">))</span>

        <span class="s0">return </span><span class="s1">asset</span>

    <span class="s0">def </span><span class="s1">get_relative_path(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a path with `requests_pathname_prefix` prefixed before it. 
        Use this function when specifying local URL paths that will work 
        in environments regardless of what `requests_pathname_prefix` is. 
        In some deployment environments, like Dash Enterprise, 
        `requests_pathname_prefix` is set to the application name, 
        e.g. `my-dash-app`. 
        When working locally, `requests_pathname_prefix` might be unset and 
        so a relative URL like `/page-2` can just be `/page-2`. 
        However, when the app is deployed to a URL like `/my-dash-app`, then 
        `app.get_relative_path('/page-2')` will return `/my-dash-app/page-2`. 
        This can be used as an alternative to `get_asset_url` as well with 
        `app.get_relative_path('/assets/logo.png')` 
 
        Use this function with `app.strip_relative_path` in callbacks that 
        deal with `dcc.Location` `pathname` routing. 
        That is, your usage may look like: 
        ``` 
        app.layout = html.Div([ 
            dcc.Location(id='url'), 
            html.Div(id='content') 
        ]) 
        @app.callback(Output('content', 'children'), [Input('url', 'pathname')]) 
        def display_content(path): 
            page_name = app.strip_relative_path(path) 
            if not page_name:  # None or '' 
                return html.Div([ 
                    dcc.Link(href=app.get_relative_path('/page-1')), 
                    dcc.Link(href=app.get_relative_path('/page-2')), 
                ]) 
            elif page_name == 'page-1': 
                return chapters.page_1 
            if page_name == &quot;page-2&quot;: 
                return chapters.page_2 
        ``` 
        &quot;&quot;&quot;</span>
        <span class="s1">asset = get_relative_path(self.config.requests_pathname_prefix</span><span class="s0">, </span><span class="s1">path)</span>

        <span class="s0">return </span><span class="s1">asset</span>

    <span class="s0">def </span><span class="s1">strip_relative_path(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a path with `requests_pathname_prefix` and leading and trailing 
        slashes stripped from it. Also, if None is passed in, None is returned. 
        Use this function with `get_relative_path` in callbacks that deal 
        with `dcc.Location` `pathname` routing. 
        That is, your usage may look like: 
        ``` 
        app.layout = html.Div([ 
            dcc.Location(id='url'), 
            html.Div(id='content') 
        ]) 
        @app.callback(Output('content', 'children'), [Input('url', 'pathname')]) 
        def display_content(path): 
            page_name = app.strip_relative_path(path) 
            if not page_name:  # None or '' 
                return html.Div([ 
                    dcc.Link(href=app.get_relative_path('/page-1')), 
                    dcc.Link(href=app.get_relative_path('/page-2')), 
                ]) 
            elif page_name == 'page-1': 
                return chapters.page_1 
            if page_name == &quot;page-2&quot;: 
                return chapters.page_2 
        ``` 
        Note that `chapters.page_1` will be served if the user visits `/page-1` 
        _or_ `/page-1/` since `strip_relative_path` removes the trailing slash. 
 
        Also note that `strip_relative_path` is compatible with 
        `get_relative_path` in environments where `requests_pathname_prefix` set. 
        In some deployment environments, like Dash Enterprise, 
        `requests_pathname_prefix` is set to the application name, e.g. `my-dash-app`. 
        When working locally, `requests_pathname_prefix` might be unset and 
        so a relative URL like `/page-2` can just be `/page-2`. 
        However, when the app is deployed to a URL like `/my-dash-app`, then 
        `app.get_relative_path('/page-2')` will return `/my-dash-app/page-2` 
 
        The `pathname` property of `dcc.Location` will return '`/my-dash-app/page-2`' 
        to the callback. 
        In this case, `app.strip_relative_path('/my-dash-app/page-2')` 
        will return `'page-2'` 
 
        For nested URLs, slashes are still included: 
        `app.strip_relative_path('/page-1/sub-page-1/')` will return 
        `page-1/sub-page-1` 
        ``` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">strip_relative_path(self.config.requests_pathname_prefix</span><span class="s0">, </span><span class="s1">path)</span>

    <span class="s0">def </span><span class="s1">_setup_dev_tools(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">debug = kwargs.get(</span><span class="s2">&quot;debug&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">dev_tools = self._dev_tools = AttributeDict()</span>

        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s2">&quot;ui&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;props_check&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;serve_dev_bundles&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;hot_reload&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;silence_routes_logging&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;prune_errors&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">dev_tools[attr] = get_combined_config(</span>
                <span class="s1">attr</span><span class="s0">, </span><span class="s1">kwargs.get(attr</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default=debug</span>
            <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">_type</span><span class="s0">, </span><span class="s1">default </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s1">(</span><span class="s2">&quot;hot_reload_interval&quot;</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;hot_reload_watch_interval&quot;</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;hot_reload_max_retry&quot;</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s5">8</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">dev_tools[attr] = _type(</span>
                <span class="s1">get_combined_config(attr</span><span class="s0">, </span><span class="s1">kwargs.get(attr</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default=default)</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">dev_tools</span>

    <span class="s0">def </span><span class="s1">enable_dev_tools(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">debug=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_ui=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_props_check=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_serve_dev_bundles=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload_interval=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload_watch_interval=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload_max_retry=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_silence_routes_logging=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_prune_errors=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Activate the dev tools, called by `run_server`. If your application 
        is served by wsgi and you want to activate the dev tools, you can call 
        this method out of `__main__`. 
 
        All parameters can be set by environment variables as listed. 
        Values provided here take precedence over environment variables. 
 
        Available dev_tools environment variables: 
 
            - DASH_DEBUG 
            - DASH_UI 
            - DASH_PROPS_CHECK 
            - DASH_SERVE_DEV_BUNDLES 
            - DASH_HOT_RELOAD 
            - DASH_HOT_RELOAD_INTERVAL 
            - DASH_HOT_RELOAD_WATCH_INTERVAL 
            - DASH_HOT_RELOAD_MAX_RETRY 
            - DASH_SILENCE_ROUTES_LOGGING 
            - DASH_PRUNE_ERRORS 
 
        :param debug: Enable/disable all the dev tools unless overridden by the 
            arguments or environment variables. Default is ``True`` when 
            ``enable_dev_tools`` is called directly, and ``False`` when called 
            via ``run_server``. env: ``DASH_DEBUG`` 
        :type debug: bool 
 
        :param dev_tools_ui: Show the dev tools UI. env: ``DASH_UI`` 
        :type dev_tools_ui: bool 
 
        :param dev_tools_props_check: Validate the types and values of Dash 
            component props. env: ``DASH_PROPS_CHECK`` 
        :type dev_tools_props_check: bool 
 
        :param dev_tools_serve_dev_bundles: Serve the dev bundles. Production 
            bundles do not necessarily include all the dev tools code. 
            env: ``DASH_SERVE_DEV_BUNDLES`` 
        :type dev_tools_serve_dev_bundles: bool 
 
        :param dev_tools_hot_reload: Activate hot reloading when app, assets, 
            and component files change. env: ``DASH_HOT_RELOAD`` 
        :type dev_tools_hot_reload: bool 
 
        :param dev_tools_hot_reload_interval: Interval in seconds for the 
            client to request the reload hash. Default 3. 
            env: ``DASH_HOT_RELOAD_INTERVAL`` 
        :type dev_tools_hot_reload_interval: float 
 
        :param dev_tools_hot_reload_watch_interval: Interval in seconds for the 
            server to check asset and component folders for changes. 
            Default 0.5. env: ``DASH_HOT_RELOAD_WATCH_INTERVAL`` 
        :type dev_tools_hot_reload_watch_interval: float 
 
        :param dev_tools_hot_reload_max_retry: Maximum number of failed reload 
            hash requests before failing and displaying a pop up. Default 8. 
            env: ``DASH_HOT_RELOAD_MAX_RETRY`` 
        :type dev_tools_hot_reload_max_retry: int 
 
        :param dev_tools_silence_routes_logging: Silence the `werkzeug` logger, 
            will remove all routes logging. Enabled with debugging by default 
            because hot reload hash checks generate a lot of requests. 
            env: ``DASH_SILENCE_ROUTES_LOGGING`` 
        :type dev_tools_silence_routes_logging: bool 
 
        :param dev_tools_prune_errors: Reduce tracebacks to just user code, 
            stripping out Flask and Dash pieces. Only available with debugging. 
            `True` by default, set to `False` to see the complete traceback. 
            env: ``DASH_PRUNE_ERRORS`` 
        :type dev_tools_prune_errors: bool 
 
        :return: debug 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">debug </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">debug = get_combined_config(</span><span class="s2">&quot;debug&quot;</span><span class="s0">, None, True</span><span class="s1">)</span>

        <span class="s1">dev_tools = self._setup_dev_tools(</span>
            <span class="s1">debug=debug</span><span class="s0">,</span>
            <span class="s1">ui=dev_tools_ui</span><span class="s0">,</span>
            <span class="s1">props_check=dev_tools_props_check</span><span class="s0">,</span>
            <span class="s1">serve_dev_bundles=dev_tools_serve_dev_bundles</span><span class="s0">,</span>
            <span class="s1">hot_reload=dev_tools_hot_reload</span><span class="s0">,</span>
            <span class="s1">hot_reload_interval=dev_tools_hot_reload_interval</span><span class="s0">,</span>
            <span class="s1">hot_reload_watch_interval=dev_tools_hot_reload_watch_interval</span><span class="s0">,</span>
            <span class="s1">hot_reload_max_retry=dev_tools_hot_reload_max_retry</span><span class="s0">,</span>
            <span class="s1">silence_routes_logging=dev_tools_silence_routes_logging</span><span class="s0">,</span>
            <span class="s1">prune_errors=dev_tools_prune_errors</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">dev_tools.silence_routes_logging:</span>
            <span class="s1">logging.getLogger(</span><span class="s2">&quot;werkzeug&quot;</span><span class="s1">).setLevel(logging.ERROR)</span>

        <span class="s0">if </span><span class="s1">dev_tools.hot_reload:</span>
            <span class="s1">_reload = self._hot_reload</span>
            <span class="s1">_reload.hash = generate_hash()</span>

            <span class="s3"># find_loader should return None on __main__ but doesn't</span>
            <span class="s3"># on some Python versions https://bugs.python.org/issue14710</span>
            <span class="s1">packages = [</span>
                <span class="s1">pkgutil.find_loader(x)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">list(ComponentRegistry.registry)</span>
                <span class="s0">if </span><span class="s1">x != </span><span class="s2">&quot;__main__&quot;</span>
            <span class="s1">]</span>

            <span class="s3"># # additional condition to account for AssertionRewritingHook object</span>
            <span class="s3"># # loader when running pytest</span>

            <span class="s0">if </span><span class="s2">&quot;_pytest&quot; </span><span class="s0">in </span><span class="s1">sys.modules:</span>
                <span class="s0">from </span><span class="s1">_pytest.assertion.rewrite </span><span class="s0">import </span><span class="s1">(  </span><span class="s3"># pylint: disable=import-outside-toplevel</span>
                    <span class="s1">AssertionRewritingHook</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">package </span><span class="s0">in </span><span class="s1">enumerate(packages):</span>
                    <span class="s0">if </span><span class="s1">isinstance(package</span><span class="s0">, </span><span class="s1">AssertionRewritingHook):</span>
                        <span class="s1">dash_spec = importlib.util.find_spec(</span><span class="s2">&quot;dash&quot;</span><span class="s1">)</span>
                        <span class="s1">dash_test_path = dash_spec.submodule_search_locations[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">setattr(dash_spec</span><span class="s0">, </span><span class="s2">&quot;path&quot;</span><span class="s0">, </span><span class="s1">dash_test_path)</span>
                        <span class="s1">packages[index] = dash_spec</span>

            <span class="s1">component_packages_dist = [</span>
                <span class="s1">dash_test_path</span>
                <span class="s0">if </span><span class="s1">isinstance(package</span><span class="s0">, </span><span class="s1">ModuleSpec)</span>
                <span class="s0">else </span><span class="s1">os.path.dirname(package.path)</span>
                <span class="s0">if </span><span class="s1">hasattr(package</span><span class="s0">, </span><span class="s2">&quot;path&quot;</span><span class="s1">)</span>
                <span class="s0">else </span><span class="s1">os.path.dirname(</span>
                    <span class="s1">package._path[</span><span class="s5">0</span><span class="s1">]  </span><span class="s3"># pylint: disable=protected-access</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">hasattr(package</span><span class="s0">, </span><span class="s2">&quot;_path&quot;</span><span class="s1">)</span>
                <span class="s0">else </span><span class="s1">package.filename</span>
                <span class="s0">for </span><span class="s1">package </span><span class="s0">in </span><span class="s1">packages</span>
            <span class="s1">]</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">package </span><span class="s0">in </span><span class="s1">enumerate(packages):</span>
                <span class="s0">if </span><span class="s1">hasattr(package</span><span class="s0">, </span><span class="s2">&quot;path&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s2">&quot;dash/dash&quot; </span><span class="s0">in </span><span class="s1">os.path.dirname(</span>
                    <span class="s1">package.path</span>
                <span class="s1">):</span>
                    <span class="s1">component_packages_dist[i : i + </span><span class="s5">1</span><span class="s1">] = [</span>
                        <span class="s1">os.path.join(os.path.dirname(package.path)</span><span class="s0">, </span><span class="s1">x)</span>
                        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;dcc&quot;</span><span class="s0">, </span><span class="s2">&quot;html&quot;</span><span class="s0">, </span><span class="s2">&quot;dash_table&quot;</span><span class="s1">]</span>
                    <span class="s1">]</span>

            <span class="s1">_reload.watch_thread = threading.Thread(</span>
                <span class="s1">target=</span><span class="s0">lambda</span><span class="s1">: _watch.watch(</span>
                    <span class="s1">[self.config.assets_folder] + component_packages_dist</span><span class="s0">,</span>
                    <span class="s1">self._on_assets_change</span><span class="s0">,</span>
                    <span class="s1">sleep_time=dev_tools.hot_reload_watch_interval</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">_reload.watch_thread.daemon = </span><span class="s0">True</span>
            <span class="s1">_reload.watch_thread.start()</span>

        <span class="s0">if </span><span class="s1">debug </span><span class="s0">and </span><span class="s1">dev_tools.prune_errors:</span>

            <span class="s1">@self.server.errorhandler(Exception)</span>
            <span class="s0">def </span><span class="s1">_wrap_errors(_):</span>
                <span class="s3"># find the callback invocation, if the error is from a callback</span>
                <span class="s3"># and skip the traceback up to that point</span>
                <span class="s3"># if the error didn't come from inside a callback, we won't</span>
                <span class="s3"># skip anything.</span>
                <span class="s1">tb = get_current_traceback()</span>
                <span class="s1">skip = </span><span class="s5">0</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">line </span><span class="s0">in </span><span class="s1">enumerate(tb.plaintext.splitlines()):</span>
                    <span class="s0">if </span><span class="s2">&quot;%% callback invoked %%&quot; </span><span class="s0">in </span><span class="s1">line:</span>
                        <span class="s1">skip = int((i + </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s1">)</span>
                        <span class="s0">break</span>
                <span class="s0">return </span><span class="s1">get_current_traceback(skip=skip).render_full()</span><span class="s0">, </span><span class="s5">500</span>

        <span class="s0">if </span><span class="s1">debug </span><span class="s0">and </span><span class="s1">dev_tools.ui:</span>

            <span class="s0">def </span><span class="s1">_before_request():</span>
                <span class="s1">flask.g.timing_information = {  </span><span class="s3"># pylint: disable=assigning-non-slot</span>
                    <span class="s2">&quot;__dash_server&quot;</span><span class="s1">: {</span><span class="s2">&quot;dur&quot;</span><span class="s1">: time.time()</span><span class="s0">, </span><span class="s2">&quot;desc&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
                <span class="s1">}</span>

            <span class="s0">def </span><span class="s1">_after_request(response):</span>
                <span class="s1">timing_information = flask.g.get(</span><span class="s2">&quot;timing_information&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">timing_information </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">response</span>

                <span class="s1">dash_total = timing_information.get(</span><span class="s2">&quot;__dash_server&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">dash_total </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">dash_total[</span><span class="s2">&quot;dur&quot;</span><span class="s1">] = round((time.time() - dash_total[</span><span class="s2">&quot;dur&quot;</span><span class="s1">]) * </span><span class="s5">1000</span><span class="s1">)</span>

                <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">info </span><span class="s0">in </span><span class="s1">timing_information.items():</span>

                    <span class="s1">value = name</span>
                    <span class="s0">if </span><span class="s1">info.get(</span><span class="s2">&quot;desc&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">value += </span><span class="s2">';desc=&quot;{}&quot;'</span><span class="s1">.format(info[</span><span class="s2">&quot;desc&quot;</span><span class="s1">])</span>

                    <span class="s0">if </span><span class="s1">info.get(</span><span class="s2">&quot;dur&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">value += </span><span class="s2">&quot;;dur={}&quot;</span><span class="s1">.format(info[</span><span class="s2">&quot;dur&quot;</span><span class="s1">])</span>

                    <span class="s1">response.headers.add(</span><span class="s2">&quot;Server-Timing&quot;</span><span class="s0">, </span><span class="s1">value)</span>

                <span class="s0">return </span><span class="s1">response</span>

            <span class="s1">self.server.before_request(_before_request)</span>

            <span class="s1">self.server.after_request(_after_request)</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">debug</span>
            <span class="s0">and </span><span class="s1">dev_tools.serve_dev_bundles</span>
            <span class="s0">and not </span><span class="s1">self.scripts.config.serve_locally</span>
        <span class="s1">):</span>
            <span class="s3"># Dev bundles only works locally.</span>
            <span class="s1">self.scripts.config.serve_locally = </span><span class="s0">True</span>
            <span class="s1">print(</span>
                <span class="s2">&quot;WARNING: dev bundles requested with serve_locally=False.</span><span class="s0">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;This is not supported, switching to serve_locally=True&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">debug</span>

    <span class="s3"># noinspection PyProtectedMember</span>
    <span class="s0">def </span><span class="s1">_on_assets_change(self</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">modified</span><span class="s0">, </span><span class="s1">deleted):</span>
        <span class="s1">_reload = self._hot_reload</span>
        <span class="s0">with </span><span class="s1">_reload.lock:</span>
            <span class="s1">_reload.hard = </span><span class="s0">True</span>
            <span class="s1">_reload.hash = generate_hash()</span>

            <span class="s0">if </span><span class="s1">self.config.assets_folder </span><span class="s0">in </span><span class="s1">filename:</span>
                <span class="s1">asset_path = (</span>
                    <span class="s1">os.path.relpath(</span>
                        <span class="s1">filename</span><span class="s0">,</span>
                        <span class="s1">os.path.commonprefix([self.config.assets_folder</span><span class="s0">, </span><span class="s1">filename])</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s1">.replace(</span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
                    <span class="s1">.lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>

                <span class="s1">_reload.changed_assets.append(</span>
                    <span class="s1">{</span>
                        <span class="s2">&quot;url&quot;</span><span class="s1">: self.get_asset_url(asset_path)</span><span class="s0">,</span>
                        <span class="s2">&quot;modified&quot;</span><span class="s1">: int(modified)</span><span class="s0">,</span>
                        <span class="s2">&quot;is_css&quot;</span><span class="s1">: filename.endswith(</span><span class="s2">&quot;css&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>

                <span class="s0">if </span><span class="s1">filename </span><span class="s0">not in </span><span class="s1">self._assets_files </span><span class="s0">and not </span><span class="s1">deleted:</span>
                    <span class="s1">res = self._add_assets_resource(asset_path</span><span class="s0">, </span><span class="s1">filename)</span>
                    <span class="s0">if </span><span class="s1">filename.endswith(</span><span class="s2">&quot;js&quot;</span><span class="s1">):</span>
                        <span class="s1">self.scripts.append_script(res)</span>
                    <span class="s0">elif </span><span class="s1">filename.endswith(</span><span class="s2">&quot;css&quot;</span><span class="s1">):</span>
                        <span class="s1">self.css.append_css(res)</span>

                <span class="s0">if </span><span class="s1">deleted:</span>
                    <span class="s0">if </span><span class="s1">filename </span><span class="s0">in </span><span class="s1">self._assets_files:</span>
                        <span class="s1">self._assets_files.remove(filename)</span>

                    <span class="s0">def </span><span class="s1">delete_resource(resources):</span>
                        <span class="s1">to_delete = </span><span class="s0">None</span>
                        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">resources:</span>
                            <span class="s0">if </span><span class="s1">r.get(</span><span class="s2">&quot;asset_path&quot;</span><span class="s1">) == asset_path:</span>
                                <span class="s1">to_delete = r</span>
                                <span class="s0">break</span>
                        <span class="s0">if </span><span class="s1">to_delete:</span>
                            <span class="s1">resources.remove(to_delete)</span>

                    <span class="s0">if </span><span class="s1">filename.endswith(</span><span class="s2">&quot;js&quot;</span><span class="s1">):</span>
                        <span class="s3"># pylint: disable=protected-access</span>
                        <span class="s1">delete_resource(self.scripts._resources._resources)</span>
                    <span class="s0">elif </span><span class="s1">filename.endswith(</span><span class="s2">&quot;css&quot;</span><span class="s1">):</span>
                        <span class="s3"># pylint: disable=protected-access</span>
                        <span class="s1">delete_resource(self.css._resources._resources)</span>

    <span class="s0">def </span><span class="s1">run_server(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">host=os.getenv(</span><span class="s2">&quot;HOST&quot;</span><span class="s0">, </span><span class="s2">&quot;127.0.0.1&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">port=os.getenv(</span><span class="s2">&quot;PORT&quot;</span><span class="s0">, </span><span class="s2">&quot;8050&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">proxy=os.getenv(</span><span class="s2">&quot;DASH_PROXY&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">debug=</span><span class="s0">False,</span>
        <span class="s1">dev_tools_ui=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_props_check=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_serve_dev_bundles=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload_interval=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload_watch_interval=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_hot_reload_max_retry=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_silence_routes_logging=</span><span class="s0">None,</span>
        <span class="s1">dev_tools_prune_errors=</span><span class="s0">None,</span>
        <span class="s1">**flask_run_options</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Start the flask server in local mode, you should not run this on a 
        production server, use gunicorn/waitress instead. 
 
        If a parameter can be set by an environment variable, that is listed 
        too. Values provided here take precedence over environment variables. 
 
        :param host: Host IP used to serve the application 
            env: ``HOST`` 
        :type host: string 
 
        :param port: Port used to serve the application 
            env: ``PORT`` 
        :type port: int 
 
        :param proxy: If this application will be served to a different URL 
            via a proxy configured outside of Python, you can list it here 
            as a string of the form ``&quot;{input}::{output}&quot;``, for example: 
            ``&quot;http://0.0.0.0:8050::https://my.domain.com&quot;`` 
            so that the startup message will display an accurate URL. 
            env: ``DASH_PROXY`` 
        :type proxy: string 
 
        :param debug: Set Flask debug mode and enable dev tools. 
            env: ``DASH_DEBUG`` 
        :type debug: bool 
 
        :param debug: Enable/disable all the dev tools unless overridden by the 
            arguments or environment variables. Default is ``True`` when 
            ``enable_dev_tools`` is called directly, and ``False`` when called 
            via ``run_server``. env: ``DASH_DEBUG`` 
        :type debug: bool 
 
        :param dev_tools_ui: Show the dev tools UI. env: ``DASH_UI`` 
        :type dev_tools_ui: bool 
 
        :param dev_tools_props_check: Validate the types and values of Dash 
            component props. env: ``DASH_PROPS_CHECK`` 
        :type dev_tools_props_check: bool 
 
        :param dev_tools_serve_dev_bundles: Serve the dev bundles. Production 
            bundles do not necessarily include all the dev tools code. 
            env: ``DASH_SERVE_DEV_BUNDLES`` 
        :type dev_tools_serve_dev_bundles: bool 
 
        :param dev_tools_hot_reload: Activate hot reloading when app, assets, 
            and component files change. env: ``DASH_HOT_RELOAD`` 
        :type dev_tools_hot_reload: bool 
 
        :param dev_tools_hot_reload_interval: Interval in seconds for the 
            client to request the reload hash. Default 3. 
            env: ``DASH_HOT_RELOAD_INTERVAL`` 
        :type dev_tools_hot_reload_interval: float 
 
        :param dev_tools_hot_reload_watch_interval: Interval in seconds for the 
            server to check asset and component folders for changes. 
            Default 0.5. env: ``DASH_HOT_RELOAD_WATCH_INTERVAL`` 
        :type dev_tools_hot_reload_watch_interval: float 
 
        :param dev_tools_hot_reload_max_retry: Maximum number of failed reload 
            hash requests before failing and displaying a pop up. Default 8. 
            env: ``DASH_HOT_RELOAD_MAX_RETRY`` 
        :type dev_tools_hot_reload_max_retry: int 
 
        :param dev_tools_silence_routes_logging: Silence the `werkzeug` logger, 
            will remove all routes logging. Enabled with debugging by default 
            because hot reload hash checks generate a lot of requests. 
            env: ``DASH_SILENCE_ROUTES_LOGGING`` 
        :type dev_tools_silence_routes_logging: bool 
 
        :param dev_tools_prune_errors: Reduce tracebacks to just user code, 
            stripping out Flask and Dash pieces. Only available with debugging. 
            `True` by default, set to `False` to see the complete traceback. 
            env: ``DASH_PRUNE_ERRORS`` 
        :type dev_tools_prune_errors: bool 
 
        :param flask_run_options: Given to `Flask.run` 
 
        :return: 
        &quot;&quot;&quot;</span>
        <span class="s1">debug = self.enable_dev_tools(</span>
            <span class="s1">debug</span><span class="s0">,</span>
            <span class="s1">dev_tools_ui</span><span class="s0">,</span>
            <span class="s1">dev_tools_props_check</span><span class="s0">,</span>
            <span class="s1">dev_tools_serve_dev_bundles</span><span class="s0">,</span>
            <span class="s1">dev_tools_hot_reload</span><span class="s0">,</span>
            <span class="s1">dev_tools_hot_reload_interval</span><span class="s0">,</span>
            <span class="s1">dev_tools_hot_reload_watch_interval</span><span class="s0">,</span>
            <span class="s1">dev_tools_hot_reload_max_retry</span><span class="s0">,</span>
            <span class="s1">dev_tools_silence_routes_logging</span><span class="s0">,</span>
            <span class="s1">dev_tools_prune_errors</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># Verify port value</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">port = int(port)</span>
            <span class="s0">assert </span><span class="s1">port </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">65536</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">e.args = [</span>
                <span class="s2">&quot;Expecting an integer from 1 to 65535, found port={}&quot;</span><span class="s1">.format(repr(port))</span>
            <span class="s1">]</span>
            <span class="s0">raise</span>

        <span class="s3"># so we only see the &quot;Running on&quot; message once with hot reloading</span>
        <span class="s3"># https://stackoverflow.com/a/57231282/9188800</span>
        <span class="s0">if </span><span class="s1">os.getenv(</span><span class="s2">&quot;WERKZEUG_RUN_MAIN&quot;</span><span class="s1">) != </span><span class="s2">&quot;true&quot;</span><span class="s1">:</span>
            <span class="s1">ssl_context = flask_run_options.get(</span><span class="s2">&quot;ssl_context&quot;</span><span class="s1">)</span>
            <span class="s1">protocol = </span><span class="s2">&quot;https&quot; </span><span class="s0">if </span><span class="s1">ssl_context </span><span class="s0">else </span><span class="s2">&quot;http&quot;</span>
            <span class="s1">path = self.config.requests_pathname_prefix</span>

            <span class="s0">if </span><span class="s1">proxy:</span>
                <span class="s1">served_url</span><span class="s0">, </span><span class="s1">proxied_url = map(urlparse</span><span class="s0">, </span><span class="s1">proxy.split(</span><span class="s2">&quot;::&quot;</span><span class="s1">))</span>

                <span class="s0">def </span><span class="s1">verify_url_part(served_part</span><span class="s0">, </span><span class="s1">url_part</span><span class="s0">, </span><span class="s1">part_name):</span>
                    <span class="s0">if </span><span class="s1">served_part != url_part:</span>
                        <span class="s0">raise </span><span class="s1">ProxyError(</span>
                            <span class="s2">&quot;&quot;&quot; 
                            {0}: {1} is incompatible with the proxy: 
                                {3} 
                            To see your app at {4}, 
                            you must use {0}: {2} 
                        &quot;&quot;&quot;</span><span class="s1">.format(</span>
                                <span class="s1">part_name</span><span class="s0">,</span>
                                <span class="s1">url_part</span><span class="s0">,</span>
                                <span class="s1">served_part</span><span class="s0">,</span>
                                <span class="s1">proxy</span><span class="s0">,</span>
                                <span class="s1">proxied_url.geturl()</span><span class="s0">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>

                <span class="s1">verify_url_part(served_url.scheme</span><span class="s0">, </span><span class="s1">protocol</span><span class="s0">, </span><span class="s2">&quot;protocol&quot;</span><span class="s1">)</span>
                <span class="s1">verify_url_part(served_url.hostname</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s2">&quot;host&quot;</span><span class="s1">)</span>
                <span class="s1">verify_url_part(served_url.port</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s2">&quot;port&quot;</span><span class="s1">)</span>

                <span class="s1">display_url = (</span>
                    <span class="s1">proxied_url.scheme</span><span class="s0">,</span>
                    <span class="s1">proxied_url.hostname</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s2">&quot;:{}&quot;</span><span class="s1">.format(proxied_url.port) </span><span class="s0">if </span><span class="s1">proxied_url.port </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">path</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">display_url = (protocol</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s2">&quot;:{}&quot;</span><span class="s1">.format(port)</span><span class="s0">, </span><span class="s1">path)</span>

            <span class="s1">self.logger.info(</span><span class="s2">&quot;Dash is running on %s://%s%s%s</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">*display_url)</span>

        <span class="s0">if </span><span class="s1">self.config.extra_hot_reload_paths:</span>
            <span class="s1">extra_files = flask_run_options[</span><span class="s2">&quot;extra_files&quot;</span><span class="s1">] = []</span>
            <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">self.config.extra_hot_reload_paths:</span>
                <span class="s0">if </span><span class="s1">os.path.isdir(path):</span>
                    <span class="s0">for </span><span class="s1">dirpath</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">filenames </span><span class="s0">in </span><span class="s1">os.walk(path):</span>
                        <span class="s0">for </span><span class="s1">fn </span><span class="s0">in </span><span class="s1">filenames:</span>
                            <span class="s1">extra_files.append(os.path.join(dirpath</span><span class="s0">, </span><span class="s1">fn))</span>
                <span class="s0">elif </span><span class="s1">os.path.isfile(path):</span>
                    <span class="s1">extra_files.append(path)</span>

        <span class="s1">self.server.run(host=host</span><span class="s0">, </span><span class="s1">port=port</span><span class="s0">, </span><span class="s1">debug=debug</span><span class="s0">, </span><span class="s1">**flask_run_options)</span>
</pre>
</body>
</html>