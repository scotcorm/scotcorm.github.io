<html>
<head>
<title>test_arithmetic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_arithmetic.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">timedelta</span>
<span class="s0">import </span><span class="s1">operator</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">pytz</span>

<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">IncompatibleFrequency</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_datetime64_dtype</span><span class="s0">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timedelta</span><span class="s0">,</span>
    <span class="s1">bdate_range</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.core </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">nanops</span><span class="s0">,</span>
    <span class="s1">ops</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.computation </span><span class="s0">import </span><span class="s1">expressions </span><span class="s0">as </span><span class="s1">expr</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">autouse=</span><span class="s0">True, </span><span class="s1">scope=</span><span class="s2">&quot;module&quot;</span><span class="s0">, </span><span class="s1">params=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1000000</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s2">&quot;numexpr&quot;</span><span class="s0">, </span><span class="s2">&quot;python&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">switch_numexpr_min_elements(request):</span>
    <span class="s1">_MIN_ELEMENTS = expr._MIN_ELEMENTS</span>
    <span class="s1">expr._MIN_ELEMENTS = request.param</span>
    <span class="s0">yield </span><span class="s1">request.param</span>
    <span class="s1">expr._MIN_ELEMENTS = _MIN_ELEMENTS</span>


<span class="s0">def </span><span class="s1">_permute(obj):</span>
    <span class="s0">return </span><span class="s1">obj.take(np.random.permutation(len(obj)))</span>


<span class="s0">class </span><span class="s1">TestSeriesFlexArithmetic:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;ts&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, lambda </span><span class="s1">x: x * </span><span class="s3">2</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, lambda </span><span class="s1">x: x[::</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, lambda </span><span class="s1">x: </span><span class="s3">5</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: tm.makeFloatSeries()</span><span class="s0">, lambda </span><span class="s1">x: tm.makeFloatSeries()</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;opname&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;add&quot;</span><span class="s0">, </span><span class="s2">&quot;sub&quot;</span><span class="s0">, </span><span class="s2">&quot;mul&quot;</span><span class="s0">, </span><span class="s2">&quot;floordiv&quot;</span><span class="s0">, </span><span class="s2">&quot;truediv&quot;</span><span class="s0">, </span><span class="s2">&quot;pow&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_flex_method_equivalence(self</span><span class="s0">, </span><span class="s1">opname</span><span class="s0">, </span><span class="s1">ts):</span>
        <span class="s4"># check that Series.{opname} behaves like Series.__{opname}__,</span>
        <span class="s1">tser = tm.makeTimeSeries().rename(</span><span class="s2">&quot;ts&quot;</span><span class="s1">)</span>

        <span class="s1">series = ts[</span><span class="s3">0</span><span class="s1">](tser)</span>
        <span class="s1">other = ts[</span><span class="s3">1</span><span class="s1">](tser)</span>
        <span class="s1">check_reverse = ts[</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s1">op = getattr(Series</span><span class="s0">, </span><span class="s1">opname)</span>
        <span class="s1">alt = getattr(operator</span><span class="s0">, </span><span class="s1">opname)</span>

        <span class="s1">result = op(series</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s1">expected = alt(series</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">if </span><span class="s1">check_reverse:</span>
            <span class="s1">rop = getattr(Series</span><span class="s0">, </span><span class="s2">&quot;r&quot; </span><span class="s1">+ opname)</span>
            <span class="s1">result = rop(series</span><span class="s0">, </span><span class="s1">other)</span>
            <span class="s1">expected = alt(other</span><span class="s0">, </span><span class="s1">series)</span>
            <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_flex_method_subclass_metadata_preservation(self</span><span class="s0">, </span><span class="s1">all_arithmetic_operators):</span>
        <span class="s4"># GH 13208</span>
        <span class="s0">class </span><span class="s1">MySeries(Series):</span>
            <span class="s1">_metadata = [</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>

            <span class="s1">@property</span>
            <span class="s0">def </span><span class="s1">_constructor(self):</span>
                <span class="s0">return </span><span class="s1">MySeries</span>

        <span class="s1">opname = all_arithmetic_operators</span>
        <span class="s1">op = getattr(Series</span><span class="s0">, </span><span class="s1">opname)</span>
        <span class="s1">m = MySeries([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s1">m.x = </span><span class="s3">42</span>
        <span class="s1">result = op(m</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result.x == </span><span class="s3">42</span>

    <span class="s0">def </span><span class="s1">test_flex_add_scalar_fill_value(self):</span>
        <span class="s4"># GH12723</span>
        <span class="s1">ser = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>

        <span class="s1">exp = ser.fillna(</span><span class="s3">0</span><span class="s1">).add(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">res = ser.add(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">pairings = [(Series.div</span><span class="s0">, </span><span class="s1">operator.truediv</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(Series.rdiv</span><span class="s0">, </span><span class="s1">ops.rtruediv</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>
    <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;add&quot;</span><span class="s0">, </span><span class="s2">&quot;sub&quot;</span><span class="s0">, </span><span class="s2">&quot;mul&quot;</span><span class="s0">, </span><span class="s2">&quot;pow&quot;</span><span class="s0">, </span><span class="s2">&quot;truediv&quot;</span><span class="s0">, </span><span class="s2">&quot;floordiv&quot;</span><span class="s1">]:</span>
        <span class="s1">fv = </span><span class="s3">0</span>
        <span class="s1">lop = getattr(Series</span><span class="s0">, </span><span class="s1">op)</span>
        <span class="s1">lequiv = getattr(operator</span><span class="s0">, </span><span class="s1">op)</span>
        <span class="s1">rop = getattr(Series</span><span class="s0">, </span><span class="s2">&quot;r&quot; </span><span class="s1">+ op)</span>
        <span class="s4"># bind op at definition time...</span>
        <span class="s1">requiv = </span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">op=op: getattr(operator</span><span class="s0">, </span><span class="s1">op)(y</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">pairings.append((lop</span><span class="s0">, </span><span class="s1">lequiv</span><span class="s0">, </span><span class="s1">fv))</span>
        <span class="s1">pairings.append((rop</span><span class="s0">, </span><span class="s1">requiv</span><span class="s0">, </span><span class="s1">fv))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op, equiv_op, fv&quot;</span><span class="s0">, </span><span class="s1">pairings)</span>
    <span class="s0">def </span><span class="s1">test_operators_combine(self</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">equiv_op</span><span class="s0">, </span><span class="s1">fv):</span>
        <span class="s0">def </span><span class="s1">_check_fill(meth</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s3">0</span><span class="s1">):</span>
            <span class="s1">exp_index = a.index.union(b.index)</span>
            <span class="s1">a = a.reindex(exp_index)</span>
            <span class="s1">b = b.reindex(exp_index)</span>

            <span class="s1">amask = isna(a)</span>
            <span class="s1">bmask = isna(b)</span>

            <span class="s1">exp_values = []</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(exp_index)):</span>
                <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">amask[i]:</span>
                        <span class="s0">if </span><span class="s1">bmask[i]:</span>
                            <span class="s1">exp_values.append(np.nan)</span>
                            <span class="s0">continue</span>
                        <span class="s1">exp_values.append(op(fill_value</span><span class="s0">, </span><span class="s1">b[i]))</span>
                    <span class="s0">elif </span><span class="s1">bmask[i]:</span>
                        <span class="s0">if </span><span class="s1">amask[i]:</span>
                            <span class="s1">exp_values.append(np.nan)</span>
                            <span class="s0">continue</span>
                        <span class="s1">exp_values.append(op(a[i]</span><span class="s0">, </span><span class="s1">fill_value))</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">exp_values.append(op(a[i]</span><span class="s0">, </span><span class="s1">b[i]))</span>

            <span class="s1">result = meth(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
            <span class="s1">expected = Series(exp_values</span><span class="s0">, </span><span class="s1">exp_index)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">a = Series([np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=np.arange(</span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">b = Series([np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=np.arange(</span><span class="s3">6</span><span class="s1">))</span>

        <span class="s1">result = op(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">exp = equiv_op(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
        <span class="s1">_check_fill(op</span><span class="s0">, </span><span class="s1">equiv_op</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">fill_value=fv)</span>
        <span class="s4"># should accept axis=0 or axis='rows'</span>
        <span class="s1">op(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSeriesArithmetic:</span>
    <span class="s4"># Some of these may end up in tests/arithmetic, but are not yet sorted</span>

    <span class="s0">def </span><span class="s1">test_add_series_with_period_index(self):</span>
        <span class="s1">rng = pd.period_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s2">&quot;1/1/2010&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">ts = Series(np.random.randn(len(rng))</span><span class="s0">, </span><span class="s1">index=rng)</span>

        <span class="s1">result = ts + ts[::</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">expected = ts + ts</span>
        <span class="s1">expected.iloc[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = ts + _permute(ts[::</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Input has different freq=D from Period</span><span class="s0">\\</span><span class="s2">(freq=A-DEC</span><span class="s0">\\</span><span class="s2">)&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(IncompatibleFrequency</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts + ts.asfreq(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;end&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;target_add,input_value,expected_value&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;!&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;hello&quot;</span><span class="s0">, </span><span class="s2">&quot;world&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;hello!&quot;</span><span class="s0">, </span><span class="s2">&quot;world!&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;hello&quot;</span><span class="s0">, </span><span class="s2">&quot;world&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;hellom&quot;</span><span class="s0">, </span><span class="s2">&quot;worldm&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_string_addition(self</span><span class="s0">, </span><span class="s1">target_add</span><span class="s0">, </span><span class="s1">input_value</span><span class="s0">, </span><span class="s1">expected_value):</span>
        <span class="s4"># GH28658 - ensure adding 'm' does not raise an error</span>
        <span class="s1">a = Series(input_value)</span>

        <span class="s1">result = a + target_add</span>
        <span class="s1">expected = Series(expected_value)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_divmod(self):</span>
        <span class="s4"># GH#25557</span>
        <span class="s1">a = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span>
        <span class="s1">b = Series([</span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">])</span>

        <span class="s1">result = a.divmod(b)</span>
        <span class="s1">expected = divmod(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">result = a.rdivmod(b)</span>
        <span class="s1">expected = divmod(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected[</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">range(</span><span class="s3">9</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_series_integer_mod(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s4"># GH#24396</span>
        <span class="s1">s1 = Series(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">s2 = Series(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">index=index)</span>

        <span class="s1">msg = </span><span class="s2">&quot;not all arguments converted during string formatting&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s2 % s1</span>

    <span class="s0">def </span><span class="s1">test_add_with_duplicate_index(self):</span>
        <span class="s4"># GH14227</span>
        <span class="s1">s1 = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">s2 = Series([</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">result = s1 + s2</span>
        <span class="s1">expected = Series([</span><span class="s3">11</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_add_na_handling(self):</span>
        <span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">date</span>
        <span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>

        <span class="s1">ser = Series(</span>
            <span class="s1">[Decimal(</span><span class="s2">&quot;1.3&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">&quot;2.3&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">index=[date(</span><span class="s3">2012</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">date(</span><span class="s3">2012</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span>
        <span class="s1">)</span>

        <span class="s1">result = ser + ser.shift(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">result2 = ser.shift(</span><span class="s3">1</span><span class="s1">) + ser</span>
        <span class="s0">assert </span><span class="s1">isna(result[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">isna(result2[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_add_corner_cases(self</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s1">empty = Series([]</span><span class="s0">, </span><span class="s1">index=Index([])</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>

        <span class="s1">result = datetime_series + empty</span>
        <span class="s0">assert </span><span class="s1">np.isnan(result).all()</span>

        <span class="s1">result = empty + empty.copy()</span>
        <span class="s0">assert </span><span class="s1">len(result) == </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">test_add_float_plus_int(self</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s4"># float + int</span>
        <span class="s1">int_ts = datetime_series.astype(int)[:-</span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">added = datetime_series + int_ts</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">datetime_series.values[:-</span><span class="s3">5</span><span class="s1">] + int_ts.values</span><span class="s0">,</span>
            <span class="s1">index=datetime_series.index[:-</span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s2">&quot;ts&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(added[:-</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_mul_empty_int_corner_case(self):</span>
        <span class="s1">s1 = Series([]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">s2 = Series({</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">0.0</span><span class="s1">})</span>
        <span class="s1">tm.assert_series_equal(s1 * s2</span><span class="s0">, </span><span class="s1">Series([np.nan]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;x&quot;</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_sub_datetimelike_align(self):</span>
        <span class="s4"># GH#7500</span>
        <span class="s4"># datetimelike ops need to align</span>
        <span class="s1">dt = Series(date_range(</span><span class="s2">&quot;2012-1-1&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">))</span>
        <span class="s1">dt.iloc[</span><span class="s3">2</span><span class="s1">] = np.nan</span>
        <span class="s1">dt2 = dt[::-</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s1">expected = Series([timedelta(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.NaT])</span>
        <span class="s4"># name is reset</span>
        <span class="s1">result = dt2 - dt</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series(expected</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">result = (dt2.to_frame() - dt.to_frame())[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_alignment_doesnt_change_tz(self):</span>
        <span class="s4"># GH#33671</span>
        <span class="s1">dti = date_range(</span><span class="s2">&quot;2016-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;CET&quot;</span><span class="s1">)</span>
        <span class="s1">dti_utc = dti.tz_convert(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">ser = Series(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">index=dti)</span>
        <span class="s1">ser_utc = Series(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">index=dti_utc)</span>

        <span class="s4"># we don't care about the result, just that original indexes are unchanged</span>
        <span class="s1">ser * ser_utc</span>

        <span class="s0">assert </span><span class="s1">ser.index </span><span class="s0">is </span><span class="s1">dti</span>
        <span class="s0">assert </span><span class="s1">ser_utc.index </span><span class="s0">is </span><span class="s1">dti_utc</span>

    <span class="s0">def </span><span class="s1">test_arithmetic_with_duplicate_index(self):</span>

        <span class="s4"># GH#8363</span>
        <span class="s4"># integer ops with a non-unique index</span>
        <span class="s1">index = [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">ser = Series(np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">other = Series(np.arange(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">result = ser - other</span>
        <span class="s1">expected = Series(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># GH#8363</span>
        <span class="s4"># datetime ops with a non-unique index</span>
        <span class="s1">ser = Series(date_range(</span><span class="s2">&quot;20130101 09:00:00&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">other = Series(date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">result = ser - other</span>
        <span class="s1">expected = Series(Timedelta(</span><span class="s2">&quot;9 hours&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s4"># ------------------------------------------------------------------</span>
<span class="s4"># Comparisons</span>


<span class="s0">class </span><span class="s1">TestSeriesFlexComparison:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;axis&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, None, </span><span class="s2">&quot;index&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_comparison_flex_basic(self</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">comparison_op):</span>
        <span class="s1">left = Series(np.random.randn(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">right = Series(np.random.randn(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">result = getattr(left</span><span class="s0">, </span><span class="s1">comparison_op.__name__)(right</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">expected = comparison_op(left</span><span class="s0">, </span><span class="s1">right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_comparison_bad_axis(self</span><span class="s0">, </span><span class="s1">comparison_op):</span>
        <span class="s1">left = Series(np.random.randn(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">right = Series(np.random.randn(</span><span class="s3">10</span><span class="s1">))</span>

        <span class="s1">msg = </span><span class="s2">&quot;No axis named 1 for object type&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">getattr(left</span><span class="s0">, </span><span class="s1">comparison_op.__name__)(right</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;values, op&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">([</span><span class="s0">False, False, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;eq&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">True, True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;ne&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">False, False, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;le&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">False, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;lt&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">False, True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;ge&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">False, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;gt&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_comparison_flex_alignment(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s1">left = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">right = Series([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;bcd&quot;</span><span class="s1">))</span>
        <span class="s1">result = getattr(left</span><span class="s0">, </span><span class="s1">op)(right)</span>
        <span class="s1">expected = Series(values</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;values, op, fill_value&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">([</span><span class="s0">False, False, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;eq&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">True, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;ne&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">False, False, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;le&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">False, False, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;lt&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">True, True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;ge&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s0">True, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;gt&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_comparison_flex_alignment_fill(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">fill_value):</span>
        <span class="s1">left = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">right = Series([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;bcd&quot;</span><span class="s1">))</span>
        <span class="s1">result = getattr(left</span><span class="s0">, </span><span class="s1">op)(right</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s1">expected = Series(values</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestSeriesComparison:</span>
    <span class="s0">def </span><span class="s1">test_comparison_different_length(self):</span>
        <span class="s1">a = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
        <span class="s1">b = Series([</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;only compare identically-labeled Series&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">a &lt; b</span>

        <span class="s1">a = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">b = Series([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">a == b</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;opname&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;eq&quot;</span><span class="s0">, </span><span class="s2">&quot;ne&quot;</span><span class="s0">, </span><span class="s2">&quot;gt&quot;</span><span class="s0">, </span><span class="s2">&quot;lt&quot;</span><span class="s0">, </span><span class="s2">&quot;ge&quot;</span><span class="s0">, </span><span class="s2">&quot;le&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_ser_flex_cmp_return_dtypes(self</span><span class="s0">, </span><span class="s1">opname):</span>
        <span class="s4"># GH#15115</span>
        <span class="s1">ser = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=range(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">const = </span><span class="s3">2</span>
        <span class="s1">result = getattr(ser</span><span class="s0">, </span><span class="s1">opname)(const).dtypes</span>
        <span class="s1">expected = np.dtype(</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;opname&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;eq&quot;</span><span class="s0">, </span><span class="s2">&quot;ne&quot;</span><span class="s0">, </span><span class="s2">&quot;gt&quot;</span><span class="s0">, </span><span class="s2">&quot;lt&quot;</span><span class="s0">, </span><span class="s2">&quot;ge&quot;</span><span class="s0">, </span><span class="s2">&quot;le&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_ser_flex_cmp_return_dtypes_empty(self</span><span class="s0">, </span><span class="s1">opname):</span>
        <span class="s4"># GH#15115 empty Series case</span>
        <span class="s1">ser = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=range(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">empty = ser.iloc[:</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">const = </span><span class="s3">2</span>
        <span class="s1">result = getattr(empty</span><span class="s0">, </span><span class="s1">opname)(const).dtypes</span>
        <span class="s1">expected = np.dtype(</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;names&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;baz&quot;</span><span class="s0">, </span><span class="s2">&quot;baz&quot;</span><span class="s0">, </span><span class="s2">&quot;baz&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_ser_cmp_result_names(self</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">comparison_op):</span>
        <span class="s4"># datetime64 dtype</span>
        <span class="s1">op = comparison_op</span>
        <span class="s1">dti = date_range(</span><span class="s2">&quot;1949-06-07 03:00:00&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">name=names[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">ser = Series(dti).rename(names[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">dti)</span>
        <span class="s0">assert </span><span class="s1">result.name == names[</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s4"># datetime64tz dtype</span>
        <span class="s1">dti = dti.tz_localize(</span><span class="s2">&quot;US/Central&quot;</span><span class="s1">)</span>
        <span class="s1">dti = pd.DatetimeIndex(dti</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;infer&quot;</span><span class="s1">)  </span><span class="s4"># freq not preserved by tz_localize</span>
        <span class="s1">ser = Series(dti).rename(names[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">dti)</span>
        <span class="s0">assert </span><span class="s1">result.name == names[</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s4"># timedelta64 dtype</span>
        <span class="s1">tdi = dti - dti.shift(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">ser = Series(tdi).rename(names[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">tdi)</span>
        <span class="s0">assert </span><span class="s1">result.name == names[</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s4"># interval dtype</span>
        <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[operator.eq</span><span class="s0">, </span><span class="s1">operator.ne]:</span>
            <span class="s4"># interval dtype comparisons not yet implemented</span>
            <span class="s1">ii = pd.interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">name=names[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">ser = Series(ii).rename(names[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">ii)</span>
            <span class="s0">assert </span><span class="s1">result.name == names[</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s4"># categorical</span>
        <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[operator.eq</span><span class="s0">, </span><span class="s1">operator.ne]:</span>
            <span class="s4"># categorical dtype comparisons raise for inequalities</span>
            <span class="s1">cidx = tdi.astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
            <span class="s1">ser = Series(cidx).rename(names[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">cidx)</span>
            <span class="s0">assert </span><span class="s1">result.name == names[</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_comparisons(self):</span>
        <span class="s1">left = np.random.randn(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">right = np.random.randn(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">left[:</span><span class="s3">3</span><span class="s1">] = np.nan</span>

        <span class="s1">result = nanops.nangt(left</span><span class="s0">, </span><span class="s1">right)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">expected = (left &gt; right).astype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">expected[:</span><span class="s3">3</span><span class="s1">] = np.nan</span>

        <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">s = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
        <span class="s1">s2 = Series([</span><span class="s0">False, True, False</span><span class="s1">])</span>

        <span class="s4"># it works!</span>
        <span class="s1">exp = Series([</span><span class="s0">False, False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(s == s2</span><span class="s0">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_series_equal(s2 == s</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s4"># -----------------------------------------------------------------</span>
    <span class="s4"># Categorical Dtype Comparisons</span>

    <span class="s0">def </span><span class="s1">test_categorical_comparisons(self):</span>
        <span class="s4"># GH#8938</span>
        <span class="s4"># allow equality comparisons</span>
        <span class="s1">a = Series(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
        <span class="s1">b = Series(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s1">c = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;cc&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s1">d = Series(list(</span><span class="s2">&quot;acb&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s1">e = Categorical(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">f = Categorical(list(</span><span class="s2">&quot;acb&quot;</span><span class="s1">))</span>

        <span class="s4"># vs scalar</span>
        <span class="s0">assert not </span><span class="s1">(a == </span><span class="s2">&quot;a&quot;</span><span class="s1">).all()</span>
        <span class="s0">assert </span><span class="s1">((a != </span><span class="s2">&quot;a&quot;</span><span class="s1">) == ~(a == </span><span class="s2">&quot;a&quot;</span><span class="s1">)).all()</span>

        <span class="s0">assert not </span><span class="s1">(</span><span class="s2">&quot;a&quot; </span><span class="s1">== a).all()</span>
        <span class="s0">assert </span><span class="s1">(a == </span><span class="s2">&quot;a&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">(</span><span class="s2">&quot;a&quot; </span><span class="s1">== a)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert not </span><span class="s1">(</span><span class="s2">&quot;a&quot; </span><span class="s1">!= a)[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s4"># vs list-like</span>
        <span class="s0">assert </span><span class="s1">(a == a).all()</span>
        <span class="s0">assert not </span><span class="s1">(a != a).all()</span>

        <span class="s0">assert </span><span class="s1">(a == list(a)).all()</span>
        <span class="s0">assert </span><span class="s1">(a == b).all()</span>
        <span class="s0">assert </span><span class="s1">(b == a).all()</span>
        <span class="s0">assert </span><span class="s1">((~(a == b)) == (a != b)).all()</span>
        <span class="s0">assert </span><span class="s1">((~(b == a)) == (b != a)).all()</span>

        <span class="s0">assert not </span><span class="s1">(a == c).all()</span>
        <span class="s0">assert not </span><span class="s1">(c == a).all()</span>
        <span class="s0">assert not </span><span class="s1">(a == d).all()</span>
        <span class="s0">assert not </span><span class="s1">(d == a).all()</span>

        <span class="s4"># vs a cat-like</span>
        <span class="s0">assert </span><span class="s1">(a == e).all()</span>
        <span class="s0">assert </span><span class="s1">(e == a).all()</span>
        <span class="s0">assert not </span><span class="s1">(a == f).all()</span>
        <span class="s0">assert not </span><span class="s1">(f == a).all()</span>

        <span class="s0">assert </span><span class="s1">(~(a == e) == (a != e)).all()</span>
        <span class="s0">assert </span><span class="s1">(~(e == a) == (e != a)).all()</span>
        <span class="s0">assert </span><span class="s1">(~(a == f) == (a != f)).all()</span>
        <span class="s0">assert </span><span class="s1">(~(f == a) == (f != a)).all()</span>

        <span class="s4"># non-equality is not comparable</span>
        <span class="s1">msg = </span><span class="s2">&quot;can only compare equality or not&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">a &lt; b</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">b &lt; a</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">a &gt; b</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">b &gt; a</span>

    <span class="s0">def </span><span class="s1">test_unequal_categorical_comparison_raises_type_error(self):</span>
        <span class="s4"># unequal comparison should raise for unordered cats</span>
        <span class="s1">cat = Series(Categorical(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)))</span>
        <span class="s1">msg = </span><span class="s2">&quot;can only compare equality or not&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">cat &gt; </span><span class="s2">&quot;b&quot;</span>

        <span class="s1">cat = Series(Categorical(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">cat &gt; </span><span class="s2">&quot;b&quot;</span>

        <span class="s4"># https://github.com/pandas-dev/pandas/issues/9836#issuecomment-92123057</span>
        <span class="s4"># and following comparisons with scalars not in categories should raise</span>
        <span class="s4"># for unequal comps, but not for equal/not equal</span>
        <span class="s1">cat = Series(Categorical(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">))</span>

        <span class="s1">msg = </span><span class="s2">&quot;Invalid comparison between dtype=category and str&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">cat &lt; </span><span class="s2">&quot;d&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">cat &gt; </span><span class="s2">&quot;d&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s2">&quot;d&quot; </span><span class="s1">&lt; cat</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s2">&quot;d&quot; </span><span class="s1">&gt; cat</span>

        <span class="s1">tm.assert_series_equal(cat == </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s1">Series([</span><span class="s0">False, False, False</span><span class="s1">]))</span>
        <span class="s1">tm.assert_series_equal(cat != </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s1">Series([</span><span class="s0">True, True, True</span><span class="s1">]))</span>

    <span class="s4"># -----------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">test_comparison_tuples(self):</span>
        <span class="s4"># GH#11339</span>
        <span class="s4"># comparisons vs tuple</span>
        <span class="s1">s = Series([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)])</span>

        <span class="s1">result = s == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">False, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s != (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s == (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s != (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">True, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">s = Series([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)])</span>

        <span class="s1">result = s == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">True, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s != (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_comparison_frozenset(self):</span>
        <span class="s1">ser = Series([frozenset([</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">frozenset([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])])</span>

        <span class="s1">result = ser == frozenset([</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">expected = Series([</span><span class="s0">True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_comparison_operators_with_nas(self</span><span class="s0">, </span><span class="s1">comparison_op):</span>
        <span class="s1">ser = Series(bdate_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">ser[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>

        <span class="s4"># test that comparisons work</span>
        <span class="s1">val = ser[</span><span class="s3">5</span><span class="s1">]</span>

        <span class="s1">result = comparison_op(ser</span><span class="s0">, </span><span class="s1">val)</span>
        <span class="s1">expected = comparison_op(ser.dropna()</span><span class="s0">, </span><span class="s1">val).reindex(ser.index)</span>

        <span class="s0">if </span><span class="s1">comparison_op </span><span class="s0">is </span><span class="s1">operator.ne:</span>
            <span class="s1">expected = expected.fillna(</span><span class="s0">True</span><span class="s1">).astype(bool)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = expected.fillna(</span><span class="s0">False</span><span class="s1">).astype(bool)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_ne(self):</span>
        <span class="s1">ts = Series([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">expected = [</span><span class="s0">True, True, False, True, True</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">tm.equalContents(ts.index != </span><span class="s3">5</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">assert </span><span class="s1">tm.equalContents(~(ts.index == </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;left, right&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Series([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Series([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_comp_ops_df_compat(self</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">frame_or_series):</span>
        <span class="s4"># GH 1134</span>
        <span class="s1">msg = </span><span class="s2">f&quot;Can only compare identically-labeled </span><span class="s0">{</span><span class="s1">frame_or_series.__name__</span><span class="s0">} </span><span class="s2">objects&quot;</span>
        <span class="s0">if </span><span class="s1">frame_or_series </span><span class="s0">is not </span><span class="s1">Series:</span>
            <span class="s1">left = left.to_frame()</span>
            <span class="s1">right = right.to_frame()</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">left == right</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">right == left</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">left != right</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">right != left</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">left &lt; right</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">right &lt; left</span>

    <span class="s0">def </span><span class="s1">test_compare_series_interval_keyword(self):</span>
        <span class="s4"># GH#25338</span>
        <span class="s1">ser = Series([</span><span class="s2">&quot;IntervalA&quot;</span><span class="s0">, </span><span class="s2">&quot;IntervalB&quot;</span><span class="s0">, </span><span class="s2">&quot;IntervalC&quot;</span><span class="s1">])</span>
        <span class="s1">result = ser == </span><span class="s2">&quot;IntervalA&quot;</span>
        <span class="s1">expected = Series([</span><span class="s0">True, False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s4"># ------------------------------------------------------------------</span>
<span class="s4"># Unsorted</span>
<span class="s4">#  These arithmetic tests were previously in other files, eventually</span>
<span class="s4">#  should be parametrized and put into tests.arithmetic</span>


<span class="s0">class </span><span class="s1">TestTimeSeriesArithmetic:</span>
    <span class="s0">def </span><span class="s1">test_series_add_tz_mismatch_converts_to_utc(self):</span>
        <span class="s1">rng = date_range(</span><span class="s2">&quot;1/1/2011&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;utc&quot;</span><span class="s1">)</span>

        <span class="s1">perm = np.random.permutation(</span><span class="s3">100</span><span class="s1">)[:</span><span class="s3">90</span><span class="s1">]</span>
        <span class="s1">ser1 = Series(</span>
            <span class="s1">np.random.randn(</span><span class="s3">90</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=rng.take(perm).tz_convert(</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">perm = np.random.permutation(</span><span class="s3">100</span><span class="s1">)[:</span><span class="s3">90</span><span class="s1">]</span>
        <span class="s1">ser2 = Series(</span>
            <span class="s1">np.random.randn(</span><span class="s3">90</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=rng.take(perm).tz_convert(</span><span class="s2">&quot;Europe/Berlin&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">result = ser1 + ser2</span>

        <span class="s1">uts1 = ser1.tz_convert(</span><span class="s2">&quot;utc&quot;</span><span class="s1">)</span>
        <span class="s1">uts2 = ser2.tz_convert(</span><span class="s2">&quot;utc&quot;</span><span class="s1">)</span>
        <span class="s1">expected = uts1 + uts2</span>

        <span class="s0">assert </span><span class="s1">result.index.tz == pytz.UTC</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_series_add_aware_naive_raises(self):</span>
        <span class="s1">rng = date_range(</span><span class="s2">&quot;1/1/2011&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s1">)</span>
        <span class="s1">ser = Series(np.random.randn(len(rng))</span><span class="s0">, </span><span class="s1">index=rng)</span>

        <span class="s1">ser_utc = ser.tz_localize(</span><span class="s2">&quot;utc&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Cannot join tz-naive with tz-aware DatetimeIndex&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(Exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser + ser_utc</span>

        <span class="s0">with </span><span class="s1">pytest.raises(Exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser_utc + ser</span>

    <span class="s0">def </span><span class="s1">test_datetime_understood(self):</span>
        <span class="s4"># Ensures it doesn't fail to create the right series</span>
        <span class="s4"># reported in issue#16726</span>
        <span class="s1">series = Series(date_range(</span><span class="s2">&quot;2012-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">offset = pd.offsets.DateOffset(days=</span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">result = series - offset</span>
        <span class="s1">expected = Series(pd.to_datetime([</span><span class="s2">&quot;2011-12-26&quot;</span><span class="s0">, </span><span class="s2">&quot;2011-12-27&quot;</span><span class="s0">, </span><span class="s2">&quot;2011-12-28&quot;</span><span class="s1">]))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_align_date_objects_with_datetimeindex(self):</span>
        <span class="s1">rng = date_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">ts = Series(np.random.randn(</span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=rng)</span>

        <span class="s1">ts_slice = ts[</span><span class="s3">5</span><span class="s1">:]</span>
        <span class="s1">ts2 = ts_slice.copy()</span>
        <span class="s1">ts2.index = [x.date() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">ts2.index]</span>

        <span class="s1">result = ts + ts2</span>
        <span class="s1">result2 = ts2 + ts</span>
        <span class="s1">expected = ts + ts[</span><span class="s3">5</span><span class="s1">:]</span>
        <span class="s1">expected.index = expected.index._with_freq(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_series_equal(result2</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestNamePreservation:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;box&quot;</span><span class="s0">, </span><span class="s1">[list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">np.array</span><span class="s0">, </span><span class="s1">Index</span><span class="s0">, </span><span class="s1">Series</span><span class="s0">, </span><span class="s1">pd.array])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;flex&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_ops_name_retention(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">flex</span><span class="s0">, </span><span class="s1">box</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">all_binary_operators</span>
    <span class="s1">):</span>
        <span class="s4"># GH#33930 consistent name renteiton</span>
        <span class="s1">op = all_binary_operators</span>

        <span class="s1">left = Series(range(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=names[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">right = Series(range(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=names[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">name = op.__name__.strip(</span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s1">is_logical = name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;and&quot;</span><span class="s0">, </span><span class="s2">&quot;rand&quot;</span><span class="s0">, </span><span class="s2">&quot;xor&quot;</span><span class="s0">, </span><span class="s2">&quot;rxor&quot;</span><span class="s0">, </span><span class="s2">&quot;or&quot;</span><span class="s0">, </span><span class="s2">&quot;ror&quot;</span><span class="s1">]</span>
        <span class="s1">is_rlogical = is_logical </span><span class="s0">and </span><span class="s1">name.startswith(</span><span class="s2">&quot;r&quot;</span><span class="s1">)</span>

        <span class="s1">right = box(right)</span>
        <span class="s0">if </span><span class="s1">flex:</span>
            <span class="s0">if </span><span class="s1">is_logical:</span>
                <span class="s4"># Series doesn't have these as flex methods</span>
                <span class="s0">return</span>
            <span class="s1">result = getattr(left</span><span class="s0">, </span><span class="s1">name)(right)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># GH#37374 logical ops behaving as set ops deprecated</span>
            <span class="s1">warn = FutureWarning </span><span class="s0">if </span><span class="s1">is_rlogical </span><span class="s0">and </span><span class="s1">box </span><span class="s0">is </span><span class="s1">Index </span><span class="s0">else None</span>
            <span class="s1">msg = </span><span class="s2">&quot;operating as a set operation is deprecated&quot;</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s4"># stacklevel is correct for Index op, not reversed op</span>
                <span class="s1">result = op(left</span><span class="s0">, </span><span class="s1">right)</span>

        <span class="s0">if </span><span class="s1">box </span><span class="s0">is </span><span class="s1">Index </span><span class="s0">and </span><span class="s1">is_rlogical:</span>
            <span class="s4"># Index treats these as set operators, so does not defer</span>
            <span class="s0">assert </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Index)</span>
            <span class="s0">return</span>

        <span class="s0">assert </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Series)</span>
        <span class="s0">if </span><span class="s1">box </span><span class="s0">in </span><span class="s1">[Index</span><span class="s0">, </span><span class="s1">Series]:</span>
            <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is </span><span class="s1">names[</span><span class="s3">2</span><span class="s1">] </span><span class="s0">or </span><span class="s1">result.name == names[</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is </span><span class="s1">names[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">or </span><span class="s1">result.name == names[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_binop_maybe_preserve_name(self</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s4"># names match, preserve</span>
        <span class="s1">result = datetime_series * datetime_series</span>
        <span class="s0">assert </span><span class="s1">result.name == datetime_series.name</span>
        <span class="s1">result = datetime_series.mul(datetime_series)</span>
        <span class="s0">assert </span><span class="s1">result.name == datetime_series.name</span>

        <span class="s1">result = datetime_series * datetime_series[:-</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">result.name == datetime_series.name</span>

        <span class="s4"># names don't match, don't preserve</span>
        <span class="s1">cp = datetime_series.copy()</span>
        <span class="s1">cp.name = </span><span class="s2">&quot;something else&quot;</span>
        <span class="s1">result = datetime_series + cp</span>
        <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is None</span>
        <span class="s1">result = datetime_series.add(cp)</span>
        <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is None</span>

        <span class="s1">ops = [</span><span class="s2">&quot;add&quot;</span><span class="s0">, </span><span class="s2">&quot;sub&quot;</span><span class="s0">, </span><span class="s2">&quot;mul&quot;</span><span class="s0">, </span><span class="s2">&quot;div&quot;</span><span class="s0">, </span><span class="s2">&quot;truediv&quot;</span><span class="s0">, </span><span class="s2">&quot;floordiv&quot;</span><span class="s0">, </span><span class="s2">&quot;mod&quot;</span><span class="s0">, </span><span class="s2">&quot;pow&quot;</span><span class="s1">]</span>
        <span class="s1">ops = ops + [</span><span class="s2">&quot;r&quot; </span><span class="s1">+ op </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops]</span>
        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops:</span>
            <span class="s4"># names match, preserve</span>
            <span class="s1">ser = datetime_series.copy()</span>
            <span class="s1">result = getattr(ser</span><span class="s0">, </span><span class="s1">op)(ser)</span>
            <span class="s0">assert </span><span class="s1">result.name == datetime_series.name</span>

            <span class="s4"># names don't match, don't preserve</span>
            <span class="s1">cp = datetime_series.copy()</span>
            <span class="s1">cp.name = </span><span class="s2">&quot;changed&quot;</span>
            <span class="s1">result = getattr(ser</span><span class="s0">, </span><span class="s1">op)(cp)</span>
            <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is None</span>

    <span class="s0">def </span><span class="s1">test_scalarop_preserve_name(self</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s1">result = datetime_series * </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">result.name == datetime_series.name</span>


<span class="s0">class </span><span class="s1">TestInplaceOperations:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;dtype1, dtype2, dtype_expected, dtype_mul&quot;</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_series_inplace_ops(self</span><span class="s0">, </span><span class="s1">dtype1</span><span class="s0">, </span><span class="s1">dtype2</span><span class="s0">, </span><span class="s1">dtype_expected</span><span class="s0">, </span><span class="s1">dtype_mul):</span>
        <span class="s4"># GH 37910</span>

        <span class="s1">ser1 = Series([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype1)</span>
        <span class="s1">ser2 = Series([</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype2)</span>
        <span class="s1">ser1 += ser2</span>
        <span class="s1">expected = Series([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype_expected)</span>
        <span class="s1">tm.assert_series_equal(ser1</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">ser1 -= ser2</span>
        <span class="s1">expected = Series([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype_expected)</span>
        <span class="s1">tm.assert_series_equal(ser1</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">ser1 *= ser2</span>
        <span class="s1">expected = Series([</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype_mul)</span>
        <span class="s1">tm.assert_series_equal(ser1</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_none_comparison(series_with_simple_index):</span>
    <span class="s1">series = series_with_simple_index</span>

    <span class="s0">if </span><span class="s1">len(series) &lt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s2">&quot;Test doesn't make sense on empty data&quot;</span><span class="s1">)</span>

    <span class="s4"># bug brought up by #1079</span>
    <span class="s4"># changed from TypeError in 0.17.0</span>
    <span class="s1">series.iloc[</span><span class="s3">0</span><span class="s1">] = np.nan</span>

    <span class="s4"># noinspection PyComparisonWithNone</span>
    <span class="s1">result = series == </span><span class="s0">None  </span><span class="s4"># noqa:E711</span>
    <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s4"># noinspection PyComparisonWithNone</span>
    <span class="s1">result = series != </span><span class="s0">None  </span><span class="s4"># noqa:E711</span>
    <span class="s0">assert </span><span class="s1">result.iat[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">result.iat[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">result = </span><span class="s0">None </span><span class="s1">== series  </span><span class="s4"># noqa:E711</span>
    <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">result = </span><span class="s0">None </span><span class="s1">!= series  </span><span class="s4"># noqa:E711</span>
    <span class="s0">assert </span><span class="s1">result.iat[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">result.iat[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">is_datetime64_dtype(series.dtype) </span><span class="s0">or </span><span class="s1">is_datetime64tz_dtype(series.dtype):</span>
        <span class="s4"># Following DatetimeIndex (and Timestamp) convention,</span>
        <span class="s4"># inequality comparisons with Series[datetime64] raise</span>
        <span class="s1">msg = </span><span class="s2">&quot;Invalid comparison&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">None </span><span class="s1">&gt; series</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">series &gt; </span><span class="s0">None</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = </span><span class="s0">None </span><span class="s1">&gt; series</span>
        <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s1">result = series &lt; </span><span class="s0">None</span>
        <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert not </span><span class="s1">result.iat[</span><span class="s3">1</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_series_varied_multiindex_alignment():</span>
    <span class="s4"># GH 20414</span>
    <span class="s1">s1 = Series(</span>
        <span class="s1">range(</span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">index=pd.MultiIndex.from_product(</span>
            <span class="s1">[list(</span><span class="s2">&quot;ab&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;xy&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;ab&quot;</span><span class="s0">, </span><span class="s2">&quot;xy&quot;</span><span class="s0">, </span><span class="s2">&quot;num&quot;</span><span class="s1">]</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">s2 = Series(</span>
        <span class="s1">[</span><span class="s3">1000 </span><span class="s1">* i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">index=pd.MultiIndex.from_product([list(</span><span class="s2">&quot;xy&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;xy&quot;</span><span class="s0">, </span><span class="s2">&quot;num&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">result = s1.loc[pd.IndexSlice[[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:]] + s2</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">[</span><span class="s3">1000</span><span class="s0">, </span><span class="s3">2001</span><span class="s0">, </span><span class="s3">3002</span><span class="s0">, </span><span class="s3">4003</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=pd.MultiIndex.from_tuples(</span>
            <span class="s1">[(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">names=[</span><span class="s2">&quot;ab&quot;</span><span class="s0">, </span><span class="s2">&quot;xy&quot;</span><span class="s0">, </span><span class="s2">&quot;num&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>