<html>
<head>
<title>test_c_parser_only.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_c_parser_only.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests that apply specifically to the CParser. Unless specifically stated 
as a CParser-specific issue, the goal is to eventually move as many of 
these tests out of this module as soon as the Python parser can accept 
further arguments when parsing. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BytesIO</span><span class="s2">,</span>
    <span class="s1">StringIO</span><span class="s2">,</span>
    <span class="s1">TextIOWrapper</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">mmap</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">tarfile</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">IS64</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">ParserError</span>
<span class="s2">import </span><span class="s1">pandas.util._test_decorators </span><span class="s2">as </span><span class="s1">td</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">concat</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;malformed&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;1</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r </span><span class="s3">1</span><span class="s2">\r </span><span class="s3">1</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;1</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r </span><span class="s3">1</span><span class="s2">\r </span><span class="s3">1</span><span class="s2">\r</span><span class="s3">11</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;1</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r </span><span class="s3">1</span><span class="s2">\r </span><span class="s3">1</span><span class="s2">\r</span><span class="s3">11</span><span class="s2">\r</span><span class="s3">1</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">ids=[</span><span class="s3">&quot;words pointer&quot;</span><span class="s2">, </span><span class="s3">&quot;stream pointer&quot;</span><span class="s2">, </span><span class="s3">&quot;lines pointer&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_buffer_overflow(c_parser_only</span><span class="s2">, </span><span class="s1">malformed):</span>
    <span class="s4"># see gh-9205: test certain malformed input files that cause</span>
    <span class="s4"># buffer overflows in tokenizer.c</span>
    <span class="s1">msg = </span><span class="s3">&quot;Buffer overflow caught - possible malformed input file.&quot;</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ParserError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(StringIO(malformed))</span>


<span class="s2">def </span><span class="s1">test_buffer_rd_bytes(c_parser_only):</span>
    <span class="s4"># see gh-12098: src-&gt;buffer in the C parser can be freed twice leading</span>
    <span class="s4"># to a segfault if a corrupt gzip file is read with 'read_csv', and the</span>
    <span class="s4"># buffer is filled more than once before gzip raises an Exception.</span>

    <span class="s1">data = (</span>
        <span class="s3">&quot;</span><span class="s2">\x1F\x8B\x08\x00\x00\x00\x00\x00\x00\x03\xED\xC3\x41\x09</span><span class="s3">&quot;</span>
        <span class="s3">&quot;</span><span class="s2">\x00\x00\x08\x00\xB1\xB7\xB6\xBA\xFE\xA5\xCC\x21\x6C\xB0</span><span class="s3">&quot;</span>
        <span class="s3">&quot;</span><span class="s2">\xA6\x4D</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\x55</span><span class="s3">&quot; </span><span class="s1">* </span><span class="s5">267 </span><span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\x7D\xF7\x00\x91\xE0\x47\x97\x14\x38\x04\x00</span><span class="s3">&quot;</span>
        <span class="s3">&quot;</span><span class="s2">\x1f\x8b\x08\x00</span><span class="s3">VT</span><span class="s2">\x97</span><span class="s3">V</span><span class="s2">\x00\x03\xed</span><span class="s3">]</span><span class="s2">\xef</span><span class="s3">O&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
        <span class="s4"># compression has no effect when passing a non-binary object as input</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">100</span><span class="s1">):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">parser.read_csv(</span>
                    <span class="s1">StringIO(data)</span><span class="s2">, </span><span class="s1">compression=</span><span class="s3">&quot;gzip&quot;</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">test_delim_whitespace_custom_terminator(c_parser_only):</span>
    <span class="s4"># See gh-12912</span>
    <span class="s1">data = </span><span class="s3">&quot;a b c~1 2 3~4 5 6~7 8 9&quot;</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s1">df = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">lineterminator=</span><span class="s3">&quot;~&quot;</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dtype_and_names_error(c_parser_only):</span>
    <span class="s4"># see gh-8833: passing both dtype and names</span>
    <span class="s4"># resulting in an error reporting issue</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot; 
1.0 1 
2.0 2 
3.0 3 
&quot;&quot;&quot;</span>
    <span class="s4"># base cases</span>
    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">r&quot;\s+&quot;</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3.0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">r&quot;\s+&quot;</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3.0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s4"># fallback casting</span>
    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">r&quot;\s+&quot;</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;a&quot;</span><span class="s1">: np.int32}</span>
    <span class="s1">)</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">expected[</span><span class="s3">&quot;a&quot;</span><span class="s1">] = expected[</span><span class="s3">&quot;a&quot;</span><span class="s1">].astype(np.int32)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot; 
1.0 1 
nan 2 
3.0 3 
&quot;&quot;&quot;</span>
    <span class="s4"># fallback casting, but not castable</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;cannot safely convert&quot;</span><span class="s1">):</span>
        <span class="s1">parser.read_csv(</span>
            <span class="s1">StringIO(data)</span><span class="s2">,</span>
            <span class="s1">sep=</span><span class="s3">r&quot;\s+&quot;</span><span class="s2">,</span>
            <span class="s1">header=</span><span class="s2">None,</span>
            <span class="s1">names=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype={</span><span class="s3">&quot;a&quot;</span><span class="s1">: np.int32}</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;match,kwargs&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s4"># For each of these cases, all of the dtypes are valid, just unsupported.</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s3">&quot;the dtype datetime64 is not supported for parsing, &quot;</span>
                <span class="s3">&quot;pass this column using parse_dates instead&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">{</span><span class="s3">&quot;dtype&quot;</span><span class="s1">: {</span><span class="s3">&quot;A&quot;</span><span class="s1">: </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;float64&quot;</span><span class="s1">}}</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s3">&quot;the dtype datetime64 is not supported for parsing, &quot;</span>
                <span class="s3">&quot;pass this column using parse_dates instead&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">{</span><span class="s3">&quot;dtype&quot;</span><span class="s1">: {</span><span class="s3">&quot;A&quot;</span><span class="s1">: </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;float64&quot;</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;parse_dates&quot;</span><span class="s1">: [</span><span class="s3">&quot;B&quot;</span><span class="s1">]}</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;the dtype timedelta64 is not supported for parsing&quot;</span><span class="s2">,</span>
            <span class="s1">{</span><span class="s3">&quot;dtype&quot;</span><span class="s1">: {</span><span class="s3">&quot;A&quot;</span><span class="s1">: </span><span class="s3">&quot;timedelta64&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;float64&quot;</span><span class="s1">}}</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;the dtype &lt;U8 is not supported for parsing&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;dtype&quot;</span><span class="s1">: {</span><span class="s3">&quot;A&quot;</span><span class="s1">: </span><span class="s3">&quot;U8&quot;</span><span class="s1">}})</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">ids=[</span><span class="s3">&quot;dt64-0&quot;</span><span class="s2">, </span><span class="s3">&quot;dt64-1&quot;</span><span class="s2">, </span><span class="s3">&quot;td64&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;U8&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_unsupported_dtype(c_parser_only</span><span class="s2">, </span><span class="s1">match</span><span class="s2">, </span><span class="s1">kwargs):</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">np.random.rand(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">columns=list(</span><span class="s3">&quot;AB&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">&quot;1A&quot;</span><span class="s2">, </span><span class="s3">&quot;1B&quot;</span><span class="s2">, </span><span class="s3">&quot;1C&quot;</span><span class="s2">, </span><span class="s3">&quot;1D&quot;</span><span class="s2">, </span><span class="s3">&quot;1E&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s2">with </span><span class="s1">tm.ensure_clean(</span><span class="s3">&quot;__unsupported_dtype__.csv&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">path:</span>
        <span class="s1">df.to_csv(path)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=match):</span>
            <span class="s1">parser.read_csv(path</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">@td.skip_if_32bit</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_precise_conversion(c_parser_only):</span>
    <span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>

    <span class="s1">parser = c_parser_only</span>

    <span class="s1">normal_errors = []</span>
    <span class="s1">precise_errors = []</span>

    <span class="s4"># test numbers between 1 and 2</span>
    <span class="s2">for </span><span class="s1">num </span><span class="s2">in </span><span class="s1">np.linspace(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s1">num=</span><span class="s5">500</span><span class="s1">):</span>
        <span class="s4"># 25 decimal digits of precision</span>
        <span class="s1">text = </span><span class="s3">f&quot;a</span><span class="s2">\n{</span><span class="s1">num</span><span class="s2">:</span><span class="s3">.25</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">normal_val = float(</span>
            <span class="s1">parser.read_csv(StringIO(text)</span><span class="s2">, </span><span class="s1">float_precision=</span><span class="s3">&quot;legacy&quot;</span><span class="s1">)[</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">precise_val = float(</span>
            <span class="s1">parser.read_csv(StringIO(text)</span><span class="s2">, </span><span class="s1">float_precision=</span><span class="s3">&quot;high&quot;</span><span class="s1">)[</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">roundtrip_val = float(</span>
            <span class="s1">parser.read_csv(StringIO(text)</span><span class="s2">, </span><span class="s1">float_precision=</span><span class="s3">&quot;round_trip&quot;</span><span class="s1">)[</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">actual_val = Decimal(text[</span><span class="s5">2</span><span class="s1">:])</span>

        <span class="s2">def </span><span class="s1">error(val):</span>
            <span class="s2">return </span><span class="s1">abs(Decimal(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">val</span><span class="s2">:</span><span class="s3">.100</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">) - actual_val)</span>

        <span class="s1">normal_errors.append(error(normal_val))</span>
        <span class="s1">precise_errors.append(error(precise_val))</span>

        <span class="s4"># round-trip should match float()</span>
        <span class="s2">assert </span><span class="s1">roundtrip_val == float(text[</span><span class="s5">2</span><span class="s1">:])</span>

    <span class="s2">assert </span><span class="s1">sum(precise_errors) &lt;= sum(normal_errors)</span>
    <span class="s2">assert </span><span class="s1">max(precise_errors) &lt;= max(normal_errors)</span>


<span class="s2">def </span><span class="s1">test_usecols_dtypes(c_parser_only):</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">1,2,3 
4,5,6 
7,8,9 
10,11,12&quot;&quot;&quot;</span>

    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">,</span>
        <span class="s1">usecols=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">names=(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s2">None,</span>
        <span class="s1">converters={</span><span class="s3">&quot;a&quot;</span><span class="s1">: str}</span><span class="s2">,</span>
        <span class="s1">dtype={</span><span class="s3">&quot;b&quot;</span><span class="s1">: int</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">: float}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result2 = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">,</span>
        <span class="s1">usecols=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">names=(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s2">None,</span>
        <span class="s1">converters={</span><span class="s3">&quot;a&quot;</span><span class="s1">: str}</span><span class="s2">,</span>
        <span class="s1">dtype={</span><span class="s3">&quot;b&quot;</span><span class="s1">: int</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">: float}</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">(result.dtypes == [object</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float]).all()</span>
    <span class="s2">assert </span><span class="s1">(result2.dtypes == [object</span><span class="s2">, </span><span class="s1">float]).all()</span>


<span class="s2">def </span><span class="s1">test_disable_bool_parsing(c_parser_only):</span>
    <span class="s4"># see gh-2090</span>

    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A,B,C 
Yes,No,Yes 
No,Yes,Yes 
Yes,,Yes 
No,No,No&quot;&quot;&quot;</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">assert </span><span class="s1">(result.dtypes == object).all()</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">dtype=object</span><span class="s2">, </span><span class="s1">na_filter=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result[</span><span class="s3">&quot;B&quot;</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] == </span><span class="s3">&quot;&quot;</span>


<span class="s2">def </span><span class="s1">test_custom_lineterminator(c_parser_only):</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">&quot;a,b,c~1,2,3~4,5,6&quot;</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">lineterminator=</span><span class="s3">&quot;~&quot;</span><span class="s1">)</span>
    <span class="s1">expected = parser.read_csv(StringIO(data.replace(</span><span class="s3">&quot;~&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)))</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_parse_ragged_csv(c_parser_only):</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;1,2,3 
1,2,3,4 
1,2,3,4,5 
1,2 
1,2,3,4&quot;&quot;&quot;</span>

    <span class="s1">nice_data = </span><span class="s3">&quot;&quot;&quot;1,2,3,, 
1,2,3,4, 
1,2,3,4,5 
1,2,,, 
1,2,3,4,&quot;&quot;&quot;</span>
    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">expected = parser.read_csv(</span>
        <span class="s1">StringIO(nice_data)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s4"># too many columns, cause segfault if not careful</span>
    <span class="s1">data = </span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">3,4,5&quot;</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=range(</span><span class="s5">50</span><span class="s1">))</span>
    <span class="s1">expected = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=range(</span><span class="s5">3</span><span class="s1">)).reindex(</span>
        <span class="s1">columns=range(</span><span class="s5">50</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_tokenize_CR_with_quoting(c_parser_only):</span>
    <span class="s4"># see gh-3453</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">' a,b,c</span><span class="s2">\r</span><span class="s3">&quot;a,b&quot;,&quot;e,d&quot;,&quot;f,f&quot;'</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">expected = parser.read_csv(StringIO(data.replace(</span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">))</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = parser.read_csv(StringIO(data))</span>
    <span class="s1">expected = parser.read_csv(StringIO(data.replace(</span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_grow_boundary_at_cap(c_parser_only):</span>
    <span class="s4"># See gh-12494</span>
    <span class="s4">#</span>
    <span class="s4"># Cause of error was that the C parser</span>
    <span class="s4"># was not increasing the buffer size when</span>
    <span class="s4"># the desired space would fill the buffer</span>
    <span class="s4"># to capacity, which would later cause a</span>
    <span class="s4"># buffer overflow error when checking the</span>
    <span class="s4"># EOF terminator of the CSV stream.</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s2">def </span><span class="s1">test_empty_header_read(count):</span>
        <span class="s2">with </span><span class="s1">StringIO(</span><span class="s3">&quot;,&quot; </span><span class="s1">* count) </span><span class="s2">as </span><span class="s1">s:</span>
            <span class="s1">expected = DataFrame(columns=[</span><span class="s3">f&quot;Unnamed: </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(count + </span><span class="s5">1</span><span class="s1">)])</span>
            <span class="s1">df = parser.read_csv(s)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">for </span><span class="s1">cnt </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">101</span><span class="s1">):</span>
        <span class="s1">test_empty_header_read(cnt)</span>


<span class="s2">def </span><span class="s1">test_parse_trim_buffers(c_parser_only):</span>
    <span class="s4"># This test is part of a bugfix for gh-13703. It attempts to</span>
    <span class="s4"># to stress the system memory allocator, to cause it to move the</span>
    <span class="s4"># stream buffer and either let the OS reclaim the region, or let</span>
    <span class="s4"># other memory requests of parser otherwise modify the contents</span>
    <span class="s4"># of memory space, where it was formally located.</span>
    <span class="s4"># This test is designed to cause a `segfault` with unpatched</span>
    <span class="s4"># `tokenizer.c`. Sometimes the test fails on `segfault`, other</span>
    <span class="s4"># times it fails due to memory corruption, which causes the</span>
    <span class="s4"># loaded DataFrame to differ from the expected one.</span>

    <span class="s1">parser = c_parser_only</span>

    <span class="s4"># Generate a large mixed-type CSV file on-the-fly (one record is</span>
    <span class="s4"># approx 1.5KiB).</span>
    <span class="s1">record_ = (</span>
        <span class="s3">&quot;&quot;&quot;9999-9,99:99,,,,ZZ,ZZ,,,ZZZ-ZZZZ,.Z-ZZZZ,-9.99,,,9.99,Z&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZZZ,,-99,9,ZZZ-ZZZZ,ZZ-ZZZZ,,9.99,ZZZ-ZZZZZ,ZZZ-ZZZZZ,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZZ-ZZZZ,ZZZ-ZZZZ,ZZZ-ZZZZ,ZZZ-ZZZZ,ZZZ-ZZZZ,ZZZ-ZZZZ,9&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;99,ZZZ-ZZZZ,,ZZ-ZZZZ,,,,,ZZZZ,ZZZ-ZZZZZ,ZZZ-ZZZZ,,,9,9,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;9,9,99,99,999,999,ZZZZZ,ZZZ-ZZZZZ,ZZZ-ZZZZ,9,ZZ-ZZZZ,9.&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;99,ZZ-ZZZZ,ZZ-ZZZZ,,,,ZZZZ,,,ZZ,ZZ,,,,,,,,,,,,,9,,,999.&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;99,999.99,,,ZZZZZ,,,Z9,,,,,,,ZZZ,ZZZ,,,,,,,,,,,ZZZZZ,ZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZZ,ZZZ-ZZZZZZ,ZZZ-ZZZZZZ,ZZ-ZZZZ,ZZ-ZZZZ,ZZ-ZZZZ,ZZ-ZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZ,,,999999,999999,ZZZ,ZZZ,,,ZZZ,ZZZ,999.99,999.99,,,,Z&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZ-ZZZ,ZZZ-ZZZ,-9.99,-9.99,9,9,,99,,9.99,9.99,9,9,9.99,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;9.99,,,,9.99,9.99,,99,,99,9.99,9.99,,,ZZZ,ZZZ,,999.99,,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;999.99,ZZZ,ZZZ-ZZZZ,ZZZ-ZZZZ,,,ZZZZZ,ZZZZZ,ZZZ,ZZZ,9,9,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,,,,,ZZZ-ZZZZ,ZZZ999Z,,,999.99,,999.99,ZZZ-ZZZZ,,,9.999&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,9.999,9.999,9.999,-9.999,-9.999,-9.999,-9.999,9.999,9.&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;999,9.999,9.999,9.999,9.999,9.999,9.999,99999,ZZZ-ZZZZ,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,9.99,ZZZ,,,,,,,,ZZZ,,,,,9,,,,9,,,,,,,,,,ZZZ-ZZZZ,ZZZ-Z&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZZ,,ZZZZZ,ZZZZZ,ZZZZZ,ZZZZZ,,,9.99,,ZZ-ZZZZ,ZZ-ZZZZ,ZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,999,,,,ZZ-ZZZZ,ZZZ,ZZZ,ZZZ-ZZZZ,ZZZ-ZZZZ,,,99.99,99.99&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,,,9.99,9.99,9.99,9.99,ZZZ-ZZZZ,,,ZZZ-ZZZZZ,,,,,-9.99,-&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;9.99,-9.99,-9.99,,,,,,,,,ZZZ-ZZZZ,,9,9.99,9.99,99ZZ,,-9&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;.99,-9.99,ZZZ-ZZZZ,,,,,,,ZZZ-ZZZZ,9.99,9.99,9999,,,,,,,&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,,,-9.9,Z/Z-ZZZZ,999.99,9.99,,999.99,ZZ-ZZZZ,ZZ-ZZZZ,9.&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;99,9.99,9.99,9.99,9.99,9.99,,ZZZ-ZZZZZ,ZZZ-ZZZZZ,ZZZ-ZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZZ,ZZZ-ZZZZZ,ZZZ-ZZZZZ,ZZZ,ZZZ,ZZZ,ZZZ,9.99,,,-9.99,ZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;-ZZZZ,-999.99,,-9999,,999.99,,,,999.99,99.99,,,ZZ-ZZZZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;ZZZ,ZZ-ZZZZ-ZZZZZZZ,,,,ZZ-ZZ-ZZZZZZZZ,ZZZZZZZZ,ZZZ-ZZZZ&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,9999,999.99,ZZZ-ZZZZ,-9.99,-9.99,ZZZ-ZZZZ,99:99:99,,99&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;,99,,9.99,,-99.99,,,,,,9.99,ZZZ-ZZZZ,-9.99,-9.99,9.99,9&quot;&quot;&quot;</span>
        <span class="s3">&quot;&quot;&quot;.99,,ZZZ,,,,,,,ZZZ,ZZZ,,,,,&quot;&quot;&quot;</span>
    <span class="s1">)</span>

    <span class="s4"># Set the number of lines so that a call to `parser_trim_buffers`</span>
    <span class="s4"># is triggered: after a couple of full chunks are consumed a</span>
    <span class="s4"># relatively small 'residual' chunk would cause reallocation</span>
    <span class="s4"># within the parser.</span>
    <span class="s1">chunksize</span><span class="s2">, </span><span class="s1">n_lines = </span><span class="s5">128</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* </span><span class="s5">128 </span><span class="s1">+ </span><span class="s5">15</span>
    <span class="s1">csv_data = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([record_] * n_lines) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>

    <span class="s4"># We will use StringIO to load the CSV from this text buffer.</span>
    <span class="s4"># pd.read_csv() will iterate over the file in chunks and will</span>
    <span class="s4"># finally read a residual chunk of really small size.</span>

    <span class="s4"># Generate the expected output: manually create the dataframe</span>
    <span class="s4"># by splitting by comma and repeating the `n_lines` times.</span>
    <span class="s1">row = tuple(val_ </span><span class="s2">if </span><span class="s1">val_ </span><span class="s2">else </span><span class="s1">np.nan </span><span class="s2">for </span><span class="s1">val_ </span><span class="s2">in </span><span class="s1">record_.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">))</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[row </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(n_lines)]</span><span class="s2">, </span><span class="s1">dtype=object</span><span class="s2">, </span><span class="s1">columns=</span><span class="s2">None, </span><span class="s1">index=</span><span class="s2">None</span>
    <span class="s1">)</span>

    <span class="s4"># Iterate over the CSV file in chunks of `chunksize` lines</span>
    <span class="s2">with </span><span class="s1">parser.read_csv(</span>
        <span class="s1">StringIO(csv_data)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">dtype=object</span><span class="s2">, </span><span class="s1">chunksize=chunksize</span>
    <span class="s1">) </span><span class="s2">as </span><span class="s1">chunks_:</span>
        <span class="s1">result = concat(chunks_</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s4"># Check for data corruption if there was no segfault</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s4"># This extra test was added to replicate the fault in gh-5291.</span>
    <span class="s4"># Force 'utf-8' encoding, so that `_string_convert` would take</span>
    <span class="s4"># a different execution branch.</span>
    <span class="s2">with </span><span class="s1">parser.read_csv(</span>
        <span class="s1">StringIO(csv_data)</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s2">None,</span>
        <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">chunksize=chunksize</span><span class="s2">,</span>
        <span class="s1">encoding=</span><span class="s3">&quot;utf_8&quot;</span><span class="s2">,</span>
    <span class="s1">) </span><span class="s2">as </span><span class="s1">chunks_:</span>
        <span class="s1">result = concat(chunks_</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_internal_null_byte(c_parser_only):</span>
    <span class="s4"># see gh-14012</span>
    <span class="s4">#</span>
    <span class="s4"># The null byte ('\x00') should not be used as a</span>
    <span class="s4"># true line terminator, escape character, or comment</span>
    <span class="s4"># character, only as a placeholder to indicate that</span>
    <span class="s4"># none was specified.</span>
    <span class="s4">#</span>
    <span class="s4"># This test should be moved to test_common.py ONLY when</span>
    <span class="s4"># Python's csv class supports parsing '\x00'.</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s1">names = [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span>
    <span class="s1">data = </span><span class="s3">&quot;1,2,3</span><span class="s2">\n</span><span class="s3">4,</span><span class="s2">\x00</span><span class="s3">,6</span><span class="s2">\n</span><span class="s3">7,8,9&quot;</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">4</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=names)</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">names=names)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_nrows_large(c_parser_only):</span>
    <span class="s4"># gh-7626 - Read only nrows of data in for large inputs (&gt;262144b)</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">header_narrow = </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">.join([</span><span class="s3">&quot;COL_HEADER_&quot; </span><span class="s1">+ str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">)]) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">data_narrow = </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">.join([</span><span class="s3">&quot;somedatasomedatasomedata1&quot; </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">)]) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">header_wide = </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">.join([</span><span class="s3">&quot;COL_HEADER_&quot; </span><span class="s1">+ str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">15</span><span class="s1">)]) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">data_wide = </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">.join([</span><span class="s3">&quot;somedatasomedatasomedata2&quot; </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">15</span><span class="s1">)]) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">test_input = header_narrow + data_narrow * </span><span class="s5">1050 </span><span class="s1">+ header_wide + data_wide * </span><span class="s5">2</span>

    <span class="s1">df = parser.read_csv(StringIO(test_input)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s5">1010</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">df.size == </span><span class="s5">1010 </span><span class="s1">* </span><span class="s5">10</span>


<span class="s2">def </span><span class="s1">test_float_precision_round_trip_with_text(c_parser_only):</span>
    <span class="s4"># see gh-15140</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">df = parser.read_csv(StringIO(</span><span class="s3">&quot;a&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">float_precision=</span><span class="s3">&quot;round_trip&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">DataFrame({</span><span class="s5">0</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s1">]}))</span>


<span class="s2">def </span><span class="s1">test_large_difference_in_columns(c_parser_only):</span>
    <span class="s4"># see gh-14125</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s1">count = </span><span class="s5">10000</span>
    <span class="s1">large_row = (</span><span class="s3">&quot;X,&quot; </span><span class="s1">* count)[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">normal_row = </span><span class="s3">&quot;XXXXXX XXXXXX,111111111111111</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">test_input = (large_row + normal_row * </span><span class="s5">6</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">result = parser.read_csv(StringIO(test_input)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">usecols=[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">rows = test_input.split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame([row.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_data_after_quote(c_parser_only):</span>
    <span class="s4"># see gh-15910</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s1">data = </span><span class="s3">'a</span><span class="s2">\n</span><span class="s3">1</span><span class="s2">\n</span><span class="s3">&quot;b&quot;a'</span>
    <span class="s1">result = parser.read_csv(StringIO(data))</span>

    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;ba&quot;</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_comment_whitespace_delimited(c_parser_only</span><span class="s2">, </span><span class="s1">capsys):</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">test_input = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">1 2 
2 2 3 
3 2 3 # 3 fields 
4 2 3# 3 fields 
5 2 # 2 fields 
6 2# 2 fields 
7 # 1 field, NaN 
8# 1 field, NaN 
9 2 3 # skipped line 
# comment&quot;&quot;&quot;</span>
    <span class="s1">df = parser.read_csv(</span>
        <span class="s1">StringIO(test_input)</span><span class="s2">,</span>
        <span class="s1">comment=</span><span class="s3">&quot;#&quot;</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s2">None,</span>
        <span class="s1">delimiter=</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">s+&quot;</span><span class="s2">,</span>
        <span class="s1">skiprows=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">on_bad_lines=</span><span class="s3">&quot;warn&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">captured = capsys.readouterr()</span>
    <span class="s4"># skipped lines 2, 3, 4, 9</span>
    <span class="s2">for </span><span class="s1">line_num </span><span class="s2">in </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">9</span><span class="s1">):</span>
        <span class="s2">assert </span><span class="s3">f&quot;Skipping line </span><span class="s2">{</span><span class="s1">line_num</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">in </span><span class="s1">captured.err</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">6</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">7</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">8</span><span class="s2">, </span><span class="s1">np.nan]])</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_file_like_no_next(c_parser_only):</span>
    <span class="s4"># gh-16530: the file-like need not have a &quot;next&quot; or &quot;__next__&quot;</span>
    <span class="s4"># attribute despite having an &quot;__iter__&quot; attribute.</span>
    <span class="s4">#</span>
    <span class="s4"># NOTE: This is only true for the C engine, not Python engine.</span>
    <span class="s2">class </span><span class="s1">NoNextBuffer(StringIO):</span>
        <span class="s2">def </span><span class="s1">__next__(self):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;No next method&quot;</span><span class="s1">)</span>

        <span class="s1">next = __next__</span>

    <span class="s1">parser = c_parser_only</span>
    <span class="s1">data = </span><span class="s3">&quot;a</span><span class="s2">\n</span><span class="s3">1&quot;</span>

    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s1">]})</span>
    <span class="s1">result = parser.read_csv(NoNextBuffer(data))</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_buffer_rd_bytes_bad_unicode(c_parser_only):</span>
    <span class="s4"># see gh-22748</span>
    <span class="s1">t = BytesIO(</span><span class="s6">b&quot;</span><span class="s2">\xB0</span><span class="s6">&quot;</span><span class="s1">)</span>
    <span class="s1">t = TextIOWrapper(t</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;ascii&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;surrogateescape&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;'utf-8' codec can't encode character&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(UnicodeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">c_parser_only.read_csv(t</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;UTF-8&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tar_suffix&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;.tar&quot;</span><span class="s2">, </span><span class="s3">&quot;.tar.gz&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_read_tarfile(c_parser_only</span><span class="s2">, </span><span class="s1">csv_dir_path</span><span class="s2">, </span><span class="s1">tar_suffix):</span>
    <span class="s4"># see gh-16530</span>
    <span class="s4">#</span>
    <span class="s4"># Unfortunately, Python's CSV library can't handle</span>
    <span class="s4"># tarfile objects (expects string, not bytes when</span>
    <span class="s4"># iterating through a file-like).</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">tar_path = os.path.join(csv_dir_path</span><span class="s2">, </span><span class="s3">&quot;tar_csv&quot; </span><span class="s1">+ tar_suffix)</span>

    <span class="s2">with </span><span class="s1">tarfile.open(tar_path</span><span class="s2">, </span><span class="s3">&quot;r&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">tar:</span>
        <span class="s1">data_file = tar.extractfile(</span><span class="s3">&quot;tar_data.csv&quot;</span><span class="s1">)</span>

        <span class="s1">out = parser.read_csv(data_file)</span>
        <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s1">]})</span>
        <span class="s1">tm.assert_frame_equal(out</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.high_memory</span>
<span class="s2">def </span><span class="s1">test_bytes_exceed_2gb(c_parser_only):</span>
    <span class="s4"># see gh-16798</span>
    <span class="s4">#</span>
    <span class="s4"># Read from a &quot;CSV&quot; that has a column larger than 2GB.</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s2">if </span><span class="s1">parser.low_memory:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;not a high_memory test&quot;</span><span class="s1">)</span>

    <span class="s1">csv = StringIO(</span><span class="s3">&quot;strings</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([</span><span class="s3">&quot;x&quot; </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">20</span><span class="s1">) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2100</span><span class="s1">)]))</span>
    <span class="s1">df = parser.read_csv(csv)</span>
    <span class="s2">assert not </span><span class="s1">df.empty</span>


<span class="s2">def </span><span class="s1">test_chunk_whitespace_on_boundary(c_parser_only):</span>
    <span class="s4"># see gh-9735: this issue is C parser-specific (bug when</span>
    <span class="s4"># parsing whitespace and characters at chunk boundary)</span>
    <span class="s4">#</span>
    <span class="s4"># This test case has a field too large for the Python parser / CSV library.</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s1">chunk1 = </span><span class="s3">&quot;a&quot; </span><span class="s1">* (</span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">256 </span><span class="s1">- </span><span class="s5">2</span><span class="s1">) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">a&quot;</span>
    <span class="s1">chunk2 = </span><span class="s3">&quot;</span><span class="s2">\n </span><span class="s3">a&quot;</span>
    <span class="s1">result = parser.read_csv(StringIO(chunk1 + chunk2)</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame([</span><span class="s3">&quot;a&quot; </span><span class="s1">* (</span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">256 </span><span class="s1">- </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot; a&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_file_handles_mmap(c_parser_only</span><span class="s2">, </span><span class="s1">csv1):</span>
    <span class="s4"># gh-14418</span>
    <span class="s4">#</span>
    <span class="s4"># Don't close user provided file handles.</span>
    <span class="s1">parser = c_parser_only</span>

    <span class="s2">with </span><span class="s1">open(csv1) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">m = mmap.mmap(f.fileno()</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">access=mmap.ACCESS_READ)</span>
        <span class="s1">parser.read_csv(m)</span>

        <span class="s2">assert not </span><span class="s1">m.closed</span>
        <span class="s1">m.close()</span>


<span class="s2">def </span><span class="s1">test_file_binary_mode(c_parser_only):</span>
    <span class="s4"># see gh-23779</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]])</span>

    <span class="s2">with </span><span class="s1">tm.ensure_clean() </span><span class="s2">as </span><span class="s1">path:</span>
        <span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s3">&quot;1,2,3</span><span class="s2">\n</span><span class="s3">4,5,6&quot;</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">result = parser.read_csv(f</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_unix_style_breaks(c_parser_only):</span>
    <span class="s4"># GH 11020</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s2">with </span><span class="s1">tm.ensure_clean() </span><span class="s2">as </span><span class="s1">path:</span>
        <span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s2">, </span><span class="s1">newline=</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s3">&quot;blah</span><span class="s2">\n\n</span><span class="s3">col_1,col_2,col_3</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">result = parser.read_csv(path</span><span class="s2">, </span><span class="s1">skiprows=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s1">engine=</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(columns=[</span><span class="s3">&quot;col_1&quot;</span><span class="s2">, </span><span class="s3">&quot;col_2&quot;</span><span class="s2">, </span><span class="s3">&quot;col_3&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;float_precision&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;legacy&quot;</span><span class="s2">, </span><span class="s3">&quot;high&quot;</span><span class="s2">, </span><span class="s3">&quot;round_trip&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data,thousands,decimal&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s3">&quot;&quot;&quot;A|B|C 
1|2,334.01|5 
10|13|10. 
&quot;&quot;&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;,&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;.&quot;</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;&quot;&quot;A|B|C 
1|2.334,01|5 
10|13|10, 
&quot;&quot;&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;.&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;,&quot;</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_1000_sep_with_decimal(</span>
    <span class="s1">c_parser_only</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">thousands</span><span class="s2">, </span><span class="s1">decimal</span><span class="s2">, </span><span class="s1">float_precision</span>
<span class="s1">):</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s5">2334.01</span><span class="s2">, </span><span class="s5">13</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">: [</span><span class="s5">5</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]})</span>

    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">,</span>
        <span class="s1">sep=</span><span class="s3">&quot;|&quot;</span><span class="s2">,</span>
        <span class="s1">thousands=thousands</span><span class="s2">,</span>
        <span class="s1">decimal=decimal</span><span class="s2">,</span>
        <span class="s1">float_precision=float_precision</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_float_precision_options(c_parser_only):</span>
    <span class="s4"># GH 17154, 36228</span>
    <span class="s1">parser = c_parser_only</span>
    <span class="s1">s = </span><span class="s3">&quot;foo</span><span class="s2">\n</span><span class="s3">243.164</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">df = parser.read_csv(StringIO(s))</span>
    <span class="s1">df2 = parser.read_csv(StringIO(s)</span><span class="s2">, </span><span class="s1">float_precision=</span><span class="s3">&quot;high&quot;</span><span class="s1">)</span>

    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">df2)</span>

    <span class="s1">df3 = parser.read_csv(StringIO(s)</span><span class="s2">, </span><span class="s1">float_precision=</span><span class="s3">&quot;legacy&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">IS64:</span>
        <span class="s2">assert not </span><span class="s1">df.iloc[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] == df3.iloc[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">df.iloc[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] == df3.iloc[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">msg = </span><span class="s3">&quot;Unrecognized float_precision option: junk&quot;</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(StringIO(s)</span><span class="s2">, </span><span class="s1">float_precision=</span><span class="s3">&quot;junk&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>