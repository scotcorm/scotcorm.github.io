<html>
<head>
<title>arraypad.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arraypad.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The arraypad module contains a group of functions to pad values onto the edges 
of an n-dimensional array. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">array_function_dispatch</span>
<span class="s2">from </span><span class="s1">numpy.lib.index_tricks </span><span class="s2">import </span><span class="s1">ndindex</span>


<span class="s1">__all__ = [</span><span class="s3">'pad'</span><span class="s1">]</span>


<span class="s4">###############################################################################</span>
<span class="s4"># Private utility functions.</span>


<span class="s2">def </span><span class="s1">_round_if_needed(arr</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Rounds arr inplace if destination dtype is integer. 
 
    Parameters 
    ---------- 
    arr : ndarray 
        Input array. 
    dtype : dtype 
        The dtype of the destination array. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.integer):</span>
        <span class="s1">arr.round(out=arr)</span>


<span class="s2">def </span><span class="s1">_slice_at_axis(sl</span><span class="s2">, </span><span class="s1">axis):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct tuple of slices to slice an array in the given dimension. 
 
    Parameters 
    ---------- 
    sl : slice 
        The slice for the given dimension. 
    axis : int 
        The axis to which `sl` is applied. All other dimensions are left 
        &quot;unsliced&quot;. 
 
    Returns 
    ------- 
    sl : tuple of slices 
        A tuple with slices matching `shape` in length. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; _slice_at_axis(slice(None, 3, -1), 1) 
    (slice(None, None, None), slice(None, 3, -1), (...,)) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(slice(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span><span class="s1">) * axis + (sl</span><span class="s2">,</span><span class="s1">) + (...</span><span class="s2">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_view_roi(array</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get a view of the current region of interest during iterative padding. 
 
    When padding multiple dimensions iteratively corner values are 
    unnecessarily overwritten multiple times. This function reduces the 
    working area for the first dimensions so that corners are excluded. 
 
    Parameters 
    ---------- 
    array : ndarray 
        The array with the region of interest. 
    original_area_slice : tuple of slices 
        Denotes the area with original values of the unpadded array. 
    axis : int 
        The currently padded dimension assuming that `axis` is padded before 
        `axis` + 1. 
 
    Returns 
    ------- 
    roi : ndarray 
        The region of interest of the original `array`. 
    &quot;&quot;&quot;</span>
    <span class="s1">axis += </span><span class="s5">1</span>
    <span class="s1">sl = (slice(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span><span class="s1">) * axis + original_area_slice[axis:]</span>
    <span class="s2">return </span><span class="s1">array[sl]</span>


<span class="s2">def </span><span class="s1">_pad_simple(array</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pad array on all sides with either a single value or undefined values. 
 
    Parameters 
    ---------- 
    array : ndarray 
        Array to grow. 
    pad_width : sequence of tuple[int, int] 
        Pad width on both sides for each dimension in `arr`. 
    fill_value : scalar, optional 
        If provided the padded area is filled with this value, otherwise 
        the pad area left undefined. 
 
    Returns 
    ------- 
    padded : ndarray 
        The padded array with the same dtype as`array`. Its order will default 
        to C-style if `array` is not F-contiguous. 
    original_area_slice : tuple 
        A tuple of slices pointing to the area of the original array. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Allocate grown array</span>
    <span class="s1">new_shape = tuple(</span>
        <span class="s1">left + size + right</span>
        <span class="s2">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">(left</span><span class="s2">, </span><span class="s1">right) </span><span class="s2">in </span><span class="s1">zip(array.shape</span><span class="s2">, </span><span class="s1">pad_width)</span>
    <span class="s1">)</span>
    <span class="s1">order = </span><span class="s3">'F' </span><span class="s2">if </span><span class="s1">array.flags.fnc </span><span class="s2">else </span><span class="s3">'C'  </span><span class="s4"># Fortran and not also C-order</span>
    <span class="s1">padded = np.empty(new_shape</span><span class="s2">, </span><span class="s1">dtype=array.dtype</span><span class="s2">, </span><span class="s1">order=order)</span>

    <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">padded.fill(fill_value)</span>

    <span class="s4"># Copy old array into correct space</span>
    <span class="s1">original_area_slice = tuple(</span>
        <span class="s1">slice(left</span><span class="s2">, </span><span class="s1">left + size)</span>
        <span class="s2">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">(left</span><span class="s2">, </span><span class="s1">right) </span><span class="s2">in </span><span class="s1">zip(array.shape</span><span class="s2">, </span><span class="s1">pad_width)</span>
    <span class="s1">)</span>
    <span class="s1">padded[original_area_slice] = array</span>

    <span class="s2">return </span><span class="s1">padded</span><span class="s2">, </span><span class="s1">original_area_slice</span>


<span class="s2">def </span><span class="s1">_set_pad_area(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">value_pair):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set empty-padded area in given dimension. 
 
    Parameters 
    ---------- 
    padded : ndarray 
        Array with the pad area which is modified inplace. 
    axis : int 
        Dimension with the pad area to set. 
    width_pair : (int, int) 
        Pair of widths that mark the pad area on both sides in the given 
        dimension. 
    value_pair : tuple of scalars or ndarrays 
        Values inserted into the pad area on each side. It must match or be 
        broadcastable to the shape of `arr`. 
    &quot;&quot;&quot;</span>
    <span class="s1">left_slice = _slice_at_axis(slice(</span><span class="s2">None, </span><span class="s1">width_pair[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">padded[left_slice] = value_pair[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">right_slice = _slice_at_axis(</span>
        <span class="s1">slice(padded.shape[axis] - width_pair[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">padded[right_slice] = value_pair[</span><span class="s5">1</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_get_edges(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair):</span>
    <span class="s0">&quot;&quot;&quot; 
    Retrieve edge values from empty-padded array in given dimension. 
 
    Parameters 
    ---------- 
    padded : ndarray 
        Empty-padded array. 
    axis : int 
        Dimension in which the edges are considered. 
    width_pair : (int, int) 
        Pair of widths that mark the pad area on both sides in the given 
        dimension. 
 
    Returns 
    ------- 
    left_edge, right_edge : ndarray 
        Edge values of the valid area in `padded` in the given dimension. Its 
        shape will always match `padded` except for the dimension given by 
        `axis` which will have a length of 1. 
    &quot;&quot;&quot;</span>
    <span class="s1">left_index = width_pair[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">left_slice = _slice_at_axis(slice(left_index</span><span class="s2">, </span><span class="s1">left_index + </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">left_edge = padded[left_slice]</span>

    <span class="s1">right_index = padded.shape[axis] - width_pair[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">right_slice = _slice_at_axis(slice(right_index - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">right_index)</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">right_edge = padded[right_slice]</span>

    <span class="s2">return </span><span class="s1">left_edge</span><span class="s2">, </span><span class="s1">right_edge</span>


<span class="s2">def </span><span class="s1">_get_linear_ramps(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">end_value_pair):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct linear ramps for empty-padded array in given dimension. 
 
    Parameters 
    ---------- 
    padded : ndarray 
        Empty-padded array. 
    axis : int 
        Dimension in which the ramps are constructed. 
    width_pair : (int, int) 
        Pair of widths that mark the pad area on both sides in the given 
        dimension. 
    end_value_pair : (scalar, scalar) 
        End values for the linear ramps which form the edge of the fully padded 
        array. These values are included in the linear ramps. 
 
    Returns 
    ------- 
    left_ramp, right_ramp : ndarray 
        Linear ramps to set on both sides of `padded`. 
    &quot;&quot;&quot;</span>
    <span class="s1">edge_pair = _get_edges(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair)</span>

    <span class="s1">left_ramp</span><span class="s2">, </span><span class="s1">right_ramp = (</span>
        <span class="s1">np.linspace(</span>
            <span class="s1">start=end_value</span><span class="s2">,</span>
            <span class="s1">stop=edge.squeeze(axis)</span><span class="s2">, </span><span class="s4"># Dimension is replaced by linspace</span>
            <span class="s1">num=width</span><span class="s2">,</span>
            <span class="s1">endpoint=</span><span class="s2">False,</span>
            <span class="s1">dtype=padded.dtype</span><span class="s2">,</span>
            <span class="s1">axis=axis</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">end_value</span><span class="s2">, </span><span class="s1">edge</span><span class="s2">, </span><span class="s1">width </span><span class="s2">in </span><span class="s1">zip(</span>
            <span class="s1">end_value_pair</span><span class="s2">, </span><span class="s1">edge_pair</span><span class="s2">, </span><span class="s1">width_pair</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
        
    <span class="s4"># Reverse linear space in appropriate dimension</span>
    <span class="s1">right_ramp = right_ramp[_slice_at_axis(slice(</span><span class="s2">None, None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)]</span>

    <span class="s2">return </span><span class="s1">left_ramp</span><span class="s2">, </span><span class="s1">right_ramp</span>


<span class="s2">def </span><span class="s1">_get_stats(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">length_pair</span><span class="s2">, </span><span class="s1">stat_func):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate statistic for the empty-padded array in given dimension. 
 
    Parameters 
    ---------- 
    padded : ndarray 
        Empty-padded array. 
    axis : int 
        Dimension in which the statistic is calculated. 
    width_pair : (int, int) 
        Pair of widths that mark the pad area on both sides in the given 
        dimension. 
    length_pair : 2-element sequence of None or int 
        Gives the number of values in valid area from each side that is 
        taken into account when calculating the statistic. If None the entire 
        valid area in `padded` is considered. 
    stat_func : function 
        Function to compute statistic. The expected signature is 
        ``stat_func(x: ndarray, axis: int, keepdims: bool) -&gt; ndarray``. 
 
    Returns 
    ------- 
    left_stat, right_stat : ndarray 
        Calculated statistic for both sides of `padded`. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Calculate indices of the edges of the area with original values</span>
    <span class="s1">left_index = width_pair[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">right_index = padded.shape[axis] - width_pair[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s4"># as well as its length</span>
    <span class="s1">max_length = right_index - left_index</span>

    <span class="s4"># Limit stat_lengths to max_length</span>
    <span class="s1">left_length</span><span class="s2">, </span><span class="s1">right_length = length_pair</span>
    <span class="s2">if </span><span class="s1">left_length </span><span class="s2">is None or </span><span class="s1">max_length &lt; left_length:</span>
        <span class="s1">left_length = max_length</span>
    <span class="s2">if </span><span class="s1">right_length </span><span class="s2">is None or </span><span class="s1">max_length &lt; right_length:</span>
        <span class="s1">right_length = max_length</span>

    <span class="s2">if </span><span class="s1">(left_length == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">right_length == </span><span class="s5">0</span><span class="s1">) \</span>
            <span class="s2">and </span><span class="s1">stat_func </span><span class="s2">in </span><span class="s1">{np.amax</span><span class="s2">, </span><span class="s1">np.amin}:</span>
        <span class="s4"># amax and amin can't operate on an empty array,</span>
        <span class="s4"># raise a more descriptive warning here instead of the default one</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;stat_length of 0 yields no value for padding&quot;</span><span class="s1">)</span>

    <span class="s4"># Calculate statistic for the left side</span>
    <span class="s1">left_slice = _slice_at_axis(</span>
        <span class="s1">slice(left_index</span><span class="s2">, </span><span class="s1">left_index + left_length)</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">left_chunk = padded[left_slice]</span>
    <span class="s1">left_stat = stat_func(left_chunk</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">_round_if_needed(left_stat</span><span class="s2">, </span><span class="s1">padded.dtype)</span>

    <span class="s2">if </span><span class="s1">left_length == right_length == max_length:</span>
        <span class="s4"># return early as right_stat must be identical to left_stat</span>
        <span class="s2">return </span><span class="s1">left_stat</span><span class="s2">, </span><span class="s1">left_stat</span>

    <span class="s4"># Calculate statistic for the right side</span>
    <span class="s1">right_slice = _slice_at_axis(</span>
        <span class="s1">slice(right_index - right_length</span><span class="s2">, </span><span class="s1">right_index)</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">right_chunk = padded[right_slice]</span>
    <span class="s1">right_stat = stat_func(right_chunk</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">_round_if_needed(right_stat</span><span class="s2">, </span><span class="s1">padded.dtype)</span>

    <span class="s2">return </span><span class="s1">left_stat</span><span class="s2">, </span><span class="s1">right_stat</span>


<span class="s2">def </span><span class="s1">_set_reflect_both(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">include_edge=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pad `axis` of `arr` with reflection. 
 
    Parameters 
    ---------- 
    padded : ndarray 
        Input array of arbitrary shape. 
    axis : int 
        Axis along which to pad `arr`. 
    width_pair : (int, int) 
        Pair of widths that mark the pad area on both sides in the given 
        dimension. 
    method : str 
        Controls method of reflection; options are 'even' or 'odd'. 
    include_edge : bool 
        If true, edge value is included in reflection, otherwise the edge 
        value forms the symmetric axis to the reflection. 
 
    Returns 
    ------- 
    pad_amt : tuple of ints, length 2 
        New index positions of padding to do along the `axis`. If these are 
        both 0, padding is done in this dimension. 
    &quot;&quot;&quot;</span>
    <span class="s1">left_pad</span><span class="s2">, </span><span class="s1">right_pad = width_pair</span>
    <span class="s1">old_length = padded.shape[axis] - right_pad - left_pad</span>

    <span class="s2">if </span><span class="s1">include_edge:</span>
        <span class="s4"># Edge is included, we need to offset the pad amount by 1</span>
        <span class="s1">edge_offset = </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">edge_offset = </span><span class="s5">0  </span><span class="s4"># Edge is not included, no need to offset pad amount</span>
        <span class="s1">old_length -= </span><span class="s5">1  </span><span class="s4"># but must be omitted from the chunk</span>

    <span class="s2">if </span><span class="s1">left_pad &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># Pad with reflected values on left side:</span>
        <span class="s4"># First limit chunk size which can't be larger than pad area</span>
        <span class="s1">chunk_length = min(old_length</span><span class="s2">, </span><span class="s1">left_pad)</span>
        <span class="s4"># Slice right to left, stop on or next to edge, start relative to stop</span>
        <span class="s1">stop = left_pad - edge_offset</span>
        <span class="s1">start = stop + chunk_length</span>
        <span class="s1">left_slice = _slice_at_axis(slice(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">left_chunk = padded[left_slice]</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;odd&quot;</span><span class="s1">:</span>
            <span class="s4"># Negate chunk and align with edge</span>
            <span class="s1">edge_slice = _slice_at_axis(slice(left_pad</span><span class="s2">, </span><span class="s1">left_pad + </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">left_chunk = </span><span class="s5">2 </span><span class="s1">* padded[edge_slice] - left_chunk</span>

        <span class="s4"># Insert chunk into padded area</span>
        <span class="s1">start = left_pad - chunk_length</span>
        <span class="s1">stop = left_pad</span>
        <span class="s1">pad_area = _slice_at_axis(slice(start</span><span class="s2">, </span><span class="s1">stop)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">padded[pad_area] = left_chunk</span>
        <span class="s4"># Adjust pointer to left edge for next iteration</span>
        <span class="s1">left_pad -= chunk_length</span>

    <span class="s2">if </span><span class="s1">right_pad &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># Pad with reflected values on right side:</span>
        <span class="s4"># First limit chunk size which can't be larger than pad area</span>
        <span class="s1">chunk_length = min(old_length</span><span class="s2">, </span><span class="s1">right_pad)</span>
        <span class="s4"># Slice right to left, start on or next to edge, stop relative to start</span>
        <span class="s1">start = -right_pad + edge_offset - </span><span class="s5">2</span>
        <span class="s1">stop = start - chunk_length</span>
        <span class="s1">right_slice = _slice_at_axis(slice(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">right_chunk = padded[right_slice]</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;odd&quot;</span><span class="s1">:</span>
            <span class="s4"># Negate chunk and align with edge</span>
            <span class="s1">edge_slice = _slice_at_axis(</span>
                <span class="s1">slice(-right_pad - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-right_pad)</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">right_chunk = </span><span class="s5">2 </span><span class="s1">* padded[edge_slice] - right_chunk</span>

        <span class="s4"># Insert chunk into padded area</span>
        <span class="s1">start = padded.shape[axis] - right_pad</span>
        <span class="s1">stop = start + chunk_length</span>
        <span class="s1">pad_area = _slice_at_axis(slice(start</span><span class="s2">, </span><span class="s1">stop)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">padded[pad_area] = right_chunk</span>
        <span class="s4"># Adjust pointer to right edge for next iteration</span>
        <span class="s1">right_pad -= chunk_length</span>

    <span class="s2">return </span><span class="s1">left_pad</span><span class="s2">, </span><span class="s1">right_pad</span>


<span class="s2">def </span><span class="s1">_set_wrap_both(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pad `axis` of `arr` with wrapped values. 
 
    Parameters 
    ---------- 
    padded : ndarray 
        Input array of arbitrary shape. 
    axis : int 
        Axis along which to pad `arr`. 
    width_pair : (int, int) 
        Pair of widths that mark the pad area on both sides in the given 
        dimension. 
 
    Returns 
    ------- 
    pad_amt : tuple of ints, length 2 
        New index positions of padding to do along the `axis`. If these are 
        both 0, padding is done in this dimension. 
    &quot;&quot;&quot;</span>
    <span class="s1">left_pad</span><span class="s2">, </span><span class="s1">right_pad = width_pair</span>
    <span class="s1">period = padded.shape[axis] - right_pad - left_pad</span>

    <span class="s4"># If the current dimension of `arr` doesn't contain enough valid values</span>
    <span class="s4"># (not part of the undefined pad area) we need to pad multiple times.</span>
    <span class="s4"># Each time the pad area shrinks on both sides which is communicated with</span>
    <span class="s4"># these variables.</span>
    <span class="s1">new_left_pad = </span><span class="s5">0</span>
    <span class="s1">new_right_pad = </span><span class="s5">0</span>

    <span class="s2">if </span><span class="s1">left_pad &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># Pad with wrapped values on left side</span>
        <span class="s4"># First slice chunk from right side of the non-pad area.</span>
        <span class="s4"># Use min(period, left_pad) to ensure that chunk is not larger than</span>
        <span class="s4"># pad area</span>
        <span class="s1">right_slice = _slice_at_axis(</span>
            <span class="s1">slice(-right_pad - min(period</span><span class="s2">, </span><span class="s1">left_pad)</span><span class="s2">,</span>
                  <span class="s1">-right_pad </span><span class="s2">if </span><span class="s1">right_pad != </span><span class="s5">0 </span><span class="s2">else None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">axis</span>
        <span class="s1">)</span>
        <span class="s1">right_chunk = padded[right_slice]</span>

        <span class="s2">if </span><span class="s1">left_pad &gt; period:</span>
            <span class="s4"># Chunk is smaller than pad area</span>
            <span class="s1">pad_area = _slice_at_axis(slice(left_pad - period</span><span class="s2">, </span><span class="s1">left_pad)</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">new_left_pad = left_pad - period</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Chunk matches pad area</span>
            <span class="s1">pad_area = _slice_at_axis(slice(</span><span class="s2">None, </span><span class="s1">left_pad)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">padded[pad_area] = right_chunk</span>

    <span class="s2">if </span><span class="s1">right_pad &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># Pad with wrapped values on right side</span>
        <span class="s4"># First slice chunk from left side of the non-pad area.</span>
        <span class="s4"># Use min(period, right_pad) to ensure that chunk is not larger than</span>
        <span class="s4"># pad area</span>
        <span class="s1">left_slice = _slice_at_axis(</span>
            <span class="s1">slice(left_pad</span><span class="s2">, </span><span class="s1">left_pad + min(period</span><span class="s2">, </span><span class="s1">right_pad)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">left_chunk = padded[left_slice]</span>

        <span class="s2">if </span><span class="s1">right_pad &gt; period:</span>
            <span class="s4"># Chunk is smaller than pad area</span>
            <span class="s1">pad_area = _slice_at_axis(</span>
                <span class="s1">slice(-right_pad</span><span class="s2">, </span><span class="s1">-right_pad + period)</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">new_right_pad = right_pad - period</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Chunk matches pad area</span>
            <span class="s1">pad_area = _slice_at_axis(slice(-right_pad</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis)</span>
        <span class="s1">padded[pad_area] = left_chunk</span>

    <span class="s2">return </span><span class="s1">new_left_pad</span><span class="s2">, </span><span class="s1">new_right_pad</span>


<span class="s2">def </span><span class="s1">_as_pairs(x</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">as_index=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Broadcast `x` to an array with the shape (`ndim`, 2). 
 
    A helper function for `pad` that prepares and validates arguments like 
    `pad_width` for iteration in pairs. 
 
    Parameters 
    ---------- 
    x : {None, scalar, array-like} 
        The object to broadcast to the shape (`ndim`, 2). 
    ndim : int 
        Number of pairs the broadcasted `x` will have. 
    as_index : bool, optional 
        If `x` is not None, try to round each element of `x` to an integer 
        (dtype `np.intp`) and ensure every element is positive. 
 
    Returns 
    ------- 
    pairs : nested iterables, shape (`ndim`, 2) 
        The broadcasted version of `x`. 
 
    Raises 
    ------ 
    ValueError 
        If `as_index` is True and `x` contains negative elements. 
        Or if `x` is not broadcastable to the shape (`ndim`, 2). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s4"># Pass through None as a special case, otherwise np.round(x) fails</span>
        <span class="s4"># with an AttributeError</span>
        <span class="s2">return </span><span class="s1">((</span><span class="s2">None, None</span><span class="s1">)</span><span class="s2">,</span><span class="s1">) * ndim</span>

    <span class="s1">x = np.array(x)</span>
    <span class="s2">if </span><span class="s1">as_index:</span>
        <span class="s1">x = np.round(x).astype(np.intp</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">x.ndim &lt; </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s4"># Optimization: Possibly use faster paths for cases where `x` has</span>
        <span class="s4"># only 1 or 2 elements. `np.broadcast_to` could handle these as well</span>
        <span class="s4"># but is currently slower</span>

        <span class="s2">if </span><span class="s1">x.size == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># x was supplied as a single value</span>
            <span class="s1">x = x.ravel()  </span><span class="s4"># Ensure x[0] works for x.ndim == 0, 1, 2</span>
            <span class="s2">if </span><span class="s1">as_index </span><span class="s2">and </span><span class="s1">x &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;index can't contain negative values&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">((x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span><span class="s1">) * ndim</span>

        <span class="s2">if </span><span class="s1">x.size == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">x.shape != (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s4"># x was supplied with a single value for each side</span>
            <span class="s4"># but except case when each dimension has a single value</span>
            <span class="s4"># which should be broadcasted to a pair,</span>
            <span class="s4"># e.g. [[1], [2]] -&gt; [[1, 1], [2, 2]] not [[1, 2], [1, 2]]</span>
            <span class="s1">x = x.ravel()  </span><span class="s4"># Ensure x[0], x[1] works</span>
            <span class="s2">if </span><span class="s1">as_index </span><span class="s2">and </span><span class="s1">(x[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">] &lt; </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;index can't contain negative values&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">((x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span><span class="s1">) * ndim</span>

    <span class="s2">if </span><span class="s1">as_index </span><span class="s2">and </span><span class="s1">x.min() &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;index can't contain negative values&quot;</span><span class="s1">)</span>

    <span class="s4"># Converting the array with `tolist` seems to improve performance</span>
    <span class="s4"># when iterating and indexing the result (see usage in `pad`)</span>
    <span class="s2">return </span><span class="s1">np.broadcast_to(x</span><span class="s2">, </span><span class="s1">(ndim</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)).tolist()</span>


<span class="s2">def </span><span class="s1">_pad_dispatcher(array</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">mode=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
    <span class="s2">return </span><span class="s1">(array</span><span class="s2">,</span><span class="s1">)</span>


<span class="s4">###############################################################################</span>
<span class="s4"># Public functions</span>


<span class="s1">@array_function_dispatch(_pad_dispatcher</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">pad(array</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pad an array. 
 
    Parameters 
    ---------- 
    array : array_like of rank N 
        The array to pad. 
    pad_width : {sequence, array_like, int} 
        Number of values padded to the edges of each axis. 
        ((before_1, after_1), ... (before_N, after_N)) unique pad widths 
        for each axis. 
        ((before, after),) yields same before and after pad for each axis. 
        (pad,) or int is a shortcut for before = after = pad width for all 
        axes. 
    mode : str or function, optional 
        One of the following string values or a user supplied function. 
 
        'constant' (default) 
            Pads with a constant value. 
        'edge' 
            Pads with the edge values of array. 
        'linear_ramp' 
            Pads with the linear ramp between end_value and the 
            array edge value. 
        'maximum' 
            Pads with the maximum value of all or part of the 
            vector along each axis. 
        'mean' 
            Pads with the mean value of all or part of the 
            vector along each axis. 
        'median' 
            Pads with the median value of all or part of the 
            vector along each axis. 
        'minimum' 
            Pads with the minimum value of all or part of the 
            vector along each axis. 
        'reflect' 
            Pads with the reflection of the vector mirrored on 
            the first and last values of the vector along each 
            axis. 
        'symmetric' 
            Pads with the reflection of the vector mirrored 
            along the edge of the array. 
        'wrap' 
            Pads with the wrap of the vector along the axis. 
            The first values are used to pad the end and the 
            end values are used to pad the beginning. 
        'empty' 
            Pads with undefined values. 
 
            .. versionadded:: 1.17 
 
        &lt;function&gt; 
            Padding function, see Notes. 
    stat_length : sequence or int, optional 
        Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of 
        values at edge of each axis used to calculate the statistic value. 
 
        ((before_1, after_1), ... (before_N, after_N)) unique statistic 
        lengths for each axis. 
 
        ((before, after),) yields same before and after statistic lengths 
        for each axis. 
 
        (stat_length,) or int is a shortcut for before = after = statistic 
        length for all axes. 
 
        Default is ``None``, to use the entire axis. 
    constant_values : sequence or scalar, optional 
        Used in 'constant'.  The values to set the padded values for each 
        axis. 
 
        ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants 
        for each axis. 
 
        ``((before, after),)`` yields same before and after constants for each 
        axis. 
 
        ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for 
        all axes. 
 
        Default is 0. 
    end_values : sequence or scalar, optional 
        Used in 'linear_ramp'.  The values used for the ending value of the 
        linear_ramp and that will form the edge of the padded array. 
 
        ``((before_1, after_1), ... (before_N, after_N))`` unique end values 
        for each axis. 
 
        ``((before, after),)`` yields same before and after end values for each 
        axis. 
 
        ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for 
        all axes. 
 
        Default is 0. 
    reflect_type : {'even', 'odd'}, optional 
        Used in 'reflect', and 'symmetric'.  The 'even' style is the 
        default with an unaltered reflection around the edge value.  For 
        the 'odd' style, the extended part of the array is created by 
        subtracting the reflected values from two times the edge value. 
 
    Returns 
    ------- 
    pad : ndarray 
        Padded array of rank equal to `array` with shape increased 
        according to `pad_width`. 
 
    Notes 
    ----- 
    .. versionadded:: 1.7.0 
 
    For an array with rank greater than 1, some of the padding of later 
    axes is calculated from padding of previous axes.  This is easiest to 
    think about with a rank 2 array where the corners of the padded array 
    are calculated by using padded values from the first axis. 
 
    The padding function, if used, should modify a rank 1 array in-place. It 
    has the following signature:: 
 
        padding_func(vector, iaxis_pad_width, iaxis, kwargs) 
 
    where 
 
        vector : ndarray 
            A rank 1 array already padded with zeros.  Padded values are 
            vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:]. 
        iaxis_pad_width : tuple 
            A 2-tuple of ints, iaxis_pad_width[0] represents the number of 
            values padded at the beginning of vector where 
            iaxis_pad_width[1] represents the number of values padded at 
            the end of vector. 
        iaxis : int 
            The axis currently being calculated. 
        kwargs : dict 
            Any keyword arguments the function requires. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = [1, 2, 3, 4, 5] 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'constant', constant_values=(4, 6)) 
    array([4, 4, 1, ..., 6, 6, 6]) 
 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'edge') 
    array([1, 1, 1, ..., 5, 5, 5]) 
 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4)) 
    array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4]) 
 
    &gt;&gt;&gt; np.pad(a, (2,), 'maximum') 
    array([5, 5, 1, 2, 3, 4, 5, 5, 5]) 
 
    &gt;&gt;&gt; np.pad(a, (2,), 'mean') 
    array([3, 3, 1, 2, 3, 4, 5, 3, 3]) 
 
    &gt;&gt;&gt; np.pad(a, (2,), 'median') 
    array([3, 3, 1, 2, 3, 4, 5, 3, 3]) 
 
    &gt;&gt;&gt; a = [[1, 2], [3, 4]] 
    &gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), 'minimum') 
    array([[1, 1, 1, 2, 1, 1, 1], 
           [1, 1, 1, 2, 1, 1, 1], 
           [1, 1, 1, 2, 1, 1, 1], 
           [1, 1, 1, 2, 1, 1, 1], 
           [3, 3, 3, 4, 3, 3, 3], 
           [1, 1, 1, 2, 1, 1, 1], 
           [1, 1, 1, 2, 1, 1, 1]]) 
 
    &gt;&gt;&gt; a = [1, 2, 3, 4, 5] 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'reflect') 
    array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2]) 
 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'reflect', reflect_type='odd') 
    array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8]) 
 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric') 
    array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3]) 
 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric', reflect_type='odd') 
    array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7]) 
 
    &gt;&gt;&gt; np.pad(a, (2, 3), 'wrap') 
    array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3]) 
 
    &gt;&gt;&gt; def pad_with(vector, pad_width, iaxis, kwargs): 
    ...     pad_value = kwargs.get('padder', 10) 
    ...     vector[:pad_width[0]] = pad_value 
    ...     vector[-pad_width[1]:] = pad_value 
    &gt;&gt;&gt; a = np.arange(6) 
    &gt;&gt;&gt; a = a.reshape((2, 3)) 
    &gt;&gt;&gt; np.pad(a, 2, pad_with) 
    array([[10, 10, 10, 10, 10, 10, 10], 
           [10, 10, 10, 10, 10, 10, 10], 
           [10, 10,  0,  1,  2, 10, 10], 
           [10, 10,  3,  4,  5, 10, 10], 
           [10, 10, 10, 10, 10, 10, 10], 
           [10, 10, 10, 10, 10, 10, 10]]) 
    &gt;&gt;&gt; np.pad(a, 2, pad_with, padder=100) 
    array([[100, 100, 100, 100, 100, 100, 100], 
           [100, 100, 100, 100, 100, 100, 100], 
           [100, 100,   0,   1,   2, 100, 100], 
           [100, 100,   3,   4,   5, 100, 100], 
           [100, 100, 100, 100, 100, 100, 100], 
           [100, 100, 100, 100, 100, 100, 100]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">array = np.asarray(array)</span>
    <span class="s1">pad_width = np.asarray(pad_width)</span>

    <span class="s2">if not </span><span class="s1">pad_width.dtype.kind == </span><span class="s3">'i'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'`pad_width` must be of integral type.'</span><span class="s1">)</span>

    <span class="s4"># Broadcast to shape (array.ndim, 2)</span>
    <span class="s1">pad_width = _as_pairs(pad_width</span><span class="s2">, </span><span class="s1">array.ndim</span><span class="s2">, </span><span class="s1">as_index=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">callable(mode):</span>
        <span class="s4"># Old behavior: Use user-supplied function with np.apply_along_axis</span>
        <span class="s1">function = mode</span>
        <span class="s4"># Create a new zero padded array</span>
        <span class="s1">padded</span><span class="s2">, </span><span class="s1">_ = _pad_simple(array</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s4"># And apply along each axis</span>

        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range(padded.ndim):</span>
            <span class="s4"># Iterate using ndindex as in apply_along_axis, but assuming that</span>
            <span class="s4"># function operates inplace on the padded array.</span>

            <span class="s4"># view with the iteration axis at the end</span>
            <span class="s1">view = np.moveaxis(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

            <span class="s4"># compute indices for the iteration axes, and append a trailing</span>
            <span class="s4"># ellipsis to prevent 0d arrays decaying to scalars (gh-8642)</span>
            <span class="s1">inds = ndindex(view.shape[:-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">inds = (ind + (Ellipsis</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">inds)</span>
            <span class="s2">for </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">inds:</span>
                <span class="s1">function(view[ind]</span><span class="s2">, </span><span class="s1">pad_width[axis]</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">kwargs)</span>

        <span class="s2">return </span><span class="s1">padded</span>

    <span class="s4"># Make sure that no unsupported keywords were passed for the current mode</span>
    <span class="s1">allowed_kwargs = {</span>
        <span class="s3">'empty'</span><span class="s1">: []</span><span class="s2">, </span><span class="s3">'edge'</span><span class="s1">: []</span><span class="s2">, </span><span class="s3">'wrap'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s3">'constant'</span><span class="s1">: [</span><span class="s3">'constant_values'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'linear_ramp'</span><span class="s1">: [</span><span class="s3">'end_values'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'maximum'</span><span class="s1">: [</span><span class="s3">'stat_length'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'mean'</span><span class="s1">: [</span><span class="s3">'stat_length'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'median'</span><span class="s1">: [</span><span class="s3">'stat_length'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'minimum'</span><span class="s1">: [</span><span class="s3">'stat_length'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'reflect'</span><span class="s1">: [</span><span class="s3">'reflect_type'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">'symmetric'</span><span class="s1">: [</span><span class="s3">'reflect_type'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">unsupported_kwargs = set(kwargs) - set(allowed_kwargs[mode])</span>
    <span class="s2">except </span><span class="s1">KeyError:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;mode '{}' is not supported&quot;</span><span class="s1">.format(mode)) </span><span class="s2">from None</span>
    <span class="s2">if </span><span class="s1">unsupported_kwargs:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unsupported keyword arguments for mode '{}': {}&quot;</span>
                         <span class="s1">.format(mode</span><span class="s2">, </span><span class="s1">unsupported_kwargs))</span>

    <span class="s1">stat_functions = {</span><span class="s3">&quot;maximum&quot;</span><span class="s1">: np.amax</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s1">: np.amin</span><span class="s2">,</span>
                      <span class="s3">&quot;mean&quot;</span><span class="s1">: np.mean</span><span class="s2">, </span><span class="s3">&quot;median&quot;</span><span class="s1">: np.median}</span>

    <span class="s4"># Create array with final shape and original values</span>
    <span class="s4"># (padded area is undefined)</span>
    <span class="s1">padded</span><span class="s2">, </span><span class="s1">original_area_slice = _pad_simple(array</span><span class="s2">, </span><span class="s1">pad_width)</span>
    <span class="s4"># And prepare iteration over all dimensions</span>
    <span class="s4"># (zipping may be more readable than using enumerate)</span>
    <span class="s1">axes = range(padded.ndim)</span>

    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;constant&quot;</span><span class="s1">:</span>
        <span class="s1">values = kwargs.get(</span><span class="s3">&quot;constant_values&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">values = _as_pairs(values</span><span class="s2">, </span><span class="s1">padded.ndim)</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">value_pair </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">values):</span>
            <span class="s1">roi = _view_roi(padded</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">_set_pad_area(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">value_pair)</span>

    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;empty&quot;</span><span class="s1">:</span>
        <span class="s2">pass  </span><span class="s4"># Do nothing as _pad_simple already returned the correct result</span>

    <span class="s2">elif </span><span class="s1">array.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># Only modes &quot;constant&quot; and &quot;empty&quot; can extend empty axes, all other</span>
        <span class="s4"># modes depend on `array` not being empty</span>
        <span class="s4"># -&gt; ensure every empty axis is only &quot;padded with 0&quot;</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width):</span>
            <span class="s2">if </span><span class="s1">array.shape[axis] == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">any(width_pair):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;can't extend empty axis {} using modes other than &quot;</span>
                    <span class="s3">&quot;'constant' or 'empty'&quot;</span><span class="s1">.format(axis)</span>
                <span class="s1">)</span>
        <span class="s4"># passed, don't need to do anything more as _pad_simple already</span>
        <span class="s4"># returned the correct result</span>

    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;edge&quot;</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width):</span>
            <span class="s1">roi = _view_roi(padded</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">edge_pair = _get_edges(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair)</span>
            <span class="s1">_set_pad_area(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">edge_pair)</span>

    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;linear_ramp&quot;</span><span class="s1">:</span>
        <span class="s1">end_values = kwargs.get(</span><span class="s3">&quot;end_values&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">end_values = _as_pairs(end_values</span><span class="s2">, </span><span class="s1">padded.ndim)</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">value_pair </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">end_values):</span>
            <span class="s1">roi = _view_roi(padded</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">ramp_pair = _get_linear_ramps(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">value_pair)</span>
            <span class="s1">_set_pad_area(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">ramp_pair)</span>

    <span class="s2">elif </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">stat_functions:</span>
        <span class="s1">func = stat_functions[mode]</span>
        <span class="s1">length = kwargs.get(</span><span class="s3">&quot;stat_length&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">length = _as_pairs(length</span><span class="s2">, </span><span class="s1">padded.ndim</span><span class="s2">, </span><span class="s1">as_index=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">length_pair </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width</span><span class="s2">, </span><span class="s1">length):</span>
            <span class="s1">roi = _view_roi(padded</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">stat_pair = _get_stats(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">length_pair</span><span class="s2">, </span><span class="s1">func)</span>
            <span class="s1">_set_pad_area(roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">width_pair</span><span class="s2">, </span><span class="s1">stat_pair)</span>

    <span class="s2">elif </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;reflect&quot;</span><span class="s2">, </span><span class="s3">&quot;symmetric&quot;</span><span class="s1">}:</span>
        <span class="s1">method = kwargs.get(</span><span class="s3">&quot;reflect_type&quot;</span><span class="s2">, </span><span class="s3">&quot;even&quot;</span><span class="s1">)</span>
        <span class="s1">include_edge = </span><span class="s2">True if </span><span class="s1">mode == </span><span class="s3">&quot;symmetric&quot; </span><span class="s2">else False</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">(left_index</span><span class="s2">, </span><span class="s1">right_index) </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width):</span>
            <span class="s2">if </span><span class="s1">array.shape[axis] == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">(left_index &gt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">right_index &gt; </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s4"># Extending singleton dimension for 'reflect' is legacy</span>
                <span class="s4"># behavior; it really should raise an error.</span>
                <span class="s1">edge_pair = _get_edges(padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">(left_index</span><span class="s2">, </span><span class="s1">right_index))</span>
                <span class="s1">_set_pad_area(</span>
                    <span class="s1">padded</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">(left_index</span><span class="s2">, </span><span class="s1">right_index)</span><span class="s2">, </span><span class="s1">edge_pair)</span>
                <span class="s2">continue</span>

            <span class="s1">roi = _view_roi(padded</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s2">while </span><span class="s1">left_index &gt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">right_index &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># Iteratively pad until dimension is filled with reflected</span>
                <span class="s4"># values. This is necessary if the pad area is larger than</span>
                <span class="s4"># the length of the original values in the current dimension.</span>
                <span class="s1">left_index</span><span class="s2">, </span><span class="s1">right_index = _set_reflect_both(</span>
                    <span class="s1">roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">(left_index</span><span class="s2">, </span><span class="s1">right_index)</span><span class="s2">,</span>
                    <span class="s1">method</span><span class="s2">, </span><span class="s1">include_edge</span>
                <span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;wrap&quot;</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">(left_index</span><span class="s2">, </span><span class="s1">right_index) </span><span class="s2">in </span><span class="s1">zip(axes</span><span class="s2">, </span><span class="s1">pad_width):</span>
            <span class="s1">roi = _view_roi(padded</span><span class="s2">, </span><span class="s1">original_area_slice</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s2">while </span><span class="s1">left_index &gt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">right_index &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># Iteratively pad until dimension is filled with wrapped</span>
                <span class="s4"># values. This is necessary if the pad area is larger than</span>
                <span class="s4"># the length of the original values in the current dimension.</span>
                <span class="s1">left_index</span><span class="s2">, </span><span class="s1">right_index = _set_wrap_both(</span>
                    <span class="s1">roi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">(left_index</span><span class="s2">, </span><span class="s1">right_index))</span>

    <span class="s2">return </span><span class="s1">padded</span>
</pre>
</body>
</html>