<html>
<head>
<title>datastructures.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
datastructures.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">codecs</span>
<span class="s0">import </span><span class="s1">mimetypes</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Collection</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">MutableSet</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">repeat</span>
<span class="s0">from </span><span class="s1">os </span><span class="s0">import </span><span class="s1">fspath</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">exceptions</span>
<span class="s0">from </span><span class="s1">._internal </span><span class="s0">import </span><span class="s1">_make_encode_wrapper</span>
<span class="s0">from </span><span class="s1">._internal </span><span class="s0">import </span><span class="s1">_missing</span>
<span class="s0">from </span><span class="s1">.filesystem </span><span class="s0">import </span><span class="s1">get_filesystem_encoding</span>


<span class="s0">def </span><span class="s1">is_immutable(self):</span>
    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">!r} </span><span class="s2">objects are immutable&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">iter_multi_items(mapping):</span>
    <span class="s3">&quot;&quot;&quot;Iterates over the items of a mapping yielding keys and values 
    without dropping any from more complex structures. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">MultiDict):</span>
        <span class="s0">yield from </span><span class="s1">mapping.items(multi=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">mapping.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
                <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value:</span>
                    <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">v</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">yield from </span><span class="s1">mapping</span>


<span class="s0">class </span><span class="s1">ImmutableListMixin:</span>
    <span class="s3">&quot;&quot;&quot;Makes a :class:`list` immutable. 
 
    .. versionadded:: 0.5 
 
    :private: 
    &quot;&quot;&quot;</span>

    <span class="s1">_hash_cache = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">if </span><span class="s1">self._hash_cache </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._hash_cache</span>
        <span class="s1">rv = self._hash_cache = hash(tuple(self))</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">__reduce_ex__(self</span><span class="s0">, </span><span class="s1">protocol):</span>
        <span class="s0">return </span><span class="s1">type(self)</span><span class="s0">, </span><span class="s1">(list(self)</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">__iadd__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">__imul__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">append(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">remove(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">extend(self</span><span class="s0">, </span><span class="s1">iterable):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">index=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">reverse(self):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">sort(self</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None, </span><span class="s1">reverse=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">is_immutable(self)</span>


<span class="s0">class </span><span class="s1">ImmutableList(ImmutableListMixin</span><span class="s0">, </span><span class="s1">list):</span>
    <span class="s3">&quot;&quot;&quot;An immutable :class:`list`. 
 
    .. versionadded:: 0.5 
 
    :private: 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">list.__repr__(self)</span><span class="s0">}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">ImmutableDictMixin:</span>
    <span class="s3">&quot;&quot;&quot;Makes a :class:`dict` immutable. 
 
    .. versionadded:: 0.5 
 
    :private: 
    &quot;&quot;&quot;</span>

    <span class="s1">_hash_cache = </span><span class="s0">None</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">fromkeys(cls</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">value=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">instance = super().__new__(cls)</span>
        <span class="s1">instance.__init__(zip(keys</span><span class="s0">, </span><span class="s1">repeat(value)))</span>
        <span class="s0">return </span><span class="s1">instance</span>

    <span class="s0">def </span><span class="s1">__reduce_ex__(self</span><span class="s0">, </span><span class="s1">protocol):</span>
        <span class="s0">return </span><span class="s1">type(self)</span><span class="s0">, </span><span class="s1">(dict(self)</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_iter_hashitems(self):</span>
        <span class="s0">return </span><span class="s1">self.items()</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">if </span><span class="s1">self._hash_cache </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._hash_cache</span>
        <span class="s1">rv = self._hash_cache = hash(frozenset(self._iter_hashitems()))</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">popitem(self):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s1">is_immutable(self)</span>


<span class="s0">class </span><span class="s1">ImmutableMultiDictMixin(ImmutableDictMixin):</span>
    <span class="s3">&quot;&quot;&quot;Makes a :class:`MultiDict` immutable. 
 
    .. versionadded:: 0.5 
 
    :private: 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__reduce_ex__(self</span><span class="s0">, </span><span class="s1">protocol):</span>
        <span class="s0">return </span><span class="s1">type(self)</span><span class="s0">, </span><span class="s1">(list(self.items(multi=</span><span class="s0">True</span><span class="s1">))</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_iter_hashitems(self):</span>
        <span class="s0">return </span><span class="s1">self.items(multi=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">popitemlist(self):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">poplist(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">setlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">new_list):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">setlistdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default_list=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">is_immutable(self)</span>


<span class="s0">def </span><span class="s1">_calls_update(name):</span>
    <span class="s0">def </span><span class="s1">oncall(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">rv = getattr(super(UpdateDictMixin</span><span class="s0">, </span><span class="s1">self)</span><span class="s0">, </span><span class="s1">name)(*args</span><span class="s0">, </span><span class="s1">**kw)</span>

        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s1">oncall.__name__ = name</span>
    <span class="s0">return </span><span class="s1">oncall</span>


<span class="s0">class </span><span class="s1">UpdateDictMixin(dict):</span>
    <span class="s3">&quot;&quot;&quot;Makes dicts call `self.on_update` on modifications. 
 
    .. versionadded:: 0.5 
 
    :private: 
    &quot;&quot;&quot;</span>

    <span class="s1">on_update = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">modified = key </span><span class="s0">not in </span><span class="s1">self</span>
        <span class="s1">rv = super().setdefault(key</span><span class="s0">, </span><span class="s1">default)</span>
        <span class="s0">if </span><span class="s1">modified </span><span class="s0">and </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=_missing):</span>
        <span class="s1">modified = key </span><span class="s0">in </span><span class="s1">self</span>
        <span class="s0">if </span><span class="s1">default </span><span class="s0">is </span><span class="s1">_missing:</span>
            <span class="s1">rv = super().pop(key)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">rv = super().pop(key</span><span class="s0">, </span><span class="s1">default)</span>
        <span class="s0">if </span><span class="s1">modified </span><span class="s0">and </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s1">__setitem__ = _calls_update(</span><span class="s2">&quot;__setitem__&quot;</span><span class="s1">)</span>
    <span class="s1">__delitem__ = _calls_update(</span><span class="s2">&quot;__delitem__&quot;</span><span class="s1">)</span>
    <span class="s1">clear = _calls_update(</span><span class="s2">&quot;clear&quot;</span><span class="s1">)</span>
    <span class="s1">popitem = _calls_update(</span><span class="s2">&quot;popitem&quot;</span><span class="s1">)</span>
    <span class="s1">update = _calls_update(</span><span class="s2">&quot;update&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TypeConversionDict(dict):</span>
    <span class="s3">&quot;&quot;&quot;Works like a regular dict but the :meth:`get` method can perform 
    type conversions.  :class:`MultiDict` and :class:`CombinedMultiDict` 
    are subclasses of this class and provide the same feature. 
 
    .. versionadded:: 0.5 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">get(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the default value if the requested data doesn't exist. 
        If `type` is provided and is a callable it should convert the value, 
        return it or raise a :exc:`ValueError` if that is not possible.  In 
        this case the function will return the default as if the value was not 
        found: 
 
        &gt;&gt;&gt; d = TypeConversionDict(foo='42', bar='blub') 
        &gt;&gt;&gt; d.get('foo', type=int) 
        42 
        &gt;&gt;&gt; d.get('bar', -1, type=int) 
        -1 
 
        :param key: The key to be looked up. 
        :param default: The default value to be returned if the key can't 
                        be looked up.  If not further specified `None` is 
                        returned. 
        :param type: A callable that is used to cast the value in the 
                     :class:`MultiDict`.  If a :exc:`ValueError` is raised 
                     by this callable the default value is returned. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = self[key]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">default</span>
        <span class="s0">if </span><span class="s1">type </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">rv = type(rv)</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">rv = default</span>
        <span class="s0">return </span><span class="s1">rv</span>


<span class="s0">class </span><span class="s1">ImmutableTypeConversionDict(ImmutableDictMixin</span><span class="s0">, </span><span class="s1">TypeConversionDict):</span>
    <span class="s3">&quot;&quot;&quot;Works like a :class:`TypeConversionDict` but does not support 
    modifications. 
 
    .. versionadded:: 0.5 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a shallow mutable copy of this object.  Keep in mind that 
        the standard library's :func:`copy` function is a no-op for this class 
        like for any other python immutable type (eg: :class:`tuple`). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">TypeConversionDict(self)</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">MultiDict(TypeConversionDict):</span>
    <span class="s3">&quot;&quot;&quot;A :class:`MultiDict` is a dictionary subclass customized to deal with 
    multiple values for the same key which is for example used by the parsing 
    functions in the wrappers.  This is necessary because some HTML form 
    elements pass multiple values for the same key. 
 
    :class:`MultiDict` implements all standard dictionary methods. 
    Internally, it saves all values for a key as a list, but the standard dict 
    access methods will only return the first value for a key. If you want to 
    gain access to the other values, too, you have to use the `list` methods as 
    explained below. 
 
    Basic Usage: 
 
    &gt;&gt;&gt; d = MultiDict([('a', 'b'), ('a', 'c')]) 
    &gt;&gt;&gt; d 
    MultiDict([('a', 'b'), ('a', 'c')]) 
    &gt;&gt;&gt; d['a'] 
    'b' 
    &gt;&gt;&gt; d.getlist('a') 
    ['b', 'c'] 
    &gt;&gt;&gt; 'a' in d 
    True 
 
    It behaves like a normal dict thus all dict functions will only return the 
    first value when multiple values for one key are found. 
 
    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a 
    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will 
    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP 
    exceptions. 
 
    A :class:`MultiDict` can be constructed from an iterable of 
    ``(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2 
    onwards some keyword parameters. 
 
    :param mapping: the initial value for the :class:`MultiDict`.  Either a 
                    regular dict, an iterable of ``(key, value)`` tuples 
                    or `None`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">mapping=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">MultiDict):</span>
            <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">((k</span><span class="s0">, </span><span class="s1">l[:]) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">l </span><span class="s0">in </span><span class="s1">mapping.lists()))</span>
        <span class="s0">elif </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">tmp = {}</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">mapping.items():</span>
                <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
                    <span class="s0">if </span><span class="s1">len(value) == </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">value = list(value)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">value = [value]</span>
                <span class="s1">tmp[key] = value</span>
            <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">tmp)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tmp = {}</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">mapping </span><span class="s0">or </span><span class="s1">():</span>
                <span class="s1">tmp.setdefault(key</span><span class="s0">, </span><span class="s1">[]).append(value)</span>
            <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">tmp)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0">return </span><span class="s1">dict(self.lists())</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">dict.clear(self)</span>
        <span class="s1">dict.update(self</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s5"># Work around https://bugs.python.org/issue43246.</span>
        <span class="s5"># (`return super().__iter__()` also works here, which makes this look</span>
        <span class="s5"># even more like it should be a no-op, yet it isn't.)</span>
        <span class="s0">return </span><span class="s1">dict.__iter__(self)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Return the first data value for this key; 
        raises KeyError if not found. 
 
        :param key: The key to be looked up. 
        :raise KeyError: if the key does not exist. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s1">lst = dict.__getitem__(self</span><span class="s0">, </span><span class="s1">key)</span>
            <span class="s0">if </span><span class="s1">len(lst) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">lst[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`add` but removes an existing key first. 
 
        :param key: the key for the value. 
        :param value: the value to set. 
        &quot;&quot;&quot;</span>
        <span class="s1">dict.__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">[value])</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot;Adds a new value for the key. 
 
        .. versionadded:: 0.6 
 
        :param key: the key for the value. 
        :param value: the value to add. 
        &quot;&quot;&quot;</span>
        <span class="s1">dict.setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">[]).append(value)</span>

    <span class="s0">def </span><span class="s1">getlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the list of items for a given key. If that key is not in the 
        `MultiDict`, the return value will be an empty list.  Just like `get`, 
        `getlist` accepts a `type` parameter.  All items will be converted 
        with the callable defined there. 
 
        :param key: The key to be looked up. 
        :param type: A callable that is used to cast the value in the 
                     :class:`MultiDict`.  If a :exc:`ValueError` is raised 
                     by this callable the value will be removed from the list. 
        :return: a :class:`list` of all the values for the key. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = dict.__getitem__(self</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s0">if </span><span class="s1">type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">list(rv)</span>
        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">rv:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result.append(type(item))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">setlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">new_list):</span>
        <span class="s3">&quot;&quot;&quot;Remove the old values for a key and add new ones.  Note that the list 
        you pass the values in will be shallow-copied before it is inserted in 
        the dictionary. 
 
        &gt;&gt;&gt; d = MultiDict() 
        &gt;&gt;&gt; d.setlist('foo', ['1', '2']) 
        &gt;&gt;&gt; d['foo'] 
        '1' 
        &gt;&gt;&gt; d.getlist('foo') 
        ['1', '2'] 
 
        :param key: The key for which the values are set. 
        :param new_list: An iterable with the new values for the key.  Old values 
                         are removed first. 
        &quot;&quot;&quot;</span>
        <span class="s1">dict.__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">list(new_list))</span>

    <span class="s0">def </span><span class="s1">setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Returns the value for the key if it is in the dict, otherwise it 
        returns `default` and sets that value for `key`. 
 
        :param key: The key to be looked up. 
        :param default: The default value to be returned if the key is not 
                        in the dict.  If not further specified it's `None`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self:</span>
            <span class="s1">self[key] = default</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">default = self[key]</span>
        <span class="s0">return </span><span class="s1">default</span>

    <span class="s0">def </span><span class="s1">setlistdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default_list=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Like `setdefault` but sets multiple values.  The list returned 
        is not a copy, but the list that is actually used internally.  This 
        means that you can put new values into the dict by appending items 
        to the list: 
 
        &gt;&gt;&gt; d = MultiDict({&quot;foo&quot;: 1}) 
        &gt;&gt;&gt; d.setlistdefault(&quot;foo&quot;).extend([2, 3]) 
        &gt;&gt;&gt; d.getlist(&quot;foo&quot;) 
        [1, 2, 3] 
 
        :param key: The key to be looked up. 
        :param default_list: An iterable of default values.  It is either copied 
                             (in case it was a list) or converted into a list 
                             before returned. 
        :return: a :class:`list` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self:</span>
            <span class="s1">default_list = list(default_list </span><span class="s0">or </span><span class="s1">())</span>
            <span class="s1">dict.__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default_list)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">default_list = dict.__getitem__(self</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s0">return </span><span class="s1">default_list</span>

    <span class="s0">def </span><span class="s1">items(self</span><span class="s0">, </span><span class="s1">multi=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return an iterator of ``(key, value)`` pairs. 
 
        :param multi: If set to `True` the iterator returned will have a pair 
                      for each value of each key.  Otherwise it will only 
                      contain pairs for the first value of each key. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">dict.items(self):</span>
            <span class="s0">if </span><span class="s1">multi:</span>
                <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values:</span>
                    <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">lists(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a iterator of ``(key, values)`` pairs, where values is the list 
        of all values associated with the key.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">dict.items(self):</span>
            <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">list(values)</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s3">&quot;&quot;&quot;Returns an iterator of the first value on every key's value list.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">values </span><span class="s0">in </span><span class="s1">dict.values(self):</span>
            <span class="s0">yield </span><span class="s1">values[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">listvalues(self):</span>
        <span class="s3">&quot;&quot;&quot;Return an iterator of all values associated with a key.  Zipping 
        :meth:`keys` and this is the same as calling :meth:`lists`: 
 
        &gt;&gt;&gt; d = MultiDict({&quot;foo&quot;: [1, 2, 3]}) 
        &gt;&gt;&gt; zip(d.keys(), d.listvalues()) == d.lists() 
        True 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">dict.values(self)</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a shallow copy of this object.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.__class__(self)</span>

    <span class="s0">def </span><span class="s1">deepcopy(self</span><span class="s0">, </span><span class="s1">memo=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return a deep copy of this object.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.__class__(deepcopy(self.to_dict(flat=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">memo))</span>

    <span class="s0">def </span><span class="s1">to_dict(self</span><span class="s0">, </span><span class="s1">flat=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the contents as regular dict.  If `flat` is `True` the 
        returned dict will only have the first item present, if `flat` is 
        `False` all values will be returned as lists. 
 
        :param flat: If set to `False` the dict returned will have lists 
                     with all the values in it.  Otherwise it will only 
                     contain the first value for each key. 
        :return: a :class:`dict` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">flat:</span>
            <span class="s0">return </span><span class="s1">dict(self.items())</span>
        <span class="s0">return </span><span class="s1">dict(self.lists())</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">mapping):</span>
        <span class="s3">&quot;&quot;&quot;update() extends rather than replaces existing key lists: 
 
        &gt;&gt;&gt; a = MultiDict({'x': 1}) 
        &gt;&gt;&gt; b = MultiDict({'x': 2, 'y': 3}) 
        &gt;&gt;&gt; a.update(b) 
        &gt;&gt;&gt; a 
        MultiDict([('y', 3), ('x', 1), ('x', 2)]) 
 
        If the value list for a key in ``other_dict`` is empty, no new values 
        will be added to the dict and the key will not be created: 
 
        &gt;&gt;&gt; x = {'empty_list': []} 
        &gt;&gt;&gt; y = MultiDict() 
        &gt;&gt;&gt; y.update(x) 
        &gt;&gt;&gt; y 
        MultiDict([]) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(mapping):</span>
            <span class="s1">MultiDict.add(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=_missing):</span>
        <span class="s3">&quot;&quot;&quot;Pop the first item for a list on the dict.  Afterwards the 
        key is removed from the dict, so additional values are discarded: 
 
        &gt;&gt;&gt; d = MultiDict({&quot;foo&quot;: [1, 2, 3]}) 
        &gt;&gt;&gt; d.pop(&quot;foo&quot;) 
        1 
        &gt;&gt;&gt; &quot;foo&quot; in d 
        False 
 
        :param key: the key to pop. 
        :param default: if provided the value to return if the key was 
                        not in the dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">lst = dict.pop(self</span><span class="s0">, </span><span class="s1">key)</span>

            <span class="s0">if </span><span class="s1">len(lst) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key)</span>

            <span class="s0">return </span><span class="s1">lst[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">if </span><span class="s1">default </span><span class="s0">is not </span><span class="s1">_missing:</span>
                <span class="s0">return </span><span class="s1">default</span>

            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key) </span><span class="s0">from None</span>

    <span class="s0">def </span><span class="s1">popitem(self):</span>
        <span class="s3">&quot;&quot;&quot;Pop an item from the dict.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">item = dict.popitem(self)</span>

            <span class="s0">if </span><span class="s1">len(item[</span><span class="s4">1</span><span class="s1">]) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(item[</span><span class="s4">0</span><span class="s1">])</span>

            <span class="s0">return </span><span class="s1">(item[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">item[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(e.args[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">from None</span>

    <span class="s0">def </span><span class="s1">poplist(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Pop the list for a key from the dict.  If the key is not in the dict 
        an empty list is returned. 
 
        .. versionchanged:: 0.5 
           If the key does no longer exist a list is returned instead of 
           raising an error. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">dict.pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s0">def </span><span class="s1">popitemlist(self):</span>
        <span class="s3">&quot;&quot;&quot;Pop a ``(key, list)`` tuple from the dict.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">dict.popitem(self)</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(e.args[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">from None</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">return </span><span class="s1">self.copy()</span>

    <span class="s0">def </span><span class="s1">__deepcopy__(self</span><span class="s0">, </span><span class="s1">memo):</span>
        <span class="s0">return </span><span class="s1">self.deepcopy(memo=memo)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">list(self.items(multi=</span><span class="s0">True</span><span class="s1">))</span><span class="s0">!r}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">_omd_bucket:</span>
    <span class="s3">&quot;&quot;&quot;Wraps values in the :class:`OrderedMultiDict`.  This makes it 
    possible to keep an order over multiple different keys.  It requires 
    a lot of extra memory and slows down access a lot, but makes it 
    possible to access elements in O(1) and iterate in O(n). 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s2">&quot;prev&quot;</span><span class="s0">, </span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s2">&quot;next&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">omd</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self.prev = omd._last_bucket</span>
        <span class="s1">self.key = key</span>
        <span class="s1">self.value = value</span>
        <span class="s1">self.next = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">omd._first_bucket </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">omd._first_bucket = self</span>
        <span class="s0">if </span><span class="s1">omd._last_bucket </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">omd._last_bucket.next = self</span>
        <span class="s1">omd._last_bucket = self</span>

    <span class="s0">def </span><span class="s1">unlink(self</span><span class="s0">, </span><span class="s1">omd):</span>
        <span class="s0">if </span><span class="s1">self.prev:</span>
            <span class="s1">self.prev.next = self.next</span>
        <span class="s0">if </span><span class="s1">self.next:</span>
            <span class="s1">self.next.prev = self.prev</span>
        <span class="s0">if </span><span class="s1">omd._first_bucket </span><span class="s0">is </span><span class="s1">self:</span>
            <span class="s1">omd._first_bucket = self.next</span>
        <span class="s0">if </span><span class="s1">omd._last_bucket </span><span class="s0">is </span><span class="s1">self:</span>
            <span class="s1">omd._last_bucket = self.prev</span>


<span class="s0">class </span><span class="s1">OrderedMultiDict(MultiDict):</span>
    <span class="s3">&quot;&quot;&quot;Works like a regular :class:`MultiDict` but preserves the 
    order of the fields.  To convert the ordered multi dict into a 
    list you can use the :meth:`items` method and pass it ``multi=True``. 
 
    In general an :class:`OrderedMultiDict` is an order of magnitude 
    slower than a :class:`MultiDict`. 
 
    .. admonition:: note 
 
       Due to a limitation in Python you cannot convert an ordered 
       multi dict into a regular dict by using ``dict(multidict)``. 
       Instead you have to use the :meth:`to_dict` method, otherwise 
       the internal bucket objects are exposed. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">mapping=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dict.__init__(self)</span>
        <span class="s1">self._first_bucket = self._last_bucket = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">mapping </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">OrderedMultiDict.update(self</span><span class="s0">, </span><span class="s1">mapping)</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">MultiDict):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">OrderedMultiDict):</span>
            <span class="s1">iter1 = iter(self.items(multi=</span><span class="s0">True</span><span class="s1">))</span>
            <span class="s1">iter2 = iter(other.items(multi=</span><span class="s0">True</span><span class="s1">))</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">k1</span><span class="s0">, </span><span class="s1">v1 </span><span class="s0">in </span><span class="s1">iter1:</span>
                    <span class="s1">k2</span><span class="s0">, </span><span class="s1">v2 = next(iter2)</span>
                    <span class="s0">if </span><span class="s1">k1 != k2 </span><span class="s0">or </span><span class="s1">v1 != v2:</span>
                        <span class="s0">return False</span>
            <span class="s0">except </span><span class="s1">StopIteration:</span>
                <span class="s0">return False</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">next(iter2)</span>
            <span class="s0">except </span><span class="s1">StopIteration:</span>
                <span class="s0">return True</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s1">len(self) != len(other):</span>
            <span class="s0">return False</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">self.lists():</span>
            <span class="s0">if </span><span class="s1">other.getlist(key) != values:</span>
                <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s1">__hash__ = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__reduce_ex__(self</span><span class="s0">, </span><span class="s1">protocol):</span>
        <span class="s0">return </span><span class="s1">type(self)</span><span class="s0">, </span><span class="s1">(list(self.items(multi=</span><span class="s0">True</span><span class="s1">))</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0">return </span><span class="s1">list(self.items(multi=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s1">dict.clear(self)</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values:</span>
            <span class="s1">self.add(key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">return </span><span class="s1">dict.__getitem__(self</span><span class="s0">, </span><span class="s1">key)[</span><span class="s4">0</span><span class="s1">].value</span>
        <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self.poplist(key)</span>
        <span class="s1">self.add(key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">self.pop(key)</span>

    <span class="s0">def </span><span class="s1">keys(self):</span>
        <span class="s0">return </span><span class="s1">(key </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.items())</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self.keys())</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s0">return </span><span class="s1">(value </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.items())</span>

    <span class="s0">def </span><span class="s1">items(self</span><span class="s0">, </span><span class="s1">multi=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">ptr = self._first_bucket</span>
        <span class="s0">if </span><span class="s1">multi:</span>
            <span class="s0">while </span><span class="s1">ptr </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">ptr.key</span><span class="s0">, </span><span class="s1">ptr.value</span>
                <span class="s1">ptr = ptr.next</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">returned_keys = set()</span>
            <span class="s0">while </span><span class="s1">ptr </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">ptr.key </span><span class="s0">not in </span><span class="s1">returned_keys:</span>
                    <span class="s1">returned_keys.add(ptr.key)</span>
                    <span class="s0">yield </span><span class="s1">ptr.key</span><span class="s0">, </span><span class="s1">ptr.value</span>
                <span class="s1">ptr = ptr.next</span>

    <span class="s0">def </span><span class="s1">lists(self):</span>
        <span class="s1">returned_keys = set()</span>
        <span class="s1">ptr = self._first_bucket</span>
        <span class="s0">while </span><span class="s1">ptr </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">ptr.key </span><span class="s0">not in </span><span class="s1">returned_keys:</span>
                <span class="s0">yield </span><span class="s1">ptr.key</span><span class="s0">, </span><span class="s1">self.getlist(ptr.key)</span>
                <span class="s1">returned_keys.add(ptr.key)</span>
            <span class="s1">ptr = ptr.next</span>

    <span class="s0">def </span><span class="s1">listvalues(self):</span>
        <span class="s0">for </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">self.lists():</span>
            <span class="s0">yield </span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">dict.setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">[]).append(_omd_bucket(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value))</span>

    <span class="s0">def </span><span class="s1">getlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = dict.__getitem__(self</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s0">if </span><span class="s1">type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[x.value </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">rv]</span>
        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">rv:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result.append(type(item.value))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">setlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">new_list):</span>
        <span class="s1">self.poplist(key)</span>
        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">new_list:</span>
            <span class="s1">self.add(key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">setlistdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default_list=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;setlistdefault is unsupported for ordered multi dicts&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">mapping):</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(mapping):</span>
            <span class="s1">OrderedMultiDict.add(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">poplist(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">buckets = dict.pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s0">for </span><span class="s1">bucket </span><span class="s0">in </span><span class="s1">buckets:</span>
            <span class="s1">bucket.unlink(self)</span>
        <span class="s0">return </span><span class="s1">[x.value </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">buckets]</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=_missing):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">buckets = dict.pop(self</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">if </span><span class="s1">default </span><span class="s0">is not </span><span class="s1">_missing:</span>
                <span class="s0">return </span><span class="s1">default</span>

            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key) </span><span class="s0">from None</span>

        <span class="s0">for </span><span class="s1">bucket </span><span class="s0">in </span><span class="s1">buckets:</span>
            <span class="s1">bucket.unlink(self)</span>

        <span class="s0">return </span><span class="s1">buckets[</span><span class="s4">0</span><span class="s1">].value</span>

    <span class="s0">def </span><span class="s1">popitem(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">key</span><span class="s0">, </span><span class="s1">buckets = dict.popitem(self)</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(e.args[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">from None</span>

        <span class="s0">for </span><span class="s1">bucket </span><span class="s0">in </span><span class="s1">buckets:</span>
            <span class="s1">bucket.unlink(self)</span>

        <span class="s0">return </span><span class="s1">key</span><span class="s0">, </span><span class="s1">buckets[</span><span class="s4">0</span><span class="s1">].value</span>

    <span class="s0">def </span><span class="s1">popitemlist(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">key</span><span class="s0">, </span><span class="s1">buckets = dict.popitem(self)</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(e.args[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">from None</span>

        <span class="s0">for </span><span class="s1">bucket </span><span class="s0">in </span><span class="s1">buckets:</span>
            <span class="s1">bucket.unlink(self)</span>

        <span class="s0">return </span><span class="s1">key</span><span class="s0">, </span><span class="s1">[x.value </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">buckets]</span>


<span class="s0">def </span><span class="s1">_options_header_vkw(value</span><span class="s0">, </span><span class="s1">kw):</span>
    <span class="s0">return </span><span class="s1">http.dump_options_header(</span>
        <span class="s1">value</span><span class="s0">, </span><span class="s1">{k.replace(</span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s1">): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kw.items()}</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unicodify_header_value(value):</span>
    <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s1">value = value.decode(</span><span class="s2">&quot;latin-1&quot;</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">value = str(value)</span>
    <span class="s0">return </span><span class="s1">value</span>


<span class="s0">class </span><span class="s1">Headers:</span>
    <span class="s3">&quot;&quot;&quot;An object that stores some headers. It has a dict-like interface, 
    but is ordered, can store the same key multiple times, and iterating 
    yields ``(key, value)`` pairs instead of only keys. 
 
    This data structure is useful if you want a nicer way to handle WSGI 
    headers which are stored as tuples in a list. 
 
    From Werkzeug 0.3 onwards, the :exc:`KeyError` raised by this class is 
    also a subclass of the :class:`~exceptions.BadRequest` HTTP exception 
    and will render a page for a ``400 BAD REQUEST`` if caught in a 
    catch-all for HTTP exceptions. 
 
    Headers is mostly compatible with the Python :class:`wsgiref.headers.Headers` 
    class, with the exception of `__getitem__`.  :mod:`wsgiref` will return 
    `None` for ``headers['missing']``, whereas :class:`Headers` will raise 
    a :class:`KeyError`. 
 
    To create a new :class:`Headers` object pass it a list or dict of headers 
    which are used as default values.  This does not reuse the list passed 
    to the constructor for internal usage. 
 
    :param defaults: The list of default values for the :class:`Headers`. 
 
    .. versionchanged:: 0.9 
       This data structure now stores unicode values similar to how the 
       multi dicts do it.  The main difference is that bytes can be set as 
       well which will automatically be latin1 decoded. 
 
    .. versionchanged:: 0.9 
       The :meth:`linked` function was removed without replacement as it 
       was an API that does not support the changes to the encoding model. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">defaults=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._list = []</span>
        <span class="s0">if </span><span class="s1">defaults </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(defaults</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">Headers)):</span>
                <span class="s1">self._list.extend(defaults)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.extend(defaults)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">_get_mode=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">_get_mode:</span>
            <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s0">return </span><span class="s1">self._list[key]</span>
            <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s0">return </span><span class="s1">self.__class__(self._list[key])</span>
        <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key)</span>
        <span class="s1">ikey = key.lower()</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self._list:</span>
            <span class="s0">if </span><span class="s1">k.lower() == ikey:</span>
                <span class="s0">return </span><span class="s1">v</span>
        <span class="s5"># micro optimization: if we are in get mode we will catch that</span>
        <span class="s5"># exception one stack level down so we can raise a standard</span>
        <span class="s5"># key error instead of our special one.</span>
        <span class="s0">if </span><span class="s1">_get_mode:</span>
            <span class="s0">raise </span><span class="s1">KeyError()</span>
        <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key)</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">def </span><span class="s1">lowered(item):</span>
            <span class="s0">return </span><span class="s1">(item[</span><span class="s4">0</span><span class="s1">].lower()</span><span class="s0">,</span><span class="s1">) + item[</span><span class="s4">1</span><span class="s1">:]</span>

        <span class="s0">return </span><span class="s1">other.__class__ </span><span class="s0">is </span><span class="s1">self.__class__ </span><span class="s0">and </span><span class="s1">set(</span>
            <span class="s1">map(lowered</span><span class="s0">, </span><span class="s1">other._list)</span>
        <span class="s1">) == set(map(lowered</span><span class="s0">, </span><span class="s1">self._list))</span>

    <span class="s1">__hash__ = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">get(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None, </span><span class="s1">type=</span><span class="s0">None, </span><span class="s1">as_bytes=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the default value if the requested data doesn't exist. 
        If `type` is provided and is a callable it should convert the value, 
        return it or raise a :exc:`ValueError` if that is not possible.  In 
        this case the function will return the default as if the value was not 
        found: 
 
        &gt;&gt;&gt; d = Headers([('Content-Length', '42')]) 
        &gt;&gt;&gt; d.get('Content-Length', type=int) 
        42 
 
        .. versionadded:: 0.9 
           Added support for `as_bytes`. 
 
        :param key: The key to be looked up. 
        :param default: The default value to be returned if the key can't 
                        be looked up.  If not further specified `None` is 
                        returned. 
        :param type: A callable that is used to cast the value in the 
                     :class:`Headers`.  If a :exc:`ValueError` is raised 
                     by this callable the default value is returned. 
        :param as_bytes: return bytes instead of strings. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = self.__getitem__(key</span><span class="s0">, </span><span class="s1">_get_mode=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">default</span>
        <span class="s0">if </span><span class="s1">as_bytes:</span>
            <span class="s1">rv = rv.encode(</span><span class="s2">&quot;latin1&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">rv</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">type(rv)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">return </span><span class="s1">default</span>

    <span class="s0">def </span><span class="s1">getlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None, </span><span class="s1">as_bytes=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the list of items for a given key. If that key is not in the 
        :class:`Headers`, the return value will be an empty list.  Just like 
        :meth:`get`, :meth:`getlist` accepts a `type` parameter.  All items will 
        be converted with the callable defined there. 
 
        .. versionadded:: 0.9 
           Added support for `as_bytes`. 
 
        :param key: The key to be looked up. 
        :param type: A callable that is used to cast the value in the 
                     :class:`Headers`.  If a :exc:`ValueError` is raised 
                     by this callable the value will be removed from the list. 
        :return: a :class:`list` of all the values for the key. 
        :param as_bytes: return bytes instead of strings. 
        &quot;&quot;&quot;</span>
        <span class="s1">ikey = key.lower()</span>
        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">k.lower() == ikey:</span>
                <span class="s0">if </span><span class="s1">as_bytes:</span>
                    <span class="s1">v = v.encode(</span><span class="s2">&quot;latin1&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">type </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">v = type(v)</span>
                    <span class="s0">except </span><span class="s1">ValueError:</span>
                        <span class="s0">continue</span>
                <span class="s1">result.append(v)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">get_all(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3">&quot;&quot;&quot;Return a list of all the values for the named field. 
 
        This method is compatible with the :mod:`wsgiref` 
        :meth:`~wsgiref.headers.Headers.get_all` method. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.getlist(name)</span>

    <span class="s0">def </span><span class="s1">items(self</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">lower:</span>
                <span class="s1">key = key.lower()</span>
            <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">keys(self</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self.items(lower):</span>
            <span class="s0">yield </span><span class="s1">key</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.items():</span>
            <span class="s0">yield </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">extend(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Extend headers in this object with items from another object 
        containing header items as well as keyword arguments. 
 
        To replace existing keys instead of extending, use 
        :meth:`update` instead. 
 
        If provided, the first argument can be another :class:`Headers` 
        object, a :class:`MultiDict`, :class:`dict`, or iterable of 
        pairs. 
 
        .. versionchanged:: 1.0 
            Support :class:`MultiDict`. Allow passing ``kwargs``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(args) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;update expected at most 1 arguments, got </span><span class="s0">{</span><span class="s1">len(args)</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(args[</span><span class="s4">0</span><span class="s1">]):</span>
                <span class="s1">self.add(key</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(kwargs):</span>
            <span class="s1">self.add(key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">_index_operation=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">_index_operation </span><span class="s0">and </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">slice)):</span>
            <span class="s0">del </span><span class="s1">self._list[key]</span>
            <span class="s0">return</span>
        <span class="s1">key = key.lower()</span>
        <span class="s1">new = []</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self._list:</span>
            <span class="s0">if </span><span class="s1">k.lower() != key:</span>
                <span class="s1">new.append((k</span><span class="s0">, </span><span class="s1">v))</span>
        <span class="s1">self._list[:] = new</span>

    <span class="s0">def </span><span class="s1">remove(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Remove a key. 
 
        :param key: The key to be removed. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.__delitem__(key</span><span class="s0">, </span><span class="s1">_index_operation=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None, </span><span class="s1">default=_missing):</span>
        <span class="s3">&quot;&quot;&quot;Removes and returns a key or index. 
 
        :param key: The key to be popped.  If this is an integer the item at 
                    that position is removed, if it's a string the value for 
                    that key is.  If the key is omitted or `None` the last 
                    item is removed. 
        :return: an item. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._list.pop()</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">return </span><span class="s1">self._list.pop(key)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = self[key]</span>
            <span class="s1">self.remove(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">if </span><span class="s1">default </span><span class="s0">is not </span><span class="s1">_missing:</span>
                <span class="s0">return </span><span class="s1">default</span>
            <span class="s0">raise</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">popitem(self):</span>
        <span class="s3">&quot;&quot;&quot;Removes a key or index and returns a (key, value) item.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.pop()</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Check if a key is present.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.__getitem__(key</span><span class="s0">, </span><span class="s1">_get_mode=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">has_key(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot; 
        .. deprecated:: 2.0 
            Will be removed in Werkzeug 2.1. Use ``key in data`` 
            instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;'has_key' is deprecated and will be removed in Werkzeug&quot;</span>
            <span class="s2">&quot; 2.1. Use 'key in data' instead.&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">&quot;&quot;&quot;Yield ``(key, value)`` tuples.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">iter(self._list)</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._list)</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s3">&quot;&quot;&quot;Add a new header tuple to the list. 
 
        Keyword arguments can specify additional parameters for the header 
        value, with underscores converted to dashes:: 
 
        &gt;&gt;&gt; d = Headers() 
        &gt;&gt;&gt; d.add('Content-Type', 'text/plain') 
        &gt;&gt;&gt; d.add('Content-Disposition', 'attachment', filename='foo.png') 
 
        The keyword argument dumping uses :func:`dump_options_header` 
        behind the scenes. 
 
        .. versionadded:: 0.4.1 
            keyword arguments were added for :mod:`wsgiref` compatibility. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">kw:</span>
            <span class="s1">_value = _options_header_vkw(_value</span><span class="s0">, </span><span class="s1">kw)</span>
        <span class="s1">_key = _unicodify_header_value(_key)</span>
        <span class="s1">_value = _unicodify_header_value(_value)</span>
        <span class="s1">self._validate_value(_value)</span>
        <span class="s1">self._list.append((_key</span><span class="s0">, </span><span class="s1">_value))</span>

    <span class="s0">def </span><span class="s1">_validate_value(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if not </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Value should be a string.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s0">in </span><span class="s1">value </span><span class="s0">or </span><span class="s2">&quot;</span><span class="s0">\r</span><span class="s2">&quot; </span><span class="s0">in </span><span class="s1">value:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Detected newline in header value.  This is &quot;</span>
                <span class="s2">&quot;a potential security problem&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_header(self</span><span class="s0">, </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**_kw):</span>
        <span class="s3">&quot;&quot;&quot;Add a new header tuple to the list. 
 
        An alias for :meth:`add` for compatibility with the :mod:`wsgiref` 
        :meth:`~wsgiref.headers.Headers.add_header` method. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.add(_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**_kw)</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s3">&quot;&quot;&quot;Clears all headers.&quot;&quot;&quot;</span>
        <span class="s0">del </span><span class="s1">self._list[:]</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s3">&quot;&quot;&quot;Remove all header tuples for `key` and add a new one.  The newly 
        added key either appears at the end of the list if there was no 
        entry or replaces the first one. 
 
        Keyword arguments can specify additional parameters for the header 
        value, with underscores converted to dashes.  See :meth:`add` for 
        more information. 
 
        .. versionchanged:: 0.6.1 
           :meth:`set` now accepts the same arguments as :meth:`add`. 
 
        :param key: The key to be inserted. 
        :param value: The value to be inserted. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">kw:</span>
            <span class="s1">_value = _options_header_vkw(_value</span><span class="s0">, </span><span class="s1">kw)</span>
        <span class="s1">_key = _unicodify_header_value(_key)</span>
        <span class="s1">_value = _unicodify_header_value(_value)</span>
        <span class="s1">self._validate_value(_value)</span>
        <span class="s0">if not </span><span class="s1">self._list:</span>
            <span class="s1">self._list.append((_key</span><span class="s0">, </span><span class="s1">_value))</span>
            <span class="s0">return</span>
        <span class="s1">listiter = iter(self._list)</span>
        <span class="s1">ikey = _key.lower()</span>
        <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">(old_key</span><span class="s0">, </span><span class="s1">_old_value) </span><span class="s0">in </span><span class="s1">enumerate(listiter):</span>
            <span class="s0">if </span><span class="s1">old_key.lower() == ikey:</span>
                <span class="s5"># replace first occurrence</span>
                <span class="s1">self._list[idx] = (_key</span><span class="s0">, </span><span class="s1">_value)</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._list.append((_key</span><span class="s0">, </span><span class="s1">_value))</span>
            <span class="s0">return</span>
        <span class="s1">self._list[idx + </span><span class="s4">1 </span><span class="s1">:] = [t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">listiter </span><span class="s0">if </span><span class="s1">t[</span><span class="s4">0</span><span class="s1">].lower() != ikey]</span>

    <span class="s0">def </span><span class="s1">setlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s3">&quot;&quot;&quot;Remove any existing values for a header and add new ones. 
 
        :param key: The header key to set. 
        :param values: An iterable of values to set for the key. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">values:</span>
            <span class="s1">values_iter = iter(values)</span>
            <span class="s1">self.set(key</span><span class="s0">, </span><span class="s1">next(values_iter))</span>

            <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values_iter:</span>
                <span class="s1">self.add(key</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.remove(key)</span>

    <span class="s0">def </span><span class="s1">setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default):</span>
        <span class="s3">&quot;&quot;&quot;Return the first value for the key if it is in the headers, 
        otherwise set the header to the value given by ``default`` and 
        return that. 
 
        :param key: The header key to get. 
        :param default: The value to set for the key if it is not in the 
            headers. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">return </span><span class="s1">self[key]</span>

        <span class="s1">self.set(key</span><span class="s0">, </span><span class="s1">default)</span>
        <span class="s0">return </span><span class="s1">default</span>

    <span class="s0">def </span><span class="s1">setlistdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default):</span>
        <span class="s3">&quot;&quot;&quot;Return the list of values for the key if it is in the 
        headers, otherwise set the header to the list of values given 
        by ``default`` and return that. 
 
        Unlike :meth:`MultiDict.setlistdefault`, modifying the returned 
        list will not affect the headers. 
 
        :param key: The header key to get. 
        :param default: An iterable of values to set for the key if it 
            is not in the headers. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self:</span>
            <span class="s1">self.setlist(key</span><span class="s0">, </span><span class="s1">default)</span>

        <span class="s0">return </span><span class="s1">self.getlist(key)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`set` but also supports index/slice based setting.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">(slice</span><span class="s0">, </span><span class="s1">int)):</span>
            <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">value = [value]</span>
            <span class="s1">value = [</span>
                <span class="s1">(_unicodify_header_value(k)</span><span class="s0">, </span><span class="s1">_unicodify_header_value(v))</span>
                <span class="s0">for </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">in </span><span class="s1">value</span>
            <span class="s1">]</span>
            <span class="s0">for </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">in </span><span class="s1">value:</span>
                <span class="s1">self._validate_value(v)</span>
            <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">self._list[key] = value[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._list[key] = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.set(key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Replace headers in this object with items from another 
        headers object and keyword arguments. 
 
        To extend existing keys instead of replacing, use :meth:`extend` 
        instead. 
 
        If provided, the first argument can be another :class:`Headers` 
        object, a :class:`MultiDict`, :class:`dict`, or iterable of 
        pairs. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(args) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;update expected at most 1 arguments, got </span><span class="s0">{</span><span class="s1">len(args)</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s1">mapping = args[</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">(Headers</span><span class="s0">, </span><span class="s1">MultiDict)):</span>
                <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">mapping.keys():</span>
                    <span class="s1">self.setlist(key</span><span class="s0">, </span><span class="s1">mapping.getlist(key))</span>
            <span class="s0">elif </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">mapping.items():</span>
                    <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
                        <span class="s1">self.setlist(key</span><span class="s0">, </span><span class="s1">value)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self.set(key</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">mapping:</span>
                    <span class="s1">self.set(key</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">kwargs.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
                <span class="s1">self.setlist(key</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.set(key</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">to_wsgi_list(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the headers into a list suitable for WSGI. 
 
        :return: list 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">list(self)</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s0">return </span><span class="s1">self.__class__(self._list)</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">return </span><span class="s1">self.copy()</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s3">&quot;&quot;&quot;Returns formatted headers suitable for HTTP transmission.&quot;&quot;&quot;</span>
        <span class="s1">strs = []</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.to_wsgi_list():</span>
            <span class="s1">strs.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">: </span><span class="s0">{</span><span class="s1">value</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s1">strs.append(</span><span class="s2">&quot;</span><span class="s0">\r\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s2">&quot;</span><span class="s0">\r\n</span><span class="s2">&quot;</span><span class="s1">.join(strs)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">list(self)</span><span class="s0">!r}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">ImmutableHeadersMixin:</span>
    <span class="s3">&quot;&quot;&quot;Makes a :class:`Headers` immutable.  We do not mark them as 
    hashable though since the only usecase for this datastructure 
    in Werkzeug is a view on a mutable structure. 
 
    .. versionadded:: 0.5 
 
    :private: 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">setlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">add_header(self</span><span class="s0">, </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">_value</span><span class="s0">, </span><span class="s1">**_kw):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">remove(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">extend(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None, </span><span class="s1">default=_missing):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">popitem(self):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">setdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default):</span>
        <span class="s1">is_immutable(self)</span>

    <span class="s0">def </span><span class="s1">setlistdefault(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default):</span>
        <span class="s1">is_immutable(self)</span>


<span class="s0">class </span><span class="s1">EnvironHeaders(ImmutableHeadersMixin</span><span class="s0">, </span><span class="s1">Headers):</span>
    <span class="s3">&quot;&quot;&quot;Read only version of the headers from a WSGI environment.  This 
    provides the same interface as `Headers` and is constructed from 
    a WSGI environment. 
 
    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a 
    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will 
    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for 
    HTTP exceptions. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">environ):</span>
        <span class="s1">self.environ = environ</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">self.environ </span><span class="s0">is </span><span class="s1">other.environ</span>

    <span class="s1">__hash__ = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">_get_mode=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5"># _get_mode is a no-op for this class as there is no index but</span>
        <span class="s5"># used because get() calls it.</span>
        <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>
        <span class="s1">key = key.upper().replace(</span><span class="s2">&quot;-&quot;</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;CONTENT_TYPE&quot;</span><span class="s0">, </span><span class="s2">&quot;CONTENT_LENGTH&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">_unicodify_header_value(self.environ[key])</span>
        <span class="s0">return </span><span class="s1">_unicodify_header_value(self.environ[</span><span class="s2">f&quot;HTTP_</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s5"># the iter is necessary because otherwise list calls our</span>
        <span class="s5"># len which would call list again and so forth.</span>
        <span class="s0">return </span><span class="s1">len(list(iter(self)))</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.environ.items():</span>
            <span class="s0">if </span><span class="s1">key.startswith(</span><span class="s2">&quot;HTTP_&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">(</span>
                <span class="s2">&quot;HTTP_CONTENT_TYPE&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;HTTP_CONTENT_LENGTH&quot;</span><span class="s0">,</span>
            <span class="s1">):</span>
                <span class="s0">yield </span><span class="s1">(</span>
                    <span class="s1">key[</span><span class="s4">5</span><span class="s1">:].replace(</span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s1">).title()</span><span class="s0">,</span>
                    <span class="s1">_unicodify_header_value(value)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;CONTENT_TYPE&quot;</span><span class="s0">, </span><span class="s2">&quot;CONTENT_LENGTH&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">value:</span>
                <span class="s0">yield </span><span class="s1">(key.replace(</span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s1">).title()</span><span class="s0">, </span><span class="s1">_unicodify_header_value(value))</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;cannot create </span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">!r} </span><span class="s2">copies&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">CombinedMultiDict(ImmutableMultiDictMixin</span><span class="s0">, </span><span class="s1">MultiDict):</span>
    <span class="s3">&quot;&quot;&quot;A read only :class:`MultiDict` that you can pass multiple :class:`MultiDict` 
    instances as sequence and it will combine the return values of all wrapped 
    dicts: 
 
    &gt;&gt;&gt; from werkzeug.datastructures import CombinedMultiDict, MultiDict 
    &gt;&gt;&gt; post = MultiDict([('foo', 'bar')]) 
    &gt;&gt;&gt; get = MultiDict([('blub', 'blah')]) 
    &gt;&gt;&gt; combined = CombinedMultiDict([get, post]) 
    &gt;&gt;&gt; combined['foo'] 
    'bar' 
    &gt;&gt;&gt; combined['blub'] 
    'blah' 
 
    This works for all read operations and will raise a `TypeError` for 
    methods that usually change data which isn't possible. 
 
    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a 
    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will 
    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP 
    exceptions. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__reduce_ex__(self</span><span class="s0">, </span><span class="s1">protocol):</span>
        <span class="s0">return </span><span class="s1">type(self)</span><span class="s0">, </span><span class="s1">(self.dicts</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">dicts=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.dicts = list(dicts) </span><span class="s0">or </span><span class="s1">[]</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">fromkeys(cls</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">value=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;cannot create </span><span class="s0">{</span><span class="s1">cls.__name__</span><span class="s0">!r} </span><span class="s2">instances by fromkeys&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.dicts:</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                <span class="s0">return </span><span class="s1">d[key]</span>
        <span class="s0">raise </span><span class="s1">exceptions.BadRequestKeyError(key)</span>

    <span class="s0">def </span><span class="s1">get(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.dicts:</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                <span class="s0">if </span><span class="s1">type </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">type(d[key])</span>
                    <span class="s0">except </span><span class="s1">ValueError:</span>
                        <span class="s0">continue</span>
                <span class="s0">return </span><span class="s1">d[key]</span>
        <span class="s0">return </span><span class="s1">default</span>

    <span class="s0">def </span><span class="s1">getlist(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">rv = []</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.dicts:</span>
            <span class="s1">rv.extend(d.getlist(key</span><span class="s0">, </span><span class="s1">type))</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">_keys_impl(self):</span>
        <span class="s3">&quot;&quot;&quot;This function exists so __len__ can be implemented more efficiently, 
        saving one list creation from an iterator. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = set()</span>
        <span class="s1">rv.update(*self.dicts)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">keys(self):</span>
        <span class="s0">return </span><span class="s1">self._keys_impl()</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self.keys())</span>

    <span class="s0">def </span><span class="s1">items(self</span><span class="s0">, </span><span class="s1">multi=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">found = set()</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.dicts:</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">d.items(multi):</span>
                <span class="s0">if </span><span class="s1">multi:</span>
                    <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span>
                <span class="s0">elif </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">found:</span>
                    <span class="s1">found.add(key)</span>
                    <span class="s0">yield </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s0">for </span><span class="s1">_key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.items():</span>
            <span class="s0">yield </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">lists(self):</span>
        <span class="s1">rv = {}</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.dicts:</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">d.lists():</span>
                <span class="s1">rv.setdefault(key</span><span class="s0">, </span><span class="s1">[]).extend(values)</span>
        <span class="s0">return </span><span class="s1">list(rv.items())</span>

    <span class="s0">def </span><span class="s1">listvalues(self):</span>
        <span class="s0">return </span><span class="s1">(x[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.lists())</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a shallow mutable copy of this object. 
 
        This returns a :class:`MultiDict` representing the data at the 
        time of copying. The copy will no longer reflect changes to the 
        wrapped dicts. 
 
        .. versionchanged:: 0.15 
            Return a mutable :class:`MultiDict`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">MultiDict(self)</span>

    <span class="s0">def </span><span class="s1">to_dict(self</span><span class="s0">, </span><span class="s1">flat=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the contents as regular dict.  If `flat` is `True` the 
        returned dict will only have the first item present, if `flat` is 
        `False` all values will be returned as lists. 
 
        :param flat: If set to `False` the dict returned will have lists 
                     with all the values in it.  Otherwise it will only 
                     contain the first item for each key. 
        :return: a :class:`dict` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">flat:</span>
            <span class="s0">return </span><span class="s1">dict(self.items())</span>

        <span class="s0">return </span><span class="s1">dict(self.lists())</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._keys_impl())</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.dicts:</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">has_key(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot; 
        .. deprecated:: 2.0 
            Will be removed in Werkzeug 2.1. Use ``key in data`` 
            instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;'has_key' is deprecated and will be removed in Werkzeug&quot;</span>
            <span class="s2">&quot; 2.1. Use 'key in data' instead.&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">self.dicts</span><span class="s0">!r}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">FileMultiDict(MultiDict):</span>
    <span class="s3">&quot;&quot;&quot;A special :class:`MultiDict` that has convenience methods to add 
    files to it.  This is used for :class:`EnvironBuilder` and generally 
    useful for unittesting. 
 
    .. versionadded:: 0.5 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">add_file(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">file</span><span class="s0">, </span><span class="s1">filename=</span><span class="s0">None, </span><span class="s1">content_type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Adds a new file to the dict.  `file` can be a file name or 
        a :class:`file`-like or a :class:`FileStorage` object. 
 
        :param name: the name of the field. 
        :param file: a filename or :class:`file`-like object 
        :param filename: an optional filename 
        :param content_type: an optional content type 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(file</span><span class="s0">, </span><span class="s1">FileStorage):</span>
            <span class="s1">value = file</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(file</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">if </span><span class="s1">filename </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">filename = file</span>
                <span class="s1">file = open(file</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">filename </span><span class="s0">and </span><span class="s1">content_type </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">content_type = (</span>
                    <span class="s1">mimetypes.guess_type(filename)[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;application/octet-stream&quot;</span>
                <span class="s1">)</span>
            <span class="s1">value = FileStorage(file</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">content_type)</span>

        <span class="s1">self.add(name</span><span class="s0">, </span><span class="s1">value)</span>


<span class="s0">class </span><span class="s1">ImmutableDict(ImmutableDictMixin</span><span class="s0">, </span><span class="s1">dict):</span>
    <span class="s3">&quot;&quot;&quot;An immutable :class:`dict`. 
 
    .. versionadded:: 0.5 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">dict.__repr__(self)</span><span class="s0">}</span><span class="s2">)&quot;</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a shallow mutable copy of this object.  Keep in mind that 
        the standard library's :func:`copy` function is a no-op for this class 
        like for any other python immutable type (eg: :class:`tuple`). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">dict(self)</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">ImmutableMultiDict(ImmutableMultiDictMixin</span><span class="s0">, </span><span class="s1">MultiDict):</span>
    <span class="s3">&quot;&quot;&quot;An immutable :class:`MultiDict`. 
 
    .. versionadded:: 0.5 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a shallow mutable copy of this object.  Keep in mind that 
        the standard library's :func:`copy` function is a no-op for this class 
        like for any other python immutable type (eg: :class:`tuple`). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">MultiDict(self)</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">ImmutableOrderedMultiDict(ImmutableMultiDictMixin</span><span class="s0">, </span><span class="s1">OrderedMultiDict):</span>
    <span class="s3">&quot;&quot;&quot;An immutable :class:`OrderedMultiDict`. 
 
    .. versionadded:: 0.6 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_iter_hashitems(self):</span>
        <span class="s0">return </span><span class="s1">enumerate(self.items(multi=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a shallow mutable copy of this object.  Keep in mind that 
        the standard library's :func:`copy` function is a no-op for this class 
        like for any other python immutable type (eg: :class:`tuple`). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">OrderedMultiDict(self)</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">Accept(ImmutableList):</span>
    <span class="s3">&quot;&quot;&quot;An :class:`Accept` object is just a list subclass for lists of 
    ``(value, quality)`` tuples.  It is automatically sorted by specificity 
    and quality. 
 
    All :class:`Accept` objects work similar to a list but provide extra 
    functionality for working with the data.  Containment checks are 
    normalized to the rules of that header: 
 
    &gt;&gt;&gt; a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)]) 
    &gt;&gt;&gt; a.best 
    'ISO-8859-1' 
    &gt;&gt;&gt; 'iso-8859-1' in a 
    True 
    &gt;&gt;&gt; 'UTF8' in a 
    True 
    &gt;&gt;&gt; 'utf7' in a 
    False 
 
    To get the quality for an item you can use normal item lookup: 
 
    &gt;&gt;&gt; print a['utf-8'] 
    0.7 
    &gt;&gt;&gt; a['utf7'] 
    0 
 
    .. versionchanged:: 0.5 
       :class:`Accept` objects are forced immutable now. 
 
    .. versionchanged:: 1.0.0 
       :class:`Accept` internal values are no longer ordered 
       alphabetically for equal quality tags. Instead the initial 
       order is preserved. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values=()):</span>
        <span class="s0">if </span><span class="s1">values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">list.__init__(self)</span>
            <span class="s1">self.provided = </span><span class="s0">False</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Accept):</span>
            <span class="s1">self.provided = values.provided</span>
            <span class="s1">list.__init__(self</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.provided = </span><span class="s0">True</span>
            <span class="s1">values = sorted(</span>
                <span class="s1">values</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: (self._specificity(x[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span>
            <span class="s1">)</span>
            <span class="s1">list.__init__(self</span><span class="s0">, </span><span class="s1">values)</span>

    <span class="s0">def </span><span class="s1">_specificity(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot;Returns a tuple describing the value's specificity.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(value != </span><span class="s2">&quot;*&quot;</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s3">&quot;&quot;&quot;Check if a value matches a given accept item.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">item == </span><span class="s2">&quot;*&quot; </span><span class="s0">or </span><span class="s1">item.lower() == value.lower()</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Besides index lookup (getting item n) you can also pass it a string 
        to get the quality for the item.  If the item is not in the list, the 
        returned quality is ``0``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">self.quality(key)</span>
        <span class="s0">return </span><span class="s1">list.__getitem__(self</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">quality(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Returns the quality of the key. 
 
        .. versionadded:: 0.6 
           In previous versions you had to use the item-lookup syntax 
           (eg: ``obj[key]`` instead of ``obj.quality(key)``) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">item</span><span class="s0">, </span><span class="s1">quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">self._value_matches(key</span><span class="s0">, </span><span class="s1">item):</span>
                <span class="s0">return </span><span class="s1">quality</span>
        <span class="s0">return </span><span class="s4">0</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">for </span><span class="s1">item</span><span class="s0">, </span><span class="s1">_quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">self._value_matches(value</span><span class="s0">, </span><span class="s1">item):</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">pairs_str = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(</span><span class="s2">f&quot;(</span><span class="s0">{</span><span class="s1">x</span><span class="s0">!r}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">y</span><span class="s0">}</span><span class="s2">)&quot; </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">self)</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">([</span><span class="s0">{</span><span class="s1">pairs_str</span><span class="s0">}</span><span class="s2">])&quot;</span>

    <span class="s0">def </span><span class="s1">index(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Get the position of an entry or raise :exc:`ValueError`. 
 
        :param key: The key to be looked up. 
 
        .. versionchanged:: 0.5 
           This used to raise :exc:`IndexError`, which was inconsistent 
           with the list API. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">, </span><span class="s1">_quality) </span><span class="s0">in </span><span class="s1">enumerate(self):</span>
                <span class="s0">if </span><span class="s1">self._value_matches(key</span><span class="s0">, </span><span class="s1">item):</span>
                    <span class="s0">return </span><span class="s1">idx</span>
            <span class="s0">raise </span><span class="s1">ValueError(key)</span>
        <span class="s0">return </span><span class="s1">list.index(self</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">find(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Get the position of an entry or return -1. 
 
        :param key: The key to be looked up. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.index(key)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s3">&quot;&quot;&quot;Iterate over all values.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">yield </span><span class="s1">item[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the header set into an HTTP header string.&quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">value</span><span class="s0">, </span><span class="s1">quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">quality != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">value = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">}</span><span class="s2">;q=</span><span class="s0">{</span><span class="s1">quality</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">result.append(value)</span>
        <span class="s0">return </span><span class="s2">&quot;,&quot;</span><span class="s1">.join(result)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">_best_single_match(self</span><span class="s0">, </span><span class="s1">match):</span>
        <span class="s0">for </span><span class="s1">client_item</span><span class="s0">, </span><span class="s1">quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">self._value_matches(match</span><span class="s0">, </span><span class="s1">client_item):</span>
                <span class="s5"># self is sorted by specificity descending, we can exit</span>
                <span class="s0">return </span><span class="s1">client_item</span><span class="s0">, </span><span class="s1">quality</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">best_match(self</span><span class="s0">, </span><span class="s1">matches</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Returns the best match from a list of possible matches based 
        on the specificity and quality of the client. If two items have the 
        same quality and specificity, the one is returned that comes first. 
 
        :param matches: a list of matches to check for 
        :param default: the value that is returned if none match 
        &quot;&quot;&quot;</span>
        <span class="s1">result = default</span>
        <span class="s1">best_quality = -</span><span class="s4">1</span>
        <span class="s1">best_specificity = (-</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">server_item </span><span class="s0">in </span><span class="s1">matches:</span>
            <span class="s1">match = self._best_single_match(server_item)</span>
            <span class="s0">if not </span><span class="s1">match:</span>
                <span class="s0">continue</span>
            <span class="s1">client_item</span><span class="s0">, </span><span class="s1">quality = match</span>
            <span class="s1">specificity = self._specificity(client_item)</span>
            <span class="s0">if </span><span class="s1">quality &lt;= </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">quality &lt; best_quality:</span>
                <span class="s0">continue</span>
            <span class="s5"># better quality or same quality but more specific =&gt; better match</span>
            <span class="s0">if </span><span class="s1">quality &gt; best_quality </span><span class="s0">or </span><span class="s1">specificity &gt; best_specificity:</span>
                <span class="s1">result = server_item</span>
                <span class="s1">best_quality = quality</span>
                <span class="s1">best_specificity = specificity</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">best(self):</span>
        <span class="s3">&quot;&quot;&quot;The best match as value.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self:</span>
            <span class="s0">return </span><span class="s1">self[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>


<span class="s1">_mime_split_re = re.compile(</span><span class="s2">r&quot;/|(?:\s*;\s*)&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_normalize_mime(value):</span>
    <span class="s0">return </span><span class="s1">_mime_split_re.split(value.lower())</span>


<span class="s0">class </span><span class="s1">MIMEAccept(Accept):</span>
    <span class="s3">&quot;&quot;&quot;Like :class:`Accept` but with special methods and behavior for 
    mimetypes. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_specificity(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">return </span><span class="s1">tuple(x != </span><span class="s2">&quot;*&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">_mime_split_re.split(value))</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s5"># item comes from the client, can't match if it's invalid.</span>
        <span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">item:</span>
            <span class="s0">return False</span>

        <span class="s5"># value comes from the application, tell the developer when it</span>
        <span class="s5"># doesn't look valid.</span>
        <span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">value:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;invalid mimetype </span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s5"># Split the match value into type, subtype, and a sorted list of parameters.</span>
        <span class="s1">normalized_value = _normalize_mime(value)</span>
        <span class="s1">value_type</span><span class="s0">, </span><span class="s1">value_subtype = normalized_value[:</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">value_params = sorted(normalized_value[</span><span class="s4">2</span><span class="s1">:])</span>

        <span class="s5"># &quot;*/*&quot; is the only valid value that can start with &quot;*&quot;.</span>
        <span class="s0">if </span><span class="s1">value_type == </span><span class="s2">&quot;*&quot; </span><span class="s0">and </span><span class="s1">value_subtype != </span><span class="s2">&quot;*&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;invalid mimetype </span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s5"># Split the accept item into type, subtype, and parameters.</span>
        <span class="s1">normalized_item = _normalize_mime(item)</span>
        <span class="s1">item_type</span><span class="s0">, </span><span class="s1">item_subtype = normalized_item[:</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">item_params = sorted(normalized_item[</span><span class="s4">2</span><span class="s1">:])</span>

        <span class="s5"># &quot;*/not-*&quot; from the client is invalid, can't match.</span>
        <span class="s0">if </span><span class="s1">item_type == </span><span class="s2">&quot;*&quot; </span><span class="s0">and </span><span class="s1">item_subtype != </span><span class="s2">&quot;*&quot;</span><span class="s1">:</span>
            <span class="s0">return False</span>

        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">(item_type == </span><span class="s2">&quot;*&quot; </span><span class="s0">and </span><span class="s1">item_subtype == </span><span class="s2">&quot;*&quot;</span><span class="s1">)</span>
            <span class="s0">or </span><span class="s1">(value_type == </span><span class="s2">&quot;*&quot; </span><span class="s0">and </span><span class="s1">value_subtype == </span><span class="s2">&quot;*&quot;</span><span class="s1">)</span>
        <span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">item_type == value_type</span>
            <span class="s0">and </span><span class="s1">(</span>
                <span class="s1">item_subtype == </span><span class="s2">&quot;*&quot;</span>
                <span class="s0">or </span><span class="s1">value_subtype == </span><span class="s2">&quot;*&quot;</span>
                <span class="s0">or </span><span class="s1">(item_subtype == value_subtype </span><span class="s0">and </span><span class="s1">item_params == value_params)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">accept_html(self):</span>
        <span class="s3">&quot;&quot;&quot;True if this object accepts HTML.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s2">&quot;text/html&quot; </span><span class="s0">in </span><span class="s1">self </span><span class="s0">or </span><span class="s2">&quot;application/xhtml+xml&quot; </span><span class="s0">in </span><span class="s1">self </span><span class="s0">or </span><span class="s1">self.accept_xhtml</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">accept_xhtml(self):</span>
        <span class="s3">&quot;&quot;&quot;True if this object accepts XHTML.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;application/xhtml+xml&quot; </span><span class="s0">in </span><span class="s1">self </span><span class="s0">or </span><span class="s2">&quot;application/xml&quot; </span><span class="s0">in </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">accept_json(self):</span>
        <span class="s3">&quot;&quot;&quot;True if this object accepts JSON.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;application/json&quot; </span><span class="s0">in </span><span class="s1">self</span>


<span class="s1">_locale_delim_re = re.compile(</span><span class="s2">r&quot;[_-]&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_normalize_lang(value):</span>
    <span class="s3">&quot;&quot;&quot;Process a language tag for matching.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_locale_delim_re.split(value.lower())</span>


<span class="s0">class </span><span class="s1">LanguageAccept(Accept):</span>
    <span class="s3">&quot;&quot;&quot;Like :class:`Accept` but with normalization for language tags.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">return </span><span class="s1">item == </span><span class="s2">&quot;*&quot; </span><span class="s0">or </span><span class="s1">_normalize_lang(value) == _normalize_lang(item)</span>

    <span class="s0">def </span><span class="s1">best_match(self</span><span class="s0">, </span><span class="s1">matches</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Given a list of supported values, finds the best match from 
        the list of accepted values. 
 
        Language tags are normalized for the purpose of matching, but 
        are returned unchanged. 
 
        If no exact match is found, this will fall back to matching 
        the first subtag (primary language only), first with the 
        accepted values then with the match values. This partial is not 
        applied to any other language subtags. 
 
        The default is returned if no exact or fallback match is found. 
 
        :param matches: A list of supported languages to find a match. 
        :param default: The value that is returned if none match. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Look for an exact match first. If a client accepts &quot;en-US&quot;,</span>
        <span class="s5"># &quot;en-US&quot; is a valid match at this point.</span>
        <span class="s1">result = super().best_match(matches)</span>

        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s5"># Fall back to accepting primary tags. If a client accepts</span>
        <span class="s5"># &quot;en-US&quot;, &quot;en&quot; is a valid match at this point. Need to use</span>
        <span class="s5"># re.split to account for 2 or 3 letter codes.</span>
        <span class="s1">fallback = Accept(</span>
            <span class="s1">[(_locale_delim_re.split(item[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">item[</span><span class="s4">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self]</span>
        <span class="s1">)</span>
        <span class="s1">result = fallback.best_match(matches)</span>

        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s5"># Fall back to matching primary tags. If the client accepts</span>
        <span class="s5"># &quot;en&quot;, &quot;en-US&quot; is a valid match at this point.</span>
        <span class="s1">fallback_matches = [_locale_delim_re.split(item</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">matches]</span>
        <span class="s1">result = super().best_match(fallback_matches)</span>

        <span class="s5"># Return a value from the original match list. Find the first</span>
        <span class="s5"># original value that starts with the matched primary tag.</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">next(item </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">matches </span><span class="s0">if </span><span class="s1">item.startswith(result))</span>

        <span class="s0">return </span><span class="s1">default</span>


<span class="s0">class </span><span class="s1">CharsetAccept(Accept):</span>
    <span class="s3">&quot;&quot;&quot;Like :class:`Accept` but with normalization for charsets.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">def </span><span class="s1">_normalize(name):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">codecs.lookup(name).name</span>
            <span class="s0">except </span><span class="s1">LookupError:</span>
                <span class="s0">return </span><span class="s1">name.lower()</span>

        <span class="s0">return </span><span class="s1">item == </span><span class="s2">&quot;*&quot; </span><span class="s0">or </span><span class="s1">_normalize(value) == _normalize(item)</span>


<span class="s0">def </span><span class="s1">cache_control_property(key</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">type):</span>
    <span class="s3">&quot;&quot;&quot;Return a new property object for a cache header. Useful if you 
    want to add support for a cache extension in a subclass. 
 
    .. versionchanged:: 2.0 
        Renamed from ``cache_property``. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">property(</span>
        <span class="s0">lambda </span><span class="s1">x: x._get_cache_value(key</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">type)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">v: x._set_cache_value(key</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">type)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">x: x._del_cache_value(key)</span><span class="s0">,</span>
        <span class="s2">f&quot;accessor for </span><span class="s0">{</span><span class="s1">key</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">cache_property(key</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">type):</span>
    <span class="s1">warnings.warn(</span>
        <span class="s2">&quot;'cache_property' is renamed to 'cache_control_property'. The&quot;</span>
        <span class="s2">&quot; old name is deprecated and will be removed in Werkzeug 2.1.&quot;</span><span class="s0">,</span>
        <span class="s1">DeprecationWarning</span><span class="s0">,</span>
        <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">cache_control_property(key</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">type)</span>


<span class="s0">class </span><span class="s1">_CacheControl(UpdateDictMixin</span><span class="s0">, </span><span class="s1">dict):</span>
    <span class="s3">&quot;&quot;&quot;Subclass of a dict that stores values for a Cache-Control header.  It 
    has accessors for all the cache-control directives specified in RFC 2616. 
    The class does not differentiate between request and response directives. 
 
    Because the cache-control directives in the HTTP header use dashes the 
    python descriptors use underscores for that. 
 
    To get a header of the :class:`CacheControl` object again you can convert 
    the object into a string or call the :meth:`to_header` method.  If you plan 
    to subclass it and add your own items have a look at the sourcecode for 
    that class. 
 
    .. versionchanged:: 0.4 
 
       Setting `no_cache` or `private` to boolean `True` will set the implicit 
       none-value which is ``*``: 
 
       &gt;&gt;&gt; cc = ResponseCacheControl() 
       &gt;&gt;&gt; cc.no_cache = True 
       &gt;&gt;&gt; cc 
       &lt;ResponseCacheControl 'no-cache'&gt; 
       &gt;&gt;&gt; cc.no_cache 
       '*' 
       &gt;&gt;&gt; cc.no_cache = None 
       &gt;&gt;&gt; cc 
       &lt;ResponseCacheControl ''&gt; 
 
       In versions before 0.5 the behavior documented here affected the now 
       no longer existing `CacheControl` class. 
    &quot;&quot;&quot;</span>

    <span class="s1">no_cache = cache_control_property(</span><span class="s2">&quot;no-cache&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">no_store = cache_control_property(</span><span class="s2">&quot;no-store&quot;</span><span class="s0">, None, </span><span class="s1">bool)</span>
    <span class="s1">max_age = cache_control_property(</span><span class="s2">&quot;max-age&quot;</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s1">no_transform = cache_control_property(</span><span class="s2">&quot;no-transform&quot;</span><span class="s0">, None, None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values=()</span><span class="s0">, </span><span class="s1">on_update=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">values </span><span class="s0">or </span><span class="s1">())</span>
        <span class="s1">self.on_update = on_update</span>
        <span class="s1">self.provided = values </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">_get_cache_value(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">type):</span>
        <span class="s3">&quot;&quot;&quot;Used internally by the accessor properties.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">type </span><span class="s0">is </span><span class="s1">bool:</span>
            <span class="s0">return </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s1">value = self[key]</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">empty</span>
            <span class="s0">elif </span><span class="s1">type </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">value = type(value)</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s0">pass</span>
            <span class="s0">return </span><span class="s1">value</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">_set_cache_value(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">type):</span>
        <span class="s3">&quot;&quot;&quot;Used internally by the accessor properties.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">type </span><span class="s0">is </span><span class="s1">bool:</span>
            <span class="s0">if </span><span class="s1">value:</span>
                <span class="s1">self[key] = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.pop(key</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self.pop(key</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">value </span><span class="s0">is True</span><span class="s1">:</span>
                <span class="s1">self[key] = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self[key] = value</span>

    <span class="s0">def </span><span class="s1">_del_cache_value(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Used internally by the accessor properties.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">del </span><span class="s1">self[key]</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the stored values into a cache control header.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">http.dump_header(self)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">kv_str = </span><span class="s2">&quot; &quot;</span><span class="s1">.join(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">=</span><span class="s0">{</span><span class="s1">v</span><span class="s0">!r}</span><span class="s2">&quot; </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sorted(self.items()))</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">kv_str</span><span class="s0">}</span><span class="s2">&gt;&quot;</span>

    <span class="s1">cache_property = staticmethod(cache_control_property)</span>


<span class="s0">class </span><span class="s1">RequestCacheControl(ImmutableDictMixin</span><span class="s0">, </span><span class="s1">_CacheControl):</span>
    <span class="s3">&quot;&quot;&quot;A cache control for requests.  This is immutable and gives access 
    to all the request-relevant cache control headers. 
 
    To get a header of the :class:`RequestCacheControl` object again you can 
    convert the object into a string or call the :meth:`to_header` method.  If 
    you plan to subclass it and add your own items have a look at the sourcecode 
    for that class. 
 
    .. versionadded:: 0.5 
       In previous versions a `CacheControl` class existed that was used 
       both for request and response. 
    &quot;&quot;&quot;</span>

    <span class="s1">max_stale = cache_control_property(</span><span class="s2">&quot;max-stale&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s1">min_fresh = cache_control_property(</span><span class="s2">&quot;min-fresh&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s1">only_if_cached = cache_control_property(</span><span class="s2">&quot;only-if-cached&quot;</span><span class="s0">, None, </span><span class="s1">bool)</span>


<span class="s0">class </span><span class="s1">ResponseCacheControl(_CacheControl):</span>
    <span class="s3">&quot;&quot;&quot;A cache control for responses.  Unlike :class:`RequestCacheControl` 
    this is mutable and gives access to response-relevant cache control 
    headers. 
 
    To get a header of the :class:`ResponseCacheControl` object again you can 
    convert the object into a string or call the :meth:`to_header` method.  If 
    you plan to subclass it and add your own items have a look at the sourcecode 
    for that class. 
 
    .. versionadded:: 0.5 
       In previous versions a `CacheControl` class existed that was used 
       both for request and response. 
    &quot;&quot;&quot;</span>

    <span class="s1">public = cache_control_property(</span><span class="s2">&quot;public&quot;</span><span class="s0">, None, </span><span class="s1">bool)</span>
    <span class="s1">private = cache_control_property(</span><span class="s2">&quot;private&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">must_revalidate = cache_control_property(</span><span class="s2">&quot;must-revalidate&quot;</span><span class="s0">, None, </span><span class="s1">bool)</span>
    <span class="s1">proxy_revalidate = cache_control_property(</span><span class="s2">&quot;proxy-revalidate&quot;</span><span class="s0">, None, </span><span class="s1">bool)</span>
    <span class="s1">s_maxage = cache_control_property(</span><span class="s2">&quot;s-maxage&quot;</span><span class="s0">, None, None</span><span class="s1">)</span>
    <span class="s1">immutable = cache_control_property(</span><span class="s2">&quot;immutable&quot;</span><span class="s0">, None, </span><span class="s1">bool)</span>


<span class="s0">def </span><span class="s1">csp_property(key):</span>
    <span class="s3">&quot;&quot;&quot;Return a new property object for a content security policy header. 
    Useful if you want to add support for a csp extension in a 
    subclass. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">property(</span>
        <span class="s0">lambda </span><span class="s1">x: x._get_value(key)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">v: x._set_value(key</span><span class="s0">, </span><span class="s1">v)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">x: x._del_value(key)</span><span class="s0">,</span>
        <span class="s2">f&quot;accessor for </span><span class="s0">{</span><span class="s1">key</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">ContentSecurityPolicy(UpdateDictMixin</span><span class="s0">, </span><span class="s1">dict):</span>
    <span class="s3">&quot;&quot;&quot;Subclass of a dict that stores values for a Content Security Policy 
    header. It has accessors for all the level 3 policies. 
 
    Because the csp directives in the HTTP header use dashes the 
    python descriptors use underscores for that. 
 
    To get a header of the :class:`ContentSecuirtyPolicy` object again 
    you can convert the object into a string or call the 
    :meth:`to_header` method.  If you plan to subclass it and add your 
    own items have a look at the sourcecode for that class. 
 
    .. versionadded:: 1.0.0 
       Support for Content Security Policy headers was added. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">base_uri = csp_property(</span><span class="s2">&quot;base-uri&quot;</span><span class="s1">)</span>
    <span class="s1">child_src = csp_property(</span><span class="s2">&quot;child-src&quot;</span><span class="s1">)</span>
    <span class="s1">connect_src = csp_property(</span><span class="s2">&quot;connect-src&quot;</span><span class="s1">)</span>
    <span class="s1">default_src = csp_property(</span><span class="s2">&quot;default-src&quot;</span><span class="s1">)</span>
    <span class="s1">font_src = csp_property(</span><span class="s2">&quot;font-src&quot;</span><span class="s1">)</span>
    <span class="s1">form_action = csp_property(</span><span class="s2">&quot;form-action&quot;</span><span class="s1">)</span>
    <span class="s1">frame_ancestors = csp_property(</span><span class="s2">&quot;frame-ancestors&quot;</span><span class="s1">)</span>
    <span class="s1">frame_src = csp_property(</span><span class="s2">&quot;frame-src&quot;</span><span class="s1">)</span>
    <span class="s1">img_src = csp_property(</span><span class="s2">&quot;img-src&quot;</span><span class="s1">)</span>
    <span class="s1">manifest_src = csp_property(</span><span class="s2">&quot;manifest-src&quot;</span><span class="s1">)</span>
    <span class="s1">media_src = csp_property(</span><span class="s2">&quot;media-src&quot;</span><span class="s1">)</span>
    <span class="s1">navigate_to = csp_property(</span><span class="s2">&quot;navigate-to&quot;</span><span class="s1">)</span>
    <span class="s1">object_src = csp_property(</span><span class="s2">&quot;object-src&quot;</span><span class="s1">)</span>
    <span class="s1">prefetch_src = csp_property(</span><span class="s2">&quot;prefetch-src&quot;</span><span class="s1">)</span>
    <span class="s1">plugin_types = csp_property(</span><span class="s2">&quot;plugin-types&quot;</span><span class="s1">)</span>
    <span class="s1">report_to = csp_property(</span><span class="s2">&quot;report-to&quot;</span><span class="s1">)</span>
    <span class="s1">report_uri = csp_property(</span><span class="s2">&quot;report-uri&quot;</span><span class="s1">)</span>
    <span class="s1">sandbox = csp_property(</span><span class="s2">&quot;sandbox&quot;</span><span class="s1">)</span>
    <span class="s1">script_src = csp_property(</span><span class="s2">&quot;script-src&quot;</span><span class="s1">)</span>
    <span class="s1">script_src_attr = csp_property(</span><span class="s2">&quot;script-src-attr&quot;</span><span class="s1">)</span>
    <span class="s1">script_src_elem = csp_property(</span><span class="s2">&quot;script-src-elem&quot;</span><span class="s1">)</span>
    <span class="s1">style_src = csp_property(</span><span class="s2">&quot;style-src&quot;</span><span class="s1">)</span>
    <span class="s1">style_src_attr = csp_property(</span><span class="s2">&quot;style-src-attr&quot;</span><span class="s1">)</span>
    <span class="s1">style_src_elem = csp_property(</span><span class="s2">&quot;style-src-elem&quot;</span><span class="s1">)</span>
    <span class="s1">worker_src = csp_property(</span><span class="s2">&quot;worker-src&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values=()</span><span class="s0">, </span><span class="s1">on_update=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">values </span><span class="s0">or </span><span class="s1">())</span>
        <span class="s1">self.on_update = on_update</span>
        <span class="s1">self.provided = values </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">_get_value(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Used internally by the accessor properties.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(key)</span>

    <span class="s0">def </span><span class="s1">_set_value(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot;Used internally by the accessor properties.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.pop(key</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self[key] = value</span>

    <span class="s0">def </span><span class="s1">_del_value(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot;Used internally by the accessor properties.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">del </span><span class="s1">self[key]</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the stored values into a cache control header.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">http.dump_csp_header(self)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">kv_str = </span><span class="s2">&quot; &quot;</span><span class="s1">.join(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">=</span><span class="s0">{</span><span class="s1">v</span><span class="s0">!r}</span><span class="s2">&quot; </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sorted(self.items()))</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">kv_str</span><span class="s0">}</span><span class="s2">&gt;&quot;</span>


<span class="s0">class </span><span class="s1">CallbackDict(UpdateDictMixin</span><span class="s0">, </span><span class="s1">dict):</span>
    <span class="s3">&quot;&quot;&quot;A dict that calls a function passed every time something is changed. 
    The function is passed the dict instance. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None, </span><span class="s1">on_update=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">initial </span><span class="s0">or </span><span class="s1">())</span>
        <span class="s1">self.on_update = on_update</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">dict.__repr__(self)</span><span class="s0">}</span><span class="s2">&gt;&quot;</span>


<span class="s0">class </span><span class="s1">HeaderSet(MutableSet):</span>
    <span class="s3">&quot;&quot;&quot;Similar to the :class:`ETags` class this implements a set-like structure. 
    Unlike :class:`ETags` this is case insensitive and used for vary, allow, and 
    content-language headers. 
 
    If not constructed using the :func:`parse_set_header` function the 
    instantiation works like this: 
 
    &gt;&gt;&gt; hs = HeaderSet(['foo', 'bar', 'baz']) 
    &gt;&gt;&gt; hs 
    HeaderSet(['foo', 'bar', 'baz']) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">headers=</span><span class="s0">None, </span><span class="s1">on_update=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._headers = list(headers </span><span class="s0">or </span><span class="s1">())</span>
        <span class="s1">self._set = {x.lower() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self._headers}</span>
        <span class="s1">self.on_update = on_update</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">header):</span>
        <span class="s3">&quot;&quot;&quot;Add a new header to the set.&quot;&quot;&quot;</span>
        <span class="s1">self.update((header</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">remove(self</span><span class="s0">, </span><span class="s1">header):</span>
        <span class="s3">&quot;&quot;&quot;Remove a header from the set.  This raises an :exc:`KeyError` if the 
        header is not in the set. 
 
        .. versionchanged:: 0.5 
            In older versions a :exc:`IndexError` was raised instead of a 
            :exc:`KeyError` if the object was missing. 
 
        :param header: the header to be removed. 
        &quot;&quot;&quot;</span>
        <span class="s1">key = header.lower()</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self._set:</span>
            <span class="s0">raise </span><span class="s1">KeyError(header)</span>
        <span class="s1">self._set.remove(key)</span>
        <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">key </span><span class="s0">in </span><span class="s1">enumerate(self._headers):</span>
            <span class="s0">if </span><span class="s1">key.lower() == header:</span>
                <span class="s0">del </span><span class="s1">self._headers[idx]</span>
                <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">iterable):</span>
        <span class="s3">&quot;&quot;&quot;Add all the headers from the iterable to the set. 
 
        :param iterable: updates the set with the items from the iterable. 
        &quot;&quot;&quot;</span>
        <span class="s1">inserted_any = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">header </span><span class="s0">in </span><span class="s1">iterable:</span>
            <span class="s1">key = header.lower()</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self._set:</span>
                <span class="s1">self._headers.append(header)</span>
                <span class="s1">self._set.add(key)</span>
                <span class="s1">inserted_any = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">inserted_any </span><span class="s0">and </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">discard(self</span><span class="s0">, </span><span class="s1">header):</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`remove` but ignores errors. 
 
        :param header: the header to be discarded. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.remove(header)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">find(self</span><span class="s0">, </span><span class="s1">header):</span>
        <span class="s3">&quot;&quot;&quot;Return the index of the header in the set or return -1 if not found. 
 
        :param header: the header to be looked up. 
        &quot;&quot;&quot;</span>
        <span class="s1">header = header.lower()</span>
        <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate(self._headers):</span>
            <span class="s0">if </span><span class="s1">item.lower() == header:</span>
                <span class="s0">return </span><span class="s1">idx</span>
        <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">index(self</span><span class="s0">, </span><span class="s1">header):</span>
        <span class="s3">&quot;&quot;&quot;Return the index of the header in the set or raise an 
        :exc:`IndexError`. 
 
        :param header: the header to be looked up. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.find(header)</span>
        <span class="s0">if </span><span class="s1">rv &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">IndexError(header)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s3">&quot;&quot;&quot;Clear the set.&quot;&quot;&quot;</span>
        <span class="s1">self._set.clear()</span>
        <span class="s0">del </span><span class="s1">self._headers[:]</span>
        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">as_set(self</span><span class="s0">, </span><span class="s1">preserve_casing=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the set as real python set type.  When calling this, all 
        the items are converted to lowercase and the ordering is lost. 
 
        :param preserve_casing: if set to `True` the items in the set returned 
                                will have the original case like in the 
                                :class:`HeaderSet`, otherwise they will 
                                be lowercase. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">preserve_casing:</span>
            <span class="s0">return </span><span class="s1">set(self._headers)</span>
        <span class="s0">return </span><span class="s1">set(self._set)</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the header set into an HTTP header string.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(map(http.quote_header_value</span><span class="s0">, </span><span class="s1">self._headers))</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">idx):</span>
        <span class="s0">return </span><span class="s1">self._headers[idx]</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">idx):</span>
        <span class="s1">rv = self._headers.pop(idx)</span>
        <span class="s1">self._set.remove(rv.lower())</span>
        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">old = self._headers[idx]</span>
        <span class="s1">self._set.remove(old.lower())</span>
        <span class="s1">self._headers[idx] = value</span>
        <span class="s1">self._set.add(value.lower())</span>
        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">header):</span>
        <span class="s0">return </span><span class="s1">header.lower() </span><span class="s0">in </span><span class="s1">self._set</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._set)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self._headers)</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">return </span><span class="s1">bool(self._set)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">self._headers</span><span class="s0">!r}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">ETags(Collection):</span>
    <span class="s3">&quot;&quot;&quot;A set that can be used to check if one etag is present in a collection 
    of etags. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">strong_etags=</span><span class="s0">None, </span><span class="s1">weak_etags=</span><span class="s0">None, </span><span class="s1">star_tag=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">star_tag </span><span class="s0">and </span><span class="s1">strong_etags:</span>
            <span class="s1">self._strong = frozenset(strong_etags)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._strong = frozenset()</span>

        <span class="s1">self._weak = frozenset(weak_etags </span><span class="s0">or </span><span class="s1">())</span>
        <span class="s1">self.star_tag = star_tag</span>

    <span class="s0">def </span><span class="s1">as_set(self</span><span class="s0">, </span><span class="s1">include_weak=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Convert the `ETags` object into a python set.  Per default all the 
        weak etags are not part of this set.&quot;&quot;&quot;</span>
        <span class="s1">rv = set(self._strong)</span>
        <span class="s0">if </span><span class="s1">include_weak:</span>
            <span class="s1">rv.update(self._weak)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">is_weak(self</span><span class="s0">, </span><span class="s1">etag):</span>
        <span class="s3">&quot;&quot;&quot;Check if an etag is weak.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">etag </span><span class="s0">in </span><span class="s1">self._weak</span>

    <span class="s0">def </span><span class="s1">is_strong(self</span><span class="s0">, </span><span class="s1">etag):</span>
        <span class="s3">&quot;&quot;&quot;Check if an etag is strong.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">etag </span><span class="s0">in </span><span class="s1">self._strong</span>

    <span class="s0">def </span><span class="s1">contains_weak(self</span><span class="s0">, </span><span class="s1">etag):</span>
        <span class="s3">&quot;&quot;&quot;Check if an etag is part of the set including weak and strong tags.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.is_weak(etag) </span><span class="s0">or </span><span class="s1">self.contains(etag)</span>

    <span class="s0">def </span><span class="s1">contains(self</span><span class="s0">, </span><span class="s1">etag):</span>
        <span class="s3">&quot;&quot;&quot;Check if an etag is part of the set ignoring weak tags. 
        It is also possible to use the ``in`` operator. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.star_tag:</span>
            <span class="s0">return True</span>
        <span class="s0">return </span><span class="s1">self.is_strong(etag)</span>

    <span class="s0">def </span><span class="s1">contains_raw(self</span><span class="s0">, </span><span class="s1">etag):</span>
        <span class="s3">&quot;&quot;&quot;When passed a quoted tag it will check if this tag is part of the 
        set.  If the tag is weak it is checked against weak and strong tags, 
        otherwise strong only.&quot;&quot;&quot;</span>
        <span class="s1">etag</span><span class="s0">, </span><span class="s1">weak = http.unquote_etag(etag)</span>
        <span class="s0">if </span><span class="s1">weak:</span>
            <span class="s0">return </span><span class="s1">self.contains_weak(etag)</span>
        <span class="s0">return </span><span class="s1">self.contains(etag)</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the etags set into a HTTP header string.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.star_tag:</span>
            <span class="s0">return </span><span class="s2">&quot;*&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span><span class="s2">f'&quot;</span><span class="s0">{</span><span class="s1">x</span><span class="s0">}</span><span class="s2">&quot;' </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self._strong] + [</span><span class="s2">f'W/&quot;</span><span class="s0">{</span><span class="s1">x</span><span class="s0">}</span><span class="s2">&quot;' </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self._weak]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">etag=</span><span class="s0">None, </span><span class="s1">data=</span><span class="s0">None, </span><span class="s1">include_weak=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">[etag</span><span class="s0">, </span><span class="s1">data].count(</span><span class="s0">None</span><span class="s1">) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;either tag or data required, but at least one&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">etag </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">etag = http.generate_etag(data)</span>
        <span class="s0">if </span><span class="s1">include_weak:</span>
            <span class="s0">if </span><span class="s1">etag </span><span class="s0">in </span><span class="s1">self._weak:</span>
                <span class="s0">return True</span>
        <span class="s0">return </span><span class="s1">etag </span><span class="s0">in </span><span class="s1">self._strong</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">return </span><span class="s1">bool(self.star_tag </span><span class="s0">or </span><span class="s1">self._strong </span><span class="s0">or </span><span class="s1">self._weak)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._strong)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self._strong)</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">etag):</span>
        <span class="s0">return </span><span class="s1">self.contains(etag)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">str(self)</span><span class="s0">!r}</span><span class="s2">&gt;&quot;</span>


<span class="s0">class </span><span class="s1">IfRange:</span>
    <span class="s3">&quot;&quot;&quot;Very simple object that represents the `If-Range` header in parsed 
    form.  It will either have neither a etag or date or one of either but 
    never both. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">etag=</span><span class="s0">None, </span><span class="s1">date=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5">#: The etag parsed and unquoted.  Ranges always operate on strong</span>
        <span class="s5">#: etags so the weakness information is not necessary.</span>
        <span class="s1">self.etag = etag</span>
        <span class="s5">#: The date in parsed format or `None`.</span>
        <span class="s1">self.date = date</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Converts the object back into an HTTP header.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.date </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">http.http_date(self.date)</span>
        <span class="s0">if </span><span class="s1">self.etag </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">http.quote_etag(self.etag)</span>
        <span class="s0">return </span><span class="s2">&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">str(self)</span><span class="s0">!r}</span><span class="s2">&gt;&quot;</span>


<span class="s0">class </span><span class="s1">Range:</span>
    <span class="s3">&quot;&quot;&quot;Represents a ``Range`` header. All methods only support only 
    bytes as the unit. Stores a list of ranges if given, but the methods 
    only work if only one range is provided. 
 
    :raise ValueError: If the ranges provided are invalid. 
 
    .. versionchanged:: 0.15 
        The ranges passed in are validated. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">units</span><span class="s0">, </span><span class="s1">ranges):</span>
        <span class="s5">#: The units of this range.  Usually &quot;bytes&quot;.</span>
        <span class="s1">self.units = units</span>
        <span class="s5">#: A list of ``(begin, end)`` tuples for the range header provided.</span>
        <span class="s5">#: The ranges are non-inclusive.</span>
        <span class="s1">self.ranges = ranges</span>

        <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end </span><span class="s0">in </span><span class="s1">ranges:</span>
            <span class="s0">if </span><span class="s1">start </span><span class="s0">is None or </span><span class="s1">(end </span><span class="s0">is not None and </span><span class="s1">(start &lt; </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">start &gt;= end)):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">(start</span><span class="s0">, </span><span class="s1">end)</span><span class="s0">} </span><span class="s2">is not a valid range.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">range_for_length(self</span><span class="s0">, </span><span class="s1">length):</span>
        <span class="s3">&quot;&quot;&quot;If the range is for bytes, the length is not None and there is 
        exactly one range and it is satisfiable it returns a ``(start, stop)`` 
        tuple, otherwise `None`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.units != </span><span class="s2">&quot;bytes&quot; </span><span class="s0">or </span><span class="s1">length </span><span class="s0">is None or </span><span class="s1">len(self.ranges) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = self.ranges[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">end = length</span>
            <span class="s0">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">start += length</span>
        <span class="s0">if </span><span class="s1">http.is_byte_range_valid(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">length):</span>
            <span class="s0">return </span><span class="s1">start</span><span class="s0">, </span><span class="s1">min(end</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">make_content_range(self</span><span class="s0">, </span><span class="s1">length):</span>
        <span class="s3">&quot;&quot;&quot;Creates a :class:`~werkzeug.datastructures.ContentRange` object 
        from the current range and given content length. 
        &quot;&quot;&quot;</span>
        <span class="s1">rng = self.range_for_length(length)</span>
        <span class="s0">if </span><span class="s1">rng </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">ContentRange(self.units</span><span class="s0">, </span><span class="s1">rng[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rng[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">length)</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Converts the object back into an HTTP header.&quot;&quot;&quot;</span>
        <span class="s1">ranges = []</span>
        <span class="s0">for </span><span class="s1">begin</span><span class="s0">, </span><span class="s1">end </span><span class="s0">in </span><span class="s1">self.ranges:</span>
            <span class="s0">if </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">ranges.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">begin</span><span class="s0">}</span><span class="s2">-&quot; </span><span class="s0">if </span><span class="s1">begin &gt;= </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">str(begin))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ranges.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">begin</span><span class="s0">}</span><span class="s2">-</span><span class="s0">{</span><span class="s1">end - </span><span class="s4">1</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.units</span><span class="s0">}</span><span class="s2">=</span><span class="s0">{</span><span class="s2">','</span><span class="s1">.join(ranges)</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">def </span><span class="s1">to_content_range_header(self</span><span class="s0">, </span><span class="s1">length):</span>
        <span class="s3">&quot;&quot;&quot;Converts the object into `Content-Range` HTTP header, 
        based on given length 
        &quot;&quot;&quot;</span>
        <span class="s1">range = self.range_for_length(length)</span>
        <span class="s0">if </span><span class="s1">range </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.units</span><span class="s0">} {</span><span class="s1">range[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">}</span><span class="s2">-</span><span class="s0">{</span><span class="s1">range[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s0">}</span><span class="s2">/</span><span class="s0">{</span><span class="s1">length</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">str(self)</span><span class="s0">!r}</span><span class="s2">&gt;&quot;</span>


<span class="s0">def </span><span class="s1">_callback_property(name):</span>
    <span class="s0">def </span><span class="s1">fget(self):</span>
        <span class="s0">return </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">name)</span>

    <span class="s0">def </span><span class="s1">fset(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">return </span><span class="s1">property(fget</span><span class="s0">, </span><span class="s1">fset)</span>


<span class="s0">class </span><span class="s1">ContentRange:</span>
    <span class="s3">&quot;&quot;&quot;Represents the content range header. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">units</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">length=</span><span class="s0">None, </span><span class="s1">on_update=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">http.is_byte_range_valid(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">, </span><span class="s2">&quot;Bad range provided&quot;</span>
        <span class="s1">self.on_update = on_update</span>
        <span class="s1">self.set(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">units)</span>

    <span class="s5">#: The units to use, usually &quot;bytes&quot;</span>
    <span class="s1">units = _callback_property(</span><span class="s2">&quot;_units&quot;</span><span class="s1">)</span>
    <span class="s5">#: The start point of the range or `None`.</span>
    <span class="s1">start = _callback_property(</span><span class="s2">&quot;_start&quot;</span><span class="s1">)</span>
    <span class="s5">#: The stop point of the range (non-inclusive) or `None`.  Can only be</span>
    <span class="s5">#: `None` if also start is `None`.</span>
    <span class="s1">stop = _callback_property(</span><span class="s2">&quot;_stop&quot;</span><span class="s1">)</span>
    <span class="s5">#: The length of the range or `None`.</span>
    <span class="s1">length = _callback_property(</span><span class="s2">&quot;_length&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">length=</span><span class="s0">None, </span><span class="s1">units=</span><span class="s2">&quot;bytes&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Simple method to update the ranges.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">http.is_byte_range_valid(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">, </span><span class="s2">&quot;Bad range provided&quot;</span>
        <span class="s1">self._units = units</span>
        <span class="s1">self._start = start</span>
        <span class="s1">self._stop = stop</span>
        <span class="s1">self._length = length</span>
        <span class="s0">if </span><span class="s1">self.on_update </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">unset(self):</span>
        <span class="s3">&quot;&quot;&quot;Sets the units to `None` which indicates that the header should 
        no longer be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set(</span><span class="s0">None, None, </span><span class="s1">units=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s0">if </span><span class="s1">self.units </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.length </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">length = </span><span class="s2">&quot;*&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">length = self.length</span>
        <span class="s0">if </span><span class="s1">self.start </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.units</span><span class="s0">} </span><span class="s2">*/</span><span class="s0">{</span><span class="s1">length</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.units</span><span class="s0">} {</span><span class="s1">self.start</span><span class="s0">}</span><span class="s2">-</span><span class="s0">{</span><span class="s1">self.stop - </span><span class="s4">1</span><span class="s0">}</span><span class="s2">/</span><span class="s0">{</span><span class="s1">length</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">return </span><span class="s1">self.units </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">str(self)</span><span class="s0">!r}</span><span class="s2">&gt;&quot;</span>


<span class="s0">class </span><span class="s1">Authorization(ImmutableDictMixin</span><span class="s0">, </span><span class="s1">dict):</span>
    <span class="s3">&quot;&quot;&quot;Represents an ``Authorization`` header sent by the client. 
 
    This is returned by 
    :func:`~werkzeug.http.parse_authorization_header`. It can be useful 
    to create the object manually to pass to the test 
    :class:`~werkzeug.test.Client`. 
 
    .. versionchanged:: 0.5 
        This object became immutable. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">auth_type</span><span class="s0">, </span><span class="s1">data=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">data </span><span class="s0">or </span><span class="s1">{})</span>
        <span class="s1">self.type = auth_type</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">username(self):</span>
        <span class="s3">&quot;&quot;&quot;The username transmitted.  This is set for both basic and digest 
        auth all the time. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;username&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">password(self):</span>
        <span class="s3">&quot;&quot;&quot;When the authentication type is basic this is the password 
        transmitted by the client, else `None`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;password&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">realm(self):</span>
        <span class="s3">&quot;&quot;&quot;This is the server realm sent back for HTTP digest auth.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;realm&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nonce(self):</span>
        <span class="s3">&quot;&quot;&quot;The nonce the server sent for digest auth, sent back by the client. 
        A nonce should be unique for every 401 response for HTTP digest auth. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;nonce&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">uri(self):</span>
        <span class="s3">&quot;&quot;&quot;The URI from Request-URI of the Request-Line; duplicated because 
        proxies are allowed to change the Request-Line in transit.  HTTP 
        digest auth only. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;uri&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nc(self):</span>
        <span class="s3">&quot;&quot;&quot;The nonce count value transmitted by clients if a qop-header is 
        also transmitted.  HTTP digest auth only. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;nc&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">cnonce(self):</span>
        <span class="s3">&quot;&quot;&quot;If the server sent a qop-header in the ``WWW-Authenticate`` 
        header, the client has to provide this value for HTTP digest auth. 
        See the RFC for more details. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;cnonce&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">response(self):</span>
        <span class="s3">&quot;&quot;&quot;A string of 32 hex digits computed as defined in RFC 2617, which 
        proves that the user knows a password.  Digest auth only. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;response&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">opaque(self):</span>
        <span class="s3">&quot;&quot;&quot;The opaque header from the server returned unchanged by the client. 
        It is recommended that this string be base64 or hexadecimal data. 
        Digest auth only. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;opaque&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">qop(self):</span>
        <span class="s3">&quot;&quot;&quot;Indicates what &quot;quality of protection&quot; the client has applied to 
        the message for HTTP digest auth. Note that this is a single token, 
        not a quoted list of alternatives as in WWW-Authenticate. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get(</span><span class="s2">&quot;qop&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert to a string value for an ``Authorization`` header. 
 
        .. versionadded:: 2.0 
            Added to support passing authorization to the test client. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.type == </span><span class="s2">&quot;basic&quot;</span><span class="s1">:</span>
            <span class="s1">value = base64.b64encode(</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.username</span><span class="s0">}</span><span class="s2">:</span><span class="s0">{</span><span class="s1">self.password</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">.encode()</span>
            <span class="s1">).decode(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s2">f&quot;Basic </span><span class="s0">{</span><span class="s1">value</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s0">if </span><span class="s1">self.type == </span><span class="s2">&quot;digest&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">f&quot;Digest </span><span class="s0">{</span><span class="s1">http.dump_header(self)</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Unsupported type </span><span class="s0">{</span><span class="s1">self.type</span><span class="s0">!r}</span><span class="s2">.&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">auth_property(name</span><span class="s0">, </span><span class="s1">doc=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;A static helper function for Authentication subclasses to add 
    extra authentication system properties onto a class:: 
 
        class FooAuthenticate(WWWAuthenticate): 
            special_realm = auth_property('special_realm') 
 
    For more information have a look at the sourcecode to see how the 
    regular properties (:attr:`realm` etc.) are implemented. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_set_value(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.pop(name</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self[name] = str(value)</span>

    <span class="s0">return </span><span class="s1">property(</span><span class="s0">lambda </span><span class="s1">x: x.get(name)</span><span class="s0">, </span><span class="s1">_set_value</span><span class="s0">, </span><span class="s1">doc=doc)</span>


<span class="s0">def </span><span class="s1">_set_property(name</span><span class="s0">, </span><span class="s1">doc=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">def </span><span class="s1">fget(self):</span>
        <span class="s0">def </span><span class="s1">on_update(header_set):</span>
            <span class="s0">if not </span><span class="s1">header_set </span><span class="s0">and </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self:</span>
                <span class="s0">del </span><span class="s1">self[name]</span>
            <span class="s0">elif </span><span class="s1">header_set:</span>
                <span class="s1">self[name] = header_set.to_header()</span>

        <span class="s0">return </span><span class="s1">http.parse_set_header(self.get(name)</span><span class="s0">, </span><span class="s1">on_update)</span>

    <span class="s0">return </span><span class="s1">property(fget</span><span class="s0">, </span><span class="s1">doc=doc)</span>


<span class="s0">class </span><span class="s1">WWWAuthenticate(UpdateDictMixin</span><span class="s0">, </span><span class="s1">dict):</span>
    <span class="s3">&quot;&quot;&quot;Provides simple access to `WWW-Authenticate` headers.&quot;&quot;&quot;</span>

    <span class="s5">#: list of keys that require quoting in the generated header</span>
    <span class="s1">_require_quoting = frozenset([</span><span class="s2">&quot;domain&quot;</span><span class="s0">, </span><span class="s2">&quot;nonce&quot;</span><span class="s0">, </span><span class="s2">&quot;opaque&quot;</span><span class="s0">, </span><span class="s2">&quot;realm&quot;</span><span class="s0">, </span><span class="s2">&quot;qop&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">auth_type=</span><span class="s0">None, </span><span class="s1">values=</span><span class="s0">None, </span><span class="s1">on_update=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dict.__init__(self</span><span class="s0">, </span><span class="s1">values </span><span class="s0">or </span><span class="s1">())</span>
        <span class="s0">if </span><span class="s1">auth_type:</span>
            <span class="s1">self[</span><span class="s2">&quot;__auth_type__&quot;</span><span class="s1">] = auth_type</span>
        <span class="s1">self.on_update = on_update</span>

    <span class="s0">def </span><span class="s1">set_basic(self</span><span class="s0">, </span><span class="s1">realm=</span><span class="s2">&quot;authentication required&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Clear the auth info and enable basic auth.&quot;&quot;&quot;</span>
        <span class="s1">dict.clear(self)</span>
        <span class="s1">dict.update(self</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;__auth_type__&quot;</span><span class="s1">: </span><span class="s2">&quot;basic&quot;</span><span class="s0">, </span><span class="s2">&quot;realm&quot;</span><span class="s1">: realm})</span>
        <span class="s0">if </span><span class="s1">self.on_update:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">set_digest(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">realm</span><span class="s0">, </span><span class="s1">nonce</span><span class="s0">, </span><span class="s1">qop=(</span><span class="s2">&quot;auth&quot;</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">opaque=</span><span class="s0">None, </span><span class="s1">algorithm=</span><span class="s0">None, </span><span class="s1">stale=</span><span class="s0">False</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Clear the auth info and enable digest auth.&quot;&quot;&quot;</span>
        <span class="s1">d = {</span>
            <span class="s2">&quot;__auth_type__&quot;</span><span class="s1">: </span><span class="s2">&quot;digest&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;realm&quot;</span><span class="s1">: realm</span><span class="s0">,</span>
            <span class="s2">&quot;nonce&quot;</span><span class="s1">: nonce</span><span class="s0">,</span>
            <span class="s2">&quot;qop&quot;</span><span class="s1">: http.dump_header(qop)</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">stale:</span>
            <span class="s1">d[</span><span class="s2">&quot;stale&quot;</span><span class="s1">] = </span><span class="s2">&quot;TRUE&quot;</span>
        <span class="s0">if </span><span class="s1">opaque </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">d[</span><span class="s2">&quot;opaque&quot;</span><span class="s1">] = opaque</span>
        <span class="s0">if </span><span class="s1">algorithm </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">d[</span><span class="s2">&quot;algorithm&quot;</span><span class="s1">] = algorithm</span>
        <span class="s1">dict.clear(self)</span>
        <span class="s1">dict.update(self</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s0">if </span><span class="s1">self.on_update:</span>
            <span class="s1">self.on_update(self)</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s3">&quot;&quot;&quot;Convert the stored values into a WWW-Authenticate header.&quot;&quot;&quot;</span>
        <span class="s1">d = dict(self)</span>
        <span class="s1">auth_type = d.pop(</span><span class="s2">&quot;__auth_type__&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;basic&quot;</span>
        <span class="s1">kv_items = (</span>
            <span class="s1">(k</span><span class="s0">, </span><span class="s1">http.quote_header_value(v</span><span class="s0">, </span><span class="s1">allow_token=k </span><span class="s0">not in </span><span class="s1">self._require_quoting))</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">d.items()</span>
        <span class="s1">)</span>
        <span class="s1">kv_string = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join([</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">=</span><span class="s0">{</span><span class="s1">v</span><span class="s0">}</span><span class="s2">&quot; </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kv_items])</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">auth_type.title()</span><span class="s0">} {</span><span class="s1">kv_string</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">self.to_header()</span><span class="s0">!r}</span><span class="s2">&gt;&quot;</span>

    <span class="s1">type = auth_property(</span>
        <span class="s2">&quot;__auth_type__&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot;The type of the auth mechanism. HTTP currently specifies 
        ``Basic`` and ``Digest``.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">realm = auth_property(</span>
        <span class="s2">&quot;realm&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot;A string to be displayed to users so they know which 
        username and password to use. This string should contain at 
        least the name of the host performing the authentication and 
        might additionally indicate the collection of users who might 
        have access.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">domain = _set_property(</span>
        <span class="s2">&quot;domain&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot;A list of URIs that define the protection space. If a URI 
        is an absolute path, it is relative to the canonical root URL of 
        the server being accessed.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">nonce = auth_property(</span>
        <span class="s2">&quot;nonce&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot; 
        A server-specified data string which should be uniquely generated 
        each time a 401 response is made. It is recommended that this 
        string be base64 or hexadecimal data.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">opaque = auth_property(</span>
        <span class="s2">&quot;opaque&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot;A string of data, specified by the server, which should 
        be returned by the client unchanged in the Authorization header 
        of subsequent requests with URIs in the same protection space. 
        It is recommended that this string be base64 or hexadecimal 
        data.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">algorithm = auth_property(</span>
        <span class="s2">&quot;algorithm&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot;A string indicating a pair of algorithms used to produce 
        the digest and a checksum. If this is not present it is assumed 
        to be &quot;MD5&quot;. If the algorithm is not understood, the challenge 
        should be ignored (and a different one used, if there is more 
        than one).&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">qop = _set_property(</span>
        <span class="s2">&quot;qop&quot;</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot;A set of quality-of-privacy directives such as auth and 
        auth-int.&quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">stale(self):</span>
        <span class="s3">&quot;&quot;&quot;A flag, indicating that the previous request from the client 
        was rejected because the nonce value was stale. 
        &quot;&quot;&quot;</span>
        <span class="s1">val = self.get(</span><span class="s2">&quot;stale&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">val.lower() == </span><span class="s2">&quot;true&quot;</span>

    <span class="s1">@stale.setter</span>
    <span class="s0">def </span><span class="s1">stale(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.pop(</span><span class="s2">&quot;stale&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self[</span><span class="s2">&quot;stale&quot;</span><span class="s1">] = </span><span class="s2">&quot;TRUE&quot; </span><span class="s0">if </span><span class="s1">value </span><span class="s0">else </span><span class="s2">&quot;FALSE&quot;</span>

    <span class="s1">auth_property = staticmethod(auth_property)</span>


<span class="s0">class </span><span class="s1">FileStorage:</span>
    <span class="s3">&quot;&quot;&quot;The :class:`FileStorage` class is a thin wrapper over incoming files. 
    It is used by the request object to represent uploaded files.  All the 
    attributes of the wrapper stream are proxied by the file storage so 
    it's possible to do ``storage.read()`` instead of the long form 
    ``storage.stream.read()``. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">stream=</span><span class="s0">None,</span>
        <span class="s1">filename=</span><span class="s0">None,</span>
        <span class="s1">name=</span><span class="s0">None,</span>
        <span class="s1">content_type=</span><span class="s0">None,</span>
        <span class="s1">content_length=</span><span class="s0">None,</span>
        <span class="s1">headers=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.stream = stream </span><span class="s0">or </span><span class="s1">BytesIO()</span>

        <span class="s5"># if no filename is provided we can attempt to get the filename</span>
        <span class="s5"># from the stream object passed.  There we have to be careful to</span>
        <span class="s5"># skip things like &lt;fdopen&gt;, &lt;stderr&gt; etc.  Python marks these</span>
        <span class="s5"># special filenames with angular brackets.</span>
        <span class="s0">if </span><span class="s1">filename </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">filename = getattr(stream</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">s = _make_encode_wrapper(filename)</span>
            <span class="s0">if </span><span class="s1">filename </span><span class="s0">and </span><span class="s1">filename[</span><span class="s4">0</span><span class="s1">] == s(</span><span class="s2">&quot;&lt;&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">filename[-</span><span class="s4">1</span><span class="s1">] == s(</span><span class="s2">&quot;&gt;&quot;</span><span class="s1">):</span>
                <span class="s1">filename = </span><span class="s0">None</span>

            <span class="s5"># Make sure the filename is not bytes. This might happen if</span>
            <span class="s5"># the file was opened from the bytes API.</span>
            <span class="s0">if </span><span class="s1">isinstance(filename</span><span class="s0">, </span><span class="s1">bytes):</span>
                <span class="s1">filename = filename.decode(get_filesystem_encoding()</span><span class="s0">, </span><span class="s2">&quot;replace&quot;</span><span class="s1">)</span>

        <span class="s1">self.filename = filename</span>
        <span class="s0">if </span><span class="s1">headers </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">headers = Headers()</span>
        <span class="s1">self.headers = headers</span>
        <span class="s0">if </span><span class="s1">content_type </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">headers[</span><span class="s2">&quot;Content-Type&quot;</span><span class="s1">] = content_type</span>
        <span class="s0">if </span><span class="s1">content_length </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">headers[</span><span class="s2">&quot;Content-Length&quot;</span><span class="s1">] = str(content_length)</span>

    <span class="s0">def </span><span class="s1">_parse_content_type(self):</span>
        <span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s2">&quot;_parsed_content_type&quot;</span><span class="s1">):</span>
            <span class="s1">self._parsed_content_type = http.parse_options_header(self.content_type)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">content_type(self):</span>
        <span class="s3">&quot;&quot;&quot;The content-type sent in the header.  Usually not available&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.headers.get(</span><span class="s2">&quot;content-type&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">content_length(self):</span>
        <span class="s3">&quot;&quot;&quot;The content-length sent in the header.  Usually not available&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">int(self.headers.get(</span><span class="s2">&quot;content-length&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">mimetype(self):</span>
        <span class="s3">&quot;&quot;&quot;Like :attr:`content_type`, but without parameters (eg, without 
        charset, type etc.) and always lowercase.  For example if the content 
        type is ``text/HTML; charset=utf-8`` the mimetype would be 
        ``'text/html'``. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">self._parse_content_type()</span>
        <span class="s0">return </span><span class="s1">self._parsed_content_type[</span><span class="s4">0</span><span class="s1">].lower()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">mimetype_params(self):</span>
        <span class="s3">&quot;&quot;&quot;The mimetype parameters as dict.  For example if the content 
        type is ``text/html; charset=utf-8`` the params would be 
        ``{'charset': 'utf-8'}``. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">self._parse_content_type()</span>
        <span class="s0">return </span><span class="s1">self._parsed_content_type[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">save(self</span><span class="s0">, </span><span class="s1">dst</span><span class="s0">, </span><span class="s1">buffer_size=</span><span class="s4">16384</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Save the file to a destination path or file object.  If the 
        destination is a file object you have to close it yourself after the 
        call.  The buffer size is the number of bytes held in memory during 
        the copy process.  It defaults to 16KB. 
 
        For secure file saving also have a look at :func:`secure_filename`. 
 
        :param dst: a filename, :class:`os.PathLike`, or open file 
            object to write to. 
        :param buffer_size: Passed as the ``length`` parameter of 
            :func:`shutil.copyfileobj`. 
 
        .. versionchanged:: 1.0 
            Supports :mod:`pathlib`. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">shutil </span><span class="s0">import </span><span class="s1">copyfileobj</span>

        <span class="s1">close_dst = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">hasattr(dst</span><span class="s0">, </span><span class="s2">&quot;__fspath__&quot;</span><span class="s1">):</span>
            <span class="s1">dst = fspath(dst)</span>

        <span class="s0">if </span><span class="s1">isinstance(dst</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">dst = open(dst</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">)</span>
            <span class="s1">close_dst = </span><span class="s0">True</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">copyfileobj(self.stream</span><span class="s0">, </span><span class="s1">dst</span><span class="s0">, </span><span class="s1">buffer_size)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">close_dst:</span>
                <span class="s1">dst.close()</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s3">&quot;&quot;&quot;Close the underlying file if possible.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.stream.close()</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">return </span><span class="s1">bool(self.filename)</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">getattr(self.stream</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s5"># SpooledTemporaryFile doesn't implement IOBase, get the</span>
            <span class="s5"># attribute from its backing file instead.</span>
            <span class="s5"># https://github.com/python/cpython/pull/3249</span>
            <span class="s0">if </span><span class="s1">hasattr(self.stream</span><span class="s0">, </span><span class="s2">&quot;_file&quot;</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">getattr(self.stream._file</span><span class="s0">, </span><span class="s1">name)</span>
            <span class="s0">raise</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self.stream)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">: </span><span class="s0">{</span><span class="s1">self.filename</span><span class="s0">!r} </span><span class="s2">(</span><span class="s0">{</span><span class="s1">self.content_type</span><span class="s0">!r}</span><span class="s2">)&gt;&quot;</span>


<span class="s5"># circular dependencies</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">http</span>
</pre>
</body>
</html>