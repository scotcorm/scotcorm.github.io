<html>
<head>
<title>serving.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
serving.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;A WSGI and HTTP server for use **during development only**. This 
server is convenient to use, but is not designed to be particularly 
stable, secure, or efficient. Use a dedicate WSGI server and HTTP 
server when deploying to production. 
 
It provides features like interactive debugging and code reloading. Use 
``run_simple`` to start the server. Put this in a ``run.py`` script: 
 
.. code-block:: python 
 
    from myapp import create_app 
    from werkzeug import run_simple 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">signal</span>
<span class="s2">import </span><span class="s1">socket</span>
<span class="s2">import </span><span class="s1">socketserver</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime </span><span class="s2">as </span><span class="s1">dt</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">timezone</span>
<span class="s2">from </span><span class="s1">http.server </span><span class="s2">import </span><span class="s1">BaseHTTPRequestHandler</span>
<span class="s2">from </span><span class="s1">http.server </span><span class="s2">import </span><span class="s1">HTTPServer</span>

<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_log</span>
<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_wsgi_encoding_dance</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">InternalServerError</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">uri_to_iri</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">url_parse</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">url_unquote</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">ssl</span>
<span class="s2">except </span><span class="s1">ImportError:</span>

    <span class="s2">class </span><span class="s1">_SslDummy:</span>
        <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; t.Any:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;SSL support unavailable&quot;</span><span class="s1">)  </span><span class="s4"># noqa: B904</span>

    <span class="s1">ssl = _SslDummy()  </span><span class="s4"># type: ignore</span>

<span class="s1">_log_add_style = </span><span class="s2">True</span>

<span class="s2">if </span><span class="s1">os.name == </span><span class="s3">&quot;nt&quot;</span><span class="s1">:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">__import__(</span><span class="s3">&quot;colorama&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s1">_log_add_style = </span><span class="s2">False</span>

<span class="s1">can_fork = hasattr(os</span><span class="s2">, </span><span class="s3">&quot;fork&quot;</span><span class="s1">)</span>

<span class="s2">if </span><span class="s1">can_fork:</span>
    <span class="s1">ForkingMixIn = socketserver.ForkingMixIn</span>
<span class="s2">else</span><span class="s1">:</span>

    <span class="s2">class </span><span class="s1">ForkingMixIn:  </span><span class="s4"># type: ignore</span>
        <span class="s2">pass</span>


<span class="s2">try</span><span class="s1">:</span>
    <span class="s1">af_unix = socket.AF_UNIX</span>
<span class="s2">except </span><span class="s1">AttributeError:</span>
    <span class="s1">af_unix = </span><span class="s2">None  </span><span class="s4"># type: ignore</span>

<span class="s1">LISTEN_QUEUE = </span><span class="s5">128</span>
<span class="s1">can_open_by_fd = </span><span class="s2">not </span><span class="s1">platform.system() == </span><span class="s3">&quot;Windows&quot; </span><span class="s2">and </span><span class="s1">hasattr(socket</span><span class="s2">, </span><span class="s3">&quot;fromfd&quot;</span><span class="s1">)</span>

<span class="s1">_TSSLContextArg = t.Optional[</span>
    <span class="s1">t.Union[</span><span class="s3">&quot;ssl.SSLContext&quot;</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Optional[str]]</span><span class="s2">, </span><span class="s3">&quot;te.Literal['adhoc']&quot;</span><span class="s1">]</span>
<span class="s1">]</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te  </span><span class="s4"># noqa: F401</span>
    <span class="s2">from </span><span class="s1">_typeshed.wsgi </span><span class="s2">import </span><span class="s1">WSGIApplication</span>
    <span class="s2">from </span><span class="s1">_typeshed.wsgi </span><span class="s2">import </span><span class="s1">WSGIEnvironment</span>
    <span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric.rsa </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">RSAPrivateKeyWithSerialization</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">from </span><span class="s1">cryptography.x509 </span><span class="s2">import </span><span class="s1">Certificate</span>


<span class="s2">class </span><span class="s1">DechunkedInput(io.RawIOBase):</span>
    <span class="s0">&quot;&quot;&quot;An input stream that handles Transfer-Encoding 'chunked'&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">rfile: t.IO[bytes]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._rfile = rfile</span>
        <span class="s1">self._done = </span><span class="s2">False</span>
        <span class="s1">self._len = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">readable(self) -&gt; bool:</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">read_chunk_len(self) -&gt; int:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">line = self._rfile.readline().decode(</span><span class="s3">&quot;latin1&quot;</span><span class="s1">)</span>
            <span class="s1">_len = int(line.strip()</span><span class="s2">, </span><span class="s5">16</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">OSError(</span><span class="s3">&quot;Invalid chunk header&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">if </span><span class="s1">_len &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">OSError(</span><span class="s3">&quot;Negative chunk length not allowed&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">_len</span>

    <span class="s2">def </span><span class="s1">readinto(self</span><span class="s2">, </span><span class="s1">buf: bytearray) -&gt; int:  </span><span class="s4"># type: ignore</span>
        <span class="s1">read = </span><span class="s5">0</span>
        <span class="s2">while not </span><span class="s1">self._done </span><span class="s2">and </span><span class="s1">read &lt; len(buf):</span>
            <span class="s2">if </span><span class="s1">self._len == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># This is the first chunk or we fully consumed the previous</span>
                <span class="s4"># one. Read the next length of the next chunk</span>
                <span class="s1">self._len = self.read_chunk_len()</span>

            <span class="s2">if </span><span class="s1">self._len == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># Found the final chunk of size 0. The stream is now exhausted,</span>
                <span class="s4"># but there is still a final newline that should be consumed</span>
                <span class="s1">self._done = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">self._len &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># There is data (left) in this chunk, so append it to the</span>
                <span class="s4"># buffer. If this operation fully consumes the chunk, this will</span>
                <span class="s4"># reset self._len to 0.</span>
                <span class="s1">n = min(len(buf)</span><span class="s2">, </span><span class="s1">self._len)</span>

                <span class="s4"># If (read + chunk size) becomes more than len(buf), buf will</span>
                <span class="s4"># grow beyond the original size and read more data than</span>
                <span class="s4"># required. So only read as much data as can fit in buf.</span>
                <span class="s2">if </span><span class="s1">read + n &gt; len(buf):</span>
                    <span class="s1">buf[read:] = self._rfile.read(len(buf) - read)</span>
                    <span class="s1">self._len -= len(buf) - read</span>
                    <span class="s1">read = len(buf)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">buf[read : read + n] = self._rfile.read(n)</span>
                    <span class="s1">self._len -= n</span>
                    <span class="s1">read += n</span>

            <span class="s2">if </span><span class="s1">self._len == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># Skip the terminating newline of a chunk that has been fully</span>
                <span class="s4"># consumed. This also applies to the 0-sized final chunk</span>
                <span class="s1">terminator = self._rfile.readline()</span>
                <span class="s2">if </span><span class="s1">terminator </span><span class="s2">not in </span><span class="s1">(</span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\r\n</span><span class="s6">&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\r</span><span class="s6">&quot;</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">OSError(</span><span class="s3">&quot;Missing chunk terminating newline&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">read</span>


<span class="s2">class </span><span class="s1">WSGIRequestHandler(BaseHTTPRequestHandler):</span>
    <span class="s0">&quot;&quot;&quot;A request handler that implements WSGI dispatching.&quot;&quot;&quot;</span>

    <span class="s1">server: </span><span class="s3">&quot;BaseWSGIServer&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">server_version(self) -&gt; str:  </span><span class="s4"># type: ignore</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">__version__</span>

        <span class="s2">return </span><span class="s3">f&quot;Werkzeug/</span><span class="s2">{</span><span class="s1">__version__</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s2">def </span><span class="s1">make_environ(self) -&gt; </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">:</span>
        <span class="s1">request_url = url_parse(self.path)</span>

        <span class="s2">def </span><span class="s1">shutdown_server() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;The 'environ['werkzeug.server.shutdown']' function is&quot;</span>
                <span class="s3">&quot; deprecated and will be removed in Werkzeug 2.1.&quot;</span><span class="s2">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.server.shutdown_signal = </span><span class="s2">True</span>

        <span class="s1">url_scheme = </span><span class="s3">&quot;http&quot; </span><span class="s2">if </span><span class="s1">self.server.ssl_context </span><span class="s2">is None else </span><span class="s3">&quot;https&quot;</span>

        <span class="s2">if not </span><span class="s1">self.client_address:</span>
            <span class="s1">self.client_address = (</span><span class="s3">&quot;&lt;local&gt;&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.client_address</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self.client_address = (self.client_address</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s4"># If there was no scheme but the path started with two slashes,</span>
        <span class="s4"># the first segment may have been incorrectly parsed as the</span>
        <span class="s4"># netloc, prepend it to the path again.</span>
        <span class="s2">if not </span><span class="s1">request_url.scheme </span><span class="s2">and </span><span class="s1">request_url.netloc:</span>
            <span class="s1">path_info = </span><span class="s3">f&quot;/</span><span class="s2">{</span><span class="s1">request_url.netloc</span><span class="s2">}{</span><span class="s1">request_url.path</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">path_info = request_url.path</span>

        <span class="s1">path_info = url_unquote(path_info)</span>

        <span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot; </span><span class="s1">= {</span>
            <span class="s3">&quot;wsgi.version&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;wsgi.url_scheme&quot;</span><span class="s1">: url_scheme</span><span class="s2">,</span>
            <span class="s3">&quot;wsgi.input&quot;</span><span class="s1">: self.rfile</span><span class="s2">,</span>
            <span class="s3">&quot;wsgi.errors&quot;</span><span class="s1">: sys.stderr</span><span class="s2">,</span>
            <span class="s3">&quot;wsgi.multithread&quot;</span><span class="s1">: self.server.multithread</span><span class="s2">,</span>
            <span class="s3">&quot;wsgi.multiprocess&quot;</span><span class="s1">: self.server.multiprocess</span><span class="s2">,</span>
            <span class="s3">&quot;wsgi.run_once&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;werkzeug.server.shutdown&quot;</span><span class="s1">: shutdown_server</span><span class="s2">,</span>
            <span class="s3">&quot;werkzeug.socket&quot;</span><span class="s1">: self.connection</span><span class="s2">,</span>
            <span class="s3">&quot;SERVER_SOFTWARE&quot;</span><span class="s1">: self.server_version</span><span class="s2">,</span>
            <span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">: self.command</span><span class="s2">,</span>
            <span class="s3">&quot;SCRIPT_NAME&quot;</span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;PATH_INFO&quot;</span><span class="s1">: _wsgi_encoding_dance(path_info)</span><span class="s2">,</span>
            <span class="s3">&quot;QUERY_STRING&quot;</span><span class="s1">: _wsgi_encoding_dance(request_url.query)</span><span class="s2">,</span>
            <span class="s4"># Non-standard, added by mod_wsgi, uWSGI</span>
            <span class="s3">&quot;REQUEST_URI&quot;</span><span class="s1">: _wsgi_encoding_dance(self.path)</span><span class="s2">,</span>
            <span class="s4"># Non-standard, added by gunicorn</span>
            <span class="s3">&quot;RAW_URI&quot;</span><span class="s1">: _wsgi_encoding_dance(self.path)</span><span class="s2">,</span>
            <span class="s3">&quot;REMOTE_ADDR&quot;</span><span class="s1">: self.address_string()</span><span class="s2">,</span>
            <span class="s3">&quot;REMOTE_PORT&quot;</span><span class="s1">: self.port_integer()</span><span class="s2">,</span>
            <span class="s3">&quot;SERVER_NAME&quot;</span><span class="s1">: self.server.server_address[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s3">&quot;SERVER_PORT&quot;</span><span class="s1">: str(self.server.server_address[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s3">&quot;SERVER_PROTOCOL&quot;</span><span class="s1">: self.request_version</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.headers.items():</span>
            <span class="s1">key = key.upper().replace(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s3">&quot;_&quot;</span><span class="s1">)</span>
            <span class="s1">value = value.replace(</span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;CONTENT_TYPE&quot;</span><span class="s2">, </span><span class="s3">&quot;CONTENT_LENGTH&quot;</span><span class="s1">):</span>
                <span class="s1">key = </span><span class="s3">f&quot;HTTP_</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">environ:</span>
                    <span class="s1">value = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">environ[key]</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">environ[key] = value</span>

        <span class="s2">if </span><span class="s1">environ.get(</span><span class="s3">&quot;HTTP_TRANSFER_ENCODING&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).strip().lower() == </span><span class="s3">&quot;chunked&quot;</span><span class="s1">:</span>
            <span class="s1">environ[</span><span class="s3">&quot;wsgi.input_terminated&quot;</span><span class="s1">] = </span><span class="s2">True</span>
            <span class="s1">environ[</span><span class="s3">&quot;wsgi.input&quot;</span><span class="s1">] = DechunkedInput(environ[</span><span class="s3">&quot;wsgi.input&quot;</span><span class="s1">])</span>

        <span class="s4"># Per RFC 2616, if the URL is absolute, use that as the host.</span>
        <span class="s4"># We're using &quot;has a scheme&quot; to indicate an absolute URL.</span>
        <span class="s2">if </span><span class="s1">request_url.scheme </span><span class="s2">and </span><span class="s1">request_url.netloc:</span>
            <span class="s1">environ[</span><span class="s3">&quot;HTTP_HOST&quot;</span><span class="s1">] = request_url.netloc</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s4"># binary_form=False gives nicer information, but wouldn't be compatible with</span>
            <span class="s4"># what Nginx or Apache could return.</span>
            <span class="s1">peer_cert = self.connection.getpeercert(binary_form=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">peer_cert </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s4"># Nginx and Apache use PEM format.</span>
                <span class="s1">environ[</span><span class="s3">&quot;SSL_CLIENT_CERT&quot;</span><span class="s1">] = ssl.DER_cert_to_PEM_cert(peer_cert)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s4"># SSL handshake hasn't finished.</span>
            <span class="s1">self.server.log(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s3">&quot;Cannot fetch SSL peer certificate info&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s4"># Not using TLS, the socket will not have getpeercert().</span>
            <span class="s2">pass</span>

        <span class="s2">return </span><span class="s1">environ</span>

    <span class="s2">def </span><span class="s1">run_wsgi(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.headers.get(</span><span class="s3">&quot;Expect&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).lower().strip() == </span><span class="s3">&quot;100-continue&quot;</span><span class="s1">:</span>
            <span class="s1">self.wfile.write(</span><span class="s6">b&quot;HTTP/1.1 100 Continue</span><span class="s2">\r\n\r\n</span><span class="s6">&quot;</span><span class="s1">)</span>

        <span class="s1">self.environ = environ = self.make_environ()</span>
        <span class="s1">status_set: t.Optional[str] = </span><span class="s2">None</span>
        <span class="s1">headers_set: t.Optional[t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]] = </span><span class="s2">None</span>
        <span class="s1">status_sent: t.Optional[str] = </span><span class="s2">None</span>
        <span class="s1">headers_sent: t.Optional[t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]] = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">write(data: bytes) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">nonlocal </span><span class="s1">status_sent</span><span class="s2">, </span><span class="s1">headers_sent</span>
            <span class="s2">assert </span><span class="s1">status_set </span><span class="s2">is not None, </span><span class="s3">&quot;write() before start_response&quot;</span>
            <span class="s2">assert </span><span class="s1">headers_set </span><span class="s2">is not None, </span><span class="s3">&quot;write() before start_response&quot;</span>
            <span class="s2">if </span><span class="s1">status_sent </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">status_sent = status_set</span>
                <span class="s1">headers_sent = headers_set</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">code_str</span><span class="s2">, </span><span class="s1">msg = status_sent.split(</span><span class="s2">None, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s1">code_str</span><span class="s2">, </span><span class="s1">msg = status_sent</span><span class="s2">, </span><span class="s3">&quot;&quot;</span>
                <span class="s1">code = int(code_str)</span>
                <span class="s1">self.send_response(code</span><span class="s2">, </span><span class="s1">msg)</span>
                <span class="s1">header_keys = set()</span>
                <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">headers_sent:</span>
                    <span class="s1">self.send_header(key</span><span class="s2">, </span><span class="s1">value)</span>
                    <span class="s1">key = key.lower()</span>
                    <span class="s1">header_keys.add(key)</span>
                <span class="s2">if not </span><span class="s1">(</span>
                    <span class="s3">&quot;content-length&quot; </span><span class="s2">in </span><span class="s1">header_keys</span>
                    <span class="s2">or </span><span class="s1">environ[</span><span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">] == </span><span class="s3">&quot;HEAD&quot;</span>
                    <span class="s2">or </span><span class="s1">code &lt; </span><span class="s5">200</span>
                    <span class="s2">or </span><span class="s1">code </span><span class="s2">in </span><span class="s1">(</span><span class="s5">204</span><span class="s2">, </span><span class="s5">304</span><span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s1">self.close_connection = </span><span class="s2">True</span>
                    <span class="s1">self.send_header(</span><span class="s3">&quot;Connection&quot;</span><span class="s2">, </span><span class="s3">&quot;close&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s3">&quot;server&quot; </span><span class="s2">not in </span><span class="s1">header_keys:</span>
                    <span class="s1">self.send_header(</span><span class="s3">&quot;Server&quot;</span><span class="s2">, </span><span class="s1">self.version_string())</span>
                <span class="s2">if </span><span class="s3">&quot;date&quot; </span><span class="s2">not in </span><span class="s1">header_keys:</span>
                    <span class="s1">self.send_header(</span><span class="s3">&quot;Date&quot;</span><span class="s2">, </span><span class="s1">self.date_time_string())</span>
                <span class="s1">self.end_headers()</span>

            <span class="s2">assert </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">bytes)</span><span class="s2">, </span><span class="s3">&quot;applications must write bytes&quot;</span>
            <span class="s1">self.wfile.write(data)</span>
            <span class="s1">self.wfile.flush()</span>

        <span class="s2">def </span><span class="s1">start_response(status</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">exc_info=</span><span class="s2">None</span><span class="s1">):  </span><span class="s4"># type: ignore</span>
            <span class="s2">nonlocal </span><span class="s1">status_set</span><span class="s2">, </span><span class="s1">headers_set</span>
            <span class="s2">if </span><span class="s1">exc_info:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">headers_sent:</span>
                        <span class="s2">raise </span><span class="s1">exc_info[</span><span class="s5">1</span><span class="s1">].with_traceback(exc_info[</span><span class="s5">2</span><span class="s1">])</span>
                <span class="s2">finally</span><span class="s1">:</span>
                    <span class="s1">exc_info = </span><span class="s2">None</span>
            <span class="s2">elif </span><span class="s1">headers_set:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Headers already set&quot;</span><span class="s1">)</span>
            <span class="s1">status_set = status</span>
            <span class="s1">headers_set = headers</span>
            <span class="s2">return </span><span class="s1">write</span>

        <span class="s2">def </span><span class="s1">execute(app: </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">application_iter = app(environ</span><span class="s2">, </span><span class="s1">start_response)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">data </span><span class="s2">in </span><span class="s1">application_iter:</span>
                    <span class="s1">write(data)</span>
                <span class="s2">if not </span><span class="s1">headers_sent:</span>
                    <span class="s1">write(</span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">hasattr(application_iter</span><span class="s2">, </span><span class="s3">&quot;close&quot;</span><span class="s1">):</span>
                    <span class="s1">application_iter.close()  </span><span class="s4"># type: ignore</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">execute(self.server.app)</span>
        <span class="s2">except </span><span class="s1">(ConnectionError</span><span class="s2">, </span><span class="s1">socket.timeout) </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">self.connection_dropped(e</span><span class="s2">, </span><span class="s1">environ)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">if </span><span class="s1">self.server.passthrough_errors:</span>
                <span class="s2">raise</span>
            <span class="s2">from </span><span class="s1">.debug.tbtools </span><span class="s2">import </span><span class="s1">get_current_traceback</span>

            <span class="s1">traceback = get_current_traceback(ignore_system_exceptions=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># if we haven't yet sent the headers but they are set</span>
                <span class="s4"># we roll back to be able to set them again.</span>
                <span class="s2">if </span><span class="s1">status_sent </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">status_set = </span><span class="s2">None</span>
                    <span class="s1">headers_set = </span><span class="s2">None</span>
                <span class="s1">execute(InternalServerError())</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s2">pass</span>
            <span class="s1">self.server.log(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s3">&quot;Error on request:</span><span class="s2">\n</span><span class="s3">%s&quot;</span><span class="s2">, </span><span class="s1">traceback.plaintext)</span>

    <span class="s2">def </span><span class="s1">handle(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Handles a request ignoring dropped connections.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">BaseHTTPRequestHandler.handle(self)</span>
        <span class="s2">except </span><span class="s1">(ConnectionError</span><span class="s2">, </span><span class="s1">socket.timeout) </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">self.connection_dropped(e)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">self.server.ssl_context </span><span class="s2">is not None and </span><span class="s1">is_ssl_error(e):</span>
                <span class="s1">self.log_error(</span><span class="s3">&quot;SSL error occurred: %s&quot;</span><span class="s2">, </span><span class="s1">e)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise</span>
        <span class="s2">if </span><span class="s1">self.server.shutdown_signal:</span>
            <span class="s1">self.initiate_shutdown()</span>

    <span class="s2">def </span><span class="s1">initiate_shutdown(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_running_from_reloader():</span>
            <span class="s4"># Windows does not provide SIGKILL, go with SIGTERM then.</span>
            <span class="s1">sig = getattr(signal</span><span class="s2">, </span><span class="s3">&quot;SIGKILL&quot;</span><span class="s2">, </span><span class="s1">signal.SIGTERM)</span>
            <span class="s1">os.kill(os.getpid()</span><span class="s2">, </span><span class="s1">sig)</span>

        <span class="s1">self.server._BaseServer__shutdown_request = </span><span class="s2">True  </span><span class="s4"># type: ignore</span>

    <span class="s2">def </span><span class="s1">connection_dropped(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">error: BaseException</span><span class="s2">, </span><span class="s1">environ: t.Optional[</span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Called if the connection was closed by the client.  By default 
        nothing happens. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">handle_one_request(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Handle a single HTTP request.&quot;&quot;&quot;</span>
        <span class="s1">self.raw_requestline = self.rfile.readline()</span>
        <span class="s2">if not </span><span class="s1">self.raw_requestline:</span>
            <span class="s1">self.close_connection = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">self.parse_request():</span>
            <span class="s1">self.run_wsgi()</span>

    <span class="s2">def </span><span class="s1">send_response(self</span><span class="s2">, </span><span class="s1">code: int</span><span class="s2">, </span><span class="s1">message: t.Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Send the response header and log the response code.&quot;&quot;&quot;</span>
        <span class="s1">self.log_request(code)</span>
        <span class="s2">if </span><span class="s1">message </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">message = self.responses[code][</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">code </span><span class="s2">in </span><span class="s1">self.responses </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.request_version != </span><span class="s3">&quot;HTTP/0.9&quot;</span><span class="s1">:</span>
            <span class="s1">hdr = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.protocol_version</span><span class="s2">} {</span><span class="s1">code</span><span class="s2">} {</span><span class="s1">message</span><span class="s2">}\r\n</span><span class="s3">&quot;</span>
            <span class="s1">self.wfile.write(hdr.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">version_string(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">super().version_string().strip()</span>

    <span class="s2">def </span><span class="s1">address_string(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;environ&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.environ[</span><span class="s3">&quot;REMOTE_ADDR&quot;</span><span class="s1">]  </span><span class="s4"># type: ignore</span>

        <span class="s2">if not </span><span class="s1">self.client_address:</span>
            <span class="s2">return </span><span class="s3">&quot;&lt;local&gt;&quot;</span>

        <span class="s2">return </span><span class="s1">self.client_address[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">port_integer(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">self.client_address[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">log_request(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">code: t.Union[int</span><span class="s2">, </span><span class="s1">str] = </span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s1">size: t.Union[int</span><span class="s2">, </span><span class="s1">str] = </span><span class="s3">&quot;-&quot;</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">path = uri_to_iri(self.path)</span>
            <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.command</span><span class="s2">} {</span><span class="s1">path</span><span class="s2">} {</span><span class="s1">self.request_version</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s4"># path isn't set if the requestline was bad</span>
            <span class="s1">msg = self.requestline</span>

        <span class="s1">code = str(code)</span>

        <span class="s2">if </span><span class="s1">_log_add_style:</span>
            <span class="s2">if </span><span class="s1">code[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;1&quot;</span><span class="s1">:  </span><span class="s4"># 1xx - Informational</span>
                <span class="s1">msg = _ansi_style(msg</span><span class="s2">, </span><span class="s3">&quot;bold&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">code == </span><span class="s3">&quot;200&quot;</span><span class="s1">:  </span><span class="s4"># 2xx - Success</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">code == </span><span class="s3">&quot;304&quot;</span><span class="s1">:  </span><span class="s4"># 304 - Resource Not Modified</span>
                <span class="s1">msg = _ansi_style(msg</span><span class="s2">, </span><span class="s3">&quot;cyan&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">code[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;3&quot;</span><span class="s1">:  </span><span class="s4"># 3xx - Redirection</span>
                <span class="s1">msg = _ansi_style(msg</span><span class="s2">, </span><span class="s3">&quot;green&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">code == </span><span class="s3">&quot;404&quot;</span><span class="s1">:  </span><span class="s4"># 404 - Resource Not Found</span>
                <span class="s1">msg = _ansi_style(msg</span><span class="s2">, </span><span class="s3">&quot;yellow&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">code[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;4&quot;</span><span class="s1">:  </span><span class="s4"># 4xx - Client Error</span>
                <span class="s1">msg = _ansi_style(msg</span><span class="s2">, </span><span class="s3">&quot;bold&quot;</span><span class="s2">, </span><span class="s3">&quot;red&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s4"># 5xx, or any other response</span>
                <span class="s1">msg = _ansi_style(msg</span><span class="s2">, </span><span class="s3">&quot;bold&quot;</span><span class="s2">, </span><span class="s3">&quot;magenta&quot;</span><span class="s1">)</span>

        <span class="s1">self.log(</span><span class="s3">&quot;info&quot;</span><span class="s2">, </span><span class="s3">'&quot;%s&quot; %s %s'</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">size)</span>

    <span class="s2">def </span><span class="s1">log_error(self</span><span class="s2">, </span><span class="s1">format: str</span><span class="s2">, </span><span class="s1">*args: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.log(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">log_message(self</span><span class="s2">, </span><span class="s1">format: str</span><span class="s2">, </span><span class="s1">*args: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.log(</span><span class="s3">&quot;info&quot;</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">log(self</span><span class="s2">, </span><span class="s1">type: str</span><span class="s2">, </span><span class="s1">message: str</span><span class="s2">, </span><span class="s1">*args: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">_log(</span>
            <span class="s1">type</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.address_string()</span><span class="s2">} </span><span class="s3">- - [</span><span class="s2">{</span><span class="s1">self.log_date_time_string()</span><span class="s2">}</span><span class="s3">] </span><span class="s2">{</span><span class="s1">message</span><span class="s2">}\n</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_ansi_style(value: str</span><span class="s2">, </span><span class="s1">*styles: str) -&gt; str:</span>
    <span class="s1">codes = {</span>
        <span class="s3">&quot;bold&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s3">&quot;red&quot;</span><span class="s1">: </span><span class="s5">31</span><span class="s2">,</span>
        <span class="s3">&quot;green&quot;</span><span class="s1">: </span><span class="s5">32</span><span class="s2">,</span>
        <span class="s3">&quot;yellow&quot;</span><span class="s1">: </span><span class="s5">33</span><span class="s2">,</span>
        <span class="s3">&quot;magenta&quot;</span><span class="s1">: </span><span class="s5">35</span><span class="s2">,</span>
        <span class="s3">&quot;cyan&quot;</span><span class="s1">: </span><span class="s5">36</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">style </span><span class="s2">in </span><span class="s1">styles:</span>
        <span class="s1">value = </span><span class="s3">f&quot;</span><span class="s2">\x1b</span><span class="s3">[</span><span class="s2">{</span><span class="s1">codes[style]</span><span class="s2">}</span><span class="s3">m</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}\x1b</span><span class="s3">[0m&quot;</span>


<span class="s2">def </span><span class="s1">generate_adhoc_ssl_pair(</span>
    <span class="s1">cn: t.Optional[str] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; t.Tuple[</span><span class="s3">&quot;Certificate&quot;</span><span class="s2">, </span><span class="s3">&quot;RSAPrivateKeyWithSerialization&quot;</span><span class="s1">]:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">cryptography </span><span class="s2">import </span><span class="s1">x509</span>
        <span class="s2">from </span><span class="s1">cryptography.x509.oid </span><span class="s2">import </span><span class="s1">NameOID</span>
        <span class="s2">from </span><span class="s1">cryptography.hazmat.backends </span><span class="s2">import </span><span class="s1">default_backend</span>
        <span class="s2">from </span><span class="s1">cryptography.hazmat.primitives </span><span class="s2">import </span><span class="s1">hashes</span>
        <span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric </span><span class="s2">import </span><span class="s1">rsa</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">&quot;Using ad-hoc certificates requires the cryptography library.&quot;</span>
        <span class="s1">) </span><span class="s2">from None</span>

    <span class="s1">backend = default_backend()</span>
    <span class="s1">pkey = rsa.generate_private_key(</span>
        <span class="s1">public_exponent=</span><span class="s5">65537</span><span class="s2">, </span><span class="s1">key_size=</span><span class="s5">2048</span><span class="s2">, </span><span class="s1">backend=backend</span>
    <span class="s1">)</span>

    <span class="s4"># pretty damn sure that this is not actually accepted by anyone</span>
    <span class="s2">if </span><span class="s1">cn </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">cn = </span><span class="s3">&quot;*&quot;</span>

    <span class="s1">subject = x509.Name(</span>
        <span class="s1">[</span>
            <span class="s1">x509.NameAttribute(NameOID.ORGANIZATION_NAME</span><span class="s2">, </span><span class="s3">&quot;Dummy Certificate&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">x509.NameAttribute(NameOID.COMMON_NAME</span><span class="s2">, </span><span class="s1">cn)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">backend = default_backend()</span>
    <span class="s1">cert = (</span>
        <span class="s1">x509.CertificateBuilder()</span>
        <span class="s1">.subject_name(subject)</span>
        <span class="s1">.issuer_name(subject)</span>
        <span class="s1">.public_key(pkey.public_key())</span>
        <span class="s1">.serial_number(x509.random_serial_number())</span>
        <span class="s1">.not_valid_before(dt.now(timezone.utc))</span>
        <span class="s1">.not_valid_after(dt.now(timezone.utc) + timedelta(days=</span><span class="s5">365</span><span class="s1">))</span>
        <span class="s1">.add_extension(x509.ExtendedKeyUsage([x509.OID_SERVER_AUTH])</span><span class="s2">, </span><span class="s1">critical=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">.add_extension(x509.SubjectAlternativeName([x509.DNSName(cn)])</span><span class="s2">, </span><span class="s1">critical=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">.sign(pkey</span><span class="s2">, </span><span class="s1">hashes.SHA256()</span><span class="s2">, </span><span class="s1">backend)</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">cert</span><span class="s2">, </span><span class="s1">pkey</span>


<span class="s2">def </span><span class="s1">make_ssl_devcert(</span>
    <span class="s1">base_path: str</span><span class="s2">, </span><span class="s1">host: t.Optional[str] = </span><span class="s2">None, </span><span class="s1">cn: t.Optional[str] = </span><span class="s2">None</span>
<span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot;Creates an SSL key for development.  This should be used instead of 
    the ``'adhoc'`` key which generates a new cert on each server start. 
    It accepts a path for where it should store the key and cert and 
    either a host or CN.  If a host is given it will use the CN 
    ``*.host/CN=host``. 
 
    For more information see :func:`run_simple`. 
 
    .. versionadded:: 0.9 
 
    :param base_path: the path to the certificate and key.  The extension 
                      ``.crt`` is added for the certificate, ``.key`` is 
                      added for the key. 
    :param host: the name of the host.  This can be used as an alternative 
                 for the `cn`. 
    :param cn: the `CN` to use. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">host </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">cn = </span><span class="s3">f&quot;*.</span><span class="s2">{</span><span class="s1">host</span><span class="s2">}</span><span class="s3">/CN=</span><span class="s2">{</span><span class="s1">host</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s1">cert</span><span class="s2">, </span><span class="s1">pkey = generate_adhoc_ssl_pair(cn=cn)</span>

    <span class="s2">from </span><span class="s1">cryptography.hazmat.primitives </span><span class="s2">import </span><span class="s1">serialization</span>

    <span class="s1">cert_file = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base_path</span><span class="s2">}</span><span class="s3">.crt&quot;</span>
    <span class="s1">pkey_file = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base_path</span><span class="s2">}</span><span class="s3">.key&quot;</span>

    <span class="s2">with </span><span class="s1">open(cert_file</span><span class="s2">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">f.write(cert.public_bytes(serialization.Encoding.PEM))</span>
    <span class="s2">with </span><span class="s1">open(pkey_file</span><span class="s2">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">f.write(</span>
            <span class="s1">pkey.private_bytes(</span>
                <span class="s1">encoding=serialization.Encoding.PEM</span><span class="s2">,</span>
                <span class="s1">format=serialization.PrivateFormat.TraditionalOpenSSL</span><span class="s2">,</span>
                <span class="s1">encryption_algorithm=serialization.NoEncryption()</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">cert_file</span><span class="s2">, </span><span class="s1">pkey_file</span>


<span class="s2">def </span><span class="s1">generate_adhoc_ssl_context() -&gt; </span><span class="s3">&quot;ssl.SSLContext&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Generates an adhoc SSL context for the development server.&quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">tempfile</span>
    <span class="s2">import </span><span class="s1">atexit</span>

    <span class="s1">cert</span><span class="s2">, </span><span class="s1">pkey = generate_adhoc_ssl_pair()</span>

    <span class="s2">from </span><span class="s1">cryptography.hazmat.primitives </span><span class="s2">import </span><span class="s1">serialization</span>

    <span class="s1">cert_handle</span><span class="s2">, </span><span class="s1">cert_file = tempfile.mkstemp()</span>
    <span class="s1">pkey_handle</span><span class="s2">, </span><span class="s1">pkey_file = tempfile.mkstemp()</span>
    <span class="s1">atexit.register(os.remove</span><span class="s2">, </span><span class="s1">pkey_file)</span>
    <span class="s1">atexit.register(os.remove</span><span class="s2">, </span><span class="s1">cert_file)</span>

    <span class="s1">os.write(cert_handle</span><span class="s2">, </span><span class="s1">cert.public_bytes(serialization.Encoding.PEM))</span>
    <span class="s1">os.write(</span>
        <span class="s1">pkey_handle</span><span class="s2">,</span>
        <span class="s1">pkey.private_bytes(</span>
            <span class="s1">encoding=serialization.Encoding.PEM</span><span class="s2">,</span>
            <span class="s1">format=serialization.PrivateFormat.TraditionalOpenSSL</span><span class="s2">,</span>
            <span class="s1">encryption_algorithm=serialization.NoEncryption()</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">os.close(cert_handle)</span>
    <span class="s1">os.close(pkey_handle)</span>
    <span class="s1">ctx = load_ssl_context(cert_file</span><span class="s2">, </span><span class="s1">pkey_file)</span>
    <span class="s2">return </span><span class="s1">ctx</span>


<span class="s2">def </span><span class="s1">load_ssl_context(</span>
    <span class="s1">cert_file: str</span><span class="s2">, </span><span class="s1">pkey_file: t.Optional[str] = </span><span class="s2">None, </span><span class="s1">protocol: t.Optional[int] = </span><span class="s2">None</span>
<span class="s1">) -&gt; </span><span class="s3">&quot;ssl.SSLContext&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Loads SSL context from cert/private key files and optional protocol. 
    Many parameters are directly taken from the API of 
    :py:class:`ssl.SSLContext`. 
 
    :param cert_file: Path of the certificate to use. 
    :param pkey_file: Path of the private key to use. If not given, the key 
                      will be obtained from the certificate file. 
    :param protocol: A ``PROTOCOL`` constant from the :mod:`ssl` module. 
        Defaults to :data:`ssl.PROTOCOL_TLS_SERVER`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">protocol </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">protocol = ssl.PROTOCOL_TLS_SERVER</span>

    <span class="s1">ctx = ssl.SSLContext(protocol)</span>
    <span class="s1">ctx.load_cert_chain(cert_file</span><span class="s2">, </span><span class="s1">pkey_file)</span>
    <span class="s2">return </span><span class="s1">ctx</span>


<span class="s2">def </span><span class="s1">is_ssl_error(error: t.Optional[Exception] = </span><span class="s2">None</span><span class="s1">) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;Checks if the given error (or the current one) is an SSL error.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">error </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">error = t.cast(Exception</span><span class="s2">, </span><span class="s1">sys.exc_info()[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">isinstance(error</span><span class="s2">, </span><span class="s1">ssl.SSLError)</span>


<span class="s2">def </span><span class="s1">select_address_family(host: str</span><span class="s2">, </span><span class="s1">port: int) -&gt; socket.AddressFamily:</span>
    <span class="s0">&quot;&quot;&quot;Return ``AF_INET4``, ``AF_INET6``, or ``AF_UNIX`` depending on 
    the host and port.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">host.startswith(</span><span class="s3">&quot;unix://&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">socket.AF_UNIX</span>
    <span class="s2">elif </span><span class="s3">&quot;:&quot; </span><span class="s2">in </span><span class="s1">host </span><span class="s2">and </span><span class="s1">hasattr(socket</span><span class="s2">, </span><span class="s3">&quot;AF_INET6&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">socket.AF_INET6</span>
    <span class="s2">return </span><span class="s1">socket.AF_INET</span>


<span class="s2">def </span><span class="s1">get_sockaddr(</span>
    <span class="s1">host: str</span><span class="s2">, </span><span class="s1">port: int</span><span class="s2">, </span><span class="s1">family: socket.AddressFamily</span>
<span class="s1">) -&gt; t.Union[t.Tuple[str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot;Return a fully qualified socket address that can be passed to 
    :func:`socket.bind`.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">family == af_unix:</span>
        <span class="s2">return </span><span class="s1">host.split(</span><span class="s3">&quot;://&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">res = socket.getaddrinfo(</span>
            <span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">socket.SOCK_STREAM</span><span class="s2">, </span><span class="s1">socket.IPPROTO_TCP</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">socket.gaierror:</span>
        <span class="s2">return </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span>
    <span class="s2">return </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">4</span><span class="s1">]  </span><span class="s4"># type: ignore</span>


<span class="s2">def </span><span class="s1">get_interface_ip(family: socket.AddressFamily) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Get the IP address of an external interface. Used when binding to 
    0.0.0.0 or ::1 to show a more useful URL. 
 
    :meta private: 
    &quot;&quot;&quot;</span>
    <span class="s4"># arbitrary private address</span>
    <span class="s1">host = </span><span class="s3">&quot;fd31:f903:5ab5:1::1&quot; </span><span class="s2">if </span><span class="s1">family == socket.AF_INET6 </span><span class="s2">else </span><span class="s3">&quot;10.253.155.219&quot;</span>

    <span class="s2">with </span><span class="s1">socket.socket(family</span><span class="s2">, </span><span class="s1">socket.SOCK_DGRAM) </span><span class="s2">as </span><span class="s1">s:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">s.connect((host</span><span class="s2">, </span><span class="s5">58162</span><span class="s1">))</span>
        <span class="s2">except </span><span class="s1">OSError:</span>
            <span class="s2">return </span><span class="s3">&quot;::1&quot; </span><span class="s2">if </span><span class="s1">family == socket.AF_INET6 </span><span class="s2">else </span><span class="s3">&quot;127.0.0.1&quot;</span>

        <span class="s2">return </span><span class="s1">s.getsockname()[</span><span class="s5">0</span><span class="s1">]  </span><span class="s4"># type: ignore</span>


<span class="s2">class </span><span class="s1">BaseWSGIServer(HTTPServer):</span>

    <span class="s0">&quot;&quot;&quot;Simple single-threaded, single-process WSGI server.&quot;&quot;&quot;</span>

    <span class="s1">multithread = </span><span class="s2">False</span>
    <span class="s1">multiprocess = </span><span class="s2">False</span>
    <span class="s1">request_queue_size = LISTEN_QUEUE</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">host: str</span><span class="s2">,</span>
        <span class="s1">port: int</span><span class="s2">,</span>
        <span class="s1">app: </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s2">,</span>
        <span class="s1">handler: t.Optional[t.Type[WSGIRequestHandler]] = </span><span class="s2">None,</span>
        <span class="s1">passthrough_errors: bool = </span><span class="s2">False,</span>
        <span class="s1">ssl_context: t.Optional[_TSSLContextArg] = </span><span class="s2">None,</span>
        <span class="s1">fd: t.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">handler </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">handler = WSGIRequestHandler</span>

        <span class="s1">self.address_family = select_address_family(host</span><span class="s2">, </span><span class="s1">port)</span>

        <span class="s2">if </span><span class="s1">fd </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">real_sock = socket.fromfd(fd</span><span class="s2">, </span><span class="s1">self.address_family</span><span class="s2">, </span><span class="s1">socket.SOCK_STREAM)</span>
            <span class="s1">port = </span><span class="s5">0</span>

        <span class="s1">server_address = get_sockaddr(host</span><span class="s2">, </span><span class="s1">int(port)</span><span class="s2">, </span><span class="s1">self.address_family)</span>

        <span class="s4"># remove socket file if it already exists</span>
        <span class="s2">if </span><span class="s1">self.address_family == af_unix:</span>
            <span class="s1">server_address = t.cast(str</span><span class="s2">, </span><span class="s1">server_address)</span>

            <span class="s2">if </span><span class="s1">os.path.exists(server_address):</span>
                <span class="s1">os.unlink(server_address)</span>

        <span class="s1">super().__init__(server_address</span><span class="s2">, </span><span class="s1">handler)  </span><span class="s4"># type: ignore</span>

        <span class="s1">self.app = app</span>
        <span class="s1">self.passthrough_errors = passthrough_errors</span>
        <span class="s1">self.shutdown_signal = </span><span class="s2">False</span>
        <span class="s1">self.host = host</span>
        <span class="s1">self.port = self.socket.getsockname()[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s4"># Patch in the original socket.</span>
        <span class="s2">if </span><span class="s1">fd </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.socket.close()</span>
            <span class="s1">self.socket = real_sock</span>
            <span class="s1">self.server_address = self.socket.getsockname()</span>

        <span class="s2">if </span><span class="s1">ssl_context </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(ssl_context</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s1">ssl_context = load_ssl_context(*ssl_context)</span>
            <span class="s2">if </span><span class="s1">ssl_context == </span><span class="s3">&quot;adhoc&quot;</span><span class="s1">:</span>
                <span class="s1">ssl_context = generate_adhoc_ssl_context()</span>

            <span class="s1">self.socket = ssl_context.wrap_socket(self.socket</span><span class="s2">, </span><span class="s1">server_side=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.ssl_context: t.Optional[</span><span class="s3">&quot;ssl.SSLContext&quot;</span><span class="s1">] = ssl_context</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ssl_context = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">log(self</span><span class="s2">, </span><span class="s1">type: str</span><span class="s2">, </span><span class="s1">message: str</span><span class="s2">, </span><span class="s1">*args: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">_log(type</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">serve_forever(self</span><span class="s2">, </span><span class="s1">poll_interval: float = </span><span class="s5">0.5</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.shutdown_signal = </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">super().serve_forever(poll_interval=poll_interval)</span>
        <span class="s2">except </span><span class="s1">KeyboardInterrupt:</span>
            <span class="s2">pass</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.server_close()</span>

    <span class="s2">def </span><span class="s1">handle_error(self</span><span class="s2">, </span><span class="s1">request: t.Any</span><span class="s2">, </span><span class="s1">client_address: t.Tuple[str</span><span class="s2">, </span><span class="s1">int]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.passthrough_errors:</span>
            <span class="s2">raise</span>

        <span class="s2">return </span><span class="s1">super().handle_error(request</span><span class="s2">, </span><span class="s1">client_address)</span>


<span class="s2">class </span><span class="s1">ThreadedWSGIServer(socketserver.ThreadingMixIn</span><span class="s2">, </span><span class="s1">BaseWSGIServer):</span>

    <span class="s0">&quot;&quot;&quot;A WSGI server that does threading.&quot;&quot;&quot;</span>

    <span class="s1">multithread = </span><span class="s2">True</span>
    <span class="s1">daemon_threads = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">ForkingWSGIServer(ForkingMixIn</span><span class="s2">, </span><span class="s1">BaseWSGIServer):</span>

    <span class="s0">&quot;&quot;&quot;A WSGI server that does forking.&quot;&quot;&quot;</span>

    <span class="s1">multiprocess = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">host: str</span><span class="s2">,</span>
        <span class="s1">port: int</span><span class="s2">,</span>
        <span class="s1">app: </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s2">,</span>
        <span class="s1">processes: int = </span><span class="s5">40</span><span class="s2">,</span>
        <span class="s1">handler: t.Optional[t.Type[WSGIRequestHandler]] = </span><span class="s2">None,</span>
        <span class="s1">passthrough_errors: bool = </span><span class="s2">False,</span>
        <span class="s1">ssl_context: t.Optional[_TSSLContextArg] = </span><span class="s2">None,</span>
        <span class="s1">fd: t.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">can_fork:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Your platform does not support forking.&quot;</span><span class="s1">)</span>
        <span class="s1">BaseWSGIServer.__init__(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">app</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">passthrough_errors</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">, </span><span class="s1">fd</span>
        <span class="s1">)</span>
        <span class="s1">self.max_children = processes</span>


<span class="s2">def </span><span class="s1">make_server(</span>
    <span class="s1">host: str</span><span class="s2">,</span>
    <span class="s1">port: int</span><span class="s2">,</span>
    <span class="s1">app: </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s2">,</span>
    <span class="s1">threaded: bool = </span><span class="s2">False,</span>
    <span class="s1">processes: int = </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s1">request_handler: t.Optional[t.Type[WSGIRequestHandler]] = </span><span class="s2">None,</span>
    <span class="s1">passthrough_errors: bool = </span><span class="s2">False,</span>
    <span class="s1">ssl_context: t.Optional[_TSSLContextArg] = </span><span class="s2">None,</span>
    <span class="s1">fd: t.Optional[int] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; BaseWSGIServer:</span>
    <span class="s0">&quot;&quot;&quot;Create a new server instance that is either threaded, or forks 
    or just processes one request after another. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">threaded </span><span class="s2">and </span><span class="s1">processes &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot have a multithreaded and multi process server.&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">threaded:</span>
        <span class="s2">return </span><span class="s1">ThreadedWSGIServer(</span>
            <span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">app</span><span class="s2">, </span><span class="s1">request_handler</span><span class="s2">, </span><span class="s1">passthrough_errors</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">, </span><span class="s1">fd=fd</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">processes &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">ForkingWSGIServer(</span>
            <span class="s1">host</span><span class="s2">,</span>
            <span class="s1">port</span><span class="s2">,</span>
            <span class="s1">app</span><span class="s2">,</span>
            <span class="s1">processes</span><span class="s2">,</span>
            <span class="s1">request_handler</span><span class="s2">,</span>
            <span class="s1">passthrough_errors</span><span class="s2">,</span>
            <span class="s1">ssl_context</span><span class="s2">,</span>
            <span class="s1">fd=fd</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">BaseWSGIServer(</span>
            <span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">app</span><span class="s2">, </span><span class="s1">request_handler</span><span class="s2">, </span><span class="s1">passthrough_errors</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">, </span><span class="s1">fd=fd</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">is_running_from_reloader() -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;Checks if the application is running from within the Werkzeug 
    reloader subprocess. 
 
    .. versionadded:: 0.10 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">os.environ.get(</span><span class="s3">&quot;WERKZEUG_RUN_MAIN&quot;</span><span class="s1">) == </span><span class="s3">&quot;true&quot;</span>


<span class="s2">def </span><span class="s1">run_simple(</span>
    <span class="s1">hostname: str</span><span class="s2">,</span>
    <span class="s1">port: int</span><span class="s2">,</span>
    <span class="s1">application: </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s2">,</span>
    <span class="s1">use_reloader: bool = </span><span class="s2">False,</span>
    <span class="s1">use_debugger: bool = </span><span class="s2">False,</span>
    <span class="s1">use_evalex: bool = </span><span class="s2">True,</span>
    <span class="s1">extra_files: t.Optional[t.Iterable[str]] = </span><span class="s2">None,</span>
    <span class="s1">exclude_patterns: t.Optional[t.Iterable[str]] = </span><span class="s2">None,</span>
    <span class="s1">reloader_interval: int = </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s1">reloader_type: str = </span><span class="s3">&quot;auto&quot;</span><span class="s2">,</span>
    <span class="s1">threaded: bool = </span><span class="s2">False,</span>
    <span class="s1">processes: int = </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s1">request_handler: t.Optional[t.Type[WSGIRequestHandler]] = </span><span class="s2">None,</span>
    <span class="s1">static_files: t.Optional[t.Dict[str</span><span class="s2">, </span><span class="s1">t.Union[str</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]]] = </span><span class="s2">None,</span>
    <span class="s1">passthrough_errors: bool = </span><span class="s2">False,</span>
    <span class="s1">ssl_context: t.Optional[_TSSLContextArg] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Start a WSGI application. Optional features include a reloader, 
    multithreading and fork support. 
 
    This function has a command-line interface too:: 
 
        python -m werkzeug.serving --help 
 
    .. versionchanged:: 2.0 
        Added ``exclude_patterns`` parameter. 
 
    .. versionadded:: 0.5 
       `static_files` was added to simplify serving of static files as well 
       as `passthrough_errors`. 
 
    .. versionadded:: 0.6 
       support for SSL was added. 
 
    .. versionadded:: 0.8 
       Added support for automatically loading a SSL context from certificate 
       file and private key. 
 
    .. versionadded:: 0.9 
       Added command-line interface. 
 
    .. versionadded:: 0.10 
       Improved the reloader and added support for changing the backend 
       through the `reloader_type` parameter.  See :ref:`reloader` 
       for more information. 
 
    .. versionchanged:: 0.15 
        Bind to a Unix socket by passing a path that starts with 
        ``unix://`` as the ``hostname``. 
 
    :param hostname: The host to bind to, for example ``'localhost'``. 
        If the value is a path that starts with ``unix://`` it will bind 
        to a Unix socket instead of a TCP socket.. 
    :param port: The port for the server.  eg: ``8080`` 
    :param application: the WSGI application to execute 
    :param use_reloader: should the server automatically restart the python 
                         process if modules were changed? 
    :param use_debugger: should the werkzeug debugging system be used? 
    :param use_evalex: should the exception evaluation feature be enabled? 
    :param extra_files: a list of files the reloader should watch 
                        additionally to the modules.  For example configuration 
                        files. 
    :param exclude_patterns: List of :mod:`fnmatch` patterns to ignore 
        when running the reloader. For example, ignore cache files that 
        shouldn't reload when updated. 
    :param reloader_interval: the interval for the reloader in seconds. 
    :param reloader_type: the type of reloader to use.  The default is 
                          auto detection.  Valid values are ``'stat'`` and 
                          ``'watchdog'``. See :ref:`reloader` for more 
                          information. 
    :param threaded: should the process handle each request in a separate 
                     thread? 
    :param processes: if greater than 1 then handle each request in a new process 
                      up to this maximum number of concurrent processes. 
    :param request_handler: optional parameter that can be used to replace 
                            the default one.  You can use this to replace it 
                            with a different 
                            :class:`~BaseHTTPServer.BaseHTTPRequestHandler` 
                            subclass. 
    :param static_files: a list or dict of paths for static files.  This works 
                         exactly like :class:`SharedDataMiddleware`, it's actually 
                         just wrapping the application in that middleware before 
                         serving. 
    :param passthrough_errors: set this to `True` to disable the error catching. 
                               This means that the server will die on errors but 
                               it can be useful to hook debuggers in (pdb etc.) 
    :param ssl_context: an SSL context for the connection. Either an 
                        :class:`ssl.SSLContext`, a tuple in the form 
                        ``(cert_file, pkey_file)``, the string ``'adhoc'`` if 
                        the server should automatically create one, or ``None`` 
                        to disable SSL (which is the default). 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(port</span><span class="s2">, </span><span class="s1">int):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;port must be an integer&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">use_debugger:</span>
        <span class="s2">from </span><span class="s1">.debug </span><span class="s2">import </span><span class="s1">DebuggedApplication</span>

        <span class="s1">application = DebuggedApplication(application</span><span class="s2">, </span><span class="s1">use_evalex)</span>
    <span class="s2">if </span><span class="s1">static_files:</span>
        <span class="s2">from </span><span class="s1">.middleware.shared_data </span><span class="s2">import </span><span class="s1">SharedDataMiddleware</span>

        <span class="s1">application = SharedDataMiddleware(application</span><span class="s2">, </span><span class="s1">static_files)</span>

    <span class="s2">def </span><span class="s1">log_startup(sock: socket.socket) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">all_addresses_message = (</span>
            <span class="s3">&quot; * Running on all addresses.</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;   WARNING: This is a development server. Do not use it in&quot;</span>
            <span class="s3">&quot; a production deployment.&quot;</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">sock.family == af_unix:</span>
            <span class="s1">_log(</span><span class="s3">&quot;info&quot;</span><span class="s2">, </span><span class="s3">&quot; * Running on %s (Press CTRL+C to quit)&quot;</span><span class="s2">, </span><span class="s1">hostname)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hostname == </span><span class="s3">&quot;0.0.0.0&quot;</span><span class="s1">:</span>
                <span class="s1">_log(</span><span class="s3">&quot;warning&quot;</span><span class="s2">, </span><span class="s1">all_addresses_message)</span>
                <span class="s1">display_hostname = get_interface_ip(socket.AF_INET)</span>
            <span class="s2">elif </span><span class="s1">hostname == </span><span class="s3">&quot;::&quot;</span><span class="s1">:</span>
                <span class="s1">_log(</span><span class="s3">&quot;warning&quot;</span><span class="s2">, </span><span class="s1">all_addresses_message)</span>
                <span class="s1">display_hostname = get_interface_ip(socket.AF_INET6)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">display_hostname = hostname</span>

            <span class="s2">if </span><span class="s3">&quot;:&quot; </span><span class="s2">in </span><span class="s1">display_hostname:</span>
                <span class="s1">display_hostname = </span><span class="s3">f&quot;[</span><span class="s2">{</span><span class="s1">display_hostname</span><span class="s2">}</span><span class="s3">]&quot;</span>

            <span class="s1">_log(</span>
                <span class="s3">&quot;info&quot;</span><span class="s2">,</span>
                <span class="s3">&quot; * Running on %s://%s:%d/ (Press CTRL+C to quit)&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;http&quot; </span><span class="s2">if </span><span class="s1">ssl_context </span><span class="s2">is None else </span><span class="s3">&quot;https&quot;</span><span class="s2">,</span>
                <span class="s1">display_hostname</span><span class="s2">,</span>
                <span class="s1">sock.getsockname()[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">inner() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fd: t.Optional[int] = int(os.environ[</span><span class="s3">&quot;WERKZEUG_SERVER_FD&quot;</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">(LookupError</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s1">fd = </span><span class="s2">None</span>
        <span class="s1">srv = make_server(</span>
            <span class="s1">hostname</span><span class="s2">,</span>
            <span class="s1">port</span><span class="s2">,</span>
            <span class="s1">application</span><span class="s2">,</span>
            <span class="s1">threaded</span><span class="s2">,</span>
            <span class="s1">processes</span><span class="s2">,</span>
            <span class="s1">request_handler</span><span class="s2">,</span>
            <span class="s1">passthrough_errors</span><span class="s2">,</span>
            <span class="s1">ssl_context</span><span class="s2">,</span>
            <span class="s1">fd=fd</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fd </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">log_startup(srv.socket)</span>
        <span class="s1">srv.serve_forever()</span>

    <span class="s2">if </span><span class="s1">use_reloader:</span>
        <span class="s4"># If we're not running already in the subprocess that is the</span>
        <span class="s4"># reloader we want to open up a socket early to make sure the</span>
        <span class="s4"># port is actually available.</span>
        <span class="s2">if not </span><span class="s1">is_running_from_reloader():</span>
            <span class="s2">if </span><span class="s1">port == </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">can_open_by_fd:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Cannot bind to a random port with enabled &quot;</span>
                    <span class="s3">&quot;reloader if the Python interpreter does &quot;</span>
                    <span class="s3">&quot;not support socket opening by fd.&quot;</span>
                <span class="s1">)</span>

            <span class="s4"># Create and destroy a socket so that any exceptions are</span>
            <span class="s4"># raised before we spawn a separate Python interpreter and</span>
            <span class="s4"># lose this ability.</span>
            <span class="s1">address_family = select_address_family(hostname</span><span class="s2">, </span><span class="s1">port)</span>
            <span class="s1">server_address = get_sockaddr(hostname</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">address_family)</span>
            <span class="s1">s = socket.socket(address_family</span><span class="s2">, </span><span class="s1">socket.SOCK_STREAM)</span>
            <span class="s1">s.setsockopt(socket.SOL_SOCKET</span><span class="s2">, </span><span class="s1">socket.SO_REUSEADDR</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">s.bind(server_address)</span>
            <span class="s1">s.set_inheritable(</span><span class="s2">True</span><span class="s1">)</span>

            <span class="s4"># If we can open the socket by file descriptor, then we can just</span>
            <span class="s4"># reuse this one and our socket will survive the restarts.</span>
            <span class="s2">if </span><span class="s1">can_open_by_fd:</span>
                <span class="s1">os.environ[</span><span class="s3">&quot;WERKZEUG_SERVER_FD&quot;</span><span class="s1">] = str(s.fileno())</span>
                <span class="s1">s.listen(LISTEN_QUEUE)</span>
                <span class="s1">log_startup(s)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s.close()</span>
                <span class="s2">if </span><span class="s1">address_family == af_unix:</span>
                    <span class="s1">server_address = t.cast(str</span><span class="s2">, </span><span class="s1">server_address)</span>
                    <span class="s1">_log(</span><span class="s3">&quot;info&quot;</span><span class="s2">, </span><span class="s3">&quot;Unlinking %s&quot;</span><span class="s2">, </span><span class="s1">server_address)</span>
                    <span class="s1">os.unlink(server_address)</span>

        <span class="s2">from </span><span class="s1">._reloader </span><span class="s2">import </span><span class="s1">run_with_reloader </span><span class="s2">as </span><span class="s1">_rwr</span>

        <span class="s1">_rwr(</span>
            <span class="s1">inner</span><span class="s2">,</span>
            <span class="s1">extra_files=extra_files</span><span class="s2">,</span>
            <span class="s1">exclude_patterns=exclude_patterns</span><span class="s2">,</span>
            <span class="s1">interval=reloader_interval</span><span class="s2">,</span>
            <span class="s1">reloader_type=reloader_type</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">inner()</span>


<span class="s2">def </span><span class="s1">run_with_reloader(*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Run a process with the reloader. This is not a public API, do 
    not use this function. 
 
    .. deprecated:: 2.0 
        Will be removed in Werkzeug 2.1. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">._reloader </span><span class="s2">import </span><span class="s1">run_with_reloader </span><span class="s2">as </span><span class="s1">_rwr</span>

    <span class="s1">warnings.warn(</span>
        <span class="s1">(</span>
            <span class="s3">&quot;'run_with_reloader' is a private API, it will no longer be&quot;</span>
            <span class="s3">&quot; accessible in Werkzeug 2.1. Use 'run_simple' instead.&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">_rwr(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">main() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;A simple command-line interface for :py:func:`run_simple`.&quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">argparse</span>
    <span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">import_string</span>

    <span class="s1">_log(</span><span class="s3">&quot;warning&quot;</span><span class="s2">, </span><span class="s3">&quot;This CLI is deprecated and will be removed in version 2.1.&quot;</span><span class="s1">)</span>

    <span class="s1">parser = argparse.ArgumentParser(</span>
        <span class="s1">description=</span><span class="s3">&quot;Run the given WSGI application with the development server.&quot;</span><span class="s2">,</span>
        <span class="s1">allow_abbrev=</span><span class="s2">False,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;-b&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;--bind&quot;</span><span class="s2">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;address&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;The hostname:port the app should listen on.&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;-d&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;--debug&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Show the interactive debugger for unhandled exceptions.&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;-r&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;--reload&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Reload the process if modules change.&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;application&quot;</span><span class="s2">, </span><span class="s1">help=</span><span class="s3">&quot;Application to import and serve, in the form module:app.&quot;</span>
    <span class="s1">)</span>
    <span class="s1">args = parser.parse_args()</span>
    <span class="s1">hostname</span><span class="s2">, </span><span class="s1">port = </span><span class="s2">None, None</span>

    <span class="s2">if </span><span class="s1">args.address:</span>
        <span class="s1">hostname</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">port = args.address.partition(</span><span class="s3">&quot;:&quot;</span><span class="s1">)</span>

    <span class="s1">run_simple(</span>
        <span class="s1">hostname=hostname </span><span class="s2">or </span><span class="s3">&quot;127.0.0.1&quot;</span><span class="s2">,</span>
        <span class="s1">port=int(port </span><span class="s2">or </span><span class="s5">5000</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">application=import_string(args.application)</span><span class="s2">,</span>
        <span class="s1">use_reloader=args.reload</span><span class="s2">,</span>
        <span class="s1">use_debugger=args.debug</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">main()</span>
</pre>
</body>
</html>