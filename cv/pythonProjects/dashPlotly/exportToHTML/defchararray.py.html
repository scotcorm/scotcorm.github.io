<html>
<head>
<title>defchararray.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
defchararray.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This module contains a set of functions for vectorized string 
operations and methods. 
 
.. note:: 
   The `chararray` class exists for backwards compatibility with 
   Numarray, it is not recommended for new development. Starting from numpy 
   1.4, if one needs arrays of strings, it is recommended to use arrays of 
   `dtype` `object_`, `string_` or `unicode_`, and use the free functions 
   in the `numpy.char` module for fast vectorized string operations. 
 
Some methods will only be available if the corresponding string method is 
available in your version of Python. 
 
The preferred alias for `defchararray` is `numpy.char`. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">.numerictypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">string_</span><span class="s2">, </span><span class="s1">unicode_</span><span class="s2">, </span><span class="s1">integer</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s1">character)</span>
<span class="s2">from </span><span class="s1">.numeric </span><span class="s2">import </span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">compare_chararrays</span>
<span class="s2">from </span><span class="s1">.numeric </span><span class="s2">import </span><span class="s1">array </span><span class="s2">as </span><span class="s1">narray</span>
<span class="s2">from </span><span class="s1">numpy.core.multiarray </span><span class="s2">import </span><span class="s1">_vec_string</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">set_module</span>
<span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">overrides</span>
<span class="s2">from </span><span class="s1">numpy.compat </span><span class="s2">import </span><span class="s1">asbytes</span>
<span class="s2">import </span><span class="s1">numpy</span>

<span class="s1">__all__ = [</span>
    <span class="s3">'equal'</span><span class="s2">, </span><span class="s3">'not_equal'</span><span class="s2">, </span><span class="s3">'greater_equal'</span><span class="s2">, </span><span class="s3">'less_equal'</span><span class="s2">,</span>
    <span class="s3">'greater'</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s3">'str_len'</span><span class="s2">, </span><span class="s3">'add'</span><span class="s2">, </span><span class="s3">'multiply'</span><span class="s2">, </span><span class="s3">'mod'</span><span class="s2">, </span><span class="s3">'capitalize'</span><span class="s2">,</span>
    <span class="s3">'center'</span><span class="s2">, </span><span class="s3">'count'</span><span class="s2">, </span><span class="s3">'decode'</span><span class="s2">, </span><span class="s3">'encode'</span><span class="s2">, </span><span class="s3">'endswith'</span><span class="s2">, </span><span class="s3">'expandtabs'</span><span class="s2">,</span>
    <span class="s3">'find'</span><span class="s2">, </span><span class="s3">'index'</span><span class="s2">, </span><span class="s3">'isalnum'</span><span class="s2">, </span><span class="s3">'isalpha'</span><span class="s2">, </span><span class="s3">'isdigit'</span><span class="s2">, </span><span class="s3">'islower'</span><span class="s2">, </span><span class="s3">'isspace'</span><span class="s2">,</span>
    <span class="s3">'istitle'</span><span class="s2">, </span><span class="s3">'isupper'</span><span class="s2">, </span><span class="s3">'join'</span><span class="s2">, </span><span class="s3">'ljust'</span><span class="s2">, </span><span class="s3">'lower'</span><span class="s2">, </span><span class="s3">'lstrip'</span><span class="s2">, </span><span class="s3">'partition'</span><span class="s2">,</span>
    <span class="s3">'replace'</span><span class="s2">, </span><span class="s3">'rfind'</span><span class="s2">, </span><span class="s3">'rindex'</span><span class="s2">, </span><span class="s3">'rjust'</span><span class="s2">, </span><span class="s3">'rpartition'</span><span class="s2">, </span><span class="s3">'rsplit'</span><span class="s2">,</span>
    <span class="s3">'rstrip'</span><span class="s2">, </span><span class="s3">'split'</span><span class="s2">, </span><span class="s3">'splitlines'</span><span class="s2">, </span><span class="s3">'startswith'</span><span class="s2">, </span><span class="s3">'strip'</span><span class="s2">, </span><span class="s3">'swapcase'</span><span class="s2">,</span>
    <span class="s3">'title'</span><span class="s2">, </span><span class="s3">'translate'</span><span class="s2">, </span><span class="s3">'upper'</span><span class="s2">, </span><span class="s3">'zfill'</span><span class="s2">, </span><span class="s3">'isnumeric'</span><span class="s2">, </span><span class="s3">'isdecimal'</span><span class="s2">,</span>
    <span class="s3">'array'</span><span class="s2">, </span><span class="s3">'asarray'</span>
    <span class="s1">]</span>


<span class="s1">_globalvar = </span><span class="s4">0</span>

<span class="s1">array_function_dispatch = functools.partial(</span>
    <span class="s1">overrides.array_function_dispatch</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy.char'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_use_unicode(*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function for determining the output type of some string 
    operations. 
 
    For an operation on two ndarrays, if at least one is unicode, the 
    result should be unicode. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args:</span>
        <span class="s2">if </span><span class="s1">(isinstance(x</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or</span>
                <span class="s1">issubclass(numpy.asarray(x).dtype.type</span><span class="s2">, </span><span class="s1">unicode_)):</span>
            <span class="s2">return </span><span class="s1">unicode_</span>
    <span class="s2">return </span><span class="s1">string_</span>

<span class="s2">def </span><span class="s1">_to_string_or_unicode_array(result):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function to cast a result back into a string or unicode array 
    if an object array must be used as an intermediary. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">numpy.asarray(result.tolist())</span>

<span class="s2">def </span><span class="s1">_clean_args(*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function for delegating arguments to Python string 
    functions. 
 
    Many of the Python string operations that have optional arguments 
    do not use 'None' to indicate a default value.  In these cases, 
    we need to remove all None arguments, and those following them. 
    &quot;&quot;&quot;</span>
    <span class="s1">newargs = []</span>
    <span class="s2">for </span><span class="s1">chk </span><span class="s2">in </span><span class="s1">args:</span>
        <span class="s2">if </span><span class="s1">chk </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">break</span>
        <span class="s1">newargs.append(chk)</span>
    <span class="s2">return </span><span class="s1">newargs</span>

<span class="s2">def </span><span class="s1">_get_num_chars(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function that returns the number of characters per field in 
    a string or unicode array.  This is to abstract out the fact that 
    for a unicode array this is itemsize / 4. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">issubclass(a.dtype.type</span><span class="s2">, </span><span class="s1">unicode_):</span>
        <span class="s2">return </span><span class="s1">a.itemsize // </span><span class="s4">4</span>
    <span class="s2">return </span><span class="s1">a.itemsize</span>


<span class="s2">def </span><span class="s1">_binary_op_dispatcher(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s2">return </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">x2)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">equal(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 == x2) element-wise. 
 
    Unlike `numpy.equal`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    not_equal, greater_equal, less_equal, greater, less 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s3">'=='</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">not_equal(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 != x2) element-wise. 
 
    Unlike `numpy.not_equal`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, greater_equal, less_equal, greater, less 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s3">'!='</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">greater_equal(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &gt;= x2) element-wise. 
 
    Unlike `numpy.greater_equal`, this comparison is performed by 
    first stripping whitespace characters from the end of the string. 
    This behavior is provided for backward-compatibility with 
    numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, less_equal, greater, less 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s3">'&gt;='</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">less_equal(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &lt;= x2) element-wise. 
 
    Unlike `numpy.less_equal`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, greater_equal, greater, less 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s3">'&lt;='</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">greater(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &gt; x2) element-wise. 
 
    Unlike `numpy.greater`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, greater_equal, less_equal, less 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s3">'&gt;'</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">less(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &lt; x2) element-wise. 
 
    Unlike `numpy.greater`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, greater_equal, less_equal, greater 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s3">'&lt;'</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_unary_op_dispatcher(a):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">str_len(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return len(a) element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of integers 
 
    See Also 
    -------- 
    builtins.len 
    &quot;&quot;&quot;</span>
    <span class="s5"># Note: __len__, etc. currently return ints, which are not C-integers.</span>
    <span class="s5"># Generally intp would be expected for lengths, although int is sufficient</span>
    <span class="s5"># due to the dtype itemsize limitation.</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s3">'__len__'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_binary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">add(x1</span><span class="s2">, </span><span class="s1">x2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return element-wise string concatenation for two arrays of str or unicode. 
 
    Arrays `x1` and `x2` must have the same shape. 
 
    Parameters 
    ---------- 
    x1 : array_like of str or unicode 
        Input array. 
    x2 : array_like of str or unicode 
        Input array. 
 
    Returns 
    ------- 
    add : ndarray 
        Output array of `string_` or `unicode_`, depending on input types 
        of the same shape as `x1` and `x2`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arr1 = numpy.asarray(x1)</span>
    <span class="s1">arr2 = numpy.asarray(x2)</span>
    <span class="s1">out_size = _get_num_chars(arr1) + _get_num_chars(arr2)</span>
    <span class="s1">dtype = _use_unicode(arr1</span><span class="s2">, </span><span class="s1">arr2)</span>
    <span class="s2">return </span><span class="s1">_vec_string(arr1</span><span class="s2">, </span><span class="s1">(dtype</span><span class="s2">, </span><span class="s1">out_size)</span><span class="s2">, </span><span class="s3">'__add__'</span><span class="s2">, </span><span class="s1">(arr2</span><span class="s2">,</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_multiply_dispatcher(a</span><span class="s2">, </span><span class="s1">i):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_multiply_dispatcher)</span>
<span class="s2">def </span><span class="s1">multiply(a</span><span class="s2">, </span><span class="s1">i):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (a * i), that is string multiple concatenation, 
    element-wise. 
 
    Values in `i` of less than 0 are treated as 0 (which yields an 
    empty string). 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    i : array_like of ints 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input types 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s1">i_arr = numpy.asarray(i)</span>
    <span class="s2">if not </span><span class="s1">issubclass(i_arr.dtype.type</span><span class="s2">, </span><span class="s1">integer):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Can only multiply by integers&quot;</span><span class="s1">)</span>
    <span class="s1">out_size = _get_num_chars(a_arr) * max(int(i_arr.max())</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">(a_arr.dtype.type</span><span class="s2">, </span><span class="s1">out_size)</span><span class="s2">, </span><span class="s3">'__mul__'</span><span class="s2">, </span><span class="s1">(i_arr</span><span class="s2">,</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_mod_dispatcher(a</span><span class="s2">, </span><span class="s1">values):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">values)</span>


<span class="s1">@array_function_dispatch(_mod_dispatcher)</span>
<span class="s2">def </span><span class="s1">mod(a</span><span class="s2">, </span><span class="s1">values):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (a % i), that is pre-Python 2.6 string formatting 
    (interpolation), element-wise for a pair of array_likes of str 
    or unicode. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    values : array_like of values 
       These values will be element-wise interpolated into the string. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input types 
 
    See Also 
    -------- 
    str.__mod__ 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'__mod__'</span><span class="s2">, </span><span class="s1">(values</span><span class="s2">,</span><span class="s1">)))</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">capitalize(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a copy of `a` with only the first character of each element 
    capitalized. 
 
    Calls `str.capitalize` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
        Input array of strings to capitalize. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input 
        types 
 
    See Also 
    -------- 
    str.capitalize 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c 
    array(['a1b2', '1b2a', 'b2a1', '2a1b'], 
        dtype='|S4') 
    &gt;&gt;&gt; np.char.capitalize(c) 
    array(['A1b2', '1b2a', 'B2a1', '2a1b'], 
        dtype='|S4') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'capitalize'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_center_dispatcher(a</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_center_dispatcher)</span>
<span class="s2">def </span><span class="s1">center(a</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">' '</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a copy of `a` with its elements centered in a string of 
    length `width`. 
 
    Calls `str.center` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    width : int 
        The length of the resulting strings 
    fillchar : str or unicode, optional 
        The padding character to use (default is space). 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input 
        types 
 
    See Also 
    -------- 
    str.center 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s1">width_arr = numpy.asarray(width)</span>
    <span class="s1">size = int(numpy.max(width_arr.flat))</span>
    <span class="s2">if </span><span class="s1">numpy.issubdtype(a_arr.dtype</span><span class="s2">, </span><span class="s1">numpy.string_):</span>
        <span class="s1">fillchar = asbytes(fillchar)</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">(a_arr.dtype.type</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">, </span><span class="s3">'center'</span><span class="s2">, </span><span class="s1">(width_arr</span><span class="s2">, </span><span class="s1">fillchar))</span>


<span class="s2">def </span><span class="s1">_count_dispatcher(a</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_count_dispatcher)</span>
<span class="s2">def </span><span class="s1">count(a</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an array with the number of non-overlapping occurrences of 
    substring `sub` in the range [`start`, `end`]. 
 
    Calls `str.count` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    sub : str or unicode 
       The substring to search for. 
 
    start, end : int, optional 
       Optional arguments `start` and `end` are interpreted as slice 
       notation to specify the range in which to count. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ints. 
 
    See Also 
    -------- 
    str.count 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.char.count(c, 'A') 
    array([3, 1, 1]) 
    &gt;&gt;&gt; np.char.count(c, 'aA') 
    array([3, 1, 0]) 
    &gt;&gt;&gt; np.char.count(c, 'A', start=1, end=4) 
    array([2, 1, 1]) 
    &gt;&gt;&gt; np.char.count(c, 'A', start=1, end=3) 
    array([1, 0, 0]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s3">'count'</span><span class="s2">, </span><span class="s1">[sub</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s2">def </span><span class="s1">_code_dispatcher(a</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">errors=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_code_dispatcher)</span>
<span class="s2">def </span><span class="s1">decode(a</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">errors=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calls `str.decode` element-wise. 
 
    The set of available codecs comes from the Python standard library, 
    and may be extended at runtime.  For more information, see the 
    :mod:`codecs` module. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    encoding : str, optional 
       The name of an encoding 
 
    errors : str, optional 
       Specifies how to handle encoding errors 
 
    Returns 
    ------- 
    out : ndarray 
 
    See Also 
    -------- 
    str.decode 
 
    Notes 
    ----- 
    The type of the result will depend on the encoding specified. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.char.encode(c, encoding='cp037') 
    array(['\\x81\\xc1\\x81\\xc1\\x81\\xc1', '@@\\x81\\xc1@@', 
        '\\x81\\x82\\xc2\\xc1\\xc2\\x82\\x81'], 
        dtype='|S7') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'decode'</span><span class="s2">, </span><span class="s1">_clean_args(encoding</span><span class="s2">, </span><span class="s1">errors)))</span>


<span class="s1">@array_function_dispatch(_code_dispatcher)</span>
<span class="s2">def </span><span class="s1">encode(a</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">errors=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calls `str.encode` element-wise. 
 
    The set of available codecs comes from the Python standard library, 
    and may be extended at runtime. For more information, see the codecs 
    module. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    encoding : str, optional 
       The name of an encoding 
 
    errors : str, optional 
       Specifies how to handle encoding errors 
 
    Returns 
    ------- 
    out : ndarray 
 
    See Also 
    -------- 
    str.encode 
 
    Notes 
    ----- 
    The type of the result will depend on the encoding specified. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'encode'</span><span class="s2">, </span><span class="s1">_clean_args(encoding</span><span class="s2">, </span><span class="s1">errors)))</span>


<span class="s2">def </span><span class="s1">_endswith_dispatcher(a</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_endswith_dispatcher)</span>
<span class="s2">def </span><span class="s1">endswith(a</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a boolean array which is `True` where the string element 
    in `a` ends with `suffix`, otherwise `False`. 
 
    Calls `str.endswith` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    suffix : str 
 
    start, end : int, optional 
        With optional `start`, test beginning at that position. With 
        optional `end`, stop comparing at that position. 
 
    Returns 
    ------- 
    out : ndarray 
        Outputs an array of bools. 
 
    See Also 
    -------- 
    str.endswith 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = np.array(['foo', 'bar']) 
    &gt;&gt;&gt; s[0] = 'foo' 
    &gt;&gt;&gt; s[1] = 'bar' 
    &gt;&gt;&gt; s 
    array(['foo', 'bar'], dtype='&lt;U3') 
    &gt;&gt;&gt; np.char.endswith(s, 'ar') 
    array([False,  True]) 
    &gt;&gt;&gt; np.char.endswith(s, 'a', start=1, end=2) 
    array([False,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'endswith'</span><span class="s2">, </span><span class="s1">[suffix</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s2">def </span><span class="s1">_expandtabs_dispatcher(a</span><span class="s2">, </span><span class="s1">tabsize=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_expandtabs_dispatcher)</span>
<span class="s2">def </span><span class="s1">expandtabs(a</span><span class="s2">, </span><span class="s1">tabsize=</span><span class="s4">8</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a copy of each string element where all tab characters are 
    replaced by one or more spaces. 
 
    Calls `str.expandtabs` element-wise. 
 
    Return a copy of each string element where all tab characters are 
    replaced by one or more spaces, depending on the current column 
    and the given `tabsize`. The column number is reset to zero after 
    each newline occurring in the string. This doesn't understand other 
    non-printing characters or escape sequences. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
        Input array 
    tabsize : int, optional 
        Replace tabs with `tabsize` number of spaces.  If not given defaults 
        to 8 spaces. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.expandtabs 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'expandtabs'</span><span class="s2">, </span><span class="s1">(tabsize</span><span class="s2">,</span><span class="s1">)))</span>


<span class="s1">@array_function_dispatch(_count_dispatcher)</span>
<span class="s2">def </span><span class="s1">find(a</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element, return the lowest index in the string where 
    substring `sub` is found. 
 
    Calls `str.find` element-wise. 
 
    For each element, return the lowest index in the string where 
    substring `sub` is found, such that `sub` is contained in the 
    range [`start`, `end`]. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    sub : str or unicode 
 
    start, end : int, optional 
        Optional arguments `start` and `end` are interpreted as in 
        slice notation. 
 
    Returns 
    ------- 
    out : ndarray or int 
        Output array of ints.  Returns -1 if `sub` is not found. 
 
    See Also 
    -------- 
    str.find 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s3">'find'</span><span class="s2">, </span><span class="s1">[sub</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s1">@array_function_dispatch(_count_dispatcher)</span>
<span class="s2">def </span><span class="s1">index(a</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like `find`, but raises `ValueError` when the substring is not found. 
 
    Calls `str.index` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    sub : str or unicode 
 
    start, end : int, optional 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ints.  Returns -1 if `sub` is not found. 
 
    See Also 
    -------- 
    find, str.find 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s3">'index'</span><span class="s2">, </span><span class="s1">[sub</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isalnum(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if all characters in the string are 
    alphanumeric and there is at least one character, false otherwise. 
 
    Calls `str.isalnum` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.isalnum 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isalnum'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isalpha(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if all characters in the string are 
    alphabetic and there is at least one character, false otherwise. 
 
    Calls `str.isalpha` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.isalpha 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isalpha'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isdigit(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if all characters in the string are 
    digits and there is at least one character, false otherwise. 
 
    Calls `str.isdigit` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.isdigit 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isdigit'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">islower(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if all cased characters in the 
    string are lowercase and there is at least one cased character, 
    false otherwise. 
 
    Calls `str.islower` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.islower 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'islower'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isspace(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if there are only whitespace 
    characters in the string and there is at least one character, 
    false otherwise. 
 
    Calls `str.isspace` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.isspace 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isspace'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">istitle(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if the element is a titlecased 
    string and there is at least one character, false otherwise. 
 
    Call `str.istitle` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.istitle 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'istitle'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isupper(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns true for each element if all cased characters in the 
    string are uppercase and there is at least one character, false 
    otherwise. 
 
    Call `str.isupper` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.isupper 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isupper'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_join_dispatcher(sep</span><span class="s2">, </span><span class="s1">seq):</span>
    <span class="s2">return </span><span class="s1">(sep</span><span class="s2">, </span><span class="s1">seq)</span>


<span class="s1">@array_function_dispatch(_join_dispatcher)</span>
<span class="s2">def </span><span class="s1">join(sep</span><span class="s2">, </span><span class="s1">seq):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string which is the concatenation of the strings in the 
    sequence `seq`. 
 
    Calls `str.join` element-wise. 
 
    Parameters 
    ---------- 
    sep : array_like of str or unicode 
    seq : array_like of str or unicode 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input types 
 
    See Also 
    -------- 
    str.join 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(sep</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'join'</span><span class="s2">, </span><span class="s1">(seq</span><span class="s2">,</span><span class="s1">)))</span>



<span class="s2">def </span><span class="s1">_just_dispatcher(a</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_just_dispatcher)</span>
<span class="s2">def </span><span class="s1">ljust(a</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">' '</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements of `a` left-justified in a 
    string of length `width`. 
 
    Calls `str.ljust` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    width : int 
        The length of the resulting strings 
    fillchar : str or unicode, optional 
        The character to use for padding 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.ljust 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s1">width_arr = numpy.asarray(width)</span>
    <span class="s1">size = int(numpy.max(width_arr.flat))</span>
    <span class="s2">if </span><span class="s1">numpy.issubdtype(a_arr.dtype</span><span class="s2">, </span><span class="s1">numpy.string_):</span>
        <span class="s1">fillchar = asbytes(fillchar)</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">(a_arr.dtype.type</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">, </span><span class="s3">'ljust'</span><span class="s2">, </span><span class="s1">(width_arr</span><span class="s2">, </span><span class="s1">fillchar))</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">lower(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements converted to lowercase. 
 
    Call `str.lower` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like, {str, unicode} 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray, {str, unicode} 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.lower 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['A1B C', '1BCA', 'BCA1']); c 
    array(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5') 
    &gt;&gt;&gt; np.char.lower(c) 
    array(['a1b c', '1bca', 'bca1'], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'lower'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_strip_dispatcher(a</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_strip_dispatcher)</span>
<span class="s2">def </span><span class="s1">lstrip(a</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy with the leading characters 
    removed. 
 
    Calls `str.lstrip` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like, {str, unicode} 
        Input array. 
 
    chars : {str, unicode}, optional 
        The `chars` argument is a string specifying the set of 
        characters to be removed. If omitted or None, the `chars` 
        argument defaults to removing whitespace. The `chars` argument 
        is not a prefix; rather, all combinations of its values are 
        stripped. 
 
    Returns 
    ------- 
    out : ndarray, {str, unicode} 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.lstrip 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
 
    The 'a' variable is unstripped from c[1] because whitespace leading. 
 
    &gt;&gt;&gt; np.char.lstrip(c, 'a') 
    array(['AaAaA', '  aA  ', 'bBABba'], dtype='&lt;U7') 
 
 
    &gt;&gt;&gt; np.char.lstrip(c, 'A') # leaves c unchanged 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; (np.char.lstrip(c, ' ') == np.char.lstrip(c, '')).all() 
    ... # XXX: is this a regression? This used to return True 
    ... # np.char.lstrip(c,'') does not modify c at all. 
    False 
    &gt;&gt;&gt; (np.char.lstrip(c, ' ') == np.char.lstrip(c, None)).all() 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'lstrip'</span><span class="s2">, </span><span class="s1">(chars</span><span class="s2">,</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_partition_dispatcher(a</span><span class="s2">, </span><span class="s1">sep):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_partition_dispatcher)</span>
<span class="s2">def </span><span class="s1">partition(a</span><span class="s2">, </span><span class="s1">sep):</span>
    <span class="s0">&quot;&quot;&quot; 
    Partition each element in `a` around `sep`. 
 
    Calls `str.partition` element-wise. 
 
    For each element in `a`, split the element as the first 
    occurrence of `sep`, and return 3 strings containing the part 
    before the separator, the separator itself, and the part after 
    the separator. If the separator is not found, return 3 strings 
    containing the string itself, followed by two empty strings. 
 
    Parameters 
    ---------- 
    a : array_like, {str, unicode} 
        Input array 
    sep : {str, unicode} 
        Separator to split each string element in `a`. 
 
    Returns 
    ------- 
    out : ndarray, {str, unicode} 
        Output array of str or unicode, depending on input type. 
        The output array will have an extra dimension with 3 
        elements per input element. 
 
    See Also 
    -------- 
    str.partition 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'partition'</span><span class="s2">, </span><span class="s1">(sep</span><span class="s2">,</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">_replace_dispatcher(a</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">count=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_replace_dispatcher)</span>
<span class="s2">def </span><span class="s1">replace(a</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">count=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy of the string with all 
    occurrences of substring `old` replaced by `new`. 
 
    Calls `str.replace` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like of str or unicode 
 
    old, new : str or unicode 
 
    count : int, optional 
        If the optional argument `count` is given, only the first 
        `count` occurrences are replaced. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.replace 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">, </span><span class="s1">[old</span><span class="s2">, </span><span class="s1">new] + _clean_args(count)))</span>


<span class="s1">@array_function_dispatch(_count_dispatcher)</span>
<span class="s2">def </span><span class="s1">rfind(a</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return the highest index in the string 
    where substring `sub` is found, such that `sub` is contained 
    within [`start`, `end`]. 
 
    Calls `str.rfind` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like of str or unicode 
 
    sub : str or unicode 
 
    start, end : int, optional 
        Optional arguments `start` and `end` are interpreted as in 
        slice notation. 
 
    Returns 
    ------- 
    out : ndarray 
       Output array of ints.  Return -1 on failure. 
 
    See Also 
    -------- 
    str.rfind 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s3">'rfind'</span><span class="s2">, </span><span class="s1">[sub</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s1">@array_function_dispatch(_count_dispatcher)</span>
<span class="s2">def </span><span class="s1">rindex(a</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like `rfind`, but raises `ValueError` when the substring `sub` is 
    not found. 
 
    Calls `str.rindex` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like of str or unicode 
 
    sub : str or unicode 
 
    start, end : int, optional 
 
    Returns 
    ------- 
    out : ndarray 
       Output array of ints. 
 
    See Also 
    -------- 
    rfind, str.rindex 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">int_</span><span class="s2">, </span><span class="s3">'rindex'</span><span class="s2">, </span><span class="s1">[sub</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s1">@array_function_dispatch(_just_dispatcher)</span>
<span class="s2">def </span><span class="s1">rjust(a</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">' '</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements of `a` right-justified in a 
    string of length `width`. 
 
    Calls `str.rjust` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    width : int 
        The length of the resulting strings 
    fillchar : str or unicode, optional 
        The character to use for padding 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.rjust 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s1">width_arr = numpy.asarray(width)</span>
    <span class="s1">size = int(numpy.max(width_arr.flat))</span>
    <span class="s2">if </span><span class="s1">numpy.issubdtype(a_arr.dtype</span><span class="s2">, </span><span class="s1">numpy.string_):</span>
        <span class="s1">fillchar = asbytes(fillchar)</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">(a_arr.dtype.type</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">, </span><span class="s3">'rjust'</span><span class="s2">, </span><span class="s1">(width_arr</span><span class="s2">, </span><span class="s1">fillchar))</span>


<span class="s1">@array_function_dispatch(_partition_dispatcher)</span>
<span class="s2">def </span><span class="s1">rpartition(a</span><span class="s2">, </span><span class="s1">sep):</span>
    <span class="s0">&quot;&quot;&quot; 
    Partition (split) each element around the right-most separator. 
 
    Calls `str.rpartition` element-wise. 
 
    For each element in `a`, split the element as the last 
    occurrence of `sep`, and return 3 strings containing the part 
    before the separator, the separator itself, and the part after 
    the separator. If the separator is not found, return 3 strings 
    containing the string itself, followed by two empty strings. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
        Input array 
    sep : str or unicode 
        Right-most separator to split each element in array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of string or unicode, depending on input 
        type.  The output array will have an extra dimension with 
        3 elements per input element. 
 
    See Also 
    -------- 
    str.rpartition 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_string_or_unicode_array(</span>
        <span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'rpartition'</span><span class="s2">, </span><span class="s1">(sep</span><span class="s2">,</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">_split_dispatcher(a</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_split_dispatcher)</span>
<span class="s2">def </span><span class="s1">rsplit(a</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a list of the words in the 
    string, using `sep` as the delimiter string. 
 
    Calls `str.rsplit` element-wise. 
 
    Except for splitting from the right, `rsplit` 
    behaves like `split`. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    sep : str or unicode, optional 
        If `sep` is not specified or None, any whitespace string 
        is a separator. 
    maxsplit : int, optional 
        If `maxsplit` is given, at most `maxsplit` splits are done, 
        the rightmost ones. 
 
    Returns 
    ------- 
    out : ndarray 
       Array of list objects 
 
    See Also 
    -------- 
    str.rsplit, split 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># This will return an array of lists of different sizes, so we</span>
    <span class="s5"># leave it as an object array</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'rsplit'</span><span class="s2">, </span><span class="s1">[sep] + _clean_args(maxsplit))</span>


<span class="s2">def </span><span class="s1">_strip_dispatcher(a</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_strip_dispatcher)</span>
<span class="s2">def </span><span class="s1">rstrip(a</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy with the trailing 
    characters removed. 
 
    Calls `str.rstrip` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like of str or unicode 
 
    chars : str or unicode, optional 
       The `chars` argument is a string specifying the set of 
       characters to be removed. If omitted or None, the `chars` 
       argument defaults to removing whitespace. The `chars` argument 
       is not a suffix; rather, all combinations of its values are 
       stripped. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.rstrip 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c 
    array(['aAaAaA', 'abBABba'], 
        dtype='|S7') 
    &gt;&gt;&gt; np.char.rstrip(c, b'a') 
    array(['aAaAaA', 'abBABb'], 
        dtype='|S7') 
    &gt;&gt;&gt; np.char.rstrip(c, b'A') 
    array(['aAaAa', 'abBABba'], 
        dtype='|S7') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'rstrip'</span><span class="s2">, </span><span class="s1">(chars</span><span class="s2">,</span><span class="s1">))</span>


<span class="s1">@array_function_dispatch(_split_dispatcher)</span>
<span class="s2">def </span><span class="s1">split(a</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a list of the words in the 
    string, using `sep` as the delimiter string. 
 
    Calls `str.split` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    sep : str or unicode, optional 
       If `sep` is not specified or None, any whitespace string is a 
       separator. 
 
    maxsplit : int, optional 
        If `maxsplit` is given, at most `maxsplit` splits are done. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of list objects 
 
    See Also 
    -------- 
    str.split, rsplit 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># This will return an array of lists of different sizes, so we</span>
    <span class="s5"># leave it as an object array</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'split'</span><span class="s2">, </span><span class="s1">[sep] + _clean_args(maxsplit))</span>


<span class="s2">def </span><span class="s1">_splitlines_dispatcher(a</span><span class="s2">, </span><span class="s1">keepends=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_splitlines_dispatcher)</span>
<span class="s2">def </span><span class="s1">splitlines(a</span><span class="s2">, </span><span class="s1">keepends=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a list of the lines in the 
    element, breaking at line boundaries. 
 
    Calls `str.splitlines` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    keepends : bool, optional 
        Line breaks are not included in the resulting list unless 
        keepends is given and true. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of list objects 
 
    See Also 
    -------- 
    str.splitlines 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">object_</span><span class="s2">, </span><span class="s3">'splitlines'</span><span class="s2">, </span><span class="s1">_clean_args(keepends))</span>


<span class="s2">def </span><span class="s1">_startswith_dispatcher(a</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_startswith_dispatcher)</span>
<span class="s2">def </span><span class="s1">startswith(a</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a boolean array which is `True` where the string element 
    in `a` starts with `prefix`, otherwise `False`. 
 
    Calls `str.startswith` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like of str or unicode 
 
    prefix : str 
 
    start, end : int, optional 
        With optional `start`, test beginning at that position. With 
        optional `end`, stop comparing at that position. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of booleans 
 
    See Also 
    -------- 
    str.startswith 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'startswith'</span><span class="s2">, </span><span class="s1">[prefix</span><span class="s2">, </span><span class="s1">start] + _clean_args(end))</span>


<span class="s1">@array_function_dispatch(_strip_dispatcher)</span>
<span class="s2">def </span><span class="s1">strip(a</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy with the leading and 
    trailing characters removed. 
 
    Calls `str.strip` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like of str or unicode 
 
    chars : str or unicode, optional 
       The `chars` argument is a string specifying the set of 
       characters to be removed. If omitted or None, the `chars` 
       argument defaults to removing whitespace. The `chars` argument 
       is not a prefix or suffix; rather, all combinations of its 
       values are stripped. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.strip 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.char.strip(c) 
    array(['aAaAaA', 'aA', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads 
    array(['AaAaA', '  aA  ', 'bBABb'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails 
    array(['aAaAa', '  aA  ', 'abBABba'], dtype='&lt;U7') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'strip'</span><span class="s2">, </span><span class="s1">_clean_args(chars))</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">swapcase(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return element-wise a copy of the string with 
    uppercase characters converted to lowercase and vice versa. 
 
    Calls `str.swapcase` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like, {str, unicode} 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray, {str, unicode} 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.swapcase 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c 
    array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'], 
        dtype='|S5') 
    &gt;&gt;&gt; np.char.swapcase(c) 
    array(['A1b C', '1B cA', 'B cA1', 'Ca1B'], 
        dtype='|S5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'swapcase'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">title(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return element-wise title cased version of string or unicode. 
 
    Title case words start with uppercase characters, all remaining cased 
    characters are lowercase. 
 
    Calls `str.title` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like, {str, unicode} 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.title 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c 
    array(['a1b c', '1b ca', 'b ca1', 'ca1b'], 
        dtype='|S5') 
    &gt;&gt;&gt; np.char.title(c) 
    array(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'], 
        dtype='|S5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'title'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_translate_dispatcher(a</span><span class="s2">, </span><span class="s1">table</span><span class="s2">, </span><span class="s1">deletechars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_translate_dispatcher)</span>
<span class="s2">def </span><span class="s1">translate(a</span><span class="s2">, </span><span class="s1">table</span><span class="s2">, </span><span class="s1">deletechars=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy of the string where all 
    characters occurring in the optional argument `deletechars` are 
    removed, and the remaining characters have been mapped through the 
    given translation table. 
 
    Calls `str.translate` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like of str or unicode 
 
    table : str of length 256 
 
    deletechars : str 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.translate 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">if </span><span class="s1">issubclass(a_arr.dtype.type</span><span class="s2">, </span><span class="s1">unicode_):</span>
        <span class="s2">return </span><span class="s1">_vec_string(</span>
            <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'translate'</span><span class="s2">, </span><span class="s1">(table</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_vec_string(</span>
            <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'translate'</span><span class="s2">, </span><span class="s1">[table] + _clean_args(deletechars))</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">upper(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements converted to uppercase. 
 
    Calls `str.upper` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array_like, {str, unicode} 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray, {str, unicode} 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.upper 
 
    Examples 
    -------- 
    &gt;&gt;&gt; c = np.array(['a1b c', '1bca', 'bca1']); c 
    array(['a1b c', '1bca', 'bca1'], dtype='&lt;U5') 
    &gt;&gt;&gt; np.char.upper(c) 
    array(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a_arr</span><span class="s2">, </span><span class="s1">a_arr.dtype</span><span class="s2">, </span><span class="s3">'upper'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_zfill_dispatcher(a</span><span class="s2">, </span><span class="s1">width):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_zfill_dispatcher)</span>
<span class="s2">def </span><span class="s1">zfill(a</span><span class="s2">, </span><span class="s1">width):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the numeric string left-filled with zeros 
 
    Calls `str.zfill` element-wise. 
 
    Parameters 
    ---------- 
    a : array_like, {str, unicode} 
        Input array. 
    width : int 
        Width of string to left-fill elements in `a`. 
 
    Returns 
    ------- 
    out : ndarray, {str, unicode} 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.zfill 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr = numpy.asarray(a)</span>
    <span class="s1">width_arr = numpy.asarray(width)</span>
    <span class="s1">size = int(numpy.max(width_arr.flat))</span>
    <span class="s2">return </span><span class="s1">_vec_string(</span>
        <span class="s1">a_arr</span><span class="s2">, </span><span class="s1">(a_arr.dtype.type</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">, </span><span class="s3">'zfill'</span><span class="s2">, </span><span class="s1">(width_arr</span><span class="s2">,</span><span class="s1">))</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isnumeric(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element, return True if there are only numeric 
    characters in the element. 
 
    Calls `unicode.isnumeric` element-wise. 
 
    Numeric characters include digit characters, and all characters 
    that have the Unicode numeric value property, e.g. ``U+2155, 
    VULGAR FRACTION ONE FIFTH``. 
 
    Parameters 
    ---------- 
    a : array_like, unicode 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray, bool 
        Array of booleans of same shape as `a`. 
 
    See Also 
    -------- 
    unicode.isnumeric 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_use_unicode(a) != unicode_:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;isnumeric is only available for Unicode strings and arrays&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isnumeric'</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_unary_op_dispatcher)</span>
<span class="s2">def </span><span class="s1">isdecimal(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element, return True if there are only decimal 
    characters in the element. 
 
    Calls `unicode.isdecimal` element-wise. 
 
    Decimal characters include digit characters, and all characters 
    that can be used to form decimal-radix numbers, 
    e.g. ``U+0660, ARABIC-INDIC DIGIT ZERO``. 
 
    Parameters 
    ---------- 
    a : array_like, unicode 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray, bool 
        Array of booleans identical in shape to `a`. 
 
    See Also 
    -------- 
    unicode.isdecimal 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_use_unicode(a) != unicode_:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;isnumeric is only available for Unicode strings and arrays&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_vec_string(a</span><span class="s2">, </span><span class="s1">bool_</span><span class="s2">, </span><span class="s3">'isdecimal'</span><span class="s1">)</span>


<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">chararray(ndarray):</span>
    <span class="s0">&quot;&quot;&quot; 
    chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0, 
              strides=None, order=None) 
 
    Provides a convenient view on arrays of string and unicode values. 
 
    .. note:: 
       The `chararray` class exists for backwards compatibility with 
       Numarray, it is not recommended for new development. Starting from numpy 
       1.4, if one needs arrays of strings, it is recommended to use arrays of 
       `dtype` `object_`, `string_` or `unicode_`, and use the free functions 
       in the `numpy.char` module for fast vectorized string operations. 
 
    Versus a regular NumPy array of type `str` or `unicode`, this 
    class adds the following functionality: 
 
      1) values automatically have whitespace removed from the end 
         when indexed 
 
      2) comparison operators automatically remove whitespace from the 
         end when comparing values 
 
      3) vectorized string operations are provided as methods 
         (e.g. `.endswith`) and infix operators (e.g. ``&quot;+&quot;, &quot;*&quot;, &quot;%&quot;``) 
 
    chararrays should be created using `numpy.char.array` or 
    `numpy.char.asarray`, rather than this constructor directly. 
 
    This constructor creates the array, using `buffer` (with `offset` 
    and `strides`) if it is not ``None``. If `buffer` is ``None``, then 
    constructs a new array with `strides` in &quot;C order&quot;, unless both 
    ``len(shape) &gt;= 2`` and ``order='F'``, in which case `strides` 
    is in &quot;Fortran order&quot;. 
 
    Methods 
    ------- 
    astype 
    argsort 
    copy 
    count 
    decode 
    dump 
    dumps 
    encode 
    endswith 
    expandtabs 
    fill 
    find 
    flatten 
    getfield 
    index 
    isalnum 
    isalpha 
    isdecimal 
    isdigit 
    islower 
    isnumeric 
    isspace 
    istitle 
    isupper 
    item 
    join 
    ljust 
    lower 
    lstrip 
    nonzero 
    put 
    ravel 
    repeat 
    replace 
    reshape 
    resize 
    rfind 
    rindex 
    rjust 
    rsplit 
    rstrip 
    searchsorted 
    setfield 
    setflags 
    sort 
    split 
    splitlines 
    squeeze 
    startswith 
    strip 
    swapaxes 
    swapcase 
    take 
    title 
    tofile 
    tolist 
    tostring 
    translate 
    transpose 
    upper 
    view 
    zfill 
 
    Parameters 
    ---------- 
    shape : tuple 
        Shape of the array. 
    itemsize : int, optional 
        Length of each array element, in number of characters. Default is 1. 
    unicode : bool, optional 
        Are the array elements of type unicode (True) or string (False). 
        Default is False. 
    buffer : object exposing the buffer interface or str, optional 
        Memory address of the start of the array data.  Default is None, 
        in which case a new array is created. 
    offset : int, optional 
        Fixed stride displacement from the beginning of an axis? 
        Default is 0. Needs to be &gt;=0. 
    strides : array_like of ints, optional 
        Strides for the array (see `ndarray.strides` for full description). 
        Default is None. 
    order : {'C', 'F'}, optional 
        The order in which the array data is stored in memory: 'C' -&gt; 
        &quot;row major&quot; order (the default), 'F' -&gt; &quot;column major&quot; 
        (Fortran) order. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; charar = np.chararray((3, 3)) 
    &gt;&gt;&gt; charar[:] = 'a' 
    &gt;&gt;&gt; charar 
    chararray([[b'a', b'a', b'a'], 
               [b'a', b'a', b'a'], 
               [b'a', b'a', b'a']], dtype='|S1') 
 
    &gt;&gt;&gt; charar = np.chararray(charar.shape, itemsize=5) 
    &gt;&gt;&gt; charar[:] = 'abc' 
    &gt;&gt;&gt; charar 
    chararray([[b'abc', b'abc', b'abc'], 
               [b'abc', b'abc', b'abc'], 
               [b'abc', b'abc', b'abc']], dtype='|S5') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__new__(subtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">itemsize=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unicode=</span><span class="s2">False, </span><span class="s1">buffer=</span><span class="s2">None,</span>
                <span class="s1">offset=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">strides=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s3">'C'</span><span class="s1">):</span>
        <span class="s2">global </span><span class="s1">_globalvar</span>

        <span class="s2">if </span><span class="s1">unicode:</span>
            <span class="s1">dtype = unicode_</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = string_</span>

        <span class="s5"># force itemsize to be a Python int, since using NumPy integer</span>
        <span class="s5"># types results in itemsize.itemsize being used as the size of</span>
        <span class="s5"># strings in the new array.</span>
        <span class="s1">itemsize = int(itemsize)</span>

        <span class="s2">if </span><span class="s1">isinstance(buffer</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s5"># unicode objects do not have the buffer interface</span>
            <span class="s1">filler = buffer</span>
            <span class="s1">buffer = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">filler = </span><span class="s2">None</span>

        <span class="s1">_globalvar = </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">buffer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self = ndarray.__new__(subtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">(dtype</span><span class="s2">, </span><span class="s1">itemsize)</span><span class="s2">,</span>
                                   <span class="s1">order=order)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self = ndarray.__new__(subtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">(dtype</span><span class="s2">, </span><span class="s1">itemsize)</span><span class="s2">,</span>
                                   <span class="s1">buffer=buffer</span><span class="s2">,</span>
                                   <span class="s1">offset=offset</span><span class="s2">, </span><span class="s1">strides=strides</span><span class="s2">,</span>
                                   <span class="s1">order=order)</span>
        <span class="s2">if </span><span class="s1">filler </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self[...] = filler</span>
        <span class="s1">_globalvar = </span><span class="s4">0</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__array_finalize__(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s5"># The b is a special case because it is used for reconstructing.</span>
        <span class="s2">if not </span><span class="s1">_globalvar </span><span class="s2">and </span><span class="s1">self.dtype.char </span><span class="s2">not in </span><span class="s3">'SUbc'</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Can only create a chararray from string data.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s1">val = ndarray.__getitem__(self</span><span class="s2">, </span><span class="s1">obj)</span>

        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">character):</span>
            <span class="s1">temp = val.rstrip()</span>
            <span class="s2">if </span><span class="s1">len(temp) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">val = </span><span class="s3">''</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">val = temp</span>

        <span class="s2">return </span><span class="s1">val</span>

    <span class="s5"># IMPLEMENTATION NOTE: Most of the methods of this class are</span>
    <span class="s5"># direct delegations to the free functions in this module.</span>
    <span class="s5"># However, those that return an array of strings should instead</span>
    <span class="s5"># return a chararray, so some extra wrapping is required.</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self == other) element-wise. 
 
        See Also 
        -------- 
        equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">equal(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self != other) element-wise. 
 
        See Also 
        -------- 
        not_equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">not_equal(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__ge__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &gt;= other) element-wise. 
 
        See Also 
        -------- 
        greater_equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">greater_equal(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__le__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &lt;= other) element-wise. 
 
        See Also 
        -------- 
        less_equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">less_equal(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__gt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &gt; other) element-wise. 
 
        See Also 
        -------- 
        greater 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">greater(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &lt; other) element-wise. 
 
        See Also 
        -------- 
        less 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">less(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self + other), that is string concatenation, 
        element-wise for a pair of array_likes of str or unicode. 
 
        See Also 
        -------- 
        add 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(add(self</span><span class="s2">, </span><span class="s1">other))</span>

    <span class="s2">def </span><span class="s1">__radd__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (other + self), that is string concatenation, 
        element-wise for a pair of array_likes of `string_` or `unicode_`. 
 
        See Also 
        -------- 
        add 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(add(numpy.asarray(other)</span><span class="s2">, </span><span class="s1">self))</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self * i), that is string multiple concatenation, 
        element-wise. 
 
        See Also 
        -------- 
        multiply 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(multiply(self</span><span class="s2">, </span><span class="s1">i))</span>

    <span class="s2">def </span><span class="s1">__rmul__(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self * i), that is string multiple concatenation, 
        element-wise. 
 
        See Also 
        -------- 
        multiply 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(multiply(self</span><span class="s2">, </span><span class="s1">i))</span>

    <span class="s2">def </span><span class="s1">__mod__(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self % i), that is pre-Python 2.6 string formatting 
        (interpolation), element-wise for a pair of array_likes of `string_` 
        or `unicode_`. 
 
        See Also 
        -------- 
        mod 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(mod(self</span><span class="s2">, </span><span class="s1">i))</span>

    <span class="s2">def </span><span class="s1">__rmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">argsort(self</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">kind=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the indices that sort the array lexicographically. 
 
        For full documentation see `numpy.argsort`, for which this method is 
        in fact merely a &quot;thin wrapper.&quot; 
 
        Examples 
        -------- 
        &gt;&gt;&gt; c = np.array(['a1b c', '1b ca', 'b ca1', 'Ca1b'], 'S5') 
        &gt;&gt;&gt; c = c.view(np.chararray); c 
        chararray(['a1b c', '1b ca', 'b ca1', 'Ca1b'], 
              dtype='|S5') 
        &gt;&gt;&gt; c[c.argsort()] 
        chararray(['1b ca', 'Ca1b', 'a1b c', 'b ca1'], 
              dtype='|S5') 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__array__().argsort(axis</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">order)</span>
    <span class="s1">argsort.__doc__ = ndarray.argsort.__doc__</span>

    <span class="s2">def </span><span class="s1">capitalize(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of `self` with only the first character of each element 
        capitalized. 
 
        See Also 
        -------- 
        char.capitalize 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(capitalize(self))</span>

    <span class="s2">def </span><span class="s1">center(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">' '</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of `self` with its elements centered in a 
        string of length `width`. 
 
        See Also 
        -------- 
        center 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(center(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar))</span>

    <span class="s2">def </span><span class="s1">count(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns an array with the number of non-overlapping occurrences of 
        substring `sub` in the range [`start`, `end`]. 
 
        See Also 
        -------- 
        char.count 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">count(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">decode(self</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">errors=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calls `str.decode` element-wise. 
 
        See Also 
        -------- 
        char.decode 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">decode(self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

    <span class="s2">def </span><span class="s1">encode(self</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">errors=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calls `str.encode` element-wise. 
 
        See Also 
        -------- 
        char.encode 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">encode(self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

    <span class="s2">def </span><span class="s1">endswith(self</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a boolean array which is `True` where the string element 
        in `self` ends with `suffix`, otherwise `False`. 
 
        See Also 
        -------- 
        char.endswith 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">endswith(self</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">expandtabs(self</span><span class="s2">, </span><span class="s1">tabsize=</span><span class="s4">8</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of each string element where all tab characters are 
        replaced by one or more spaces. 
 
        See Also 
        -------- 
        char.expandtabs 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(expandtabs(self</span><span class="s2">, </span><span class="s1">tabsize))</span>

    <span class="s2">def </span><span class="s1">find(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element, return the lowest index in the string where 
        substring `sub` is found. 
 
        See Also 
        -------- 
        char.find 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">find(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">index(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Like `find`, but raises `ValueError` when the substring is not found. 
 
        See Also 
        -------- 
        char.index 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">index(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">isalnum(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all characters in the string 
        are alphanumeric and there is at least one character, false 
        otherwise. 
 
        See Also 
        -------- 
        char.isalnum 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isalnum(self)</span>

    <span class="s2">def </span><span class="s1">isalpha(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all characters in the string 
        are alphabetic and there is at least one character, false 
        otherwise. 
 
        See Also 
        -------- 
        char.isalpha 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isalpha(self)</span>

    <span class="s2">def </span><span class="s1">isdigit(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all characters in the string are 
        digits and there is at least one character, false otherwise. 
 
        See Also 
        -------- 
        char.isdigit 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isdigit(self)</span>

    <span class="s2">def </span><span class="s1">islower(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all cased characters in the 
        string are lowercase and there is at least one cased character, 
        false otherwise. 
 
        See Also 
        -------- 
        char.islower 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">islower(self)</span>

    <span class="s2">def </span><span class="s1">isspace(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if there are only whitespace 
        characters in the string and there is at least one character, 
        false otherwise. 
 
        See Also 
        -------- 
        char.isspace 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isspace(self)</span>

    <span class="s2">def </span><span class="s1">istitle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if the element is a titlecased 
        string and there is at least one character, false otherwise. 
 
        See Also 
        -------- 
        char.istitle 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">istitle(self)</span>

    <span class="s2">def </span><span class="s1">isupper(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all cased characters in the 
        string are uppercase and there is at least one character, false 
        otherwise. 
 
        See Also 
        -------- 
        char.isupper 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isupper(self)</span>

    <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">seq):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string which is the concatenation of the strings in the 
        sequence `seq`. 
 
        See Also 
        -------- 
        char.join 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">seq)</span>

    <span class="s2">def </span><span class="s1">ljust(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">' '</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` left-justified in a 
        string of length `width`. 
 
        See Also 
        -------- 
        char.ljust 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(ljust(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar))</span>

    <span class="s2">def </span><span class="s1">lower(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` converted to 
        lowercase. 
 
        See Also 
        -------- 
        char.lower 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(lower(self))</span>

    <span class="s2">def </span><span class="s1">lstrip(self</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy with the leading characters 
        removed. 
 
        See Also 
        -------- 
        char.lstrip 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(lstrip(self</span><span class="s2">, </span><span class="s1">chars))</span>

    <span class="s2">def </span><span class="s1">partition(self</span><span class="s2">, </span><span class="s1">sep):</span>
        <span class="s0">&quot;&quot;&quot; 
        Partition each element in `self` around `sep`. 
 
        See Also 
        -------- 
        partition 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(partition(self</span><span class="s2">, </span><span class="s1">sep))</span>

    <span class="s2">def </span><span class="s1">replace(self</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">count=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy of the string with all 
        occurrences of substring `old` replaced by `new`. 
 
        See Also 
        -------- 
        char.replace 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(replace(self</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">count))</span>

    <span class="s2">def </span><span class="s1">rfind(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return the highest index in the string 
        where substring `sub` is found, such that `sub` is contained 
        within [`start`, `end`]. 
 
        See Also 
        -------- 
        char.rfind 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rfind(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">rindex(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Like `rfind`, but raises `ValueError` when the substring `sub` is 
        not found. 
 
        See Also 
        -------- 
        char.rindex 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rindex(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">rjust(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">' '</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` 
        right-justified in a string of length `width`. 
 
        See Also 
        -------- 
        char.rjust 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(rjust(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">fillchar))</span>

    <span class="s2">def </span><span class="s1">rpartition(self</span><span class="s2">, </span><span class="s1">sep):</span>
        <span class="s0">&quot;&quot;&quot; 
        Partition each element in `self` around `sep`. 
 
        See Also 
        -------- 
        rpartition 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(rpartition(self</span><span class="s2">, </span><span class="s1">sep))</span>

    <span class="s2">def </span><span class="s1">rsplit(self</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a list of the words in 
        the string, using `sep` as the delimiter string. 
 
        See Also 
        -------- 
        char.rsplit 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rsplit(self</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">maxsplit)</span>

    <span class="s2">def </span><span class="s1">rstrip(self</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy with the trailing 
        characters removed. 
 
        See Also 
        -------- 
        char.rstrip 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(rstrip(self</span><span class="s2">, </span><span class="s1">chars))</span>

    <span class="s2">def </span><span class="s1">split(self</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a list of the words in the 
        string, using `sep` as the delimiter string. 
 
        See Also 
        -------- 
        char.split 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">split(self</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">maxsplit)</span>

    <span class="s2">def </span><span class="s1">splitlines(self</span><span class="s2">, </span><span class="s1">keepends=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a list of the lines in the 
        element, breaking at line boundaries. 
 
        See Also 
        -------- 
        char.splitlines 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">splitlines(self</span><span class="s2">, </span><span class="s1">keepends)</span>

    <span class="s2">def </span><span class="s1">startswith(self</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a boolean array which is `True` where the string element 
        in `self` starts with `prefix`, otherwise `False`. 
 
        See Also 
        -------- 
        char.startswith 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">startswith(self</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s2">def </span><span class="s1">strip(self</span><span class="s2">, </span><span class="s1">chars=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy with the leading and 
        trailing characters removed. 
 
        See Also 
        -------- 
        char.strip 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(strip(self</span><span class="s2">, </span><span class="s1">chars))</span>

    <span class="s2">def </span><span class="s1">swapcase(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy of the string with 
        uppercase characters converted to lowercase and vice versa. 
 
        See Also 
        -------- 
        char.swapcase 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(swapcase(self))</span>

    <span class="s2">def </span><span class="s1">title(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a titlecased version of the 
        string: words start with uppercase characters, all remaining cased 
        characters are lowercase. 
 
        See Also 
        -------- 
        char.title 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(title(self))</span>

    <span class="s2">def </span><span class="s1">translate(self</span><span class="s2">, </span><span class="s1">table</span><span class="s2">, </span><span class="s1">deletechars=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy of the string where 
        all characters occurring in the optional argument 
        `deletechars` are removed, and the remaining characters have 
        been mapped through the given translation table. 
 
        See Also 
        -------- 
        char.translate 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(translate(self</span><span class="s2">, </span><span class="s1">table</span><span class="s2">, </span><span class="s1">deletechars))</span>

    <span class="s2">def </span><span class="s1">upper(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` converted to 
        uppercase. 
 
        See Also 
        -------- 
        char.upper 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(upper(self))</span>

    <span class="s2">def </span><span class="s1">zfill(self</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the numeric string left-filled with zeros in a string of 
        length `width`. 
 
        See Also 
        -------- 
        char.zfill 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray(zfill(self</span><span class="s2">, </span><span class="s1">width))</span>

    <span class="s2">def </span><span class="s1">isnumeric(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return True if there are only 
        numeric characters in the element. 
 
        See Also 
        -------- 
        char.isnumeric 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isnumeric(self)</span>

    <span class="s2">def </span><span class="s1">isdecimal(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return True if there are only 
        decimal characters in the element. 
 
        See Also 
        -------- 
        char.isdecimal 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isdecimal(self)</span>


<span class="s1">@set_module(</span><span class="s3">&quot;numpy.char&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">array(obj</span><span class="s2">, </span><span class="s1">itemsize=</span><span class="s2">None, </span><span class="s1">copy=</span><span class="s2">True, </span><span class="s1">unicode=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a `chararray`. 
 
    .. note:: 
       This class is provided for numarray backward-compatibility. 
       New code (not concerned with numarray compatibility) should use 
       arrays of type `string_` or `unicode_` and use the free functions 
       in :mod:`numpy.char &lt;numpy.core.defchararray&gt;` for fast 
       vectorized string operations instead. 
 
    Versus a regular NumPy array of type `str` or `unicode`, this 
    class adds the following functionality: 
 
      1) values automatically have whitespace removed from the end 
         when indexed 
 
      2) comparison operators automatically remove whitespace from the 
         end when comparing values 
 
      3) vectorized string operations are provided as methods 
         (e.g. `str.endswith`) and infix operators (e.g. ``+, *, %``) 
 
    Parameters 
    ---------- 
    obj : array of str or unicode-like 
 
    itemsize : int, optional 
        `itemsize` is the number of characters per scalar in the 
        resulting array.  If `itemsize` is None, and `obj` is an 
        object array or a Python list, the `itemsize` will be 
        automatically determined.  If `itemsize` is provided and `obj` 
        is of type str or unicode, then the `obj` string will be 
        chunked into `itemsize` pieces. 
 
    copy : bool, optional 
        If true (default), then the object is copied.  Otherwise, a copy 
        will only be made if __array__ returns a copy, if obj is a 
        nested sequence, or if a copy is needed to satisfy any of the other 
        requirements (`itemsize`, unicode, `order`, etc.). 
 
    unicode : bool, optional 
        When true, the resulting `chararray` can contain Unicode 
        characters, when false only 8-bit characters.  If unicode is 
        None and `obj` is one of the following: 
 
          - a `chararray`, 
          - an ndarray of type `str` or `unicode` 
          - a Python str or unicode object, 
 
        then the unicode setting of the output array will be 
        automatically determined. 
 
    order : {'C', 'F', 'A'}, optional 
        Specify the order of the array.  If order is 'C' (default), then the 
        array will be in C-contiguous order (last-index varies the 
        fastest).  If order is 'F', then the returned array 
        will be in Fortran-contiguous order (first-index varies the 
        fastest).  If order is 'A', then the returned array may 
        be in any order (either C-, Fortran-contiguous, or even 
        discontiguous). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(bytes</span><span class="s2">, </span><span class="s1">str)):</span>
        <span class="s2">if </span><span class="s1">unicode </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">unicode = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">unicode = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">itemsize = len(obj)</span>
        <span class="s1">shape = len(obj) // itemsize</span>

        <span class="s2">return </span><span class="s1">chararray(shape</span><span class="s2">, </span><span class="s1">itemsize=itemsize</span><span class="s2">, </span><span class="s1">unicode=unicode</span><span class="s2">,</span>
                         <span class="s1">buffer=obj</span><span class="s2">, </span><span class="s1">order=order)</span>

    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">obj = numpy.asarray(obj)</span>

    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ndarray) </span><span class="s2">and </span><span class="s1">issubclass(obj.dtype.type</span><span class="s2">, </span><span class="s1">character):</span>
        <span class="s5"># If we just have a vanilla chararray, create a chararray</span>
        <span class="s5"># view around it.</span>
        <span class="s2">if not </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">chararray):</span>
            <span class="s1">obj = obj.view(chararray)</span>

        <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">itemsize = obj.itemsize</span>
            <span class="s5"># itemsize is in 8-bit chars, so for Unicode, we need</span>
            <span class="s5"># to divide by the size of a single Unicode character,</span>
            <span class="s5"># which for NumPy is always 4</span>
            <span class="s2">if </span><span class="s1">issubclass(obj.dtype.type</span><span class="s2">, </span><span class="s1">unicode_):</span>
                <span class="s1">itemsize //= </span><span class="s4">4</span>

        <span class="s2">if </span><span class="s1">unicode </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">issubclass(obj.dtype.type</span><span class="s2">, </span><span class="s1">unicode_):</span>
                <span class="s1">unicode = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">unicode = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">unicode:</span>
            <span class="s1">dtype = unicode_</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = string_</span>

        <span class="s2">if </span><span class="s1">order </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">obj = numpy.asarray(obj</span><span class="s2">, </span><span class="s1">order=order)</span>
        <span class="s2">if </span><span class="s1">(copy </span><span class="s2">or</span>
                <span class="s1">(itemsize != obj.itemsize) </span><span class="s2">or</span>
                <span class="s1">(</span><span class="s2">not </span><span class="s1">unicode </span><span class="s2">and </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">unicode_)) </span><span class="s2">or</span>
                <span class="s1">(unicode </span><span class="s2">and </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">string_))):</span>
            <span class="s1">obj = obj.astype((dtype</span><span class="s2">, </span><span class="s1">int(itemsize)))</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ndarray) </span><span class="s2">and </span><span class="s1">issubclass(obj.dtype.type</span><span class="s2">, </span><span class="s1">object):</span>
        <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s5"># Since no itemsize was specified, convert the input array to</span>
            <span class="s5"># a list so the ndarray constructor will automatically</span>
            <span class="s5"># determine the itemsize for us.</span>
            <span class="s1">obj = obj.tolist()</span>
            <span class="s5"># Fall through to the default case</span>

    <span class="s2">if </span><span class="s1">unicode:</span>
        <span class="s1">dtype = unicode_</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dtype = string_</span>

    <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">val = narray(obj</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">val = narray(obj</span><span class="s2">, </span><span class="s1">dtype=(dtype</span><span class="s2">, </span><span class="s1">itemsize)</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">val.view(chararray)</span>


<span class="s1">@set_module(</span><span class="s3">&quot;numpy.char&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">asarray(obj</span><span class="s2">, </span><span class="s1">itemsize=</span><span class="s2">None, </span><span class="s1">unicode=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert the input to a `chararray`, copying the data only if 
    necessary. 
 
    Versus a regular NumPy array of type `str` or `unicode`, this 
    class adds the following functionality: 
 
      1) values automatically have whitespace removed from the end 
         when indexed 
 
      2) comparison operators automatically remove whitespace from the 
         end when comparing values 
 
      3) vectorized string operations are provided as methods 
         (e.g. `str.endswith`) and infix operators (e.g. ``+``, ``*``,``%``) 
 
    Parameters 
    ---------- 
    obj : array of str or unicode-like 
 
    itemsize : int, optional 
        `itemsize` is the number of characters per scalar in the 
        resulting array.  If `itemsize` is None, and `obj` is an 
        object array or a Python list, the `itemsize` will be 
        automatically determined.  If `itemsize` is provided and `obj` 
        is of type str or unicode, then the `obj` string will be 
        chunked into `itemsize` pieces. 
 
    unicode : bool, optional 
        When true, the resulting `chararray` can contain Unicode 
        characters, when false only 8-bit characters.  If unicode is 
        None and `obj` is one of the following: 
 
          - a `chararray`, 
          - an ndarray of type `str` or 'unicode` 
          - a Python str or unicode object, 
 
        then the unicode setting of the output array will be 
        automatically determined. 
 
    order : {'C', 'F'}, optional 
        Specify the order of the array.  If order is 'C' (default), then the 
        array will be in C-contiguous order (last-index varies the 
        fastest).  If order is 'F', then the returned array 
        will be in Fortran-contiguous order (first-index varies the 
        fastest). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">array(obj</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False,</span>
                 <span class="s1">unicode=unicode</span><span class="s2">, </span><span class="s1">order=order)</span>
</pre>
</body>
</html>