<html>
<head>
<title>object_array.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
object_array.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Callable  </span><span class="s2"># noqa: PDF001</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">textwrap</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">import </span><span class="s1">unicodedata</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">pandas._libs.lib </span><span class="s0">as </span><span class="s1">lib</span>
<span class="s0">import </span><span class="s1">pandas._libs.missing </span><span class="s0">as </span><span class="s1">libmissing</span>
<span class="s0">import </span><span class="s1">pandas._libs.ops </span><span class="s0">as </span><span class="s1">libops</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">NpDtype</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">is_scalar</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">isna</span>

<span class="s0">from </span><span class="s1">pandas.core.strings.base </span><span class="s0">import </span><span class="s1">BaseStringArrayMethods</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>


<span class="s0">class </span><span class="s1">ObjectStringArrayMixin(BaseStringArrayMethods):</span>
    <span class="s3">&quot;&quot;&quot; 
    String Methods operating on object-dtype ndarrays. 
    &quot;&quot;&quot;</span>

    <span class="s1">_str_na_value = np.nan</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s2"># For typing, _str_map relies on the object being sized.</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">_str_map(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">na_value=</span><span class="s0">None, </span><span class="s1">dtype: NpDtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">convert: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Map a callable over valid elements of the array. 
 
        Parameters 
        ---------- 
        f : Callable 
            A function to call on each non-NA element. 
        na_value : Scalar, optional 
            The value to set for NA values. Might also be used for the 
            fill value if the callable `f` raises an exception. 
            This defaults to ``self._str_na_value`` which is ``np.nan`` 
            for object-dtype and Categorical and ``pd.NA`` for StringArray. 
        dtype : Dtype, optional 
            The dtype of the result array. 
        convert : bool, default True 
            Whether to call `maybe_convert_objects` on the resulting ndarray 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(</span><span class="s4">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">na_value = self._str_na_value</span>

        <span class="s0">if not </span><span class="s1">len(self):</span>
            <span class="s0">return </span><span class="s1">np.ndarray(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">arr = np.asarray(self</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">mask = isna(arr)</span>
        <span class="s1">map_convert = convert </span><span class="s0">and not </span><span class="s1">np.all(mask)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = lib.map_infer_mask(arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(np.uint8)</span><span class="s0">, </span><span class="s1">map_convert)</span>
        <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">AttributeError) </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s2"># Reraise the exception if callable `f` got wrong number of args.</span>
            <span class="s2"># The user may want to be warned by this, instead of getting NaN</span>
            <span class="s1">p_err = (</span>
                <span class="s4">r&quot;((takes)|(missing)) (?(2)from \d+ to )?\d+ &quot;</span>
                <span class="s4">r&quot;(?(3)required )positional arguments?&quot;</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">len(err.args) &gt;= </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">re.search(p_err</span><span class="s0">, </span><span class="s1">err.args[</span><span class="s5">0</span><span class="s1">]):</span>
                <span class="s2"># FIXME: this should be totally avoidable</span>
                <span class="s0">raise </span><span class="s1">err</span>

            <span class="s0">def </span><span class="s1">g(x):</span>
                <span class="s2"># This type of fallback behavior can be removed once</span>
                <span class="s2"># we remove object-dtype .str accessor.</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">f(x)</span>
                <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">AttributeError):</span>
                    <span class="s0">return </span><span class="s1">na_value</span>

            <span class="s0">return </span><span class="s1">self._str_map(g</span><span class="s0">, </span><span class="s1">na_value=na_value</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is not </span><span class="s1">np.nan:</span>
            <span class="s1">np.putmask(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">na_value)</span>
            <span class="s0">if </span><span class="s1">convert </span><span class="s0">and </span><span class="s1">result.dtype == object:</span>
                <span class="s1">result = lib.maybe_convert_objects(result)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_count(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>
        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: len(regex.findall(x))</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_pad(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">side=</span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s1">fillchar=</span><span class="s4">&quot; &quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">side == </span><span class="s4">&quot;left&quot;</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.rjust(width</span><span class="s0">, </span><span class="s1">fillchar)</span>
        <span class="s0">elif </span><span class="s1">side == </span><span class="s4">&quot;right&quot;</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.ljust(width</span><span class="s0">, </span><span class="s1">fillchar)</span>
        <span class="s0">elif </span><span class="s1">side == </span><span class="s4">&quot;both&quot;</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.center(width</span><span class="s0">, </span><span class="s1">fillchar)</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid side&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f)</span>

    <span class="s0">def </span><span class="s1">_str_contains(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case=</span><span class="s0">True, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">na=np.nan</span><span class="s0">, </span><span class="s1">regex: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">regex:</span>
            <span class="s0">if not </span><span class="s1">case:</span>
                <span class="s1">flags |= re.IGNORECASE</span>

            <span class="s1">pat = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>

            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: pat.search(x) </span><span class="s0">is not None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">case:</span>
                <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: pat </span><span class="s0">in </span><span class="s1">x</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">upper_pat = pat.upper()</span>
                <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: upper_pat </span><span class="s0">in </span><span class="s1">x.upper()</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">dtype=np.dtype(</span><span class="s4">&quot;bool&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_str_startswith(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.startswith(pat)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">na_value=na</span><span class="s0">, </span><span class="s1">dtype=np.dtype(bool))</span>

    <span class="s0">def </span><span class="s1">_str_endswith(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.endswith(pat)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">na_value=na</span><span class="s0">, </span><span class="s1">dtype=np.dtype(bool))</span>

    <span class="s0">def </span><span class="s1">_str_replace(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern</span><span class="s0">,</span>
        <span class="s1">repl: str | Callable</span><span class="s0">,</span>
        <span class="s1">n: int = -</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">case: bool = </span><span class="s0">True,</span>
        <span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">regex: bool = </span><span class="s0">True,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">case </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s2"># add case flag, if provided</span>
            <span class="s1">flags |= re.IGNORECASE</span>

        <span class="s0">if </span><span class="s1">regex </span><span class="s0">or </span><span class="s1">flags </span><span class="s0">or </span><span class="s1">callable(repl):</span>
            <span class="s0">if not </span><span class="s1">isinstance(pat</span><span class="s0">, </span><span class="s1">re.Pattern):</span>
                <span class="s0">if </span><span class="s1">regex </span><span class="s0">is False</span><span class="s1">:</span>
                    <span class="s1">pat = re.escape(pat)</span>
                <span class="s1">pat = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>

            <span class="s1">n = n </span><span class="s0">if </span><span class="s1">n &gt;= </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">0</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: pat.sub(repl=repl</span><span class="s0">, </span><span class="s1">string=x</span><span class="s0">, </span><span class="s1">count=n)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.replace(pat</span><span class="s0">, </span><span class="s1">repl</span><span class="s0">, </span><span class="s1">n)</span>

        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=str)</span>

    <span class="s0">def </span><span class="s1">_str_repeat(self</span><span class="s0">, </span><span class="s1">repeats):</span>
        <span class="s0">if </span><span class="s1">is_scalar(repeats):</span>

            <span class="s0">def </span><span class="s1">scalar_rep(x):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">bytes.__mul__(x</span><span class="s0">, </span><span class="s1">repeats)</span>
                <span class="s0">except </span><span class="s1">TypeError:</span>
                    <span class="s0">return </span><span class="s1">str.__mul__(x</span><span class="s0">, </span><span class="s1">repeats)</span>

            <span class="s0">return </span><span class="s1">self._str_map(scalar_rep</span><span class="s0">, </span><span class="s1">dtype=str)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s0">import </span><span class="s1">BaseStringArray</span>

            <span class="s0">def </span><span class="s1">rep(x</span><span class="s0">, </span><span class="s1">r):</span>
                <span class="s0">if </span><span class="s1">x </span><span class="s0">is </span><span class="s1">libmissing.NA:</span>
                    <span class="s0">return </span><span class="s1">x</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">bytes.__mul__(x</span><span class="s0">, </span><span class="s1">r)</span>
                <span class="s0">except </span><span class="s1">TypeError:</span>
                    <span class="s0">return </span><span class="s1">str.__mul__(x</span><span class="s0">, </span><span class="s1">r)</span>

            <span class="s1">repeats = np.asarray(repeats</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">result = libops.vec_binop(np.asarray(self)</span><span class="s0">, </span><span class="s1">repeats</span><span class="s0">, </span><span class="s1">rep)</span>
            <span class="s0">if </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">BaseStringArray):</span>
                <span class="s2"># Not going through map, so we have to do this here.</span>
                <span class="s1">result = type(self)._from_sequence(result)</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_match(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">case: bool = </span><span class="s0">True, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">na: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">case:</span>
            <span class="s1">flags |= re.IGNORECASE</span>

        <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>

        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: regex.match(x) </span><span class="s0">is not None</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">na_value=na</span><span class="s0">, </span><span class="s1">dtype=np.dtype(bool))</span>

    <span class="s0">def </span><span class="s1">_str_fullmatch(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern</span><span class="s0">,</span>
        <span class="s1">case: bool = </span><span class="s0">True,</span>
        <span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">na: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">case:</span>
            <span class="s1">flags |= re.IGNORECASE</span>

        <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>

        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: regex.fullmatch(x) </span><span class="s0">is not None</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">na_value=na</span><span class="s0">, </span><span class="s1">dtype=np.dtype(bool))</span>

    <span class="s0">def </span><span class="s1">_str_encode(self</span><span class="s0">, </span><span class="s1">encoding</span><span class="s0">, </span><span class="s1">errors=</span><span class="s4">&quot;strict&quot;</span><span class="s1">):</span>
        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.encode(encoding</span><span class="s0">, </span><span class="s1">errors=errors)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=object)</span>

    <span class="s0">def </span><span class="s1">_str_find(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self._str_find_(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">side=</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_rfind(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self._str_find_(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">side=</span><span class="s4">&quot;right&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_find_(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">side):</span>
        <span class="s0">if </span><span class="s1">side == </span><span class="s4">&quot;left&quot;</span><span class="s1">:</span>
            <span class="s1">method = </span><span class="s4">&quot;find&quot;</span>
        <span class="s0">elif </span><span class="s1">side == </span><span class="s4">&quot;right&quot;</span><span class="s1">:</span>
            <span class="s1">method = </span><span class="s4">&quot;rfind&quot;</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid side&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: getattr(x</span><span class="s0">, </span><span class="s1">method)(sub</span><span class="s0">, </span><span class="s1">start)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: getattr(x</span><span class="s0">, </span><span class="s1">method)(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_findall(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>
        <span class="s0">return </span><span class="s1">self._str_map(regex.findall</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_get(self</span><span class="s0">, </span><span class="s1">i):</span>
        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">return </span><span class="s1">x.get(i)</span>
            <span class="s0">elif </span><span class="s1">len(x) &gt; i &gt;= -len(x):</span>
                <span class="s0">return </span><span class="s1">x[i]</span>
            <span class="s0">return </span><span class="s1">self._str_na_value</span>

        <span class="s0">return </span><span class="s1">self._str_map(f)</span>

    <span class="s0">def </span><span class="s1">_str_index(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">end:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.index(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.index(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_rindex(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">end:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.rindex(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.rindex(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_join(self</span><span class="s0">, </span><span class="s1">sep):</span>
        <span class="s0">return </span><span class="s1">self._str_map(sep.join)</span>

    <span class="s0">def </span><span class="s1">_str_partition(self</span><span class="s0">, </span><span class="s1">sep</span><span class="s0">, </span><span class="s1">expand):</span>
        <span class="s1">result = self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.partition(sep)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_rpartition(self</span><span class="s0">, </span><span class="s1">sep</span><span class="s0">, </span><span class="s1">expand):</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.rpartition(sep)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_len(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(len</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_slice(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">stop=</span><span class="s0">None, </span><span class="s1">step=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">obj = slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x[obj])</span>

    <span class="s0">def </span><span class="s1">_str_slice_replace(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">stop=</span><span class="s0">None, </span><span class="s1">repl=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">repl </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">repl = </span><span class="s4">&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">if </span><span class="s1">x[start:stop] == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
                <span class="s1">local_stop = start</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">local_stop = stop</span>
            <span class="s1">y = </span><span class="s4">&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">start </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">y += x[:start]</span>
            <span class="s1">y += repl</span>
            <span class="s0">if </span><span class="s1">stop </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">y += x[local_stop:]</span>
            <span class="s0">return </span><span class="s1">y</span>

        <span class="s0">return </span><span class="s1">self._str_map(f)</span>

    <span class="s0">def </span><span class="s1">_str_split(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">n=-</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">expand=</span><span class="s0">False,</span>
        <span class="s1">regex: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pat </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">n </span><span class="s0">is None or </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">n = -</span><span class="s5">1</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.split(pat</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_pat: str | re.Pattern</span>
            <span class="s0">if </span><span class="s1">regex </span><span class="s0">is True or </span><span class="s1">isinstance(pat</span><span class="s0">, </span><span class="s1">re.Pattern):</span>
                <span class="s1">new_pat = re.compile(pat)</span>
            <span class="s0">elif </span><span class="s1">regex </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s1">new_pat = pat</span>
            <span class="s2"># regex is None so link to old behavior #43563</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">len(pat) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">new_pat = pat</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">new_pat = re.compile(pat)</span>

            <span class="s0">if </span><span class="s1">isinstance(new_pat</span><span class="s0">, </span><span class="s1">re.Pattern):</span>
                <span class="s0">if </span><span class="s1">n </span><span class="s0">is None or </span><span class="s1">n == -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">n = </span><span class="s5">0</span>
                <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: new_pat.split(x</span><span class="s0">, </span><span class="s1">maxsplit=n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">n </span><span class="s0">is None or </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">n = -</span><span class="s5">1</span>
                <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.split(pat</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=object)</span>

    <span class="s0">def </span><span class="s1">_str_rsplit(self</span><span class="s0">, </span><span class="s1">pat=</span><span class="s0">None, </span><span class="s1">n=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">n </span><span class="s0">is None or </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">n = -</span><span class="s5">1</span>
        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.rsplit(pat</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_translate(self</span><span class="s0">, </span><span class="s1">table):</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.translate(table))</span>

    <span class="s0">def </span><span class="s1">_str_wrap(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;width&quot;</span><span class="s1">] = width</span>
        <span class="s1">tw = textwrap.TextWrapper(**kwargs)</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">s: </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(tw.wrap(s)))</span>

    <span class="s0">def </span><span class="s1">_str_get_dummies(self</span><span class="s0">, </span><span class="s1">sep=</span><span class="s4">&quot;|&quot;</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s1">arr = Series(self).fillna(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">arr = sep + arr + sep</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s1">arr = sep + arr.astype(str) + sep</span>

        <span class="s1">tags: set[str] = set()</span>
        <span class="s0">for </span><span class="s1">ts </span><span class="s0">in </span><span class="s1">Series(arr).str.split(sep):</span>
            <span class="s1">tags.update(ts)</span>
        <span class="s1">tags2 = sorted(tags - {</span><span class="s4">&quot;&quot;</span><span class="s1">})</span>

        <span class="s1">dummies = np.empty((len(arr)</span><span class="s0">, </span><span class="s1">len(tags2))</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">enumerate(tags2):</span>
            <span class="s1">pat = sep + t + sep</span>
            <span class="s1">dummies[:</span><span class="s0">, </span><span class="s1">i] = lib.map_infer(arr.to_numpy()</span><span class="s0">, lambda </span><span class="s1">x: pat </span><span class="s0">in </span><span class="s1">x)</span>
        <span class="s0">return </span><span class="s1">dummies</span><span class="s0">, </span><span class="s1">tags2</span>

    <span class="s0">def </span><span class="s1">_str_upper(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.upper())</span>

    <span class="s0">def </span><span class="s1">_str_isalnum(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isalnum</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_isalpha(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isalpha</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_isdecimal(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isdecimal</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_isdigit(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isdigit</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_islower(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.islower</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_isnumeric(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isnumeric</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_isspace(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isspace</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_istitle(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.istitle</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_isupper(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.isupper</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_capitalize(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.capitalize)</span>

    <span class="s0">def </span><span class="s1">_str_casefold(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.casefold)</span>

    <span class="s0">def </span><span class="s1">_str_title(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.title)</span>

    <span class="s0">def </span><span class="s1">_str_swapcase(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.swapcase)</span>

    <span class="s0">def </span><span class="s1">_str_lower(self):</span>
        <span class="s0">return </span><span class="s1">self._str_map(str.lower)</span>

    <span class="s0">def </span><span class="s1">_str_normalize(self</span><span class="s0">, </span><span class="s1">form):</span>
        <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: unicodedata.normalize(form</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s0">return </span><span class="s1">self._str_map(f)</span>

    <span class="s0">def </span><span class="s1">_str_strip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.strip(to_strip))</span>

    <span class="s0">def </span><span class="s1">_str_lstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.lstrip(to_strip))</span>

    <span class="s0">def </span><span class="s1">_str_rstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self._str_map(</span><span class="s0">lambda </span><span class="s1">x: x.rstrip(to_strip))</span>

    <span class="s0">def </span><span class="s1">_str_removeprefix(self</span><span class="s0">, </span><span class="s1">prefix: str) -&gt; Series:</span>
        <span class="s2"># outstanding question on whether to use native methods for users</span>
        <span class="s2"># on Python 3.9+ https://git.io/JE9QK, in which case we could do</span>
        <span class="s2"># return self._str_map(str.removeprefix)</span>

        <span class="s0">def </span><span class="s1">removeprefix(text: str) -&gt; str:</span>
            <span class="s0">if </span><span class="s1">text.startswith(prefix):</span>
                <span class="s0">return </span><span class="s1">text[len(prefix) :]</span>
            <span class="s0">return </span><span class="s1">text</span>

        <span class="s0">return </span><span class="s1">self._str_map(removeprefix)</span>

    <span class="s0">def </span><span class="s1">_str_removesuffix(self</span><span class="s0">, </span><span class="s1">suffix: str) -&gt; Series:</span>
        <span class="s2"># this could be used on Python 3.9+</span>
        <span class="s2"># f = lambda x: x.removesuffix(suffix)</span>
        <span class="s2"># return self._str_map(str.removesuffix)</span>

        <span class="s0">def </span><span class="s1">removesuffix(text: str) -&gt; str:</span>
            <span class="s0">if </span><span class="s1">text.endswith(suffix):</span>
                <span class="s0">return </span><span class="s1">text[: -len(suffix)]</span>
            <span class="s0">return </span><span class="s1">text</span>

        <span class="s0">return </span><span class="s1">self._str_map(removesuffix)</span>

    <span class="s0">def </span><span class="s1">_str_extract(self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">expand: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>
        <span class="s1">na_value = self._str_na_value</span>

        <span class="s0">if not </span><span class="s1">expand:</span>

            <span class="s0">def </span><span class="s1">g(x):</span>
                <span class="s1">m = regex.search(x)</span>
                <span class="s0">return </span><span class="s1">m.groups()[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">m </span><span class="s0">else </span><span class="s1">na_value</span>

            <span class="s0">return </span><span class="s1">self._str_map(g</span><span class="s0">, </span><span class="s1">convert=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">empty_row = [na_value] * regex.groups</span>

        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">if not </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">return </span><span class="s1">empty_row</span>
            <span class="s1">m = regex.search(x)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s0">return </span><span class="s1">[na_value </span><span class="s0">if </span><span class="s1">item </span><span class="s0">is None else </span><span class="s1">item </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">m.groups()]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">empty_row</span>

        <span class="s0">return </span><span class="s1">[f(val) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">np.asarray(self)]</span>
</pre>
</body>
</html>