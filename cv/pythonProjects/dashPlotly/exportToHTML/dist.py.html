<html>
<head>
<title>dist.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dist.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.dist 
 
Provides the Distribution class, which represents the module distribution 
being built/installed/distributed. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">email </span><span class="s2">import </span><span class="s1">message_from_file</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">warnings = </span><span class="s2">None</span>

<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">*</span>
<span class="s2">from </span><span class="s1">distutils.fancy_getopt </span><span class="s2">import </span><span class="s1">FancyGetopt</span><span class="s2">, </span><span class="s1">translate_longopt</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">check_environ</span><span class="s2">, </span><span class="s1">strtobool</span><span class="s2">, </span><span class="s1">rfc822_escape</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils.debug </span><span class="s2">import </span><span class="s1">DEBUG</span>

<span class="s3"># Regex to define acceptable Distutils command names.  This is not *quite*</span>
<span class="s3"># the same as a Python NAME -- I don't allow leading underscores.  The fact</span>
<span class="s3"># that they're very similar is no coincidence; the default naming scheme is</span>
<span class="s3"># to look for a Python module named after the command.</span>
<span class="s1">command_re = re.compile(</span><span class="s4">r'^[a-zA-Z]([a-zA-Z0-9_]*)$'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_ensure_list(value</span><span class="s2">, </span><span class="s1">fieldname):</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s3"># a string containing comma separated values is okay.  It will</span>
        <span class="s3"># be converted to a list by Distribution.finalize_options().</span>
        <span class="s2">pass</span>
    <span class="s2">elif not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s3"># passing a tuple or an iterator perhaps, warn and convert</span>
        <span class="s1">typename = type(value).__name__</span>
        <span class="s1">msg = </span><span class="s4">&quot;Warning: '{fieldname}' should be a list, got type '{typename}'&quot;</span>
        <span class="s1">msg = msg.format(**locals())</span>
        <span class="s1">log.log(log.WARN</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">value = list(value)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">class </span><span class="s1">Distribution:</span>
    <span class="s0">&quot;&quot;&quot;The core of the Distutils.  Most of the work hiding behind 'setup' 
    is really done within a Distribution instance, which farms the work out 
    to the Distutils commands specified on the command line. 
 
    Setup scripts will almost never instantiate Distribution directly, 
    unless the 'setup()' function is totally inadequate to their needs. 
    However, it is conceivable that a setup script might wish to subclass 
    Distribution for some specialized purpose, and then pass the subclass 
    to 'setup()' as the 'distclass' keyword argument.  If so, it is 
    necessary to respect the expectations that 'setup' has of Distribution. 
    See the code for 'setup()', in core.py, for details. 
    &quot;&quot;&quot;</span>

    <span class="s3"># 'global_options' describes the command-line options that may be</span>
    <span class="s3"># supplied to the setup script prior to any actual commands.</span>
    <span class="s3"># Eg. &quot;./setup.py -n&quot; or &quot;./setup.py --quiet&quot; both take advantage of</span>
    <span class="s3"># these global options.  This list should be kept to a bare minimum,</span>
    <span class="s3"># since every global option is also valid as a command option -- and we</span>
    <span class="s3"># don't want to pollute the commands with too many options that they</span>
    <span class="s3"># have minimal control over.</span>
    <span class="s3"># The fourth entry for verbose means that it can be repeated.</span>
    <span class="s1">global_options = [</span>
        <span class="s1">(</span><span class="s4">'verbose'</span><span class="s2">, </span><span class="s4">'v'</span><span class="s2">, </span><span class="s4">&quot;run verbosely (default)&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'quiet'</span><span class="s2">, </span><span class="s4">'q'</span><span class="s2">, </span><span class="s4">&quot;run quietly (turns verbosity off)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'dry-run'</span><span class="s2">, </span><span class="s4">'n'</span><span class="s2">, </span><span class="s4">&quot;don't actually do anything&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'help'</span><span class="s2">, </span><span class="s4">'h'</span><span class="s2">, </span><span class="s4">&quot;show detailed help message&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'no-user-cfg'</span><span class="s2">, None,</span>
            <span class="s4">'ignore pydistutils.cfg in your home directory'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s3"># 'common_usage' is a short (2-3 line) string describing the common</span>
    <span class="s3"># usage of the setup script.</span>
    <span class="s1">common_usage = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Common commands: (see '--help-commands' for more) 
 
  setup.py build      will build the package underneath 'build/' 
  setup.py install    will install the package 
&quot;&quot;&quot;</span>

    <span class="s3"># options that are not propagated to the commands</span>
    <span class="s1">display_options = [</span>
        <span class="s1">(</span><span class="s4">'help-commands'</span><span class="s2">, None,</span>
         <span class="s4">&quot;list all available commands&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'name'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print package name&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'version'</span><span class="s2">, </span><span class="s4">'V'</span><span class="s2">,</span>
         <span class="s4">&quot;print package version&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'fullname'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print &lt;package name&gt;-&lt;version&gt;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'author'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the author's name&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'author-email'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the author's email address&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'maintainer'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the maintainer's name&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'maintainer-email'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the maintainer's email address&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'contact'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the maintainer's name if known, else the author's&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'contact-email'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the maintainer's email address if known, else the author's&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'url'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the URL for this package&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'license'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the license of the package&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'licence'</span><span class="s2">, None,</span>
         <span class="s4">&quot;alias for --license&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'description'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the package description&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'long-description'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the long package description&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'platforms'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the list of platforms&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'classifiers'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the list of classifiers&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'keywords'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the list of keywords&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'provides'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the list of packages/modules provided&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'requires'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the list of packages/modules required&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'obsoletes'</span><span class="s2">, None,</span>
         <span class="s4">&quot;print the list of packages/modules made obsolete&quot;</span><span class="s1">)</span>
        <span class="s1">]</span>
    <span class="s1">display_option_names = [translate_longopt(x[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">display_options]</span>

    <span class="s3"># negative options are options that exclude other options</span>
    <span class="s1">negative_opt = {</span><span class="s4">'quiet'</span><span class="s1">: </span><span class="s4">'verbose'</span><span class="s1">}</span>

    <span class="s3"># -- Creation/initialization methods -------------------------------</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">attrs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Construct a new Distribution instance: initialize all the 
        attributes of a Distribution, and then use 'attrs' (a dictionary 
        mapping attribute names to values) to assign some of those 
        attributes their &quot;real&quot; values.  (Any attributes not mentioned in 
        'attrs' will be assigned to some null value: 0, None, an empty list 
        or dictionary, etc.)  Most importantly, initialize the 
        'command_obj' attribute to the empty dictionary; this will be 
        filled in with real command objects by 'parse_command_line()'. 
        &quot;&quot;&quot;</span>

        <span class="s3"># Default values for our command-line options</span>
        <span class="s1">self.verbose = </span><span class="s5">1</span>
        <span class="s1">self.dry_run = </span><span class="s5">0</span>
        <span class="s1">self.help = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.display_option_names:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># Store the distribution meta-data (name, version, author, and so</span>
        <span class="s3"># forth) in a separate object -- we're getting to have enough</span>
        <span class="s3"># information here (and enough command-line options) that it's</span>
        <span class="s3"># worth it.  Also delegate 'get_XXX()' methods to the 'metadata'</span>
        <span class="s3"># object in a sneaky and underhanded (but efficient!) way.</span>
        <span class="s1">self.metadata = DistributionMetadata()</span>
        <span class="s2">for </span><span class="s1">basename </span><span class="s2">in </span><span class="s1">self.metadata._METHOD_BASENAMES:</span>
            <span class="s1">method_name = </span><span class="s4">&quot;get_&quot; </span><span class="s1">+ basename</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">method_name</span><span class="s2">, </span><span class="s1">getattr(self.metadata</span><span class="s2">, </span><span class="s1">method_name))</span>

        <span class="s3"># 'cmdclass' maps command names to class objects, so we</span>
        <span class="s3"># can 1) quickly figure out which class to instantiate when</span>
        <span class="s3"># we need to create a new command object, and 2) have a way</span>
        <span class="s3"># for the setup script to override command classes</span>
        <span class="s1">self.cmdclass = {}</span>

        <span class="s3"># 'command_packages' is a list of packages in which commands</span>
        <span class="s3"># are searched for.  The factory for command 'foo' is expected</span>
        <span class="s3"># to be named 'foo' in the module 'foo' in one of the packages</span>
        <span class="s3"># named here.  This list is searched from the left; an error</span>
        <span class="s3"># is raised if no named package provides the command being</span>
        <span class="s3"># searched for.  (Always access using get_command_packages().)</span>
        <span class="s1">self.command_packages = </span><span class="s2">None</span>

        <span class="s3"># 'script_name' and 'script_args' are usually set to sys.argv[0]</span>
        <span class="s3"># and sys.argv[1:], but they can be overridden when the caller is</span>
        <span class="s3"># not necessarily a setup script run from the command-line.</span>
        <span class="s1">self.script_name = </span><span class="s2">None</span>
        <span class="s1">self.script_args = </span><span class="s2">None</span>

        <span class="s3"># 'command_options' is where we store command options between</span>
        <span class="s3"># parsing them (from config files, the command-line, etc.) and when</span>
        <span class="s3"># they are actually needed -- ie. when the command in question is</span>
        <span class="s3"># instantiated.  It is a dictionary of dictionaries of 2-tuples:</span>
        <span class="s3">#   command_options = { command_name : { option : (source, value) } }</span>
        <span class="s1">self.command_options = {}</span>

        <span class="s3"># 'dist_files' is the list of (command, pyversion, file) that</span>
        <span class="s3"># have been created by any dist commands run so far. This is</span>
        <span class="s3"># filled regardless of whether the run is dry or not. pyversion</span>
        <span class="s3"># gives sysconfig.get_python_version() if the dist file is</span>
        <span class="s3"># specific to a Python version, 'any' if it is good for all</span>
        <span class="s3"># Python versions on the target platform, and '' for a source</span>
        <span class="s3"># file. pyversion should not be used to specify minimum or</span>
        <span class="s3"># maximum required Python versions; use the metainfo for that</span>
        <span class="s3"># instead.</span>
        <span class="s1">self.dist_files = []</span>

        <span class="s3"># These options are really the business of various commands, rather</span>
        <span class="s3"># than of the Distribution itself.  We provide aliases for them in</span>
        <span class="s3"># Distribution as a convenience to the developer.</span>
        <span class="s1">self.packages = </span><span class="s2">None</span>
        <span class="s1">self.package_data = {}</span>
        <span class="s1">self.package_dir = </span><span class="s2">None</span>
        <span class="s1">self.py_modules = </span><span class="s2">None</span>
        <span class="s1">self.libraries = </span><span class="s2">None</span>
        <span class="s1">self.headers = </span><span class="s2">None</span>
        <span class="s1">self.ext_modules = </span><span class="s2">None</span>
        <span class="s1">self.ext_package = </span><span class="s2">None</span>
        <span class="s1">self.include_dirs = </span><span class="s2">None</span>
        <span class="s1">self.extra_path = </span><span class="s2">None</span>
        <span class="s1">self.scripts = </span><span class="s2">None</span>
        <span class="s1">self.data_files = </span><span class="s2">None</span>
        <span class="s1">self.password = </span><span class="s4">''</span>

        <span class="s3"># And now initialize bookkeeping stuff that can't be supplied by</span>
        <span class="s3"># the caller at all.  'command_obj' maps command names to</span>
        <span class="s3"># Command instances -- that's how we enforce that every command</span>
        <span class="s3"># class is a singleton.</span>
        <span class="s1">self.command_obj = {}</span>

        <span class="s3"># 'have_run' maps command names to boolean values; it keeps track</span>
        <span class="s3"># of whether we have actually run a particular command, to make it</span>
        <span class="s3"># cheap to &quot;run&quot; a command whenever we think we might need to -- if</span>
        <span class="s3"># it's already been done, no need for expensive filesystem</span>
        <span class="s3"># operations, we just check the 'have_run' dictionary and carry on.</span>
        <span class="s3"># It's only safe to query 'have_run' for a command class that has</span>
        <span class="s3"># been instantiated -- a false value will be inserted when the</span>
        <span class="s3"># command object is created, and replaced with a true value when</span>
        <span class="s3"># the command is successfully run.  Thus it's probably best to use</span>
        <span class="s3"># '.get()' rather than a straight lookup.</span>
        <span class="s1">self.have_run = {}</span>

        <span class="s3"># Now we'll use the attrs dictionary (ultimately, keyword args from</span>
        <span class="s3"># the setup script) to possibly override any or all of these</span>
        <span class="s3"># distribution options.</span>

        <span class="s2">if </span><span class="s1">attrs:</span>
            <span class="s3"># Pull out the set of command options and work on them</span>
            <span class="s3"># specifically.  Note that this order guarantees that aliased</span>
            <span class="s3"># command options will override any supplied redundantly</span>
            <span class="s3"># through the general options dictionary.</span>
            <span class="s1">options = attrs.get(</span><span class="s4">'options'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">options </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">del </span><span class="s1">attrs[</span><span class="s4">'options'</span><span class="s1">]</span>
                <span class="s2">for </span><span class="s1">(command</span><span class="s2">, </span><span class="s1">cmd_options) </span><span class="s2">in </span><span class="s1">options.items():</span>
                    <span class="s1">opt_dict = self.get_option_dict(command)</span>
                    <span class="s2">for </span><span class="s1">(opt</span><span class="s2">, </span><span class="s1">val) </span><span class="s2">in </span><span class="s1">cmd_options.items():</span>
                        <span class="s1">opt_dict[opt] = (</span><span class="s4">&quot;setup script&quot;</span><span class="s2">, </span><span class="s1">val)</span>

            <span class="s2">if </span><span class="s4">'licence' </span><span class="s2">in </span><span class="s1">attrs:</span>
                <span class="s1">attrs[</span><span class="s4">'license'</span><span class="s1">] = attrs[</span><span class="s4">'licence'</span><span class="s1">]</span>
                <span class="s2">del </span><span class="s1">attrs[</span><span class="s4">'licence'</span><span class="s1">]</span>
                <span class="s1">msg = </span><span class="s4">&quot;'licence' distribution option is deprecated; use 'license'&quot;</span>
                <span class="s2">if </span><span class="s1">warnings </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(msg)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sys.stderr.write(msg + </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

            <span class="s3"># Now work on the rest of the attributes.  Any attribute that's</span>
            <span class="s3"># not already defined is invalid!</span>
            <span class="s2">for </span><span class="s1">(key</span><span class="s2">, </span><span class="s1">val) </span><span class="s2">in </span><span class="s1">attrs.items():</span>
                <span class="s2">if </span><span class="s1">hasattr(self.metadata</span><span class="s2">, </span><span class="s4">&quot;set_&quot; </span><span class="s1">+ key):</span>
                    <span class="s1">getattr(self.metadata</span><span class="s2">, </span><span class="s4">&quot;set_&quot; </span><span class="s1">+ key)(val)</span>
                <span class="s2">elif </span><span class="s1">hasattr(self.metadata</span><span class="s2">, </span><span class="s1">key):</span>
                    <span class="s1">setattr(self.metadata</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val)</span>
                <span class="s2">elif </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s1">key):</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s4">&quot;Unknown distribution option: %s&quot; </span><span class="s1">% repr(key)</span>
                    <span class="s1">warnings.warn(msg)</span>

        <span class="s3"># no-user-cfg is handled before other command line args</span>
        <span class="s3"># because other args override the config files, and this</span>
        <span class="s3"># one is needed before we can load the config files.</span>
        <span class="s3"># If attrs['script_args'] wasn't passed, assume false.</span>
        <span class="s3">#</span>
        <span class="s3"># This also make sure we just look at the global options</span>
        <span class="s1">self.want_user_cfg = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">self.script_args </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">self.script_args:</span>
                <span class="s2">if not </span><span class="s1">arg.startswith(</span><span class="s4">'-'</span><span class="s1">):</span>
                    <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">arg == </span><span class="s4">'--no-user-cfg'</span><span class="s1">:</span>
                    <span class="s1">self.want_user_cfg = </span><span class="s2">False</span>
                    <span class="s2">break</span>

        <span class="s1">self.finalize_options()</span>

    <span class="s2">def </span><span class="s1">get_option_dict(self</span><span class="s2">, </span><span class="s1">command):</span>
        <span class="s0">&quot;&quot;&quot;Get the option dictionary for a given command.  If that 
        command's option dictionary hasn't been created yet, then create it 
        and return the new dictionary; otherwise, return the existing 
        option dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s1">dict = self.command_options.get(command)</span>
        <span class="s2">if </span><span class="s1">dict </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dict = self.command_options[command] = {}</span>
        <span class="s2">return </span><span class="s1">dict</span>

    <span class="s2">def </span><span class="s1">dump_option_dicts(self</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">commands=</span><span class="s2">None, </span><span class="s1">indent=</span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
        <span class="s2">from </span><span class="s1">pprint </span><span class="s2">import </span><span class="s1">pformat</span>

        <span class="s2">if </span><span class="s1">commands </span><span class="s2">is None</span><span class="s1">:             </span><span class="s3"># dump all command option dicts</span>
            <span class="s1">commands = sorted(self.command_options.keys())</span>

        <span class="s2">if </span><span class="s1">header </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.announce(indent + header)</span>
            <span class="s1">indent = indent + </span><span class="s4">&quot;  &quot;</span>

        <span class="s2">if not </span><span class="s1">commands:</span>
            <span class="s1">self.announce(indent + </span><span class="s4">&quot;no commands known yet&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">commands:</span>
            <span class="s1">opt_dict = self.command_options.get(cmd_name)</span>
            <span class="s2">if </span><span class="s1">opt_dict </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.announce(indent +</span>
                              <span class="s4">&quot;no option dict for '%s' command&quot; </span><span class="s1">% cmd_name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.announce(indent +</span>
                              <span class="s4">&quot;option dict for '%s' command:&quot; </span><span class="s1">% cmd_name)</span>
                <span class="s1">out = pformat(opt_dict)</span>
                <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">out.split(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">):</span>
                    <span class="s1">self.announce(indent + </span><span class="s4">&quot;  &quot; </span><span class="s1">+ line)</span>

    <span class="s3"># -- Config file finding/parsing methods ---------------------------</span>

    <span class="s2">def </span><span class="s1">find_config_files(self):</span>
        <span class="s0">&quot;&quot;&quot;Find as many configuration files as should be processed for this 
        platform, and return a list of filenames in the order in which they 
        should be parsed.  The filenames returned are guaranteed to exist 
        (modulo nasty race conditions). 
 
        There are three possible config files: distutils.cfg in the 
        Distutils installation directory (ie. where the top-level 
        Distutils __inst__.py file lives), a file in the user's home 
        directory named .pydistutils.cfg on Unix and pydistutils.cfg 
        on Windows/Mac; and setup.cfg in the current directory. 
 
        The file in the user's home directory can be disabled with the 
        --no-user-cfg option. 
        &quot;&quot;&quot;</span>
        <span class="s1">files = []</span>
        <span class="s1">check_environ()</span>

        <span class="s3"># Where to look for the system-wide Distutils config file</span>
        <span class="s1">sys_dir = os.path.dirname(sys.modules[</span><span class="s4">'distutils'</span><span class="s1">].__file__)</span>

        <span class="s3"># Look for the system config file</span>
        <span class="s1">sys_file = os.path.join(sys_dir</span><span class="s2">, </span><span class="s4">&quot;distutils.cfg&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(sys_file):</span>
            <span class="s1">files.append(sys_file)</span>

        <span class="s3"># What to call the per-user config file</span>
        <span class="s2">if </span><span class="s1">os.name == </span><span class="s4">'posix'</span><span class="s1">:</span>
            <span class="s1">user_filename = </span><span class="s4">&quot;.pydistutils.cfg&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">user_filename = </span><span class="s4">&quot;pydistutils.cfg&quot;</span>

        <span class="s3"># And look for the user config file</span>
        <span class="s2">if </span><span class="s1">self.want_user_cfg:</span>
            <span class="s1">user_file = os.path.join(os.path.expanduser(</span><span class="s4">'~'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">user_filename)</span>
            <span class="s2">if </span><span class="s1">os.path.isfile(user_file):</span>
                <span class="s1">files.append(user_file)</span>

        <span class="s3"># All platforms support local setup.cfg</span>
        <span class="s1">local_file = </span><span class="s4">&quot;setup.cfg&quot;</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(local_file):</span>
            <span class="s1">files.append(local_file)</span>

        <span class="s2">if </span><span class="s1">DEBUG:</span>
            <span class="s1">self.announce(</span><span class="s4">&quot;using config files: %s&quot; </span><span class="s1">% </span><span class="s4">', '</span><span class="s1">.join(files))</span>

        <span class="s2">return </span><span class="s1">files</span>

    <span class="s2">def </span><span class="s1">parse_config_files(self</span><span class="s2">, </span><span class="s1">filenames=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">from </span><span class="s1">configparser </span><span class="s2">import </span><span class="s1">ConfigParser</span>

        <span class="s3"># Ignore install directory options if we have a venv</span>
        <span class="s2">if </span><span class="s1">sys.prefix != sys.base_prefix:</span>
            <span class="s1">ignore_options = [</span>
                <span class="s4">'install-base'</span><span class="s2">, </span><span class="s4">'install-platbase'</span><span class="s2">, </span><span class="s4">'install-lib'</span><span class="s2">,</span>
                <span class="s4">'install-platlib'</span><span class="s2">, </span><span class="s4">'install-purelib'</span><span class="s2">, </span><span class="s4">'install-headers'</span><span class="s2">,</span>
                <span class="s4">'install-scripts'</span><span class="s2">, </span><span class="s4">'install-data'</span><span class="s2">, </span><span class="s4">'prefix'</span><span class="s2">, </span><span class="s4">'exec-prefix'</span><span class="s2">,</span>
                <span class="s4">'home'</span><span class="s2">, </span><span class="s4">'user'</span><span class="s2">, </span><span class="s4">'root'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ignore_options = []</span>

        <span class="s1">ignore_options = frozenset(ignore_options)</span>

        <span class="s2">if </span><span class="s1">filenames </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">filenames = self.find_config_files()</span>

        <span class="s2">if </span><span class="s1">DEBUG:</span>
            <span class="s1">self.announce(</span><span class="s4">&quot;Distribution.parse_config_files():&quot;</span><span class="s1">)</span>

        <span class="s1">parser = ConfigParser()</span>
        <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames:</span>
            <span class="s2">if </span><span class="s1">DEBUG:</span>
                <span class="s1">self.announce(</span><span class="s4">&quot;  reading %s&quot; </span><span class="s1">% filename)</span>
            <span class="s1">parser.read(filename)</span>
            <span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">parser.sections():</span>
                <span class="s1">options = parser.options(section)</span>
                <span class="s1">opt_dict = self.get_option_dict(section)</span>

                <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">options:</span>
                    <span class="s2">if </span><span class="s1">opt != </span><span class="s4">'__name__' </span><span class="s2">and </span><span class="s1">opt </span><span class="s2">not in </span><span class="s1">ignore_options:</span>
                        <span class="s1">val = parser.get(section</span><span class="s2">,</span><span class="s1">opt)</span>
                        <span class="s1">opt = opt.replace(</span><span class="s4">'-'</span><span class="s2">, </span><span class="s4">'_'</span><span class="s1">)</span>
                        <span class="s1">opt_dict[opt] = (filename</span><span class="s2">, </span><span class="s1">val)</span>

            <span class="s3"># Make the ConfigParser forget everything (so we retain</span>
            <span class="s3"># the original filenames that options come from)</span>
            <span class="s1">parser.__init__()</span>

        <span class="s3"># If there was a &quot;global&quot; section in the config file, use it</span>
        <span class="s3"># to set Distribution options.</span>

        <span class="s2">if </span><span class="s4">'global' </span><span class="s2">in </span><span class="s1">self.command_options:</span>
            <span class="s2">for </span><span class="s1">(opt</span><span class="s2">, </span><span class="s1">(src</span><span class="s2">, </span><span class="s1">val)) </span><span class="s2">in </span><span class="s1">self.command_options[</span><span class="s4">'global'</span><span class="s1">].items():</span>
                <span class="s1">alias = self.negative_opt.get(opt)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">alias:</span>
                        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, not </span><span class="s1">strtobool(val))</span>
                    <span class="s2">elif </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'verbose'</span><span class="s2">, </span><span class="s4">'dry_run'</span><span class="s1">): </span><span class="s3"># ugh!</span>
                        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">opt</span><span class="s2">, </span><span class="s1">strtobool(val))</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">opt</span><span class="s2">, </span><span class="s1">val)</span>
                <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">msg:</span>
                    <span class="s2">raise </span><span class="s1">DistutilsOptionError(msg)</span>

    <span class="s3"># -- Command-line parsing methods ----------------------------------</span>

    <span class="s2">def </span><span class="s1">parse_command_line(self):</span>
        <span class="s0">&quot;&quot;&quot;Parse the setup script's command line, taken from the 
        'script_args' instance attribute (which defaults to 'sys.argv[1:]' 
        -- see 'setup()' in core.py).  This list is first processed for 
        &quot;global options&quot; -- options that set attributes of the Distribution 
        instance.  Then, it is alternately scanned for Distutils commands 
        and options for that command.  Each new command terminates the 
        options for the previous command.  The allowed options for a 
        command are determined by the 'user_options' attribute of the 
        command class -- thus, we have to be able to load command classes 
        in order to parse the command line.  Any error in that 'options' 
        attribute raises DistutilsGetoptError; any error on the 
        command-line raises DistutilsArgError.  If no Distutils commands 
        were found on the command line, raises DistutilsArgError.  Return 
        true if command-line was successfully parsed and we should carry 
        on with executing commands; false if no errors but we shouldn't 
        execute commands (currently, this only happens if user asks for 
        help). 
        &quot;&quot;&quot;</span>
        <span class="s3">#</span>
        <span class="s3"># We now have enough information to show the Macintosh dialog</span>
        <span class="s3"># that allows the user to interactively specify the &quot;command line&quot;.</span>
        <span class="s3">#</span>
        <span class="s1">toplevel_options = self._get_toplevel_options()</span>

        <span class="s3"># We have to parse the command line a bit at a time -- global</span>
        <span class="s3"># options, then the first command, then its options, and so on --</span>
        <span class="s3"># because each command will be handled by a different class, and</span>
        <span class="s3"># the options that are valid for a particular class aren't known</span>
        <span class="s3"># until we have loaded the command class, which doesn't happen</span>
        <span class="s3"># until we know what the command is.</span>

        <span class="s1">self.commands = []</span>
        <span class="s1">parser = FancyGetopt(toplevel_options + self.display_options)</span>
        <span class="s1">parser.set_negative_aliases(self.negative_opt)</span>
        <span class="s1">parser.set_aliases({</span><span class="s4">'licence'</span><span class="s1">: </span><span class="s4">'license'</span><span class="s1">})</span>
        <span class="s1">args = parser.getopt(args=self.script_args</span><span class="s2">, </span><span class="s1">object=self)</span>
        <span class="s1">option_order = parser.get_option_order()</span>
        <span class="s1">log.set_verbosity(self.verbose)</span>

        <span class="s3"># for display options we return immediately</span>
        <span class="s2">if </span><span class="s1">self.handle_display_options(option_order):</span>
            <span class="s2">return</span>
        <span class="s2">while </span><span class="s1">args:</span>
            <span class="s1">args = self._parse_command_opts(parser</span><span class="s2">, </span><span class="s1">args)</span>
            <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:            </span><span class="s3"># user asked for help (and got it)</span>
                <span class="s2">return</span>

        <span class="s3"># Handle the cases of --help as a &quot;global&quot; option, ie.</span>
        <span class="s3"># &quot;setup.py --help&quot; and &quot;setup.py --help command ...&quot;.  For the</span>
        <span class="s3"># former, we show global options (--verbose, --dry-run, etc.)</span>
        <span class="s3"># and display-only options (--name, --version, etc.); for the</span>
        <span class="s3"># latter, we omit the display-only options and show help for</span>
        <span class="s3"># each command listed on the command line.</span>
        <span class="s2">if </span><span class="s1">self.help:</span>
            <span class="s1">self._show_help(parser</span><span class="s2">,</span>
                            <span class="s1">display_options=len(self.commands) == </span><span class="s5">0</span><span class="s2">,</span>
                            <span class="s1">commands=self.commands)</span>
            <span class="s2">return</span>

        <span class="s3"># Oops, no commands found -- an end-user error</span>
        <span class="s2">if not </span><span class="s1">self.commands:</span>
            <span class="s2">raise </span><span class="s1">DistutilsArgError(</span><span class="s4">&quot;no commands supplied&quot;</span><span class="s1">)</span>

        <span class="s3"># All is well: return true</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_get_toplevel_options(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the non-display options recognized at the top level. 
 
        This includes options that are recognized *only* at the top 
        level as well as options recognized for commands. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.global_options + [</span>
            <span class="s1">(</span><span class="s4">&quot;command-packages=&quot;</span><span class="s2">, None,</span>
             <span class="s4">&quot;list of packages that provide distutils commands&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_parse_command_opts(self</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s0">&quot;&quot;&quot;Parse the command-line options for a single command. 
        'parser' must be a FancyGetopt instance; 'args' must be the list 
        of arguments, starting with the current command (whose options 
        we are about to parse).  Returns a new version of 'args' with 
        the next command at the front of the list; will be the empty 
        list if there are no more commands on the command line.  Returns 
        None if the user asked for help on this command. 
        &quot;&quot;&quot;</span>
        <span class="s3"># late import because of mutual dependence between these modules</span>
        <span class="s2">from </span><span class="s1">distutils.cmd </span><span class="s2">import </span><span class="s1">Command</span>

        <span class="s3"># Pull the current command from the head of the command line</span>
        <span class="s1">command = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">command_re.match(command):</span>
            <span class="s2">raise </span><span class="s1">SystemExit(</span><span class="s4">&quot;invalid command name '%s'&quot; </span><span class="s1">% command)</span>
        <span class="s1">self.commands.append(command)</span>

        <span class="s3"># Dig up the command class that implements this command, so we</span>
        <span class="s3"># 1) know that it's a valid command, and 2) know which options</span>
        <span class="s3"># it takes.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">cmd_class = self.get_command_class(command)</span>
        <span class="s2">except </span><span class="s1">DistutilsModuleError </span><span class="s2">as </span><span class="s1">msg:</span>
            <span class="s2">raise </span><span class="s1">DistutilsArgError(msg)</span>

        <span class="s3"># Require that the command class be derived from Command -- want</span>
        <span class="s3"># to be sure that the basic &quot;command&quot; interface is implemented.</span>
        <span class="s2">if not </span><span class="s1">issubclass(cmd_class</span><span class="s2">, </span><span class="s1">Command):</span>
            <span class="s2">raise </span><span class="s1">DistutilsClassError(</span>
                <span class="s4">&quot;command class %s must subclass Command&quot; </span><span class="s1">% cmd_class)</span>

        <span class="s3"># Also make sure that the command object provides a list of its</span>
        <span class="s3"># known options.</span>
        <span class="s2">if not </span><span class="s1">(hasattr(cmd_class</span><span class="s2">, </span><span class="s4">'user_options'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">isinstance(cmd_class.user_options</span><span class="s2">, </span><span class="s1">list)):</span>
            <span class="s1">msg = (</span><span class="s4">&quot;command class %s must provide &quot;</span>
                <span class="s4">&quot;'user_options' attribute (a list of tuples)&quot;</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">DistutilsClassError(msg % cmd_class)</span>

        <span class="s3"># If the command class has a list of negative alias options,</span>
        <span class="s3"># merge it in with the global negative aliases.</span>
        <span class="s1">negative_opt = self.negative_opt</span>
        <span class="s2">if </span><span class="s1">hasattr(cmd_class</span><span class="s2">, </span><span class="s4">'negative_opt'</span><span class="s1">):</span>
            <span class="s1">negative_opt = negative_opt.copy()</span>
            <span class="s1">negative_opt.update(cmd_class.negative_opt)</span>

        <span class="s3"># Check for help_options in command class.  They have a different</span>
        <span class="s3"># format (tuple of four) so we need to preprocess them here.</span>
        <span class="s2">if </span><span class="s1">(hasattr(cmd_class</span><span class="s2">, </span><span class="s4">'help_options'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">isinstance(cmd_class.help_options</span><span class="s2">, </span><span class="s1">list)):</span>
            <span class="s1">help_options = fix_help_options(cmd_class.help_options)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">help_options = []</span>

        <span class="s3"># All commands support the global options too, just by adding</span>
        <span class="s3"># in 'global_options'.</span>
        <span class="s1">parser.set_option_table(self.global_options +</span>
                                <span class="s1">cmd_class.user_options +</span>
                                <span class="s1">help_options)</span>
        <span class="s1">parser.set_negative_aliases(negative_opt)</span>
        <span class="s1">(args</span><span class="s2">, </span><span class="s1">opts) = parser.getopt(args[</span><span class="s5">1</span><span class="s1">:])</span>
        <span class="s2">if </span><span class="s1">hasattr(opts</span><span class="s2">, </span><span class="s4">'help'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">opts.help:</span>
            <span class="s1">self._show_help(parser</span><span class="s2">, </span><span class="s1">display_options=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">commands=[cmd_class])</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">(hasattr(cmd_class</span><span class="s2">, </span><span class="s4">'help_options'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">isinstance(cmd_class.help_options</span><span class="s2">, </span><span class="s1">list)):</span>
            <span class="s1">help_option_found=</span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">(help_option</span><span class="s2">, </span><span class="s1">short</span><span class="s2">, </span><span class="s1">desc</span><span class="s2">, </span><span class="s1">func) </span><span class="s2">in </span><span class="s1">cmd_class.help_options:</span>
                <span class="s2">if </span><span class="s1">hasattr(opts</span><span class="s2">, </span><span class="s1">parser.get_attr_name(help_option)):</span>
                    <span class="s1">help_option_found=</span><span class="s5">1</span>
                    <span class="s2">if </span><span class="s1">callable(func):</span>
                        <span class="s1">func()</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">DistutilsClassError(</span>
                            <span class="s4">&quot;invalid help function %r for help option '%s': &quot;</span>
                            <span class="s4">&quot;must be a callable object (function, etc.)&quot;</span>
                            <span class="s1">% (func</span><span class="s2">, </span><span class="s1">help_option))</span>

            <span class="s2">if </span><span class="s1">help_option_found:</span>
                <span class="s2">return</span>

        <span class="s3"># Put the options from the command-line into their official</span>
        <span class="s3"># holding pen, the 'command_options' dictionary.</span>
        <span class="s1">opt_dict = self.get_option_dict(command)</span>
        <span class="s2">for </span><span class="s1">(name</span><span class="s2">, </span><span class="s1">value) </span><span class="s2">in </span><span class="s1">vars(opts).items():</span>
            <span class="s1">opt_dict[name] = (</span><span class="s4">&quot;command line&quot;</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s2">return </span><span class="s1">args</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s0">&quot;&quot;&quot;Set final values for all the options on the Distribution 
        instance, analogous to the .finalize_options() method of Command 
        objects. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'keywords'</span><span class="s2">, </span><span class="s4">'platforms'</span><span class="s1">):</span>
            <span class="s1">value = getattr(self.metadata</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">value = [elm.strip() </span><span class="s2">for </span><span class="s1">elm </span><span class="s2">in </span><span class="s1">value.split(</span><span class="s4">','</span><span class="s1">)]</span>
                <span class="s1">setattr(self.metadata</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s2">def </span><span class="s1">_show_help(self</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">, </span><span class="s1">global_options=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">display_options=</span><span class="s5">1</span><span class="s2">,</span>
                   <span class="s1">commands=[]):</span>
        <span class="s0">&quot;&quot;&quot;Show help for the setup script command-line in the form of 
        several lists of command-line options.  'parser' should be a 
        FancyGetopt instance; do not expect it to be returned in the 
        same state, as its option table will be reset to make it 
        generate the correct help text. 
 
        If 'global_options' is true, lists the global options: 
        --verbose, --dry-run, etc.  If 'display_options' is true, lists 
        the &quot;display-only&quot; options: --name, --version, etc.  Finally, 
        lists per-command help for every command name or command class 
        in 'commands'. 
        &quot;&quot;&quot;</span>
        <span class="s3"># late import because of mutual dependence between these modules</span>
        <span class="s2">from </span><span class="s1">distutils.core </span><span class="s2">import </span><span class="s1">gen_usage</span>
        <span class="s2">from </span><span class="s1">distutils.cmd </span><span class="s2">import </span><span class="s1">Command</span>

        <span class="s2">if </span><span class="s1">global_options:</span>
            <span class="s2">if </span><span class="s1">display_options:</span>
                <span class="s1">options = self._get_toplevel_options()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">options = self.global_options</span>
            <span class="s1">parser.set_option_table(options)</span>
            <span class="s1">parser.print_help(self.common_usage + </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">Global options:&quot;</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">display_options:</span>
            <span class="s1">parser.set_option_table(self.display_options)</span>
            <span class="s1">parser.print_help(</span>
                <span class="s4">&quot;Information display options (just display &quot; </span><span class="s1">+</span>
                <span class="s4">&quot;information, ignore any commands)&quot;</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">command </span><span class="s2">in </span><span class="s1">self.commands:</span>
            <span class="s2">if </span><span class="s1">isinstance(command</span><span class="s2">, </span><span class="s1">type) </span><span class="s2">and </span><span class="s1">issubclass(command</span><span class="s2">, </span><span class="s1">Command):</span>
                <span class="s1">klass = command</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">klass = self.get_command_class(command)</span>
            <span class="s2">if </span><span class="s1">(hasattr(klass</span><span class="s2">, </span><span class="s4">'help_options'</span><span class="s1">) </span><span class="s2">and</span>
                    <span class="s1">isinstance(klass.help_options</span><span class="s2">, </span><span class="s1">list)):</span>
                <span class="s1">parser.set_option_table(klass.user_options +</span>
                                        <span class="s1">fix_help_options(klass.help_options))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">parser.set_option_table(klass.user_options)</span>
            <span class="s1">parser.print_help(</span><span class="s4">&quot;Options for '%s' command:&quot; </span><span class="s1">% klass.__name__)</span>
            <span class="s1">print(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s1">print(gen_usage(self.script_name))</span>

    <span class="s2">def </span><span class="s1">handle_display_options(self</span><span class="s2">, </span><span class="s1">option_order):</span>
        <span class="s0">&quot;&quot;&quot;If there were any non-global &quot;display-only&quot; options 
        (--help-commands or the metadata display options) on the command 
        line, display the requested info and return true; else return 
        false. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">distutils.core </span><span class="s2">import </span><span class="s1">gen_usage</span>

        <span class="s3"># User just wants a list of commands -- we'll print it out and stop</span>
        <span class="s3"># processing now (ie. if they ran &quot;setup --help-commands foo bar&quot;,</span>
        <span class="s3"># we ignore &quot;foo bar&quot;).</span>
        <span class="s2">if </span><span class="s1">self.help_commands:</span>
            <span class="s1">self.print_commands()</span>
            <span class="s1">print(</span><span class="s4">''</span><span class="s1">)</span>
            <span class="s1">print(gen_usage(self.script_name))</span>
            <span class="s2">return </span><span class="s5">1</span>

        <span class="s3"># If user supplied any of the &quot;display metadata&quot; options, then</span>
        <span class="s3"># display that metadata in the order in which the user supplied the</span>
        <span class="s3"># metadata options.</span>
        <span class="s1">any_display_options = </span><span class="s5">0</span>
        <span class="s1">is_display_option = {}</span>
        <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">self.display_options:</span>
            <span class="s1">is_display_option[option[</span><span class="s5">0</span><span class="s1">]] = </span><span class="s5">1</span>

        <span class="s2">for </span><span class="s1">(opt</span><span class="s2">, </span><span class="s1">val) </span><span class="s2">in </span><span class="s1">option_order:</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">and </span><span class="s1">is_display_option.get(opt):</span>
                <span class="s1">opt = translate_longopt(opt)</span>
                <span class="s1">value = getattr(self.metadata</span><span class="s2">, </span><span class="s4">&quot;get_&quot;</span><span class="s1">+opt)()</span>
                <span class="s2">if </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'keywords'</span><span class="s2">, </span><span class="s4">'platforms'</span><span class="s1">]:</span>
                    <span class="s1">print(</span><span class="s4">','</span><span class="s1">.join(value))</span>
                <span class="s2">elif </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'classifiers'</span><span class="s2">, </span><span class="s4">'provides'</span><span class="s2">, </span><span class="s4">'requires'</span><span class="s2">,</span>
                             <span class="s4">'obsoletes'</span><span class="s1">):</span>
                    <span class="s1">print(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(value))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">print(value)</span>
                <span class="s1">any_display_options = </span><span class="s5">1</span>

        <span class="s2">return </span><span class="s1">any_display_options</span>

    <span class="s2">def </span><span class="s1">print_command_list(self</span><span class="s2">, </span><span class="s1">commands</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">max_length):</span>
        <span class="s0">&quot;&quot;&quot;Print a subset of the list of all commands -- used by 
        'print_commands()'. 
        &quot;&quot;&quot;</span>
        <span class="s1">print(header + </span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">commands:</span>
            <span class="s1">klass = self.cmdclass.get(cmd)</span>
            <span class="s2">if not </span><span class="s1">klass:</span>
                <span class="s1">klass = self.get_command_class(cmd)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">description = klass.description</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">description = </span><span class="s4">&quot;(no description available)&quot;</span>

            <span class="s1">print(</span><span class="s4">&quot;  %-*s  %s&quot; </span><span class="s1">% (max_length</span><span class="s2">, </span><span class="s1">cmd</span><span class="s2">, </span><span class="s1">description))</span>

    <span class="s2">def </span><span class="s1">print_commands(self):</span>
        <span class="s0">&quot;&quot;&quot;Print out a help message listing all available commands with a 
        description of each.  The list is divided into &quot;standard commands&quot; 
        (listed in distutils.command.__all__) and &quot;extra commands&quot; 
        (mentioned in self.cmdclass, but not a standard command).  The 
        descriptions come from the command class attribute 
        'description'. 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">distutils.command</span>
        <span class="s1">std_commands = distutils.command.__all__</span>
        <span class="s1">is_std = {}</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">std_commands:</span>
            <span class="s1">is_std[cmd] = </span><span class="s5">1</span>

        <span class="s1">extra_commands = []</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">self.cmdclass.keys():</span>
            <span class="s2">if not </span><span class="s1">is_std.get(cmd):</span>
                <span class="s1">extra_commands.append(cmd)</span>

        <span class="s1">max_length = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">(std_commands + extra_commands):</span>
            <span class="s2">if </span><span class="s1">len(cmd) &gt; max_length:</span>
                <span class="s1">max_length = len(cmd)</span>

        <span class="s1">self.print_command_list(std_commands</span><span class="s2">,</span>
                                <span class="s4">&quot;Standard commands&quot;</span><span class="s2">,</span>
                                <span class="s1">max_length)</span>
        <span class="s2">if </span><span class="s1">extra_commands:</span>
            <span class="s1">print()</span>
            <span class="s1">self.print_command_list(extra_commands</span><span class="s2">,</span>
                                    <span class="s4">&quot;Extra commands&quot;</span><span class="s2">,</span>
                                    <span class="s1">max_length)</span>

    <span class="s2">def </span><span class="s1">get_command_list(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of (command, description) tuples. 
        The list is divided into &quot;standard commands&quot; (listed in 
        distutils.command.__all__) and &quot;extra commands&quot; (mentioned in 
        self.cmdclass, but not a standard command).  The descriptions come 
        from the command class attribute 'description'. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Currently this is only used on Mac OS, for the Mac-only GUI</span>
        <span class="s3"># Distutils interface (by Jack Jansen)</span>
        <span class="s2">import </span><span class="s1">distutils.command</span>
        <span class="s1">std_commands = distutils.command.__all__</span>
        <span class="s1">is_std = {}</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">std_commands:</span>
            <span class="s1">is_std[cmd] = </span><span class="s5">1</span>

        <span class="s1">extra_commands = []</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">self.cmdclass.keys():</span>
            <span class="s2">if not </span><span class="s1">is_std.get(cmd):</span>
                <span class="s1">extra_commands.append(cmd)</span>

        <span class="s1">rv = []</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">(std_commands + extra_commands):</span>
            <span class="s1">klass = self.cmdclass.get(cmd)</span>
            <span class="s2">if not </span><span class="s1">klass:</span>
                <span class="s1">klass = self.get_command_class(cmd)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">description = klass.description</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">description = </span><span class="s4">&quot;(no description available)&quot;</span>
            <span class="s1">rv.append((cmd</span><span class="s2">, </span><span class="s1">description))</span>
        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s3"># -- Command class/object methods ----------------------------------</span>

    <span class="s2">def </span><span class="s1">get_command_packages(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a list of packages from which commands are loaded.&quot;&quot;&quot;</span>
        <span class="s1">pkgs = self.command_packages</span>
        <span class="s2">if not </span><span class="s1">isinstance(pkgs</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s2">if </span><span class="s1">pkgs </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">pkgs = </span><span class="s4">''</span>
            <span class="s1">pkgs = [pkg.strip() </span><span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">pkgs.split(</span><span class="s4">','</span><span class="s1">) </span><span class="s2">if </span><span class="s1">pkg != </span><span class="s4">''</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s4">&quot;distutils.command&quot; </span><span class="s2">not in </span><span class="s1">pkgs:</span>
                <span class="s1">pkgs.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s4">&quot;distutils.command&quot;</span><span class="s1">)</span>
            <span class="s1">self.command_packages = pkgs</span>
        <span class="s2">return </span><span class="s1">pkgs</span>

    <span class="s2">def </span><span class="s1">get_command_class(self</span><span class="s2">, </span><span class="s1">command):</span>
        <span class="s0">&quot;&quot;&quot;Return the class that implements the Distutils command named by 
        'command'.  First we check the 'cmdclass' dictionary; if the 
        command is mentioned there, we fetch the class object from the 
        dictionary and return it.  Otherwise we load the command module 
        (&quot;distutils.command.&quot; + command) and fetch the command class from 
        the module.  The loaded class is also stored in 'cmdclass' 
        to speed future calls to 'get_command_class()'. 
 
        Raises DistutilsModuleError if the expected module could not be 
        found, or if that module does not define the expected class. 
        &quot;&quot;&quot;</span>
        <span class="s1">klass = self.cmdclass.get(command)</span>
        <span class="s2">if </span><span class="s1">klass:</span>
            <span class="s2">return </span><span class="s1">klass</span>

        <span class="s2">for </span><span class="s1">pkgname </span><span class="s2">in </span><span class="s1">self.get_command_packages():</span>
            <span class="s1">module_name = </span><span class="s4">&quot;%s.%s&quot; </span><span class="s1">% (pkgname</span><span class="s2">, </span><span class="s1">command)</span>
            <span class="s1">klass_name = command</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">__import__(module_name)</span>
                <span class="s1">module = sys.modules[module_name]</span>
            <span class="s2">except </span><span class="s1">ImportError:</span>
                <span class="s2">continue</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">klass = getattr(module</span><span class="s2">, </span><span class="s1">klass_name)</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">raise </span><span class="s1">DistutilsModuleError(</span>
                    <span class="s4">&quot;invalid command '%s' (no class '%s' in module '%s')&quot;</span>
                    <span class="s1">% (command</span><span class="s2">, </span><span class="s1">klass_name</span><span class="s2">, </span><span class="s1">module_name))</span>

            <span class="s1">self.cmdclass[command] = klass</span>
            <span class="s2">return </span><span class="s1">klass</span>

        <span class="s2">raise </span><span class="s1">DistutilsModuleError(</span><span class="s4">&quot;invalid command '%s'&quot; </span><span class="s1">% command)</span>

    <span class="s2">def </span><span class="s1">get_command_obj(self</span><span class="s2">, </span><span class="s1">command</span><span class="s2">, </span><span class="s1">create=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return the command object for 'command'.  Normally this object 
        is cached on a previous call to 'get_command_obj()'; if no command 
        object for 'command' is in the cache, then we either create and 
        return it (if 'create' is true) or return None. 
        &quot;&quot;&quot;</span>
        <span class="s1">cmd_obj = self.command_obj.get(command)</span>
        <span class="s2">if not </span><span class="s1">cmd_obj </span><span class="s2">and </span><span class="s1">create:</span>
            <span class="s2">if </span><span class="s1">DEBUG:</span>
                <span class="s1">self.announce(</span><span class="s4">&quot;Distribution.get_command_obj(): &quot;</span>
                              <span class="s4">&quot;creating '%s' command object&quot; </span><span class="s1">% command)</span>

            <span class="s1">klass = self.get_command_class(command)</span>
            <span class="s1">cmd_obj = self.command_obj[command] = klass(self)</span>
            <span class="s1">self.have_run[command] = </span><span class="s5">0</span>

            <span class="s3"># Set any options that were supplied in config files</span>
            <span class="s3"># or on the command line.  (NB. support for error</span>
            <span class="s3"># reporting is lame here: any errors aren't reported</span>
            <span class="s3"># until 'finalize_options()' is called, which means</span>
            <span class="s3"># we won't report the source of the error.)</span>
            <span class="s1">options = self.command_options.get(command)</span>
            <span class="s2">if </span><span class="s1">options:</span>
                <span class="s1">self._set_command_options(cmd_obj</span><span class="s2">, </span><span class="s1">options)</span>

        <span class="s2">return </span><span class="s1">cmd_obj</span>

    <span class="s2">def </span><span class="s1">_set_command_options(self</span><span class="s2">, </span><span class="s1">command_obj</span><span class="s2">, </span><span class="s1">option_dict=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set the options for 'command_obj' from 'option_dict'.  Basically 
        this means copying elements of a dictionary ('option_dict') to 
        attributes of an instance ('command'). 
 
        'command_obj' must be a Command instance.  If 'option_dict' is not 
        supplied, uses the standard option dictionary for this command 
        (from 'self.command_options'). 
        &quot;&quot;&quot;</span>
        <span class="s1">command_name = command_obj.get_command_name()</span>
        <span class="s2">if </span><span class="s1">option_dict </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">option_dict = self.get_option_dict(command_name)</span>

        <span class="s2">if </span><span class="s1">DEBUG:</span>
            <span class="s1">self.announce(</span><span class="s4">&quot;  setting options for '%s' command:&quot; </span><span class="s1">% command_name)</span>
        <span class="s2">for </span><span class="s1">(option</span><span class="s2">, </span><span class="s1">(source</span><span class="s2">, </span><span class="s1">value)) </span><span class="s2">in </span><span class="s1">option_dict.items():</span>
            <span class="s2">if </span><span class="s1">DEBUG:</span>
                <span class="s1">self.announce(</span><span class="s4">&quot;    %s = %s (from %s)&quot; </span><span class="s1">% (option</span><span class="s2">, </span><span class="s1">value</span><span class="s2">,</span>
                                                         <span class="s1">source))</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">bool_opts = [translate_longopt(o)</span>
                             <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">command_obj.boolean_options]</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">bool_opts = []</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">neg_opt = command_obj.negative_opt</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">neg_opt = {}</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">is_string = isinstance(value</span><span class="s2">, </span><span class="s1">str)</span>
                <span class="s2">if </span><span class="s1">option </span><span class="s2">in </span><span class="s1">neg_opt </span><span class="s2">and </span><span class="s1">is_string:</span>
                    <span class="s1">setattr(command_obj</span><span class="s2">, </span><span class="s1">neg_opt[option]</span><span class="s2">, not </span><span class="s1">strtobool(value))</span>
                <span class="s2">elif </span><span class="s1">option </span><span class="s2">in </span><span class="s1">bool_opts </span><span class="s2">and </span><span class="s1">is_string:</span>
                    <span class="s1">setattr(command_obj</span><span class="s2">, </span><span class="s1">option</span><span class="s2">, </span><span class="s1">strtobool(value))</span>
                <span class="s2">elif </span><span class="s1">hasattr(command_obj</span><span class="s2">, </span><span class="s1">option):</span>
                    <span class="s1">setattr(command_obj</span><span class="s2">, </span><span class="s1">option</span><span class="s2">, </span><span class="s1">value)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                        <span class="s4">&quot;error in %s: command '%s' has no such option '%s'&quot;</span>
                        <span class="s1">% (source</span><span class="s2">, </span><span class="s1">command_name</span><span class="s2">, </span><span class="s1">option))</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">msg:</span>
                <span class="s2">raise </span><span class="s1">DistutilsOptionError(msg)</span>

    <span class="s2">def </span><span class="s1">reinitialize_command(self</span><span class="s2">, </span><span class="s1">command</span><span class="s2">, </span><span class="s1">reinit_subcommands=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Reinitializes a command to the state it was in when first 
        returned by 'get_command_obj()': ie., initialized but not yet 
        finalized.  This provides the opportunity to sneak option 
        values in programmatically, overriding or supplementing 
        user-supplied values from the config files and command line. 
        You'll have to re-finalize the command object (by calling 
        'finalize_options()' or 'ensure_finalized()') before using it for 
        real. 
 
        'command' should be a command name (string) or command object.  If 
        'reinit_subcommands' is true, also reinitializes the command's 
        sub-commands, as declared by the 'sub_commands' class attribute (if 
        it has one).  See the &quot;install&quot; command for an example.  Only 
        reinitializes the sub-commands that actually matter, ie. those 
        whose test predicates return true. 
 
        Returns the reinitialized command object. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">distutils.cmd </span><span class="s2">import </span><span class="s1">Command</span>
        <span class="s2">if not </span><span class="s1">isinstance(command</span><span class="s2">, </span><span class="s1">Command):</span>
            <span class="s1">command_name = command</span>
            <span class="s1">command = self.get_command_obj(command_name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">command_name = command.get_command_name()</span>

        <span class="s2">if not </span><span class="s1">command.finalized:</span>
            <span class="s2">return </span><span class="s1">command</span>
        <span class="s1">command.initialize_options()</span>
        <span class="s1">command.finalized = </span><span class="s5">0</span>
        <span class="s1">self.have_run[command_name] = </span><span class="s5">0</span>
        <span class="s1">self._set_command_options(command)</span>

        <span class="s2">if </span><span class="s1">reinit_subcommands:</span>
            <span class="s2">for </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">command.get_sub_commands():</span>
                <span class="s1">self.reinitialize_command(sub</span><span class="s2">, </span><span class="s1">reinit_subcommands)</span>

        <span class="s2">return </span><span class="s1">command</span>

    <span class="s3"># -- Methods that operate on the Distribution ----------------------</span>

    <span class="s2">def </span><span class="s1">announce(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">level=log.INFO):</span>
        <span class="s1">log.log(level</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">run_commands(self):</span>
        <span class="s0">&quot;&quot;&quot;Run each command that was seen on the setup script command line. 
        Uses the list of commands found and cache of command objects 
        created by 'get_command_obj()'. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">self.commands:</span>
            <span class="s1">self.run_command(cmd)</span>

    <span class="s3"># -- Methods that operate on its Commands --------------------------</span>

    <span class="s2">def </span><span class="s1">run_command(self</span><span class="s2">, </span><span class="s1">command):</span>
        <span class="s0">&quot;&quot;&quot;Do whatever it takes to run a command (including nothing at all, 
        if the command has already been run).  Specifically: if we have 
        already created and run the command named by 'command', return 
        silently without doing anything.  If the command named by 'command' 
        doesn't even have a command object yet, create one.  Then invoke 
        'run()' on that command object (or an existing one). 
        &quot;&quot;&quot;</span>
        <span class="s3"># Already been here, done that? then return silently.</span>
        <span class="s2">if </span><span class="s1">self.have_run.get(command):</span>
            <span class="s2">return</span>

        <span class="s1">log.info(</span><span class="s4">&quot;running %s&quot;</span><span class="s2">, </span><span class="s1">command)</span>
        <span class="s1">cmd_obj = self.get_command_obj(command)</span>
        <span class="s1">cmd_obj.ensure_finalized()</span>
        <span class="s1">cmd_obj.run()</span>
        <span class="s1">self.have_run[command] = </span><span class="s5">1</span>

    <span class="s3"># -- Distribution query methods ------------------------------------</span>

    <span class="s2">def </span><span class="s1">has_pure_modules(self):</span>
        <span class="s2">return </span><span class="s1">len(self.packages </span><span class="s2">or </span><span class="s1">self.py_modules </span><span class="s2">or </span><span class="s1">[]) &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">has_ext_modules(self):</span>
        <span class="s2">return </span><span class="s1">self.ext_modules </span><span class="s2">and </span><span class="s1">len(self.ext_modules) &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">has_c_libraries(self):</span>
        <span class="s2">return </span><span class="s1">self.libraries </span><span class="s2">and </span><span class="s1">len(self.libraries) &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">has_modules(self):</span>
        <span class="s2">return </span><span class="s1">self.has_pure_modules() </span><span class="s2">or </span><span class="s1">self.has_ext_modules()</span>

    <span class="s2">def </span><span class="s1">has_headers(self):</span>
        <span class="s2">return </span><span class="s1">self.headers </span><span class="s2">and </span><span class="s1">len(self.headers) &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">has_scripts(self):</span>
        <span class="s2">return </span><span class="s1">self.scripts </span><span class="s2">and </span><span class="s1">len(self.scripts) &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">has_data_files(self):</span>
        <span class="s2">return </span><span class="s1">self.data_files </span><span class="s2">and </span><span class="s1">len(self.data_files) &gt; </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">is_pure(self):</span>
        <span class="s2">return </span><span class="s1">(self.has_pure_modules() </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">self.has_ext_modules() </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">self.has_c_libraries())</span>

    <span class="s3"># -- Metadata query methods ----------------------------------------</span>

    <span class="s3"># If you're looking for 'get_name()', 'get_version()', and so forth,</span>
    <span class="s3"># they are defined in a sneaky way: the constructor binds self.get_XXX</span>
    <span class="s3"># to self.metadata.get_XXX.  The actual code is in the</span>
    <span class="s3"># DistributionMetadata class, below.</span>

<span class="s2">class </span><span class="s1">DistributionMetadata:</span>
    <span class="s0">&quot;&quot;&quot;Dummy class to hold the distribution meta-data: name, version, 
    author, and so forth. 
    &quot;&quot;&quot;</span>

    <span class="s1">_METHOD_BASENAMES = (</span><span class="s4">&quot;name&quot;</span><span class="s2">, </span><span class="s4">&quot;version&quot;</span><span class="s2">, </span><span class="s4">&quot;author&quot;</span><span class="s2">, </span><span class="s4">&quot;author_email&quot;</span><span class="s2">,</span>
                         <span class="s4">&quot;maintainer&quot;</span><span class="s2">, </span><span class="s4">&quot;maintainer_email&quot;</span><span class="s2">, </span><span class="s4">&quot;url&quot;</span><span class="s2">,</span>
                         <span class="s4">&quot;license&quot;</span><span class="s2">, </span><span class="s4">&quot;description&quot;</span><span class="s2">, </span><span class="s4">&quot;long_description&quot;</span><span class="s2">,</span>
                         <span class="s4">&quot;keywords&quot;</span><span class="s2">, </span><span class="s4">&quot;platforms&quot;</span><span class="s2">, </span><span class="s4">&quot;fullname&quot;</span><span class="s2">, </span><span class="s4">&quot;contact&quot;</span><span class="s2">,</span>
                         <span class="s4">&quot;contact_email&quot;</span><span class="s2">, </span><span class="s4">&quot;classifiers&quot;</span><span class="s2">, </span><span class="s4">&quot;download_url&quot;</span><span class="s2">,</span>
                         <span class="s3"># PEP 314</span>
                         <span class="s4">&quot;provides&quot;</span><span class="s2">, </span><span class="s4">&quot;requires&quot;</span><span class="s2">, </span><span class="s4">&quot;obsoletes&quot;</span><span class="s2">,</span>
                         <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">path=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">path </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.read_pkg_file(open(path))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.name = </span><span class="s2">None</span>
            <span class="s1">self.version = </span><span class="s2">None</span>
            <span class="s1">self.author = </span><span class="s2">None</span>
            <span class="s1">self.author_email = </span><span class="s2">None</span>
            <span class="s1">self.maintainer = </span><span class="s2">None</span>
            <span class="s1">self.maintainer_email = </span><span class="s2">None</span>
            <span class="s1">self.url = </span><span class="s2">None</span>
            <span class="s1">self.license = </span><span class="s2">None</span>
            <span class="s1">self.description = </span><span class="s2">None</span>
            <span class="s1">self.long_description = </span><span class="s2">None</span>
            <span class="s1">self.keywords = </span><span class="s2">None</span>
            <span class="s1">self.platforms = </span><span class="s2">None</span>
            <span class="s1">self.classifiers = </span><span class="s2">None</span>
            <span class="s1">self.download_url = </span><span class="s2">None</span>
            <span class="s3"># PEP 314</span>
            <span class="s1">self.provides = </span><span class="s2">None</span>
            <span class="s1">self.requires = </span><span class="s2">None</span>
            <span class="s1">self.obsoletes = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">read_pkg_file(self</span><span class="s2">, </span><span class="s1">file):</span>
        <span class="s0">&quot;&quot;&quot;Reads the metadata values from a file object.&quot;&quot;&quot;</span>
        <span class="s1">msg = message_from_file(file)</span>

        <span class="s2">def </span><span class="s1">_read_field(name):</span>
            <span class="s1">value = msg[name]</span>
            <span class="s2">if </span><span class="s1">value == </span><span class="s4">'UNKNOWN'</span><span class="s1">:</span>
                <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">value</span>

        <span class="s2">def </span><span class="s1">_read_list(name):</span>
            <span class="s1">values = msg.get_all(name</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">values == []:</span>
                <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">values</span>

        <span class="s1">metadata_version = msg[</span><span class="s4">'metadata-version'</span><span class="s1">]</span>
        <span class="s1">self.name = _read_field(</span><span class="s4">'name'</span><span class="s1">)</span>
        <span class="s1">self.version = _read_field(</span><span class="s4">'version'</span><span class="s1">)</span>
        <span class="s1">self.description = _read_field(</span><span class="s4">'summary'</span><span class="s1">)</span>
        <span class="s3"># we are filling author only.</span>
        <span class="s1">self.author = _read_field(</span><span class="s4">'author'</span><span class="s1">)</span>
        <span class="s1">self.maintainer = </span><span class="s2">None</span>
        <span class="s1">self.author_email = _read_field(</span><span class="s4">'author-email'</span><span class="s1">)</span>
        <span class="s1">self.maintainer_email = </span><span class="s2">None</span>
        <span class="s1">self.url = _read_field(</span><span class="s4">'home-page'</span><span class="s1">)</span>
        <span class="s1">self.license = _read_field(</span><span class="s4">'license'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s4">'download-url' </span><span class="s2">in </span><span class="s1">msg:</span>
            <span class="s1">self.download_url = _read_field(</span><span class="s4">'download-url'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.download_url = </span><span class="s2">None</span>

        <span class="s1">self.long_description = _read_field(</span><span class="s4">'description'</span><span class="s1">)</span>
        <span class="s1">self.description = _read_field(</span><span class="s4">'summary'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s4">'keywords' </span><span class="s2">in </span><span class="s1">msg:</span>
            <span class="s1">self.keywords = _read_field(</span><span class="s4">'keywords'</span><span class="s1">).split(</span><span class="s4">','</span><span class="s1">)</span>

        <span class="s1">self.platforms = _read_list(</span><span class="s4">'platform'</span><span class="s1">)</span>
        <span class="s1">self.classifiers = _read_list(</span><span class="s4">'classifier'</span><span class="s1">)</span>

        <span class="s3"># PEP 314 - these fields only exist in 1.1</span>
        <span class="s2">if </span><span class="s1">metadata_version == </span><span class="s4">'1.1'</span><span class="s1">:</span>
            <span class="s1">self.requires = _read_list(</span><span class="s4">'requires'</span><span class="s1">)</span>
            <span class="s1">self.provides = _read_list(</span><span class="s4">'provides'</span><span class="s1">)</span>
            <span class="s1">self.obsoletes = _read_list(</span><span class="s4">'obsoletes'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.requires = </span><span class="s2">None</span>
            <span class="s1">self.provides = </span><span class="s2">None</span>
            <span class="s1">self.obsoletes = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">write_pkg_info(self</span><span class="s2">, </span><span class="s1">base_dir):</span>
        <span class="s0">&quot;&quot;&quot;Write the PKG-INFO file into the release tree. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">open(os.path.join(base_dir</span><span class="s2">, </span><span class="s4">'PKG-INFO'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">'w'</span><span class="s2">,</span>
                  <span class="s1">encoding=</span><span class="s4">'UTF-8'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">pkg_info:</span>
            <span class="s1">self.write_pkg_file(pkg_info)</span>

    <span class="s2">def </span><span class="s1">write_pkg_file(self</span><span class="s2">, </span><span class="s1">file):</span>
        <span class="s0">&quot;&quot;&quot;Write the PKG-INFO format data to a file object. 
        &quot;&quot;&quot;</span>
        <span class="s1">version = </span><span class="s4">'1.0'</span>
        <span class="s2">if </span><span class="s1">(self.provides </span><span class="s2">or </span><span class="s1">self.requires </span><span class="s2">or </span><span class="s1">self.obsoletes </span><span class="s2">or</span>
                <span class="s1">self.classifiers </span><span class="s2">or </span><span class="s1">self.download_url):</span>
            <span class="s1">version = </span><span class="s4">'1.1'</span>

        <span class="s1">file.write(</span><span class="s4">'Metadata-Version: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% version)</span>
        <span class="s1">file.write(</span><span class="s4">'Name: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_name())</span>
        <span class="s1">file.write(</span><span class="s4">'Version: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_version())</span>
        <span class="s1">file.write(</span><span class="s4">'Summary: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_description())</span>
        <span class="s1">file.write(</span><span class="s4">'Home-page: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_url())</span>
        <span class="s1">file.write(</span><span class="s4">'Author: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_contact())</span>
        <span class="s1">file.write(</span><span class="s4">'Author-email: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_contact_email())</span>
        <span class="s1">file.write(</span><span class="s4">'License: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.get_license())</span>
        <span class="s2">if </span><span class="s1">self.download_url:</span>
            <span class="s1">file.write(</span><span class="s4">'Download-URL: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% self.download_url)</span>

        <span class="s1">long_desc = rfc822_escape(self.get_long_description())</span>
        <span class="s1">file.write(</span><span class="s4">'Description: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% long_desc)</span>

        <span class="s1">keywords = </span><span class="s4">','</span><span class="s1">.join(self.get_keywords())</span>
        <span class="s2">if </span><span class="s1">keywords:</span>
            <span class="s1">file.write(</span><span class="s4">'Keywords: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% keywords)</span>

        <span class="s1">self._write_list(file</span><span class="s2">, </span><span class="s4">'Platform'</span><span class="s2">, </span><span class="s1">self.get_platforms())</span>
        <span class="s1">self._write_list(file</span><span class="s2">, </span><span class="s4">'Classifier'</span><span class="s2">, </span><span class="s1">self.get_classifiers())</span>

        <span class="s3"># PEP 314</span>
        <span class="s1">self._write_list(file</span><span class="s2">, </span><span class="s4">'Requires'</span><span class="s2">, </span><span class="s1">self.get_requires())</span>
        <span class="s1">self._write_list(file</span><span class="s2">, </span><span class="s4">'Provides'</span><span class="s2">, </span><span class="s1">self.get_provides())</span>
        <span class="s1">self._write_list(file</span><span class="s2">, </span><span class="s4">'Obsoletes'</span><span class="s2">, </span><span class="s1">self.get_obsoletes())</span>

    <span class="s2">def </span><span class="s1">_write_list(self</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">values):</span>
        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">values:</span>
            <span class="s1">file.write(</span><span class="s4">'%s: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">value))</span>

    <span class="s3"># -- Metadata query methods ----------------------------------------</span>

    <span class="s2">def </span><span class="s1">get_name(self):</span>
        <span class="s2">return </span><span class="s1">self.name </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_version(self):</span>
        <span class="s2">return </span><span class="s1">self.version </span><span class="s2">or </span><span class="s4">&quot;0.0.0&quot;</span>

    <span class="s2">def </span><span class="s1">get_fullname(self):</span>
        <span class="s2">return </span><span class="s4">&quot;%s-%s&quot; </span><span class="s1">% (self.get_name()</span><span class="s2">, </span><span class="s1">self.get_version())</span>

    <span class="s2">def </span><span class="s1">get_author(self):</span>
        <span class="s2">return </span><span class="s1">self.author </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_author_email(self):</span>
        <span class="s2">return </span><span class="s1">self.author_email </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_maintainer(self):</span>
        <span class="s2">return </span><span class="s1">self.maintainer </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_maintainer_email(self):</span>
        <span class="s2">return </span><span class="s1">self.maintainer_email </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_contact(self):</span>
        <span class="s2">return </span><span class="s1">self.maintainer </span><span class="s2">or </span><span class="s1">self.author </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_contact_email(self):</span>
        <span class="s2">return </span><span class="s1">self.maintainer_email </span><span class="s2">or </span><span class="s1">self.author_email </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_url(self):</span>
        <span class="s2">return </span><span class="s1">self.url </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_license(self):</span>
        <span class="s2">return </span><span class="s1">self.license </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>
    <span class="s1">get_licence = get_license</span>

    <span class="s2">def </span><span class="s1">get_description(self):</span>
        <span class="s2">return </span><span class="s1">self.description </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_long_description(self):</span>
        <span class="s2">return </span><span class="s1">self.long_description </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s2">def </span><span class="s1">get_keywords(self):</span>
        <span class="s2">return </span><span class="s1">self.keywords </span><span class="s2">or </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">set_keywords(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.keywords = _ensure_list(value</span><span class="s2">, </span><span class="s4">'keywords'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_platforms(self):</span>
        <span class="s2">return </span><span class="s1">self.platforms </span><span class="s2">or </span><span class="s1">[</span><span class="s4">&quot;UNKNOWN&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">set_platforms(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.platforms = _ensure_list(value</span><span class="s2">, </span><span class="s4">'platforms'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_classifiers(self):</span>
        <span class="s2">return </span><span class="s1">self.classifiers </span><span class="s2">or </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">set_classifiers(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.classifiers = _ensure_list(value</span><span class="s2">, </span><span class="s4">'classifiers'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_download_url(self):</span>
        <span class="s2">return </span><span class="s1">self.download_url </span><span class="s2">or </span><span class="s4">&quot;UNKNOWN&quot;</span>

    <span class="s3"># PEP 314</span>
    <span class="s2">def </span><span class="s1">get_requires(self):</span>
        <span class="s2">return </span><span class="s1">self.requires </span><span class="s2">or </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">set_requires(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">import </span><span class="s1">distutils.versionpredicate</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s1">distutils.versionpredicate.VersionPredicate(v)</span>
        <span class="s1">self.requires = list(value)</span>

    <span class="s2">def </span><span class="s1">get_provides(self):</span>
        <span class="s2">return </span><span class="s1">self.provides </span><span class="s2">or </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">set_provides(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">value = [v.strip() </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value]</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s2">import </span><span class="s1">distutils.versionpredicate</span>
            <span class="s1">distutils.versionpredicate.split_provision(v)</span>
        <span class="s1">self.provides = value</span>

    <span class="s2">def </span><span class="s1">get_obsoletes(self):</span>
        <span class="s2">return </span><span class="s1">self.obsoletes </span><span class="s2">or </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">set_obsoletes(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">import </span><span class="s1">distutils.versionpredicate</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s1">distutils.versionpredicate.VersionPredicate(v)</span>
        <span class="s1">self.obsoletes = list(value)</span>

<span class="s2">def </span><span class="s1">fix_help_options(options):</span>
    <span class="s0">&quot;&quot;&quot;Convert a 4-tuple 'help_options' list as found in various command 
    classes to the 3-tuple form required by FancyGetopt. 
    &quot;&quot;&quot;</span>
    <span class="s1">new_options = []</span>
    <span class="s2">for </span><span class="s1">help_tuple </span><span class="s2">in </span><span class="s1">options:</span>
        <span class="s1">new_options.append(help_tuple[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">new_options</span>
</pre>
</body>
</html>