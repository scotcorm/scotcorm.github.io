<html>
<head>
<title>interval.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interval.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import numbers</span>
<span class="s0">from operator import (</span>
    <span class="s0">le,</span>
    <span class="s0">lt,</span>
<span class="s0">)</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
<span class="s0">)</span>

<span class="s0">PyDateTime_IMPORT</span>

<span class="s0">from cpython.object cimport (</span>
    <span class="s0">Py_EQ,</span>
    <span class="s0">Py_GE,</span>
    <span class="s0">Py_GT,</span>
    <span class="s0">Py_LE,</span>
    <span class="s0">Py_LT,</span>
    <span class="s0">Py_NE,</span>
    <span class="s0">PyObject_RichCompare,</span>
<span class="s0">)</span>

<span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>
<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">NPY_QUICKSORT,</span>
    <span class="s0">PyArray_ArgSort,</span>
    <span class="s0">PyArray_Take,</span>
    <span class="s0">float32_t,</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int32_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint64_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>


<span class="s0">from pandas._libs cimport util</span>
<span class="s0">from pandas._libs.hashtable cimport Int64Vector</span>
<span class="s0">from pandas._libs.tslibs.timedeltas cimport _Timedelta</span>
<span class="s0">from pandas._libs.tslibs.timestamps cimport _Timestamp</span>
<span class="s0">from pandas._libs.tslibs.timezones cimport tz_compare</span>
<span class="s0">from pandas._libs.tslibs.util cimport (</span>
    <span class="s0">is_float_object,</span>
    <span class="s0">is_integer_object,</span>
    <span class="s0">is_timedelta64_object,</span>
<span class="s0">)</span>

<span class="s0">VALID_CLOSED = frozenset(['left', 'right', 'both', 'neither'])</span>


<span class="s0">cdef class IntervalMixin:</span>

    <span class="s0">@property</span>
    <span class="s0">def closed_left(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check if the interval is closed on the left side.</span>

        <span class="s0">For the meaning of `closed` and `open` see :class:`~pandas.Interval`.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool</span>
            <span class="s0">True if the Interval is closed on the left-side.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.closed in ('left', 'both')</span>

    <span class="s0">@property</span>
    <span class="s0">def closed_right(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check if the interval is closed on the right side.</span>

        <span class="s0">For the meaning of `closed` and `open` see :class:`~pandas.Interval`.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool</span>
            <span class="s0">True if the Interval is closed on the left-side.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.closed in ('right', 'both')</span>

    <span class="s0">@property</span>
    <span class="s0">def open_left(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check if the interval is open on the left side.</span>

        <span class="s0">For the meaning of `closed` and `open` see :class:`~pandas.Interval`.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool</span>
            <span class="s0">True if the Interval is closed on the left-side.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return not self.closed_left</span>

    <span class="s0">@property</span>
    <span class="s0">def open_right(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check if the interval is open on the right side.</span>

        <span class="s0">For the meaning of `closed` and `open` see :class:`~pandas.Interval`.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool</span>
            <span class="s0">True if the Interval is closed on the left-side.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return not self.closed_right</span>

    <span class="s0">@property</span>
    <span class="s0">def mid(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the midpoint of the Interval.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">try:</span>
            <span class="s0">return 0.5 * (self.left + self.right)</span>
        <span class="s0">except TypeError:</span>
            <span class="s0"># datetime safe version</span>
            <span class="s0">return self.left + 0.5 * self.length</span>

    <span class="s0">@property</span>
    <span class="s0">def length(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the length of the Interval.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.right - self.left</span>

    <span class="s0">@property</span>
    <span class="s0">def is_empty(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Indicates if an interval is empty, meaning it contains no points.</span>

        <span class="s0">.. versionadded:: 0.25.0</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool or ndarray</span>
            <span class="s0">A boolean indicating if a scalar :class:`Interval` is empty, or a</span>
            <span class="s0">boolean ``ndarray`` positionally indicating if an ``Interval`` in</span>
            <span class="s0">an :class:`~arrays.IntervalArray` or :class:`IntervalIndex` is</span>
            <span class="s0">empty.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">An :class:`Interval` that contains points is not empty:</span>

        <span class="s0">&gt;&gt;&gt; pd.Interval(0, 1, closed='right').is_empty</span>
        <span class="s0">False</span>

        <span class="s0">An ``Interval`` that does not contain any points is empty:</span>

        <span class="s0">&gt;&gt;&gt; pd.Interval(0, 0, closed='right').is_empty</span>
        <span class="s0">True</span>
        <span class="s0">&gt;&gt;&gt; pd.Interval(0, 0, closed='left').is_empty</span>
        <span class="s0">True</span>
        <span class="s0">&gt;&gt;&gt; pd.Interval(0, 0, closed='neither').is_empty</span>
        <span class="s0">True</span>

        <span class="s0">An ``Interval`` that contains a single point is not empty:</span>

        <span class="s0">&gt;&gt;&gt; pd.Interval(0, 0, closed='both').is_empty</span>
        <span class="s0">False</span>

        <span class="s0">An :class:`~arrays.IntervalArray` or :class:`IntervalIndex` returns a</span>
        <span class="s0">boolean ``ndarray`` positionally indicating if an ``Interval`` is</span>
        <span class="s0">empty:</span>

        <span class="s0">&gt;&gt;&gt; ivs = [pd.Interval(0, 0, closed='neither'),</span>
        <span class="s0">...        pd.Interval(1, 2, closed='neither')]</span>
        <span class="s0">&gt;&gt;&gt; pd.arrays.IntervalArray(ivs).is_empty</span>
        <span class="s0">array([ True, False])</span>

        <span class="s0">Missing values are not considered empty:</span>

        <span class="s0">&gt;&gt;&gt; ivs = [pd.Interval(0, 0, closed='neither'), np.nan]</span>
        <span class="s0">&gt;&gt;&gt; pd.IntervalIndex(ivs).is_empty</span>
        <span class="s0">array([ True, False])</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return (self.right == self.left) &amp; (self.closed != 'both')</span>

    <span class="s0">def _check_closed_matches(self, other, name='other'):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check if the closed attribute of `other` matches.</span>

        <span class="s0">Note that 'left' and 'right' are considered different from 'both'.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : Interval, IntervalIndex, IntervalArray</span>
        <span class="s0">name : str</span>
            <span class="s0">Name to use for 'other' in the error message.</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError</span>
            <span class="s0">When `other` is not closed exactly the same as self.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.closed != other.closed:</span>
            <span class="s0">raise ValueError(f&quot;'{name}.closed' is {repr(other.closed)}, &quot;</span>
                             <span class="s0">f&quot;expected {repr(self.closed)}.&quot;)</span>


<span class="s0">cdef bint _interval_like(other):</span>
    <span class="s0">return (hasattr(other, 'left')</span>
            <span class="s0">and hasattr(other, 'right')</span>
            <span class="s0">and hasattr(other, 'closed'))</span>


<span class="s0">cdef class Interval(IntervalMixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Immutable object implementing an Interval, a bounded slice-like interval.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">left : orderable scalar</span>
        <span class="s0">Left bound for the interval.</span>
    <span class="s0">right : orderable scalar</span>
        <span class="s0">Right bound for the interval.</span>
    <span class="s0">closed : {'right', 'left', 'both', 'neither'}, default 'right'</span>
        <span class="s0">Whether the interval is closed on the left-side, right-side, both or</span>
        <span class="s0">neither. See the Notes for more detailed explanation.</span>

    <span class="s0">See Also</span>
    <span class="s0">--------</span>
    <span class="s0">IntervalIndex : An Index of Interval objects that are all closed on the</span>
        <span class="s0">same side.</span>
    <span class="s0">cut : Convert continuous data into discrete bins (Categorical</span>
        <span class="s0">of Interval objects).</span>
    <span class="s0">qcut : Convert continuous data into bins (Categorical of Interval objects)</span>
        <span class="s0">based on quantiles.</span>
    <span class="s0">Period : Represents a period of time.</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">The parameters `left` and `right` must be from the same type, you must be</span>
    <span class="s0">able to compare them and they must satisfy ``left &lt;= right``.</span>

    <span class="s0">A closed interval (in mathematics denoted by square brackets) contains</span>
    <span class="s0">its endpoints, i.e. the closed interval ``[0, 5]`` is characterized by the</span>
    <span class="s0">conditions ``0 &lt;= x &lt;= 5``. This is what ``closed='both'`` stands for.</span>
    <span class="s0">An open interval (in mathematics denoted by parentheses) does not contain</span>
    <span class="s0">its endpoints, i.e. the open interval ``(0, 5)`` is characterized by the</span>
    <span class="s0">conditions ``0 &lt; x &lt; 5``. This is what ``closed='neither'`` stands for.</span>
    <span class="s0">Intervals can also be half-open or half-closed, i.e. ``[0, 5)`` is</span>
    <span class="s0">described by ``0 &lt;= x &lt; 5`` (``closed='left'``) and ``(0, 5]`` is</span>
    <span class="s0">described by ``0 &lt; x &lt;= 5`` (``closed='right'``).</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">It is possible to build Intervals of different types, like numeric ones:</span>

    <span class="s0">&gt;&gt;&gt; iv = pd.Interval(left=0, right=5)</span>
    <span class="s0">&gt;&gt;&gt; iv</span>
    <span class="s0">Interval(0, 5, closed='right')</span>

    <span class="s0">You can check if an element belongs to it</span>

    <span class="s0">&gt;&gt;&gt; 2.5 in iv</span>
    <span class="s0">True</span>

    <span class="s0">You can test the bounds (``closed='right'``, so ``0 &lt; x &lt;= 5``):</span>

    <span class="s0">&gt;&gt;&gt; 0 in iv</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; 5 in iv</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; 0.0001 in iv</span>
    <span class="s0">True</span>

    <span class="s0">Calculate its length</span>

    <span class="s0">&gt;&gt;&gt; iv.length</span>
    <span class="s0">5</span>

    <span class="s0">You can operate with `+` and `*` over an Interval and the operation</span>
    <span class="s0">is applied to each of its bounds, so the result depends on the type</span>
    <span class="s0">of the bound elements</span>

    <span class="s0">&gt;&gt;&gt; shifted_iv = iv + 3</span>
    <span class="s0">&gt;&gt;&gt; shifted_iv</span>
    <span class="s0">Interval(3, 8, closed='right')</span>
    <span class="s0">&gt;&gt;&gt; extended_iv = iv * 10.0</span>
    <span class="s0">&gt;&gt;&gt; extended_iv</span>
    <span class="s0">Interval(0.0, 50.0, closed='right')</span>

    <span class="s0">To create a time interval you can use Timestamps as the bounds</span>

    <span class="s0">&gt;&gt;&gt; year_2017 = pd.Interval(pd.Timestamp('2017-01-01 00:00:00'),</span>
    <span class="s0">...                         pd.Timestamp('2018-01-01 00:00:00'),</span>
    <span class="s0">...                         closed='left')</span>
    <span class="s0">&gt;&gt;&gt; pd.Timestamp('2017-01-01 00:00') in year_2017</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; year_2017.length</span>
    <span class="s0">Timedelta('365 days 00:00:00')</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_typ = &quot;interval&quot;</span>
    <span class="s0">__array_priority__ = 1000</span>

    <span class="s0">cdef readonly object left</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Left bound for the interval.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef readonly object right</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Right bound for the interval.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef readonly str closed</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Whether the interval is closed on the left-side, right-side, both or</span>
    <span class="s0">neither.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def __init__(self, left, right, str closed='right'):</span>
        <span class="s0"># note: it is faster to just do these checks than to use a special</span>
        <span class="s0"># constructor (__cinit__/__new__) to avoid them</span>

        <span class="s0">self._validate_endpoint(left)</span>
        <span class="s0">self._validate_endpoint(right)</span>

        <span class="s0">if closed not in VALID_CLOSED:</span>
            <span class="s0">raise ValueError(f&quot;invalid option for 'closed': {closed}&quot;)</span>
        <span class="s0">if not left &lt;= right:</span>
            <span class="s0">raise ValueError(&quot;left side of interval must be &lt;= right side&quot;)</span>
        <span class="s0">if (isinstance(left, _Timestamp) and</span>
                <span class="s0">not tz_compare(left.tzinfo, right.tzinfo)):</span>
            <span class="s0"># GH 18538</span>
            <span class="s0">raise ValueError(&quot;left and right must have the same time zone, got &quot;</span>
                             <span class="s0">f&quot;{repr(left.tzinfo)}' and {repr(right.tzinfo)}&quot;)</span>
        <span class="s0">self.left = left</span>
        <span class="s0">self.right = right</span>
        <span class="s0">self.closed = closed</span>

    <span class="s0">def _validate_endpoint(self, endpoint):</span>
        <span class="s0"># GH 23013</span>
        <span class="s0">if not (is_integer_object(endpoint) or is_float_object(endpoint) or</span>
                <span class="s0">isinstance(endpoint, (_Timestamp, _Timedelta))):</span>
            <span class="s0">raise ValueError(&quot;Only numeric, Timestamp and Timedelta endpoints &quot;</span>
                             <span class="s0">&quot;are allowed when constructing an Interval.&quot;)</span>

    <span class="s0">def __hash__(self):</span>
        <span class="s0">return hash((self.left, self.right, self.closed))</span>

    <span class="s0">def __contains__(self, key) -&gt; bool:</span>
        <span class="s0">if _interval_like(key):</span>
            <span class="s0">raise TypeError(&quot;__contains__ not defined for two intervals&quot;)</span>
        <span class="s0">return ((self.left &lt; key if self.open_left else self.left &lt;= key) and</span>
                <span class="s0">(key &lt; self.right if self.open_right else key &lt;= self.right))</span>

    <span class="s0">def __richcmp__(self, other, op: int):</span>
        <span class="s0">if isinstance(other, Interval):</span>
            <span class="s0">self_tuple = (self.left, self.right, self.closed)</span>
            <span class="s0">other_tuple = (other.left, other.right, other.closed)</span>
            <span class="s0">return PyObject_RichCompare(self_tuple, other_tuple, op)</span>
        <span class="s0">elif util.is_array(other):</span>
            <span class="s0">return np.array(</span>
                <span class="s0">[PyObject_RichCompare(self, x, op) for x in other],</span>
                <span class="s0">dtype=bool,</span>
            <span class="s0">)</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">args = (self.left, self.right, self.closed)</span>
        <span class="s0">return (type(self), args)</span>

    <span class="s0">def _repr_base(self):</span>
        <span class="s0">left = self.left</span>
        <span class="s0">right = self.right</span>

        <span class="s0"># TODO: need more general formatting methodology here</span>
        <span class="s0">if isinstance(left, _Timestamp) and isinstance(right, _Timestamp):</span>
            <span class="s0">left = left._short_repr</span>
            <span class="s0">right = right._short_repr</span>

        <span class="s0">return left, right</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>

        <span class="s0">left, right = self._repr_base()</span>
        <span class="s0">name = type(self).__name__</span>
        <span class="s0">repr_str = f'{name}({repr(left)}, {repr(right)}, closed={repr(self.closed)})'</span>
        <span class="s0">return repr_str</span>

    <span class="s0">def __str__(self) -&gt; str:</span>

        <span class="s0">left, right = self._repr_base()</span>
        <span class="s0">start_symbol = '[' if self.closed_left else '('</span>
        <span class="s0">end_symbol = ']' if self.closed_right else ')'</span>
        <span class="s0">return f'{start_symbol}{left}, {right}{end_symbol}'</span>

    <span class="s0">def __add__(self, y):</span>
        <span class="s0">if (</span>
            <span class="s0">isinstance(y, numbers.Number)</span>
            <span class="s0">or PyDelta_Check(y)</span>
            <span class="s0">or is_timedelta64_object(y)</span>
        <span class="s0">):</span>
            <span class="s0">return Interval(self.left + y, self.right + y, closed=self.closed)</span>
        <span class="s0">elif (</span>
            <span class="s0">isinstance(y, Interval)</span>
            <span class="s0">and (</span>
                <span class="s0">isinstance(self, numbers.Number)</span>
                <span class="s0">or PyDelta_Check(self)</span>
                <span class="s0">or is_timedelta64_object(self)</span>
            <span class="s0">)</span>
        <span class="s0">):</span>
            <span class="s0">return Interval(y.left + self, y.right + self, closed=y.closed)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __sub__(self, y):</span>
        <span class="s0">if (</span>
            <span class="s0">isinstance(y, numbers.Number)</span>
            <span class="s0">or PyDelta_Check(y)</span>
            <span class="s0">or is_timedelta64_object(y)</span>
        <span class="s0">):</span>
            <span class="s0">return Interval(self.left - y, self.right - y, closed=self.closed)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __mul__(self, y):</span>
        <span class="s0">if isinstance(y, numbers.Number):</span>
            <span class="s0">return Interval(self.left * y, self.right * y, closed=self.closed)</span>
        <span class="s0">elif isinstance(y, Interval) and isinstance(self, numbers.Number):</span>
            <span class="s0">return Interval(y.left * self, y.right * self, closed=y.closed)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __truediv__(self, y):</span>
        <span class="s0">if isinstance(y, numbers.Number):</span>
            <span class="s0">return Interval(self.left / y, self.right / y, closed=self.closed)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __floordiv__(self, y):</span>
        <span class="s0">if isinstance(y, numbers.Number):</span>
            <span class="s0">return Interval(</span>
                <span class="s0">self.left // y, self.right // y, closed=self.closed)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def overlaps(self, other):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check whether two Interval objects overlap.</span>

        <span class="s0">Two intervals overlap if they share a common point, including closed</span>
        <span class="s0">endpoints. Intervals that only have an open endpoint in common do not</span>
        <span class="s0">overlap.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : Interval</span>
            <span class="s0">Interval to check against for an overlap.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool</span>
            <span class="s0">True if the two intervals overlap.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">IntervalArray.overlaps : The corresponding method for IntervalArray.</span>
        <span class="s0">IntervalIndex.overlaps : The corresponding method for IntervalIndex.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; i1 = pd.Interval(0, 2)</span>
        <span class="s0">&gt;&gt;&gt; i2 = pd.Interval(1, 3)</span>
        <span class="s0">&gt;&gt;&gt; i1.overlaps(i2)</span>
        <span class="s0">True</span>
        <span class="s0">&gt;&gt;&gt; i3 = pd.Interval(4, 5)</span>
        <span class="s0">&gt;&gt;&gt; i1.overlaps(i3)</span>
        <span class="s0">False</span>

        <span class="s0">Intervals that share closed endpoints overlap:</span>

        <span class="s0">&gt;&gt;&gt; i4 = pd.Interval(0, 1, closed='both')</span>
        <span class="s0">&gt;&gt;&gt; i5 = pd.Interval(1, 2, closed='both')</span>
        <span class="s0">&gt;&gt;&gt; i4.overlaps(i5)</span>
        <span class="s0">True</span>

        <span class="s0">Intervals that only have an open endpoint in common do not overlap:</span>

        <span class="s0">&gt;&gt;&gt; i6 = pd.Interval(1, 2, closed='neither')</span>
        <span class="s0">&gt;&gt;&gt; i4.overlaps(i6)</span>
        <span class="s0">False</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if not isinstance(other, Interval):</span>
            <span class="s0">raise TypeError(&quot;`other` must be an Interval, &quot;</span>
                            <span class="s0">f&quot;got {type(other).__name__}&quot;)</span>

        <span class="s0"># equality is okay if both endpoints are closed (overlap at a point)</span>
        <span class="s0">op1 = le if (self.closed_left and other.closed_right) else lt</span>
        <span class="s0">op2 = le if (other.closed_left and self.closed_right) else lt</span>

        <span class="s0"># overlaps is equivalent negation of two interval being disjoint:</span>
        <span class="s0"># disjoint = (A.left &gt; B.right) or (B.left &gt; A.right)</span>
        <span class="s0"># (simplifying the negation allows this to be done in less operations)</span>
        <span class="s0">return op1(self.left, other.right) and op2(other.left, self.right)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def intervals_to_interval_bounds(ndarray intervals, bint validate_closed=True):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">intervals : ndarray</span>
        <span class="s0">Object array of Intervals / nulls.</span>

    <span class="s0">validate_closed: bool, default True</span>
        <span class="s0">Boolean indicating if all intervals must be closed on the same side.</span>
        <span class="s0">Mismatching closed will raise if True, else return None for closed.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">tuple of</span>
        <span class="s0">left : ndarray</span>
        <span class="s0">right : ndarray</span>
        <span class="s0">closed: str</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">object closed = None, interval</span>
        <span class="s0">Py_ssize_t i, n = len(intervals)</span>
        <span class="s0">ndarray left, right</span>
        <span class="s0">bint seen_closed = False</span>

    <span class="s0">left = np.empty(n, dtype=intervals.dtype)</span>
    <span class="s0">right = np.empty(n, dtype=intervals.dtype)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">interval = intervals[i]</span>
        <span class="s0">if interval is None or util.is_nan(interval):</span>
            <span class="s0">left[i] = np.nan</span>
            <span class="s0">right[i] = np.nan</span>
            <span class="s0">continue</span>

        <span class="s0">if not isinstance(interval, Interval):</span>
            <span class="s0">raise TypeError(f&quot;type {type(interval)} with value &quot;</span>
                            <span class="s0">f&quot;{interval} is not an interval&quot;)</span>

        <span class="s0">left[i] = interval.left</span>
        <span class="s0">right[i] = interval.right</span>
        <span class="s0">if not seen_closed:</span>
            <span class="s0">seen_closed = True</span>
            <span class="s0">closed = interval.closed</span>
        <span class="s0">elif closed != interval.closed:</span>
            <span class="s0">closed = None</span>
            <span class="s0">if validate_closed:</span>
                <span class="s0">raise ValueError(&quot;intervals must all be closed on the same side&quot;)</span>

    <span class="s0">return left, right, closed</span>


<span class="s0">include &quot;intervaltree.pxi&quot;</span>
</pre>
</body>
</html>