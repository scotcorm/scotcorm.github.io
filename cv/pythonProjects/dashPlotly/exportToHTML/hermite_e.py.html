<html>
<head>
<title>hermite_e.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hermite_e.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
=================================================================== 
HermiteE Series, &quot;Probabilists&quot; (:mod:`numpy.polynomial.hermite_e`) 
=================================================================== 
 
This module provides a number of objects (mostly functions) useful for 
dealing with Hermite_e series, including a `HermiteE` class that 
encapsulates the usual arithmetic operations.  (General information 
on how this module represents and works with such polynomials is in the 
docstring for its &quot;parent&quot; sub-package, `numpy.polynomial`). 
 
Classes 
------- 
.. autosummary:: 
   :toctree: generated/ 
 
   HermiteE 
 
Constants 
--------- 
.. autosummary:: 
   :toctree: generated/ 
 
   hermedomain 
   hermezero 
   hermeone 
   hermex 
 
Arithmetic 
---------- 
.. autosummary:: 
   :toctree: generated/ 
 
   hermeadd 
   hermesub 
   hermemulx 
   hermemul 
   hermediv 
   hermepow 
   hermeval 
   hermeval2d 
   hermeval3d 
   hermegrid2d 
   hermegrid3d 
 
Calculus 
-------- 
.. autosummary:: 
   :toctree: generated/ 
 
   hermeder 
   hermeint 
 
Misc Functions 
-------------- 
.. autosummary:: 
   :toctree: generated/ 
 
   hermefromroots 
   hermeroots 
   hermevander 
   hermevander2d 
   hermevander3d 
   hermegauss 
   hermeweight 
   hermecompanion 
   hermefit 
   hermetrim 
   hermeline 
   herme2poly 
   poly2herme 
 
See also 
-------- 
`numpy.polynomial` 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">numpy.linalg </span><span class="s2">as </span><span class="s1">la</span>
<span class="s2">from </span><span class="s1">numpy.core.multiarray </span><span class="s2">import </span><span class="s1">normalize_axis_index</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">polyutils </span><span class="s2">as </span><span class="s1">pu</span>
<span class="s2">from </span><span class="s1">._polybase </span><span class="s2">import </span><span class="s1">ABCPolyBase</span>

<span class="s1">__all__ = [</span>
    <span class="s3">'hermezero'</span><span class="s2">, </span><span class="s3">'hermeone'</span><span class="s2">, </span><span class="s3">'hermex'</span><span class="s2">, </span><span class="s3">'hermedomain'</span><span class="s2">, </span><span class="s3">'hermeline'</span><span class="s2">,</span>
    <span class="s3">'hermeadd'</span><span class="s2">, </span><span class="s3">'hermesub'</span><span class="s2">, </span><span class="s3">'hermemulx'</span><span class="s2">, </span><span class="s3">'hermemul'</span><span class="s2">, </span><span class="s3">'hermediv'</span><span class="s2">,</span>
    <span class="s3">'hermepow'</span><span class="s2">, </span><span class="s3">'hermeval'</span><span class="s2">, </span><span class="s3">'hermeder'</span><span class="s2">, </span><span class="s3">'hermeint'</span><span class="s2">, </span><span class="s3">'herme2poly'</span><span class="s2">,</span>
    <span class="s3">'poly2herme'</span><span class="s2">, </span><span class="s3">'hermefromroots'</span><span class="s2">, </span><span class="s3">'hermevander'</span><span class="s2">, </span><span class="s3">'hermefit'</span><span class="s2">, </span><span class="s3">'hermetrim'</span><span class="s2">,</span>
    <span class="s3">'hermeroots'</span><span class="s2">, </span><span class="s3">'HermiteE'</span><span class="s2">, </span><span class="s3">'hermeval2d'</span><span class="s2">, </span><span class="s3">'hermeval3d'</span><span class="s2">, </span><span class="s3">'hermegrid2d'</span><span class="s2">,</span>
    <span class="s3">'hermegrid3d'</span><span class="s2">, </span><span class="s3">'hermevander2d'</span><span class="s2">, </span><span class="s3">'hermevander3d'</span><span class="s2">, </span><span class="s3">'hermecompanion'</span><span class="s2">,</span>
    <span class="s3">'hermegauss'</span><span class="s2">, </span><span class="s3">'hermeweight'</span><span class="s1">]</span>

<span class="s1">hermetrim = pu.trimcoef</span>


<span class="s2">def </span><span class="s1">poly2herme(pol):</span>
    <span class="s0">&quot;&quot;&quot; 
    poly2herme(pol) 
 
    Convert a polynomial to a Hermite series. 
 
    Convert an array representing the coefficients of a polynomial (relative 
    to the &quot;standard&quot; basis) ordered from lowest degree to highest, to an 
    array of the coefficients of the equivalent Hermite series, ordered 
    from lowest to highest degree. 
 
    Parameters 
    ---------- 
    pol : array_like 
        1-D array containing the polynomial coefficients 
 
    Returns 
    ------- 
    c : ndarray 
        1-D array containing the coefficients of the equivalent Hermite 
        series. 
 
    See Also 
    -------- 
    herme2poly 
 
    Notes 
    ----- 
    The easy way to do conversions between polynomial basis sets 
    is to use the convert method of a class instance. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import poly2herme 
    &gt;&gt;&gt; poly2herme(np.arange(4)) 
    array([  2.,  10.,   2.,   3.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">[pol] = pu.as_series([pol])</span>
    <span class="s1">deg = len(pol) - </span><span class="s4">1</span>
    <span class="s1">res = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(deg</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">res = hermeadd(hermemulx(res)</span><span class="s2">, </span><span class="s1">pol[i])</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">herme2poly(c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a Hermite series to a polynomial. 
 
    Convert an array representing the coefficients of a Hermite series, 
    ordered from lowest degree to highest, to an array of the coefficients 
    of the equivalent polynomial (relative to the &quot;standard&quot; basis) ordered 
    from lowest to highest degree. 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array containing the Hermite series coefficients, ordered 
        from lowest order term to highest. 
 
    Returns 
    ------- 
    pol : ndarray 
        1-D array containing the coefficients of the equivalent polynomial 
        (relative to the &quot;standard&quot; basis) ordered from lowest order term 
        to highest. 
 
    See Also 
    -------- 
    poly2herme 
 
    Notes 
    ----- 
    The easy way to do conversions between polynomial basis sets 
    is to use the convert method of a class instance. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import herme2poly 
    &gt;&gt;&gt; herme2poly([  2.,  10.,   2.,   3.]) 
    array([0.,  1.,  2.,  3.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">.polynomial </span><span class="s2">import </span><span class="s1">polyadd</span><span class="s2">, </span><span class="s1">polysub</span><span class="s2">, </span><span class="s1">polymulx</span>

    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s1">n = len(c)</span>
    <span class="s2">if </span><span class="s1">n == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">c</span>
    <span class="s2">if </span><span class="s1">n == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">c</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">c0 = c[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">c1 = c[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s5"># i is the current degree of c1</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">tmp = c0</span>
            <span class="s1">c0 = polysub(c[i - </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c1*(i - </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">c1 = polyadd(tmp</span><span class="s2">, </span><span class="s1">polymulx(c1))</span>
        <span class="s2">return </span><span class="s1">polyadd(c0</span><span class="s2">, </span><span class="s1">polymulx(c1))</span>

<span class="s5">#</span>
<span class="s5"># These are constant arrays are of integer type so as to be compatible</span>
<span class="s5"># with the widest range of other types, such as Decimal.</span>
<span class="s5">#</span>

<span class="s5"># Hermite</span>
<span class="s1">hermedomain = np.array([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

<span class="s5"># Hermite coefficients representing zero.</span>
<span class="s1">hermezero = np.array([</span><span class="s4">0</span><span class="s1">])</span>

<span class="s5"># Hermite coefficients representing one.</span>
<span class="s1">hermeone = np.array([</span><span class="s4">1</span><span class="s1">])</span>

<span class="s5"># Hermite coefficients representing the identity x.</span>
<span class="s1">hermex = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">hermeline(off</span><span class="s2">, </span><span class="s1">scl):</span>
    <span class="s0">&quot;&quot;&quot; 
    Hermite series whose graph is a straight line. 
 
    Parameters 
    ---------- 
    off, scl : scalars 
        The specified line is given by ``off + scl*x``. 
 
    Returns 
    ------- 
    y : ndarray 
        This module's representation of the Hermite series for 
        ``off + scl*x``. 
 
    See Also 
    -------- 
    numpy.polynomial.polynomial.polyline 
    numpy.polynomial.chebyshev.chebline 
    numpy.polynomial.legendre.legline 
    numpy.polynomial.laguerre.lagline 
    numpy.polynomial.hermite.hermline 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeline 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeline, hermeval 
    &gt;&gt;&gt; hermeval(0,hermeline(3, 2)) 
    3.0 
    &gt;&gt;&gt; hermeval(1,hermeline(3, 2)) 
    5.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">scl != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.array([off</span><span class="s2">, </span><span class="s1">scl])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.array([off])</span>


<span class="s2">def </span><span class="s1">hermefromroots(roots):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a HermiteE series with given roots. 
 
    The function returns the coefficients of the polynomial 
 
    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n), 
 
    in HermiteE form, where the `r_n` are the roots specified in `roots`. 
    If a zero has multiplicity n, then it must appear in `roots` n times. 
    For instance, if 2 is a root of multiplicity three and 3 is a root of 
    multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The 
    roots can appear in any order. 
 
    If the returned coefficients are `c`, then 
 
    .. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x) 
 
    The coefficient of the last term is not generally 1 for monic 
    polynomials in HermiteE form. 
 
    Parameters 
    ---------- 
    roots : array_like 
        Sequence containing the roots. 
 
    Returns 
    ------- 
    out : ndarray 
        1-D array of coefficients.  If all roots are real then `out` is a 
        real array, if some of the roots are complex, then `out` is complex 
        even if all the coefficients in the result are real (see Examples 
        below). 
 
    See Also 
    -------- 
    numpy.polynomial.polynomial.polyfromroots 
    numpy.polynomial.legendre.legfromroots 
    numpy.polynomial.laguerre.lagfromroots 
    numpy.polynomial.hermite.hermfromroots 
    numpy.polynomial.chebyshev.chebfromroots 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermefromroots, hermeval 
    &gt;&gt;&gt; coef = hermefromroots((-1, 0, 1)) 
    &gt;&gt;&gt; hermeval((-1, 0, 1), coef) 
    array([0., 0., 0.]) 
    &gt;&gt;&gt; coef = hermefromroots((-1j, 1j)) 
    &gt;&gt;&gt; hermeval((-1j, 1j), coef) 
    array([0.+0.j, 0.+0.j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._fromroots(hermeline</span><span class="s2">, </span><span class="s1">hermemul</span><span class="s2">, </span><span class="s1">roots)</span>


<span class="s2">def </span><span class="s1">hermeadd(c1</span><span class="s2">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add one Hermite series to another. 
 
    Returns the sum of two Hermite series `c1` + `c2`.  The arguments 
    are sequences of coefficients ordered from lowest order term to 
    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of Hermite series coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    out : ndarray 
        Array representing the Hermite series of their sum. 
 
    See Also 
    -------- 
    hermesub, hermemulx, hermemul, hermediv, hermepow 
 
    Notes 
    ----- 
    Unlike multiplication, division, etc., the sum of two Hermite series 
    is a Hermite series (without having to &quot;reproject&quot; the result onto 
    the basis set) so addition, just like that of &quot;standard&quot; polynomials, 
    is simply &quot;component-wise.&quot; 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeadd 
    &gt;&gt;&gt; hermeadd([1, 2, 3], [1, 2, 3, 4]) 
    array([2.,  4.,  6.,  4.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._add(c1</span><span class="s2">, </span><span class="s1">c2)</span>


<span class="s2">def </span><span class="s1">hermesub(c1</span><span class="s2">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Subtract one Hermite series from another. 
 
    Returns the difference of two Hermite series `c1` - `c2`.  The 
    sequences of coefficients are from lowest order term to highest, i.e., 
    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of Hermite series coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    out : ndarray 
        Of Hermite series coefficients representing their difference. 
 
    See Also 
    -------- 
    hermeadd, hermemulx, hermemul, hermediv, hermepow 
 
    Notes 
    ----- 
    Unlike multiplication, division, etc., the difference of two Hermite 
    series is a Hermite series (without having to &quot;reproject&quot; the result 
    onto the basis set) so subtraction, just like that of &quot;standard&quot; 
    polynomials, is simply &quot;component-wise.&quot; 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermesub 
    &gt;&gt;&gt; hermesub([1, 2, 3, 4], [1, 2, 3]) 
    array([0., 0., 0., 4.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._sub(c1</span><span class="s2">, </span><span class="s1">c2)</span>


<span class="s2">def </span><span class="s1">hermemulx(c):</span>
    <span class="s0">&quot;&quot;&quot;Multiply a Hermite series by x. 
 
    Multiply the Hermite series `c` by x, where x is the independent 
    variable. 
 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of Hermite series coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    out : ndarray 
        Array representing the result of the multiplication. 
 
    Notes 
    ----- 
    The multiplication uses the recursion relationship for Hermite 
    polynomials in the form 
 
    .. math:: 
 
        xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x))) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermemulx 
    &gt;&gt;&gt; hermemulx([1, 2, 3]) 
    array([2.,  7.,  2.,  3.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># c is a trimmed copy</span>
    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s5"># The zero series needs special treatment</span>
    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">c[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s1">prd = np.empty(len(c) + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=c.dtype)</span>
    <span class="s1">prd[</span><span class="s4">0</span><span class="s1">] = c[</span><span class="s4">0</span><span class="s1">]*</span><span class="s4">0</span>
    <span class="s1">prd[</span><span class="s4">1</span><span class="s1">] = c[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(c)):</span>
        <span class="s1">prd[i + </span><span class="s4">1</span><span class="s1">] = c[i]</span>
        <span class="s1">prd[i - </span><span class="s4">1</span><span class="s1">] += c[i]*i</span>
    <span class="s2">return </span><span class="s1">prd</span>


<span class="s2">def </span><span class="s1">hermemul(c1</span><span class="s2">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Multiply one Hermite series by another. 
 
    Returns the product of two Hermite series `c1` * `c2`.  The arguments 
    are sequences of coefficients, from lowest order &quot;term&quot; to highest, 
    e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of Hermite series coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    out : ndarray 
        Of Hermite series coefficients representing their product. 
 
    See Also 
    -------- 
    hermeadd, hermesub, hermemulx, hermediv, hermepow 
 
    Notes 
    ----- 
    In general, the (polynomial) product of two C-series results in terms 
    that are not in the Hermite polynomial basis set.  Thus, to express 
    the product as a Hermite series, it is necessary to &quot;reproject&quot; the 
    product onto said basis set, which may produce &quot;unintuitive&quot; (but 
    correct) results; see Examples section below. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermemul 
    &gt;&gt;&gt; hermemul([1, 2, 3], [0, 1, 2]) 
    array([14.,  15.,  28.,   7.,   6.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># s1, s2 are trimmed copies</span>
    <span class="s1">[c1</span><span class="s2">, </span><span class="s1">c2] = pu.as_series([c1</span><span class="s2">, </span><span class="s1">c2])</span>

    <span class="s2">if </span><span class="s1">len(c1) &gt; len(c2):</span>
        <span class="s1">c = c2</span>
        <span class="s1">xs = c1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">c = c1</span>
        <span class="s1">xs = c2</span>

    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">c0 = c[</span><span class="s4">0</span><span class="s1">]*xs</span>
        <span class="s1">c1 = </span><span class="s4">0</span>
    <span class="s2">elif </span><span class="s1">len(c) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">c0 = c[</span><span class="s4">0</span><span class="s1">]*xs</span>
        <span class="s1">c1 = c[</span><span class="s4">1</span><span class="s1">]*xs</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">nd = len(c)</span>
        <span class="s1">c0 = c[-</span><span class="s4">2</span><span class="s1">]*xs</span>
        <span class="s1">c1 = c[-</span><span class="s4">1</span><span class="s1">]*xs</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">len(c) + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">tmp = c0</span>
            <span class="s1">nd = nd - </span><span class="s4">1</span>
            <span class="s1">c0 = hermesub(c[-i]*xs</span><span class="s2">, </span><span class="s1">c1*(nd - </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">c1 = hermeadd(tmp</span><span class="s2">, </span><span class="s1">hermemulx(c1))</span>
    <span class="s2">return </span><span class="s1">hermeadd(c0</span><span class="s2">, </span><span class="s1">hermemulx(c1))</span>


<span class="s2">def </span><span class="s1">hermediv(c1</span><span class="s2">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Divide one Hermite series by another. 
 
    Returns the quotient-with-remainder of two Hermite series 
    `c1` / `c2`.  The arguments are sequences of coefficients from lowest 
    order &quot;term&quot; to highest, e.g., [1,2,3] represents the series 
    ``P_0 + 2*P_1 + 3*P_2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of Hermite series coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    [quo, rem] : ndarrays 
        Of Hermite series coefficients representing the quotient and 
        remainder. 
 
    See Also 
    -------- 
    hermeadd, hermesub, hermemulx, hermemul, hermepow 
 
    Notes 
    ----- 
    In general, the (polynomial) division of one Hermite series by another 
    results in quotient and remainder terms that are not in the Hermite 
    polynomial basis set.  Thus, to express these results as a Hermite 
    series, it is necessary to &quot;reproject&quot; the results onto the Hermite 
    basis set, which may produce &quot;unintuitive&quot; (but correct) results; see 
    Examples section below. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermediv 
    &gt;&gt;&gt; hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2]) 
    (array([1., 2., 3.]), array([0.])) 
    &gt;&gt;&gt; hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2]) 
    (array([1., 2., 3.]), array([1., 2.])) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._div(hermemul</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">c2)</span>


<span class="s2">def </span><span class="s1">hermepow(c</span><span class="s2">, </span><span class="s1">pow</span><span class="s2">, </span><span class="s1">maxpower=</span><span class="s4">16</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Raise a Hermite series to a power. 
 
    Returns the Hermite series `c` raised to the power `pow`. The 
    argument `c` is a sequence of coefficients ordered from low to high. 
    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.`` 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of Hermite series coefficients ordered from low to 
        high. 
    pow : integer 
        Power to which the series will be raised 
    maxpower : integer, optional 
        Maximum power allowed. This is mainly to limit growth of the series 
        to unmanageable size. Default is 16 
 
    Returns 
    ------- 
    coef : ndarray 
        Hermite series of power. 
 
    See Also 
    -------- 
    hermeadd, hermesub, hermemulx, hermemul, hermediv 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermepow 
    &gt;&gt;&gt; hermepow([1, 2, 3], 2) 
    array([23.,  28.,  46.,  12.,   9.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._pow(hermemul</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">pow</span><span class="s2">, </span><span class="s1">maxpower)</span>


<span class="s2">def </span><span class="s1">hermeder(c</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">scl=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Differentiate a Hermite_e series. 
 
    Returns the series coefficients `c` differentiated `m` times along 
    `axis`.  At each iteration the result is multiplied by `scl` (the 
    scaling factor is for use in a linear change of variable). The argument 
    `c` is an array of coefficients from low to high degree along each 
    axis, e.g., [1,2,3] represents the series ``1*He_0 + 2*He_1 + 3*He_2`` 
    while [[1,2],[1,2]] represents ``1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y) 
    + 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)`` if axis=0 is ``x`` and axis=1 
    is ``y``. 
 
    Parameters 
    ---------- 
    c : array_like 
        Array of Hermite_e series coefficients. If `c` is multidimensional 
        the different axis correspond to different variables with the 
        degree in each axis given by the corresponding index. 
    m : int, optional 
        Number of derivatives taken, must be non-negative. (Default: 1) 
    scl : scalar, optional 
        Each differentiation is multiplied by `scl`.  The end result is 
        multiplication by ``scl**m``.  This is for use in a linear change of 
        variable. (Default: 1) 
    axis : int, optional 
        Axis over which the derivative is taken. (Default: 0). 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    der : ndarray 
        Hermite series of the derivative. 
 
    See Also 
    -------- 
    hermeint 
 
    Notes 
    ----- 
    In general, the result of differentiating a Hermite series does not 
    resemble the same operation on a power series. Thus the result of this 
    function may be &quot;unintuitive,&quot; albeit correct; see Examples section 
    below. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeder 
    &gt;&gt;&gt; hermeder([ 1.,  1.,  1.,  1.]) 
    array([1.,  2.,  3.]) 
    &gt;&gt;&gt; hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2) 
    array([1.,  2.,  3.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.array(c</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">c.dtype.char </span><span class="s2">in </span><span class="s3">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s1">c = c.astype(np.double)</span>
    <span class="s1">cnt = pu._deprecate_as_int(m</span><span class="s2">, </span><span class="s3">&quot;the order of derivation&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = pu._deprecate_as_int(axis</span><span class="s2">, </span><span class="s3">&quot;the axis&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">cnt &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The order of derivation must be non-negative&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = normalize_axis_index(iaxis</span><span class="s2">, </span><span class="s1">c.ndim)</span>

    <span class="s2">if </span><span class="s1">cnt == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s1">c = np.moveaxis(c</span><span class="s2">, </span><span class="s1">iaxis</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">n = len(c)</span>
    <span class="s2">if </span><span class="s1">cnt &gt;= n:</span>
        <span class="s2">return </span><span class="s1">c[:</span><span class="s4">1</span><span class="s1">]*</span><span class="s4">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(cnt):</span>
            <span class="s1">n = n - </span><span class="s4">1</span>
            <span class="s1">c *= scl</span>
            <span class="s1">der = np.empty((n</span><span class="s2">,</span><span class="s1">) + c.shape[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">dtype=c.dtype)</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">der[j - </span><span class="s4">1</span><span class="s1">] = j*c[j]</span>
            <span class="s1">c = der</span>
    <span class="s1">c = np.moveaxis(c</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">iaxis)</span>
    <span class="s2">return </span><span class="s1">c</span>


<span class="s2">def </span><span class="s1">hermeint(c</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k=[]</span><span class="s2">, </span><span class="s1">lbnd=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scl=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Integrate a Hermite_e series. 
 
    Returns the Hermite_e series coefficients `c` integrated `m` times from 
    `lbnd` along `axis`. At each iteration the resulting series is 
    **multiplied** by `scl` and an integration constant, `k`, is added. 
    The scaling factor is for use in a linear change of variable.  (&quot;Buyer 
    beware&quot;: note that, depending on what one is doing, one may want `scl` 
    to be the reciprocal of what one might expect; for more information, 
    see the Notes section below.)  The argument `c` is an array of 
    coefficients from low to high degree along each axis, e.g., [1,2,3] 
    represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]] 
    represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) + 
    2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``. 
 
    Parameters 
    ---------- 
    c : array_like 
        Array of Hermite_e series coefficients. If c is multidimensional 
        the different axis correspond to different variables with the 
        degree in each axis given by the corresponding index. 
    m : int, optional 
        Order of integration, must be positive. (Default: 1) 
    k : {[], list, scalar}, optional 
        Integration constant(s).  The value of the first integral at 
        ``lbnd`` is the first value in the list, the value of the second 
        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the 
        default), all constants are set to zero.  If ``m == 1``, a single 
        scalar can be given instead of a list. 
    lbnd : scalar, optional 
        The lower bound of the integral. (Default: 0) 
    scl : scalar, optional 
        Following each integration the result is *multiplied* by `scl` 
        before the integration constant is added. (Default: 1) 
    axis : int, optional 
        Axis over which the integral is taken. (Default: 0). 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    S : ndarray 
        Hermite_e series coefficients of the integral. 
 
    Raises 
    ------ 
    ValueError 
        If ``m &lt; 0``, ``len(k) &gt; m``, ``np.ndim(lbnd) != 0``, or 
        ``np.ndim(scl) != 0``. 
 
    See Also 
    -------- 
    hermeder 
 
    Notes 
    ----- 
    Note that the result of each integration is *multiplied* by `scl`. 
    Why is this important to note?  Say one is making a linear change of 
    variable :math:`u = ax + b` in an integral relative to `x`.  Then 
    :math:`dx = du/a`, so one will need to set `scl` equal to 
    :math:`1/a` - perhaps not what one would have first thought. 
 
    Also note that, in general, the result of integrating a C-series needs 
    to be &quot;reprojected&quot; onto the C-series basis set.  Thus, typically, 
    the result of this function is &quot;unintuitive,&quot; albeit correct; see 
    Examples section below. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeint 
    &gt;&gt;&gt; hermeint([1, 2, 3]) # integrate once, value 0 at 0. 
    array([1., 1., 1., 1.]) 
    &gt;&gt;&gt; hermeint([1, 2, 3], m=2) # integrate twice, value &amp; deriv 0 at 0 
    array([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary 
    &gt;&gt;&gt; hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0. 
    array([2., 1., 1., 1.]) 
    &gt;&gt;&gt; hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1 
    array([-1.,  1.,  1.,  1.]) 
    &gt;&gt;&gt; hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1) 
    array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.array(c</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">c.dtype.char </span><span class="s2">in </span><span class="s3">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s1">c = c.astype(np.double)</span>
    <span class="s2">if not </span><span class="s1">np.iterable(k):</span>
        <span class="s1">k = [k]</span>
    <span class="s1">cnt = pu._deprecate_as_int(m</span><span class="s2">, </span><span class="s3">&quot;the order of integration&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = pu._deprecate_as_int(axis</span><span class="s2">, </span><span class="s3">&quot;the axis&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">cnt &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The order of integration must be non-negative&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(k) &gt; cnt:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Too many integration constants&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">np.ndim(lbnd) != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;lbnd must be a scalar.&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">np.ndim(scl) != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;scl must be a scalar.&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = normalize_axis_index(iaxis</span><span class="s2">, </span><span class="s1">c.ndim)</span>

    <span class="s2">if </span><span class="s1">cnt == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s1">c = np.moveaxis(c</span><span class="s2">, </span><span class="s1">iaxis</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">k = list(k) + [</span><span class="s4">0</span><span class="s1">]*(cnt - len(k))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(cnt):</span>
        <span class="s1">n = len(c)</span>
        <span class="s1">c *= scl</span>
        <span class="s2">if </span><span class="s1">n == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">np.all(c[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">c[</span><span class="s4">0</span><span class="s1">] += k[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tmp = np.empty((n + </span><span class="s4">1</span><span class="s2">,</span><span class="s1">) + c.shape[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">dtype=c.dtype)</span>
            <span class="s1">tmp[</span><span class="s4">0</span><span class="s1">] = c[</span><span class="s4">0</span><span class="s1">]*</span><span class="s4">0</span>
            <span class="s1">tmp[</span><span class="s4">1</span><span class="s1">] = c[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n):</span>
                <span class="s1">tmp[j + </span><span class="s4">1</span><span class="s1">] = c[j]/(j + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">tmp[</span><span class="s4">0</span><span class="s1">] += k[i] - hermeval(lbnd</span><span class="s2">, </span><span class="s1">tmp)</span>
            <span class="s1">c = tmp</span>
    <span class="s1">c = np.moveaxis(c</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">iaxis)</span>
    <span class="s2">return </span><span class="s1">c</span>


<span class="s2">def </span><span class="s1">hermeval(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">tensor=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate an HermiteE series at points x. 
 
    If `c` is of length `n + 1`, this function returns the value: 
 
    .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x) 
 
    The parameter `x` is converted to an array only if it is a tuple or a 
    list, otherwise it is treated as a scalar. In either case, either `x` 
    or its elements must support multiplication and addition both with 
    themselves and with the elements of `c`. 
 
    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If 
    `c` is multidimensional, then the shape of the result depends on the 
    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] + 
    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that 
    scalars have shape (,). 
 
    Trailing zeros in the coefficients will be used in the evaluation, so 
    they should be avoided if efficiency is a concern. 
 
    Parameters 
    ---------- 
    x : array_like, compatible object 
        If `x` is a list or tuple, it is converted to an ndarray, otherwise 
        it is left unchanged and treated as a scalar. In either case, `x` 
        or its elements must support addition and multiplication with 
        with themselves and with the elements of `c`. 
    c : array_like 
        Array of coefficients ordered so that the coefficients for terms of 
        degree n are contained in c[n]. If `c` is multidimensional the 
        remaining indices enumerate multiple polynomials. In the two 
        dimensional case the coefficients may be thought of as stored in 
        the columns of `c`. 
    tensor : boolean, optional 
        If True, the shape of the coefficient array is extended with ones 
        on the right, one for each dimension of `x`. Scalars have dimension 0 
        for this action. The result is that every column of coefficients in 
        `c` is evaluated for every element of `x`. If False, `x` is broadcast 
        over the columns of `c` for the evaluation.  This keyword is useful 
        when `c` is multidimensional. The default value is True. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    values : ndarray, algebra_like 
        The shape of the return value is described above. 
 
    See Also 
    -------- 
    hermeval2d, hermegrid2d, hermeval3d, hermegrid3d 
 
    Notes 
    ----- 
    The evaluation uses Clenshaw recursion, aka synthetic division. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeval 
    &gt;&gt;&gt; coef = [1,2,3] 
    &gt;&gt;&gt; hermeval(1, coef) 
    3.0 
    &gt;&gt;&gt; hermeval([[1,2],[3,4]], coef) 
    array([[ 3., 14.], 
           [31., 54.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.array(c</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">c.dtype.char </span><span class="s2">in </span><span class="s3">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s1">c = c.astype(np.double)</span>
    <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
        <span class="s1">x = np.asarray(x)</span>
    <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">tensor:</span>
        <span class="s1">c = c.reshape(c.shape + (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)*x.ndim)</span>

    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">c0 = c[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">c1 = </span><span class="s4">0</span>
    <span class="s2">elif </span><span class="s1">len(c) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">c0 = c[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">c1 = c[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">nd = len(c)</span>
        <span class="s1">c0 = c[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">c1 = c[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">len(c) + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">tmp = c0</span>
            <span class="s1">nd = nd - </span><span class="s4">1</span>
            <span class="s1">c0 = c[-i] - c1*(nd - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">c1 = tmp + c1*x</span>
    <span class="s2">return </span><span class="s1">c0 + c1*x</span>


<span class="s2">def </span><span class="s1">hermeval2d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 2-D HermiteE series at points (x, y). 
 
    This function returns the values: 
 
    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * He_i(x) * He_j(y) 
 
    The parameters `x` and `y` are converted to arrays only if they are 
    tuples or a lists, otherwise they are treated as a scalars and they 
    must have the same shape after conversion. In either case, either `x` 
    and `y` or their elements must support multiplication and addition both 
    with themselves and with the elements of `c`. 
 
    If `c` is a 1-D array a one is implicitly appended to its shape to make 
    it 2-D. The shape of the result will be c.shape[2:] + x.shape. 
 
    Parameters 
    ---------- 
    x, y : array_like, compatible objects 
        The two dimensional series is evaluated at the points `(x, y)`, 
        where `x` and `y` must have the same shape. If `x` or `y` is a list 
        or tuple, it is first converted to an ndarray, otherwise it is left 
        unchanged and if it isn't an ndarray it is treated as a scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficient of the term 
        of multi-degree i,j is contained in ``c[i,j]``. If `c` has 
        dimension greater than two the remaining indices enumerate multiple 
        sets of coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the two dimensional polynomial at points formed with 
        pairs of corresponding values from `x` and `y`. 
 
    See Also 
    -------- 
    hermeval, hermegrid2d, hermeval3d, hermegrid3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._valnd(hermeval</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">hermegrid2d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 2-D HermiteE series on the Cartesian product of x and y. 
 
    This function returns the values: 
 
    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b) 
 
    where the points `(a, b)` consist of all pairs formed by taking 
    `a` from `x` and `b` from `y`. The resulting points form a grid with 
    `x` in the first dimension and `y` in the second. 
 
    The parameters `x` and `y` are converted to arrays only if they are 
    tuples or a lists, otherwise they are treated as a scalars. In either 
    case, either `x` and `y` or their elements must support multiplication 
    and addition both with themselves and with the elements of `c`. 
 
    If `c` has fewer than two dimensions, ones are implicitly appended to 
    its shape to make it 2-D. The shape of the result will be c.shape[2:] + 
    x.shape. 
 
    Parameters 
    ---------- 
    x, y : array_like, compatible objects 
        The two dimensional series is evaluated at the points in the 
        Cartesian product of `x` and `y`.  If `x` or `y` is a list or 
        tuple, it is first converted to an ndarray, otherwise it is left 
        unchanged and, if it isn't an ndarray, it is treated as a scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficients for terms of 
        degree i,j are contained in ``c[i,j]``. If `c` has dimension 
        greater than two the remaining indices enumerate multiple sets of 
        coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the two dimensional polynomial at points in the Cartesian 
        product of `x` and `y`. 
 
    See Also 
    -------- 
    hermeval, hermeval2d, hermeval3d, hermegrid3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._gridnd(hermeval</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">hermeval3d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 3-D Hermite_e series at points (x, y, z). 
 
    This function returns the values: 
 
    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z) 
 
    The parameters `x`, `y`, and `z` are converted to arrays only if 
    they are tuples or a lists, otherwise they are treated as a scalars and 
    they must have the same shape after conversion. In either case, either 
    `x`, `y`, and `z` or their elements must support multiplication and 
    addition both with themselves and with the elements of `c`. 
 
    If `c` has fewer than 3 dimensions, ones are implicitly appended to its 
    shape to make it 3-D. The shape of the result will be c.shape[3:] + 
    x.shape. 
 
    Parameters 
    ---------- 
    x, y, z : array_like, compatible object 
        The three dimensional series is evaluated at the points 
        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If 
        any of `x`, `y`, or `z` is a list or tuple, it is first converted 
        to an ndarray, otherwise it is left unchanged and if it isn't an 
        ndarray it is  treated as a scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficient of the term of 
        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension 
        greater than 3 the remaining indices enumerate multiple sets of 
        coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the multidimensional polynomial on points formed with 
        triples of corresponding values from `x`, `y`, and `z`. 
 
    See Also 
    -------- 
    hermeval, hermeval2d, hermegrid2d, hermegrid3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._valnd(hermeval</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)</span>


<span class="s2">def </span><span class="s1">hermegrid3d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z. 
 
    This function returns the values: 
 
    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c) 
 
    where the points `(a, b, c)` consist of all triples formed by taking 
    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form 
    a grid with `x` in the first dimension, `y` in the second, and `z` in 
    the third. 
 
    The parameters `x`, `y`, and `z` are converted to arrays only if they 
    are tuples or a lists, otherwise they are treated as a scalars. In 
    either case, either `x`, `y`, and `z` or their elements must support 
    multiplication and addition both with themselves and with the elements 
    of `c`. 
 
    If `c` has fewer than three dimensions, ones are implicitly appended to 
    its shape to make it 3-D. The shape of the result will be c.shape[3:] + 
    x.shape + y.shape + z.shape. 
 
    Parameters 
    ---------- 
    x, y, z : array_like, compatible objects 
        The three dimensional series is evaluated at the points in the 
        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a 
        list or tuple, it is first converted to an ndarray, otherwise it is 
        left unchanged and, if it isn't an ndarray, it is treated as a 
        scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficients for terms of 
        degree i,j are contained in ``c[i,j]``. If `c` has dimension 
        greater than two the remaining indices enumerate multiple sets of 
        coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the two dimensional polynomial at points in the Cartesian 
        product of `x` and `y`. 
 
    See Also 
    -------- 
    hermeval, hermeval2d, hermegrid2d, hermeval3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._gridnd(hermeval</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)</span>


<span class="s2">def </span><span class="s1">hermevander(x</span><span class="s2">, </span><span class="s1">deg):</span>
    <span class="s0">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degree. 
 
    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points 
    `x`. The pseudo-Vandermonde matrix is defined by 
 
    .. math:: V[..., i] = He_i(x), 
 
    where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of 
    `x` and the last index is the degree of the HermiteE polynomial. 
 
    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the 
    array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and 
    ``hermeval(x, c)`` are the same up to roundoff. This equivalence is 
    useful both for least squares fitting and for the evaluation of a large 
    number of HermiteE series of the same degree and sample points. 
 
    Parameters 
    ---------- 
    x : array_like 
        Array of points. The dtype is converted to float64 or complex128 
        depending on whether any of the elements are complex. If `x` is 
        scalar it is converted to a 1-D array. 
    deg : int 
        Degree of the resulting matrix. 
 
    Returns 
    ------- 
    vander : ndarray 
        The pseudo-Vandermonde matrix. The shape of the returned matrix is 
        ``x.shape + (deg + 1,)``, where The last index is the degree of the 
        corresponding HermiteE polynomial.  The dtype will be the same as 
        the converted `x`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermevander 
    &gt;&gt;&gt; x = np.array([-1, 0, 1]) 
    &gt;&gt;&gt; hermevander(x, 3) 
    array([[ 1., -1.,  0.,  2.], 
           [ 1.,  0., -1., -0.], 
           [ 1.,  1.,  0., -2.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ideg = pu._deprecate_as_int(deg</span><span class="s2">, </span><span class="s3">&quot;deg&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">ideg &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;deg must be non-negative&quot;</span><span class="s1">)</span>

    <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">) + </span><span class="s4">0.0</span>
    <span class="s1">dims = (ideg + </span><span class="s4">1</span><span class="s2">,</span><span class="s1">) + x.shape</span>
    <span class="s1">dtyp = x.dtype</span>
    <span class="s1">v = np.empty(dims</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
    <span class="s1">v[</span><span class="s4">0</span><span class="s1">] = x*</span><span class="s4">0 </span><span class="s1">+ </span><span class="s4">1</span>
    <span class="s2">if </span><span class="s1">ideg &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">v[</span><span class="s4">1</span><span class="s1">] = x</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ideg + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">v[i] = (v[i-</span><span class="s4">1</span><span class="s1">]*x - v[i-</span><span class="s4">2</span><span class="s1">]*(i - </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">np.moveaxis(v</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">hermevander2d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg):</span>
    <span class="s0">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degrees. 
 
    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample 
    points `(x, y)`. The pseudo-Vandermonde matrix is defined by 
 
    .. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y), 
 
    where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of 
    `V` index the points `(x, y)` and the last index encodes the degrees of 
    the HermiteE polynomials. 
 
    If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V` 
    correspond to the elements of a 2-D coefficient array `c` of shape 
    (xdeg + 1, ydeg + 1) in the order 
 
    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ... 
 
    and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same 
    up to roundoff. This equivalence is useful both for least squares 
    fitting and for the evaluation of a large number of 2-D HermiteE 
    series of the same degrees and sample points. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Arrays of point coordinates, all of the same shape. The dtypes 
        will be converted to either float64 or complex128 depending on 
        whether any of the elements are complex. Scalars are converted to 
        1-D arrays. 
    deg : list of ints 
        List of maximum degrees of the form [x_deg, y_deg]. 
 
    Returns 
    ------- 
    vander2d : ndarray 
        The shape of the returned matrix is ``x.shape + (order,)``, where 
        :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same 
        as the converted `x` and `y`. 
 
    See Also 
    -------- 
    hermevander, hermevander3d, hermeval2d, hermeval3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._vander_nd_flat((hermevander</span><span class="s2">, </span><span class="s1">hermevander)</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">deg)</span>


<span class="s2">def </span><span class="s1">hermevander3d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">deg):</span>
    <span class="s0">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degrees. 
 
    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample 
    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`, 
    then Hehe pseudo-Vandermonde matrix is defined by 
 
    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z), 
 
    where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading 
    indices of `V` index the points `(x, y, z)` and the last index encodes 
    the degrees of the HermiteE polynomials. 
 
    If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns 
    of `V` correspond to the elements of a 3-D coefficient array `c` of 
    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order 
 
    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},... 
 
    and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the 
    same up to roundoff. This equivalence is useful both for least squares 
    fitting and for the evaluation of a large number of 3-D HermiteE 
    series of the same degrees and sample points. 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        Arrays of point coordinates, all of the same shape. The dtypes will 
        be converted to either float64 or complex128 depending on whether 
        any of the elements are complex. Scalars are converted to 1-D 
        arrays. 
    deg : list of ints 
        List of maximum degrees of the form [x_deg, y_deg, z_deg]. 
 
    Returns 
    ------- 
    vander3d : ndarray 
        The shape of the returned matrix is ``x.shape + (order,)``, where 
        :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will 
        be the same as the converted `x`, `y`, and `z`. 
 
    See Also 
    -------- 
    hermevander, hermevander3d, hermeval2d, hermeval3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._vander_nd_flat((hermevander</span><span class="s2">, </span><span class="s1">hermevander</span><span class="s2">, </span><span class="s1">hermevander)</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">, </span><span class="s1">deg)</span>


<span class="s2">def </span><span class="s1">hermefit(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">rcond=</span><span class="s2">None, </span><span class="s1">full=</span><span class="s2">False, </span><span class="s1">w=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Least squares fit of Hermite series to data. 
 
    Return the coefficients of a HermiteE series of degree `deg` that is 
    the least squares fit to the data values `y` given at points `x`. If 
    `y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D 
    multiple fits are done, one for each column of `y`, and the resulting 
    coefficients are stored in the corresponding columns of a 2-D return. 
    The fitted polynomial(s) are in the form 
 
    .. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x), 
 
    where `n` is `deg`. 
 
    Parameters 
    ---------- 
    x : array_like, shape (M,) 
        x-coordinates of the M sample points ``(x[i], y[i])``. 
    y : array_like, shape (M,) or (M, K) 
        y-coordinates of the sample points. Several data sets of sample 
        points sharing the same x-coordinates can be fitted at once by 
        passing in a 2D-array that contains one dataset per column. 
    deg : int or 1-D array_like 
        Degree(s) of the fitting polynomials. If `deg` is a single integer 
        all terms up to and including the `deg`'th term are included in the 
        fit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the 
        degrees of the terms to include may be used instead. 
    rcond : float, optional 
        Relative condition number of the fit. Singular values smaller than 
        this relative to the largest singular value will be ignored. The 
        default value is len(x)*eps, where eps is the relative precision of 
        the float type, about 2e-16 in most cases. 
    full : bool, optional 
        Switch determining nature of return value. When it is False (the 
        default) just the coefficients are returned, when True diagnostic 
        information from the singular value decomposition is also returned. 
    w : array_like, shape (`M`,), optional 
        Weights. If not None, the weight ``w[i]`` applies to the unsquared 
        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are 
        chosen so that the errors of the products ``w[i]*y[i]`` all have the 
        same variance.  When using inverse-variance weighting, use 
        ``w[i] = 1/sigma(y[i])``.  The default value is None. 
 
    Returns 
    ------- 
    coef : ndarray, shape (M,) or (M, K) 
        Hermite coefficients ordered from low to high. If `y` was 2-D, 
        the coefficients for the data in column k  of `y` are in column 
        `k`. 
 
    [residuals, rank, singular_values, rcond] : list 
        These values are only returned if ``full == True`` 
 
        - residuals -- sum of squared residuals of the least squares fit 
        - rank -- the numerical rank of the scaled Vandermonde matrix 
        - singular_values -- singular values of the scaled Vandermonde matrix 
        - rcond -- value of `rcond`. 
 
        For more details, see `numpy.linalg.lstsq`. 
 
    Warns 
    ----- 
    RankWarning 
        The rank of the coefficient matrix in the least-squares fit is 
        deficient. The warning is only raised if ``full = False``.  The 
        warnings can be turned off by 
 
        &gt;&gt;&gt; import warnings 
        &gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning) 
 
    See Also 
    -------- 
    numpy.polynomial.chebyshev.chebfit 
    numpy.polynomial.legendre.legfit 
    numpy.polynomial.polynomial.polyfit 
    numpy.polynomial.hermite.hermfit 
    numpy.polynomial.laguerre.lagfit 
    hermeval : Evaluates a Hermite series. 
    hermevander : pseudo Vandermonde matrix of Hermite series. 
    hermeweight : HermiteE weight function. 
    numpy.linalg.lstsq : Computes a least-squares fit from the matrix. 
    scipy.interpolate.UnivariateSpline : Computes spline fits. 
 
    Notes 
    ----- 
    The solution is the coefficients of the HermiteE series `p` that 
    minimizes the sum of the weighted squared errors 
 
    .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2, 
 
    where the :math:`w_j` are the weights. This problem is solved by 
    setting up the (typically) overdetermined matrix equation 
 
    .. math:: V(x) * c = w * y, 
 
    where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c` 
    are the coefficients to be solved for, and the elements of `y` are the 
    observed values.  This equation is then solved using the singular value 
    decomposition of `V`. 
 
    If some of the singular values of `V` are so small that they are 
    neglected, then a `RankWarning` will be issued. This means that the 
    coefficient values may be poorly determined. Using a lower order fit 
    will usually get rid of the warning.  The `rcond` parameter can also be 
    set to a value smaller than its default, but the resulting fit may be 
    spurious and have large contributions from roundoff error. 
 
    Fits using HermiteE series are probably most useful when the data can 
    be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the HermiteE 
    weight. In that case the weight ``sqrt(w(x[i]))`` should be used 
    together with data values ``y[i]/sqrt(w(x[i]))``. The weight function is 
    available as `hermeweight`. 
 
    References 
    ---------- 
    .. [1] Wikipedia, &quot;Curve fitting&quot;, 
           https://en.wikipedia.org/wiki/Curve_fitting 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermefit, hermeval 
    &gt;&gt;&gt; x = np.linspace(-10, 10) 
    &gt;&gt;&gt; np.random.seed(123) 
    &gt;&gt;&gt; err = np.random.randn(len(x))/10 
    &gt;&gt;&gt; y = hermeval(x, [1, 2, 3]) + err 
    &gt;&gt;&gt; hermefit(x, y, 2) 
    array([ 1.01690445,  1.99951418,  2.99948696]) # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pu._fit(hermevander</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">full</span><span class="s2">, </span><span class="s1">w)</span>


<span class="s2">def </span><span class="s1">hermecompanion(c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the scaled companion matrix of c. 
 
    The basis polynomials are scaled so that the companion matrix is 
    symmetric when `c` is an HermiteE basis polynomial. This provides 
    better eigenvalue estimates than the unscaled case and for basis 
    polynomials the eigenvalues are guaranteed to be real if 
    `numpy.linalg.eigvalsh` is used to obtain them. 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of HermiteE series coefficients ordered from low to high 
        degree. 
 
    Returns 
    ------- 
    mat : ndarray 
        Scaled companion matrix of dimensions (deg, deg). 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># c is a trimmed copy</span>
    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s2">if </span><span class="s1">len(c) &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Series must have maximum degree of at least 1.'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.array([[-c[</span><span class="s4">0</span><span class="s1">]/c[</span><span class="s4">1</span><span class="s1">]]])</span>

    <span class="s1">n = len(c) - </span><span class="s4">1</span>
    <span class="s1">mat = np.zeros((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=c.dtype)</span>
    <span class="s1">scl = np.hstack((</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/np.sqrt(np.arange(n - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))))</span>
    <span class="s1">scl = np.multiply.accumulate(scl)[::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">top = mat.reshape(-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">::n+</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">bot = mat.reshape(-</span><span class="s4">1</span><span class="s1">)[n::n+</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">top[...] = np.sqrt(np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n))</span>
    <span class="s1">bot[...] = top</span>
    <span class="s1">mat[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] -= scl*c[:-</span><span class="s4">1</span><span class="s1">]/c[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">mat</span>


<span class="s2">def </span><span class="s1">hermeroots(c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the roots of a HermiteE series. 
 
    Return the roots (a.k.a. &quot;zeros&quot;) of the polynomial 
 
    .. math:: p(x) = \\sum_i c[i] * He_i(x). 
 
    Parameters 
    ---------- 
    c : 1-D array_like 
        1-D array of coefficients. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of the roots of the series. If all the roots are real, 
        then `out` is also real, otherwise it is complex. 
 
    See Also 
    -------- 
    numpy.polynomial.polynomial.polyroots 
    numpy.polynomial.legendre.legroots 
    numpy.polynomial.laguerre.lagroots 
    numpy.polynomial.hermite.hermroots 
    numpy.polynomial.chebyshev.chebroots 
 
    Notes 
    ----- 
    The root estimates are obtained as the eigenvalues of the companion 
    matrix, Roots far from the origin of the complex plane may have large 
    errors due to the numerical instability of the series for such 
    values. Roots with multiplicity greater than 1 will also show larger 
    errors as the value of the series near such points is relatively 
    insensitive to errors in the roots. Isolated roots near the origin can 
    be improved by a few iterations of Newton's method. 
 
    The HermiteE series basis polynomials aren't powers of `x` so the 
    results of this function may seem unintuitive. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeroots, hermefromroots 
    &gt;&gt;&gt; coef = hermefromroots([-1, 0, 1]) 
    &gt;&gt;&gt; coef 
    array([0., 2., 0., 1.]) 
    &gt;&gt;&gt; hermeroots(coef) 
    array([-1.,  0.,  1.]) # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># c is a trimmed copy</span>
    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s2">if </span><span class="s1">len(c) &lt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=c.dtype)</span>
    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.array([-c[</span><span class="s4">0</span><span class="s1">]/c[</span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s5"># rotated companion matrix reduces error</span>
    <span class="s1">m = hermecompanion(c)[::-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">r = la.eigvals(m)</span>
    <span class="s1">r.sort()</span>
    <span class="s2">return </span><span class="s1">r</span>


<span class="s2">def </span><span class="s1">_normed_hermite_e_n(x</span><span class="s2">, </span><span class="s1">n):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a normalized HermiteE polynomial. 
 
    Compute the value of the normalized HermiteE polynomial of degree ``n`` 
    at the points ``x``. 
 
 
    Parameters 
    ---------- 
    x : ndarray of double. 
        Points at which to evaluate the function 
    n : int 
        Degree of the normalized HermiteE function to be evaluated. 
 
    Returns 
    ------- 
    values : ndarray 
        The shape of the return value is described above. 
 
    Notes 
    ----- 
    .. versionadded:: 1.10.0 
 
    This function is needed for finding the Gauss points and integration 
    weights for high degrees. The values of the standard HermiteE functions 
    overflow when n &gt;= 207. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">n == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.full(x.shape</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/np.sqrt(np.sqrt(</span><span class="s4">2</span><span class="s1">*np.pi)))</span>

    <span class="s1">c0 = </span><span class="s4">0.</span>
    <span class="s1">c1 = </span><span class="s4">1.</span><span class="s1">/np.sqrt(np.sqrt(</span><span class="s4">2</span><span class="s1">*np.pi))</span>
    <span class="s1">nd = float(n)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">tmp = c0</span>
        <span class="s1">c0 = -c1*np.sqrt((nd - </span><span class="s4">1.</span><span class="s1">)/nd)</span>
        <span class="s1">c1 = tmp + c1*x*np.sqrt(</span><span class="s4">1.</span><span class="s1">/nd)</span>
        <span class="s1">nd = nd - </span><span class="s4">1.0</span>
    <span class="s2">return </span><span class="s1">c0 + c1*x</span>


<span class="s2">def </span><span class="s1">hermegauss(deg):</span>
    <span class="s0">&quot;&quot;&quot; 
    Gauss-HermiteE quadrature. 
 
    Computes the sample points and weights for Gauss-HermiteE quadrature. 
    These sample points and weights will correctly integrate polynomials of 
    degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]` 
    with the weight function :math:`f(x) = \\exp(-x^2/2)`. 
 
    Parameters 
    ---------- 
    deg : int 
        Number of sample points and weights. It must be &gt;= 1. 
 
    Returns 
    ------- 
    x : ndarray 
        1-D ndarray containing the sample points. 
    y : ndarray 
        1-D ndarray containing the weights. 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    The results have only been tested up to degree 100, higher degrees may 
    be problematic. The weights are determined by using the fact that 
 
    .. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k)) 
 
    where :math:`c` is a constant independent of :math:`k` and :math:`x_k` 
    is the k'th root of :math:`He_n`, and then scaling the results to get 
    the right value when integrating 1. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ideg = pu._deprecate_as_int(deg</span><span class="s2">, </span><span class="s3">&quot;deg&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">ideg &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;deg must be a positive integer&quot;</span><span class="s1">)</span>

    <span class="s5"># first approximation of roots. We use the fact that the companion</span>
    <span class="s5"># matrix is symmetric in this case in order to obtain better zeros.</span>
    <span class="s1">c = np.array([</span><span class="s4">0</span><span class="s1">]*deg + [</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">m = hermecompanion(c)</span>
    <span class="s1">x = la.eigvalsh(m)</span>

    <span class="s5"># improve roots by one application of Newton</span>
    <span class="s1">dy = _normed_hermite_e_n(x</span><span class="s2">, </span><span class="s1">ideg)</span>
    <span class="s1">df = _normed_hermite_e_n(x</span><span class="s2">, </span><span class="s1">ideg - </span><span class="s4">1</span><span class="s1">) * np.sqrt(ideg)</span>
    <span class="s1">x -= dy/df</span>

    <span class="s5"># compute the weights. We scale the factor to avoid possible numerical</span>
    <span class="s5"># overflow.</span>
    <span class="s1">fm = _normed_hermite_e_n(x</span><span class="s2">, </span><span class="s1">ideg - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">fm /= np.abs(fm).max()</span>
    <span class="s1">w = </span><span class="s4">1</span><span class="s1">/(fm * fm)</span>

    <span class="s5"># for Hermite_e we can also symmetrize</span>
    <span class="s1">w = (w + w[::-</span><span class="s4">1</span><span class="s1">])/</span><span class="s4">2</span>
    <span class="s1">x = (x - x[::-</span><span class="s4">1</span><span class="s1">])/</span><span class="s4">2</span>

    <span class="s5"># scale w to get the right value</span>
    <span class="s1">w *= np.sqrt(</span><span class="s4">2</span><span class="s1">*np.pi) / w.sum()</span>

    <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">w</span>


<span class="s2">def </span><span class="s1">hermeweight(x):</span>
    <span class="s0">&quot;&quot;&quot;Weight function of the Hermite_e polynomials. 
 
    The weight function is :math:`\\exp(-x^2/2)` and the interval of 
    integration is :math:`[-\\inf, \\inf]`. the HermiteE polynomials are 
    orthogonal, but not normalized, with respect to this weight function. 
 
    Parameters 
    ---------- 
    x : array_like 
       Values at which the weight function will be computed. 
 
    Returns 
    ------- 
    w : ndarray 
       The weight function at `x`. 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">w = np.exp(-</span><span class="s4">.5</span><span class="s1">*x**</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">w</span>


<span class="s5">#</span>
<span class="s5"># HermiteE series class</span>
<span class="s5">#</span>

<span class="s2">class </span><span class="s1">HermiteE(ABCPolyBase):</span>
    <span class="s0">&quot;&quot;&quot;An HermiteE series class. 
 
    The HermiteE class provides the standard Python numerical methods 
    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the 
    attributes and methods listed in the `ABCPolyBase` documentation. 
 
    Parameters 
    ---------- 
    coef : array_like 
        HermiteE coefficients in order of increasing degree, i.e, 
        ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``. 
    domain : (2,) array_like, optional 
        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped 
        to the interval ``[window[0], window[1]]`` by shifting and scaling. 
        The default value is [-1, 1]. 
    window : (2,) array_like, optional 
        Window, see `domain` for its use. The default value is [-1, 1]. 
 
        .. versionadded:: 1.6.0 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Virtual Functions</span>
    <span class="s1">_add = staticmethod(hermeadd)</span>
    <span class="s1">_sub = staticmethod(hermesub)</span>
    <span class="s1">_mul = staticmethod(hermemul)</span>
    <span class="s1">_div = staticmethod(hermediv)</span>
    <span class="s1">_pow = staticmethod(hermepow)</span>
    <span class="s1">_val = staticmethod(hermeval)</span>
    <span class="s1">_int = staticmethod(hermeint)</span>
    <span class="s1">_der = staticmethod(hermeder)</span>
    <span class="s1">_fit = staticmethod(hermefit)</span>
    <span class="s1">_line = staticmethod(hermeline)</span>
    <span class="s1">_roots = staticmethod(hermeroots)</span>
    <span class="s1">_fromroots = staticmethod(hermefromroots)</span>

    <span class="s5"># Virtual properties</span>
    <span class="s1">domain = np.array(hermedomain)</span>
    <span class="s1">window = np.array(hermedomain)</span>
    <span class="s1">basis_name = </span><span class="s3">'He'</span>
</pre>
</body>
</html>