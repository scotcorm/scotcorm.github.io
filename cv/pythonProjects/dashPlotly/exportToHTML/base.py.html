<html>
<head>
<title>base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">distutils.version </span><span class="s0">import </span><span class="s1">LooseVersion</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">transforms</span>

<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">_py3k_compat </span><span class="s0">as </span><span class="s1">py3k</span>


<span class="s0">class </span><span class="s1">Renderer(object):</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">ax_zoomable(ax):</span>
        <span class="s0">return </span><span class="s1">bool(ax </span><span class="s0">and </span><span class="s1">ax.get_navigate())</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">ax_has_xgrid(ax):</span>
        <span class="s0">return </span><span class="s1">bool(ax </span><span class="s0">and </span><span class="s1">ax.xaxis._gridOnMajor </span><span class="s0">and </span><span class="s1">ax.yaxis.get_gridlines())</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">ax_has_ygrid(ax):</span>
        <span class="s0">return </span><span class="s1">bool(ax </span><span class="s0">and </span><span class="s1">ax.yaxis._gridOnMajor </span><span class="s0">and </span><span class="s1">ax.yaxis.get_gridlines())</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">current_ax_zoomable(self):</span>
        <span class="s0">return </span><span class="s1">self.ax_zoomable(self._current_ax)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">current_ax_has_xgrid(self):</span>
        <span class="s0">return </span><span class="s1">self.ax_has_xgrid(self._current_ax)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">current_ax_has_ygrid(self):</span>
        <span class="s0">return </span><span class="s1">self.ax_has_ygrid(self._current_ax)</span>

    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">draw_figure(self</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s2">&quot;_current_fig&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">self._current_fig </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;figure embedded in figure: something is wrong&quot;</span><span class="s1">)</span>
        <span class="s1">self._current_fig = fig</span>
        <span class="s1">self._fig_props = props</span>
        <span class="s1">self.open_figure(fig=fig</span><span class="s0">, </span><span class="s1">props=props)</span>
        <span class="s0">yield</span>
        <span class="s1">self.close_figure(fig=fig)</span>
        <span class="s1">self._current_fig = </span><span class="s0">None</span>
        <span class="s1">self._fig_props = {}</span>

    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">draw_axes(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s2">&quot;_current_ax&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">self._current_ax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;axes embedded in axes: something is wrong&quot;</span><span class="s1">)</span>
        <span class="s1">self._current_ax = ax</span>
        <span class="s1">self._ax_props = props</span>
        <span class="s1">self.open_axes(ax=ax</span><span class="s0">, </span><span class="s1">props=props)</span>
        <span class="s0">yield</span>
        <span class="s1">self.close_axes(ax=ax)</span>
        <span class="s1">self._current_ax = </span><span class="s0">None</span>
        <span class="s1">self._ax_props = {}</span>

    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">draw_legend(self</span><span class="s0">, </span><span class="s1">legend</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s1">self._current_legend = legend</span>
        <span class="s1">self._legend_props = props</span>
        <span class="s1">self.open_legend(legend=legend</span><span class="s0">, </span><span class="s1">props=props)</span>
        <span class="s0">yield</span>
        <span class="s1">self.close_legend(legend=legend)</span>
        <span class="s1">self._current_legend = </span><span class="s0">None</span>
        <span class="s1">self._legend_props = {}</span>

    <span class="s3"># Following are the functions which should be overloaded in subclasses</span>

    <span class="s0">def </span><span class="s1">open_figure(self</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s4">&quot;&quot;&quot; 
        Begin commands for a particular figure. 
 
        Parameters 
        ---------- 
        fig : matplotlib.Figure 
            The Figure which will contain the ensuing axes and elements 
        props : dictionary 
            The dictionary of figure properties 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">close_figure(self</span><span class="s0">, </span><span class="s1">fig):</span>
        <span class="s4">&quot;&quot;&quot; 
        Finish commands for a particular figure. 
 
        Parameters 
        ---------- 
        fig : matplotlib.Figure 
            The figure which is finished being drawn. 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">open_axes(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s4">&quot;&quot;&quot; 
        Begin commands for a particular axes. 
 
        Parameters 
        ---------- 
        ax : matplotlib.Axes 
            The Axes which will contain the ensuing axes and elements 
        props : dictionary 
            The dictionary of axes properties 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">close_axes(self</span><span class="s0">, </span><span class="s1">ax):</span>
        <span class="s4">&quot;&quot;&quot; 
        Finish commands for a particular axes. 
 
        Parameters 
        ---------- 
        ax : matplotlib.Axes 
            The Axes which is finished being drawn. 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">open_legend(self</span><span class="s0">, </span><span class="s1">legend</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s4">&quot;&quot;&quot; 
        Beging commands for a particular legend. 
 
        Parameters 
        ---------- 
        legend : matplotlib.legend.Legend 
                The Legend that will contain the ensuing elements 
        props : dictionary 
                The dictionary of legend properties 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">close_legend(self</span><span class="s0">, </span><span class="s1">legend):</span>
        <span class="s4">&quot;&quot;&quot; 
        Finish commands for a particular legend. 
 
        Parameters 
        ---------- 
        legend : matplotlib.legend.Legend 
                The Legend which is finished being drawn 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">draw_marked_line(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">linestyle</span><span class="s0">, </span><span class="s1">markerstyle</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">mplobj=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Draw a line that also has markers. 
 
        If this isn't reimplemented by a renderer object, by default, it will 
        make a call to BOTH draw_line and draw_markers when both markerstyle 
        and linestyle are not None in the same Line2D object. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">linestyle </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.draw_line(data</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">linestyle</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">mplobj)</span>
        <span class="s0">if </span><span class="s1">markerstyle </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.draw_markers(data</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">markerstyle</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">mplobj)</span>

    <span class="s0">def </span><span class="s1">draw_line(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">mplobj=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw a line. By default, draw the line via the draw_path() command. 
        Some renderers might wish to override this and provide more 
        fine-grained behavior. 
 
        In matplotlib, lines are generally created via the plt.plot() command, 
        though this command also can create marker collections. 
 
        Parameters 
        ---------- 
        data : array_like 
            A shape (N, 2) array of datapoints. 
        coordinates : string 
            A string code, which should be either 'data' for data coordinates, 
            or 'figure' for figure (pixel) coordinates. 
        style : dictionary 
            a dictionary specifying the appearance of the line. 
        mplobj : matplotlib object 
            the matplotlib plot element which generated this line 
        &quot;&quot;&quot;</span>
        <span class="s1">pathcodes = [</span><span class="s2">&quot;M&quot;</span><span class="s1">] + (data.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) * [</span><span class="s2">&quot;L&quot;</span><span class="s1">]</span>
        <span class="s1">pathstyle = dict(facecolor=</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s1">**style)</span>
        <span class="s1">pathstyle[</span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">] = pathstyle.pop(</span><span class="s2">&quot;color&quot;</span><span class="s1">)</span>
        <span class="s1">pathstyle[</span><span class="s2">&quot;edgewidth&quot;</span><span class="s1">] = pathstyle.pop(</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">)</span>
        <span class="s1">self.draw_path(</span>
            <span class="s1">data=data</span><span class="s0">,</span>
            <span class="s1">coordinates=coordinates</span><span class="s0">,</span>
            <span class="s1">pathcodes=pathcodes</span><span class="s0">,</span>
            <span class="s1">style=pathstyle</span><span class="s0">,</span>
            <span class="s1">mplobj=mplobj</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_iter_path_collection(paths</span><span class="s0">, </span><span class="s1">path_transforms</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">styles):</span>
        <span class="s4">&quot;&quot;&quot;Build an iterator over the elements of the path collection&quot;&quot;&quot;</span>
        <span class="s1">N = max(len(paths)</span><span class="s0">, </span><span class="s1">len(offsets))</span>

        <span class="s3"># Before mpl 1.4.0, path_transform can be a false-y value, not a valid</span>
        <span class="s3"># transformation matrix.</span>
        <span class="s0">if </span><span class="s1">LooseVersion(mpl.__version__) &lt; LooseVersion(</span><span class="s2">&quot;1.4.0&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">path_transforms </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">path_transforms = [np.eye(</span><span class="s5">3</span><span class="s1">)]</span>

        <span class="s1">edgecolor = styles[</span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">np.size(edgecolor) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">edgecolor = [</span><span class="s2">&quot;none&quot;</span><span class="s1">]</span>
        <span class="s1">facecolor = styles[</span><span class="s2">&quot;facecolor&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">np.size(facecolor) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">facecolor = [</span><span class="s2">&quot;none&quot;</span><span class="s1">]</span>

        <span class="s1">elements = [</span>
            <span class="s1">paths</span><span class="s0">,</span>
            <span class="s1">path_transforms</span><span class="s0">,</span>
            <span class="s1">offsets</span><span class="s0">,</span>
            <span class="s1">edgecolor</span><span class="s0">,</span>
            <span class="s1">styles[</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">facecolor</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">it = itertools</span>
        <span class="s0">return </span><span class="s1">it.islice(py3k.zip(*py3k.map(it.cycle</span><span class="s0">, </span><span class="s1">elements))</span><span class="s0">, </span><span class="s1">N)</span>

    <span class="s0">def </span><span class="s1">draw_path_collection(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">paths</span><span class="s0">,</span>
        <span class="s1">path_coordinates</span><span class="s0">,</span>
        <span class="s1">path_transforms</span><span class="s0">,</span>
        <span class="s1">offsets</span><span class="s0">,</span>
        <span class="s1">offset_coordinates</span><span class="s0">,</span>
        <span class="s1">offset_order</span><span class="s0">,</span>
        <span class="s1">styles</span><span class="s0">,</span>
        <span class="s1">mplobj=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw a collection of paths. The paths, offsets, and styles are all 
        iterables, and the number of paths is max(len(paths), len(offsets)). 
 
        By default, this is implemented via multiple calls to the draw_path() 
        function. For efficiency, Renderers may choose to customize this 
        implementation. 
 
        Examples of path collections created by matplotlib are scatter plots, 
        histograms, contour plots, and many others. 
 
        Parameters 
        ---------- 
        paths : list 
            list of tuples, where each tuple has two elements: 
            (data, pathcodes).  See draw_path() for a description of these. 
        path_coordinates: string 
            the coordinates code for the paths, which should be either 
            'data' for data coordinates, or 'figure' for figure (pixel) 
            coordinates. 
        path_transforms: array_like 
            an array of shape (*, 3, 3), giving a series of 2D Affine 
            transforms for the paths. These encode translations, rotations, 
            and scalings in the standard way. 
        offsets: array_like 
            An array of offsets of shape (N, 2) 
        offset_coordinates : string 
            the coordinates code for the offsets, which should be either 
            'data' for data coordinates, or 'figure' for figure (pixel) 
            coordinates. 
        offset_order : string 
            either &quot;before&quot; or &quot;after&quot;. This specifies whether the offset 
            is applied before the path transform, or after.  The matplotlib 
            backend equivalent is &quot;before&quot;-&gt;&quot;data&quot;, &quot;after&quot;-&gt;&quot;screen&quot;. 
        styles: dictionary 
            A dictionary in which each value is a list of length N, containing 
            the style(s) for the paths. 
        mplobj : matplotlib object 
            the matplotlib plot element which generated this collection 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">offset_order == </span><span class="s2">&quot;before&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;offset before transform&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">tup </span><span class="s0">in </span><span class="s1">self._iter_path_collection(paths</span><span class="s0">, </span><span class="s1">path_transforms</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">styles):</span>
            <span class="s1">(path</span><span class="s0">, </span><span class="s1">path_transform</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">ec</span><span class="s0">, </span><span class="s1">lw</span><span class="s0">, </span><span class="s1">fc) = tup</span>
            <span class="s1">vertices</span><span class="s0">, </span><span class="s1">pathcodes = path</span>
            <span class="s1">path_transform = transforms.Affine2D(path_transform)</span>
            <span class="s1">vertices = path_transform.transform(vertices)</span>
            <span class="s3"># This is a hack:</span>
            <span class="s0">if </span><span class="s1">path_coordinates == </span><span class="s2">&quot;figure&quot;</span><span class="s1">:</span>
                <span class="s1">path_coordinates = </span><span class="s2">&quot;points&quot;</span>
            <span class="s1">style = {</span>
                <span class="s2">&quot;edgecolor&quot;</span><span class="s1">: utils.export_color(ec)</span><span class="s0">,</span>
                <span class="s2">&quot;facecolor&quot;</span><span class="s1">: utils.export_color(fc)</span><span class="s0">,</span>
                <span class="s2">&quot;edgewidth&quot;</span><span class="s1">: lw</span><span class="s0">,</span>
                <span class="s2">&quot;dasharray&quot;</span><span class="s1">: </span><span class="s2">&quot;10,0&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;alpha&quot;</span><span class="s1">: styles[</span><span class="s2">&quot;alpha&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;zorder&quot;</span><span class="s1">: styles[</span><span class="s2">&quot;zorder&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s1">self.draw_path(</span>
                <span class="s1">data=vertices</span><span class="s0">,</span>
                <span class="s1">coordinates=path_coordinates</span><span class="s0">,</span>
                <span class="s1">pathcodes=pathcodes</span><span class="s0">,</span>
                <span class="s1">style=style</span><span class="s0">,</span>
                <span class="s1">offset=offset</span><span class="s0">,</span>
                <span class="s1">offset_coordinates=offset_coordinates</span><span class="s0">,</span>
                <span class="s1">mplobj=mplobj</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">draw_markers(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">mplobj=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw a set of markers. By default, this is done by repeatedly 
        calling draw_path(), but renderers should generally overload 
        this method to provide a more efficient implementation. 
 
        In matplotlib, markers are created using the plt.plot() command. 
 
        Parameters 
        ---------- 
        data : array_like 
            A shape (N, 2) array of datapoints. 
        coordinates : string 
            A string code, which should be either 'data' for data coordinates, 
            or 'figure' for figure (pixel) coordinates. 
        style : dictionary 
            a dictionary specifying the appearance of the markers. 
        mplobj : matplotlib object 
            the matplotlib plot element which generated this marker collection 
        &quot;&quot;&quot;</span>
        <span class="s1">vertices</span><span class="s0">, </span><span class="s1">pathcodes = style[</span><span class="s2">&quot;markerpath&quot;</span><span class="s1">]</span>
        <span class="s1">pathstyle = dict(</span>
            <span class="s1">(key</span><span class="s0">, </span><span class="s1">style[key])</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;alpha&quot;</span><span class="s0">, </span><span class="s2">&quot;edgecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;facecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;zorder&quot;</span><span class="s0">, </span><span class="s2">&quot;edgewidth&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">pathstyle[</span><span class="s2">&quot;dasharray&quot;</span><span class="s1">] = </span><span class="s2">&quot;10,0&quot;</span>
        <span class="s0">for </span><span class="s1">vertex </span><span class="s0">in </span><span class="s1">data:</span>
            <span class="s1">self.draw_path(</span>
                <span class="s1">data=vertices</span><span class="s0">,</span>
                <span class="s1">coordinates=</span><span class="s2">&quot;points&quot;</span><span class="s0">,</span>
                <span class="s1">pathcodes=pathcodes</span><span class="s0">,</span>
                <span class="s1">style=pathstyle</span><span class="s0">,</span>
                <span class="s1">offset=vertex</span><span class="s0">,</span>
                <span class="s1">offset_coordinates=coordinates</span><span class="s0">,</span>
                <span class="s1">mplobj=mplobj</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">draw_text(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">text</span><span class="s0">, </span><span class="s1">position</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">text_type=</span><span class="s0">None, </span><span class="s1">mplobj=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw text on the image. 
 
        Parameters 
        ---------- 
        text : string 
            The text to draw 
        position : tuple 
            The (x, y) position of the text 
        coordinates : string 
            A string code, which should be either 'data' for data coordinates, 
            or 'figure' for figure (pixel) coordinates. 
        style : dictionary 
            a dictionary specifying the appearance of the text. 
        text_type : string or None 
            if specified, a type of text such as &quot;xlabel&quot;, &quot;ylabel&quot;, &quot;title&quot; 
        mplobj : matplotlib object 
            the matplotlib plot element which generated this text 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">draw_path(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">data</span><span class="s0">,</span>
        <span class="s1">coordinates</span><span class="s0">,</span>
        <span class="s1">pathcodes</span><span class="s0">,</span>
        <span class="s1">style</span><span class="s0">,</span>
        <span class="s1">offset=</span><span class="s0">None,</span>
        <span class="s1">offset_coordinates=</span><span class="s2">&quot;data&quot;</span><span class="s0">,</span>
        <span class="s1">mplobj=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw a path. 
 
        In matplotlib, paths are created by filled regions, histograms, 
        contour plots, patches, etc. 
 
        Parameters 
        ---------- 
        data : array_like 
            A shape (N, 2) array of datapoints. 
        coordinates : string 
            A string code, which should be either 'data' for data coordinates, 
            'figure' for figure (pixel) coordinates, or &quot;points&quot; for raw 
            point coordinates (useful in conjunction with offsets, below). 
        pathcodes : list 
            A list of single-character SVG pathcodes associated with the data. 
            Path codes are one of ['M', 'm', 'L', 'l', 'Q', 'q', 'T', 't', 
                                   'S', 's', 'C', 'c', 'Z', 'z'] 
            See the SVG specification for details.  Note that some path codes 
            consume more than one datapoint (while 'Z' consumes none), so 
            in general, the length of the pathcodes list will not be the same 
            as that of the data array. 
        style : dictionary 
            a dictionary specifying the appearance of the line. 
        offset : list (optional) 
            the (x, y) offset of the path. If not given, no offset will 
            be used. 
        offset_coordinates : string (optional) 
            A string code, which should be either 'data' for data coordinates, 
            or 'figure' for figure (pixel) coordinates. 
        mplobj : matplotlib object 
            the matplotlib plot element which generated this path 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">draw_image(self</span><span class="s0">, </span><span class="s1">imdata</span><span class="s0">, </span><span class="s1">extent</span><span class="s0">, </span><span class="s1">coordinates</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">mplobj=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw an image. 
 
        Parameters 
        ---------- 
        imdata : string 
            base64 encoded png representation of the image 
        extent : list 
            the axes extent of the image: [xmin, xmax, ymin, ymax] 
        coordinates: string 
            A string code, which should be either 'data' for data coordinates, 
            or 'figure' for figure (pixel) coordinates. 
        style : dictionary 
            a dictionary specifying the appearance of the image 
        mplobj : matplotlib object 
            the matplotlib plot object which generated this image 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>
</pre>
</body>
</html>