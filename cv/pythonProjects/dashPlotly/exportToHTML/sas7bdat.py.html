<html>
<head>
<title>sas7bdat.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sas7bdat.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Read SAS7BDAT files 
 
Based on code written by Jared Hobbs: 
  https://bitbucket.org/jaredhobbs/sas7bdat 
 
See also: 
  https://github.com/BioStatMatt/sas7bdat 
 
Partial documentation of the file format: 
  https://cran.r-project.org/package=sas7bdat/vignettes/sas7bdat.pdf 
 
Reference for binary data compression: 
  http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/1992/9210/ross/ross.htm 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FilePath</span><span class="s2">,</span>
    <span class="s1">ReadBuffer</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">EmptyDataError</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsDatetime</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.io.common </span><span class="s2">import </span><span class="s1">get_handle</span>
<span class="s2">from </span><span class="s1">pandas.io.sas._sas </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">import </span><span class="s1">pandas.io.sas.sas_constants </span><span class="s2">as </span><span class="s1">const</span>
<span class="s2">from </span><span class="s1">pandas.io.sas.sasreader </span><span class="s2">import </span><span class="s1">ReaderBase</span>


<span class="s2">def </span><span class="s1">_parse_datetime(sas_datetime: float</span><span class="s2">, </span><span class="s1">unit: str):</span>
    <span class="s2">if </span><span class="s1">isna(sas_datetime):</span>
        <span class="s2">return </span><span class="s1">pd.NaT</span>

    <span class="s2">if </span><span class="s1">unit == </span><span class="s3">&quot;s&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">datetime(</span><span class="s4">1960</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + timedelta(seconds=sas_datetime)</span>

    <span class="s2">elif </span><span class="s1">unit == </span><span class="s3">&quot;d&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">datetime(</span><span class="s4">1960</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + timedelta(days=sas_datetime)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unit must be 'd' or 's'&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_convert_datetimes(sas_datetimes: pd.Series</span><span class="s2">, </span><span class="s1">unit: str) -&gt; pd.Series:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert to Timestamp if possible, otherwise to datetime.datetime. 
    SAS float64 lacks precision for more than ms resolution so the fit 
    to datetime.datetime is ok. 
 
    Parameters 
    ---------- 
    sas_datetimes : {Series, Sequence[float]} 
       Dates or datetimes in SAS 
    unit : {str} 
       &quot;d&quot; if the floats represent dates, &quot;s&quot; for datetimes 
 
    Returns 
    ------- 
    Series 
       Series of datetime64 dtype or datetime.datetime. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.to_datetime(sas_datetimes</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1960-01-01&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
        <span class="s1">s_series = sas_datetimes.apply(_parse_datetime</span><span class="s2">, </span><span class="s1">unit=unit)</span>
        <span class="s1">s_series = cast(pd.Series</span><span class="s2">, </span><span class="s1">s_series)</span>
        <span class="s2">return </span><span class="s1">s_series</span>


<span class="s2">class </span><span class="s1">_SubheaderPointer:</span>
    <span class="s1">offset: int</span>
    <span class="s1">length: int</span>
    <span class="s1">compression: int</span>
    <span class="s1">ptype: int</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int</span><span class="s2">, </span><span class="s1">compression: int</span><span class="s2">, </span><span class="s1">ptype: int):</span>
        <span class="s1">self.offset = offset</span>
        <span class="s1">self.length = length</span>
        <span class="s1">self.compression = compression</span>
        <span class="s1">self.ptype = ptype</span>


<span class="s2">class </span><span class="s1">_Column:</span>
    <span class="s1">col_id: int</span>
    <span class="s1">name: str | bytes</span>
    <span class="s1">label: str | bytes</span>
    <span class="s1">format: str | bytes</span>
    <span class="s1">ctype: bytes</span>
    <span class="s1">length: int</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">col_id: int</span><span class="s2">,</span>
        <span class="s5"># These can be bytes when convert_header_text is False</span>
        <span class="s1">name: str | bytes</span><span class="s2">,</span>
        <span class="s1">label: str | bytes</span><span class="s2">,</span>
        <span class="s1">format: str | bytes</span><span class="s2">,</span>
        <span class="s1">ctype: bytes</span><span class="s2">,</span>
        <span class="s1">length: int</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self.col_id = col_id</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.label = label</span>
        <span class="s1">self.format = format</span>
        <span class="s1">self.ctype = ctype</span>
        <span class="s1">self.length = length</span>


<span class="s5"># SAS7BDAT represents a SAS data file in SAS7BDAT format.</span>
<span class="s2">class </span><span class="s1">SAS7BDATReader(ReaderBase</span><span class="s2">, </span><span class="s1">abc.Iterator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Read SAS files in SAS7BDAT format. 
 
    Parameters 
    ---------- 
    path_or_buf : path name or buffer 
        Name of SAS file or file-like object pointing to SAS file 
        contents. 
    index : column identifier, defaults to None 
        Column to use as index. 
    convert_dates : bool, defaults to True 
        Attempt to convert dates to Pandas datetime values.  Note that 
        some rarely used SAS date formats may be unsupported. 
    blank_missing : bool, defaults to True 
        Convert empty strings to missing values (SAS uses blanks to 
        indicate missing character variables). 
    chunksize : int, defaults to None 
        Return SAS7BDATReader object for iterations, returns chunks 
        with given number of lines. 
    encoding : string, defaults to None 
        String encoding. 
    convert_text : bool, defaults to True 
        If False, text variables are left as raw bytes. 
    convert_header_text : bool, defaults to True 
        If False, header text, including column names, are left as raw 
        bytes. 
    &quot;&quot;&quot;</span>

    <span class="s1">_int_length: int</span>
    <span class="s1">_cached_page: bytes | </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_or_buf: FilePath | ReadBuffer[bytes]</span><span class="s2">,</span>
        <span class="s1">index=</span><span class="s2">None,</span>
        <span class="s1">convert_dates=</span><span class="s2">True,</span>
        <span class="s1">blank_missing=</span><span class="s2">True,</span>
        <span class="s1">chunksize=</span><span class="s2">None,</span>
        <span class="s1">encoding=</span><span class="s2">None,</span>
        <span class="s1">convert_text=</span><span class="s2">True,</span>
        <span class="s1">convert_header_text=</span><span class="s2">True,</span>
    <span class="s1">):</span>

        <span class="s1">self.index = index</span>
        <span class="s1">self.convert_dates = convert_dates</span>
        <span class="s1">self.blank_missing = blank_missing</span>
        <span class="s1">self.chunksize = chunksize</span>
        <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.convert_text = convert_text</span>
        <span class="s1">self.convert_header_text = convert_header_text</span>

        <span class="s1">self.default_encoding = </span><span class="s3">&quot;latin-1&quot;</span>
        <span class="s1">self.compression = </span><span class="s6">b&quot;&quot;</span>
        <span class="s1">self.column_names_strings: list[str] = []</span>
        <span class="s1">self.column_names: list[str] = []</span>
        <span class="s1">self.column_formats: list[str] = []</span>
        <span class="s1">self.columns: list[_Column] = []</span>

        <span class="s1">self._current_page_data_subheader_pointers: list[_SubheaderPointer] = []</span>
        <span class="s1">self._cached_page = </span><span class="s2">None</span>
        <span class="s1">self._column_data_lengths: list[int] = []</span>
        <span class="s1">self._column_data_offsets: list[int] = []</span>
        <span class="s1">self._column_types: list[bytes] = []</span>

        <span class="s1">self._current_row_in_file_index = </span><span class="s4">0</span>
        <span class="s1">self._current_row_on_page_index = </span><span class="s4">0</span>
        <span class="s1">self._current_row_in_file_index = </span><span class="s4">0</span>

        <span class="s1">self.handles = get_handle(path_or_buf</span><span class="s2">, </span><span class="s3">&quot;rb&quot;</span><span class="s2">, </span><span class="s1">is_text=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">self._path_or_buf = self.handles.handle</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._get_properties()</span>
            <span class="s1">self._parse_metadata()</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">column_data_lengths(self) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;Return a numpy int64 array of the column data lengths&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.asarray(self._column_data_lengths</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s2">def </span><span class="s1">column_data_offsets(self) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;Return a numpy int64 array of the column offsets&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.asarray(self._column_data_offsets</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s2">def </span><span class="s1">column_types(self) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a numpy character array of the column types: 
           s (string) or d (double) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.asarray(self._column_types</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;S1&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.handles.close()</span>

    <span class="s2">def </span><span class="s1">_get_properties(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>

        <span class="s5"># Check magic number</span>
        <span class="s1">self._path_or_buf.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self._cached_page = self._path_or_buf.read(</span><span class="s4">288</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._cached_page[</span><span class="s4">0 </span><span class="s1">: len(const.magic)] != const.magic:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;magic number mismatch (not a SAS file?)&quot;</span><span class="s1">)</span>

        <span class="s5"># Get alignment information</span>
        <span class="s1">align1</span><span class="s2">, </span><span class="s1">align2 = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span>
        <span class="s1">buf = self._read_bytes(const.align_1_offset</span><span class="s2">, </span><span class="s1">const.align_1_length)</span>
        <span class="s2">if </span><span class="s1">buf == const.u64_byte_checker_value:</span>
            <span class="s1">align2 = const.align_2_value</span>
            <span class="s1">self.U64 = </span><span class="s2">True</span>
            <span class="s1">self._int_length = </span><span class="s4">8</span>
            <span class="s1">self._page_bit_offset = const.page_bit_offset_x64</span>
            <span class="s1">self._subheader_pointer_length = const.subheader_pointer_length_x64</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.U64 = </span><span class="s2">False</span>
            <span class="s1">self._page_bit_offset = const.page_bit_offset_x86</span>
            <span class="s1">self._subheader_pointer_length = const.subheader_pointer_length_x86</span>
            <span class="s1">self._int_length = </span><span class="s4">4</span>
        <span class="s1">buf = self._read_bytes(const.align_2_offset</span><span class="s2">, </span><span class="s1">const.align_2_length)</span>
        <span class="s2">if </span><span class="s1">buf == const.align_1_checker_value:</span>
            <span class="s1">align1 = const.align_2_value</span>
        <span class="s1">total_align = align1 + align2</span>

        <span class="s5"># Get endianness information</span>
        <span class="s1">buf = self._read_bytes(const.endianness_offset</span><span class="s2">, </span><span class="s1">const.endianness_length)</span>
        <span class="s2">if </span><span class="s1">buf == </span><span class="s6">b&quot;</span><span class="s2">\x01</span><span class="s6">&quot;</span><span class="s1">:</span>
            <span class="s1">self.byte_order = </span><span class="s3">&quot;&lt;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.byte_order = </span><span class="s3">&quot;&gt;&quot;</span>

        <span class="s5"># Get encoding information</span>
        <span class="s1">buf = self._read_bytes(const.encoding_offset</span><span class="s2">, </span><span class="s1">const.encoding_length)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">buf </span><span class="s2">in </span><span class="s1">const.encoding_names:</span>
            <span class="s1">self.file_encoding = const.encoding_names[buf]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.file_encoding = </span><span class="s3">f&quot;unknown (code=</span><span class="s2">{</span><span class="s1">buf</span><span class="s2">}</span><span class="s3">)&quot;</span>

        <span class="s5"># Get platform information</span>
        <span class="s1">buf = self._read_bytes(const.platform_offset</span><span class="s2">, </span><span class="s1">const.platform_length)</span>
        <span class="s2">if </span><span class="s1">buf == </span><span class="s6">b&quot;1&quot;</span><span class="s1">:</span>
            <span class="s1">self.platform = </span><span class="s3">&quot;unix&quot;</span>
        <span class="s2">elif </span><span class="s1">buf == </span><span class="s6">b&quot;2&quot;</span><span class="s1">:</span>
            <span class="s1">self.platform = </span><span class="s3">&quot;windows&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.platform = </span><span class="s3">&quot;unknown&quot;</span>

        <span class="s1">buf = self._read_bytes(const.dataset_offset</span><span class="s2">, </span><span class="s1">const.dataset_length)</span>
        <span class="s1">self.name = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
            <span class="s1">self.name = self.name.decode(self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding)</span>

        <span class="s1">buf = self._read_bytes(const.file_type_offset</span><span class="s2">, </span><span class="s1">const.file_type_length)</span>
        <span class="s1">self.file_type = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
            <span class="s1">self.file_type = self.file_type.decode(</span>
                <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
            <span class="s1">)</span>

        <span class="s5"># Timestamp is epoch 01/01/1960</span>
        <span class="s1">epoch = datetime(</span><span class="s4">1960</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">x = self._read_float(</span>
            <span class="s1">const.date_created_offset + align1</span><span class="s2">, </span><span class="s1">const.date_created_length</span>
        <span class="s1">)</span>
        <span class="s1">self.date_created = epoch + pd.to_timedelta(x</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">x = self._read_float(</span>
            <span class="s1">const.date_modified_offset + align1</span><span class="s2">, </span><span class="s1">const.date_modified_length</span>
        <span class="s1">)</span>
        <span class="s1">self.date_modified = epoch + pd.to_timedelta(x</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>

        <span class="s1">self.header_length = self._read_int(</span>
            <span class="s1">const.header_size_offset + align1</span><span class="s2">, </span><span class="s1">const.header_size_length</span>
        <span class="s1">)</span>

        <span class="s5"># Read the rest of the header into cached_page.</span>
        <span class="s1">buf = self._path_or_buf.read(self.header_length - </span><span class="s4">288</span><span class="s1">)</span>
        <span class="s1">self._cached_page += buf</span>
        <span class="s5"># error: Argument 1 to &quot;len&quot; has incompatible type &quot;Optional[bytes]&quot;;</span>
        <span class="s5">#  expected &quot;Sized&quot;</span>
        <span class="s2">if </span><span class="s1">len(self._cached_page) != self.header_length:  </span><span class="s5"># type: ignore[arg-type]</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The SAS7BDAT file appears to be truncated.&quot;</span><span class="s1">)</span>

        <span class="s1">self._page_length = self._read_int(</span>
            <span class="s1">const.page_size_offset + align1</span><span class="s2">, </span><span class="s1">const.page_size_length</span>
        <span class="s1">)</span>
        <span class="s1">self._page_count = self._read_int(</span>
            <span class="s1">const.page_count_offset + align1</span><span class="s2">, </span><span class="s1">const.page_count_length</span>
        <span class="s1">)</span>

        <span class="s1">buf = self._read_bytes(</span>
            <span class="s1">const.sas_release_offset + total_align</span><span class="s2">, </span><span class="s1">const.sas_release_length</span>
        <span class="s1">)</span>
        <span class="s1">self.sas_release = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
            <span class="s1">self.sas_release = self.sas_release.decode(</span>
                <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
            <span class="s1">)</span>

        <span class="s1">buf = self._read_bytes(</span>
            <span class="s1">const.sas_server_type_offset + total_align</span><span class="s2">, </span><span class="s1">const.sas_server_type_length</span>
        <span class="s1">)</span>
        <span class="s1">self.server_type = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
            <span class="s1">self.server_type = self.server_type.decode(</span>
                <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
            <span class="s1">)</span>

        <span class="s1">buf = self._read_bytes(</span>
            <span class="s1">const.os_version_number_offset + total_align</span><span class="s2">, </span><span class="s1">const.os_version_number_length</span>
        <span class="s1">)</span>
        <span class="s1">self.os_version = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
            <span class="s1">self.os_version = self.os_version.decode(</span>
                <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
            <span class="s1">)</span>

        <span class="s1">buf = self._read_bytes(const.os_name_offset + total_align</span><span class="s2">, </span><span class="s1">const.os_name_length)</span>
        <span class="s1">buf = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(buf) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.os_name = buf.decode(self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buf = self._read_bytes(</span>
                <span class="s1">const.os_maker_offset + total_align</span><span class="s2">, </span><span class="s1">const.os_maker_length</span>
            <span class="s1">)</span>
            <span class="s1">self.os_name = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
                <span class="s1">self.os_name = self.os_name.decode(</span>
                    <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s1">da = self.read(nrows=self.chunksize </span><span class="s2">or </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">da </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s2">return </span><span class="s1">da</span>

    <span class="s5"># Read a single float of the given width (4 or 8).</span>
    <span class="s2">def </span><span class="s1">_read_float(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">width: int):</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s1">):</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;invalid float width&quot;</span><span class="s1">)</span>
        <span class="s1">buf = self._read_bytes(offset</span><span class="s2">, </span><span class="s1">width)</span>
        <span class="s1">fd = </span><span class="s3">&quot;f&quot; </span><span class="s2">if </span><span class="s1">width == </span><span class="s4">4 </span><span class="s2">else </span><span class="s3">&quot;d&quot;</span>
        <span class="s2">return </span><span class="s1">struct.unpack(self.byte_order + fd</span><span class="s2">, </span><span class="s1">buf)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s5"># Read a single signed integer of the given width (1, 2, 4 or 8).</span>
    <span class="s2">def </span><span class="s1">_read_int(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">width: int) -&gt; int:</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s1">):</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;invalid int width&quot;</span><span class="s1">)</span>
        <span class="s1">buf = self._read_bytes(offset</span><span class="s2">, </span><span class="s1">width)</span>
        <span class="s1">it = {</span><span class="s4">1</span><span class="s1">: </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">: </span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s4">4</span><span class="s1">: </span><span class="s3">&quot;l&quot;</span><span class="s2">, </span><span class="s4">8</span><span class="s1">: </span><span class="s3">&quot;q&quot;</span><span class="s1">}[width]</span>
        <span class="s1">iv = struct.unpack(self.byte_order + it</span><span class="s2">, </span><span class="s1">buf)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">iv</span>

    <span class="s2">def </span><span class="s1">_read_bytes(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int):</span>
        <span class="s2">if </span><span class="s1">self._cached_page </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._path_or_buf.seek(offset)</span>
            <span class="s1">buf = self._path_or_buf.read(length)</span>
            <span class="s2">if </span><span class="s1">len(buf) &lt; length:</span>
                <span class="s1">self.close()</span>
                <span class="s1">msg = </span><span class="s3">f&quot;Unable to read </span><span class="s2">{</span><span class="s1">length</span><span class="s2">:</span><span class="s3">d</span><span class="s2">} </span><span class="s3">bytes from file position </span><span class="s2">{</span><span class="s1">offset</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">.&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">return </span><span class="s1">buf</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">offset + length &gt; len(self._cached_page):</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The cached page is too small.&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._cached_page[offset : offset + length]</span>

    <span class="s2">def </span><span class="s1">_parse_metadata(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">done = </span><span class="s2">False</span>
        <span class="s2">while not </span><span class="s1">done:</span>
            <span class="s1">self._cached_page = self._path_or_buf.read(self._page_length)</span>
            <span class="s2">if </span><span class="s1">len(self._cached_page) &lt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">len(self._cached_page) != self._page_length:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Failed to read a meta data page from the SAS file.&quot;</span><span class="s1">)</span>
            <span class="s1">done = self._process_page_meta()</span>

    <span class="s2">def </span><span class="s1">_process_page_meta(self) -&gt; bool:</span>
        <span class="s1">self._read_page_header()</span>
        <span class="s1">pt = [const.page_meta_type</span><span class="s2">, </span><span class="s1">const.page_amd_type] + const.page_mix_types</span>
        <span class="s2">if </span><span class="s1">self._current_page_type </span><span class="s2">in </span><span class="s1">pt:</span>
            <span class="s1">self._process_page_metadata()</span>
        <span class="s1">is_data_page = self._current_page_type &amp; const.page_data_type</span>
        <span class="s1">is_mix_page = self._current_page_type </span><span class="s2">in </span><span class="s1">const.page_mix_types</span>
        <span class="s2">return </span><span class="s1">bool(</span>
            <span class="s1">is_data_page</span>
            <span class="s2">or </span><span class="s1">is_mix_page</span>
            <span class="s2">or </span><span class="s1">self._current_page_data_subheader_pointers != []</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_read_page_header(self):</span>
        <span class="s1">bit_offset = self._page_bit_offset</span>
        <span class="s1">tx = const.page_type_offset + bit_offset</span>
        <span class="s1">self._current_page_type = self._read_int(tx</span><span class="s2">, </span><span class="s1">const.page_type_length)</span>
        <span class="s1">tx = const.block_count_offset + bit_offset</span>
        <span class="s1">self._current_page_block_count = self._read_int(tx</span><span class="s2">, </span><span class="s1">const.block_count_length)</span>
        <span class="s1">tx = const.subheader_count_offset + bit_offset</span>
        <span class="s1">self._current_page_subheaders_count = self._read_int(</span>
            <span class="s1">tx</span><span class="s2">, </span><span class="s1">const.subheader_count_length</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_process_page_metadata(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">bit_offset = self._page_bit_offset</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._current_page_subheaders_count):</span>
            <span class="s1">pointer = self._process_subheader_pointers(</span>
                <span class="s1">const.subheader_pointers_offset + bit_offset</span><span class="s2">, </span><span class="s1">i</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">pointer.length == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">pointer.compression == const.truncated_subheader_id:</span>
                <span class="s2">continue</span>
            <span class="s1">subheader_signature = self._read_subheader_signature(pointer.offset)</span>
            <span class="s1">subheader_index = self._get_subheader_index(</span>
                <span class="s1">subheader_signature</span><span class="s2">, </span><span class="s1">pointer.compression</span><span class="s2">, </span><span class="s1">pointer.ptype</span>
            <span class="s1">)</span>
            <span class="s1">self._process_subheader(subheader_index</span><span class="s2">, </span><span class="s1">pointer)</span>

    <span class="s2">def </span><span class="s1">_get_subheader_index(self</span><span class="s2">, </span><span class="s1">signature: bytes</span><span class="s2">, </span><span class="s1">compression</span><span class="s2">, </span><span class="s1">ptype) -&gt; int:</span>
        <span class="s5"># TODO: return here could be made an enum</span>
        <span class="s1">index = const.subheader_signature_to_index.get(signature)</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">f1 = (compression == const.compressed_subheader_id) </span><span class="s2">or </span><span class="s1">(compression == </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">f2 = ptype == const.compressed_subheader_type</span>
            <span class="s2">if </span><span class="s1">(self.compression != </span><span class="s6">b&quot;&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">f1 </span><span class="s2">and </span><span class="s1">f2:</span>
                <span class="s1">index = const.SASIndex.data_subheader_index</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown subheader signature&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">index</span>

    <span class="s2">def </span><span class="s1">_process_subheader_pointers(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">subheader_pointer_index: int</span>
    <span class="s1">) -&gt; _SubheaderPointer:</span>

        <span class="s1">subheader_pointer_length = self._subheader_pointer_length</span>
        <span class="s1">total_offset = offset + subheader_pointer_length * subheader_pointer_index</span>

        <span class="s1">subheader_offset = self._read_int(total_offset</span><span class="s2">, </span><span class="s1">self._int_length)</span>
        <span class="s1">total_offset += self._int_length</span>

        <span class="s1">subheader_length = self._read_int(total_offset</span><span class="s2">, </span><span class="s1">self._int_length)</span>
        <span class="s1">total_offset += self._int_length</span>

        <span class="s1">subheader_compression = self._read_int(total_offset</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">total_offset += </span><span class="s4">1</span>

        <span class="s1">subheader_type = self._read_int(total_offset</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">x = _SubheaderPointer(</span>
            <span class="s1">subheader_offset</span><span class="s2">, </span><span class="s1">subheader_length</span><span class="s2">, </span><span class="s1">subheader_compression</span><span class="s2">, </span><span class="s1">subheader_type</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_read_subheader_signature(self</span><span class="s2">, </span><span class="s1">offset: int) -&gt; bytes:</span>
        <span class="s1">subheader_signature = self._read_bytes(offset</span><span class="s2">, </span><span class="s1">self._int_length)</span>
        <span class="s2">return </span><span class="s1">subheader_signature</span>

    <span class="s2">def </span><span class="s1">_process_subheader(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">subheader_index: int</span><span class="s2">, </span><span class="s1">pointer: _SubheaderPointer</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">offset = pointer.offset</span>
        <span class="s1">length = pointer.length</span>

        <span class="s2">if </span><span class="s1">subheader_index == const.SASIndex.row_size_index:</span>
            <span class="s1">processor = self._process_rowsize_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.column_size_index:</span>
            <span class="s1">processor = self._process_columnsize_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.column_text_index:</span>
            <span class="s1">processor = self._process_columntext_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.column_name_index:</span>
            <span class="s1">processor = self._process_columnname_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.column_attributes_index:</span>
            <span class="s1">processor = self._process_columnattributes_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.format_and_label_index:</span>
            <span class="s1">processor = self._process_format_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.column_list_index:</span>
            <span class="s1">processor = self._process_columnlist_subheader</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.subheader_counts_index:</span>
            <span class="s1">processor = self._process_subheader_counts</span>
        <span class="s2">elif </span><span class="s1">subheader_index == const.SASIndex.data_subheader_index:</span>
            <span class="s1">self._current_page_data_subheader_pointers.append(pointer)</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unknown subheader index&quot;</span><span class="s1">)</span>

        <span class="s1">processor(offset</span><span class="s2">, </span><span class="s1">length)</span>

    <span class="s2">def </span><span class="s1">_process_rowsize_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>

        <span class="s1">int_len = self._int_length</span>
        <span class="s1">lcs_offset = offset</span>
        <span class="s1">lcp_offset = offset</span>
        <span class="s2">if </span><span class="s1">self.U64:</span>
            <span class="s1">lcs_offset += </span><span class="s4">682</span>
            <span class="s1">lcp_offset += </span><span class="s4">706</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lcs_offset += </span><span class="s4">354</span>
            <span class="s1">lcp_offset += </span><span class="s4">378</span>

        <span class="s1">self.row_length = self._read_int(</span>
            <span class="s1">offset + const.row_length_offset_multiplier * int_len</span><span class="s2">, </span><span class="s1">int_len</span>
        <span class="s1">)</span>
        <span class="s1">self.row_count = self._read_int(</span>
            <span class="s1">offset + const.row_count_offset_multiplier * int_len</span><span class="s2">, </span><span class="s1">int_len</span>
        <span class="s1">)</span>
        <span class="s1">self.col_count_p1 = self._read_int(</span>
            <span class="s1">offset + const.col_count_p1_multiplier * int_len</span><span class="s2">, </span><span class="s1">int_len</span>
        <span class="s1">)</span>
        <span class="s1">self.col_count_p2 = self._read_int(</span>
            <span class="s1">offset + const.col_count_p2_multiplier * int_len</span><span class="s2">, </span><span class="s1">int_len</span>
        <span class="s1">)</span>
        <span class="s1">mx = const.row_count_on_mix_page_offset_multiplier * int_len</span>
        <span class="s1">self._mix_page_row_count = self._read_int(offset + mx</span><span class="s2">, </span><span class="s1">int_len)</span>
        <span class="s1">self._lcs = self._read_int(lcs_offset</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self._lcp = self._read_int(lcp_offset</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_process_columnsize_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">int_len = self._int_length</span>
        <span class="s1">offset += int_len</span>
        <span class="s1">self.column_count = self._read_int(offset</span><span class="s2">, </span><span class="s1">int_len)</span>
        <span class="s2">if </span><span class="s1">self.col_count_p1 + self.col_count_p2 != self.column_count:</span>
            <span class="s1">print(</span>
                <span class="s3">f&quot;Warning: column count mismatch (</span><span class="s2">{</span><span class="s1">self.col_count_p1</span><span class="s2">} </span><span class="s3">+ &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.col_count_p2</span><span class="s2">} </span><span class="s3">!= </span><span class="s2">{</span><span class="s1">self.column_count</span><span class="s2">}</span><span class="s3">)</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

    <span class="s5"># Unknown purpose</span>
    <span class="s2">def </span><span class="s1">_process_subheader_counts(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_process_columntext_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>

        <span class="s1">offset += self._int_length</span>
        <span class="s1">text_block_size = self._read_int(offset</span><span class="s2">, </span><span class="s1">const.text_block_size_length)</span>

        <span class="s1">buf = self._read_bytes(offset</span><span class="s2">, </span><span class="s1">text_block_size)</span>
        <span class="s1">cname_raw = buf[</span><span class="s4">0</span><span class="s1">:text_block_size].rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00 </span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s1">cname = cname_raw</span>
        <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
            <span class="s1">cname = cname.decode(self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding)</span>
        <span class="s1">self.column_names_strings.append(cname)</span>

        <span class="s2">if </span><span class="s1">len(self.column_names_strings) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">compression_literal = </span><span class="s6">b&quot;&quot;</span>
            <span class="s2">for </span><span class="s1">cl </span><span class="s2">in </span><span class="s1">const.compression_literals:</span>
                <span class="s2">if </span><span class="s1">cl </span><span class="s2">in </span><span class="s1">cname_raw:</span>
                    <span class="s1">compression_literal = cl</span>
            <span class="s1">self.compression = compression_literal</span>
            <span class="s1">offset -= self._int_length</span>

            <span class="s1">offset1 = offset + </span><span class="s4">16</span>
            <span class="s2">if </span><span class="s1">self.U64:</span>
                <span class="s1">offset1 += </span><span class="s4">4</span>

            <span class="s1">buf = self._read_bytes(offset1</span><span class="s2">, </span><span class="s1">self._lcp)</span>
            <span class="s1">compression_literal = buf.rstrip(</span><span class="s6">b&quot;</span><span class="s2">\x00</span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">compression_literal == </span><span class="s6">b&quot;&quot;</span><span class="s1">:</span>
                <span class="s1">self._lcs = </span><span class="s4">0</span>
                <span class="s1">offset1 = offset + </span><span class="s4">32</span>
                <span class="s2">if </span><span class="s1">self.U64:</span>
                    <span class="s1">offset1 += </span><span class="s4">4</span>
                <span class="s1">buf = self._read_bytes(offset1</span><span class="s2">, </span><span class="s1">self._lcp)</span>
                <span class="s1">self.creator_proc = buf[</span><span class="s4">0 </span><span class="s1">: self._lcp]</span>
            <span class="s2">elif </span><span class="s1">compression_literal == const.rle_compression:</span>
                <span class="s1">offset1 = offset + </span><span class="s4">40</span>
                <span class="s2">if </span><span class="s1">self.U64:</span>
                    <span class="s1">offset1 += </span><span class="s4">4</span>
                <span class="s1">buf = self._read_bytes(offset1</span><span class="s2">, </span><span class="s1">self._lcp)</span>
                <span class="s1">self.creator_proc = buf[</span><span class="s4">0 </span><span class="s1">: self._lcp]</span>
            <span class="s2">elif </span><span class="s1">self._lcs &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._lcp = </span><span class="s4">0</span>
                <span class="s1">offset1 = offset + </span><span class="s4">16</span>
                <span class="s2">if </span><span class="s1">self.U64:</span>
                    <span class="s1">offset1 += </span><span class="s4">4</span>
                <span class="s1">buf = self._read_bytes(offset1</span><span class="s2">, </span><span class="s1">self._lcs)</span>
                <span class="s1">self.creator_proc = buf[</span><span class="s4">0 </span><span class="s1">: self._lcp]</span>
            <span class="s2">if </span><span class="s1">self.convert_header_text:</span>
                <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;creator_proc&quot;</span><span class="s1">):</span>
                    <span class="s1">self.creator_proc = self.creator_proc.decode(</span>
                        <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
                    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_process_columnname_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">int_len = self._int_length</span>
        <span class="s1">offset += int_len</span>
        <span class="s1">column_name_pointers_count = (length - </span><span class="s4">2 </span><span class="s1">* int_len - </span><span class="s4">12</span><span class="s1">) // </span><span class="s4">8</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(column_name_pointers_count):</span>
            <span class="s1">text_subheader = (</span>
                <span class="s1">offset</span>
                <span class="s1">+ const.column_name_pointer_length * (i + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">+ const.column_name_text_subheader_offset</span>
            <span class="s1">)</span>
            <span class="s1">col_name_offset = (</span>
                <span class="s1">offset</span>
                <span class="s1">+ const.column_name_pointer_length * (i + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">+ const.column_name_offset_offset</span>
            <span class="s1">)</span>
            <span class="s1">col_name_length = (</span>
                <span class="s1">offset</span>
                <span class="s1">+ const.column_name_pointer_length * (i + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">+ const.column_name_length_offset</span>
            <span class="s1">)</span>

            <span class="s1">idx = self._read_int(</span>
                <span class="s1">text_subheader</span><span class="s2">, </span><span class="s1">const.column_name_text_subheader_length</span>
            <span class="s1">)</span>
            <span class="s1">col_offset = self._read_int(</span>
                <span class="s1">col_name_offset</span><span class="s2">, </span><span class="s1">const.column_name_offset_length</span>
            <span class="s1">)</span>
            <span class="s1">col_len = self._read_int(col_name_length</span><span class="s2">, </span><span class="s1">const.column_name_length_length)</span>

            <span class="s1">name_str = self.column_names_strings[idx]</span>
            <span class="s1">self.column_names.append(name_str[col_offset : col_offset + col_len])</span>

    <span class="s2">def </span><span class="s1">_process_columnattributes_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">int_len = self._int_length</span>
        <span class="s1">column_attributes_vectors_count = (length - </span><span class="s4">2 </span><span class="s1">* int_len - </span><span class="s4">12</span><span class="s1">) // (int_len + </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(column_attributes_vectors_count):</span>
            <span class="s1">col_data_offset = (</span>
                <span class="s1">offset + int_len + const.column_data_offset_offset + i * (int_len + </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">col_data_len = (</span>
                <span class="s1">offset</span>
                <span class="s1">+ </span><span class="s4">2 </span><span class="s1">* int_len</span>
                <span class="s1">+ const.column_data_length_offset</span>
                <span class="s1">+ i * (int_len + </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">col_types = (</span>
                <span class="s1">offset + </span><span class="s4">2 </span><span class="s1">* int_len + const.column_type_offset + i * (int_len + </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">x = self._read_int(col_data_offset</span><span class="s2">, </span><span class="s1">int_len)</span>
            <span class="s1">self._column_data_offsets.append(x)</span>

            <span class="s1">x = self._read_int(col_data_len</span><span class="s2">, </span><span class="s1">const.column_data_length_length)</span>
            <span class="s1">self._column_data_lengths.append(x)</span>

            <span class="s1">x = self._read_int(col_types</span><span class="s2">, </span><span class="s1">const.column_type_length)</span>
            <span class="s1">self._column_types.append(</span><span class="s6">b&quot;d&quot; </span><span class="s2">if </span><span class="s1">x == </span><span class="s4">1 </span><span class="s2">else </span><span class="s6">b&quot;s&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_process_columnlist_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># unknown purpose</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_process_format_subheader(self</span><span class="s2">, </span><span class="s1">offset: int</span><span class="s2">, </span><span class="s1">length: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">int_len = self._int_length</span>
        <span class="s1">text_subheader_format = (</span>
            <span class="s1">offset + const.column_format_text_subheader_index_offset + </span><span class="s4">3 </span><span class="s1">* int_len</span>
        <span class="s1">)</span>
        <span class="s1">col_format_offset = offset + const.column_format_offset_offset + </span><span class="s4">3 </span><span class="s1">* int_len</span>
        <span class="s1">col_format_len = offset + const.column_format_length_offset + </span><span class="s4">3 </span><span class="s1">* int_len</span>
        <span class="s1">text_subheader_label = (</span>
            <span class="s1">offset + const.column_label_text_subheader_index_offset + </span><span class="s4">3 </span><span class="s1">* int_len</span>
        <span class="s1">)</span>
        <span class="s1">col_label_offset = offset + const.column_label_offset_offset + </span><span class="s4">3 </span><span class="s1">* int_len</span>
        <span class="s1">col_label_len = offset + const.column_label_length_offset + </span><span class="s4">3 </span><span class="s1">* int_len</span>

        <span class="s1">x = self._read_int(</span>
            <span class="s1">text_subheader_format</span><span class="s2">, </span><span class="s1">const.column_format_text_subheader_index_length</span>
        <span class="s1">)</span>
        <span class="s1">format_idx = min(x</span><span class="s2">, </span><span class="s1">len(self.column_names_strings) - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">format_start = self._read_int(</span>
            <span class="s1">col_format_offset</span><span class="s2">, </span><span class="s1">const.column_format_offset_length</span>
        <span class="s1">)</span>
        <span class="s1">format_len = self._read_int(col_format_len</span><span class="s2">, </span><span class="s1">const.column_format_length_length)</span>

        <span class="s1">label_idx = self._read_int(</span>
            <span class="s1">text_subheader_label</span><span class="s2">, </span><span class="s1">const.column_label_text_subheader_index_length</span>
        <span class="s1">)</span>
        <span class="s1">label_idx = min(label_idx</span><span class="s2">, </span><span class="s1">len(self.column_names_strings) - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">label_start = self._read_int(col_label_offset</span><span class="s2">, </span><span class="s1">const.column_label_offset_length)</span>
        <span class="s1">label_len = self._read_int(col_label_len</span><span class="s2">, </span><span class="s1">const.column_label_length_length)</span>

        <span class="s1">label_names = self.column_names_strings[label_idx]</span>
        <span class="s1">column_label = label_names[label_start : label_start + label_len]</span>
        <span class="s1">format_names = self.column_names_strings[format_idx]</span>
        <span class="s1">column_format = format_names[format_start : format_start + format_len]</span>
        <span class="s1">current_column_number = len(self.columns)</span>

        <span class="s1">col = _Column(</span>
            <span class="s1">current_column_number</span><span class="s2">,</span>
            <span class="s1">self.column_names[current_column_number]</span><span class="s2">,</span>
            <span class="s1">column_label</span><span class="s2">,</span>
            <span class="s1">column_format</span><span class="s2">,</span>
            <span class="s1">self._column_types[current_column_number]</span><span class="s2">,</span>
            <span class="s1">self._column_data_lengths[current_column_number]</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">self.column_formats.append(column_format)</span>
        <span class="s1">self.columns.append(col)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">nrows: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; DataFrame | </span><span class="s2">None</span><span class="s1">:</span>

        <span class="s2">if </span><span class="s1">(nrows </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(self.chunksize </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">nrows = self.chunksize</span>
        <span class="s2">elif </span><span class="s1">nrows </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">nrows = self.row_count</span>

        <span class="s2">if </span><span class="s1">len(self._column_types) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise </span><span class="s1">EmptyDataError(</span><span class="s3">&quot;No columns to parse from file&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._current_row_in_file_index &gt;= self.row_count:</span>
            <span class="s2">return None</span>

        <span class="s1">m = self.row_count - self._current_row_in_file_index</span>
        <span class="s2">if </span><span class="s1">nrows &gt; m:</span>
            <span class="s1">nrows = m</span>

        <span class="s1">nd = self._column_types.count(</span><span class="s6">b&quot;d&quot;</span><span class="s1">)</span>
        <span class="s1">ns = self._column_types.count(</span><span class="s6">b&quot;s&quot;</span><span class="s1">)</span>

        <span class="s1">self._string_chunk = np.empty((ns</span><span class="s2">, </span><span class="s1">nrows)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">self._byte_chunk = np.zeros((nd</span><span class="s2">, </span><span class="s4">8 </span><span class="s1">* nrows)</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>

        <span class="s1">self._current_row_in_chunk_index = </span><span class="s4">0</span>
        <span class="s1">p = Parser(self)</span>
        <span class="s1">p.read(nrows)</span>

        <span class="s1">rslt = self._chunk_to_dataframe()</span>
        <span class="s2">if </span><span class="s1">self.index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">rslt = rslt.set_index(self.index)</span>

        <span class="s2">return </span><span class="s1">rslt</span>

    <span class="s2">def </span><span class="s1">_read_next_page(self):</span>
        <span class="s1">self._current_page_data_subheader_pointers = []</span>
        <span class="s1">self._cached_page = self._path_or_buf.read(self._page_length)</span>
        <span class="s2">if </span><span class="s1">len(self._cached_page) &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">len(self._cached_page) != self._page_length:</span>
            <span class="s1">self.close()</span>
            <span class="s1">msg = (</span>
                <span class="s3">&quot;failed to read complete page from file (read &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(self._cached_page)</span><span class="s2">:</span><span class="s3">d</span><span class="s2">} </span><span class="s3">of </span><span class="s2">{</span><span class="s1">self._page_length</span><span class="s2">:</span><span class="s3">d</span><span class="s2">} </span><span class="s3">bytes)&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">self._read_page_header()</span>
        <span class="s1">page_type = self._current_page_type</span>
        <span class="s2">if </span><span class="s1">page_type == const.page_meta_type:</span>
            <span class="s1">self._process_page_metadata()</span>

        <span class="s1">is_data_page = page_type &amp; const.page_data_type</span>
        <span class="s1">pt = [const.page_meta_type] + const.page_mix_types</span>
        <span class="s2">if not </span><span class="s1">is_data_page </span><span class="s2">and </span><span class="s1">self._current_page_type </span><span class="s2">not in </span><span class="s1">pt:</span>
            <span class="s2">return </span><span class="s1">self._read_next_page()</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_chunk_to_dataframe(self) -&gt; DataFrame:</span>

        <span class="s1">n = self._current_row_in_chunk_index</span>
        <span class="s1">m = self._current_row_in_file_index</span>
        <span class="s1">ix = range(m - n</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">rslt = {}</span>

        <span class="s1">js</span><span class="s2">, </span><span class="s1">jb = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.column_count):</span>

            <span class="s1">name = self.column_names[j]</span>

            <span class="s2">if </span><span class="s1">self._column_types[j] == </span><span class="s6">b&quot;d&quot;</span><span class="s1">:</span>
                <span class="s1">col_arr = self._byte_chunk[jb</span><span class="s2">, </span><span class="s1">:].view(dtype=self.byte_order + </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span>
                <span class="s1">rslt[name] = pd.Series(col_arr</span><span class="s2">, </span><span class="s1">dtype=np.float64</span><span class="s2">, </span><span class="s1">index=ix)</span>
                <span class="s2">if </span><span class="s1">self.convert_dates:</span>
                    <span class="s2">if </span><span class="s1">self.column_formats[j] </span><span class="s2">in </span><span class="s1">const.sas_date_formats:</span>
                        <span class="s1">rslt[name] = _convert_datetimes(rslt[name]</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span>
                    <span class="s2">elif </span><span class="s1">self.column_formats[j] </span><span class="s2">in </span><span class="s1">const.sas_datetime_formats:</span>
                        <span class="s1">rslt[name] = _convert_datetimes(rslt[name]</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
                <span class="s1">jb += </span><span class="s4">1</span>
            <span class="s2">elif </span><span class="s1">self._column_types[j] == </span><span class="s6">b&quot;s&quot;</span><span class="s1">:</span>
                <span class="s1">rslt[name] = pd.Series(self._string_chunk[js</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">index=ix)</span>
                <span class="s2">if </span><span class="s1">self.convert_text </span><span class="s2">and </span><span class="s1">(self.encoding </span><span class="s2">is not None</span><span class="s1">):</span>
                    <span class="s1">rslt[name] = rslt[name].str.decode(</span>
                        <span class="s1">self.encoding </span><span class="s2">or </span><span class="s1">self.default_encoding</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.blank_missing:</span>
                    <span class="s1">ii = rslt[name].str.len() == </span><span class="s4">0</span>
                    <span class="s1">rslt[name][ii] = np.nan</span>
                <span class="s1">js += </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;unknown column type </span><span class="s2">{</span><span class="s1">repr(self._column_types[j])</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s1">df = DataFrame(rslt</span><span class="s2">, </span><span class="s1">columns=self.column_names</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">df</span>
</pre>
</body>
</html>