<html>
<head>
<title>_ternary_contour.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ternary_contour.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>
<span class="s0">import </span><span class="s1">plotly.colors </span><span class="s0">as </span><span class="s1">clrs</span>
<span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">graph_objs </span><span class="s0">as </span><span class="s1">go</span>
<span class="s0">from </span><span class="s1">plotly </span><span class="s0">import </span><span class="s1">exceptions</span><span class="s0">, </span><span class="s1">optional_imports</span>
<span class="s0">from </span><span class="s1">plotly </span><span class="s0">import </span><span class="s1">optional_imports</span>
<span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">graph_objs </span><span class="s0">as </span><span class="s1">go</span>

<span class="s1">np = optional_imports.get_module(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>
<span class="s1">scipy_interp = optional_imports.get_module(</span><span class="s2">&quot;scipy.interpolate&quot;</span><span class="s1">)</span>

<span class="s0">from </span><span class="s1">skimage </span><span class="s0">import </span><span class="s1">measure</span>

<span class="s3"># -------------------------- Layout ------------------------------</span>


<span class="s0">def </span><span class="s1">_ternary_layout(</span>
    <span class="s1">title=</span><span class="s2">&quot;Ternary contour plot&quot;</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">550</span><span class="s0">, </span><span class="s1">height=</span><span class="s4">525</span><span class="s0">, </span><span class="s1">pole_labels=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Layout of ternary contour plot, to be passed to ``go.FigureWidget`` 
    object. 
 
    Parameters 
    ========== 
    title : str or None 
        Title of ternary plot 
    width : int 
        Figure width. 
    height : int 
        Figure height. 
    pole_labels : str, default ['a', 'b', 'c'] 
        Names of the three poles of the triangle. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">dict(</span>
        <span class="s1">title=title</span><span class="s0">,</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">height=height</span><span class="s0">,</span>
        <span class="s1">ternary=dict(</span>
            <span class="s1">sum=</span><span class="s4">1</span><span class="s0">,</span>
            <span class="s1">aaxis=dict(</span>
                <span class="s1">title=dict(text=pole_labels[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">min=</span><span class="s4">0.01</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">ticks=</span><span class="s2">&quot;outside&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">baxis=dict(</span>
                <span class="s1">title=dict(text=pole_labels[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">min=</span><span class="s4">0.01</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">ticks=</span><span class="s2">&quot;outside&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">caxis=dict(</span>
                <span class="s1">title=dict(text=pole_labels[</span><span class="s4">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">min=</span><span class="s4">0.01</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">ticks=</span><span class="s2">&quot;outside&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">showlegend=</span><span class="s0">False,</span>
    <span class="s1">)</span>


<span class="s3"># ------------- Transformations of coordinates -------------------</span>


<span class="s0">def </span><span class="s1">_replace_zero_coords(ternary_data</span><span class="s0">, </span><span class="s1">delta=</span><span class="s4">0.0005</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Replaces zero ternary coordinates with delta and normalize the new 
    triplets (a, b, c). 
 
    Parameters 
    ---------- 
 
    ternary_data : ndarray of shape (N, 3) 
 
    delta : float 
        Small float to regularize logarithm. 
 
    Notes 
    ----- 
    Implements a method 
    by J. A. Martin-Fernandez,  C. Barcelo-Vidal, V. Pawlowsky-Glahn, 
    Dealing with zeros and missing values in compositional data sets 
    using nonparametric imputation, Mathematical Geology 35 (2003), 
    pp 253-278. 
    &quot;&quot;&quot;</span>
    <span class="s1">zero_mask = ternary_data == </span><span class="s4">0</span>
    <span class="s1">is_any_coord_zero = np.any(zero_mask</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">unity_complement = </span><span class="s4">1 </span><span class="s1">- delta * is_any_coord_zero</span>
    <span class="s0">if </span><span class="s1">np.any(unity_complement) &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;The provided value of delta led to negative&quot;</span>
            <span class="s2">&quot;ternary coords.Set a smaller delta&quot;</span>
        <span class="s1">)</span>
    <span class="s1">ternary_data = np.where(zero_mask</span><span class="s0">, </span><span class="s1">delta</span><span class="s0">, </span><span class="s1">unity_complement * ternary_data)</span>
    <span class="s0">return </span><span class="s1">ternary_data</span>


<span class="s0">def </span><span class="s1">_ilr_transform(barycentric):</span>
    <span class="s5">&quot;&quot;&quot; 
    Perform Isometric Log-Ratio on barycentric (compositional) data. 
 
    Parameters 
    ---------- 
    barycentric: ndarray of shape (3, N) 
        Barycentric coordinates. 
 
    References 
    ---------- 
    &quot;An algebraic method to compute isometric logratio transformation and 
    back transformation of compositional data&quot;, Jarauta-Bragulat, E., 
    Buenestado, P.; Hervada-Sala, C., in Proc. of the Annual Conf. of the 
    Intl Assoc for Math Geology, 2003, pp 31-30. 
    &quot;&quot;&quot;</span>
    <span class="s1">barycentric = np.asarray(barycentric)</span>
    <span class="s1">x_0 = np.log(barycentric[</span><span class="s4">0</span><span class="s1">] / barycentric[</span><span class="s4">1</span><span class="s1">]) / np.sqrt(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">x_1 = (</span>
        <span class="s4">1.0 </span><span class="s1">/ np.sqrt(</span><span class="s4">6</span><span class="s1">) * np.log(barycentric[</span><span class="s4">0</span><span class="s1">] * barycentric[</span><span class="s4">1</span><span class="s1">] / barycentric[</span><span class="s4">2</span><span class="s1">] ** </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">ilr_tdata = np.stack((x_0</span><span class="s0">, </span><span class="s1">x_1))</span>
    <span class="s0">return </span><span class="s1">ilr_tdata</span>


<span class="s0">def </span><span class="s1">_ilr_inverse(x):</span>
    <span class="s5">&quot;&quot;&quot; 
    Perform inverse Isometric Log-Ratio (ILR) transform to retrieve 
    barycentric (compositional) data. 
 
    Parameters 
    ---------- 
    x : array of shape (2, N) 
        Coordinates in ILR space. 
 
    References 
    ---------- 
    &quot;An algebraic method to compute isometric logratio transformation and 
    back transformation of compositional data&quot;, Jarauta-Bragulat, E., 
    Buenestado, P.; Hervada-Sala, C., in Proc. of the Annual Conf. of the 
    Intl Assoc for Math Geology, 2003, pp 31-30. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x)</span>
    <span class="s1">matrix = np.array([[</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">]])</span>
    <span class="s1">s = np.sqrt(</span><span class="s4">2</span><span class="s1">) / </span><span class="s4">2</span>
    <span class="s1">t = np.sqrt(</span><span class="s4">3 </span><span class="s1">/ </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">Sk = np.einsum(</span><span class="s2">&quot;ik, kj -&gt; ij&quot;</span><span class="s0">, </span><span class="s1">np.array([[s</span><span class="s0">, </span><span class="s1">t]</span><span class="s0">, </span><span class="s1">[-s</span><span class="s0">, </span><span class="s1">t]])</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s1">Z = -np.log(</span><span class="s4">1 </span><span class="s1">+ np.exp(Sk).sum(axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">log_barycentric = np.einsum(</span>
        <span class="s2">&quot;ik, kj -&gt; ij&quot;</span><span class="s0">, </span><span class="s1">matrix</span><span class="s0">, </span><span class="s1">np.stack((</span><span class="s4">2 </span><span class="s1">* s * x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t * x[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Z))</span>
    <span class="s1">)</span>
    <span class="s1">iilr_tdata = np.exp(log_barycentric)</span>
    <span class="s0">return </span><span class="s1">iilr_tdata</span>


<span class="s0">def </span><span class="s1">_transform_barycentric_cartesian():</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns the transformation matrix from barycentric to Cartesian 
    coordinates and conversely. 
    &quot;&quot;&quot;</span>
    <span class="s3"># reference triangle</span>
    <span class="s1">tri_verts = np.array([[</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">np.sqrt(</span><span class="s4">3</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">M = np.array([tri_verts[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tri_verts[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s4">3</span><span class="s1">)])</span>
    <span class="s0">return </span><span class="s1">M</span><span class="s0">, </span><span class="s1">np.linalg.inv(M)</span>


<span class="s0">def </span><span class="s1">_prepare_barycentric_coord(b_coords):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check ternary coordinates and return the right barycentric coordinates. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(b_coords</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">np.ndarray)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;Data  should be either an array of shape (n,m),&quot;</span>
            <span class="s2">&quot;or a list of n m-lists, m=2 or 3&quot;</span>
        <span class="s1">)</span>
    <span class="s1">b_coords = np.asarray(b_coords)</span>
    <span class="s0">if </span><span class="s1">b_coords.shape[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;A point should have  2 (a, b) or 3 (a, b, c)&quot; &quot;barycentric coordinates&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">(len(b_coords) == </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">and not </span><span class="s1">np.allclose(b_coords.sum(axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">0.01</span><span class="s1">)</span>
        <span class="s0">and not </span><span class="s1">np.allclose(b_coords.sum(axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">0.01</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">msg = </span><span class="s2">&quot;The sum of coordinates should be 1 or 100 for all data points&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s0">if </span><span class="s1">len(b_coords) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B = b_coords</span>
        <span class="s1">C = </span><span class="s4">1 </span><span class="s1">- (A + B)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C = b_coords / b_coords.sum(axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">np.any(np.stack((A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C)) &lt; </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Barycentric coordinates should be positive.&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">np.stack((A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C))</span>


<span class="s0">def </span><span class="s1">_compute_grid(coordinates</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">interp_mode=</span><span class="s2">&quot;ilr&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Transform data points with Cartesian or ILR mapping, then Compute 
    interpolation on a regular grid. 
 
    Parameters 
    ========== 
 
    coordinates : array-like 
        Barycentric coordinates of data points. 
    values : 1-d array-like 
        Data points, field to be represented as contours. 
    interp_mode : 'ilr' (default) or 'cartesian' 
        Defines how data are interpolated to compute contours. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">interp_mode == </span><span class="s2">&quot;cartesian&quot;</span><span class="s1">:</span>
        <span class="s1">M</span><span class="s0">, </span><span class="s1">invM = _transform_barycentric_cartesian()</span>
        <span class="s1">coord_points = np.einsum(</span><span class="s2">&quot;ik, kj -&gt; ij&quot;</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">coordinates)</span>
    <span class="s0">elif </span><span class="s1">interp_mode == </span><span class="s2">&quot;ilr&quot;</span><span class="s1">:</span>
        <span class="s1">coordinates = _replace_zero_coords(coordinates)</span>
        <span class="s1">coord_points = _ilr_transform(coordinates)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;interp_mode should be cartesian or ilr&quot;</span><span class="s1">)</span>
    <span class="s1">xx</span><span class="s0">, </span><span class="s1">yy = coord_points[:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">x_min</span><span class="s0">, </span><span class="s1">x_max = xx.min()</span><span class="s0">, </span><span class="s1">xx.max()</span>
    <span class="s1">y_min</span><span class="s0">, </span><span class="s1">y_max = yy.min()</span><span class="s0">, </span><span class="s1">yy.max()</span>
    <span class="s1">n_interp = max(</span><span class="s4">200</span><span class="s0">, </span><span class="s1">int(np.sqrt(len(values))))</span>
    <span class="s1">gr_x = np.linspace(x_min</span><span class="s0">, </span><span class="s1">x_max</span><span class="s0">, </span><span class="s1">n_interp)</span>
    <span class="s1">gr_y = np.linspace(y_min</span><span class="s0">, </span><span class="s1">y_max</span><span class="s0">, </span><span class="s1">n_interp)</span>
    <span class="s1">grid_x</span><span class="s0">, </span><span class="s1">grid_y = np.meshgrid(gr_x</span><span class="s0">, </span><span class="s1">gr_y)</span>
    <span class="s3"># We use cubic interpolation, except outside of the convex hull</span>
    <span class="s3"># of data points where we use nearest neighbor values.</span>
    <span class="s1">grid_z = scipy_interp.griddata(</span>
        <span class="s1">coord_points[:</span><span class="s4">2</span><span class="s1">].T</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">(grid_x</span><span class="s0">, </span><span class="s1">grid_y)</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;cubic&quot;</span>
    <span class="s1">)</span>
    <span class="s1">grid_z_other = scipy_interp.griddata(</span>
        <span class="s1">coord_points[:</span><span class="s4">2</span><span class="s1">].T</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">(grid_x</span><span class="s0">, </span><span class="s1">grid_y)</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;nearest&quot;</span>
    <span class="s1">)</span>
    <span class="s3"># mask_nan = np.isnan(grid_z)</span>
    <span class="s3"># grid_z[mask_nan] = grid_z_other[mask_nan]</span>
    <span class="s0">return </span><span class="s1">grid_z</span><span class="s0">, </span><span class="s1">gr_x</span><span class="s0">, </span><span class="s1">gr_y</span>


<span class="s3"># ----------------------- Contour traces ----------------------</span>


<span class="s0">def </span><span class="s1">_polygon_area(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s0">return </span><span class="s4">0.5 </span><span class="s1">* np.abs(np.dot(x</span><span class="s0">, </span><span class="s1">np.roll(y</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)) - np.dot(y</span><span class="s0">, </span><span class="s1">np.roll(x</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)))</span>


<span class="s0">def </span><span class="s1">_colors(ncontours</span><span class="s0">, </span><span class="s1">colormap=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return a list of ``ncontours`` colors from the ``colormap`` colorscale. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">colormap </span><span class="s0">in </span><span class="s1">clrs.PLOTLY_SCALES.keys():</span>
        <span class="s1">cmap = clrs.PLOTLY_SCALES[colormap]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">exceptions.PlotlyError(</span>
            <span class="s2">&quot;Colorscale must be a valid Plotly Colorscale.&quot;</span>
            <span class="s2">&quot;The available colorscale names are {}&quot;</span><span class="s1">.format(clrs.PLOTLY_SCALES.keys())</span>
        <span class="s1">)</span>
    <span class="s1">values = np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">ncontours)</span>
    <span class="s1">vals_cmap = np.array([pair[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">cmap])</span>
    <span class="s1">cols = np.array([pair[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">cmap])</span>
    <span class="s1">inds = np.searchsorted(vals_cmap</span><span class="s0">, </span><span class="s1">values)</span>
    <span class="s0">if </span><span class="s2">&quot;#&quot; </span><span class="s0">in </span><span class="s1">cols[</span><span class="s4">0</span><span class="s1">]:  </span><span class="s3"># for Viridis</span>
        <span class="s1">cols = [clrs.label_rgb(clrs.hex_to_rgb(col)) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">cols]</span>

    <span class="s1">colors = [cols[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s0">for </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">zip(inds[</span><span class="s4">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">values[</span><span class="s4">1</span><span class="s1">:]):</span>
        <span class="s1">val1</span><span class="s0">, </span><span class="s1">val2 = vals_cmap[ind - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">vals_cmap[ind]</span>
        <span class="s1">interm = (val - val1) / (val2 - val1)</span>
        <span class="s1">col = clrs.find_intermediate_color(</span>
            <span class="s1">cols[ind - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cols[ind]</span><span class="s0">, </span><span class="s1">interm</span><span class="s0">, </span><span class="s1">colortype=</span><span class="s2">&quot;rgb&quot;</span>
        <span class="s1">)</span>
        <span class="s1">colors.append(col)</span>
    <span class="s0">return </span><span class="s1">colors</span>


<span class="s0">def </span><span class="s1">_is_invalid_contour(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s5">&quot;&quot;&quot; 
    Utility function for _contour_trace 
 
    Contours with an area of the order as 1 pixel are considered spurious. 
    &quot;&quot;&quot;</span>
    <span class="s1">too_small = np.all(np.abs(x - x[</span><span class="s4">0</span><span class="s1">]) &lt; </span><span class="s4">2</span><span class="s1">) </span><span class="s0">and </span><span class="s1">np.all(np.abs(y - y[</span><span class="s4">0</span><span class="s1">]) &lt; </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">too_small</span>


<span class="s0">def </span><span class="s1">_extract_contours(im</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">colors):</span>
    <span class="s5">&quot;&quot;&quot; 
    Utility function for _contour_trace. 
 
    In ``im`` only one part of the domain has valid values (corresponding 
    to a subdomain where barycentric coordinates are well defined). When 
    computing contours, we need to assign values outside of this domain. 
    We can choose a value either smaller than all the values inside the 
    valid domain, or larger. This value must be chose with caution so that 
    no spurious contours are added. For example, if the boundary of the valid 
    domain has large values and the outer value is set to a small one, all 
    intermediate contours will be added at the boundary. 
 
    Therefore, we compute the two sets of contours (with an outer value 
    smaller of larger than all values in the valid domain), and choose 
    the value resulting in a smaller total number of contours. There might 
    be a faster way to do this, but it works... 
    &quot;&quot;&quot;</span>
    <span class="s1">mask_nan = np.isnan(im)</span>
    <span class="s1">im_min</span><span class="s0">, </span><span class="s1">im_max = (</span>
        <span class="s1">im[np.logical_not(mask_nan)].min()</span><span class="s0">,</span>
        <span class="s1">im[np.logical_not(mask_nan)].max()</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">zz_min = np.copy(im)</span>
    <span class="s1">zz_min[mask_nan] = </span><span class="s4">2 </span><span class="s1">* im_min</span>
    <span class="s1">zz_max = np.copy(im)</span>
    <span class="s1">zz_max[mask_nan] = </span><span class="s4">2 </span><span class="s1">* im_max</span>
    <span class="s1">all_contours1</span><span class="s0">, </span><span class="s1">all_values1</span><span class="s0">, </span><span class="s1">all_areas1</span><span class="s0">, </span><span class="s1">all_colors1 = []</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span>
    <span class="s1">all_contours2</span><span class="s0">, </span><span class="s1">all_values2</span><span class="s0">, </span><span class="s1">all_areas2</span><span class="s0">, </span><span class="s1">all_colors2 = []</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">enumerate(values):</span>
        <span class="s1">contour_level1 = measure.find_contours(zz_min</span><span class="s0">, </span><span class="s1">val)</span>
        <span class="s1">contour_level2 = measure.find_contours(zz_max</span><span class="s0">, </span><span class="s1">val)</span>
        <span class="s1">all_contours1.extend(contour_level1)</span>
        <span class="s1">all_contours2.extend(contour_level2)</span>
        <span class="s1">all_values1.extend([val] * len(contour_level1))</span>
        <span class="s1">all_values2.extend([val] * len(contour_level2))</span>
        <span class="s1">all_areas1.extend(</span>
            <span class="s1">[_polygon_area(contour.T[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">contour.T[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">contour </span><span class="s0">in </span><span class="s1">contour_level1]</span>
        <span class="s1">)</span>
        <span class="s1">all_areas2.extend(</span>
            <span class="s1">[_polygon_area(contour.T[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">contour.T[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">contour </span><span class="s0">in </span><span class="s1">contour_level2]</span>
        <span class="s1">)</span>
        <span class="s1">all_colors1.extend([colors[i]] * len(contour_level1))</span>
        <span class="s1">all_colors2.extend([colors[i]] * len(contour_level2))</span>
    <span class="s0">if </span><span class="s1">len(all_contours1) &lt;= len(all_contours2):</span>
        <span class="s0">return </span><span class="s1">all_contours1</span><span class="s0">, </span><span class="s1">all_values1</span><span class="s0">, </span><span class="s1">all_areas1</span><span class="s0">, </span><span class="s1">all_colors1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">all_contours2</span><span class="s0">, </span><span class="s1">all_values2</span><span class="s0">, </span><span class="s1">all_areas2</span><span class="s0">, </span><span class="s1">all_colors2</span>


<span class="s0">def </span><span class="s1">_add_outer_contour(</span>
    <span class="s1">all_contours</span><span class="s0">,</span>
    <span class="s1">all_values</span><span class="s0">,</span>
    <span class="s1">all_areas</span><span class="s0">,</span>
    <span class="s1">all_colors</span><span class="s0">,</span>
    <span class="s1">values</span><span class="s0">,</span>
    <span class="s1">val_outer</span><span class="s0">,</span>
    <span class="s1">v_min</span><span class="s0">,</span>
    <span class="s1">v_max</span><span class="s0">,</span>
    <span class="s1">colors</span><span class="s0">,</span>
    <span class="s1">color_min</span><span class="s0">,</span>
    <span class="s1">color_max</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Utility function for _contour_trace 
 
    Adds the background color to fill gaps outside of computed contours. 
 
    To compute the background color, the color of the contour with largest 
    area (``val_outer``) is used. As background color, we choose the next 
    color value in the direction of the extrema of the colormap. 
 
    Then we add information for the outer contour for the different lists 
    provided as arguments. 
 
    A discrete colormap with all used colors is also returned (to be used 
    by colorscale trace). 
    &quot;&quot;&quot;</span>
    <span class="s3">#  The exact value of outer contour is not used when defining the trace</span>
    <span class="s1">outer_contour = </span><span class="s4">20 </span><span class="s1">* np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">]]).T</span>
    <span class="s1">all_contours = [outer_contour] + all_contours</span>
    <span class="s1">delta_values = np.diff(values)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">values = np.concatenate(</span>
        <span class="s1">([values[</span><span class="s4">0</span><span class="s1">] - delta_values]</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">[values[-</span><span class="s4">1</span><span class="s1">] + delta_values])</span>
    <span class="s1">)</span>
    <span class="s1">colors = np.concatenate(([color_min]</span><span class="s0">, </span><span class="s1">colors</span><span class="s0">, </span><span class="s1">[color_max]))</span>
    <span class="s1">index = np.nonzero(values == val_outer)[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">index &lt; len(values) / </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">index -= </span><span class="s4">1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index += </span><span class="s4">1</span>
    <span class="s1">all_colors = [colors[index]] + all_colors</span>
    <span class="s1">all_values = [values[index]] + all_values</span>
    <span class="s1">all_areas = [</span><span class="s4">0</span><span class="s1">] + all_areas</span>
    <span class="s1">used_colors = [color </span><span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">colors </span><span class="s0">if </span><span class="s1">color </span><span class="s0">in </span><span class="s1">all_colors]</span>
    <span class="s3"># Define discrete colorscale</span>
    <span class="s1">color_number = len(used_colors)</span>
    <span class="s1">scale = np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">color_number + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">discrete_cm = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">enumerate(used_colors):</span>
        <span class="s1">discrete_cm.append([scale[i]</span><span class="s0">, </span><span class="s1">used_colors[i]])</span>
        <span class="s1">discrete_cm.append([scale[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">used_colors[i]])</span>
    <span class="s1">discrete_cm.append([scale[color_number]</span><span class="s0">, </span><span class="s1">used_colors[color_number - </span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s0">return </span><span class="s1">all_contours</span><span class="s0">, </span><span class="s1">all_values</span><span class="s0">, </span><span class="s1">all_areas</span><span class="s0">, </span><span class="s1">all_colors</span><span class="s0">, </span><span class="s1">discrete_cm</span>


<span class="s0">def </span><span class="s1">_contour_trace(</span>
    <span class="s1">x</span><span class="s0">,</span>
    <span class="s1">y</span><span class="s0">,</span>
    <span class="s1">z</span><span class="s0">,</span>
    <span class="s1">ncontours=</span><span class="s0">None,</span>
    <span class="s1">colorscale=</span><span class="s2">&quot;Electric&quot;</span><span class="s0">,</span>
    <span class="s1">linecolor=</span><span class="s2">&quot;rgb(150,150,150)&quot;</span><span class="s0">,</span>
    <span class="s1">interp_mode=</span><span class="s2">&quot;llr&quot;</span><span class="s0">,</span>
    <span class="s1">coloring=</span><span class="s0">None,</span>
    <span class="s1">v_min=</span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">v_max=</span><span class="s4">1</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Contour trace in Cartesian coordinates. 
 
    Parameters 
    ========== 
 
    x, y : array-like 
        Cartesian coordinates 
    z : array-like 
        Field to be represented as contours. 
    ncontours : int or None 
        Number of contours to display (determined automatically if None). 
    colorscale : None or str (Plotly colormap) 
        colorscale of the contours. 
    linecolor : rgb color 
        Color used for lines. If ``colorscale`` is not None, line colors are 
        determined from ``colorscale`` instead. 
    interp_mode : 'ilr' (default) or 'cartesian' 
        Defines how data are interpolated to compute contours. If 'irl', 
        ILR (Isometric Log-Ratio) of compositional data is performed. If 
        'cartesian', contours are determined in Cartesian space. 
    coloring : None or 'lines' 
        How to display contour. Filled contours if None, lines if ``lines``. 
    vmin, vmax : float 
        Bounds of interval of values used for the colorspace 
 
    Notes 
    ===== 
    &quot;&quot;&quot;</span>
    <span class="s3"># Prepare colors</span>
    <span class="s3"># We do not take extrema, for example for one single contour</span>
    <span class="s3"># the color will be the middle point of the colormap</span>
    <span class="s1">colors = _colors(ncontours + </span><span class="s4">2</span><span class="s0">, </span><span class="s1">colorscale)</span>
    <span class="s3"># Values used for contours, extrema are not used</span>
    <span class="s3"># For example for a binary array [0, 1], the value of</span>
    <span class="s3"># the contour for ncontours=1 is 0.5.</span>
    <span class="s1">values = np.linspace(v_min</span><span class="s0">, </span><span class="s1">v_max</span><span class="s0">, </span><span class="s1">ncontours + </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">color_min</span><span class="s0">, </span><span class="s1">color_max = colors[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">colors[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">colors = colors[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">values = values[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Color of line contours</span>
    <span class="s0">if </span><span class="s1">linecolor </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">linecolor = </span><span class="s2">&quot;rgb(150, 150, 150)&quot;</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">colors = [linecolor] * ncontours</span>

        <span class="s3"># Retrieve all contours</span>
    <span class="s1">all_contours</span><span class="s0">, </span><span class="s1">all_values</span><span class="s0">, </span><span class="s1">all_areas</span><span class="s0">, </span><span class="s1">all_colors = _extract_contours(</span>
        <span class="s1">z</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">colors</span>
    <span class="s1">)</span>

    <span class="s3"># Now sort contours by decreasing area</span>
    <span class="s1">order = np.argsort(all_areas)[::-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Add outer contour</span>
    <span class="s1">all_contours</span><span class="s0">, </span><span class="s1">all_values</span><span class="s0">, </span><span class="s1">all_areas</span><span class="s0">, </span><span class="s1">all_colors</span><span class="s0">, </span><span class="s1">discrete_cm = _add_outer_contour(</span>
        <span class="s1">all_contours</span><span class="s0">,</span>
        <span class="s1">all_values</span><span class="s0">,</span>
        <span class="s1">all_areas</span><span class="s0">,</span>
        <span class="s1">all_colors</span><span class="s0">,</span>
        <span class="s1">values</span><span class="s0">,</span>
        <span class="s1">all_values[order[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">v_min</span><span class="s0">,</span>
        <span class="s1">v_max</span><span class="s0">,</span>
        <span class="s1">colors</span><span class="s0">,</span>
        <span class="s1">color_min</span><span class="s0">,</span>
        <span class="s1">color_max</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">order = np.concatenate(([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">order + </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s3"># Compute traces, in the order of decreasing area</span>
    <span class="s1">traces = []</span>
    <span class="s1">M</span><span class="s0">, </span><span class="s1">invM = _transform_barycentric_cartesian()</span>
    <span class="s1">dx = (x.max() - x.min()) / x.size</span>
    <span class="s1">dy = (y.max() - y.min()) / y.size</span>
    <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">order:</span>
        <span class="s1">y_contour</span><span class="s0">, </span><span class="s1">x_contour = all_contours[index].T</span>
        <span class="s1">val = all_values[index]</span>
        <span class="s0">if </span><span class="s1">interp_mode == </span><span class="s2">&quot;cartesian&quot;</span><span class="s1">:</span>
            <span class="s1">bar_coords = np.dot(</span>
                <span class="s1">invM</span><span class="s0">,</span>
                <span class="s1">np.stack((dx * x_contour</span><span class="s0">, </span><span class="s1">dy * y_contour</span><span class="s0">, </span><span class="s1">np.ones(x_contour.shape)))</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">interp_mode == </span><span class="s2">&quot;ilr&quot;</span><span class="s1">:</span>
            <span class="s1">bar_coords = _ilr_inverse(</span>
                <span class="s1">np.stack((dx * x_contour + x.min()</span><span class="s0">, </span><span class="s1">dy * y_contour + y.min()))</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">index == </span><span class="s4">0</span><span class="s1">:  </span><span class="s3"># outer triangle</span>
            <span class="s1">a = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">b = np.array([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">c = np.array([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = bar_coords</span>
        <span class="s0">if </span><span class="s1">_is_invalid_contour(x_contour</span><span class="s0">, </span><span class="s1">y_contour):</span>
            <span class="s0">continue</span>

        <span class="s1">_col = all_colors[index] </span><span class="s0">if </span><span class="s1">coloring == </span><span class="s2">&quot;lines&quot; </span><span class="s0">else </span><span class="s1">linecolor</span>
        <span class="s1">trace = dict(</span>
            <span class="s1">type=</span><span class="s2">&quot;scatterternary&quot;</span><span class="s0">,</span>
            <span class="s1">a=a</span><span class="s0">,</span>
            <span class="s1">b=b</span><span class="s0">,</span>
            <span class="s1">c=c</span><span class="s0">,</span>
            <span class="s1">mode=</span><span class="s2">&quot;lines&quot;</span><span class="s0">,</span>
            <span class="s1">line=dict(color=_col</span><span class="s0">, </span><span class="s1">shape=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">fill=</span><span class="s2">&quot;toself&quot;</span><span class="s0">,</span>
            <span class="s1">fillcolor=all_colors[index]</span><span class="s0">,</span>
            <span class="s1">showlegend=</span><span class="s0">True,</span>
            <span class="s1">hoverinfo=</span><span class="s2">&quot;skip&quot;</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s2">&quot;%.3f&quot; </span><span class="s1">% val</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">coloring == </span><span class="s2">&quot;lines&quot;</span><span class="s1">:</span>
            <span class="s1">trace[</span><span class="s2">&quot;fill&quot;</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s1">traces.append(trace)</span>

    <span class="s0">return </span><span class="s1">traces</span><span class="s0">, </span><span class="s1">discrete_cm</span>


<span class="s3"># -------------------- Figure Factory for ternary contour -------------</span>


<span class="s0">def </span><span class="s1">create_ternary_contour(</span>
    <span class="s1">coordinates</span><span class="s0">,</span>
    <span class="s1">values</span><span class="s0">,</span>
    <span class="s1">pole_labels=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">width=</span><span class="s4">500</span><span class="s0">,</span>
    <span class="s1">height=</span><span class="s4">500</span><span class="s0">,</span>
    <span class="s1">ncontours=</span><span class="s0">None,</span>
    <span class="s1">showscale=</span><span class="s0">False,</span>
    <span class="s1">coloring=</span><span class="s0">None,</span>
    <span class="s1">colorscale=</span><span class="s2">&quot;Bluered&quot;</span><span class="s0">,</span>
    <span class="s1">linecolor=</span><span class="s0">None,</span>
    <span class="s1">title=</span><span class="s0">None,</span>
    <span class="s1">interp_mode=</span><span class="s2">&quot;ilr&quot;</span><span class="s0">,</span>
    <span class="s1">showmarkers=</span><span class="s0">False,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Ternary contour plot. 
 
    Parameters 
    ---------- 
 
    coordinates : list or ndarray 
        Barycentric coordinates of shape (2, N) or (3, N) where N is the 
        number of data points. The sum of the 3 coordinates is expected 
        to be 1 for all data points. 
    values : array-like 
        Data points of field to be represented as contours. 
    pole_labels : str, default ['a', 'b', 'c'] 
        Names of the three poles of the triangle. 
    width : int 
        Figure width. 
    height : int 
        Figure height. 
    ncontours : int or None 
        Number of contours to display (determined automatically if None). 
    showscale : bool, default False 
        If True, a colorbar showing the color scale is displayed. 
    coloring : None or 'lines' 
        How to display contour. Filled contours if None, lines if ``lines``. 
    colorscale : None or str (Plotly colormap) 
        colorscale of the contours. 
    linecolor : None or rgb color 
        Color used for lines. ``colorscale`` has to be set to None, otherwise 
        line colors are determined from ``colorscale``. 
    title : str or None 
        Title of ternary plot 
    interp_mode : 'ilr' (default) or 'cartesian' 
        Defines how data are interpolated to compute contours. If 'irl', 
        ILR (Isometric Log-Ratio) of compositional data is performed. If 
        'cartesian', contours are determined in Cartesian space. 
    showmarkers : bool, default False 
        If True, markers corresponding to input compositional points are 
        superimposed on contours, using the same colorscale. 
 
    Examples 
    ======== 
 
    Example 1: ternary contour plot with filled contours 
 
    &gt;&gt;&gt; import plotly.figure_factory as ff 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; # Define coordinates 
    &gt;&gt;&gt; a, b = np.mgrid[0:1:20j, 0:1:20j] 
    &gt;&gt;&gt; mask = a + b &lt;= 1 
    &gt;&gt;&gt; a = a[mask].ravel() 
    &gt;&gt;&gt; b = b[mask].ravel() 
    &gt;&gt;&gt; c = 1 - a - b 
    &gt;&gt;&gt; # Values to be displayed as contours 
    &gt;&gt;&gt; z = a * b * c 
    &gt;&gt;&gt; fig = ff.create_ternary_contour(np.stack((a, b, c)), z) 
    &gt;&gt;&gt; fig.show() 
 
    It is also possible to give only two barycentric coordinates for each 
    point, since the sum of the three coordinates is one: 
 
    &gt;&gt;&gt; fig = ff.create_ternary_contour(np.stack((a, b)), z) 
 
 
    Example 2: ternary contour plot with line contours 
 
    &gt;&gt;&gt; fig = ff.create_ternary_contour(np.stack((a, b, c)), z, coloring='lines') 
 
    Example 3: customize number of contours 
 
    &gt;&gt;&gt; fig = ff.create_ternary_contour(np.stack((a, b, c)), z, ncontours=8) 
 
    Example 4: superimpose contour plot and original data as markers 
 
    &gt;&gt;&gt; fig = ff.create_ternary_contour(np.stack((a, b, c)), z, coloring='lines', 
    ...                                 showmarkers=True) 
 
    Example 5: customize title and pole labels 
 
    &gt;&gt;&gt; fig = ff.create_ternary_contour(np.stack((a, b, c)), z, 
    ...                                 title='Ternary plot', 
    ...                                 pole_labels=['clay', 'quartz', 'fledspar']) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">scipy_interp </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ImportError(</span>
            <span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">The create_ternary_contour figure factory requires the scipy package&quot;&quot;&quot;</span>
        <span class="s1">)</span>
    <span class="s1">sk_measure = optional_imports.get_module(</span><span class="s2">&quot;skimage&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">sk_measure </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ImportError(</span>
            <span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">The create_ternary_contour figure factory requires the scikit-image 
    package&quot;&quot;&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">colorscale </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">showscale = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">ncontours </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ncontours = </span><span class="s4">5</span>
    <span class="s1">coordinates = _prepare_barycentric_coord(coordinates)</span>
    <span class="s1">v_min</span><span class="s0">, </span><span class="s1">v_max = values.min()</span><span class="s0">, </span><span class="s1">values.max()</span>
    <span class="s1">grid_z</span><span class="s0">, </span><span class="s1">gr_x</span><span class="s0">, </span><span class="s1">gr_y = _compute_grid(coordinates</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">interp_mode=interp_mode)</span>

    <span class="s1">layout = _ternary_layout(</span>
        <span class="s1">pole_labels=pole_labels</span><span class="s0">, </span><span class="s1">width=width</span><span class="s0">, </span><span class="s1">height=height</span><span class="s0">, </span><span class="s1">title=title</span>
    <span class="s1">)</span>

    <span class="s1">contour_trace</span><span class="s0">, </span><span class="s1">discrete_cm = _contour_trace(</span>
        <span class="s1">gr_x</span><span class="s0">,</span>
        <span class="s1">gr_y</span><span class="s0">,</span>
        <span class="s1">grid_z</span><span class="s0">,</span>
        <span class="s1">ncontours=ncontours</span><span class="s0">,</span>
        <span class="s1">colorscale=colorscale</span><span class="s0">,</span>
        <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
        <span class="s1">interp_mode=interp_mode</span><span class="s0">,</span>
        <span class="s1">coloring=coloring</span><span class="s0">,</span>
        <span class="s1">v_min=v_min</span><span class="s0">,</span>
        <span class="s1">v_max=v_max</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">fig = go.Figure(data=contour_trace</span><span class="s0">, </span><span class="s1">layout=layout)</span>

    <span class="s1">opacity = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">showmarkers </span><span class="s0">else </span><span class="s4">0</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = coordinates</span>
    <span class="s1">hovertemplate = (</span>
        <span class="s1">pole_labels[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s2">&quot;: %{a:.3f}&lt;br&gt;&quot;</span>
        <span class="s1">+ pole_labels[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s2">&quot;: %{b:.3f}&lt;br&gt;&quot;</span>
        <span class="s1">+ pole_labels[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s2">&quot;: %{c:.3f}&lt;br&gt;&quot;</span>
        <span class="s2">&quot;z: %{marker.color:.3f}&lt;extra&gt;&lt;/extra&gt;&quot;</span>
    <span class="s1">)</span>

    <span class="s1">fig.add_scatterternary(</span>
        <span class="s1">a=a</span><span class="s0">,</span>
        <span class="s1">b=b</span><span class="s0">,</span>
        <span class="s1">c=c</span><span class="s0">,</span>
        <span class="s1">mode=</span><span class="s2">&quot;markers&quot;</span><span class="s0">,</span>
        <span class="s1">marker={</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: values</span><span class="s0">,</span>
            <span class="s2">&quot;colorscale&quot;</span><span class="s1">: colorscale</span><span class="s0">,</span>
            <span class="s2">&quot;line&quot;</span><span class="s1">: {</span><span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s2">&quot;rgb(120, 120, 120)&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: int(coloring != </span><span class="s2">&quot;lines&quot;</span><span class="s1">)}</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">opacity=opacity</span><span class="s0">,</span>
        <span class="s1">hovertemplate=hovertemplate</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">showscale:</span>
        <span class="s0">if not </span><span class="s1">showmarkers:</span>
            <span class="s1">colorscale = discrete_cm</span>
        <span class="s1">colorbar = dict(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;scatterternary&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s0">None</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s0">None</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s0">None</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;marker&quot;</span><span class="s1">: {</span>
                    <span class="s2">&quot;cmin&quot;</span><span class="s1">: values.min()</span><span class="s0">,</span>
                    <span class="s2">&quot;cmax&quot;</span><span class="s1">: values.max()</span><span class="s0">,</span>
                    <span class="s2">&quot;colorscale&quot;</span><span class="s1">: colorscale</span><span class="s0">,</span>
                    <span class="s2">&quot;showscale&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s1">}</span><span class="s0">,</span>
                <span class="s2">&quot;mode&quot;</span><span class="s1">: </span><span class="s2">&quot;markers&quot;</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">fig.add_trace(colorbar)</span>

    <span class="s0">return </span><span class="s1">fig</span>
</pre>
</body>
</html>