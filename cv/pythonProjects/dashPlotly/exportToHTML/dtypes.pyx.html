<html>
<head>
<title>dtypes.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dtypes.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># period frequency constants corresponding to scikits timeseries</span>
<span class="s0"># originals</span>
<span class="s0">from enum import Enum</span>


<span class="s0">cdef class PeriodDtypeBase:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Similar to an actual dtype, this contains all of the information</span>
    <span class="s0">describing a PeriodDtype in an integer code.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># cdef readonly:</span>
    <span class="s0">#    PeriodDtypeCode _dtype_code</span>

    <span class="s0">def __cinit__(self, PeriodDtypeCode code):</span>
        <span class="s0">self._dtype_code = code</span>

    <span class="s0">def __eq__(self, other):</span>
        <span class="s0">if not isinstance(other, PeriodDtypeBase):</span>
            <span class="s0">return False</span>
        <span class="s0">if not isinstance(self, PeriodDtypeBase):</span>
            <span class="s0"># cython semantics, this is a reversed op</span>
            <span class="s0">return False</span>
        <span class="s0">return self._dtype_code == other._dtype_code</span>

    <span class="s0">@property</span>
    <span class="s0">def freq_group_code(self) -&gt; int:</span>
        <span class="s0"># See also: libperiod.get_freq_group</span>
        <span class="s0">return (self._dtype_code // 1000) * 1000</span>

    <span class="s0">@property</span>
    <span class="s0">def resolution(self) -&gt; &quot;Resolution&quot;:</span>
        <span class="s0">fgc = self.freq_group_code</span>
        <span class="s0">return Resolution.from_freq_group(FreqGroup(fgc))</span>

    <span class="s0">@property</span>
    <span class="s0">def date_offset(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Corresponding DateOffset object.</span>

        <span class="s0">This mapping is mainly for backward-compatibility.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">from .offsets import to_offset</span>

        <span class="s0">freqstr = _reverse_period_code_map.get(self._dtype_code)</span>

        <span class="s0">return to_offset(freqstr)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def from_date_offset(cls, offset):</span>
        <span class="s0">code = offset._period_dtype_code</span>
        <span class="s0">return cls(code)</span>


<span class="s0">_period_code_map = {</span>
    <span class="s0"># Annual freqs with various fiscal year ends.</span>
    <span class="s0"># eg, 2005 for A-FEB runs Mar 1, 2004 to Feb 28, 2005</span>
    <span class="s0">&quot;A-DEC&quot;: 1000,  # Annual - December year end</span>
    <span class="s0">&quot;A-JAN&quot;: 1001,  # Annual - January year end</span>
    <span class="s0">&quot;A-FEB&quot;: 1002,  # Annual - February year end</span>
    <span class="s0">&quot;A-MAR&quot;: 1003,  # Annual - March year end</span>
    <span class="s0">&quot;A-APR&quot;: 1004,  # Annual - April year end</span>
    <span class="s0">&quot;A-MAY&quot;: 1005,  # Annual - May year end</span>
    <span class="s0">&quot;A-JUN&quot;: 1006,  # Annual - June year end</span>
    <span class="s0">&quot;A-JUL&quot;: 1007,  # Annual - July year end</span>
    <span class="s0">&quot;A-AUG&quot;: 1008,  # Annual - August year end</span>
    <span class="s0">&quot;A-SEP&quot;: 1009,  # Annual - September year end</span>
    <span class="s0">&quot;A-OCT&quot;: 1010,  # Annual - October year end</span>
    <span class="s0">&quot;A-NOV&quot;: 1011,  # Annual - November year end</span>

    <span class="s0"># Quarterly frequencies with various fiscal year ends.</span>
    <span class="s0"># eg, Q42005 for Q-OCT runs Aug 1, 2005 to Oct 31, 2005</span>
    <span class="s0">&quot;Q-DEC&quot;: 2000,    # Quarterly - December year end</span>
    <span class="s0">&quot;Q-JAN&quot;: 2001,    # Quarterly - January year end</span>
    <span class="s0">&quot;Q-FEB&quot;: 2002,    # Quarterly - February year end</span>
    <span class="s0">&quot;Q-MAR&quot;: 2003,    # Quarterly - March year end</span>
    <span class="s0">&quot;Q-APR&quot;: 2004,    # Quarterly - April year end</span>
    <span class="s0">&quot;Q-MAY&quot;: 2005,    # Quarterly - May year end</span>
    <span class="s0">&quot;Q-JUN&quot;: 2006,    # Quarterly - June year end</span>
    <span class="s0">&quot;Q-JUL&quot;: 2007,    # Quarterly - July year end</span>
    <span class="s0">&quot;Q-AUG&quot;: 2008,    # Quarterly - August year end</span>
    <span class="s0">&quot;Q-SEP&quot;: 2009,    # Quarterly - September year end</span>
    <span class="s0">&quot;Q-OCT&quot;: 2010,    # Quarterly - October year end</span>
    <span class="s0">&quot;Q-NOV&quot;: 2011,    # Quarterly - November year end</span>

    <span class="s0">&quot;M&quot;: 3000,        # Monthly</span>

    <span class="s0">&quot;W-SUN&quot;: 4000,    # Weekly - Sunday end of week</span>
    <span class="s0">&quot;W-MON&quot;: 4001,    # Weekly - Monday end of week</span>
    <span class="s0">&quot;W-TUE&quot;: 4002,    # Weekly - Tuesday end of week</span>
    <span class="s0">&quot;W-WED&quot;: 4003,    # Weekly - Wednesday end of week</span>
    <span class="s0">&quot;W-THU&quot;: 4004,    # Weekly - Thursday end of week</span>
    <span class="s0">&quot;W-FRI&quot;: 4005,    # Weekly - Friday end of week</span>
    <span class="s0">&quot;W-SAT&quot;: 4006,    # Weekly - Saturday end of week</span>

    <span class="s0">&quot;B&quot;: 5000,        # Business days</span>
    <span class="s0">&quot;D&quot;: 6000,        # Daily</span>
    <span class="s0">&quot;H&quot;: 7000,        # Hourly</span>
    <span class="s0">&quot;T&quot;: 8000,        # Minutely</span>
    <span class="s0">&quot;S&quot;: 9000,        # Secondly</span>
    <span class="s0">&quot;L&quot;: 10000,       # Millisecondly</span>
    <span class="s0">&quot;U&quot;: 11000,       # Microsecondly</span>
    <span class="s0">&quot;N&quot;: 12000,       # Nanosecondly</span>
<span class="s0">}</span>

<span class="s0">_reverse_period_code_map = {</span>
    <span class="s0">_period_code_map[key]: key for key in _period_code_map}</span>

<span class="s0"># Yearly aliases; careful not to put these in _reverse_period_code_map</span>
<span class="s0">_period_code_map.update({&quot;Y&quot; + key[1:]: _period_code_map[key]</span>
                         <span class="s0">for key in _period_code_map</span>
                         <span class="s0">if key.startswith(&quot;A-&quot;)})</span>

<span class="s0">_period_code_map.update({</span>
    <span class="s0">&quot;Q&quot;: 2000,   # Quarterly - December year end (default quarterly)</span>
    <span class="s0">&quot;A&quot;: 1000,   # Annual</span>
    <span class="s0">&quot;W&quot;: 4000,   # Weekly</span>
    <span class="s0">&quot;C&quot;: 5000,   # Custom Business Day</span>
<span class="s0">})</span>

<span class="s0">cdef set _month_names = {</span>
    <span class="s0">x.split(&quot;-&quot;)[-1] for x in _period_code_map.keys() if x.startswith(&quot;A-&quot;)</span>
<span class="s0">}</span>

<span class="s0"># Map attribute-name resolutions to resolution abbreviations</span>
<span class="s0">_attrname_to_abbrevs = {</span>
    <span class="s0">&quot;year&quot;: &quot;A&quot;,</span>
    <span class="s0">&quot;quarter&quot;: &quot;Q&quot;,</span>
    <span class="s0">&quot;month&quot;: &quot;M&quot;,</span>
    <span class="s0">&quot;day&quot;: &quot;D&quot;,</span>
    <span class="s0">&quot;hour&quot;: &quot;H&quot;,</span>
    <span class="s0">&quot;minute&quot;: &quot;T&quot;,</span>
    <span class="s0">&quot;second&quot;: &quot;S&quot;,</span>
    <span class="s0">&quot;millisecond&quot;: &quot;L&quot;,</span>
    <span class="s0">&quot;microsecond&quot;: &quot;U&quot;,</span>
    <span class="s0">&quot;nanosecond&quot;: &quot;N&quot;,</span>
<span class="s0">}</span>
<span class="s0">cdef dict attrname_to_abbrevs = _attrname_to_abbrevs</span>
<span class="s0">cdef dict _abbrev_to_attrnames = {v: k for k, v in attrname_to_abbrevs.items()}</span>


<span class="s0">class FreqGroup(Enum):</span>
    <span class="s0"># Mirrors c_FreqGroup in the .pxd file</span>
    <span class="s0">FR_ANN = 1000</span>
    <span class="s0">FR_QTR = 2000</span>
    <span class="s0">FR_MTH = 3000</span>
    <span class="s0">FR_WK = 4000</span>
    <span class="s0">FR_BUS = 5000</span>
    <span class="s0">FR_DAY = 6000</span>
    <span class="s0">FR_HR = 7000</span>
    <span class="s0">FR_MIN = 8000</span>
    <span class="s0">FR_SEC = 9000</span>
    <span class="s0">FR_MS = 10000</span>
    <span class="s0">FR_US = 11000</span>
    <span class="s0">FR_NS = 12000</span>
    <span class="s0">FR_UND = -10000  # undefined</span>

    <span class="s0">@staticmethod</span>
    <span class="s0">def get_freq_group(code: int) -&gt; &quot;FreqGroup&quot;:</span>
        <span class="s0"># See also: PeriodDtypeBase.freq_group_code</span>
        <span class="s0">code = (code // 1000) * 1000</span>
        <span class="s0">return FreqGroup(code)</span>


<span class="s0">class Resolution(Enum):</span>

    <span class="s0"># Note: cython won't allow us to reference the cdef versions at the</span>
    <span class="s0"># module level</span>
    <span class="s0">RESO_NS = 0</span>
    <span class="s0">RESO_US = 1</span>
    <span class="s0">RESO_MS = 2</span>
    <span class="s0">RESO_SEC = 3</span>
    <span class="s0">RESO_MIN = 4</span>
    <span class="s0">RESO_HR = 5</span>
    <span class="s0">RESO_DAY = 6</span>
    <span class="s0">RESO_MTH = 7</span>
    <span class="s0">RESO_QTR = 8</span>
    <span class="s0">RESO_YR = 9</span>

    <span class="s0">def __lt__(self, other):</span>
        <span class="s0">return self.value &lt; other.value</span>

    <span class="s0">def __ge__(self, other):</span>
        <span class="s0">return self.value &gt;= other.value</span>

    <span class="s0">@property</span>
    <span class="s0">def freq_group(self) -&gt; FreqGroup:</span>
        <span class="s0">if self == Resolution.RESO_NS:</span>
            <span class="s0">return FreqGroup.FR_NS</span>
        <span class="s0">elif self == Resolution.RESO_US:</span>
            <span class="s0">return FreqGroup.FR_US</span>
        <span class="s0">elif self == Resolution.RESO_MS:</span>
            <span class="s0">return FreqGroup.FR_MS</span>
        <span class="s0">elif self == Resolution.RESO_SEC:</span>
            <span class="s0">return FreqGroup.FR_SEC</span>
        <span class="s0">elif self == Resolution.RESO_MIN:</span>
            <span class="s0">return FreqGroup.FR_MIN</span>
        <span class="s0">elif self == Resolution.RESO_HR:</span>
            <span class="s0">return FreqGroup.FR_HR</span>
        <span class="s0">elif self == Resolution.RESO_DAY:</span>
            <span class="s0">return FreqGroup.FR_DAY</span>
        <span class="s0">elif self == Resolution.RESO_MTH:</span>
            <span class="s0">return FreqGroup.FR_MTH</span>
        <span class="s0">elif self == Resolution.RESO_QTR:</span>
            <span class="s0">return FreqGroup.FR_QTR</span>
        <span class="s0">elif self == Resolution.RESO_YR:</span>
            <span class="s0">return FreqGroup.FR_ANN</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(self)  # pragma: no cover</span>

    <span class="s0">@property</span>
    <span class="s0">def attrname(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return datetime attribute name corresponding to this Resolution.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; Resolution.RESO_SEC.attrname</span>
        <span class="s0">'second'</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return _reso_str_map[self.value]</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def from_attrname(cls, attrname: str) -&gt; &quot;Resolution&quot;:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return resolution str against resolution code.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; Resolution.from_attrname('second')</span>
        <span class="s0">&lt;Resolution.RESO_SEC: 3&gt;</span>

        <span class="s0">&gt;&gt;&gt; Resolution.from_attrname('second') == Resolution.RESO_SEC</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return cls(_str_reso_map[attrname])</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def get_reso_from_freq(cls, freq: str) -&gt; &quot;Resolution&quot;:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return resolution code against frequency str.</span>

        <span class="s0">`freq` is given by the `offset.freqstr` for some DateOffset object.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; Resolution.get_reso_from_freq('H')</span>
        <span class="s0">&lt;Resolution.RESO_HR: 5&gt;</span>

        <span class="s0">&gt;&gt;&gt; Resolution.get_reso_from_freq('H') == Resolution.RESO_HR</span>
        <span class="s0">True</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">try:</span>
            <span class="s0">attr_name = _abbrev_to_attrnames[freq]</span>
        <span class="s0">except KeyError:</span>
            <span class="s0"># For quarterly and yearly resolutions, we need to chop off</span>
            <span class="s0">#  a month string.</span>
            <span class="s0">split_freq = freq.split(&quot;-&quot;)</span>
            <span class="s0">if len(split_freq) != 2:</span>
                <span class="s0">raise</span>
            <span class="s0">if split_freq[1] not in _month_names:</span>
                <span class="s0"># i.e. we want e.g. &quot;Q-DEC&quot;, not &quot;Q-INVALID&quot;</span>
                <span class="s0">raise</span>
            <span class="s0">attr_name = _abbrev_to_attrnames[split_freq[0]]</span>

        <span class="s0">return cls.from_attrname(attr_name)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def from_freq_group(cls, freq_group: FreqGroup) -&gt; &quot;Resolution&quot;:</span>
        <span class="s0">abbrev = _reverse_period_code_map[freq_group.value].split(&quot;-&quot;)[0]</span>
        <span class="s0">if abbrev == &quot;B&quot;:</span>
            <span class="s0">return cls.RESO_DAY</span>
        <span class="s0">attrname = _abbrev_to_attrnames[abbrev]</span>
        <span class="s0">return cls.from_attrname(attrname)</span>


<span class="s0">cdef dict _reso_str_map = {</span>
    <span class="s0">Resolution.RESO_NS.value: &quot;nanosecond&quot;,</span>
    <span class="s0">Resolution.RESO_US.value: &quot;microsecond&quot;,</span>
    <span class="s0">Resolution.RESO_MS.value: &quot;millisecond&quot;,</span>
    <span class="s0">Resolution.RESO_SEC.value: &quot;second&quot;,</span>
    <span class="s0">Resolution.RESO_MIN.value: &quot;minute&quot;,</span>
    <span class="s0">Resolution.RESO_HR.value: &quot;hour&quot;,</span>
    <span class="s0">Resolution.RESO_DAY.value: &quot;day&quot;,</span>
    <span class="s0">Resolution.RESO_MTH.value: &quot;month&quot;,</span>
    <span class="s0">Resolution.RESO_QTR.value: &quot;quarter&quot;,</span>
    <span class="s0">Resolution.RESO_YR.value: &quot;year&quot;,</span>
<span class="s0">}</span>

<span class="s0">cdef dict _str_reso_map = {v: k for k, v in _reso_str_map.items()}</span>
</pre>
</body>
</html>