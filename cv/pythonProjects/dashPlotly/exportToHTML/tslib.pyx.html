<html>
<head>
<title>tslib.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tslib.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import warnings</span>

<span class="s0">import cython</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDate_Check,</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">datetime,</span>
    <span class="s0">tzinfo,</span>
<span class="s0">)</span>

<span class="s0"># import datetime C API</span>
<span class="s0">PyDateTime_IMPORT</span>


<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0">import numpy as np</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">import pytz</span>

<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">_string_to_dts,</span>
    <span class="s0">check_dts_bounds,</span>
    <span class="s0">dt64_to_dtstruct,</span>
    <span class="s0">dtstruct_to_dt64,</span>
    <span class="s0">get_datetime64_value,</span>
    <span class="s0">npy_datetimestruct,</span>
    <span class="s0">pydate_to_dt64,</span>
    <span class="s0">pydatetime_to_dt64,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.util cimport (</span>
    <span class="s0">is_datetime64_object,</span>
    <span class="s0">is_float_object,</span>
    <span class="s0">is_integer_object,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime</span>
<span class="s0">from pandas._libs.tslibs.parsing import parse_datetime_string</span>

<span class="s0">from pandas._libs.tslibs.conversion cimport (</span>
    <span class="s0">_TSObject,</span>
    <span class="s0">cast_from_unit,</span>
    <span class="s0">convert_datetime_to_tsobject,</span>
    <span class="s0">get_datetime64_nanos,</span>
    <span class="s0">precision_from_unit,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">c_NaT as NaT,</span>
    <span class="s0">c_nat_strings as nat_strings,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.timestamps cimport _Timestamp</span>

<span class="s0">from pandas._libs.tslibs.timestamps import Timestamp</span>

<span class="s0"># Note: this is the only non-tslibs intra-pandas dependency here</span>

<span class="s0">from pandas._libs.missing cimport checknull_with_nat_and_na</span>
<span class="s0">from pandas._libs.tslibs.tzconversion cimport tz_localize_to_utc_single</span>


<span class="s0">def _test_parse_iso8601(ts: str):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">TESTING ONLY: Parse string into Timestamp using iso8601 parser. Used</span>
    <span class="s0">only for testing, actual construction uses `convert_str_to_tsobject`</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">_TSObject obj</span>
        <span class="s0">int out_local = 0, out_tzoffset = 0</span>

    <span class="s0">obj = _TSObject()</span>

    <span class="s0">if ts == 'now':</span>
        <span class="s0">return Timestamp.utcnow()</span>
    <span class="s0">elif ts == 'today':</span>
        <span class="s0">return Timestamp.now().normalize()</span>

    <span class="s0">_string_to_dts(ts, &amp;obj.dts, &amp;out_local, &amp;out_tzoffset, True)</span>
    <span class="s0">obj.value = dtstruct_to_dt64(&amp;obj.dts)</span>
    <span class="s0">check_dts_bounds(&amp;obj.dts)</span>
    <span class="s0">if out_local == 1:</span>
        <span class="s0">obj.tzinfo = pytz.FixedOffset(out_tzoffset)</span>
        <span class="s0">obj.value = tz_localize_to_utc_single(obj.value, obj.tzinfo)</span>
        <span class="s0">return Timestamp(obj.value, tz=obj.tzinfo)</span>
    <span class="s0">else:</span>
        <span class="s0">return Timestamp(obj.value)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def format_array_from_datetime(</span>
    <span class="s0">ndarray[int64_t] values,</span>
    <span class="s0">tzinfo tz=None,</span>
    <span class="s0">str format=None,</span>
    <span class="s0">object na_rep=None</span>
<span class="s0">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return a np object array of the string formatted values</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : a 1-d i8 array</span>
    <span class="s0">tz : tzinfo or None, default None</span>
    <span class="s0">format : str or None, default None</span>
          <span class="s0">a strftime capable string</span>
    <span class="s0">na_rep : optional, default is None</span>
          <span class="s0">a nat format</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[object]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t val, ns, N = len(values)</span>
        <span class="s0">ndarray[int64_t] consider_values</span>
        <span class="s0">bint show_ms = False, show_us = False, show_ns = False</span>
        <span class="s0">bint basic_format = False</span>
        <span class="s0">ndarray[object] result = np.empty(N, dtype=object)</span>
        <span class="s0">object ts, res</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">if na_rep is None:</span>
        <span class="s0">na_rep = 'NaT'</span>

    <span class="s0"># if we don't have a format nor tz, then choose</span>
    <span class="s0"># a format based on precision</span>
    <span class="s0">basic_format = format is None and tz is None</span>
    <span class="s0">if basic_format:</span>
        <span class="s0">consider_values = values[values != NPY_NAT]</span>
        <span class="s0">show_ns = (consider_values % 1000).any()</span>

        <span class="s0">if not show_ns:</span>
            <span class="s0">consider_values //= 1000</span>
            <span class="s0">show_us = (consider_values % 1000).any()</span>

            <span class="s0">if not show_ms:</span>
                <span class="s0">consider_values //= 1000</span>
                <span class="s0">show_ms = (consider_values % 1000).any()</span>

    <span class="s0">for i in range(N):</span>
        <span class="s0">val = values[i]</span>

        <span class="s0">if val == NPY_NAT:</span>
            <span class="s0">result[i] = na_rep</span>
        <span class="s0">elif basic_format:</span>

            <span class="s0">dt64_to_dtstruct(val, &amp;dts)</span>
            <span class="s0">res = (f'{dts.year}-{dts.month:02d}-{dts.day:02d} '</span>
                   <span class="s0">f'{dts.hour:02d}:{dts.min:02d}:{dts.sec:02d}')</span>

            <span class="s0">if show_ns:</span>
                <span class="s0">ns = dts.ps // 1000</span>
                <span class="s0">res += f'.{ns + dts.us * 1000:09d}'</span>
            <span class="s0">elif show_us:</span>
                <span class="s0">res += f'.{dts.us:06d}'</span>
            <span class="s0">elif show_ms:</span>
                <span class="s0">res += f'.{dts.us // 1000:03d}'</span>

            <span class="s0">result[i] = res</span>

        <span class="s0">else:</span>

            <span class="s0">ts = Timestamp(val, tz=tz)</span>
            <span class="s0">if format is None:</span>
                <span class="s0">result[i] = str(ts)</span>
            <span class="s0">else:</span>

                <span class="s0"># invalid format string</span>
                <span class="s0"># requires dates &gt; 1900</span>
                <span class="s0">try:</span>
                    <span class="s0">result[i] = ts.strftime(format)</span>
                <span class="s0">except ValueError:</span>
                    <span class="s0">result[i] = str(ts)</span>

    <span class="s0">return result</span>


<span class="s0">def array_with_unit_to_datetime(</span>
    <span class="s0">ndarray values,</span>
    <span class="s0">str unit,</span>
    <span class="s0">str errors=&quot;coerce&quot;</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert the ndarray to datetime according to the time unit.</span>

    <span class="s0">This function converts an array of objects into a numpy array of</span>
    <span class="s0">datetime64[ns]. It returns the converted array</span>
    <span class="s0">and also returns the timezone offset</span>

    <span class="s0">if errors:</span>
      <span class="s0">- raise: return converted values or raise OutOfBoundsDatetime</span>
          <span class="s0">if out of range on the conversion or</span>
          <span class="s0">ValueError for other conversions (e.g. a string)</span>
      <span class="s0">- ignore: return non-convertible values as the same unit</span>
      <span class="s0">- coerce: NaT for non-convertibles</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : ndarray</span>
         <span class="s0">Date-like objects to convert.</span>
    <span class="s0">unit : str</span>
         <span class="s0">Time unit to use during conversion.</span>
    <span class="s0">errors : str, default 'raise'</span>
         <span class="s0">Error behavior when parsing.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">result : ndarray of m8 values</span>
    <span class="s0">tz : parsed timezone offset or None</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, n=len(values)</span>
        <span class="s0">int64_t m</span>
        <span class="s0">int prec = 0</span>
        <span class="s0">ndarray[float64_t] fvalues</span>
        <span class="s0">bint is_ignore = errors=='ignore'</span>
        <span class="s0">bint is_coerce = errors=='coerce'</span>
        <span class="s0">bint is_raise = errors=='raise'</span>
        <span class="s0">bint need_to_iterate = True</span>
        <span class="s0">ndarray[int64_t] iresult</span>
        <span class="s0">ndarray[object] oresult</span>
        <span class="s0">ndarray mask</span>
        <span class="s0">object tz = None</span>

    <span class="s0">assert is_ignore or is_coerce or is_raise</span>

    <span class="s0">if unit == &quot;ns&quot;:</span>
        <span class="s0">if issubclass(values.dtype.type, (np.integer, np.float_)):</span>
            <span class="s0">result = values.astype(&quot;M8[ns]&quot;, copy=False)</span>
        <span class="s0">else:</span>
            <span class="s0">result, tz = array_to_datetime(</span>
                <span class="s0">values.astype(object, copy=False),</span>
                <span class="s0">errors=errors,</span>
            <span class="s0">)</span>
        <span class="s0">return result, tz</span>

    <span class="s0">m, p = precision_from_unit(unit)</span>

    <span class="s0">if is_raise:</span>
        <span class="s0"># try a quick conversion to i8/f8</span>
        <span class="s0"># if we have nulls that are not type-compat</span>
        <span class="s0"># then need to iterate</span>

        <span class="s0">if values.dtype.kind in [&quot;i&quot;, &quot;f&quot;, &quot;u&quot;]:</span>
            <span class="s0">iresult = values.astype(&quot;i8&quot;, copy=False)</span>
            <span class="s0"># fill missing values by comparing to NPY_NAT</span>
            <span class="s0">mask = iresult == NPY_NAT</span>
            <span class="s0">iresult[mask] = 0</span>
            <span class="s0">fvalues = iresult.astype(&quot;f8&quot;) * m</span>
            <span class="s0">need_to_iterate = False</span>

        <span class="s0">if not need_to_iterate:</span>
            <span class="s0"># check the bounds</span>
            <span class="s0">if (fvalues &lt; Timestamp.min.value).any() or (</span>
                <span class="s0">(fvalues &gt; Timestamp.max.value).any()</span>
            <span class="s0">):</span>
                <span class="s0">raise OutOfBoundsDatetime(f&quot;cannot convert input with unit '{unit}'&quot;)</span>

            <span class="s0">if values.dtype.kind in [&quot;i&quot;, &quot;u&quot;]:</span>
                <span class="s0">result = (iresult * m).astype(&quot;M8[ns]&quot;)</span>

            <span class="s0">elif values.dtype.kind == &quot;f&quot;:</span>
                <span class="s0">fresult = (values * m).astype(&quot;f8&quot;)</span>
                <span class="s0">fresult[mask] = 0</span>
                <span class="s0">if prec:</span>
                    <span class="s0">fresult = round(fresult, prec)</span>
                <span class="s0">result = fresult.astype(&quot;M8[ns]&quot;, copy=False)</span>

            <span class="s0">iresult = result.view(&quot;i8&quot;)</span>
            <span class="s0">iresult[mask] = NPY_NAT</span>

            <span class="s0">return result, tz</span>

    <span class="s0">result = np.empty(n, dtype='M8[ns]')</span>
    <span class="s0">iresult = result.view('i8')</span>

    <span class="s0">try:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>

            <span class="s0">if checknull_with_nat_and_na(val):</span>
                <span class="s0">iresult[i] = NPY_NAT</span>

            <span class="s0">elif is_integer_object(val) or is_float_object(val):</span>

                <span class="s0">if val != val or val == NPY_NAT:</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>
                <span class="s0">else:</span>
                    <span class="s0">try:</span>
                        <span class="s0">iresult[i] = cast_from_unit(val, unit)</span>
                    <span class="s0">except OverflowError:</span>
                        <span class="s0">if is_raise:</span>
                            <span class="s0">raise OutOfBoundsDatetime(</span>
                                <span class="s0">f&quot;cannot convert input {val} with the unit '{unit}'&quot;</span>
                            <span class="s0">)</span>
                        <span class="s0">elif is_ignore:</span>
                            <span class="s0">raise AssertionError</span>
                        <span class="s0">iresult[i] = NPY_NAT</span>

            <span class="s0">elif isinstance(val, str):</span>
                <span class="s0">if len(val) == 0 or val in nat_strings:</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>

                <span class="s0">else:</span>
                    <span class="s0">try:</span>
                        <span class="s0">iresult[i] = cast_from_unit(float(val), unit)</span>
                    <span class="s0">except ValueError:</span>
                        <span class="s0">if is_raise:</span>
                            <span class="s0">raise ValueError(</span>
                                <span class="s0">f&quot;non convertible value {val} with the unit '{unit}'&quot;</span>
                            <span class="s0">)</span>
                        <span class="s0">elif is_ignore:</span>
                            <span class="s0">raise AssertionError</span>
                        <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">except OverflowError:</span>
                        <span class="s0">if is_raise:</span>
                            <span class="s0">raise OutOfBoundsDatetime(</span>
                                <span class="s0">f&quot;cannot convert input {val} with the unit '{unit}'&quot;</span>
                            <span class="s0">)</span>
                        <span class="s0">elif is_ignore:</span>
                            <span class="s0">raise AssertionError</span>
                        <span class="s0">iresult[i] = NPY_NAT</span>

            <span class="s0">else:</span>

                <span class="s0">if is_raise:</span>
                    <span class="s0">raise ValueError(</span>
                        <span class="s0">f&quot;unit='{unit}' not valid with non-numerical val='{val}'&quot;</span>
                    <span class="s0">)</span>
                <span class="s0">if is_ignore:</span>
                    <span class="s0">raise AssertionError</span>

                <span class="s0">iresult[i] = NPY_NAT</span>

        <span class="s0">return result, tz</span>

    <span class="s0">except AssertionError:</span>
        <span class="s0">pass</span>

    <span class="s0"># we have hit an exception</span>
    <span class="s0"># and are in ignore mode</span>
    <span class="s0"># redo as object</span>

    <span class="s0">oresult = np.empty(n, dtype=object)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>

        <span class="s0">if checknull_with_nat_and_na(val):</span>
            <span class="s0">oresult[i] = &lt;object&gt;NaT</span>
        <span class="s0">elif is_integer_object(val) or is_float_object(val):</span>

            <span class="s0">if val != val or val == NPY_NAT:</span>
                <span class="s0">oresult[i] = &lt;object&gt;NaT</span>
            <span class="s0">else:</span>
                <span class="s0">try:</span>
                    <span class="s0">oresult[i] = Timestamp(cast_from_unit(val, unit))</span>
                <span class="s0">except OverflowError:</span>
                    <span class="s0">oresult[i] = val</span>

        <span class="s0">elif isinstance(val, str):</span>
            <span class="s0">if len(val) == 0 or val in nat_strings:</span>
                <span class="s0">oresult[i] = &lt;object&gt;NaT</span>

            <span class="s0">else:</span>
                <span class="s0">oresult[i] = val</span>

    <span class="s0">return oresult, tz</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cpdef array_to_datetime(</span>
    <span class="s0">ndarray[object] values,</span>
    <span class="s0">str errors='raise',</span>
    <span class="s0">bint dayfirst=False,</span>
    <span class="s0">bint yearfirst=False,</span>
    <span class="s0">bint utc=False,</span>
    <span class="s0">bint require_iso8601=False,</span>
    <span class="s0">bint allow_mixed=False,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Converts a 1D array of date-like values to a numpy array of either:</span>
        <span class="s0">1) datetime64[ns] data</span>
        <span class="s0">2) datetime.datetime objects, if OutOfBoundsDatetime or TypeError</span>
           <span class="s0">is encountered</span>

    <span class="s0">Also returns a pytz.FixedOffset if an array of strings with the same</span>
    <span class="s0">timezone offset is passed and utc=True is not passed. Otherwise, None</span>
    <span class="s0">is returned</span>

    <span class="s0">Handles datetime.date, datetime.datetime, np.datetime64 objects, numeric,</span>
    <span class="s0">strings</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : ndarray of object</span>
         <span class="s0">date-like objects to convert</span>
    <span class="s0">errors : str, default 'raise'</span>
         <span class="s0">error behavior when parsing</span>
    <span class="s0">dayfirst : bool, default False</span>
         <span class="s0">dayfirst parsing behavior when encountering datetime strings</span>
    <span class="s0">yearfirst : bool, default False</span>
         <span class="s0">yearfirst parsing behavior when encountering datetime strings</span>
    <span class="s0">utc : bool, default False</span>
         <span class="s0">indicator whether the dates should be UTC</span>
    <span class="s0">require_iso8601 : bool, default False</span>
         <span class="s0">indicator whether the datetime string should be iso8601</span>
    <span class="s0">allow_mixed : bool, default False</span>
        <span class="s0">Whether to allow mixed datetimes and integers.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray</span>
        <span class="s0">May be datetime64[ns] or object dtype</span>
    <span class="s0">tzinfo or None</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">object val, py_dt, tz, tz_out = None</span>
        <span class="s0">ndarray[int64_t] iresult</span>
        <span class="s0">ndarray[object] oresult</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">bint utc_convert = bool(utc)</span>
        <span class="s0">bint seen_integer = False</span>
        <span class="s0">bint seen_string = False</span>
        <span class="s0">bint seen_datetime = False</span>
        <span class="s0">bint seen_datetime_offset = False</span>
        <span class="s0">bint is_raise = errors=='raise'</span>
        <span class="s0">bint is_ignore = errors=='ignore'</span>
        <span class="s0">bint is_coerce = errors=='coerce'</span>
        <span class="s0">bint is_same_offsets</span>
        <span class="s0">_TSObject _ts</span>
        <span class="s0">int64_t value</span>
        <span class="s0">int out_local = 0, out_tzoffset = 0</span>
        <span class="s0">float offset_seconds, tz_offset</span>
        <span class="s0">set out_tzoffset_vals = set()</span>
        <span class="s0">bint string_to_dts_failed</span>

    <span class="s0"># specify error conditions</span>
    <span class="s0">assert is_raise or is_ignore or is_coerce</span>

    <span class="s0">result = np.empty(n, dtype='M8[ns]')</span>
    <span class="s0">iresult = result.view('i8')</span>

    <span class="s0">try:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>

            <span class="s0">try:</span>
                <span class="s0">if checknull_with_nat_and_na(val):</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>

                <span class="s0">elif PyDateTime_Check(val):</span>
                    <span class="s0">seen_datetime = True</span>
                    <span class="s0">if val.tzinfo is not None:</span>
                        <span class="s0">if utc_convert:</span>
                            <span class="s0">_ts = convert_datetime_to_tsobject(val, None)</span>
                            <span class="s0">iresult[i] = _ts.value</span>
                        <span class="s0">else:</span>
                            <span class="s0">raise ValueError('Tz-aware datetime.datetime '</span>
                                             <span class="s0">'cannot be converted to '</span>
                                             <span class="s0">'datetime64 unless utc=True')</span>
                    <span class="s0">elif isinstance(val, _Timestamp):</span>
                        <span class="s0">iresult[i] = val.value</span>
                    <span class="s0">else:</span>
                        <span class="s0">iresult[i] = pydatetime_to_dt64(val, &amp;dts)</span>
                        <span class="s0">check_dts_bounds(&amp;dts)</span>

                <span class="s0">elif PyDate_Check(val):</span>
                    <span class="s0">seen_datetime = True</span>
                    <span class="s0">iresult[i] = pydate_to_dt64(val, &amp;dts)</span>
                    <span class="s0">check_dts_bounds(&amp;dts)</span>

                <span class="s0">elif is_datetime64_object(val):</span>
                    <span class="s0">seen_datetime = True</span>
                    <span class="s0">iresult[i] = get_datetime64_nanos(val)</span>

                <span class="s0">elif is_integer_object(val) or is_float_object(val):</span>
                    <span class="s0"># these must be ns unit by-definition</span>
                    <span class="s0">seen_integer = True</span>

                    <span class="s0">if val != val or val == NPY_NAT:</span>
                        <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">elif is_raise or is_ignore:</span>
                        <span class="s0">iresult[i] = val</span>
                    <span class="s0">else:</span>
                        <span class="s0"># coerce</span>
                        <span class="s0"># we now need to parse this as if unit='ns'</span>
                        <span class="s0"># we can ONLY accept integers at this point</span>
                        <span class="s0"># if we have previously (or in future accept</span>
                        <span class="s0"># datetimes/strings, then we must coerce)</span>
                        <span class="s0">try:</span>
                            <span class="s0">iresult[i] = cast_from_unit(val, 'ns')</span>
                        <span class="s0">except OverflowError:</span>
                            <span class="s0">iresult[i] = NPY_NAT</span>

                <span class="s0">elif isinstance(val, str):</span>
                    <span class="s0"># string</span>
                    <span class="s0">seen_string = True</span>

                    <span class="s0">if len(val) == 0 or val in nat_strings:</span>
                        <span class="s0">iresult[i] = NPY_NAT</span>
                        <span class="s0">continue</span>

                    <span class="s0">string_to_dts_failed = _string_to_dts(</span>
                        <span class="s0">val, &amp;dts, &amp;out_local,</span>
                        <span class="s0">&amp;out_tzoffset, False</span>
                    <span class="s0">)</span>
                    <span class="s0">if string_to_dts_failed:</span>
                        <span class="s0"># An error at this point is a _parsing_ error</span>
                        <span class="s0"># specifically _not_ OutOfBoundsDatetime</span>
                        <span class="s0">if _parse_today_now(val, &amp;iresult[i], utc):</span>
                            <span class="s0">continue</span>
                        <span class="s0">elif require_iso8601:</span>
                            <span class="s0"># if requiring iso8601 strings, skip trying</span>
                            <span class="s0"># other formats</span>
                            <span class="s0">if is_coerce:</span>
                                <span class="s0">iresult[i] = NPY_NAT</span>
                                <span class="s0">continue</span>
                            <span class="s0">elif is_raise:</span>
                                <span class="s0">raise ValueError(</span>
                                    <span class="s0">f&quot;time data {val} doesn't match format specified&quot;</span>
                                <span class="s0">)</span>
                            <span class="s0">return values, tz_out</span>

                        <span class="s0">try:</span>
                            <span class="s0">py_dt = parse_datetime_string(val,</span>
                                                          <span class="s0">dayfirst=dayfirst,</span>
                                                          <span class="s0">yearfirst=yearfirst)</span>
                            <span class="s0"># If the dateutil parser returned tzinfo, capture it</span>
                            <span class="s0"># to check if all arguments have the same tzinfo</span>
                            <span class="s0">tz = py_dt.utcoffset()</span>

                        <span class="s0">except (ValueError, OverflowError):</span>
                            <span class="s0">if is_coerce:</span>
                                <span class="s0">iresult[i] = NPY_NAT</span>
                                <span class="s0">continue</span>
                            <span class="s0">raise TypeError(&quot;invalid string coercion to datetime&quot;)</span>

                        <span class="s0">if tz is not None:</span>
                            <span class="s0">seen_datetime_offset = True</span>
                            <span class="s0"># dateutil timezone objects cannot be hashed, so</span>
                            <span class="s0"># store the UTC offsets in seconds instead</span>
                            <span class="s0">out_tzoffset_vals.add(tz.total_seconds())</span>
                        <span class="s0">else:</span>
                            <span class="s0"># Add a marker for naive string, to track if we are</span>
                            <span class="s0"># parsing mixed naive and aware strings</span>
                            <span class="s0">out_tzoffset_vals.add('naive')</span>

                        <span class="s0">_ts = convert_datetime_to_tsobject(py_dt, None)</span>
                        <span class="s0">iresult[i] = _ts.value</span>
                    <span class="s0">if not string_to_dts_failed:</span>
                        <span class="s0"># No error reported by string_to_dts, pick back up</span>
                        <span class="s0"># where we left off</span>
                        <span class="s0">value = dtstruct_to_dt64(&amp;dts)</span>
                        <span class="s0">if out_local == 1:</span>
                            <span class="s0">seen_datetime_offset = True</span>
                            <span class="s0"># Store the out_tzoffset in seconds</span>
                            <span class="s0"># since we store the total_seconds of</span>
                            <span class="s0"># dateutil.tz.tzoffset objects</span>
                            <span class="s0">out_tzoffset_vals.add(out_tzoffset * 60.)</span>
                            <span class="s0">tz = pytz.FixedOffset(out_tzoffset)</span>
                            <span class="s0">value = tz_localize_to_utc_single(value, tz)</span>
                            <span class="s0">out_local = 0</span>
                            <span class="s0">out_tzoffset = 0</span>
                        <span class="s0">else:</span>
                            <span class="s0"># Add a marker for naive string, to track if we are</span>
                            <span class="s0"># parsing mixed naive and aware strings</span>
                            <span class="s0">out_tzoffset_vals.add('naive')</span>
                        <span class="s0">iresult[i] = value</span>
                        <span class="s0">check_dts_bounds(&amp;dts)</span>

                <span class="s0">else:</span>
                    <span class="s0">if is_coerce:</span>
                        <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">else:</span>
                        <span class="s0">raise TypeError(f&quot;{type(val)} is not convertible to datetime&quot;)</span>

            <span class="s0">except OutOfBoundsDatetime:</span>
                <span class="s0">if is_coerce:</span>
                    <span class="s0">iresult[i] = NPY_NAT</span>
                    <span class="s0">continue</span>
                <span class="s0">elif require_iso8601 and isinstance(val, str):</span>
                    <span class="s0"># GH#19382 for just-barely-OutOfBounds falling back to</span>
                    <span class="s0"># dateutil parser will return incorrect result because</span>
                    <span class="s0"># it will ignore nanoseconds</span>
                    <span class="s0">if is_raise:</span>

                        <span class="s0"># Still raise OutOfBoundsDatetime,</span>
                        <span class="s0"># as error message is informative.</span>
                        <span class="s0">raise</span>

                    <span class="s0">assert is_ignore</span>
                    <span class="s0">return values, tz_out</span>
                <span class="s0">raise</span>

    <span class="s0">except OutOfBoundsDatetime:</span>
        <span class="s0">if is_raise:</span>
            <span class="s0">raise</span>

        <span class="s0">return ignore_errors_out_of_bounds_fallback(values), tz_out</span>

    <span class="s0">except TypeError:</span>
        <span class="s0">return _array_to_datetime_object(values, errors, dayfirst, yearfirst)</span>

    <span class="s0">if seen_datetime and seen_integer:</span>
        <span class="s0"># we have mixed datetimes &amp; integers</span>

        <span class="s0">if is_coerce:</span>
            <span class="s0"># coerce all of the integers/floats to NaT, preserve</span>
            <span class="s0"># the datetimes and other convertibles</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">val = values[i]</span>
                <span class="s0">if is_integer_object(val) or is_float_object(val):</span>
                    <span class="s0">result[i] = NPY_NAT</span>
        <span class="s0">elif allow_mixed:</span>
            <span class="s0">pass</span>
        <span class="s0">elif is_raise:</span>
            <span class="s0">raise ValueError(&quot;mixed datetimes and integers in passed array&quot;)</span>
        <span class="s0">else:</span>
            <span class="s0">return _array_to_datetime_object(values, errors, dayfirst, yearfirst)</span>

    <span class="s0">if seen_datetime_offset and not utc_convert:</span>
        <span class="s0"># GH#17697</span>
        <span class="s0"># 1) If all the offsets are equal, return one offset for</span>
        <span class="s0">#    the parsed dates to (maybe) pass to DatetimeIndex</span>
        <span class="s0"># 2) If the offsets are different, then force the parsing down the</span>
        <span class="s0">#    object path where an array of datetimes</span>
        <span class="s0">#    (with individual dateutil.tzoffsets) are returned</span>
        <span class="s0">is_same_offsets = len(out_tzoffset_vals) == 1</span>
        <span class="s0">if not is_same_offsets:</span>
            <span class="s0">return _array_to_datetime_object(values, errors, dayfirst, yearfirst)</span>
        <span class="s0">else:</span>
            <span class="s0">tz_offset = out_tzoffset_vals.pop()</span>
            <span class="s0">tz_out = pytz.FixedOffset(tz_offset / 60.)</span>
    <span class="s0">return result, tz_out</span>


<span class="s0">cdef ndarray[object] ignore_errors_out_of_bounds_fallback(ndarray[object] values):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Fallback for array_to_datetime if an OutOfBoundsDatetime is raised</span>
    <span class="s0">and errors == &quot;ignore&quot;</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : ndarray[object]</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ndarray[object]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">object val</span>

    <span class="s0">oresult = np.empty(n, dtype=object)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>

        <span class="s0"># set as nan except if its a NaT</span>
        <span class="s0">if checknull_with_nat_and_na(val):</span>
            <span class="s0">if isinstance(val, float):</span>
                <span class="s0">oresult[i] = np.nan</span>
            <span class="s0">else:</span>
                <span class="s0">oresult[i] = NaT</span>
        <span class="s0">elif is_datetime64_object(val):</span>
            <span class="s0">if get_datetime64_value(val) == NPY_NAT:</span>
                <span class="s0">oresult[i] = NaT</span>
            <span class="s0">else:</span>
                <span class="s0">oresult[i] = val.item()</span>
        <span class="s0">else:</span>
            <span class="s0">oresult[i] = val</span>
    <span class="s0">return oresult</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef _array_to_datetime_object(</span>
    <span class="s0">ndarray[object] values,</span>
    <span class="s0">str errors,</span>
    <span class="s0">bint dayfirst=False,</span>
    <span class="s0">bint yearfirst=False,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Fall back function for array_to_datetime</span>

    <span class="s0">Attempts to parse datetime strings with dateutil to return an array</span>
    <span class="s0">of datetime objects</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : ndarray[object]</span>
         <span class="s0">date-like objects to convert</span>
    <span class="s0">errors : str</span>
         <span class="s0">error behavior when parsing</span>
    <span class="s0">dayfirst : bool, default False</span>
         <span class="s0">dayfirst parsing behavior when encountering datetime strings</span>
    <span class="s0">yearfirst : bool, default False</span>
         <span class="s0">yearfirst parsing behavior when encountering datetime strings</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[object]</span>
    <span class="s0">Literal[None]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">object val</span>
        <span class="s0">bint is_ignore = errors == 'ignore'</span>
        <span class="s0">bint is_coerce = errors == 'coerce'</span>
        <span class="s0">bint is_raise = errors == 'raise'</span>
        <span class="s0">ndarray[object] oresult</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">assert is_raise or is_ignore or is_coerce</span>

    <span class="s0">oresult = np.empty(n, dtype=object)</span>

    <span class="s0"># We return an object array and only attempt to parse:</span>
    <span class="s0"># 1) NaT or NaT-like values</span>
    <span class="s0"># 2) datetime strings, which we return as datetime.datetime</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if checknull_with_nat_and_na(val) or PyDateTime_Check(val):</span>
            <span class="s0"># GH 25978. No need to parse NaT-like or datetime-like vals</span>
            <span class="s0">oresult[i] = val</span>
        <span class="s0">elif isinstance(val, str):</span>
            <span class="s0">if len(val) == 0 or val in nat_strings:</span>
                <span class="s0">oresult[i] = 'NaT'</span>
                <span class="s0">continue</span>
            <span class="s0">try:</span>
                <span class="s0">oresult[i] = parse_datetime_string(val, dayfirst=dayfirst,</span>
                                                   <span class="s0">yearfirst=yearfirst)</span>
                <span class="s0">pydatetime_to_dt64(oresult[i], &amp;dts)</span>
                <span class="s0">check_dts_bounds(&amp;dts)</span>
            <span class="s0">except (ValueError, OverflowError):</span>
                <span class="s0">if is_coerce:</span>
                    <span class="s0">oresult[i] = &lt;object&gt;NaT</span>
                    <span class="s0">continue</span>
                <span class="s0">if is_raise:</span>
                    <span class="s0">raise</span>
                <span class="s0">return values, None</span>
        <span class="s0">else:</span>
            <span class="s0">if is_raise:</span>
                <span class="s0">raise</span>
            <span class="s0">return values, None</span>
    <span class="s0">return oresult, None</span>


<span class="s0">cdef inline bint _parse_today_now(str val, int64_t* iresult, bint utc):</span>
    <span class="s0"># We delay this check for as long as possible</span>
    <span class="s0"># because it catches relatively rare cases</span>
    <span class="s0">if val == &quot;now&quot;:</span>
        <span class="s0">iresult[0] = Timestamp.utcnow().value</span>
        <span class="s0">if not utc:</span>
            <span class="s0"># GH#18705 make sure to_datetime(&quot;now&quot;) matches Timestamp(&quot;now&quot;)</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;The parsing of 'now' in pd.to_datetime without `utc=True` is &quot;</span>
                <span class="s0">&quot;deprecated. In a future version, this will match Timestamp('now') &quot;</span>
                <span class="s0">&quot;and Timestamp.now()&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=1,</span>
            <span class="s0">)</span>

        <span class="s0">return True</span>
    <span class="s0">elif val == &quot;today&quot;:</span>
        <span class="s0">iresult[0] = Timestamp.today().value</span>
        <span class="s0">return True</span>
    <span class="s0">return False</span>
</pre>
</body>
</html>