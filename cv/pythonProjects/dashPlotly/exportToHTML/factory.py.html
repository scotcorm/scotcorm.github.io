<html>
<head>
<title>factory.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
factory.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">FrozenSet</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">Iterator</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Mapping</span><span class="s0">,</span>
    <span class="s1">NamedTuple</span><span class="s0">,</span>
    <span class="s1">Optional</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">Set</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
    <span class="s1">TypeVar</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pip._vendor.packaging.requirements </span><span class="s0">import </span><span class="s1">InvalidRequirement</span>
<span class="s0">from </span><span class="s1">pip._vendor.packaging.specifiers </span><span class="s0">import </span><span class="s1">SpecifierSet</span>
<span class="s0">from </span><span class="s1">pip._vendor.packaging.utils </span><span class="s0">import </span><span class="s1">NormalizedName</span><span class="s0">, </span><span class="s1">canonicalize_name</span>
<span class="s0">from </span><span class="s1">pip._vendor.resolvelib </span><span class="s0">import </span><span class="s1">ResolutionImpossible</span>

<span class="s0">from </span><span class="s1">pip._internal.cache </span><span class="s0">import </span><span class="s1">CacheEntry</span><span class="s0">, </span><span class="s1">WheelCache</span>
<span class="s0">from </span><span class="s1">pip._internal.exceptions </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DistributionNotFound</span><span class="s0">,</span>
    <span class="s1">InstallationError</span><span class="s0">,</span>
    <span class="s1">InstallationSubprocessError</span><span class="s0">,</span>
    <span class="s1">MetadataInconsistent</span><span class="s0">,</span>
    <span class="s1">UnsupportedPythonVersion</span><span class="s0">,</span>
    <span class="s1">UnsupportedWheel</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pip._internal.index.package_finder </span><span class="s0">import </span><span class="s1">PackageFinder</span>
<span class="s0">from </span><span class="s1">pip._internal.metadata </span><span class="s0">import </span><span class="s1">BaseDistribution</span><span class="s0">, </span><span class="s1">get_default_environment</span>
<span class="s0">from </span><span class="s1">pip._internal.models.link </span><span class="s0">import </span><span class="s1">Link</span>
<span class="s0">from </span><span class="s1">pip._internal.models.wheel </span><span class="s0">import </span><span class="s1">Wheel</span>
<span class="s0">from </span><span class="s1">pip._internal.operations.prepare </span><span class="s0">import </span><span class="s1">RequirementPreparer</span>
<span class="s0">from </span><span class="s1">pip._internal.req.constructors </span><span class="s0">import </span><span class="s1">install_req_from_link_and_ireq</span>
<span class="s0">from </span><span class="s1">pip._internal.req.req_install </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">InstallRequirement</span><span class="s0">,</span>
    <span class="s1">check_invalid_constraint_type</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pip._internal.resolution.base </span><span class="s0">import </span><span class="s1">InstallRequirementProvider</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.compatibility_tags </span><span class="s0">import </span><span class="s1">get_supported</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s0">import </span><span class="s1">Hashes</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.packaging </span><span class="s0">import </span><span class="s1">get_requirement</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.virtualenv </span><span class="s0">import </span><span class="s1">running_under_virtualenv</span>

<span class="s0">from </span><span class="s1">.base </span><span class="s0">import </span><span class="s1">Candidate</span><span class="s0">, </span><span class="s1">CandidateVersion</span><span class="s0">, </span><span class="s1">Constraint</span><span class="s0">, </span><span class="s1">Requirement</span>
<span class="s0">from </span><span class="s1">.candidates </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">AlreadyInstalledCandidate</span><span class="s0">,</span>
    <span class="s1">BaseCandidate</span><span class="s0">,</span>
    <span class="s1">EditableCandidate</span><span class="s0">,</span>
    <span class="s1">ExtrasCandidate</span><span class="s0">,</span>
    <span class="s1">LinkCandidate</span><span class="s0">,</span>
    <span class="s1">RequiresPythonCandidate</span><span class="s0">,</span>
    <span class="s1">as_base_candidate</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.found_candidates </span><span class="s0">import </span><span class="s1">FoundCandidates</span><span class="s0">, </span><span class="s1">IndexCandidateInfo</span>
<span class="s0">from </span><span class="s1">.requirements </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ExplicitRequirement</span><span class="s0">,</span>
    <span class="s1">RequiresPythonRequirement</span><span class="s0">,</span>
    <span class="s1">SpecifierRequirement</span><span class="s0">,</span>
    <span class="s1">UnsatisfiableRequirement</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Protocol</span>

    <span class="s0">class </span><span class="s1">ConflictCause(Protocol):</span>
        <span class="s1">requirement: RequiresPythonRequirement</span>
        <span class="s1">parent: Candidate</span>


<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">C = TypeVar(</span><span class="s2">&quot;C&quot;</span><span class="s1">)</span>
<span class="s1">Cache = Dict[Link</span><span class="s0">, </span><span class="s1">C]</span>


<span class="s0">class </span><span class="s1">CollectedRootRequirements(NamedTuple):</span>
    <span class="s1">requirements: List[Requirement]</span>
    <span class="s1">constraints: Dict[str</span><span class="s0">, </span><span class="s1">Constraint]</span>
    <span class="s1">user_requested: Dict[str</span><span class="s0">, </span><span class="s1">int]</span>


<span class="s0">class </span><span class="s1">Factory:</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">finder: PackageFinder</span><span class="s0">,</span>
        <span class="s1">preparer: RequirementPreparer</span><span class="s0">,</span>
        <span class="s1">make_install_req: InstallRequirementProvider</span><span class="s0">,</span>
        <span class="s1">wheel_cache: Optional[WheelCache]</span><span class="s0">,</span>
        <span class="s1">use_user_site: bool</span><span class="s0">,</span>
        <span class="s1">force_reinstall: bool</span><span class="s0">,</span>
        <span class="s1">ignore_installed: bool</span><span class="s0">,</span>
        <span class="s1">ignore_requires_python: bool</span><span class="s0">,</span>
        <span class="s1">suppress_build_failures: bool</span><span class="s0">,</span>
        <span class="s1">py_version_info: Optional[Tuple[int</span><span class="s0">, </span><span class="s1">...]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._finder = finder</span>
        <span class="s1">self.preparer = preparer</span>
        <span class="s1">self._wheel_cache = wheel_cache</span>
        <span class="s1">self._python_candidate = RequiresPythonCandidate(py_version_info)</span>
        <span class="s1">self._make_install_req_from_spec = make_install_req</span>
        <span class="s1">self._use_user_site = use_user_site</span>
        <span class="s1">self._force_reinstall = force_reinstall</span>
        <span class="s1">self._ignore_requires_python = ignore_requires_python</span>
        <span class="s1">self._suppress_build_failures = suppress_build_failures</span>

        <span class="s1">self._build_failures: Cache[InstallationError] = {}</span>
        <span class="s1">self._link_candidate_cache: Cache[LinkCandidate] = {}</span>
        <span class="s1">self._editable_candidate_cache: Cache[EditableCandidate] = {}</span>
        <span class="s1">self._installed_candidate_cache: Dict[str</span><span class="s0">, </span><span class="s1">AlreadyInstalledCandidate] = {}</span>
        <span class="s1">self._extras_candidate_cache: Dict[</span>
            <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">FrozenSet[str]]</span><span class="s0">, </span><span class="s1">ExtrasCandidate</span>
        <span class="s1">] = {}</span>

        <span class="s0">if not </span><span class="s1">ignore_installed:</span>
            <span class="s1">env = get_default_environment()</span>
            <span class="s1">self._installed_dists = {</span>
                <span class="s1">dist.canonical_name: dist</span>
                <span class="s0">for </span><span class="s1">dist </span><span class="s0">in </span><span class="s1">env.iter_installed_distributions(local_only=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._installed_dists = {}</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">force_reinstall(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self._force_reinstall</span>

    <span class="s0">def </span><span class="s1">_fail_if_link_is_unsupported_wheel(self</span><span class="s0">, </span><span class="s1">link: Link) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">link.is_wheel:</span>
            <span class="s0">return</span>
        <span class="s1">wheel = Wheel(link.filename)</span>
        <span class="s0">if </span><span class="s1">wheel.supported(self._finder.target_python.get_tags()):</span>
            <span class="s0">return</span>
        <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">link.filename</span><span class="s0">} </span><span class="s2">is not a supported wheel on this platform.&quot;</span>
        <span class="s0">raise </span><span class="s1">UnsupportedWheel(msg)</span>

    <span class="s0">def </span><span class="s1">_make_extras_candidate(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">base: BaseCandidate</span><span class="s0">, </span><span class="s1">extras: FrozenSet[str]</span>
    <span class="s1">) -&gt; ExtrasCandidate:</span>
        <span class="s1">cache_key = (id(base)</span><span class="s0">, </span><span class="s1">extras)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">candidate = self._extras_candidate_cache[cache_key]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">candidate = ExtrasCandidate(base</span><span class="s0">, </span><span class="s1">extras)</span>
            <span class="s1">self._extras_candidate_cache[cache_key] = candidate</span>
        <span class="s0">return </span><span class="s1">candidate</span>

    <span class="s0">def </span><span class="s1">_make_candidate_from_dist(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dist: BaseDistribution</span><span class="s0">,</span>
        <span class="s1">extras: FrozenSet[str]</span><span class="s0">,</span>
        <span class="s1">template: InstallRequirement</span><span class="s0">,</span>
    <span class="s1">) -&gt; Candidate:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">base = self._installed_candidate_cache[dist.canonical_name]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">base = AlreadyInstalledCandidate(dist</span><span class="s0">, </span><span class="s1">template</span><span class="s0">, </span><span class="s1">factory=self)</span>
            <span class="s1">self._installed_candidate_cache[dist.canonical_name] = base</span>
        <span class="s0">if not </span><span class="s1">extras:</span>
            <span class="s0">return </span><span class="s1">base</span>
        <span class="s0">return </span><span class="s1">self._make_extras_candidate(base</span><span class="s0">, </span><span class="s1">extras)</span>

    <span class="s0">def </span><span class="s1">_make_candidate_from_link(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">link: Link</span><span class="s0">,</span>
        <span class="s1">extras: FrozenSet[str]</span><span class="s0">,</span>
        <span class="s1">template: InstallRequirement</span><span class="s0">,</span>
        <span class="s1">name: Optional[NormalizedName]</span><span class="s0">,</span>
        <span class="s1">version: Optional[CandidateVersion]</span><span class="s0">,</span>
    <span class="s1">) -&gt; Optional[Candidate]:</span>
        <span class="s3"># TODO: Check already installed candidate, and use it if the link and</span>
        <span class="s3"># editable flag match.</span>

        <span class="s0">if </span><span class="s1">link </span><span class="s0">in </span><span class="s1">self._build_failures:</span>
            <span class="s3"># We already tried this candidate before, and it does not build.</span>
            <span class="s3"># Don't bother trying again.</span>
            <span class="s0">return None</span>

        <span class="s0">if </span><span class="s1">template.editable:</span>
            <span class="s0">if </span><span class="s1">link </span><span class="s0">not in </span><span class="s1">self._editable_candidate_cache:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">self._editable_candidate_cache[link] = EditableCandidate(</span>
                        <span class="s1">link</span><span class="s0">,</span>
                        <span class="s1">template</span><span class="s0">,</span>
                        <span class="s1">factory=self</span><span class="s0">,</span>
                        <span class="s1">name=name</span><span class="s0">,</span>
                        <span class="s1">version=version</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">except </span><span class="s1">MetadataInconsistent </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s1">logger.info(</span>
                        <span class="s2">&quot;Discarding [blue underline]%s[/]: [yellow]%s[reset]&quot;</span><span class="s0">,</span>
                        <span class="s1">link</span><span class="s0">,</span>
                        <span class="s1">e</span><span class="s0">,</span>
                        <span class="s1">extra={</span><span class="s2">&quot;markup&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s1">self._build_failures[link] = e</span>
                    <span class="s0">return None</span>
                <span class="s0">except </span><span class="s1">InstallationSubprocessError </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s0">if not </span><span class="s1">self._suppress_build_failures:</span>
                        <span class="s0">raise</span>
                    <span class="s1">logger.warning(</span><span class="s2">&quot;Discarding %s due to build failure: %s&quot;</span><span class="s0">, </span><span class="s1">link</span><span class="s0">, </span><span class="s1">e)</span>
                    <span class="s1">self._build_failures[link] = e</span>
                    <span class="s0">return None</span>

            <span class="s1">base: BaseCandidate = self._editable_candidate_cache[link]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">link </span><span class="s0">not in </span><span class="s1">self._link_candidate_cache:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">self._link_candidate_cache[link] = LinkCandidate(</span>
                        <span class="s1">link</span><span class="s0">,</span>
                        <span class="s1">template</span><span class="s0">,</span>
                        <span class="s1">factory=self</span><span class="s0">,</span>
                        <span class="s1">name=name</span><span class="s0">,</span>
                        <span class="s1">version=version</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">except </span><span class="s1">MetadataInconsistent </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s1">logger.info(</span>
                        <span class="s2">&quot;Discarding [blue underline]%s[/]: [yellow]%s[reset]&quot;</span><span class="s0">,</span>
                        <span class="s1">link</span><span class="s0">,</span>
                        <span class="s1">e</span><span class="s0">,</span>
                        <span class="s1">extra={</span><span class="s2">&quot;markup&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s1">self._build_failures[link] = e</span>
                    <span class="s0">return None</span>
                <span class="s0">except </span><span class="s1">InstallationSubprocessError </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s0">if not </span><span class="s1">self._suppress_build_failures:</span>
                        <span class="s0">raise</span>
                    <span class="s1">logger.warning(</span><span class="s2">&quot;Discarding %s due to build failure: %s&quot;</span><span class="s0">, </span><span class="s1">link</span><span class="s0">, </span><span class="s1">e)</span>
                    <span class="s1">self._build_failures[link] = e</span>
                    <span class="s0">return None</span>
            <span class="s1">base = self._link_candidate_cache[link]</span>

        <span class="s0">if not </span><span class="s1">extras:</span>
            <span class="s0">return </span><span class="s1">base</span>
        <span class="s0">return </span><span class="s1">self._make_extras_candidate(base</span><span class="s0">, </span><span class="s1">extras)</span>

    <span class="s0">def </span><span class="s1">_iter_found_candidates(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">ireqs: Sequence[InstallRequirement]</span><span class="s0">,</span>
        <span class="s1">specifier: SpecifierSet</span><span class="s0">,</span>
        <span class="s1">hashes: Hashes</span><span class="s0">,</span>
        <span class="s1">prefers_installed: bool</span><span class="s0">,</span>
        <span class="s1">incompatible_ids: Set[int]</span><span class="s0">,</span>
    <span class="s1">) -&gt; Iterable[Candidate]:</span>
        <span class="s0">if not </span><span class="s1">ireqs:</span>
            <span class="s0">return </span><span class="s1">()</span>

        <span class="s3"># The InstallRequirement implementation requires us to give it a</span>
        <span class="s3"># &quot;template&quot;. Here we just choose the first requirement to represent</span>
        <span class="s3"># all of them.</span>
        <span class="s3"># Hopefully the Project model can correct this mismatch in the future.</span>
        <span class="s1">template = ireqs[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">template.req</span><span class="s0">, </span><span class="s2">&quot;Candidates found on index must be PEP 508&quot;</span>
        <span class="s1">name = canonicalize_name(template.req.name)</span>

        <span class="s1">extras: FrozenSet[str] = frozenset()</span>
        <span class="s0">for </span><span class="s1">ireq </span><span class="s0">in </span><span class="s1">ireqs:</span>
            <span class="s0">assert </span><span class="s1">ireq.req</span><span class="s0">, </span><span class="s2">&quot;Candidates found on index must be PEP 508&quot;</span>
            <span class="s1">specifier &amp;= ireq.req.specifier</span>
            <span class="s1">hashes &amp;= ireq.hashes(trust_internet=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">extras |= frozenset(ireq.extras)</span>

        <span class="s0">def </span><span class="s1">_get_installed_candidate() -&gt; Optional[Candidate]:</span>
            <span class="s5">&quot;&quot;&quot;Get the candidate for the currently-installed version.&quot;&quot;&quot;</span>
            <span class="s3"># If --force-reinstall is set, we want the version from the index</span>
            <span class="s3"># instead, so we &quot;pretend&quot; there is nothing installed.</span>
            <span class="s0">if </span><span class="s1">self._force_reinstall:</span>
                <span class="s0">return None</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">installed_dist = self._installed_dists[name]</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">return None</span>
            <span class="s3"># Don't use the installed distribution if its version does not fit</span>
            <span class="s3"># the current dependency graph.</span>
            <span class="s0">if not </span><span class="s1">specifier.contains(installed_dist.version</span><span class="s0">, </span><span class="s1">prereleases=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s0">return None</span>
            <span class="s1">candidate = self._make_candidate_from_dist(</span>
                <span class="s1">dist=installed_dist</span><span class="s0">,</span>
                <span class="s1">extras=extras</span><span class="s0">,</span>
                <span class="s1">template=template</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s3"># The candidate is a known incompatibility. Don't use it.</span>
            <span class="s0">if </span><span class="s1">id(candidate) </span><span class="s0">in </span><span class="s1">incompatible_ids:</span>
                <span class="s0">return None</span>
            <span class="s0">return </span><span class="s1">candidate</span>

        <span class="s0">def </span><span class="s1">iter_index_candidate_infos() -&gt; Iterator[IndexCandidateInfo]:</span>
            <span class="s1">result = self._finder.find_best_candidate(</span>
                <span class="s1">project_name=name</span><span class="s0">,</span>
                <span class="s1">specifier=specifier</span><span class="s0">,</span>
                <span class="s1">hashes=hashes</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">icans = list(result.iter_applicable())</span>

            <span class="s3"># PEP 592: Yanked releases are ignored unless the specifier</span>
            <span class="s3"># explicitly pins a version (via '==' or '===') that can be</span>
            <span class="s3"># solely satisfied by a yanked release.</span>
            <span class="s1">all_yanked = all(ican.link.is_yanked </span><span class="s0">for </span><span class="s1">ican </span><span class="s0">in </span><span class="s1">icans)</span>

            <span class="s0">def </span><span class="s1">is_pinned(specifier: SpecifierSet) -&gt; bool:</span>
                <span class="s0">for </span><span class="s1">sp </span><span class="s0">in </span><span class="s1">specifier:</span>
                    <span class="s0">if </span><span class="s1">sp.operator == </span><span class="s2">&quot;===&quot;</span><span class="s1">:</span>
                        <span class="s0">return True</span>
                    <span class="s0">if </span><span class="s1">sp.operator != </span><span class="s2">&quot;==&quot;</span><span class="s1">:</span>
                        <span class="s0">continue</span>
                    <span class="s0">if </span><span class="s1">sp.version.endswith(</span><span class="s2">&quot;.*&quot;</span><span class="s1">):</span>
                        <span class="s0">continue</span>
                    <span class="s0">return True</span>
                <span class="s0">return False</span>

            <span class="s1">pinned = is_pinned(specifier)</span>

            <span class="s3"># PackageFinder returns earlier versions first, so we reverse.</span>
            <span class="s0">for </span><span class="s1">ican </span><span class="s0">in </span><span class="s1">reversed(icans):</span>
                <span class="s0">if not </span><span class="s1">(all_yanked </span><span class="s0">and </span><span class="s1">pinned) </span><span class="s0">and </span><span class="s1">ican.link.is_yanked:</span>
                    <span class="s0">continue</span>
                <span class="s1">func = functools.partial(</span>
                    <span class="s1">self._make_candidate_from_link</span><span class="s0">,</span>
                    <span class="s1">link=ican.link</span><span class="s0">,</span>
                    <span class="s1">extras=extras</span><span class="s0">,</span>
                    <span class="s1">template=template</span><span class="s0">,</span>
                    <span class="s1">name=name</span><span class="s0">,</span>
                    <span class="s1">version=ican.version</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">yield </span><span class="s1">ican.version</span><span class="s0">, </span><span class="s1">func</span>

        <span class="s0">return </span><span class="s1">FoundCandidates(</span>
            <span class="s1">iter_index_candidate_infos</span><span class="s0">,</span>
            <span class="s1">_get_installed_candidate()</span><span class="s0">,</span>
            <span class="s1">prefers_installed</span><span class="s0">,</span>
            <span class="s1">incompatible_ids</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_iter_explicit_candidates_from_base(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">base_requirements: Iterable[Requirement]</span><span class="s0">,</span>
        <span class="s1">extras: FrozenSet[str]</span><span class="s0">,</span>
    <span class="s1">) -&gt; Iterator[Candidate]:</span>
        <span class="s5">&quot;&quot;&quot;Produce explicit candidates from the base given an extra-ed package. 
 
        :param base_requirements: Requirements known to the resolver. The 
            requirements are guaranteed to not have extras. 
        :param extras: The extras to inject into the explicit requirements' 
            candidates. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">base_requirements:</span>
            <span class="s1">lookup_cand</span><span class="s0">, </span><span class="s1">_ = req.get_candidate_lookup()</span>
            <span class="s0">if </span><span class="s1">lookup_cand </span><span class="s0">is None</span><span class="s1">:  </span><span class="s3"># Not explicit.</span>
                <span class="s0">continue</span>
            <span class="s3"># We've stripped extras from the identifier, and should always</span>
            <span class="s3"># get a BaseCandidate here, unless there's a bug elsewhere.</span>
            <span class="s1">base_cand = as_base_candidate(lookup_cand)</span>
            <span class="s0">assert </span><span class="s1">base_cand </span><span class="s0">is not None, </span><span class="s2">&quot;no extras here&quot;</span>
            <span class="s0">yield </span><span class="s1">self._make_extras_candidate(base_cand</span><span class="s0">, </span><span class="s1">extras)</span>

    <span class="s0">def </span><span class="s1">_iter_candidates_from_constraints(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">identifier: str</span><span class="s0">,</span>
        <span class="s1">constraint: Constraint</span><span class="s0">,</span>
        <span class="s1">template: InstallRequirement</span><span class="s0">,</span>
    <span class="s1">) -&gt; Iterator[Candidate]:</span>
        <span class="s5">&quot;&quot;&quot;Produce explicit candidates from constraints. 
 
        This creates &quot;fake&quot; InstallRequirement objects that are basically clones 
        of what &quot;should&quot; be the template, but with original_link set to link. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">link </span><span class="s0">in </span><span class="s1">constraint.links:</span>
            <span class="s1">self._fail_if_link_is_unsupported_wheel(link)</span>
            <span class="s1">candidate = self._make_candidate_from_link(</span>
                <span class="s1">link</span><span class="s0">,</span>
                <span class="s1">extras=frozenset()</span><span class="s0">,</span>
                <span class="s1">template=install_req_from_link_and_ireq(link</span><span class="s0">, </span><span class="s1">template)</span><span class="s0">,</span>
                <span class="s1">name=canonicalize_name(identifier)</span><span class="s0">,</span>
                <span class="s1">version=</span><span class="s0">None,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">candidate:</span>
                <span class="s0">yield </span><span class="s1">candidate</span>

    <span class="s0">def </span><span class="s1">find_candidates(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">identifier: str</span><span class="s0">,</span>
        <span class="s1">requirements: Mapping[str</span><span class="s0">, </span><span class="s1">Iterable[Requirement]]</span><span class="s0">,</span>
        <span class="s1">incompatibilities: Mapping[str</span><span class="s0">, </span><span class="s1">Iterator[Candidate]]</span><span class="s0">,</span>
        <span class="s1">constraint: Constraint</span><span class="s0">,</span>
        <span class="s1">prefers_installed: bool</span><span class="s0">,</span>
    <span class="s1">) -&gt; Iterable[Candidate]:</span>
        <span class="s3"># Collect basic lookup information from the requirements.</span>
        <span class="s1">explicit_candidates: Set[Candidate] = set()</span>
        <span class="s1">ireqs: List[InstallRequirement] = []</span>
        <span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">requirements[identifier]:</span>
            <span class="s1">cand</span><span class="s0">, </span><span class="s1">ireq = req.get_candidate_lookup()</span>
            <span class="s0">if </span><span class="s1">cand </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">explicit_candidates.add(cand)</span>
            <span class="s0">if </span><span class="s1">ireq </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">ireqs.append(ireq)</span>

        <span class="s3"># If the current identifier contains extras, add explicit candidates</span>
        <span class="s3"># from entries from extra-less identifier.</span>
        <span class="s0">with </span><span class="s1">contextlib.suppress(InvalidRequirement):</span>
            <span class="s1">parsed_requirement = get_requirement(identifier)</span>
            <span class="s1">explicit_candidates.update(</span>
                <span class="s1">self._iter_explicit_candidates_from_base(</span>
                    <span class="s1">requirements.get(parsed_requirement.name</span><span class="s0">, </span><span class="s1">())</span><span class="s0">,</span>
                    <span class="s1">frozenset(parsed_requirement.extras)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s3"># Add explicit candidates from constraints. We only do this if there are</span>
        <span class="s3"># known ireqs, which represent requirements not already explicit. If</span>
        <span class="s3"># there are no ireqs, we're constraining already-explicit requirements,</span>
        <span class="s3"># which is handled later when we return the explicit candidates.</span>
        <span class="s0">if </span><span class="s1">ireqs:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">explicit_candidates.update(</span>
                    <span class="s1">self._iter_candidates_from_constraints(</span>
                        <span class="s1">identifier</span><span class="s0">,</span>
                        <span class="s1">constraint</span><span class="s0">,</span>
                        <span class="s1">template=ireqs[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">except </span><span class="s1">UnsupportedWheel:</span>
                <span class="s3"># If we're constrained to install a wheel incompatible with the</span>
                <span class="s3"># target architecture, no candidates will ever be valid.</span>
                <span class="s0">return </span><span class="s1">()</span>

        <span class="s3"># Since we cache all the candidates, incompatibility identification</span>
        <span class="s3"># can be made quicker by comparing only the id() values.</span>
        <span class="s1">incompat_ids = {id(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">incompatibilities.get(identifier</span><span class="s0">, </span><span class="s1">())}</span>

        <span class="s3"># If none of the requirements want an explicit candidate, we can ask</span>
        <span class="s3"># the finder for candidates.</span>
        <span class="s0">if not </span><span class="s1">explicit_candidates:</span>
            <span class="s0">return </span><span class="s1">self._iter_found_candidates(</span>
                <span class="s1">ireqs</span><span class="s0">,</span>
                <span class="s1">constraint.specifier</span><span class="s0">,</span>
                <span class="s1">constraint.hashes</span><span class="s0">,</span>
                <span class="s1">prefers_installed</span><span class="s0">,</span>
                <span class="s1">incompat_ids</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">c</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">explicit_candidates</span>
            <span class="s0">if </span><span class="s1">id(c) </span><span class="s0">not in </span><span class="s1">incompat_ids</span>
            <span class="s0">and </span><span class="s1">constraint.is_satisfied_by(c)</span>
            <span class="s0">and </span><span class="s1">all(req.is_satisfied_by(c) </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">requirements[identifier])</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_make_requirement_from_install_req(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">ireq: InstallRequirement</span><span class="s0">, </span><span class="s1">requested_extras: Iterable[str]</span>
    <span class="s1">) -&gt; Optional[Requirement]:</span>
        <span class="s0">if not </span><span class="s1">ireq.match_markers(requested_extras):</span>
            <span class="s1">logger.info(</span>
                <span class="s2">&quot;Ignoring %s: markers '%s' don't match your environment&quot;</span><span class="s0">,</span>
                <span class="s1">ireq.name</span><span class="s0">,</span>
                <span class="s1">ireq.markers</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">return None</span>
        <span class="s0">if not </span><span class="s1">ireq.link:</span>
            <span class="s0">return </span><span class="s1">SpecifierRequirement(ireq)</span>
        <span class="s1">self._fail_if_link_is_unsupported_wheel(ireq.link)</span>
        <span class="s1">cand = self._make_candidate_from_link(</span>
            <span class="s1">ireq.link</span><span class="s0">,</span>
            <span class="s1">extras=frozenset(ireq.extras)</span><span class="s0">,</span>
            <span class="s1">template=ireq</span><span class="s0">,</span>
            <span class="s1">name=canonicalize_name(ireq.name) </span><span class="s0">if </span><span class="s1">ireq.name </span><span class="s0">else None,</span>
            <span class="s1">version=</span><span class="s0">None,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">cand </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s3"># There's no way we can satisfy a URL requirement if the underlying</span>
            <span class="s3"># candidate fails to build. An unnamed URL must be user-supplied, so</span>
            <span class="s3"># we fail eagerly. If the URL is named, an unsatisfiable requirement</span>
            <span class="s3"># can make the resolver do the right thing, either backtrack (and</span>
            <span class="s3"># maybe find some other requirement that's buildable) or raise a</span>
            <span class="s3"># ResolutionImpossible eventually.</span>
            <span class="s0">if not </span><span class="s1">ireq.name:</span>
                <span class="s0">raise </span><span class="s1">self._build_failures[ireq.link]</span>
            <span class="s0">return </span><span class="s1">UnsatisfiableRequirement(canonicalize_name(ireq.name))</span>
        <span class="s0">return </span><span class="s1">self.make_requirement_from_candidate(cand)</span>

    <span class="s0">def </span><span class="s1">collect_root_requirements(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">root_ireqs: List[InstallRequirement]</span>
    <span class="s1">) -&gt; CollectedRootRequirements:</span>
        <span class="s1">collected = CollectedRootRequirements([]</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ireq </span><span class="s0">in </span><span class="s1">enumerate(root_ireqs):</span>
            <span class="s0">if </span><span class="s1">ireq.constraint:</span>
                <span class="s3"># Ensure we only accept valid constraints</span>
                <span class="s1">problem = check_invalid_constraint_type(ireq)</span>
                <span class="s0">if </span><span class="s1">problem:</span>
                    <span class="s0">raise </span><span class="s1">InstallationError(problem)</span>
                <span class="s0">if not </span><span class="s1">ireq.match_markers():</span>
                    <span class="s0">continue</span>
                <span class="s0">assert </span><span class="s1">ireq.name</span><span class="s0">, </span><span class="s2">&quot;Constraint must be named&quot;</span>
                <span class="s1">name = canonicalize_name(ireq.name)</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">collected.constraints:</span>
                    <span class="s1">collected.constraints[name] &amp;= ireq</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">collected.constraints[name] = Constraint.from_ireq(ireq)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">req = self._make_requirement_from_install_req(</span>
                    <span class="s1">ireq</span><span class="s0">,</span>
                    <span class="s1">requested_extras=()</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">req </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">ireq.user_supplied </span><span class="s0">and </span><span class="s1">req.name </span><span class="s0">not in </span><span class="s1">collected.user_requested:</span>
                    <span class="s1">collected.user_requested[req.name] = i</span>
                <span class="s1">collected.requirements.append(req)</span>
        <span class="s0">return </span><span class="s1">collected</span>

    <span class="s0">def </span><span class="s1">make_requirement_from_candidate(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">candidate: Candidate</span>
    <span class="s1">) -&gt; ExplicitRequirement:</span>
        <span class="s0">return </span><span class="s1">ExplicitRequirement(candidate)</span>

    <span class="s0">def </span><span class="s1">make_requirement_from_spec(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">specifier: str</span><span class="s0">,</span>
        <span class="s1">comes_from: Optional[InstallRequirement]</span><span class="s0">,</span>
        <span class="s1">requested_extras: Iterable[str] = ()</span><span class="s0">,</span>
    <span class="s1">) -&gt; Optional[Requirement]:</span>
        <span class="s1">ireq = self._make_install_req_from_spec(specifier</span><span class="s0">, </span><span class="s1">comes_from)</span>
        <span class="s0">return </span><span class="s1">self._make_requirement_from_install_req(ireq</span><span class="s0">, </span><span class="s1">requested_extras)</span>

    <span class="s0">def </span><span class="s1">make_requires_python_requirement(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">specifier: SpecifierSet</span><span class="s0">,</span>
    <span class="s1">) -&gt; Optional[Requirement]:</span>
        <span class="s0">if </span><span class="s1">self._ignore_requires_python:</span>
            <span class="s0">return None</span>
        <span class="s3"># Don't bother creating a dependency for an empty Requires-Python.</span>
        <span class="s0">if not </span><span class="s1">str(specifier):</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">RequiresPythonRequirement(specifier</span><span class="s0">, </span><span class="s1">self._python_candidate)</span>

    <span class="s0">def </span><span class="s1">get_wheel_cache_entry(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">link: Link</span><span class="s0">, </span><span class="s1">name: Optional[str]</span>
    <span class="s1">) -&gt; Optional[CacheEntry]:</span>
        <span class="s5">&quot;&quot;&quot;Look up the link in the wheel cache. 
 
        If ``preparer.require_hashes`` is True, don't use the wheel cache, 
        because cached wheels, always built locally, have different hashes 
        than the files downloaded from the index server and thus throw false 
        hash mismatches. Furthermore, cached wheels at present have 
        nondeterministic contents due to file modification times. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._wheel_cache </span><span class="s0">is None or </span><span class="s1">self.preparer.require_hashes:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">self._wheel_cache.get_cache_entry(</span>
            <span class="s1">link=link</span><span class="s0">,</span>
            <span class="s1">package_name=name</span><span class="s0">,</span>
            <span class="s1">supported_tags=get_supported()</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_dist_to_uninstall(self</span><span class="s0">, </span><span class="s1">candidate: Candidate) -&gt; Optional[BaseDistribution]:</span>
        <span class="s3"># TODO: Are there more cases this needs to return True? Editable?</span>
        <span class="s1">dist = self._installed_dists.get(candidate.project_name)</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is None</span><span class="s1">:  </span><span class="s3"># Not installed, no uninstallation required.</span>
            <span class="s0">return None</span>

        <span class="s3"># We're installing into global site. The current installation must</span>
        <span class="s3"># be uninstalled, no matter it's in global or user site, because the</span>
        <span class="s3"># user site installation has precedence over global.</span>
        <span class="s0">if not </span><span class="s1">self._use_user_site:</span>
            <span class="s0">return </span><span class="s1">dist</span>

        <span class="s3"># We're installing into user site. Remove the user site installation.</span>
        <span class="s0">if </span><span class="s1">dist.in_usersite:</span>
            <span class="s0">return </span><span class="s1">dist</span>

        <span class="s3"># We're installing into user site, but the installed incompatible</span>
        <span class="s3"># package is in global site. We can't uninstall that, and would let</span>
        <span class="s3"># the new user installation to &quot;shadow&quot; it. But shadowing won't work</span>
        <span class="s3"># in virtual environments, so we error out.</span>
        <span class="s0">if </span><span class="s1">running_under_virtualenv() </span><span class="s0">and </span><span class="s1">dist.in_site_packages:</span>
            <span class="s1">message = (</span>
                <span class="s2">f&quot;Will not install to the user site because it will lack &quot;</span>
                <span class="s2">f&quot;sys.path precedence to </span><span class="s0">{</span><span class="s1">dist.raw_name</span><span class="s0">} </span><span class="s2">in </span><span class="s0">{</span><span class="s1">dist.location</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">InstallationError(message)</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">_report_requires_python_error(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">causes: Sequence[</span><span class="s2">&quot;ConflictCause&quot;</span><span class="s1">]</span>
    <span class="s1">) -&gt; UnsupportedPythonVersion:</span>
        <span class="s0">assert </span><span class="s1">causes</span><span class="s0">, </span><span class="s2">&quot;Requires-Python error reported with no cause&quot;</span>

        <span class="s1">version = self._python_candidate.version</span>

        <span class="s0">if </span><span class="s1">len(causes) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">specifier = str(causes[</span><span class="s4">0</span><span class="s1">].requirement.specifier)</span>
            <span class="s1">message = (</span>
                <span class="s2">f&quot;Package </span><span class="s0">{</span><span class="s1">causes[</span><span class="s4">0</span><span class="s1">].parent.name</span><span class="s0">!r} </span><span class="s2">requires a different &quot;</span>
                <span class="s2">f&quot;Python: </span><span class="s0">{</span><span class="s1">version</span><span class="s0">} </span><span class="s2">not in </span><span class="s0">{</span><span class="s1">specifier</span><span class="s0">!r}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">UnsupportedPythonVersion(message)</span>

        <span class="s1">message = </span><span class="s2">f&quot;Packages require a different Python. </span><span class="s0">{</span><span class="s1">version</span><span class="s0">} </span><span class="s2">not in:&quot;</span>
        <span class="s0">for </span><span class="s1">cause </span><span class="s0">in </span><span class="s1">causes:</span>
            <span class="s1">package = cause.parent.format_for_error()</span>
            <span class="s1">specifier = str(cause.requirement.specifier)</span>
            <span class="s1">message += </span><span class="s2">f&quot;</span><span class="s0">\n{</span><span class="s1">specifier</span><span class="s0">!r} </span><span class="s2">(required by </span><span class="s0">{</span><span class="s1">package</span><span class="s0">}</span><span class="s2">)&quot;</span>
        <span class="s0">return </span><span class="s1">UnsupportedPythonVersion(message)</span>

    <span class="s0">def </span><span class="s1">_report_single_requirement_conflict(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">req: Requirement</span><span class="s0">, </span><span class="s1">parent: Optional[Candidate]</span>
    <span class="s1">) -&gt; DistributionNotFound:</span>
        <span class="s0">if </span><span class="s1">parent </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">req_disp = str(req)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">req_disp = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">req</span><span class="s0">} </span><span class="s2">(from </span><span class="s0">{</span><span class="s1">parent.name</span><span class="s0">}</span><span class="s2">)&quot;</span>

        <span class="s1">cands = self._finder.find_all_candidates(req.project_name)</span>
        <span class="s1">versions = [str(v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sorted({c.version </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">cands})]</span>

        <span class="s1">logger.critical(</span>
            <span class="s2">&quot;Could not find a version that satisfies the requirement %s &quot;</span>
            <span class="s2">&quot;(from versions: %s)&quot;</span><span class="s0">,</span>
            <span class="s1">req_disp</span><span class="s0">,</span>
            <span class="s2">&quot;, &quot;</span><span class="s1">.join(versions) </span><span class="s0">or </span><span class="s2">&quot;none&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">str(req) == </span><span class="s2">&quot;requirements.txt&quot;</span><span class="s1">:</span>
            <span class="s1">logger.info(</span>
                <span class="s2">&quot;HINT: You are attempting to install a package literally &quot;</span>
                <span class="s2">'named &quot;requirements.txt&quot; (which cannot exist). Consider '</span>
                <span class="s2">&quot;using the '-r' flag to install the packages listed in &quot;</span>
                <span class="s2">&quot;requirements.txt&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">DistributionNotFound(</span><span class="s2">f&quot;No matching distribution found for </span><span class="s0">{</span><span class="s1">req</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_installation_error(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">e: </span><span class="s2">&quot;ResolutionImpossible[Requirement, Candidate]&quot;</span><span class="s0">,</span>
        <span class="s1">constraints: Dict[str</span><span class="s0">, </span><span class="s1">Constraint]</span><span class="s0">,</span>
    <span class="s1">) -&gt; InstallationError:</span>

        <span class="s0">assert </span><span class="s1">e.causes</span><span class="s0">, </span><span class="s2">&quot;Installation error reported with no cause&quot;</span>

        <span class="s3"># If one of the things we can't solve is &quot;we need Python X.Y&quot;,</span>
        <span class="s3"># that is what we report.</span>
        <span class="s1">requires_python_causes = [</span>
            <span class="s1">cause</span>
            <span class="s0">for </span><span class="s1">cause </span><span class="s0">in </span><span class="s1">e.causes</span>
            <span class="s0">if </span><span class="s1">isinstance(cause.requirement</span><span class="s0">, </span><span class="s1">RequiresPythonRequirement)</span>
            <span class="s0">and not </span><span class="s1">cause.requirement.is_satisfied_by(self._python_candidate)</span>
        <span class="s1">]</span>
        <span class="s0">if </span><span class="s1">requires_python_causes:</span>
            <span class="s3"># The comprehension above makes sure all Requirement instances are</span>
            <span class="s3"># RequiresPythonRequirement, so let's cast for convenience.</span>
            <span class="s0">return </span><span class="s1">self._report_requires_python_error(</span>
                <span class="s1">cast(</span><span class="s2">&quot;Sequence[ConflictCause]&quot;</span><span class="s0">, </span><span class="s1">requires_python_causes)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s3"># Otherwise, we have a set of causes which can't all be satisfied</span>
        <span class="s3"># at once.</span>

        <span class="s3"># The simplest case is when we have *one* cause that can't be</span>
        <span class="s3"># satisfied. We just report that case.</span>
        <span class="s0">if </span><span class="s1">len(e.causes) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">req</span><span class="s0">, </span><span class="s1">parent = e.causes[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">req.name </span><span class="s0">not in </span><span class="s1">constraints:</span>
                <span class="s0">return </span><span class="s1">self._report_single_requirement_conflict(req</span><span class="s0">, </span><span class="s1">parent)</span>

        <span class="s3"># OK, we now have a list of requirements that can't all be</span>
        <span class="s3"># satisfied at once.</span>

        <span class="s3"># A couple of formatting helpers</span>
        <span class="s0">def </span><span class="s1">text_join(parts: List[str]) -&gt; str:</span>
            <span class="s0">if </span><span class="s1">len(parts) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">parts[</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s0">return </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(parts[:-</span><span class="s4">1</span><span class="s1">]) + </span><span class="s2">&quot; and &quot; </span><span class="s1">+ parts[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">describe_trigger(parent: Candidate) -&gt; str:</span>
            <span class="s1">ireq = parent.get_install_requirement()</span>
            <span class="s0">if not </span><span class="s1">ireq </span><span class="s0">or not </span><span class="s1">ireq.comes_from:</span>
                <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">parent.name</span><span class="s0">}</span><span class="s2">==</span><span class="s0">{</span><span class="s1">parent.version</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">if </span><span class="s1">isinstance(ireq.comes_from</span><span class="s0">, </span><span class="s1">InstallRequirement):</span>
                <span class="s0">return </span><span class="s1">str(ireq.comes_from.name)</span>
            <span class="s0">return </span><span class="s1">str(ireq.comes_from)</span>

        <span class="s1">triggers = set()</span>
        <span class="s0">for </span><span class="s1">req</span><span class="s0">, </span><span class="s1">parent </span><span class="s0">in </span><span class="s1">e.causes:</span>
            <span class="s0">if </span><span class="s1">parent </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s3"># This is a root requirement, so we can report it directly</span>
                <span class="s1">trigger = req.format_for_error()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">trigger = describe_trigger(parent)</span>
            <span class="s1">triggers.add(trigger)</span>

        <span class="s0">if </span><span class="s1">triggers:</span>
            <span class="s1">info = text_join(sorted(triggers))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">info = </span><span class="s2">&quot;the requested packages&quot;</span>

        <span class="s1">msg = (</span>
            <span class="s2">&quot;Cannot install {} because these package versions &quot;</span>
            <span class="s2">&quot;have conflicting dependencies.&quot;</span><span class="s1">.format(info)</span>
        <span class="s1">)</span>
        <span class="s1">logger.critical(msg)</span>
        <span class="s1">msg = </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">The conflict is caused by:&quot;</span>

        <span class="s1">relevant_constraints = set()</span>
        <span class="s0">for </span><span class="s1">req</span><span class="s0">, </span><span class="s1">parent </span><span class="s0">in </span><span class="s1">e.causes:</span>
            <span class="s0">if </span><span class="s1">req.name </span><span class="s0">in </span><span class="s1">constraints:</span>
                <span class="s1">relevant_constraints.add(req.name)</span>
            <span class="s1">msg = msg + </span><span class="s2">&quot;</span><span class="s0">\n    </span><span class="s2">&quot;</span>
            <span class="s0">if </span><span class="s1">parent:</span>
                <span class="s1">msg = msg + </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">parent.name</span><span class="s0">} {</span><span class="s1">parent.version</span><span class="s0">} </span><span class="s2">depends on &quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = msg + </span><span class="s2">&quot;The user requested &quot;</span>
            <span class="s1">msg = msg + req.format_for_error()</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">relevant_constraints:</span>
            <span class="s1">spec = constraints[key].specifier</span>
            <span class="s1">msg += </span><span class="s2">f&quot;</span><span class="s0">\n    </span><span class="s2">The user requested (constraint) </span><span class="s0">{</span><span class="s1">key</span><span class="s0">}{</span><span class="s1">spec</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s1">msg = (</span>
            <span class="s1">msg</span>
            <span class="s1">+ </span><span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">&quot;</span>
            <span class="s1">+ </span><span class="s2">&quot;To fix this you could try to:</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">+ </span><span class="s2">&quot;1. loosen the range of package versions you've specified</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">+ </span><span class="s2">&quot;2. remove package versions to allow pip attempt to solve &quot;</span>
            <span class="s1">+ </span><span class="s2">&quot;the dependency conflict</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s1">)</span>

        <span class="s1">logger.info(msg)</span>

        <span class="s0">return </span><span class="s1">DistributionNotFound(</span>
            <span class="s2">&quot;ResolutionImpossible: for help visit &quot;</span>
            <span class="s2">&quot;https://pip.pypa.io/en/latest/topics/dependency-resolution/&quot;</span>
            <span class="s2">&quot;#dealing-with-dependency-conflicts&quot;</span>
        <span class="s1">)</span>
</pre>
</body>
</html>