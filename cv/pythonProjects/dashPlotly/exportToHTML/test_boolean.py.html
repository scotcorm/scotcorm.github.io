<html>
<head>
<title>test_boolean.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_boolean.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s2">import </span><span class="s1">BooleanDtype</span>
<span class="s2">from </span><span class="s1">pandas.tests.extension </span><span class="s2">import </span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">make_data():</span>
    <span class="s2">return </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">] * </span><span class="s3">4 </span><span class="s1">+ [np.nan] + [</span><span class="s2">True, False</span><span class="s1">] * </span><span class="s3">44 </span><span class="s1">+ [np.nan] + [</span><span class="s2">True, False</span><span class="s1">]</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">dtype():</span>
    <span class="s2">return </span><span class="s1">BooleanDtype()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data(dtype):</span>
    <span class="s2">return </span><span class="s1">pd.array(make_data()</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_twos(dtype):</span>
    <span class="s2">return </span><span class="s1">pd.array(np.ones(</span><span class="s3">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing(dtype):</span>
    <span class="s2">return </span><span class="s1">pd.array([np.nan</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_sorting(dtype):</span>
    <span class="s2">return </span><span class="s1">pd.array([</span><span class="s2">True, True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting(dtype):</span>
    <span class="s2">return </span><span class="s1">pd.array([</span><span class="s2">True, </span><span class="s1">np.nan</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_cmp():</span>
    <span class="s4"># we are pd.NA</span>
    <span class="s2">return lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: x </span><span class="s2">is </span><span class="s1">pd.NA </span><span class="s2">and </span><span class="s1">y </span><span class="s2">is </span><span class="s1">pd.NA</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_value():</span>
    <span class="s2">return </span><span class="s1">pd.NA</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_grouping(dtype):</span>
    <span class="s1">b = </span><span class="s2">True</span>
    <span class="s1">a = </span><span class="s2">False</span>
    <span class="s1">na = np.nan</span>
    <span class="s2">return </span><span class="s1">pd.array([b</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s2">class </span><span class="s1">TestDtype(base.BaseDtypeTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestInterface(base.BaseInterfaceTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestConstructors(base.BaseConstructorsTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestGetitem(base.BaseGetitemTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestSetitem(base.BaseSetitemTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestIndex(base.BaseIndexTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestMissing(base.BaseMissingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestArithmeticOps(base.BaseArithmeticOpsTests):</span>
    <span class="s1">implements = {</span><span class="s5">&quot;__sub__&quot;</span><span class="s2">, </span><span class="s5">&quot;__rsub__&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">check_opname(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># overwriting to indicate ops don't raise an error</span>
        <span class="s1">super().check_opname(s</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_op(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">exc=NotImplementedError):</span>
        <span class="s2">if </span><span class="s1">exc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">self.implements:</span>
                <span class="s1">msg = </span><span class="s5">r&quot;numpy boolean subtract&quot;</span>
                <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                    <span class="s1">op(obj</span><span class="s2">, </span><span class="s1">other)</span>
                <span class="s2">return</span>

            <span class="s1">result = op(obj</span><span class="s2">, </span><span class="s1">other)</span>
            <span class="s1">expected = self._combine(obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op)</span>

            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span>
                <span class="s5">&quot;__floordiv__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;__rfloordiv__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;__pow__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;__rpow__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;__mod__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;__rmod__&quot;</span><span class="s2">,</span>
            <span class="s1">):</span>
                <span class="s4"># combine keeps boolean type</span>
                <span class="s1">expected = expected.astype(</span><span class="s5">&quot;Int8&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;__truediv__&quot;</span><span class="s2">, </span><span class="s5">&quot;__rtruediv__&quot;</span><span class="s1">):</span>
                <span class="s4"># combine with bools does not generate the correct result</span>
                <span class="s4">#  (numpy behaviour for div is to regard the bools as numeric)</span>
                <span class="s1">expected = self._combine(obj.astype(float)</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op)</span>
                <span class="s1">expected = expected.astype(</span><span class="s5">&quot;Float64&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">op_name == </span><span class="s5">&quot;__rpow__&quot;</span><span class="s1">:</span>
                <span class="s4"># for rpow, combine does not propagate NaN</span>
                <span class="s1">expected[result.isna()] = np.nan</span>
            <span class="s1">self.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(exc):</span>
                <span class="s1">op(obj</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">_check_divmod_op(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># override to not raise an error</span>
        <span class="s1">super()._check_divmod_op(s</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestComparisonOps(base.BaseComparisonOpsTests):</span>
    <span class="s2">def </span><span class="s1">check_opname(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># overwriting to indicate ops don't raise an error</span>
        <span class="s1">super().check_opname(s</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestReshaping(base.BaseReshapingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestMethods(base.BaseMethodsTests):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;na_sentinel&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_factorize(self</span><span class="s2">, </span><span class="s1">data_for_grouping</span><span class="s2">, </span><span class="s1">na_sentinel):</span>
        <span class="s4"># override because we only have 2 unique values</span>
        <span class="s1">labels</span><span class="s2">, </span><span class="s1">uniques = pd.factorize(data_for_grouping</span><span class="s2">, </span><span class="s1">na_sentinel=na_sentinel)</span>
        <span class="s1">expected_labels = np.array(</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">na_sentinel</span><span class="s2">, </span><span class="s1">na_sentinel</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.intp</span>
        <span class="s1">)</span>
        <span class="s1">expected_uniques = data_for_grouping.take([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

        <span class="s1">tm.assert_numpy_array_equal(labels</span><span class="s2">, </span><span class="s1">expected_labels)</span>
        <span class="s1">self.assert_extension_array_equal(uniques</span><span class="s2">, </span><span class="s1">expected_uniques)</span>

    <span class="s2">def </span><span class="s1">test_combine_le(self</span><span class="s2">, </span><span class="s1">data_repeated):</span>
        <span class="s4"># override because expected needs to be boolean instead of bool dtype</span>
        <span class="s1">orig_data1</span><span class="s2">, </span><span class="s1">orig_data2 = data_repeated(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">s1 = pd.Series(orig_data1)</span>
        <span class="s1">s2 = pd.Series(orig_data2)</span>
        <span class="s1">result = s1.combine(s2</span><span class="s2">, lambda </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2: x1 &lt;= x2)</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">[a &lt;= b </span><span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">b) </span><span class="s2">in </span><span class="s1">zip(list(orig_data1)</span><span class="s2">, </span><span class="s1">list(orig_data2))]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s5">&quot;boolean&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">val = s1.iloc[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">result = s1.combine(val</span><span class="s2">, lambda </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2: x1 &lt;= x2)</span>
        <span class="s1">expected = pd.Series([a &lt;= val </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">list(orig_data1)]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;boolean&quot;</span><span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_searchsorted(self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">as_series):</span>
        <span class="s4"># override because we only have 2 unique values</span>
        <span class="s1">data_for_sorting = pd.array([</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;boolean&quot;</span><span class="s1">)</span>
        <span class="s1">b</span><span class="s2">, </span><span class="s1">a = data_for_sorting</span>
        <span class="s1">arr = type(data_for_sorting)._from_sequence([a</span><span class="s2">, </span><span class="s1">b])</span>

        <span class="s2">if </span><span class="s1">as_series:</span>
            <span class="s1">arr = pd.Series(arr)</span>
        <span class="s2">assert </span><span class="s1">arr.searchsorted(a) == </span><span class="s3">0</span>
        <span class="s2">assert </span><span class="s1">arr.searchsorted(a</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;right&quot;</span><span class="s1">) == </span><span class="s3">1</span>

        <span class="s2">assert </span><span class="s1">arr.searchsorted(b) == </span><span class="s3">1</span>
        <span class="s2">assert </span><span class="s1">arr.searchsorted(b</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;right&quot;</span><span class="s1">) == </span><span class="s3">2</span>

        <span class="s1">result = arr.searchsorted(arr.take([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]))</span>
        <span class="s1">expected = np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># sorter</span>
        <span class="s1">sorter = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">data_for_sorting.searchsorted(a</span><span class="s2">, </span><span class="s1">sorter=sorter) == </span><span class="s3">0</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;uses nullable integer&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_value_counts(self</span><span class="s2">, </span><span class="s1">all_data</span><span class="s2">, </span><span class="s1">dropna):</span>
        <span class="s2">return </span><span class="s1">super().test_value_counts(all_data</span><span class="s2">, </span><span class="s1">dropna)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;uses nullable integer&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_value_counts_with_normalize(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_value_counts_with_normalize(data)</span>

    <span class="s2">def </span><span class="s1">test_argmin_argmax(self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">data_missing_for_sorting):</span>
        <span class="s4"># override because there are only 2 unique values</span>

        <span class="s4"># data_for_sorting -&gt; [B, C, A] with A &lt; B &lt; C -&gt; here True, True, False</span>
        <span class="s2">assert </span><span class="s1">data_for_sorting.argmax() == </span><span class="s3">0</span>
        <span class="s2">assert </span><span class="s1">data_for_sorting.argmin() == </span><span class="s3">2</span>

        <span class="s4"># with repeated values -&gt; first occurrence</span>
        <span class="s1">data = data_for_sorting.take([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">data.argmax() == </span><span class="s3">1</span>
        <span class="s2">assert </span><span class="s1">data.argmin() == </span><span class="s3">0</span>

        <span class="s4"># with missing values</span>
        <span class="s4"># data_missing_for_sorting -&gt; [B, NA, A] with A &lt; B and NA missing.</span>
        <span class="s2">assert </span><span class="s1">data_missing_for_sorting.argmax() == </span><span class="s3">0</span>
        <span class="s2">assert </span><span class="s1">data_missing_for_sorting.argmin() == </span><span class="s3">2</span>


<span class="s2">class </span><span class="s1">TestCasting(base.BaseCastingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestGroupby(base.BaseGroupbyTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    Groupby-specific tests are overridden because boolean only has 2 
    unique values, base tests uses 3 groups. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_grouping_grouper(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">df = pd.DataFrame(</span>
            <span class="s1">{</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s5">&quot;B&quot;</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s2">, None, None, </span><span class="s5">&quot;A&quot;</span><span class="s2">, </span><span class="s5">&quot;A&quot;</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping}</span>
        <span class="s1">)</span>
        <span class="s1">gr1 = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).grouper.groupings[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">gr2 = df.groupby(</span><span class="s5">&quot;B&quot;</span><span class="s1">).grouper.groupings[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">tm.assert_numpy_array_equal(gr1.grouping_vector</span><span class="s2">, </span><span class="s1">df.A.values)</span>
        <span class="s1">tm.assert_extension_array_equal(gr2.grouping_vector</span><span class="s2">, </span><span class="s1">data_for_grouping)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;as_index&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_groupby_extension_agg(self</span><span class="s2">, </span><span class="s1">as_index</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping})</span>
        <span class="s1">result = df.groupby(</span><span class="s5">&quot;B&quot;</span><span class="s2">, </span><span class="s1">as_index=as_index).A.mean()</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">uniques = pd.factorize(data_for_grouping</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">as_index:</span>
            <span class="s1">index = pd.Index(uniques</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;B&quot;</span><span class="s1">)</span>
            <span class="s1">expected = pd.Series([</span><span class="s3">3.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>
            <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;B&quot;</span><span class="s1">: uniques</span><span class="s2">, </span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">3.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]})</span>
            <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_groupby_agg_extension(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s4"># GH#38980 groupby agg on extension type fails for non-numeric types</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping})</span>

        <span class="s1">expected = df.iloc[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]]</span>
        <span class="s1">expected = expected.set_index(</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>

        <span class="s1">result = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).agg({</span><span class="s5">&quot;B&quot;</span><span class="s1">: </span><span class="s5">&quot;first&quot;</span><span class="s1">})</span>
        <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).agg(</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>
        <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).first()</span>
        <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_groupby_extension_no_sort(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping})</span>
        <span class="s1">result = df.groupby(</span><span class="s5">&quot;B&quot;</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">False</span><span class="s1">).A.mean()</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">index = pd.factorize(data_for_grouping</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">index = pd.Index(index</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">expected = pd.Series([</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">3.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_groupby_extension_transform(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">valid = data_for_grouping[~data_for_grouping.isna()]</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: valid})</span>

        <span class="s1">result = df.groupby(</span><span class="s5">&quot;B&quot;</span><span class="s1">).A.transform(len)</span>
        <span class="s1">expected = pd.Series([</span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>

        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_groupby_extension_apply(self</span><span class="s2">, </span><span class="s1">data_for_grouping</span><span class="s2">, </span><span class="s1">groupby_apply_op):</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping})</span>
        <span class="s1">df.groupby(</span><span class="s5">&quot;B&quot;</span><span class="s1">).apply(groupby_apply_op)</span>
        <span class="s1">df.groupby(</span><span class="s5">&quot;B&quot;</span><span class="s1">).A.apply(groupby_apply_op)</span>
        <span class="s1">df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).apply(groupby_apply_op)</span>
        <span class="s1">df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).B.apply(groupby_apply_op)</span>

    <span class="s2">def </span><span class="s1">test_groupby_apply_identity(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping})</span>
        <span class="s1">result = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).B.apply(</span><span class="s2">lambda </span><span class="s1">x: x.array)</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">[</span>
                <span class="s1">df.B.iloc[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]].array</span><span class="s2">,</span>
                <span class="s1">df.B.iloc[[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]].array</span><span class="s2">,</span>
                <span class="s1">df.B.iloc[[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">]].array</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.Index([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s5">&quot;B&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_in_numeric_groupby(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">df = pd.DataFrame(</span>
            <span class="s1">{</span>
                <span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping</span><span class="s2">,</span>
                <span class="s5">&quot;C&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">result = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).sum().columns</span>

        <span class="s2">if </span><span class="s1">data_for_grouping.dtype._is_numeric:</span>
            <span class="s1">expected = pd.Index([</span><span class="s5">&quot;B&quot;</span><span class="s2">, </span><span class="s5">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = pd.Index([</span><span class="s5">&quot;C&quot;</span><span class="s1">])</span>

        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;min_count&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">10</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_groupby_sum_mincount(self</span><span class="s2">, </span><span class="s1">data_for_grouping</span><span class="s2">, </span><span class="s1">min_count):</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: data_for_grouping})</span>
        <span class="s1">result = df.groupby(</span><span class="s5">&quot;A&quot;</span><span class="s1">).sum(min_count=min_count)</span>
        <span class="s2">if </span><span class="s1">min_count == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">expected = pd.DataFrame(</span>
                <span class="s1">{</span><span class="s5">&quot;B&quot;</span><span class="s1">: pd.array([</span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;Int64&quot;</span><span class="s1">)}</span><span class="s2">,</span>
                <span class="s1">index=pd.Index([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = pd.DataFrame(</span>
                <span class="s1">{</span><span class="s5">&quot;B&quot;</span><span class="s1">: pd.array([pd.NA] * </span><span class="s3">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;Int64&quot;</span><span class="s1">)}</span><span class="s2">,</span>
                <span class="s1">index=pd.Index([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestNumericReduce(base.BaseNumericReduceTests):</span>
    <span class="s2">def </span><span class="s1">check_reduce(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna):</span>
        <span class="s1">result = getattr(s</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
        <span class="s1">expected = getattr(s.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
        <span class="s4"># override parent function to cast to bool for min/max</span>
        <span class="s2">if </span><span class="s1">np.isnan(expected):</span>
            <span class="s1">expected = pd.NA</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s5">&quot;max&quot;</span><span class="s1">):</span>
            <span class="s1">expected = bool(expected)</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestBooleanReduce(base.BaseBooleanReduceTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestPrinting(base.BasePrintingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestUnaryOps(base.BaseUnaryOpsTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestParsing(base.BaseParsingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">Test2DCompat(base.Dim2CompatTests):</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>