<html>
<head>
<title>parsing.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parsing.pyx</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Parsing functions for datetime and datetime-like strings.</span>
<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">import re</span>
<span class="s0">import time</span>
<span class="s0">import warnings</span>

<span class="s0">from libc.string cimport strchr</span>

<span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">datetime,</span>
    <span class="s0">datetime_new,</span>
    <span class="s0">import_datetime,</span>
    <span class="s0">tzinfo,</span>
<span class="s0">)</span>
<span class="s0">from cpython.object cimport PyObject_Str</span>
<span class="s0">from cpython.version cimport PY_VERSION_HEX</span>

<span class="s0">import_datetime()</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">PyArray_GETITEM,</span>
    <span class="s0">PyArray_ITER_DATA,</span>
    <span class="s0">PyArray_ITER_NEXT,</span>
    <span class="s0">PyArray_IterNew,</span>
    <span class="s0">flatiter,</span>
    <span class="s0">float64_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0"># dateutil compat</span>

<span class="s0">from dateutil.parser import (</span>
    <span class="s0">DEFAULTPARSER,</span>
    <span class="s0">parse as du_parse,</span>
<span class="s0">)</span>
<span class="s0">from dateutil.relativedelta import relativedelta</span>
<span class="s0">from dateutil.tz import (</span>
    <span class="s0">tzlocal as _dateutil_tzlocal,</span>
    <span class="s0">tzoffset,</span>
    <span class="s0">tzstr as _dateutil_tzstr,</span>
    <span class="s0">tzutc as _dateutil_tzutc,</span>
<span class="s0">)</span>

<span class="s0">from pandas._config import get_option</span>

<span class="s0">from pandas._libs.tslibs.ccalendar cimport c_MONTH_NUMBERS</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">c_NaT as NaT,</span>
    <span class="s0">c_nat_strings as nat_strings,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.offsets cimport is_offset_object</span>
<span class="s0">from pandas._libs.tslibs.util cimport (</span>
    <span class="s0">get_c_string_buf_and_size,</span>
    <span class="s0">is_array,</span>
<span class="s0">)</span>


<span class="s0">cdef extern from &quot;../src/headers/portable.h&quot;:</span>
    <span class="s0">int getdigit_ascii(char c, int default) nogil</span>

<span class="s0">cdef extern from &quot;../src/parser/tokenizer.h&quot;:</span>
    <span class="s0">double xstrtod(const char *p, char **q, char decimal, char sci, char tsep,</span>
                   <span class="s0">int skip_trailing, int *error, int *maybe_int)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Constants</span>


<span class="s0">class DateParseError(ValueError):</span>
    <span class="s0">pass</span>


<span class="s0">_DEFAULT_DATETIME = datetime(1, 1, 1).replace(hour=0, minute=0,</span>
                                              <span class="s0">second=0, microsecond=0)</span>

<span class="s0">PARSING_WARNING_MSG = (</span>
    <span class="s0">&quot;Parsing '{date_string}' in {format} format. Provide format &quot;</span>
    <span class="s0">&quot;or specify infer_datetime_format=True for consistent parsing.&quot;</span>
<span class="s0">)</span>

<span class="s0">cdef:</span>
    <span class="s0">set _not_datelike_strings = {'a', 'A', 'm', 'M', 'p', 'P', 't', 'T'}</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0">cdef:</span>
    <span class="s0">const char* delimiters = &quot; /-.&quot;</span>
    <span class="s0">int MAX_DAYS_IN_MONTH = 31, MAX_MONTH = 12</span>


<span class="s0">cdef inline bint _is_not_delimiter(const char ch):</span>
    <span class="s0">return strchr(delimiters, ch) == NULL</span>


<span class="s0">cdef inline int _parse_2digit(const char* s):</span>
    <span class="s0">cdef int result = 0</span>
    <span class="s0">result += getdigit_ascii(s[0], -10) * 10</span>
    <span class="s0">result += getdigit_ascii(s[1], -100) * 1</span>
    <span class="s0">return result</span>


<span class="s0">cdef inline int _parse_4digit(const char* s):</span>
    <span class="s0">cdef int result = 0</span>
    <span class="s0">result += getdigit_ascii(s[0], -10) * 1000</span>
    <span class="s0">result += getdigit_ascii(s[1], -100) * 100</span>
    <span class="s0">result += getdigit_ascii(s[2], -1000) * 10</span>
    <span class="s0">result += getdigit_ascii(s[3], -10000) * 1</span>
    <span class="s0">return result</span>


<span class="s0">cdef inline object _parse_delimited_date(str date_string, bint dayfirst):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parse special cases of dates: MM/DD/YYYY, DD/MM/YYYY, MM/YYYY.</span>

    <span class="s0">At the beginning function tries to parse date in MM/DD/YYYY format, but</span>
    <span class="s0">if month &gt; 12 - in DD/MM/YYYY (`dayfirst == False`).</span>
    <span class="s0">With `dayfirst == True` function makes an attempt to parse date in</span>
    <span class="s0">DD/MM/YYYY, if an attempt is wrong - in DD/MM/YYYY</span>

    <span class="s0">For MM/DD/YYYY, DD/MM/YYYY: delimiter can be a space or one of /-.</span>
    <span class="s0">For MM/YYYY: delimiter can be a space or one of /-</span>
    <span class="s0">If `date_string` can't be converted to date, then function returns</span>
    <span class="s0">None, None</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">date_string : str</span>
    <span class="s0">dayfirst : bool</span>

    <span class="s0">Returns:</span>
    <span class="s0">--------</span>
    <span class="s0">datetime or None</span>
    <span class="s0">str or None</span>
        <span class="s0">Describing resolution of the parsed string.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">const char* buf</span>
        <span class="s0">Py_ssize_t length</span>
        <span class="s0">int day = 1, month = 1, year</span>
        <span class="s0">bint can_swap = 0</span>

    <span class="s0">buf = get_c_string_buf_and_size(date_string, &amp;length)</span>
    <span class="s0">if length == 10:</span>
        <span class="s0"># parsing MM?DD?YYYY and DD?MM?YYYY dates</span>
        <span class="s0">if _is_not_delimiter(buf[2]) or _is_not_delimiter(buf[5]):</span>
            <span class="s0">return None, None</span>
        <span class="s0">month = _parse_2digit(buf)</span>
        <span class="s0">day = _parse_2digit(buf + 3)</span>
        <span class="s0">year = _parse_4digit(buf + 6)</span>
        <span class="s0">reso = 'day'</span>
        <span class="s0">can_swap = 1</span>
    <span class="s0">elif length == 7:</span>
        <span class="s0"># parsing MM?YYYY dates</span>
        <span class="s0">if buf[2] == b'.' or _is_not_delimiter(buf[2]):</span>
            <span class="s0"># we cannot reliably tell whether e.g. 10.2010 is a float</span>
            <span class="s0"># or a date, thus we refuse to parse it here</span>
            <span class="s0">return None, None</span>
        <span class="s0">month = _parse_2digit(buf)</span>
        <span class="s0">year = _parse_4digit(buf + 3)</span>
        <span class="s0">reso = 'month'</span>
    <span class="s0">else:</span>
        <span class="s0">return None, None</span>

    <span class="s0">if month &lt; 0 or day &lt; 0 or year &lt; 1000:</span>
        <span class="s0"># some part is not an integer, so</span>
        <span class="s0"># date_string can't be converted to date, above format</span>
        <span class="s0">return None, None</span>

    <span class="s0">swapped_day_and_month = False</span>
    <span class="s0">if 1 &lt;= month &lt;= MAX_DAYS_IN_MONTH and 1 &lt;= day &lt;= MAX_DAYS_IN_MONTH \</span>
            <span class="s0">and (month &lt;= MAX_MONTH or day &lt;= MAX_MONTH):</span>
        <span class="s0">if (month &gt; MAX_MONTH or (day &lt;= MAX_MONTH and dayfirst)) and can_swap:</span>
            <span class="s0">day, month = month, day</span>
            <span class="s0">swapped_day_and_month = True</span>
        <span class="s0">if dayfirst and not swapped_day_and_month:</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">PARSING_WARNING_MSG.format(</span>
                    <span class="s0">date_string=date_string,</span>
                    <span class="s0">format='MM/DD/YYYY'</span>
                <span class="s0">),</span>
                <span class="s0">stacklevel=4,</span>
            <span class="s0">)</span>
        <span class="s0">elif not dayfirst and swapped_day_and_month:</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">PARSING_WARNING_MSG.format(</span>
                    <span class="s0">date_string=date_string,</span>
                    <span class="s0">format='DD/MM/YYYY'</span>
                <span class="s0">),</span>
                <span class="s0">stacklevel=4,</span>
            <span class="s0">)</span>
        <span class="s0">if PY_VERSION_HEX &gt;= 0x03060100:</span>
            <span class="s0"># In Python &lt;= 3.6.0 there is no range checking for invalid dates</span>
            <span class="s0"># in C api, thus we call faster C version for 3.6.1 or newer</span>
            <span class="s0">return datetime_new(year, month, day, 0, 0, 0, 0, None), reso</span>
        <span class="s0">return datetime(year, month, day, 0, 0, 0, 0, None), reso</span>

    <span class="s0">raise DateParseError(f&quot;Invalid date specified ({month}/{day})&quot;)</span>


<span class="s0">cdef inline bint does_string_look_like_time(str parse_string):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Checks whether given string is a time: it has to start either from</span>
    <span class="s0">H:MM or from HH:MM, and hour and minute values must be valid.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">parse_string : str</span>

    <span class="s0">Returns:</span>
    <span class="s0">--------</span>
    <span class="s0">bool</span>
        <span class="s0">Whether given string is potentially a time.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">const char* buf</span>
        <span class="s0">Py_ssize_t length</span>
        <span class="s0">int hour = -1, minute = -1</span>

    <span class="s0">buf = get_c_string_buf_and_size(parse_string, &amp;length)</span>
    <span class="s0">if length &gt;= 4:</span>
        <span class="s0">if buf[1] == b':':</span>
            <span class="s0"># h:MM format</span>
            <span class="s0">hour = getdigit_ascii(buf[0], -1)</span>
            <span class="s0">minute = _parse_2digit(buf + 2)</span>
        <span class="s0">elif buf[2] == b':':</span>
            <span class="s0"># HH:MM format</span>
            <span class="s0">hour = _parse_2digit(buf)</span>
            <span class="s0">minute = _parse_2digit(buf + 3)</span>

    <span class="s0">return 0 &lt;= hour &lt;= 23 and 0 &lt;= minute &lt;= 59</span>


<span class="s0">def parse_datetime_string(</span>
    <span class="s0">str date_string,</span>
    <span class="s0">bint dayfirst=False,</span>
    <span class="s0">bint yearfirst=False,</span>
    <span class="s0">**kwargs,</span>
<span class="s0">) -&gt; datetime:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parse datetime string, only returns datetime.</span>
    <span class="s0">Also cares special handling matching time patterns.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">datetime</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">object dt</span>

    <span class="s0">if not _does_string_look_like_datetime(date_string):</span>
        <span class="s0">raise ValueError('Given date string not likely a datetime.')</span>

    <span class="s0">if does_string_look_like_time(date_string):</span>
        <span class="s0"># use current datetime as default, not pass _DEFAULT_DATETIME</span>
        <span class="s0">dt = du_parse(date_string, dayfirst=dayfirst,</span>
                      <span class="s0">yearfirst=yearfirst, **kwargs)</span>
        <span class="s0">return dt</span>

    <span class="s0">dt, _ = _parse_delimited_date(date_string, dayfirst)</span>
    <span class="s0">if dt is not None:</span>
        <span class="s0">return dt</span>

    <span class="s0">try:</span>
        <span class="s0">dt, _ = _parse_dateabbr_string(date_string, _DEFAULT_DATETIME, freq=None)</span>
        <span class="s0">return dt</span>
    <span class="s0">except DateParseError:</span>
        <span class="s0">raise</span>
    <span class="s0">except ValueError:</span>
        <span class="s0">pass</span>

    <span class="s0">try:</span>
        <span class="s0">dt = du_parse(date_string, default=_DEFAULT_DATETIME,</span>
                      <span class="s0">dayfirst=dayfirst, yearfirst=yearfirst, **kwargs)</span>
    <span class="s0">except TypeError:</span>
        <span class="s0"># following may be raised from dateutil</span>
        <span class="s0"># TypeError: 'NoneType' object is not iterable</span>
        <span class="s0">raise ValueError('Given date string not likely a datetime.')</span>

    <span class="s0">return dt</span>


<span class="s0">def parse_time_string(arg: str, freq=None, dayfirst=None, yearfirst=None):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Try hard to parse datetime string, leveraging dateutil plus some extra</span>
    <span class="s0">goodies like quarter recognition.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arg : str</span>
    <span class="s0">freq : str or DateOffset, default None</span>
        <span class="s0">Helps with interpreting time string if supplied</span>
    <span class="s0">dayfirst : bool, default None</span>
        <span class="s0">If None uses default from print_config</span>
    <span class="s0">yearfirst : bool, default None</span>
        <span class="s0">If None uses default from print_config</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">datetime</span>
    <span class="s0">str</span>
        <span class="s0">Describing resolution of parsed string.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if is_offset_object(freq):</span>
        <span class="s0">freq = freq.rule_code</span>

    <span class="s0">if dayfirst is None or yearfirst is None:</span>
        <span class="s0">if dayfirst is None:</span>
            <span class="s0">dayfirst = get_option(&quot;display.date_dayfirst&quot;)</span>
        <span class="s0">if yearfirst is None:</span>
            <span class="s0">yearfirst = get_option(&quot;display.date_yearfirst&quot;)</span>

    <span class="s0">res = parse_datetime_string_with_reso(arg, freq=freq,</span>
                                          <span class="s0">dayfirst=dayfirst,</span>
                                          <span class="s0">yearfirst=yearfirst)</span>
    <span class="s0">return res</span>


<span class="s0">cdef parse_datetime_string_with_reso(</span>
    <span class="s0">str date_string, str freq=None, bint dayfirst=False, bint yearfirst=False,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parse datetime string and try to identify its resolution.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">datetime</span>
    <span class="s0">str</span>
        <span class="s0">Inferred resolution of the parsed string.</span>

    <span class="s0">Raises</span>
    <span class="s0">------</span>
    <span class="s0">ValueError : preliminary check suggests string is not datetime</span>
    <span class="s0">DateParseError : error within dateutil</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">object parsed, reso</span>

    <span class="s0">if not _does_string_look_like_datetime(date_string):</span>
        <span class="s0">raise ValueError('Given date string not likely a datetime.')</span>

    <span class="s0">parsed, reso = _parse_delimited_date(date_string, dayfirst)</span>
    <span class="s0">if parsed is not None:</span>
        <span class="s0">return parsed, reso</span>

    <span class="s0">try:</span>
        <span class="s0">return _parse_dateabbr_string(date_string, _DEFAULT_DATETIME, freq)</span>
    <span class="s0">except DateParseError:</span>
        <span class="s0">raise</span>
    <span class="s0">except ValueError:</span>
        <span class="s0">pass</span>

    <span class="s0">try:</span>
        <span class="s0">parsed, reso = dateutil_parse(date_string, _DEFAULT_DATETIME,</span>
                                      <span class="s0">dayfirst=dayfirst, yearfirst=yearfirst,</span>
                                      <span class="s0">ignoretz=False, tzinfos=None)</span>
    <span class="s0">except (ValueError, OverflowError) as err:</span>
        <span class="s0"># TODO: allow raise of errors within instead</span>
        <span class="s0">raise DateParseError(err)</span>
    <span class="s0">if parsed is None:</span>
        <span class="s0">raise DateParseError(f&quot;Could not parse {date_string}&quot;)</span>
    <span class="s0">return parsed, reso</span>


<span class="s0">cpdef bint _does_string_look_like_datetime(str py_string):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Checks whether given string is a datetime: it has to start with '0' or</span>
    <span class="s0">be greater than 1000.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">py_string: str</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
        <span class="s0">Whether given string is potentially a datetime.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">const char *buf</span>
        <span class="s0">char *endptr = NULL</span>
        <span class="s0">Py_ssize_t length = -1</span>
        <span class="s0">double converted_date</span>
        <span class="s0">char first</span>
        <span class="s0">int error = 0</span>

    <span class="s0">buf = get_c_string_buf_and_size(py_string, &amp;length)</span>
    <span class="s0">if length &gt;= 1:</span>
        <span class="s0">first = buf[0]</span>
        <span class="s0">if first == b'0':</span>
            <span class="s0"># Strings starting with 0 are more consistent with a</span>
            <span class="s0"># date-like string than a number</span>
            <span class="s0">return True</span>
        <span class="s0">elif py_string in _not_datelike_strings:</span>
            <span class="s0">return False</span>
        <span class="s0">else:</span>
            <span class="s0"># xstrtod with such parameters copies behavior of python `float`</span>
            <span class="s0"># cast; for example, &quot; 35.e-1 &quot; is valid string for this cast so,</span>
            <span class="s0"># for correctly xstrtod call necessary to pass these params:</span>
            <span class="s0"># b'.' - a dot is used as separator, b'e' - an exponential form of</span>
            <span class="s0"># a float number can be used, b'\0' - not to use a thousand</span>
            <span class="s0"># separator, 1 - skip extra spaces before and after,</span>
            <span class="s0">converted_date = xstrtod(buf, &amp;endptr,</span>
                                     <span class="s0">b'.', b'e', b'\0', 1, &amp;error, NULL)</span>
            <span class="s0"># if there were no errors and the whole line was parsed, then ...</span>
            <span class="s0">if error == 0 and endptr == buf + length:</span>
                <span class="s0">return converted_date &gt;= 1000</span>

    <span class="s0">return True</span>


<span class="s0">cdef inline object _parse_dateabbr_string(object date_string, datetime default,</span>
                                          <span class="s0">str freq=None):</span>
    <span class="s0">cdef:</span>
        <span class="s0">object ret</span>
        <span class="s0"># year initialized to prevent compiler warnings</span>
        <span class="s0">int year = -1, quarter = -1, month, mnum</span>
        <span class="s0">Py_ssize_t date_len</span>

    <span class="s0"># special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1</span>
    <span class="s0">assert isinstance(date_string, str)</span>

    <span class="s0">if date_string in nat_strings:</span>
        <span class="s0">return NaT, ''</span>

    <span class="s0">date_string = date_string.upper()</span>
    <span class="s0">date_len = len(date_string)</span>

    <span class="s0">if date_len == 4:</span>
        <span class="s0"># parse year only like 2000</span>
        <span class="s0">try:</span>
            <span class="s0">ret = default.replace(year=int(date_string))</span>
            <span class="s0">return ret, 'year'</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">pass</span>

    <span class="s0">try:</span>
        <span class="s0">if 4 &lt;= date_len &lt;= 7:</span>
            <span class="s0">i = date_string.index('Q', 1, 6)</span>
            <span class="s0">if i == 1:</span>
                <span class="s0">quarter = int(date_string[0])</span>
                <span class="s0">if date_len == 4 or (date_len == 5</span>
                                     <span class="s0">and date_string[i + 1] == '-'):</span>
                    <span class="s0"># r'(\d)Q-?(\d\d)')</span>
                    <span class="s0">year = 2000 + int(date_string[-2:])</span>
                <span class="s0">elif date_len == 6 or (date_len == 7</span>
                                       <span class="s0">and date_string[i + 1] == '-'):</span>
                    <span class="s0"># r'(\d)Q-?(\d\d\d\d)')</span>
                    <span class="s0">year = int(date_string[-4:])</span>
                <span class="s0">else:</span>
                    <span class="s0">raise ValueError</span>
            <span class="s0">elif i == 2 or i == 3:</span>
                <span class="s0"># r'(\d\d)-?Q(\d)'</span>
                <span class="s0">if date_len == 4 or (date_len == 5</span>
                                     <span class="s0">and date_string[i - 1] == '-'):</span>
                    <span class="s0">quarter = int(date_string[-1])</span>
                    <span class="s0">year = 2000 + int(date_string[:2])</span>
                <span class="s0">else:</span>
                    <span class="s0">raise ValueError</span>
            <span class="s0">elif i == 4 or i == 5:</span>
                <span class="s0">if date_len == 6 or (date_len == 7</span>
                                     <span class="s0">and date_string[i - 1] == '-'):</span>
                    <span class="s0"># r'(\d\d\d\d)-?Q(\d)'</span>
                    <span class="s0">quarter = int(date_string[-1])</span>
                    <span class="s0">year = int(date_string[:4])</span>
                <span class="s0">else:</span>
                    <span class="s0">raise ValueError</span>

            <span class="s0">if not (1 &lt;= quarter &lt;= 4):</span>
                <span class="s0">raise DateParseError(f'Incorrect quarterly string is given, '</span>
                                     <span class="s0">f'quarter must be '</span>
                                     <span class="s0">f'between 1 and 4: {date_string}')</span>

            <span class="s0">try:</span>
                <span class="s0"># GH#1228</span>
                <span class="s0">year, month = quarter_to_myear(year, quarter, freq)</span>
            <span class="s0">except KeyError:</span>
                <span class="s0">raise DateParseError(&quot;Unable to retrieve month &quot;</span>
                                     <span class="s0">&quot;information from given &quot;</span>
                                     <span class="s0">f&quot;freq: {freq}&quot;)</span>

            <span class="s0">ret = default.replace(year=year, month=month)</span>
            <span class="s0">return ret, 'quarter'</span>

    <span class="s0">except DateParseError:</span>
        <span class="s0">raise</span>
    <span class="s0">except ValueError:</span>
        <span class="s0">pass</span>

    <span class="s0">if date_len == 6 and freq == 'M':</span>
        <span class="s0">year = int(date_string[:4])</span>
        <span class="s0">month = int(date_string[4:6])</span>
        <span class="s0">try:</span>
            <span class="s0">ret = default.replace(year=year, month=month)</span>
            <span class="s0">return ret, 'month'</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">pass</span>

    <span class="s0">for pat in ['%Y-%m', '%b %Y', '%b-%Y']:</span>
        <span class="s0">try:</span>
            <span class="s0">ret = datetime.strptime(date_string, pat)</span>
            <span class="s0">return ret, 'month'</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">pass</span>

    <span class="s0">raise ValueError(f'Unable to parse {date_string}')</span>


<span class="s0">cpdef quarter_to_myear(int year, int quarter, str freq):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">A quarterly frequency defines a &quot;year&quot; which may not coincide with</span>
    <span class="s0">the calendar-year.  Find the calendar-year and calendar-month associated</span>
    <span class="s0">with the given year and quarter under the `freq`-derived calendar.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">year : int</span>
    <span class="s0">quarter : int</span>
    <span class="s0">freq : str or None</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">year : int</span>
    <span class="s0">month : int</span>

    <span class="s0">See Also</span>
    <span class="s0">--------</span>
    <span class="s0">Period.qyear</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if quarter &lt;= 0 or quarter &gt; 4:</span>
        <span class="s0">raise ValueError(&quot;Quarter must be 1 &lt;= q &lt;= 4&quot;)</span>

    <span class="s0">if freq is not None:</span>
        <span class="s0">mnum = c_MONTH_NUMBERS[get_rule_month(freq)] + 1</span>
        <span class="s0">month = (mnum + (quarter - 1) * 3) % 12 + 1</span>
        <span class="s0">if month &gt; mnum:</span>
            <span class="s0">year -= 1</span>
    <span class="s0">else:</span>
        <span class="s0">month = (quarter - 1) * 3 + 1</span>

    <span class="s0">return year, month</span>


<span class="s0">cdef dateutil_parse(</span>
    <span class="s0">str timestr,</span>
    <span class="s0">object default,</span>
    <span class="s0">bint ignoretz=False,</span>
    <span class="s0">object tzinfos=None,</span>
    <span class="s0">bint dayfirst=False,</span>
    <span class="s0">bint yearfirst=False,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot; lifted from dateutil to get resolution&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">object res, attr, ret, tzdata</span>
        <span class="s0">object reso = None</span>
        <span class="s0">dict repl = {}</span>

    <span class="s0">res, _ = DEFAULTPARSER._parse(timestr, dayfirst=dayfirst, yearfirst=yearfirst)</span>

    <span class="s0">if res is None:</span>
        <span class="s0">raise ValueError(f&quot;Unknown datetime string format, unable to parse: {timestr}&quot;)</span>

    <span class="s0">for attr in [&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;,</span>
                 <span class="s0">&quot;minute&quot;, &quot;second&quot;, &quot;microsecond&quot;]:</span>
        <span class="s0">value = getattr(res, attr)</span>
        <span class="s0">if value is not None:</span>
            <span class="s0">repl[attr] = value</span>
            <span class="s0">reso = attr</span>

    <span class="s0">if reso is None:</span>
        <span class="s0">raise ValueError(f&quot;Unable to parse datetime string: {timestr}&quot;)</span>

    <span class="s0">if reso == 'microsecond':</span>
        <span class="s0">if repl['microsecond'] == 0:</span>
            <span class="s0">reso = 'second'</span>
        <span class="s0">elif repl['microsecond'] % 1000 == 0:</span>
            <span class="s0">reso = 'millisecond'</span>

    <span class="s0">ret = default.replace(**repl)</span>
    <span class="s0">if res.weekday is not None and not res.day:</span>
        <span class="s0">ret = ret + relativedelta.relativedelta(weekday=res.weekday)</span>
    <span class="s0">if not ignoretz:</span>
        <span class="s0">if callable(tzinfos) or tzinfos and res.tzname in tzinfos:</span>
            <span class="s0"># Note: as of 1.0 this is not reached because</span>
            <span class="s0">#  we never pass tzinfos, see GH#22234</span>
            <span class="s0">if callable(tzinfos):</span>
                <span class="s0">tzdata = tzinfos(res.tzname, res.tzoffset)</span>
            <span class="s0">else:</span>
                <span class="s0">tzdata = tzinfos.get(res.tzname)</span>
            <span class="s0">if isinstance(tzdata, tzinfo):</span>
                <span class="s0">new_tzinfo = tzdata</span>
            <span class="s0">elif isinstance(tzdata, str):</span>
                <span class="s0">new_tzinfo = _dateutil_tzstr(tzdata)</span>
            <span class="s0">elif isinstance(tzdata, int):</span>
                <span class="s0">new_tzinfo = tzoffset(res.tzname, tzdata)</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(&quot;offset must be tzinfo subclass, &quot;</span>
                                 <span class="s0">&quot;tz string, or int offset&quot;)</span>
            <span class="s0">ret = ret.replace(tzinfo=new_tzinfo)</span>
        <span class="s0">elif res.tzname and res.tzname in time.tzname:</span>
            <span class="s0">ret = ret.replace(tzinfo=_dateutil_tzlocal())</span>
        <span class="s0">elif res.tzoffset == 0:</span>
            <span class="s0">ret = ret.replace(tzinfo=_dateutil_tzutc())</span>
        <span class="s0">elif res.tzoffset:</span>
            <span class="s0">ret = ret.replace(tzinfo=tzoffset(res.tzname, res.tzoffset))</span>
    <span class="s0">return ret, reso</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Parsing for type-inference</span>


<span class="s0">def try_parse_dates(</span>
    <span class="s0">object[:] values, parser=None, bint dayfirst=False, default=None,</span>
<span class="s0">) -&gt; np.ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">object[:] result</span>

    <span class="s0">n = len(values)</span>
    <span class="s0">result = np.empty(n, dtype='O')</span>

    <span class="s0">if parser is None:</span>
        <span class="s0">if default is None:  # GH2618</span>
            <span class="s0">date = datetime.now()</span>
            <span class="s0">default = datetime(date.year, date.month, 1)</span>

        <span class="s0">parse_date = lambda x: du_parse(x, dayfirst=dayfirst, default=default)</span>

        <span class="s0"># EAFP here</span>
        <span class="s0">try:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">if values[i] == '':</span>
                    <span class="s0">result[i] = np.nan</span>
                <span class="s0">else:</span>
                    <span class="s0">result[i] = parse_date(values[i])</span>
        <span class="s0">except Exception:</span>
            <span class="s0"># Since parser is user-defined, we can't guess what it might raise</span>
            <span class="s0">return values</span>
    <span class="s0">else:</span>
        <span class="s0">parse_date = parser</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0">if values[i] == '':</span>
                <span class="s0">result[i] = np.nan</span>
            <span class="s0">else:</span>
                <span class="s0">result[i] = parse_date(values[i])</span>

    <span class="s0">return result.base  # .base to access underlying ndarray</span>


<span class="s0">def try_parse_date_and_time(</span>
    <span class="s0">object[:] dates,</span>
    <span class="s0">object[:] times,</span>
    <span class="s0">date_parser=None,</span>
    <span class="s0">time_parser=None,</span>
    <span class="s0">bint dayfirst=False,</span>
    <span class="s0">default=None,</span>
<span class="s0">) -&gt; np.ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">object[:] result</span>

    <span class="s0">n = len(dates)</span>
    <span class="s0"># TODO(cython3): Use len instead of `shape[0]`</span>
    <span class="s0">if times.shape[0] != n:</span>
        <span class="s0">raise ValueError('Length of dates and times must be equal')</span>
    <span class="s0">result = np.empty(n, dtype='O')</span>

    <span class="s0">if date_parser is None:</span>
        <span class="s0">if default is None:  # GH2618</span>
            <span class="s0">date = datetime.now()</span>
            <span class="s0">default = datetime(date.year, date.month, 1)</span>

        <span class="s0">parse_date = lambda x: du_parse(x, dayfirst=dayfirst, default=default)</span>

    <span class="s0">else:</span>
        <span class="s0">parse_date = date_parser</span>

    <span class="s0">if time_parser is None:</span>
        <span class="s0">parse_time = lambda x: du_parse(x)</span>

    <span class="s0">else:</span>
        <span class="s0">parse_time = time_parser</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">d = parse_date(str(dates[i]))</span>
        <span class="s0">t = parse_time(str(times[i]))</span>
        <span class="s0">result[i] = datetime(d.year, d.month, d.day,</span>
                             <span class="s0">t.hour, t.minute, t.second)</span>

    <span class="s0">return result.base  # .base to access underlying ndarray</span>


<span class="s0">def try_parse_year_month_day(</span>
    <span class="s0">object[:] years, object[:] months, object[:] days</span>
<span class="s0">) -&gt; np.ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">object[:] result</span>

    <span class="s0">n = len(years)</span>
    <span class="s0"># TODO(cython3): Use len instead of `shape[0]`</span>
    <span class="s0">if months.shape[0] != n or days.shape[0] != n:</span>
        <span class="s0">raise ValueError('Length of years/months/days must all be equal')</span>
    <span class="s0">result = np.empty(n, dtype='O')</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">result[i] = datetime(int(years[i]), int(months[i]), int(days[i]))</span>

    <span class="s0">return result.base  # .base to access underlying ndarray</span>


<span class="s0">def try_parse_datetime_components(object[:] years,</span>
                                  <span class="s0">object[:] months,</span>
                                  <span class="s0">object[:] days,</span>
                                  <span class="s0">object[:] hours,</span>
                                  <span class="s0">object[:] minutes,</span>
                                  <span class="s0">object[:] seconds) -&gt; np.ndarray:</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">object[:] result</span>
        <span class="s0">int secs</span>
        <span class="s0">double float_secs</span>
        <span class="s0">double micros</span>

    <span class="s0">n = len(years)</span>
    <span class="s0"># TODO(cython3): Use len instead of `shape[0]`</span>
    <span class="s0">if (</span>
        <span class="s0">months.shape[0] != n</span>
        <span class="s0">or days.shape[0] != n</span>
        <span class="s0">or hours.shape[0] != n</span>
        <span class="s0">or minutes.shape[0] != n</span>
        <span class="s0">or seconds.shape[0] != n</span>
    <span class="s0">):</span>
        <span class="s0">raise ValueError('Length of all datetime components must be equal')</span>
    <span class="s0">result = np.empty(n, dtype='O')</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">float_secs = float(seconds[i])</span>
        <span class="s0">secs = int(float_secs)</span>

        <span class="s0">micros = float_secs - secs</span>
        <span class="s0">if micros &gt; 0:</span>
            <span class="s0">micros = micros * 1000000</span>

        <span class="s0">result[i] = datetime(int(years[i]), int(months[i]), int(days[i]),</span>
                             <span class="s0">int(hours[i]), int(minutes[i]), secs,</span>
                             <span class="s0">int(micros))</span>

    <span class="s0">return result.base  # .base to access underlying ndarray</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Miscellaneous</span>


<span class="s0"># Class copied verbatim from https://github.com/dateutil/dateutil/pull/732</span>
<span class="s0">#</span>
<span class="s0"># We use this class to parse and tokenize date strings. However, as it is</span>
<span class="s0"># a private class in the dateutil library, relying on backwards compatibility</span>
<span class="s0"># is not practical. In fact, using this class issues warnings (xref gh-21322).</span>
<span class="s0"># Thus, we port the class over so that both issues are resolved.</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2017 - dateutil contributors</span>
<span class="s0">class _timelex:</span>
    <span class="s0">def __init__(self, instream):</span>
        <span class="s0">if getattr(instream, 'decode', None) is not None:</span>
            <span class="s0">instream = instream.decode()</span>

        <span class="s0">if isinstance(instream, str):</span>
            <span class="s0">self.stream = instream</span>
        <span class="s0">elif getattr(instream, 'read', None) is None:</span>
            <span class="s0">raise TypeError(</span>
                <span class="s0">'Parser must be a string or character stream, not '</span>
                <span class="s0">f'{type(instream).__name__}')</span>
        <span class="s0">else:</span>
            <span class="s0">self.stream = instream.read()</span>

    <span class="s0">def get_tokens(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">This function breaks the time string into lexical units (tokens), which</span>
        <span class="s0">can be parsed by the parser. Lexical units are demarcated by changes in</span>
        <span class="s0">the character set, so any continuous string of letters is considered</span>
        <span class="s0">one unit, any continuous string of numbers is considered one unit.</span>
        <span class="s0">The main complication arises from the fact that dots ('.') can be used</span>
        <span class="s0">both as separators (e.g. &quot;Sep.20.2009&quot;) or decimal points (e.g.</span>
        <span class="s0">&quot;4:30:21.447&quot;). As such, it is necessary to read the full context of</span>
        <span class="s0">any dot-separated strings before breaking it into tokens; as such, this</span>
        <span class="s0">function maintains a &quot;token stack&quot;, for when the ambiguous context</span>
        <span class="s0">demands that multiple tokens be parsed at once.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t n</span>

        <span class="s0">stream = self.stream.replace('\x00', '')</span>

        <span class="s0"># TODO: Change \s --&gt; \s+ (this doesn't match existing behavior)</span>
        <span class="s0"># TODO: change the punctuation block to punc+ (does not match existing)</span>
        <span class="s0"># TODO: can we merge the two digit patterns?</span>
        <span class="s0">tokens = re.findall(r&quot;\s|&quot;</span>
                            <span class="s0">r&quot;(?&lt;![\.\d])\d+\.\d+(?![\.\d])&quot;</span>
                            <span class="s0">r&quot;|\d+&quot;</span>
                            <span class="s0">r&quot;|[a-zA-Z]+&quot;</span>
                            <span class="s0">r&quot;|[\./:]+&quot;</span>
                            <span class="s0">r&quot;|[^\da-zA-Z\./:\s]+&quot;, stream)</span>

        <span class="s0"># Re-combine token tuples of the form [&quot;59&quot;, &quot;,&quot;, &quot;456&quot;] because</span>
        <span class="s0"># in this context the &quot;,&quot; is treated as a decimal</span>
        <span class="s0"># (e.g. in python's default logging format)</span>
        <span class="s0">for n, token in enumerate(tokens[:-2]):</span>
            <span class="s0"># Kludge to match ,-decimal behavior; it'd be better to do this</span>
            <span class="s0"># later in the process and have a simpler tokenization</span>
            <span class="s0">if (token is not None and token.isdigit() and</span>
                    <span class="s0">tokens[n + 1] == ',' and tokens[n + 2].isdigit()):</span>
                <span class="s0"># Have to check None b/c it might be replaced during the loop</span>
                <span class="s0"># TODO: I _really_ don't faking the value here</span>
                <span class="s0">tokens[n] = token + '.' + tokens[n + 2]</span>
                <span class="s0">tokens[n + 1] = None</span>
                <span class="s0">tokens[n + 2] = None</span>

        <span class="s0">tokens = [x for x in tokens if x is not None]</span>
        <span class="s0">return tokens</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def split(cls, s):</span>
        <span class="s0">return cls(s).get_tokens()</span>


<span class="s0">_DATEUTIL_LEXER_SPLIT = _timelex.split</span>


<span class="s0">def format_is_iso(f: str) -&gt; bint:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Does format match the iso8601 set that can be handled by the C parser?</span>
    <span class="s0">Generally of form YYYY-MM-DDTHH:MM:SS - date separator can be different</span>
    <span class="s0">but must be consistent.  Leading 0s in dates and times are optional.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">iso_template = '%Y{date_sep}%m{date_sep}%d{time_sep}%H:%M:%S{micro_or_tz}'.format</span>
    <span class="s0">excluded_formats = ['%Y%m%d', '%Y%m', '%Y']</span>

    <span class="s0">for date_sep in [' ', '/', '\\', '-', '.', '']:</span>
        <span class="s0">for time_sep in [' ', 'T']:</span>
            <span class="s0">for micro_or_tz in ['', '%z', '%Z', '.%f', '.%f%z', '.%f%Z']:</span>
                <span class="s0">if (iso_template(date_sep=date_sep,</span>
                                 <span class="s0">time_sep=time_sep,</span>
                                 <span class="s0">micro_or_tz=micro_or_tz,</span>
                                 <span class="s0">).startswith(f) and f not in excluded_formats):</span>
                    <span class="s0">return True</span>
    <span class="s0">return False</span>


<span class="s0">def guess_datetime_format(</span>
    <span class="s0">dt_str,</span>
    <span class="s0">bint dayfirst=False,</span>
    <span class="s0">dt_str_parse=du_parse,</span>
    <span class="s0">dt_str_split=_DATEUTIL_LEXER_SPLIT,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Guess the datetime format of a given datetime string.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">dt_str : str</span>
        <span class="s0">Datetime string to guess the format of.</span>
    <span class="s0">dayfirst : bool, default False</span>
        <span class="s0">If True parses dates with the day first, eg 20/01/2005</span>
        <span class="s0">Warning: dayfirst=True is not strict, but will prefer to parse</span>
        <span class="s0">with day first (this is a known bug).</span>
    <span class="s0">dt_str_parse : function, defaults to `dateutil.parser.parse`</span>
        <span class="s0">This function should take in a datetime string and return</span>
        <span class="s0">a `datetime.datetime` guess that the datetime string represents</span>
    <span class="s0">dt_str_split : function, defaults to `_DATEUTIL_LEXER_SPLIT` (dateutil)</span>
        <span class="s0">This function should take in a datetime string and return</span>
        <span class="s0">a list of strings, the guess of the various specific parts</span>
        <span class="s0">e.g. '2011/12/30' -&gt; ['2011', '/', '12', '/', '30']</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ret : datetime format string (for `strftime` or `strptime`)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if dt_str_parse is None or dt_str_split is None:</span>
        <span class="s0">return None</span>

    <span class="s0">if not isinstance(dt_str, str):</span>
        <span class="s0">return None</span>

    <span class="s0">day_attribute_and_format = (('day',), '%d', 2)</span>

    <span class="s0"># attr name, format, padding (if any)</span>
    <span class="s0">datetime_attrs_to_format = [</span>
        <span class="s0">(('year', 'month', 'day'), '%Y%m%d', 0),</span>
        <span class="s0">(('year',), '%Y', 0),</span>
        <span class="s0">(('month',), '%B', 0),</span>
        <span class="s0">(('month',), '%b', 0),</span>
        <span class="s0">(('month',), '%m', 2),</span>
        <span class="s0">day_attribute_and_format,</span>
        <span class="s0">(('hour',), '%H', 2),</span>
        <span class="s0">(('minute',), '%M', 2),</span>
        <span class="s0">(('second',), '%S', 2),</span>
        <span class="s0">(('microsecond',), '%f', 6),</span>
        <span class="s0">(('second', 'microsecond'), '%S.%f', 0),</span>
        <span class="s0">(('tzinfo',), '%z', 0),</span>
        <span class="s0">(('tzinfo',), '%Z', 0),</span>
        <span class="s0">(('day_of_week',), '%a', 0),</span>
        <span class="s0">(('day_of_week',), '%A', 0),</span>
        <span class="s0">(('meridiem',), '%p', 0),</span>
    <span class="s0">]</span>

    <span class="s0">if dayfirst:</span>
        <span class="s0">datetime_attrs_to_format.remove(day_attribute_and_format)</span>
        <span class="s0">datetime_attrs_to_format.insert(0, day_attribute_and_format)</span>

    <span class="s0">try:</span>
        <span class="s0">parsed_datetime = dt_str_parse(dt_str, dayfirst=dayfirst)</span>
    <span class="s0">except (ValueError, OverflowError):</span>
        <span class="s0"># In case the datetime can't be parsed, its format cannot be guessed</span>
        <span class="s0">return None</span>

    <span class="s0">if parsed_datetime is None:</span>
        <span class="s0">return None</span>

    <span class="s0"># the default dt_str_split from dateutil will never raise here; we assume</span>
    <span class="s0">#  that any user-provided function will not either.</span>
    <span class="s0">tokens = dt_str_split(dt_str)</span>

    <span class="s0"># Normalize offset part of tokens.</span>
    <span class="s0"># There are multiple formats for the timezone offset.</span>
    <span class="s0"># To pass the comparison condition between the output of `strftime` and</span>
    <span class="s0"># joined tokens, which is carried out at the final step of the function,</span>
    <span class="s0"># the offset part of the tokens must match the '%z' format like '+0900'</span>
    <span class="s0"># instead of ‘+09:00’.</span>
    <span class="s0">if parsed_datetime.tzinfo is not None:</span>
        <span class="s0">offset_index = None</span>
        <span class="s0">if len(tokens) &gt; 0 and tokens[-1] == 'Z':</span>
            <span class="s0"># the last 'Z' means zero offset</span>
            <span class="s0">offset_index = -1</span>
        <span class="s0">elif len(tokens) &gt; 1 and tokens[-2] in ('+', '-'):</span>
            <span class="s0"># ex. [..., '+', '0900']</span>
            <span class="s0">offset_index = -2</span>
        <span class="s0">elif len(tokens) &gt; 3 and tokens[-4] in ('+', '-'):</span>
            <span class="s0"># ex. [..., '+', '09', ':', '00']</span>
            <span class="s0">offset_index = -4</span>

        <span class="s0">if offset_index is not None:</span>
            <span class="s0"># If the input string has a timezone offset like '+0900',</span>
            <span class="s0"># the offset is separated into two tokens, ex. ['+', '0900’].</span>
            <span class="s0"># This separation will prevent subsequent processing</span>
            <span class="s0"># from correctly parsing the time zone format.</span>
            <span class="s0"># So in addition to the format nomalization, we rejoin them here.</span>
            <span class="s0">tokens[offset_index] = parsed_datetime.strftime(&quot;%z&quot;)</span>
            <span class="s0">tokens = tokens[:offset_index + 1 or None]</span>

    <span class="s0">format_guess = [None] * len(tokens)</span>
    <span class="s0">found_attrs = set()</span>

    <span class="s0">for attrs, attr_format, padding in datetime_attrs_to_format:</span>
        <span class="s0"># If a given attribute has been placed in the format string, skip</span>
        <span class="s0"># over other formats for that same underlying attribute (IE, month</span>
        <span class="s0"># can be represented in multiple different ways)</span>
        <span class="s0">if set(attrs) &amp; found_attrs:</span>
            <span class="s0">continue</span>

        <span class="s0">if parsed_datetime.tzinfo is None and attr_format in (&quot;%Z&quot;, &quot;%z&quot;):</span>
            <span class="s0">continue</span>

        <span class="s0">parsed_formatted = parsed_datetime.strftime(attr_format)</span>
        <span class="s0">for i, token_format in enumerate(format_guess):</span>
            <span class="s0">token_filled = tokens[i].zfill(padding)</span>
            <span class="s0">if token_format is None and token_filled == parsed_formatted:</span>
                <span class="s0">format_guess[i] = attr_format</span>
                <span class="s0">tokens[i] = token_filled</span>
                <span class="s0">found_attrs.update(attrs)</span>
                <span class="s0">break</span>

    <span class="s0"># Only consider it a valid guess if we have a year, month and day</span>
    <span class="s0">if len({'year', 'month', 'day'} &amp; found_attrs) != 3:</span>
        <span class="s0">return None</span>

    <span class="s0">output_format = []</span>
    <span class="s0">for i, guess in enumerate(format_guess):</span>
        <span class="s0">if guess is not None:</span>
            <span class="s0"># Either fill in the format placeholder (like %Y)</span>
            <span class="s0">output_format.append(guess)</span>
        <span class="s0">else:</span>
            <span class="s0"># Or just the token separate (IE, the dashes in &quot;01-01-2013&quot;)</span>
            <span class="s0">try:</span>
                <span class="s0"># If the token is numeric, then we likely didn't parse it</span>
                <span class="s0"># properly, so our guess is wrong</span>
                <span class="s0">float(tokens[i])</span>
                <span class="s0">return None</span>
            <span class="s0">except ValueError:</span>
                <span class="s0">pass</span>

            <span class="s0">output_format.append(tokens[i])</span>

    <span class="s0">guessed_format = ''.join(output_format)</span>

    <span class="s0"># rebuild string, capturing any inferred padding</span>
    <span class="s0">dt_str = ''.join(tokens)</span>
    <span class="s0">if parsed_datetime.strftime(guessed_format) == dt_str:</span>
        <span class="s0">return guessed_format</span>
    <span class="s0">else:</span>
        <span class="s0">return None</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef inline object convert_to_unicode(object item, bint keep_trivial_numbers):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert `item` to str.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">item : object</span>
    <span class="s0">keep_trivial_numbers : bool</span>
        <span class="s0">if True, then conversion (to string from integer/float zero)</span>
        <span class="s0">is not performed</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">str or int or float</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">float64_t float_item</span>

    <span class="s0">if keep_trivial_numbers:</span>
        <span class="s0">if isinstance(item, int):</span>
            <span class="s0">if &lt;int&gt;item == 0:</span>
                <span class="s0">return item</span>
        <span class="s0">elif isinstance(item, float):</span>
            <span class="s0">float_item = item</span>
            <span class="s0">if float_item == 0.0 or float_item != float_item:</span>
                <span class="s0">return item</span>

    <span class="s0">if not isinstance(item, str):</span>
        <span class="s0">item = PyObject_Str(item)</span>

    <span class="s0">return item</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def concat_date_cols(tuple date_cols, bint keep_trivial_numbers=True) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Concatenates elements from numpy arrays in `date_cols` into strings.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">date_cols : tuple[ndarray]</span>
    <span class="s0">keep_trivial_numbers : bool, default True</span>
        <span class="s0">if True and len(date_cols) == 1, then</span>
        <span class="s0">conversion (to string from integer/float zero) is not performed</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">arr_of_rows : ndarray[object]</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; dates=np.array(['3/31/2019', '4/31/2019'], dtype=object)</span>
    <span class="s0">&gt;&gt;&gt; times=np.array(['11:20', '10:45'], dtype=object)</span>
    <span class="s0">&gt;&gt;&gt; result = concat_date_cols((dates, times))</span>
    <span class="s0">&gt;&gt;&gt; result</span>
    <span class="s0">array(['3/31/2019 11:20', '4/31/2019 10:45'], dtype=object)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t rows_count = 0, col_count = len(date_cols)</span>
        <span class="s0">Py_ssize_t col_idx, row_idx</span>
        <span class="s0">list list_to_join</span>
        <span class="s0">cnp.ndarray[object] iters</span>
        <span class="s0">object[::1] iters_view</span>
        <span class="s0">flatiter it</span>
        <span class="s0">cnp.ndarray[object] result</span>
        <span class="s0">object[:] result_view</span>

    <span class="s0">if col_count == 0:</span>
        <span class="s0">return np.zeros(0, dtype=object)</span>

    <span class="s0">if not all(is_array(array) for array in date_cols):</span>
        <span class="s0">raise ValueError(&quot;not all elements from date_cols are numpy arrays&quot;)</span>

    <span class="s0">rows_count = min(len(array) for array in date_cols)</span>
    <span class="s0">result = np.zeros(rows_count, dtype=object)</span>
    <span class="s0">result_view = result</span>

    <span class="s0">if col_count == 1:</span>
        <span class="s0">array = date_cols[0]</span>
        <span class="s0">it = &lt;flatiter&gt;PyArray_IterNew(array)</span>
        <span class="s0">for row_idx in range(rows_count):</span>
            <span class="s0">item = PyArray_GETITEM(array, PyArray_ITER_DATA(it))</span>
            <span class="s0">result_view[row_idx] = convert_to_unicode(item,</span>
                                                      <span class="s0">keep_trivial_numbers)</span>
            <span class="s0">PyArray_ITER_NEXT(it)</span>
    <span class="s0">else:</span>
        <span class="s0"># create fixed size list - more efficient memory allocation</span>
        <span class="s0">list_to_join = [None] * col_count</span>
        <span class="s0">iters = np.zeros(col_count, dtype=object)</span>

        <span class="s0"># create memoryview of iters ndarray, that will contain some</span>
        <span class="s0"># flatiter's for each array in `date_cols` - more efficient indexing</span>
        <span class="s0">iters_view = iters</span>
        <span class="s0">for col_idx, array in enumerate(date_cols):</span>
            <span class="s0">iters_view[col_idx] = PyArray_IterNew(array)</span>

        <span class="s0"># array elements that are on the same line are converted to one string</span>
        <span class="s0">for row_idx in range(rows_count):</span>
            <span class="s0">for col_idx, array in enumerate(date_cols):</span>
                <span class="s0"># this cast is needed, because we did not find a way</span>
                <span class="s0"># to efficiently store `flatiter` type objects in ndarray</span>
                <span class="s0">it = &lt;flatiter&gt;iters_view[col_idx]</span>
                <span class="s0">item = PyArray_GETITEM(array, PyArray_ITER_DATA(it))</span>
                <span class="s0">list_to_join[col_idx] = convert_to_unicode(item, False)</span>
                <span class="s0">PyArray_ITER_NEXT(it)</span>
            <span class="s0">result_view[row_idx] = &quot; &quot;.join(list_to_join)</span>

    <span class="s0">return result</span>


<span class="s0">cpdef str get_rule_month(str source):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return starting month of given freq, default is December.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">source : str</span>
        <span class="s0">Derived from `freq.rule_code` or `freq.freqstr`.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">rule_month: str</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; get_rule_month('D')</span>
    <span class="s0">'DEC'</span>

    <span class="s0">&gt;&gt;&gt; get_rule_month('A-JAN')</span>
    <span class="s0">'JAN'</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">source = source.upper()</span>
    <span class="s0">if &quot;-&quot; not in source:</span>
        <span class="s0">return &quot;DEC&quot;</span>
    <span class="s0">else:</span>
        <span class="s0">return source.split(&quot;-&quot;)[1]</span>
</pre>
</body>
</html>