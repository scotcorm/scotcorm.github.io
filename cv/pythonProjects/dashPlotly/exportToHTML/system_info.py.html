<html>
<head>
<title>system_info.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
system_info.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
This file defines a set of system_info classes for getting 
information about various resources (libraries, library directories, 
include directories, etc.) in the system. Usage: 
    info_dict = get_info(&lt;name&gt;) 
  where &lt;name&gt; is a string 'atlas','x11','fftw','lapack','blas', 
  'lapack_src', 'blas_src', etc. For a complete list of allowed names, 
  see the definition of get_info() function below. 
 
  Returned info_dict is a dictionary which is compatible with 
  distutils.setup keyword arguments. If info_dict == {}, then the 
  asked resource is not available (system_info could not find it). 
 
  Several *_info classes specify an environment variable to specify 
  the locations of software. When setting the corresponding environment 
  variable to 'None' then the software will be ignored, even when it 
  is available in system. 
 
Global parameters: 
  system_info.search_static_first - search static libraries (.a) 
             in precedence to shared ones (.so, .sl) if enabled. 
  system_info.verbosity - output the results to stdout if enabled. 
 
The file 'site.cfg' is looked for in 
 
1) Directory of main setup.py file being run. 
2) Home directory of user running the setup.py file as ~/.numpy-site.cfg 
3) System wide directory (location of this file...) 
 
The first one found is used to get system configuration options The 
format is that used by ConfigParser (i.e., Windows .INI style). The 
section ALL is not intended for general use. 
 
Appropriate defaults are used if nothing is specified. 
 
The order of finding the locations of resources is the following: 
 1. environment variable 
 2. section in site.cfg 
 3. DEFAULT section in site.cfg 
 4. System default search paths (see ``default_*`` variables below). 
Only the first complete match is returned. 
 
Currently, the following classes are available, along with their section names: 
 
    Numeric_info:Numeric 
    _numpy_info:Numeric 
    _pkg_config_info:None 
    accelerate_info:accelerate 
    agg2_info:agg2 
    amd_info:amd 
    atlas_3_10_blas_info:atlas 
    atlas_3_10_blas_threads_info:atlas 
    atlas_3_10_info:atlas 
    atlas_3_10_threads_info:atlas 
    atlas_blas_info:atlas 
    atlas_blas_threads_info:atlas 
    atlas_info:atlas 
    atlas_threads_info:atlas 
    blas64__opt_info:ALL               # usage recommended (general ILP64 BLAS, 64_ symbol suffix) 
    blas_ilp64_opt_info:ALL            # usage recommended (general ILP64 BLAS) 
    blas_ilp64_plain_opt_info:ALL      # usage recommended (general ILP64 BLAS, no symbol suffix) 
    blas_info:blas 
    blas_mkl_info:mkl 
    blas_opt_info:ALL                  # usage recommended 
    blas_src_info:blas_src 
    blis_info:blis 
    boost_python_info:boost_python 
    dfftw_info:fftw 
    dfftw_threads_info:fftw 
    djbfft_info:djbfft 
    f2py_info:ALL 
    fft_opt_info:ALL 
    fftw2_info:fftw 
    fftw3_info:fftw3 
    fftw_info:fftw 
    fftw_threads_info:fftw 
    flame_info:flame 
    freetype2_info:freetype2 
    gdk_2_info:gdk_2 
    gdk_info:gdk 
    gdk_pixbuf_2_info:gdk_pixbuf_2 
    gdk_pixbuf_xlib_2_info:gdk_pixbuf_xlib_2 
    gdk_x11_2_info:gdk_x11_2 
    gtkp_2_info:gtkp_2 
    gtkp_x11_2_info:gtkp_x11_2 
    lapack64__opt_info:ALL             # usage recommended (general ILP64 LAPACK, 64_ symbol suffix) 
    lapack_atlas_3_10_info:atlas 
    lapack_atlas_3_10_threads_info:atlas 
    lapack_atlas_info:atlas 
    lapack_atlas_threads_info:atlas 
    lapack_ilp64_opt_info:ALL          # usage recommended (general ILP64 LAPACK) 
    lapack_ilp64_plain_opt_info:ALL    # usage recommended (general ILP64 LAPACK, no symbol suffix) 
    lapack_info:lapack 
    lapack_mkl_info:mkl 
    lapack_opt_info:ALL                # usage recommended 
    lapack_src_info:lapack_src 
    mkl_info:mkl 
    numarray_info:numarray 
    numerix_info:numerix 
    numpy_info:numpy 
    openblas64__info:openblas64_ 
    openblas64__lapack_info:openblas64_ 
    openblas_clapack_info:openblas 
    openblas_ilp64_info:openblas_ilp64 
    openblas_ilp64_lapack_info:openblas_ilp64 
    openblas_info:openblas 
    openblas_lapack_info:openblas 
    sfftw_info:fftw 
    sfftw_threads_info:fftw 
    system_info:ALL 
    umfpack_info:umfpack 
    wx_info:wx 
    x11_info:x11 
    xft_info:xft 
 
Note that blas_opt_info and lapack_opt_info honor the NPY_BLAS_ORDER 
and NPY_LAPACK_ORDER environment variables to determine the order in which 
specific BLAS and LAPACK libraries are searched for. 
 
This search (or autodetection) can be bypassed by defining the environment 
variables NPY_BLAS_LIBS and NPY_LAPACK_LIBS, which should then contain the 
exact linker flags to use (language will be set to F77). Building against 
Netlib BLAS/LAPACK or stub files, in order to be able to switch BLAS and LAPACK 
implementations at runtime. If using this to build NumPy itself, it is 
recommended to also define NPY_CBLAS_LIBS (assuming your BLAS library has a 
CBLAS interface) to enable CBLAS usage for matrix multiplication (unoptimized 
otherwise). 
 
Example: 
---------- 
[DEFAULT] 
# default section 
library_dirs = /usr/lib:/usr/local/lib:/opt/lib 
include_dirs = /usr/include:/usr/local/include:/opt/include 
src_dirs = /usr/local/src:/opt/src 
# search static libraries (.a) in preference to shared ones (.so) 
search_static_first = 0 
 
[fftw] 
libraries = rfftw, fftw 
 
[atlas] 
library_dirs = /usr/lib/3dnow:/usr/lib/3dnow/atlas 
# for overriding the names of the atlas libraries 
libraries = lapack, f77blas, cblas, atlas 
 
[x11] 
library_dirs = /usr/X11R6/lib 
include_dirs = /usr/X11R6/include 
---------- 
 
Note that the ``libraries`` key is the default setting for libraries. 
 
Authors: 
  Pearu Peterson &lt;pearu@cens.ioc.ee&gt;, February 2002 
  David M. Cooke &lt;cookedm@physics.mcmaster.ca&gt;, April 2002 
 
Copyright 2002 Pearu Peterson all rights reserved, 
Pearu Peterson &lt;pearu@cens.ioc.ee&gt; 
Permission to use, modify, and distribute this software is given under the 
terms of the NumPy (BSD style) license.  See LICENSE.txt that came with 
this distribution for specifics. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">subprocess</span>
<span class="s3">import </span><span class="s1">textwrap</span>

<span class="s3">from </span><span class="s1">glob </span><span class="s3">import </span><span class="s1">glob</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">reduce</span>
<span class="s3">from </span><span class="s1">configparser </span><span class="s3">import </span><span class="s1">NoOptionError</span>
<span class="s3">from </span><span class="s1">configparser </span><span class="s3">import </span><span class="s1">RawConfigParser </span><span class="s3">as </span><span class="s1">ConfigParser</span>
<span class="s0"># It seems that some people are importing ConfigParser from here so is</span>
<span class="s0"># good to keep its class name. Use of RawConfigParser is needed in</span>
<span class="s0"># order to be able to load path names with percent in them, like</span>
<span class="s0"># `feature%2Fcool` which is common on git flow branch names.</span>

<span class="s3">from </span><span class="s1">distutils.errors </span><span class="s3">import </span><span class="s1">DistutilsError</span>
<span class="s3">from </span><span class="s1">distutils.dist </span><span class="s3">import </span><span class="s1">Distribution</span>
<span class="s3">import </span><span class="s1">sysconfig</span>
<span class="s3">from </span><span class="s1">numpy.distutils </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s1">distutils.util </span><span class="s3">import </span><span class="s1">get_platform</span>

<span class="s3">from </span><span class="s1">numpy.distutils.exec_command </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">find_executable</span><span class="s3">, </span><span class="s1">filepath_from_subprocess_output</span><span class="s3">,</span>
    <span class="s1">)</span>
<span class="s3">from </span><span class="s1">numpy.distutils.misc_util </span><span class="s3">import </span><span class="s1">(is_sequence</span><span class="s3">, </span><span class="s1">is_string</span><span class="s3">,</span>
                                       <span class="s1">get_shared_lib_extension)</span>
<span class="s3">from </span><span class="s1">numpy.distutils.command.config </span><span class="s3">import </span><span class="s1">config </span><span class="s3">as </span><span class="s1">cmd_config</span>
<span class="s3">from </span><span class="s1">numpy.distutils </span><span class="s3">import </span><span class="s1">customized_ccompiler </span><span class="s3">as </span><span class="s1">_customized_ccompiler</span>
<span class="s3">from </span><span class="s1">numpy.distutils </span><span class="s3">import </span><span class="s1">_shell_utils</span>
<span class="s3">import </span><span class="s1">distutils.ccompiler</span>
<span class="s3">import </span><span class="s1">tempfile</span>
<span class="s3">import </span><span class="s1">shutil</span>

<span class="s1">__all__ = [</span><span class="s4">'system_info'</span><span class="s1">]</span>

<span class="s0"># Determine number of bits</span>
<span class="s3">import </span><span class="s1">platform</span>
<span class="s1">_bits = {</span><span class="s4">'32bit'</span><span class="s1">: </span><span class="s5">32</span><span class="s3">, </span><span class="s4">'64bit'</span><span class="s1">: </span><span class="s5">64</span><span class="s1">}</span>
<span class="s1">platform_bits = _bits[platform.architecture()[</span><span class="s5">0</span><span class="s1">]]</span>


<span class="s1">global_compiler = </span><span class="s3">None</span>

<span class="s3">def </span><span class="s1">customized_ccompiler():</span>
    <span class="s3">global </span><span class="s1">global_compiler</span>
    <span class="s3">if not </span><span class="s1">global_compiler:</span>
        <span class="s1">global_compiler = _customized_ccompiler()</span>
    <span class="s3">return </span><span class="s1">global_compiler</span>


<span class="s3">def </span><span class="s1">_c_string_literal(s):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a python string into a literal suitable for inclusion into C code 
    &quot;&quot;&quot;</span>
    <span class="s0"># only these three characters are forbidden in C strings</span>
    <span class="s1">s = s.replace(</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s3">, </span><span class="s4">r'\\'</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s4">'&quot;'</span><span class="s3">,  </span><span class="s4">r'\&quot;'</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">r'\n'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s4">'&quot;{}&quot;'</span><span class="s1">.format(s)</span>


<span class="s3">def </span><span class="s1">libpaths(paths</span><span class="s3">, </span><span class="s1">bits):</span>
    <span class="s2">&quot;&quot;&quot;Return a list of library paths valid on 32 or 64 bit systems. 
 
    Inputs: 
      paths : sequence 
        A sequence of strings (typically paths) 
      bits : int 
        An integer, the only valid values are 32 or 64.  A ValueError exception 
      is raised otherwise. 
 
    Examples: 
 
    Consider a list of directories 
    &gt;&gt;&gt; paths = ['/usr/X11R6/lib','/usr/X11/lib','/usr/lib'] 
 
    For a 32-bit platform, this is already valid: 
    &gt;&gt;&gt; np.distutils.system_info.libpaths(paths,32) 
    ['/usr/X11R6/lib', '/usr/X11/lib', '/usr/lib'] 
 
    On 64 bits, we prepend the '64' postfix 
    &gt;&gt;&gt; np.distutils.system_info.libpaths(paths,64) 
    ['/usr/X11R6/lib64', '/usr/X11R6/lib', '/usr/X11/lib64', '/usr/X11/lib', 
    '/usr/lib64', '/usr/lib'] 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">bits </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">32</span><span class="s3">, </span><span class="s5">64</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid bit size in libpaths: 32 or 64 only&quot;</span><span class="s1">)</span>

    <span class="s0"># Handle 32bit case</span>
    <span class="s3">if </span><span class="s1">bits == </span><span class="s5">32</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">paths</span>

    <span class="s0"># Handle 64bit case</span>
    <span class="s1">out = []</span>
    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">paths:</span>
        <span class="s1">out.extend([p + </span><span class="s4">'64'</span><span class="s3">, </span><span class="s1">p])</span>

    <span class="s3">return </span><span class="s1">out</span>


<span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
    <span class="s1">default_lib_dirs = [</span><span class="s4">'C:</span><span class="s3">\\</span><span class="s4">'</span><span class="s3">,</span>
                        <span class="s1">os.path.join(sysconfig.get_config_var(</span><span class="s4">'exec_prefix'</span><span class="s1">)</span><span class="s3">,</span>
                                     <span class="s4">'libs'</span><span class="s1">)]</span>
    <span class="s1">default_runtime_dirs = []</span>
    <span class="s1">default_include_dirs = []</span>
    <span class="s1">default_src_dirs = [</span><span class="s4">'.'</span><span class="s1">]</span>
    <span class="s1">default_x11_lib_dirs = []</span>
    <span class="s1">default_x11_include_dirs = []</span>
    <span class="s1">_include_dirs = [</span>
        <span class="s4">'include'</span><span class="s3">,</span>
        <span class="s4">'include/suitesparse'</span><span class="s3">,</span>
    <span class="s1">]</span>
    <span class="s1">_lib_dirs = [</span>
        <span class="s4">'lib'</span><span class="s3">,</span>
    <span class="s1">]</span>

    <span class="s1">_include_dirs = [d.replace(</span><span class="s4">'/'</span><span class="s3">, </span><span class="s1">os.sep) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">_include_dirs]</span>
    <span class="s1">_lib_dirs = [d.replace(</span><span class="s4">'/'</span><span class="s3">, </span><span class="s1">os.sep) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">_lib_dirs]</span>
    <span class="s3">def </span><span class="s1">add_system_root(library_root):</span>
        <span class="s2">&quot;&quot;&quot;Add a package manager root to the include directories&quot;&quot;&quot;</span>
        <span class="s3">global </span><span class="s1">default_lib_dirs</span>
        <span class="s3">global </span><span class="s1">default_include_dirs</span>

        <span class="s1">library_root = os.path.normpath(library_root)</span>

        <span class="s1">default_lib_dirs.extend(</span>
            <span class="s1">os.path.join(library_root</span><span class="s3">, </span><span class="s1">d) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">_lib_dirs)</span>
        <span class="s1">default_include_dirs.extend(</span>
            <span class="s1">os.path.join(library_root</span><span class="s3">, </span><span class="s1">d) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">_include_dirs)</span>

    <span class="s0"># VCpkg is the de-facto package manager on windows for C/C++</span>
    <span class="s0"># libraries. If it is on the PATH, then we append its paths here.</span>
    <span class="s1">vcpkg = shutil.which(</span><span class="s4">'vcpkg'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">vcpkg:</span>
        <span class="s1">vcpkg_dir = os.path.dirname(vcpkg)</span>
        <span class="s3">if </span><span class="s1">platform.architecture()[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'32bit'</span><span class="s1">:</span>
            <span class="s1">specifier = </span><span class="s4">'x86'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">specifier = </span><span class="s4">'x64'</span>

        <span class="s1">vcpkg_installed = os.path.join(vcpkg_dir</span><span class="s3">, </span><span class="s4">'installed'</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">vcpkg_root </span><span class="s3">in </span><span class="s1">[</span>
            <span class="s1">os.path.join(vcpkg_installed</span><span class="s3">, </span><span class="s1">specifier + </span><span class="s4">'-windows'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">os.path.join(vcpkg_installed</span><span class="s3">, </span><span class="s1">specifier + </span><span class="s4">'-windows-static'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]:</span>
            <span class="s1">add_system_root(vcpkg_root)</span>

    <span class="s0"># Conda is another popular package manager that provides libraries</span>
    <span class="s1">conda = shutil.which(</span><span class="s4">'conda'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">conda:</span>
        <span class="s1">conda_dir = os.path.dirname(conda)</span>
        <span class="s1">add_system_root(os.path.join(conda_dir</span><span class="s3">, </span><span class="s4">'..'</span><span class="s3">, </span><span class="s4">'Library'</span><span class="s1">))</span>
        <span class="s1">add_system_root(os.path.join(conda_dir</span><span class="s3">, </span><span class="s4">'Library'</span><span class="s1">))</span>

<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">default_lib_dirs = libpaths([</span><span class="s4">'/usr/local/lib'</span><span class="s3">, </span><span class="s4">'/opt/lib'</span><span class="s3">, </span><span class="s4">'/usr/lib'</span><span class="s3">,</span>
                                 <span class="s4">'/opt/local/lib'</span><span class="s3">, </span><span class="s4">'/sw/lib'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">platform_bits)</span>
    <span class="s1">default_runtime_dirs = []</span>
    <span class="s1">default_include_dirs = [</span><span class="s4">'/usr/local/include'</span><span class="s3">,</span>
                            <span class="s4">'/opt/include'</span><span class="s3">,</span>
                            <span class="s0"># path of umfpack under macports</span>
                            <span class="s4">'/opt/local/include/ufsparse'</span><span class="s3">,</span>
                            <span class="s4">'/opt/local/include'</span><span class="s3">, </span><span class="s4">'/sw/include'</span><span class="s3">,</span>
                            <span class="s4">'/usr/include/suitesparse'</span><span class="s1">]</span>
    <span class="s1">default_src_dirs = [</span><span class="s4">'.'</span><span class="s3">, </span><span class="s4">'/usr/local/src'</span><span class="s3">, </span><span class="s4">'/opt/src'</span><span class="s3">, </span><span class="s4">'/sw/src'</span><span class="s1">]</span>

    <span class="s1">default_x11_lib_dirs = libpaths([</span><span class="s4">'/usr/X11R6/lib'</span><span class="s3">, </span><span class="s4">'/usr/X11/lib'</span><span class="s3">,</span>
                                     <span class="s4">'/usr/lib'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">platform_bits)</span>
    <span class="s1">default_x11_include_dirs = [</span><span class="s4">'/usr/X11R6/include'</span><span class="s3">, </span><span class="s4">'/usr/X11/include'</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">os.path.exists(</span><span class="s4">'/usr/lib/X11'</span><span class="s1">):</span>
        <span class="s1">globbed_x11_dir = glob(</span><span class="s4">'/usr/lib/*/libX11.so'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">globbed_x11_dir:</span>
            <span class="s1">x11_so_dir = os.path.split(globbed_x11_dir[</span><span class="s5">0</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">default_x11_lib_dirs.extend([x11_so_dir</span><span class="s3">, </span><span class="s4">'/usr/lib/X11'</span><span class="s1">])</span>
            <span class="s1">default_x11_include_dirs.extend([</span><span class="s4">'/usr/lib/X11/include'</span><span class="s3">,</span>
                                             <span class="s4">'/usr/include/X11'</span><span class="s1">])</span>

    <span class="s3">with </span><span class="s1">open(os.devnull</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">tmp:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">p = subprocess.Popen([</span><span class="s4">&quot;gcc&quot;</span><span class="s3">, </span><span class="s4">&quot;-print-multiarch&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">stdout=subprocess.PIPE</span><span class="s3">,</span>
                         <span class="s1">stderr=tmp)</span>
        <span class="s3">except </span><span class="s1">(OSError</span><span class="s3">, </span><span class="s1">DistutilsError):</span>
            <span class="s0"># OSError if gcc is not installed, or SandboxViolation (DistutilsError</span>
            <span class="s0"># subclass) if an old setuptools bug is triggered (see gh-3160).</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">triplet = str(p.communicate()[</span><span class="s5">0</span><span class="s1">].decode().strip())</span>
            <span class="s3">if </span><span class="s1">p.returncode == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0"># gcc supports the &quot;-print-multiarch&quot; option</span>
                <span class="s1">default_x11_lib_dirs += [os.path.join(</span><span class="s4">&quot;/usr/lib/&quot;</span><span class="s3">, </span><span class="s1">triplet)]</span>
                <span class="s1">default_lib_dirs += [os.path.join(</span><span class="s4">&quot;/usr/lib/&quot;</span><span class="s3">, </span><span class="s1">triplet)]</span>


<span class="s3">if </span><span class="s1">os.path.join(sys.prefix</span><span class="s3">, </span><span class="s4">'lib'</span><span class="s1">) </span><span class="s3">not in </span><span class="s1">default_lib_dirs:</span>
    <span class="s1">default_lib_dirs.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">os.path.join(sys.prefix</span><span class="s3">, </span><span class="s4">'lib'</span><span class="s1">))</span>
    <span class="s1">default_include_dirs.append(os.path.join(sys.prefix</span><span class="s3">, </span><span class="s4">'include'</span><span class="s1">))</span>
    <span class="s1">default_src_dirs.append(os.path.join(sys.prefix</span><span class="s3">, </span><span class="s4">'src'</span><span class="s1">))</span>

<span class="s1">default_lib_dirs = [_m </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">default_lib_dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(_m)]</span>
<span class="s1">default_runtime_dirs = [_m </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">default_runtime_dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(_m)]</span>
<span class="s1">default_include_dirs = [_m </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">default_include_dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(_m)]</span>
<span class="s1">default_src_dirs = [_m </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">default_src_dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(_m)]</span>

<span class="s1">so_ext = get_shared_lib_extension()</span>


<span class="s3">def </span><span class="s1">get_standard_file(fname):</span>
    <span class="s2">&quot;&quot;&quot;Returns a list of files named 'fname' from 
    1) System-wide directory (directory-location of this module) 
    2) Users HOME directory (os.environ['HOME']) 
    3) Local directory 
    &quot;&quot;&quot;</span>
    <span class="s0"># System-wide file</span>
    <span class="s1">filenames = []</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">f = __file__</span>
    <span class="s3">except </span><span class="s1">NameError:</span>
        <span class="s1">f = sys.argv[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">sysfile = os.path.join(os.path.split(os.path.abspath(f))[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                           <span class="s1">fname)</span>
    <span class="s3">if </span><span class="s1">os.path.isfile(sysfile):</span>
        <span class="s1">filenames.append(sysfile)</span>

    <span class="s0"># Home directory</span>
    <span class="s0"># And look for the user config file</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">f = os.path.expanduser(</span><span class="s4">'~'</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s3">pass</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">user_file = os.path.join(f</span><span class="s3">, </span><span class="s1">fname)</span>
        <span class="s3">if </span><span class="s1">os.path.isfile(user_file):</span>
            <span class="s1">filenames.append(user_file)</span>

    <span class="s0"># Local file</span>
    <span class="s3">if </span><span class="s1">os.path.isfile(fname):</span>
        <span class="s1">filenames.append(os.path.abspath(fname))</span>

    <span class="s3">return </span><span class="s1">filenames</span>


<span class="s3">def </span><span class="s1">_parse_env_order(base_order</span><span class="s3">, </span><span class="s1">env):</span>
    <span class="s2">&quot;&quot;&quot; Parse an environment variable `env` by splitting with &quot;,&quot; and only returning elements from `base_order` 
 
    This method will sequence the environment variable and check for their 
    individual elements in `base_order`. 
 
    The items in the environment variable may be negated via '^item' or '!itema,itemb'. 
    It must start with ^/! to negate all options. 
 
    Raises 
    ------ 
    ValueError: for mixed negated and non-negated orders or multiple negated orders 
 
    Parameters 
    ---------- 
    base_order : list of str 
       the base list of orders 
    env : str 
       the environment variable to be parsed, if none is found, `base_order` is returned 
 
    Returns 
    ------- 
    allow_order : list of str 
        allowed orders in lower-case 
    unknown_order : list of str 
        for values not overlapping with `base_order` 
    &quot;&quot;&quot;</span>
    <span class="s1">order_str = os.environ.get(env</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s0"># ensure all base-orders are lower-case (for easier comparison)</span>
    <span class="s1">base_order = [order.lower() </span><span class="s3">for </span><span class="s1">order </span><span class="s3">in </span><span class="s1">base_order]</span>
    <span class="s3">if </span><span class="s1">order_str </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">base_order</span><span class="s3">, </span><span class="s1">[]</span>

    <span class="s1">neg = order_str.startswith(</span><span class="s4">'^'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">order_str.startswith(</span><span class="s4">'!'</span><span class="s1">)</span>
    <span class="s0"># Check format</span>
    <span class="s1">order_str_l = list(order_str)</span>
    <span class="s1">sum_neg = order_str_l.count(</span><span class="s4">'^'</span><span class="s1">) + order_str_l.count(</span><span class="s4">'!'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">neg:</span>
        <span class="s3">if </span><span class="s1">sum_neg &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Environment variable '</span><span class="s3">{</span><span class="s1">env</span><span class="s3">}</span><span class="s4">' may only contain a single (prefixed) negation: </span><span class="s3">{</span><span class="s1">order_str</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s0"># remove prefix</span>
        <span class="s1">order_str = order_str[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s3">elif </span><span class="s1">sum_neg &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Environment variable '</span><span class="s3">{</span><span class="s1">env</span><span class="s3">}</span><span class="s4">' may not mix negated an non-negated items: </span><span class="s3">{</span><span class="s1">order_str</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0"># Split and lower case</span>
    <span class="s1">orders = order_str.lower().split(</span><span class="s4">','</span><span class="s1">)</span>

    <span class="s0"># to inform callee about non-overlapping elements</span>
    <span class="s1">unknown_order = []</span>

    <span class="s0"># if negated, we have to remove from the order</span>
    <span class="s3">if </span><span class="s1">neg:</span>
        <span class="s1">allow_order = base_order.copy()</span>

        <span class="s3">for </span><span class="s1">order </span><span class="s3">in </span><span class="s1">orders:</span>
            <span class="s3">if not </span><span class="s1">order:</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">order </span><span class="s3">not in </span><span class="s1">base_order:</span>
                <span class="s1">unknown_order.append(order)</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">order </span><span class="s3">in </span><span class="s1">allow_order:</span>
                <span class="s1">allow_order.remove(order)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">allow_order = []</span>

        <span class="s3">for </span><span class="s1">order </span><span class="s3">in </span><span class="s1">orders:</span>
            <span class="s3">if not </span><span class="s1">order:</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">order </span><span class="s3">not in </span><span class="s1">base_order:</span>
                <span class="s1">unknown_order.append(order)</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">order </span><span class="s3">not in </span><span class="s1">allow_order:</span>
                <span class="s1">allow_order.append(order)</span>

    <span class="s3">return </span><span class="s1">allow_order</span><span class="s3">, </span><span class="s1">unknown_order</span>


<span class="s3">def </span><span class="s1">get_info(name</span><span class="s3">, </span><span class="s1">notfound_action=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    notfound_action: 
      0 - do nothing 
      1 - display warning message 
      2 - raise error 
    &quot;&quot;&quot;</span>
    <span class="s1">cl = {</span><span class="s4">'armpl'</span><span class="s1">: armpl_info</span><span class="s3">,</span>
          <span class="s4">'blas_armpl'</span><span class="s1">: blas_armpl_info</span><span class="s3">,</span>
          <span class="s4">'lapack_armpl'</span><span class="s1">: lapack_armpl_info</span><span class="s3">,</span>
          <span class="s4">'fftw3_armpl'</span><span class="s1">: fftw3_armpl_info</span><span class="s3">,</span>
          <span class="s4">'atlas'</span><span class="s1">: atlas_info</span><span class="s3">,  </span><span class="s0"># use lapack_opt or blas_opt instead</span>
          <span class="s4">'atlas_threads'</span><span class="s1">: atlas_threads_info</span><span class="s3">,                </span><span class="s0"># ditto</span>
          <span class="s4">'atlas_blas'</span><span class="s1">: atlas_blas_info</span><span class="s3">,</span>
          <span class="s4">'atlas_blas_threads'</span><span class="s1">: atlas_blas_threads_info</span><span class="s3">,</span>
          <span class="s4">'lapack_atlas'</span><span class="s1">: lapack_atlas_info</span><span class="s3">,  </span><span class="s0"># use lapack_opt instead</span>
          <span class="s4">'lapack_atlas_threads'</span><span class="s1">: lapack_atlas_threads_info</span><span class="s3">,  </span><span class="s0"># ditto</span>
          <span class="s4">'atlas_3_10'</span><span class="s1">: atlas_3_10_info</span><span class="s3">,  </span><span class="s0"># use lapack_opt or blas_opt instead</span>
          <span class="s4">'atlas_3_10_threads'</span><span class="s1">: atlas_3_10_threads_info</span><span class="s3">,                </span><span class="s0"># ditto</span>
          <span class="s4">'atlas_3_10_blas'</span><span class="s1">: atlas_3_10_blas_info</span><span class="s3">,</span>
          <span class="s4">'atlas_3_10_blas_threads'</span><span class="s1">: atlas_3_10_blas_threads_info</span><span class="s3">,</span>
          <span class="s4">'lapack_atlas_3_10'</span><span class="s1">: lapack_atlas_3_10_info</span><span class="s3">,  </span><span class="s0"># use lapack_opt instead</span>
          <span class="s4">'lapack_atlas_3_10_threads'</span><span class="s1">: lapack_atlas_3_10_threads_info</span><span class="s3">,  </span><span class="s0"># ditto</span>
          <span class="s4">'flame'</span><span class="s1">: flame_info</span><span class="s3">,          </span><span class="s0"># use lapack_opt instead</span>
          <span class="s4">'mkl'</span><span class="s1">: mkl_info</span><span class="s3">,</span>
          <span class="s0"># openblas which may or may not have embedded lapack</span>
          <span class="s4">'openblas'</span><span class="s1">: openblas_info</span><span class="s3">,          </span><span class="s0"># use blas_opt instead</span>
          <span class="s0"># openblas with embedded lapack</span>
          <span class="s4">'openblas_lapack'</span><span class="s1">: openblas_lapack_info</span><span class="s3">, </span><span class="s0"># use blas_opt instead</span>
          <span class="s4">'openblas_clapack'</span><span class="s1">: openblas_clapack_info</span><span class="s3">, </span><span class="s0"># use blas_opt instead</span>
          <span class="s4">'blis'</span><span class="s1">: blis_info</span><span class="s3">,                  </span><span class="s0"># use blas_opt instead</span>
          <span class="s4">'lapack_mkl'</span><span class="s1">: lapack_mkl_info</span><span class="s3">,      </span><span class="s0"># use lapack_opt instead</span>
          <span class="s4">'blas_mkl'</span><span class="s1">: blas_mkl_info</span><span class="s3">,          </span><span class="s0"># use blas_opt instead</span>
          <span class="s4">'accelerate'</span><span class="s1">: accelerate_info</span><span class="s3">,      </span><span class="s0"># use blas_opt instead</span>
          <span class="s4">'openblas64_'</span><span class="s1">: openblas64__info</span><span class="s3">,</span>
          <span class="s4">'openblas64__lapack'</span><span class="s1">: openblas64__lapack_info</span><span class="s3">,</span>
          <span class="s4">'openblas_ilp64'</span><span class="s1">: openblas_ilp64_info</span><span class="s3">,</span>
          <span class="s4">'openblas_ilp64_lapack'</span><span class="s1">: openblas_ilp64_lapack_info</span><span class="s3">,</span>
          <span class="s4">'x11'</span><span class="s1">: x11_info</span><span class="s3">,</span>
          <span class="s4">'fft_opt'</span><span class="s1">: fft_opt_info</span><span class="s3">,</span>
          <span class="s4">'fftw'</span><span class="s1">: fftw_info</span><span class="s3">,</span>
          <span class="s4">'fftw2'</span><span class="s1">: fftw2_info</span><span class="s3">,</span>
          <span class="s4">'fftw3'</span><span class="s1">: fftw3_info</span><span class="s3">,</span>
          <span class="s4">'dfftw'</span><span class="s1">: dfftw_info</span><span class="s3">,</span>
          <span class="s4">'sfftw'</span><span class="s1">: sfftw_info</span><span class="s3">,</span>
          <span class="s4">'fftw_threads'</span><span class="s1">: fftw_threads_info</span><span class="s3">,</span>
          <span class="s4">'dfftw_threads'</span><span class="s1">: dfftw_threads_info</span><span class="s3">,</span>
          <span class="s4">'sfftw_threads'</span><span class="s1">: sfftw_threads_info</span><span class="s3">,</span>
          <span class="s4">'djbfft'</span><span class="s1">: djbfft_info</span><span class="s3">,</span>
          <span class="s4">'blas'</span><span class="s1">: blas_info</span><span class="s3">,                  </span><span class="s0"># use blas_opt instead</span>
          <span class="s4">'lapack'</span><span class="s1">: lapack_info</span><span class="s3">,              </span><span class="s0"># use lapack_opt instead</span>
          <span class="s4">'lapack_src'</span><span class="s1">: lapack_src_info</span><span class="s3">,</span>
          <span class="s4">'blas_src'</span><span class="s1">: blas_src_info</span><span class="s3">,</span>
          <span class="s4">'numpy'</span><span class="s1">: numpy_info</span><span class="s3">,</span>
          <span class="s4">'f2py'</span><span class="s1">: f2py_info</span><span class="s3">,</span>
          <span class="s4">'Numeric'</span><span class="s1">: Numeric_info</span><span class="s3">,</span>
          <span class="s4">'numeric'</span><span class="s1">: Numeric_info</span><span class="s3">,</span>
          <span class="s4">'numarray'</span><span class="s1">: numarray_info</span><span class="s3">,</span>
          <span class="s4">'numerix'</span><span class="s1">: numerix_info</span><span class="s3">,</span>
          <span class="s4">'lapack_opt'</span><span class="s1">: lapack_opt_info</span><span class="s3">,</span>
          <span class="s4">'lapack_ilp64_opt'</span><span class="s1">: lapack_ilp64_opt_info</span><span class="s3">,</span>
          <span class="s4">'lapack_ilp64_plain_opt'</span><span class="s1">: lapack_ilp64_plain_opt_info</span><span class="s3">,</span>
          <span class="s4">'lapack64__opt'</span><span class="s1">: lapack64__opt_info</span><span class="s3">,</span>
          <span class="s4">'blas_opt'</span><span class="s1">: blas_opt_info</span><span class="s3">,</span>
          <span class="s4">'blas_ilp64_opt'</span><span class="s1">: blas_ilp64_opt_info</span><span class="s3">,</span>
          <span class="s4">'blas_ilp64_plain_opt'</span><span class="s1">: blas_ilp64_plain_opt_info</span><span class="s3">,</span>
          <span class="s4">'blas64__opt'</span><span class="s1">: blas64__opt_info</span><span class="s3">,</span>
          <span class="s4">'boost_python'</span><span class="s1">: boost_python_info</span><span class="s3">,</span>
          <span class="s4">'agg2'</span><span class="s1">: agg2_info</span><span class="s3">,</span>
          <span class="s4">'wx'</span><span class="s1">: wx_info</span><span class="s3">,</span>
          <span class="s4">'gdk_pixbuf_xlib_2'</span><span class="s1">: gdk_pixbuf_xlib_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk-pixbuf-xlib-2.0'</span><span class="s1">: gdk_pixbuf_xlib_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk_pixbuf_2'</span><span class="s1">: gdk_pixbuf_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk-pixbuf-2.0'</span><span class="s1">: gdk_pixbuf_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk'</span><span class="s1">: gdk_info</span><span class="s3">,</span>
          <span class="s4">'gdk_2'</span><span class="s1">: gdk_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk-2.0'</span><span class="s1">: gdk_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk_x11_2'</span><span class="s1">: gdk_x11_2_info</span><span class="s3">,</span>
          <span class="s4">'gdk-x11-2.0'</span><span class="s1">: gdk_x11_2_info</span><span class="s3">,</span>
          <span class="s4">'gtkp_x11_2'</span><span class="s1">: gtkp_x11_2_info</span><span class="s3">,</span>
          <span class="s4">'gtk+-x11-2.0'</span><span class="s1">: gtkp_x11_2_info</span><span class="s3">,</span>
          <span class="s4">'gtkp_2'</span><span class="s1">: gtkp_2_info</span><span class="s3">,</span>
          <span class="s4">'gtk+-2.0'</span><span class="s1">: gtkp_2_info</span><span class="s3">,</span>
          <span class="s4">'xft'</span><span class="s1">: xft_info</span><span class="s3">,</span>
          <span class="s4">'freetype2'</span><span class="s1">: freetype2_info</span><span class="s3">,</span>
          <span class="s4">'umfpack'</span><span class="s1">: umfpack_info</span><span class="s3">,</span>
          <span class="s4">'amd'</span><span class="s1">: amd_info</span><span class="s3">,</span>
          <span class="s1">}.get(name.lower()</span><span class="s3">, </span><span class="s1">system_info)</span>
    <span class="s3">return </span><span class="s1">cl().get_info(notfound_action)</span>


<span class="s3">class </span><span class="s1">NotFoundError(DistutilsError):</span>
    <span class="s2">&quot;&quot;&quot;Some third-party program or library is not found.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">AliasedOptionError(DistutilsError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Aliases entries in config files should not be existing. 
    In section '{section}' we found multiple appearances of options {options}.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">AtlasNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Atlas (http://github.com/math-atlas/math-atlas) libraries not found. 
    Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [atlas]) or by setting 
    the ATLAS environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">FlameNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    FLAME (http://www.cs.utexas.edu/~flame/web/) libraries not found. 
    Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [flame]).&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">LapackNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Lapack (http://www.netlib.org/lapack/) libraries not found. 
    Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [lapack]) or by setting 
    the LAPACK environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">LapackSrcNotFoundError(LapackNotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Lapack (http://www.netlib.org/lapack/) sources not found. 
    Directories to search for the sources can be specified in the 
    numpy/distutils/site.cfg file (section [lapack_src]) or by setting 
    the LAPACK_SRC environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">LapackILP64NotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    64-bit Lapack libraries not found. 
    Known libraries in numpy/distutils/site.cfg file are: 
    openblas64_, openblas_ilp64 
    &quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">BlasOptNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Optimized (vendor) Blas libraries are not found. 
    Falls back to netlib Blas library which has worse performance. 
    A better performance should be easily gained by switching 
    Blas library.&quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">BlasNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Blas (http://www.netlib.org/blas/) libraries not found. 
    Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [blas]) or by setting 
    the BLAS environment variable.&quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">BlasILP64NotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    64-bit Blas libraries not found. 
    Known libraries in numpy/distutils/site.cfg file are: 
    openblas64_, openblas_ilp64 
    &quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">BlasSrcNotFoundError(BlasNotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Blas (http://www.netlib.org/blas/) sources not found. 
    Directories to search for the sources can be specified in the 
    numpy/distutils/site.cfg file (section [blas_src]) or by setting 
    the BLAS_SRC environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">FFTWNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    FFTW (http://www.fftw.org/) libraries not found. 
    Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [fftw]) or by setting 
    the FFTW environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">DJBFFTNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    DJBFFT (https://cr.yp.to/djbfft.html) libraries not found. 
    Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [djbfft]) or by setting 
    the DJBFFT environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NumericNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Numeric (https://www.numpy.org/) module not found. 
    Get it from above location, install it, and retry setup.py.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">X11NotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot;X11 libraries not found.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">UmfpackNotFoundError(NotFoundError):</span>
    <span class="s2">&quot;&quot;&quot; 
    UMFPACK sparse solver (https://www.cise.ufl.edu/research/sparse/umfpack/) 
    not found. Directories to search for the libraries can be specified in the 
    numpy/distutils/site.cfg file (section [umfpack]) or by setting 
    the UMFPACK environment variable.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">system_info:</span>

    <span class="s2">&quot;&quot;&quot; get_info() is the only public method. Don't use others. 
    &quot;&quot;&quot;</span>
    <span class="s1">dir_env_var = </span><span class="s3">None</span>
    <span class="s0"># XXX: search_static_first is disabled by default, may disappear in</span>
    <span class="s0"># future unless it is proved to be useful.</span>
    <span class="s1">search_static_first = </span><span class="s5">0</span>
    <span class="s0"># The base-class section name is a random word &quot;ALL&quot; and is not really</span>
    <span class="s0"># intended for general use. It cannot be None nor can it be DEFAULT as</span>
    <span class="s0"># these break the ConfigParser. See gh-15338</span>
    <span class="s1">section = </span><span class="s4">'ALL'</span>
    <span class="s1">saved_results = {}</span>

    <span class="s1">notfounderror = NotFoundError</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
                  <span class="s1">default_lib_dirs=default_lib_dirs</span><span class="s3">,</span>
                  <span class="s1">default_include_dirs=default_include_dirs</span><span class="s3">,</span>
                  <span class="s1">):</span>
        <span class="s1">self.__class__.info = {}</span>
        <span class="s1">self.local_prefixes = []</span>
        <span class="s1">defaults = {</span><span class="s4">'library_dirs'</span><span class="s1">: os.pathsep.join(default_lib_dirs)</span><span class="s3">,</span>
                    <span class="s4">'include_dirs'</span><span class="s1">: os.pathsep.join(default_include_dirs)</span><span class="s3">,</span>
                    <span class="s4">'runtime_library_dirs'</span><span class="s1">: os.pathsep.join(default_runtime_dirs)</span><span class="s3">,</span>
                    <span class="s4">'rpath'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
                    <span class="s4">'src_dirs'</span><span class="s1">: os.pathsep.join(default_src_dirs)</span><span class="s3">,</span>
                    <span class="s4">'search_static_first'</span><span class="s1">: str(self.search_static_first)</span><span class="s3">,</span>
                    <span class="s4">'extra_compile_args'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'extra_link_args'</span><span class="s1">: </span><span class="s4">''</span><span class="s1">}</span>
        <span class="s1">self.cp = ConfigParser(defaults)</span>
        <span class="s1">self.files = []</span>
        <span class="s1">self.files.extend(get_standard_file(</span><span class="s4">'.numpy-site.cfg'</span><span class="s1">))</span>
        <span class="s1">self.files.extend(get_standard_file(</span><span class="s4">'site.cfg'</span><span class="s1">))</span>
        <span class="s1">self.parse_config_files()</span>

        <span class="s3">if </span><span class="s1">self.section </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.search_static_first = self.cp.getboolean(</span>
                <span class="s1">self.section</span><span class="s3">, </span><span class="s4">'search_static_first'</span><span class="s1">)</span>
        <span class="s3">assert </span><span class="s1">isinstance(self.search_static_first</span><span class="s3">, </span><span class="s1">int)</span>

    <span class="s3">def </span><span class="s1">parse_config_files(self):</span>
        <span class="s1">self.cp.read(self.files)</span>
        <span class="s3">if not </span><span class="s1">self.cp.has_section(self.section):</span>
            <span class="s3">if </span><span class="s1">self.section </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.cp.add_section(self.section)</span>

    <span class="s3">def </span><span class="s1">calc_libraries_info(self):</span>
        <span class="s1">libs = self.get_libraries()</span>
        <span class="s1">dirs = self.get_lib_dirs()</span>
        <span class="s0"># The extensions use runtime_library_dirs</span>
        <span class="s1">r_dirs = self.get_runtime_lib_dirs()</span>
        <span class="s0"># Intrinsic distutils use rpath, we simply append both entries</span>
        <span class="s0"># as though they were one entry</span>
        <span class="s1">r_dirs.extend(self.get_runtime_lib_dirs(key=</span><span class="s4">'rpath'</span><span class="s1">))</span>
        <span class="s1">info = {}</span>
        <span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">libs:</span>
            <span class="s1">i = self.check_libs(dirs</span><span class="s3">, </span><span class="s1">[lib])</span>
            <span class="s3">if </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**i)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">log.info(</span><span class="s4">'Library %s was not found. Ignoring' </span><span class="s1">% (lib))</span>

            <span class="s3">if </span><span class="s1">r_dirs:</span>
                <span class="s1">i = self.check_libs(r_dirs</span><span class="s3">, </span><span class="s1">[lib])</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s0"># Swap library keywords found to runtime_library_dirs</span>
                    <span class="s0"># the libraries are insisting on the user having defined</span>
                    <span class="s0"># them using the library_dirs, and not necessarily by</span>
                    <span class="s0"># runtime_library_dirs</span>
                    <span class="s3">del </span><span class="s1">i[</span><span class="s4">'libraries'</span><span class="s1">]</span>
                    <span class="s1">i[</span><span class="s4">'runtime_library_dirs'</span><span class="s1">] = i.pop(</span><span class="s4">'library_dirs'</span><span class="s1">)</span>
                    <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**i)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">log.info(</span><span class="s4">'Runtime library %s was not found. Ignoring' </span><span class="s1">% (lib))</span>

        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">set_info(self</span><span class="s3">, </span><span class="s1">**info):</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">lib_info = self.calc_libraries_info()</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**lib_info)</span>
            <span class="s0"># Update extra information</span>
            <span class="s1">extra_info = self.calc_extra_info()</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**extra_info)</span>
        <span class="s1">self.saved_results[self.__class__.__name__] = info</span>

    <span class="s3">def </span><span class="s1">get_option_single(self</span><span class="s3">, </span><span class="s1">*options):</span>
        <span class="s2">&quot;&quot;&quot; Ensure that only one of `options` are found in the section 
 
        Parameters 
        ---------- 
        *options : list of str 
           a list of options to be found in the section (``self.section``) 
 
        Returns 
        ------- 
        str : 
            the option that is uniquely found in the section 
 
        Raises 
        ------ 
        AliasedOptionError : 
            in case more than one of the options are found 
        &quot;&quot;&quot;</span>
        <span class="s1">found = [self.cp.has_option(self.section</span><span class="s3">, </span><span class="s1">opt) </span><span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">options]</span>
        <span class="s3">if </span><span class="s1">sum(found) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">options[found.index(</span><span class="s3">True</span><span class="s1">)]</span>
        <span class="s3">elif </span><span class="s1">sum(found) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># nothing is found anyways</span>
            <span class="s3">return </span><span class="s1">options[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s0"># Else we have more than 1 key found</span>
        <span class="s3">if </span><span class="s1">AliasedOptionError.__doc__ </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AliasedOptionError()</span>
        <span class="s3">raise </span><span class="s1">AliasedOptionError(AliasedOptionError.__doc__.format(</span>
            <span class="s1">section=self.section</span><span class="s3">, </span><span class="s1">options=</span><span class="s4">'[{}]'</span><span class="s1">.format(</span><span class="s4">', '</span><span class="s1">.join(options))))</span>


    <span class="s3">def </span><span class="s1">has_info(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__.__name__ </span><span class="s3">in </span><span class="s1">self.saved_results</span>

    <span class="s3">def </span><span class="s1">calc_extra_info(self):</span>
        <span class="s2">&quot;&quot;&quot; Updates the information in the current information with 
        respect to these flags: 
          extra_compile_args 
          extra_link_args 
        &quot;&quot;&quot;</span>
        <span class="s1">info = {}</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'extra_compile_args'</span><span class="s3">, </span><span class="s4">'extra_link_args'</span><span class="s1">]:</span>
            <span class="s0"># Get values</span>
            <span class="s1">opt = self.cp.get(self.section</span><span class="s3">, </span><span class="s1">key)</span>
            <span class="s1">opt = _shell_utils.NativeParser.split(opt)</span>
            <span class="s3">if </span><span class="s1">opt:</span>
                <span class="s1">tmp = {key: opt}</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**tmp)</span>
        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">get_info(self</span><span class="s3">, </span><span class="s1">notfound_action=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Return a dictionary with items that are compatible 
            with numpy.distutils.setup keyword arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">flag = </span><span class="s5">0</span>
        <span class="s3">if not </span><span class="s1">self.has_info():</span>
            <span class="s1">flag = </span><span class="s5">1</span>
            <span class="s1">log.info(self.__class__.__name__ + </span><span class="s4">':'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'calc_info'</span><span class="s1">):</span>
                <span class="s1">self.calc_info()</span>
            <span class="s3">if </span><span class="s1">notfound_action:</span>
                <span class="s3">if not </span><span class="s1">self.has_info():</span>
                    <span class="s3">if </span><span class="s1">notfound_action == </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">warnings.warn(self.notfounderror.__doc__</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
                    <span class="s3">elif </span><span class="s1">notfound_action == </span><span class="s5">2</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">self.notfounderror(self.notfounderror.__doc__)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(repr(notfound_action))</span>

            <span class="s3">if not </span><span class="s1">self.has_info():</span>
                <span class="s1">log.info(</span><span class="s4">'  NOT AVAILABLE'</span><span class="s1">)</span>
                <span class="s1">self.set_info()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">log.info(</span><span class="s4">'  FOUND:'</span><span class="s1">)</span>

        <span class="s1">res = self.saved_results.get(self.__class__.__name__)</span>
        <span class="s3">if </span><span class="s1">log.get_threshold() &lt;= log.INFO </span><span class="s3">and </span><span class="s1">flag:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">res.items():</span>
                <span class="s1">v = str(v)</span>
                <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'sources'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">] </span><span class="s3">and </span><span class="s1">len(v) &gt; </span><span class="s5">270</span><span class="s1">:</span>
                    <span class="s1">v = v[:</span><span class="s5">120</span><span class="s1">] + </span><span class="s4">'...</span><span class="s3">\n</span><span class="s4">...</span><span class="s3">\n</span><span class="s4">...' </span><span class="s1">+ v[-</span><span class="s5">120</span><span class="s1">:]</span>
                <span class="s1">log.info(</span><span class="s4">'    %s = %s'</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v)</span>
            <span class="s1">log.info(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">copy.deepcopy(res)</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">dirs = self.cp.get(section</span><span class="s3">, </span><span class="s1">key).split(os.pathsep)</span>
        <span class="s1">env_var = self.dir_env_var</span>
        <span class="s3">if </span><span class="s1">env_var:</span>
            <span class="s3">if </span><span class="s1">is_sequence(env_var):</span>
                <span class="s1">e0 = env_var[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">env_var:</span>
                    <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">os.environ:</span>
                        <span class="s1">e0 = e</span>
                        <span class="s3">break</span>
                <span class="s3">if not </span><span class="s1">env_var[</span><span class="s5">0</span><span class="s1">] == e0:</span>
                    <span class="s1">log.info(</span><span class="s4">'Setting %s=%s' </span><span class="s1">% (env_var[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">e0))</span>
                <span class="s1">env_var = e0</span>
        <span class="s3">if </span><span class="s1">env_var </span><span class="s3">and </span><span class="s1">env_var </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s1">d = os.environ[env_var]</span>
            <span class="s3">if </span><span class="s1">d == </span><span class="s4">'None'</span><span class="s1">:</span>
                <span class="s1">log.info(</span><span class="s4">'Disabled %s: %s'</span><span class="s3">,</span>
                         <span class="s1">self.__class__.__name__</span><span class="s3">, </span><span class="s4">'(%s is None)'</span>
                         <span class="s1">% (env_var</span><span class="s3">,</span><span class="s1">))</span>
                <span class="s3">return </span><span class="s1">[]</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(d):</span>
                <span class="s1">dirs = [os.path.dirname(d)] + dirs</span>
                <span class="s1">l = getattr(self</span><span class="s3">, </span><span class="s4">'_lib_names'</span><span class="s3">, </span><span class="s1">[])</span>
                <span class="s3">if </span><span class="s1">len(l) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">b = os.path.basename(d)</span>
                    <span class="s1">b = os.path.splitext(b)[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s1">b[:</span><span class="s5">3</span><span class="s1">] == </span><span class="s4">'lib'</span><span class="s1">:</span>
                        <span class="s1">log.info(</span><span class="s4">'Replacing _lib_names[0]==%r with %r' </span><span class="s1">\</span>
                              <span class="s1">% (self._lib_names[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">b[</span><span class="s5">3</span><span class="s1">:]))</span>
                        <span class="s1">self._lib_names[</span><span class="s5">0</span><span class="s1">] = b[</span><span class="s5">3</span><span class="s1">:]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ds = d.split(os.pathsep)</span>
                <span class="s1">ds2 = []</span>
                <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">ds:</span>
                    <span class="s3">if </span><span class="s1">os.path.isdir(d):</span>
                        <span class="s1">ds2.append(d)</span>
                        <span class="s3">for </span><span class="s1">dd </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'include'</span><span class="s3">, </span><span class="s4">'lib'</span><span class="s1">]:</span>
                            <span class="s1">d1 = os.path.join(d</span><span class="s3">, </span><span class="s1">dd)</span>
                            <span class="s3">if </span><span class="s1">os.path.isdir(d1):</span>
                                <span class="s1">ds2.append(d1)</span>
                <span class="s1">dirs = ds2 + dirs</span>
        <span class="s1">default_dirs = self.cp.get(self.section</span><span class="s3">, </span><span class="s1">key).split(os.pathsep)</span>
        <span class="s1">dirs.extend(default_dirs)</span>
        <span class="s1">ret = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs:</span>
            <span class="s3">if </span><span class="s1">len(d) &gt; </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">os.path.isdir(d):</span>
                <span class="s1">warnings.warn(</span><span class="s4">'Specified path %s is invalid.' </span><span class="s1">% d</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">d </span><span class="s3">not in </span><span class="s1">ret:</span>
                <span class="s1">ret.append(d)</span>

        <span class="s1">log.debug(</span><span class="s4">'( %s = %s )'</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s4">':'</span><span class="s1">.join(ret))</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">get_lib_dirs(self</span><span class="s3">, </span><span class="s1">key=</span><span class="s4">'library_dirs'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.get_paths(self.section</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s3">def </span><span class="s1">get_runtime_lib_dirs(self</span><span class="s3">, </span><span class="s1">key=</span><span class="s4">'runtime_library_dirs'</span><span class="s1">):</span>
        <span class="s1">path = self.get_paths(self.section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s3">if </span><span class="s1">path == [</span><span class="s4">''</span><span class="s1">]:</span>
            <span class="s1">path = []</span>
        <span class="s3">return </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">get_include_dirs(self</span><span class="s3">, </span><span class="s1">key=</span><span class="s4">'include_dirs'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.get_paths(self.section</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s3">def </span><span class="s1">get_src_dirs(self</span><span class="s3">, </span><span class="s1">key=</span><span class="s4">'src_dirs'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.get_paths(self.section</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s3">def </span><span class="s1">get_libs(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">libs = self.cp.get(self.section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s3">except </span><span class="s1">NoOptionError:</span>
            <span class="s3">if not </span><span class="s1">default:</span>
                <span class="s3">return </span><span class="s1">[]</span>
            <span class="s3">if </span><span class="s1">is_string(default):</span>
                <span class="s3">return </span><span class="s1">[default]</span>
            <span class="s3">return </span><span class="s1">default</span>
        <span class="s3">return </span><span class="s1">[b </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">[a.strip() </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">libs.split(</span><span class="s4">','</span><span class="s1">)] </span><span class="s3">if </span><span class="s1">b]</span>

    <span class="s3">def </span><span class="s1">get_libraries(self</span><span class="s3">, </span><span class="s1">key=</span><span class="s4">'libraries'</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'_lib_names'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.get_libs(key</span><span class="s3">, </span><span class="s1">default=self._lib_names)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.get_libs(key</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">library_extensions(self):</span>
        <span class="s1">c = customized_ccompiler()</span>
        <span class="s1">static_exts = []</span>
        <span class="s3">if </span><span class="s1">c.compiler_type != </span><span class="s4">'msvc'</span><span class="s1">:</span>
            <span class="s0"># MSVC doesn't understand binutils</span>
            <span class="s1">static_exts.append(</span><span class="s4">'.a'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
            <span class="s1">static_exts.append(</span><span class="s4">'.lib'</span><span class="s1">)  </span><span class="s0"># .lib is used by MSVC and others</span>
        <span class="s3">if </span><span class="s1">self.search_static_first:</span>
            <span class="s1">exts = static_exts + [so_ext]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">exts = [so_ext] + static_exts</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'cygwin'</span><span class="s1">:</span>
            <span class="s1">exts.append(</span><span class="s4">'.dll.a'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'darwin'</span><span class="s1">:</span>
            <span class="s1">exts.append(</span><span class="s4">'.dylib'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">exts</span>

    <span class="s3">def </span><span class="s1">check_libs(self</span><span class="s3">, </span><span class="s1">lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">opt_libs=[]):</span>
        <span class="s2">&quot;&quot;&quot;If static or shared libraries are available then return 
        their info dictionary. 
 
        Checks for all libraries as shared libraries first, then 
        static (or vice versa if self.search_static_first is True). 
        &quot;&quot;&quot;</span>
        <span class="s1">exts = self.library_extensions()</span>
        <span class="s1">info = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">exts:</span>
            <span class="s1">info = self._check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">opt_libs</span><span class="s3">, </span><span class="s1">[ext])</span>
            <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">break</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">log.info(</span><span class="s4">'  libraries %s not found in %s'</span><span class="s3">, </span><span class="s4">','</span><span class="s1">.join(libs)</span><span class="s3">,</span>
                     <span class="s1">lib_dirs)</span>
        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">check_libs2(self</span><span class="s3">, </span><span class="s1">lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">opt_libs=[]):</span>
        <span class="s2">&quot;&quot;&quot;If static or shared libraries are available then return 
        their info dictionary. 
 
        Checks each library for shared or static. 
        &quot;&quot;&quot;</span>
        <span class="s1">exts = self.library_extensions()</span>
        <span class="s1">info = self._check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">opt_libs</span><span class="s3">, </span><span class="s1">exts)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">log.info(</span><span class="s4">'  libraries %s not found in %s'</span><span class="s3">, </span><span class="s4">','</span><span class="s1">.join(libs)</span><span class="s3">,</span>
                     <span class="s1">lib_dirs)</span>

        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">_find_lib(self</span><span class="s3">, </span><span class="s1">lib_dir</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">exts):</span>
        <span class="s3">assert </span><span class="s1">is_string(lib_dir)</span>
        <span class="s0"># under windows first try without 'lib' prefix</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
            <span class="s1">lib_prefixes = [</span><span class="s4">''</span><span class="s3">, </span><span class="s4">'lib'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">lib_prefixes = [</span><span class="s4">'lib'</span><span class="s1">]</span>
        <span class="s0"># for each library name, see if we can find a file for it.</span>
        <span class="s3">for </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">exts:</span>
            <span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">lib_prefixes:</span>
                <span class="s1">p = self.combine_paths(lib_dir</span><span class="s3">, </span><span class="s1">prefix + lib + ext)</span>
                <span class="s3">if </span><span class="s1">p:</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">p:</span>
                <span class="s3">assert </span><span class="s1">len(p) == </span><span class="s5">1</span>
                <span class="s0"># ??? splitext on p[0] would do this for cygwin</span>
                <span class="s0"># doesn't seem correct</span>
                <span class="s3">if </span><span class="s1">ext == </span><span class="s4">'.dll.a'</span><span class="s1">:</span>
                    <span class="s1">lib += </span><span class="s4">'.dll'</span>
                <span class="s3">if </span><span class="s1">ext == </span><span class="s4">'.lib'</span><span class="s1">:</span>
                    <span class="s1">lib = prefix + lib</span>
                <span class="s3">return </span><span class="s1">lib</span>

        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_find_libs(self</span><span class="s3">, </span><span class="s1">lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">exts):</span>
        <span class="s0"># make sure we preserve the order of libs, as it can be important</span>
        <span class="s1">found_dirs</span><span class="s3">, </span><span class="s1">found_libs = []</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">libs:</span>
            <span class="s3">for </span><span class="s1">lib_dir </span><span class="s3">in </span><span class="s1">lib_dirs:</span>
                <span class="s1">found_lib = self._find_lib(lib_dir</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">exts)</span>
                <span class="s3">if </span><span class="s1">found_lib:</span>
                    <span class="s1">found_libs.append(found_lib)</span>
                    <span class="s3">if </span><span class="s1">lib_dir </span><span class="s3">not in </span><span class="s1">found_dirs:</span>
                        <span class="s1">found_dirs.append(lib_dir)</span>
                    <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">found_dirs</span><span class="s3">, </span><span class="s1">found_libs</span>

    <span class="s3">def </span><span class="s1">_check_libs(self</span><span class="s3">, </span><span class="s1">lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">opt_libs</span><span class="s3">, </span><span class="s1">exts):</span>
        <span class="s2">&quot;&quot;&quot;Find mandatory and optional libs in expected paths. 
 
        Missing optional libraries are silently forgotten. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">is_sequence(lib_dirs):</span>
            <span class="s1">lib_dirs = [lib_dirs]</span>
        <span class="s0"># First, try to find the mandatory libraries</span>
        <span class="s1">found_dirs</span><span class="s3">, </span><span class="s1">found_libs = self._find_libs(lib_dirs</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">, </span><span class="s1">exts)</span>
        <span class="s3">if </span><span class="s1">len(found_libs) &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">len(found_libs) == len(libs):</span>
            <span class="s0"># Now, check for optional libraries</span>
            <span class="s1">opt_found_dirs</span><span class="s3">, </span><span class="s1">opt_found_libs = self._find_libs(lib_dirs</span><span class="s3">, </span><span class="s1">opt_libs</span><span class="s3">, </span><span class="s1">exts)</span>
            <span class="s1">found_libs.extend(opt_found_libs)</span>
            <span class="s3">for </span><span class="s1">lib_dir </span><span class="s3">in </span><span class="s1">opt_found_dirs:</span>
                <span class="s3">if </span><span class="s1">lib_dir </span><span class="s3">not in </span><span class="s1">found_dirs:</span>
                    <span class="s1">found_dirs.append(lib_dir)</span>
            <span class="s1">info = {</span><span class="s4">'libraries'</span><span class="s1">: found_libs</span><span class="s3">, </span><span class="s4">'library_dirs'</span><span class="s1">: found_dirs}</span>
            <span class="s3">return </span><span class="s1">info</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">combine_paths(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s2">&quot;&quot;&quot;Return a list of existing paths composed by all combinations 
        of items from the arguments. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">combine_paths(*args)</span>


<span class="s3">class </span><span class="s1">fft_opt_info(system_info):</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">info = {}</span>
        <span class="s1">fftw_info = get_info(</span><span class="s4">'fftw3'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">get_info(</span><span class="s4">'fftw2'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">get_info(</span><span class="s4">'dfftw'</span><span class="s1">)</span>
        <span class="s1">djbfft_info = get_info(</span><span class="s4">'djbfft'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">fftw_info:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**fftw_info)</span>
            <span class="s3">if </span><span class="s1">djbfft_info:</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**djbfft_info)</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return</span>


<span class="s3">class </span><span class="s1">fftw_info(system_info):</span>
    <span class="s0">#variables to override</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">notfounderror = FFTWNotFoundError</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'fftw3'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'fftw3'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'fftw3.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_FFTW3_H'</span><span class="s3">, None</span><span class="s1">)]}</span><span class="s3">,</span>
                  <span class="s1">{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'fftw2'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'rfftw'</span><span class="s3">, </span><span class="s4">'fftw'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'fftw.h'</span><span class="s3">, </span><span class="s4">'rfftw.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_FFTW_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>

    <span class="s3">def </span><span class="s1">calc_ver_info(self</span><span class="s3">, </span><span class="s1">ver_param):</span>
        <span class="s2">&quot;&quot;&quot;Returns True on successful version detection, else False&quot;&quot;&quot;</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">incl_dirs = self.get_include_dirs()</span>

        <span class="s1">opt = self.get_option_single(self.section + </span><span class="s4">'_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">ver_param[</span><span class="s4">'libs'</span><span class="s1">])</span>
        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">libs)</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">flag = </span><span class="s5">0</span>
            <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">incl_dirs:</span>
                <span class="s3">if </span><span class="s1">len(self.combine_paths(d</span><span class="s3">, </span><span class="s1">ver_param[</span><span class="s4">'includes'</span><span class="s1">])) \</span>
                   <span class="s1">== len(ver_param[</span><span class="s4">'includes'</span><span class="s1">]):</span>
                    <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[d])</span>
                    <span class="s1">flag = </span><span class="s5">1</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">flag:</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=ver_param[</span><span class="s4">'macros'</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">info = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.info(</span><span class="s4">'  %s not found' </span><span class="s1">% (ver_param[</span><span class="s4">'name'</span><span class="s1">]))</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">self.ver_info:</span>
            <span class="s3">if </span><span class="s1">self.calc_ver_info(i):</span>
                <span class="s3">break</span>


<span class="s3">class </span><span class="s1">fftw2_info(fftw_info):</span>
    <span class="s0">#variables to override</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">notfounderror = FFTWNotFoundError</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'fftw2'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'rfftw'</span><span class="s3">, </span><span class="s4">'fftw'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'fftw.h'</span><span class="s3">, </span><span class="s4">'rfftw.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_FFTW_H'</span><span class="s3">, None</span><span class="s1">)]}</span>
                  <span class="s1">]</span>


<span class="s3">class </span><span class="s1">fftw3_info(fftw_info):</span>
    <span class="s0">#variables to override</span>
    <span class="s1">section = </span><span class="s4">'fftw3'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW3'</span>
    <span class="s1">notfounderror = FFTWNotFoundError</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'fftw3'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'fftw3'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'fftw3.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_FFTW3_H'</span><span class="s3">, None</span><span class="s1">)]}</span><span class="s3">,</span>
                  <span class="s1">]</span>

    
<span class="s3">class </span><span class="s1">fftw3_armpl_info(fftw_info):</span>
    <span class="s1">section = </span><span class="s4">'fftw3'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'ARMPL_DIR'</span>
    <span class="s1">notfounderror = FFTWNotFoundError</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">: </span><span class="s4">'fftw3'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">: [</span><span class="s4">'armpl_lp64_mp'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">: [</span><span class="s4">'fftw3.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">: [(</span><span class="s4">'SCIPY_FFTW3_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>


<span class="s3">class </span><span class="s1">dfftw_info(fftw_info):</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'dfftw'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'drfftw'</span><span class="s3">, </span><span class="s4">'dfftw'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'dfftw.h'</span><span class="s3">, </span><span class="s4">'drfftw.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_DFFTW_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>


<span class="s3">class </span><span class="s1">sfftw_info(fftw_info):</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'sfftw'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'srfftw'</span><span class="s3">, </span><span class="s4">'sfftw'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'sfftw.h'</span><span class="s3">, </span><span class="s4">'srfftw.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_SFFTW_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>


<span class="s3">class </span><span class="s1">fftw_threads_info(fftw_info):</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'fftw threads'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'rfftw_threads'</span><span class="s3">, </span><span class="s4">'fftw_threads'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'fftw_threads.h'</span><span class="s3">, </span><span class="s4">'rfftw_threads.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_FFTW_THREADS_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>


<span class="s3">class </span><span class="s1">dfftw_threads_info(fftw_info):</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'dfftw threads'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'drfftw_threads'</span><span class="s3">, </span><span class="s4">'dfftw_threads'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'dfftw_threads.h'</span><span class="s3">, </span><span class="s4">'drfftw_threads.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_DFFTW_THREADS_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>


<span class="s3">class </span><span class="s1">sfftw_threads_info(fftw_info):</span>
    <span class="s1">section = </span><span class="s4">'fftw'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'FFTW'</span>
    <span class="s1">ver_info = [{</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'sfftw threads'</span><span class="s3">,</span>
                    <span class="s4">'libs'</span><span class="s1">:[</span><span class="s4">'srfftw_threads'</span><span class="s3">, </span><span class="s4">'sfftw_threads'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'includes'</span><span class="s1">:[</span><span class="s4">'sfftw_threads.h'</span><span class="s3">, </span><span class="s4">'srfftw_threads.h'</span><span class="s1">]</span><span class="s3">,</span>
                    <span class="s4">'macros'</span><span class="s1">:[(</span><span class="s4">'SCIPY_SFFTW_THREADS_H'</span><span class="s3">, None</span><span class="s1">)]}]</span>


<span class="s3">class </span><span class="s1">djbfft_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'djbfft'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'DJBFFT'</span>
    <span class="s1">notfounderror = DJBFFTNotFoundError</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">pre_dirs = system_info.get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">dirs = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">pre_dirs:</span>
            <span class="s1">dirs.extend(self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'djbfft'</span><span class="s1">]) + [d])</span>
        <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(d)]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">incl_dirs = self.get_include_dirs()</span>
        <span class="s1">info = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">lib_dirs:</span>
            <span class="s1">p = self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'djbfft.a'</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">p:</span>
                <span class="s1">info = {</span><span class="s4">'extra_objects'</span><span class="s1">: p}</span>
                <span class="s3">break</span>
            <span class="s1">p = self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'libdjbfft.a'</span><span class="s3">, </span><span class="s4">'libdjbfft' </span><span class="s1">+ so_ext])</span>
            <span class="s3">if </span><span class="s1">p:</span>
                <span class="s1">info = {</span><span class="s4">'libraries'</span><span class="s1">: [</span><span class="s4">'djbfft'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'library_dirs'</span><span class="s1">: [d]}</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">incl_dirs:</span>
            <span class="s3">if </span><span class="s1">len(self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'fftc8.h'</span><span class="s3">, </span><span class="s4">'fftfreq.h'</span><span class="s1">])) == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[d]</span><span class="s3">,</span>
                            <span class="s1">define_macros=[(</span><span class="s4">'SCIPY_DJBFFT_H'</span><span class="s3">, None</span><span class="s1">)])</span>
                <span class="s1">self.set_info(**info)</span>
                <span class="s3">return</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">mkl_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'mkl'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'MKLROOT'</span>
    <span class="s1">_lib_mkl = [</span><span class="s4">'mkl_rt'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_mkl_rootdir(self):</span>
        <span class="s1">mklroot = os.environ.get(</span><span class="s4">'MKLROOT'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">mklroot </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">mklroot</span>
        <span class="s1">paths = os.environ.get(</span><span class="s4">'LD_LIBRARY_PATH'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).split(os.pathsep)</span>
        <span class="s1">ld_so_conf = </span><span class="s4">'/etc/ld.so.conf'</span>
        <span class="s3">if </span><span class="s1">os.path.isfile(ld_so_conf):</span>
            <span class="s3">with </span><span class="s1">open(ld_so_conf</span><span class="s3">, </span><span class="s4">'r'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">f:</span>
                    <span class="s1">d = d.strip()</span>
                    <span class="s3">if </span><span class="s1">d:</span>
                        <span class="s1">paths.append(d)</span>
        <span class="s1">intel_mkl_dirs = []</span>
        <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">paths:</span>
            <span class="s1">path_atoms = path.split(os.sep)</span>
            <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">path_atoms:</span>
                <span class="s3">if </span><span class="s1">m.startswith(</span><span class="s4">'mkl'</span><span class="s1">):</span>
                    <span class="s1">d = os.sep.join(path_atoms[:path_atoms.index(m) + </span><span class="s5">2</span><span class="s1">])</span>
                    <span class="s1">intel_mkl_dirs.append(d)</span>
                    <span class="s3">break</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">paths:</span>
            <span class="s1">dirs = glob(os.path.join(d</span><span class="s3">, </span><span class="s4">'mkl'</span><span class="s3">, </span><span class="s4">'*'</span><span class="s1">))</span>
            <span class="s1">dirs += glob(os.path.join(d</span><span class="s3">, </span><span class="s4">'mkl*'</span><span class="s1">))</span>
            <span class="s3">for </span><span class="s1">sub_dir </span><span class="s3">in </span><span class="s1">dirs:</span>
                <span class="s3">if </span><span class="s1">os.path.isdir(os.path.join(sub_dir</span><span class="s3">, </span><span class="s4">'lib'</span><span class="s1">)):</span>
                    <span class="s3">return </span><span class="s1">sub_dir</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">mklroot = self.get_mkl_rootdir()</span>
        <span class="s3">if </span><span class="s1">mklroot </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">system_info.__init__(self)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">from </span><span class="s1">.cpuinfo </span><span class="s3">import </span><span class="s1">cpu</span>
            <span class="s3">if </span><span class="s1">cpu.is_Itanium():</span>
                <span class="s1">plt = </span><span class="s4">'64'</span>
            <span class="s3">elif </span><span class="s1">cpu.is_Intel() </span><span class="s3">and </span><span class="s1">cpu.is_64bit():</span>
                <span class="s1">plt = </span><span class="s4">'intel64'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">plt = </span><span class="s4">'32'</span>
            <span class="s1">system_info.__init__(</span>
                <span class="s1">self</span><span class="s3">,</span>
                <span class="s1">default_lib_dirs=[os.path.join(mklroot</span><span class="s3">, </span><span class="s4">'lib'</span><span class="s3">, </span><span class="s1">plt)]</span><span class="s3">,</span>
                <span class="s1">default_include_dirs=[os.path.join(mklroot</span><span class="s3">, </span><span class="s4">'include'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">incl_dirs = self.get_include_dirs()</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'mkl_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">mkl_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_mkl)</span>
        <span class="s1">info = self.check_libs2(lib_dirs</span><span class="s3">, </span><span class="s1">mkl_libs)</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">dict_append(info</span><span class="s3">,</span>
                    <span class="s1">define_macros=[(</span><span class="s4">'SCIPY_MKL_H'</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
                                   <span class="s1">(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span><span class="s3">,</span>
                    <span class="s1">include_dirs=incl_dirs)</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
            <span class="s3">pass  </span><span class="s0"># win32 has no pthread library</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">libraries=[</span><span class="s4">'pthread'</span><span class="s1">])</span>
        <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">lapack_mkl_info(mkl_info):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">blas_mkl_info(mkl_info):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">armpl_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'armpl'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'ARMPL_DIR'</span>
    <span class="s1">_lib_armpl = [</span><span class="s4">'armpl_lp64_mp'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">incl_dirs = self.get_include_dirs()</span>
        <span class="s1">armpl_libs = self.get_libs(</span><span class="s4">'armpl_libs'</span><span class="s3">, </span><span class="s1">self._lib_armpl)</span>
        <span class="s1">info = self.check_libs2(lib_dirs</span><span class="s3">, </span><span class="s1">armpl_libs)</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">dict_append(info</span><span class="s3">,</span>
                    <span class="s1">define_macros=[(</span><span class="s4">'SCIPY_MKL_H'</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
                                   <span class="s1">(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span><span class="s3">,</span>
                    <span class="s1">include_dirs=incl_dirs)</span>
        <span class="s1">self.set_info(**info)</span>

<span class="s3">class </span><span class="s1">lapack_armpl_info(armpl_info):</span>
    <span class="s3">pass</span>

<span class="s3">class </span><span class="s1">blas_armpl_info(armpl_info):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">atlas_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'atlas'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'ATLAS'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'f77blas'</span><span class="s3">, </span><span class="s4">'cblas'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">sys.platform[:</span><span class="s5">7</span><span class="s1">] == </span><span class="s4">'freebsd'</span><span class="s1">:</span>
        <span class="s1">_lib_atlas = [</span><span class="s4">'atlas_r'</span><span class="s1">]</span>
        <span class="s1">_lib_lapack = [</span><span class="s4">'alapack_r'</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">_lib_atlas = [</span><span class="s4">'atlas'</span><span class="s1">]</span>
        <span class="s1">_lib_lapack = [</span><span class="s4">'lapack'</span><span class="s1">]</span>

    <span class="s1">notfounderror = AtlasNotFoundError</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">pre_dirs = system_info.get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">dirs = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">pre_dirs:</span>
            <span class="s1">dirs.extend(self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'atlas*'</span><span class="s3">, </span><span class="s4">'ATLAS*'</span><span class="s3">,</span>
                                         <span class="s4">'sse'</span><span class="s3">, </span><span class="s4">'3dnow'</span><span class="s3">, </span><span class="s4">'sse2'</span><span class="s1">]) + [d])</span>
        <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(d)]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">info = {}</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'atlas_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">atlas_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names + self._lib_atlas)</span>
        <span class="s1">lapack_libs = self.get_libs(</span><span class="s4">'lapack_libs'</span><span class="s3">, </span><span class="s1">self._lib_lapack)</span>
        <span class="s1">atlas = </span><span class="s3">None</span>
        <span class="s1">lapack = </span><span class="s3">None</span>
        <span class="s1">atlas_1 = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">lib_dirs:</span>
            <span class="s1">atlas = self.check_libs2(d</span><span class="s3">, </span><span class="s1">atlas_libs</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s3">if </span><span class="s1">atlas </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">lib_dirs2 = [d] + self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'atlas*'</span><span class="s3">, </span><span class="s4">'ATLAS*'</span><span class="s1">])</span>
                <span class="s1">lapack = self.check_libs2(lib_dirs2</span><span class="s3">, </span><span class="s1">lapack_libs</span><span class="s3">, </span><span class="s1">[])</span>
                <span class="s3">if </span><span class="s1">lapack </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">atlas:</span>
                <span class="s1">atlas_1 = atlas</span>
        <span class="s1">log.info(self.__class__)</span>
        <span class="s3">if </span><span class="s1">atlas </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">atlas = atlas_1</span>
        <span class="s3">if </span><span class="s1">atlas </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">include_dirs = self.get_include_dirs()</span>
        <span class="s1">h = (self.combine_paths(lib_dirs + include_dirs</span><span class="s3">, </span><span class="s4">'cblas.h'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">[</span><span class="s3">None</span><span class="s1">])</span>
        <span class="s1">h = h[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">h:</span>
            <span class="s1">h = os.path.dirname(h)</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[h])</span>
        <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'c'</span>
        <span class="s3">if </span><span class="s1">lapack </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**lapack)</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**atlas)</span>
        <span class="s3">elif </span><span class="s4">'lapack_atlas' </span><span class="s3">in </span><span class="s1">atlas[</span><span class="s4">'libraries'</span><span class="s1">]:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**atlas)</span>
            <span class="s1">dict_append(info</span><span class="s3">,</span>
                        <span class="s1">define_macros=[(</span><span class="s4">'ATLAS_WITH_LAPACK_ATLAS'</span><span class="s3">, None</span><span class="s1">)])</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**atlas)</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span><span class="s4">'ATLAS_WITHOUT_LAPACK'</span><span class="s3">, None</span><span class="s1">)])</span>
            <span class="s1">message = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
                ********************************************************************* 
                    Could not find lapack library within the ATLAS installation. 
                ********************************************************************* 
                &quot;&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(message</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return</span>

        <span class="s0"># Check if lapack library is complete, only warn if it is not.</span>
        <span class="s1">lapack_dir = lapack[</span><span class="s4">'library_dirs'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">lapack_name = lapack[</span><span class="s4">'libraries'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">lapack_lib = </span><span class="s3">None</span>
        <span class="s1">lib_prefixes = [</span><span class="s4">'lib'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
            <span class="s1">lib_prefixes.append(</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.library_extensions():</span>
            <span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">lib_prefixes:</span>
                <span class="s1">fn = os.path.join(lapack_dir</span><span class="s3">, </span><span class="s1">prefix + lapack_name + e)</span>
                <span class="s3">if </span><span class="s1">os.path.exists(fn):</span>
                    <span class="s1">lapack_lib = fn</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">lapack_lib:</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">lapack_lib </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">sz = os.stat(lapack_lib)[</span><span class="s5">6</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">sz &lt;= </span><span class="s5">4000 </span><span class="s1">* </span><span class="s5">1024</span><span class="s1">:</span>
                <span class="s1">message = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
                    ********************************************************************* 
                        Lapack library (from ATLAS) is probably incomplete: 
                          size of %s is %sk (expected &gt;4000k) 
 
                        Follow the instructions in the KNOWN PROBLEMS section of the file 
                        numpy/INSTALL.txt. 
                    ********************************************************************* 
                    &quot;&quot;&quot;</span><span class="s1">) % (lapack_lib</span><span class="s3">, </span><span class="s1">sz / </span><span class="s5">1024</span><span class="s1">)</span>
                <span class="s1">warnings.warn(message</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'f77'</span>

        <span class="s1">atlas_version</span><span class="s3">, </span><span class="s1">atlas_extra_info = get_atlas_version(**atlas)</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**atlas_extra_info)</span>

        <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">atlas_blas_info(atlas_info):</span>
    <span class="s1">_lib_names = [</span><span class="s4">'f77blas'</span><span class="s3">, </span><span class="s4">'cblas'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">info = {}</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'atlas_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">atlas_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names + self._lib_atlas)</span>
        <span class="s1">atlas = self.check_libs2(lib_dirs</span><span class="s3">, </span><span class="s1">atlas_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">atlas </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">include_dirs = self.get_include_dirs()</span>
        <span class="s1">h = (self.combine_paths(lib_dirs + include_dirs</span><span class="s3">, </span><span class="s4">'cblas.h'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">[</span><span class="s3">None</span><span class="s1">])</span>
        <span class="s1">h = h[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">h:</span>
            <span class="s1">h = os.path.dirname(h)</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[h])</span>
        <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'c'</span>
        <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = [(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span>

        <span class="s1">atlas_version</span><span class="s3">, </span><span class="s1">atlas_extra_info = get_atlas_version(**atlas)</span>
        <span class="s1">dict_append(atlas</span><span class="s3">, </span><span class="s1">**atlas_extra_info)</span>

        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**atlas)</span>

        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">atlas_threads_info(atlas_info):</span>
    <span class="s1">dir_env_var = [</span><span class="s4">'PTATLAS'</span><span class="s3">, </span><span class="s4">'ATLAS'</span><span class="s1">]</span>
    <span class="s1">_lib_names = [</span><span class="s4">'ptf77blas'</span><span class="s3">, </span><span class="s4">'ptcblas'</span><span class="s1">]</span>


<span class="s3">class </span><span class="s1">atlas_blas_threads_info(atlas_blas_info):</span>
    <span class="s1">dir_env_var = [</span><span class="s4">'PTATLAS'</span><span class="s3">, </span><span class="s4">'ATLAS'</span><span class="s1">]</span>
    <span class="s1">_lib_names = [</span><span class="s4">'ptf77blas'</span><span class="s3">, </span><span class="s4">'ptcblas'</span><span class="s1">]</span>


<span class="s3">class </span><span class="s1">lapack_atlas_info(atlas_info):</span>
    <span class="s1">_lib_names = [</span><span class="s4">'lapack_atlas'</span><span class="s1">] + atlas_info._lib_names</span>


<span class="s3">class </span><span class="s1">lapack_atlas_threads_info(atlas_threads_info):</span>
    <span class="s1">_lib_names = [</span><span class="s4">'lapack_atlas'</span><span class="s1">] + atlas_threads_info._lib_names</span>


<span class="s3">class </span><span class="s1">atlas_3_10_info(atlas_info):</span>
    <span class="s1">_lib_names = [</span><span class="s4">'satlas'</span><span class="s1">]</span>
    <span class="s1">_lib_atlas = _lib_names</span>
    <span class="s1">_lib_lapack = _lib_names</span>


<span class="s3">class </span><span class="s1">atlas_3_10_blas_info(atlas_3_10_info):</span>
    <span class="s1">_lib_names = [</span><span class="s4">'satlas'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">info = {}</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'atlas_lib'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">atlas_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">atlas = self.check_libs2(lib_dirs</span><span class="s3">, </span><span class="s1">atlas_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">atlas </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">include_dirs = self.get_include_dirs()</span>
        <span class="s1">h = (self.combine_paths(lib_dirs + include_dirs</span><span class="s3">, </span><span class="s4">'cblas.h'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">[</span><span class="s3">None</span><span class="s1">])</span>
        <span class="s1">h = h[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">h:</span>
            <span class="s1">h = os.path.dirname(h)</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[h])</span>
        <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'c'</span>
        <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = [(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span>

        <span class="s1">atlas_version</span><span class="s3">, </span><span class="s1">atlas_extra_info = get_atlas_version(**atlas)</span>
        <span class="s1">dict_append(atlas</span><span class="s3">, </span><span class="s1">**atlas_extra_info)</span>

        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**atlas)</span>

        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">atlas_3_10_threads_info(atlas_3_10_info):</span>
    <span class="s1">dir_env_var = [</span><span class="s4">'PTATLAS'</span><span class="s3">, </span><span class="s4">'ATLAS'</span><span class="s1">]</span>
    <span class="s1">_lib_names = [</span><span class="s4">'tatlas'</span><span class="s1">]</span>
    <span class="s1">_lib_atlas = _lib_names</span>
    <span class="s1">_lib_lapack = _lib_names</span>


<span class="s3">class </span><span class="s1">atlas_3_10_blas_threads_info(atlas_3_10_blas_info):</span>
    <span class="s1">dir_env_var = [</span><span class="s4">'PTATLAS'</span><span class="s3">, </span><span class="s4">'ATLAS'</span><span class="s1">]</span>
    <span class="s1">_lib_names = [</span><span class="s4">'tatlas'</span><span class="s1">]</span>


<span class="s3">class </span><span class="s1">lapack_atlas_3_10_info(atlas_3_10_info):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">lapack_atlas_3_10_threads_info(atlas_3_10_threads_info):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">lapack_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'lapack'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'LAPACK'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'lapack'</span><span class="s1">]</span>
    <span class="s1">notfounderror = LapackNotFoundError</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>

        <span class="s1">opt = self.get_option_single(</span><span class="s4">'lapack_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">lapack_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">lapack_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'f77'</span>
        <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">lapack_src_info(system_info):</span>
    <span class="s0"># LAPACK_SRC is deprecated, please do not use this!</span>
    <span class="s0"># Build or install a BLAS library via your package manager or from</span>
    <span class="s0"># source separately.</span>
    <span class="s1">section = </span><span class="s4">'lapack_src'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'LAPACK_SRC'</span>
    <span class="s1">notfounderror = LapackSrcNotFoundError</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">pre_dirs = system_info.get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">dirs = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">pre_dirs:</span>
            <span class="s1">dirs.extend([d] + self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'LAPACK*/SRC'</span><span class="s3">, </span><span class="s4">'SRC'</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(d)]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">src_dirs = self.get_src_dirs()</span>
        <span class="s1">src_dir = </span><span class="s4">''</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">src_dirs:</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(os.path.join(d</span><span class="s3">, </span><span class="s4">'dgesv.f'</span><span class="s1">)):</span>
                <span class="s1">src_dir = d</span>
                <span class="s3">break</span>
        <span class="s3">if not </span><span class="s1">src_dir:</span>
            <span class="s0">#XXX: Get sources from netlib. May be ask first.</span>
            <span class="s3">return</span>
        <span class="s0"># The following is extracted from LAPACK-3.0/SRC/Makefile.</span>
        <span class="s0"># Added missing names from lapack-lite-3.1.1/SRC/Makefile</span>
        <span class="s0"># while keeping removed names for Lapack-3.0 compatibility.</span>
        <span class="s1">allaux = </span><span class="s4">''' 
        ilaenv ieeeck lsame lsamen xerbla 
        iparmq 
        '''  </span><span class="s0"># *.f</span>
        <span class="s1">laux = </span><span class="s4">''' 
        bdsdc bdsqr disna labad lacpy ladiv lae2 laebz laed0 laed1 
        laed2 laed3 laed4 laed5 laed6 laed7 laed8 laed9 laeda laev2 
        lagtf lagts lamch lamrg lanst lapy2 lapy3 larnv larrb larre 
        larrf lartg laruv las2 lascl lasd0 lasd1 lasd2 lasd3 lasd4 
        lasd5 lasd6 lasd7 lasd8 lasd9 lasda lasdq lasdt laset lasq1 
        lasq2 lasq3 lasq4 lasq5 lasq6 lasr lasrt lassq lasv2 pttrf 
        stebz stedc steqr sterf 
 
        larra larrc larrd larr larrk larrj larrr laneg laisnan isnan 
        lazq3 lazq4 
        '''  </span><span class="s0"># [s|d]*.f</span>
        <span class="s1">lasrc = </span><span class="s4">''' 
        gbbrd gbcon gbequ gbrfs gbsv gbsvx gbtf2 gbtrf gbtrs gebak 
        gebal gebd2 gebrd gecon geequ gees geesx geev geevx gegs gegv 
        gehd2 gehrd gelq2 gelqf gels gelsd gelss gelsx gelsy geql2 
        geqlf geqp3 geqpf geqr2 geqrf gerfs gerq2 gerqf gesc2 gesdd 
        gesv gesvd gesvx getc2 getf2 getrf getri getrs ggbak ggbal 
        gges ggesx ggev ggevx ggglm gghrd gglse ggqrf ggrqf ggsvd 
        ggsvp gtcon gtrfs gtsv gtsvx gttrf gttrs gtts2 hgeqz hsein 
        hseqr labrd lacon laein lags2 lagtm lahqr lahrd laic1 lals0 
        lalsa lalsd langb lange langt lanhs lansb lansp lansy lantb 
        lantp lantr lapll lapmt laqgb laqge laqp2 laqps laqsb laqsp 
        laqsy lar1v lar2v larf larfb larfg larft larfx largv larrv 
        lartv larz larzb larzt laswp lasyf latbs latdf latps latrd 
        latrs latrz latzm lauu2 lauum pbcon pbequ pbrfs pbstf pbsv 
        pbsvx pbtf2 pbtrf pbtrs pocon poequ porfs posv posvx potf2 
        potrf potri potrs ppcon ppequ pprfs ppsv ppsvx pptrf pptri 
        pptrs ptcon pteqr ptrfs ptsv ptsvx pttrs ptts2 spcon sprfs 
        spsv spsvx sptrf sptri sptrs stegr stein sycon syrfs sysv 
        sysvx sytf2 sytrf sytri sytrs tbcon tbrfs tbtrs tgevc tgex2 
        tgexc tgsen tgsja tgsna tgsy2 tgsyl tpcon tprfs tptri tptrs 
        trcon trevc trexc trrfs trsen trsna trsyl trti2 trtri trtrs 
        tzrqf tzrzf 
 
        lacn2 lahr2 stemr laqr0 laqr1 laqr2 laqr3 laqr4 laqr5 
        '''  </span><span class="s0"># [s|c|d|z]*.f</span>
        <span class="s1">sd_lasrc = </span><span class="s4">''' 
        laexc lag2 lagv2 laln2 lanv2 laqtr lasy2 opgtr opmtr org2l 
        org2r orgbr orghr orgl2 orglq orgql orgqr orgr2 orgrq orgtr 
        orm2l orm2r ormbr ormhr orml2 ormlq ormql ormqr ormr2 ormr3 
        ormrq ormrz ormtr rscl sbev sbevd sbevx sbgst sbgv sbgvd sbgvx 
        sbtrd spev spevd spevx spgst spgv spgvd spgvx sptrd stev stevd 
        stevr stevx syev syevd syevr syevx sygs2 sygst sygv sygvd 
        sygvx sytd2 sytrd 
        '''  </span><span class="s0"># [s|d]*.f</span>
        <span class="s1">cz_lasrc = </span><span class="s4">''' 
        bdsqr hbev hbevd hbevx hbgst hbgv hbgvd hbgvx hbtrd hecon heev 
        heevd heevr heevx hegs2 hegst hegv hegvd hegvx herfs hesv 
        hesvx hetd2 hetf2 hetrd hetrf hetri hetrs hpcon hpev hpevd 
        hpevx hpgst hpgv hpgvd hpgvx hprfs hpsv hpsvx hptrd hptrf 
        hptri hptrs lacgv lacp2 lacpy lacrm lacrt ladiv laed0 laed7 
        laed8 laesy laev2 lahef lanhb lanhe lanhp lanht laqhb laqhe 
        laqhp larcm larnv lartg lascl laset lasr lassq pttrf rot spmv 
        spr stedc steqr symv syr ung2l ung2r ungbr unghr ungl2 unglq 
        ungql ungqr ungr2 ungrq ungtr unm2l unm2r unmbr unmhr unml2 
        unmlq unmql unmqr unmr2 unmr3 unmrq unmrz unmtr upgtr upmtr 
        '''  </span><span class="s0"># [c|z]*.f</span>
        <span class="s0">#######</span>
        <span class="s1">sclaux = laux + </span><span class="s4">' econd '                  </span><span class="s0"># s*.f</span>
        <span class="s1">dzlaux = laux + </span><span class="s4">' secnd '                  </span><span class="s0"># d*.f</span>
        <span class="s1">slasrc = lasrc + sd_lasrc                  </span><span class="s0"># s*.f</span>
        <span class="s1">dlasrc = lasrc + sd_lasrc                  </span><span class="s0"># d*.f</span>
        <span class="s1">clasrc = lasrc + cz_lasrc + </span><span class="s4">' srot srscl '  </span><span class="s0"># c*.f</span>
        <span class="s1">zlasrc = lasrc + cz_lasrc + </span><span class="s4">' drot drscl '  </span><span class="s0"># z*.f</span>
        <span class="s1">oclasrc = </span><span class="s4">' icmax1 scsum1 '                </span><span class="s0"># *.f</span>
        <span class="s1">ozlasrc = </span><span class="s4">' izmax1 dzsum1 '                </span><span class="s0"># *.f</span>
        <span class="s1">sources = [</span><span class="s4">'s%s.f' </span><span class="s1">% f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">(sclaux + slasrc).split()] \</span>
                  <span class="s1">+ [</span><span class="s4">'d%s.f' </span><span class="s1">% f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">(dzlaux + dlasrc).split()] \</span>
                  <span class="s1">+ [</span><span class="s4">'c%s.f' </span><span class="s1">% f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">(clasrc).split()] \</span>
                  <span class="s1">+ [</span><span class="s4">'z%s.f' </span><span class="s1">% f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">(zlasrc).split()] \</span>
                  <span class="s1">+ [</span><span class="s4">'%s.f' </span><span class="s1">% f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">(allaux + oclasrc + ozlasrc).split()]</span>
        <span class="s1">sources = [os.path.join(src_dir</span><span class="s3">, </span><span class="s1">f) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">sources]</span>
        <span class="s0"># Lapack 3.1:</span>
        <span class="s1">src_dir2 = os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'..'</span><span class="s3">, </span><span class="s4">'INSTALL'</span><span class="s1">)</span>
        <span class="s1">sources += [os.path.join(src_dir2</span><span class="s3">, </span><span class="s1">p + </span><span class="s4">'lamch.f'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s4">'sdcz'</span><span class="s1">]</span>
        <span class="s0"># Lapack 3.2.1:</span>
        <span class="s1">sources += [os.path.join(src_dir</span><span class="s3">, </span><span class="s1">p + </span><span class="s4">'larfp.f'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s4">'sdcz'</span><span class="s1">]</span>
        <span class="s1">sources += [os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'ila' </span><span class="s1">+ p + </span><span class="s4">'lr.f'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s4">'sdcz'</span><span class="s1">]</span>
        <span class="s1">sources += [os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'ila' </span><span class="s1">+ p + </span><span class="s4">'lc.f'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s4">'sdcz'</span><span class="s1">]</span>
        <span class="s0"># Should we check here actual existence of source files?</span>
        <span class="s0"># Yes, the file listing is different between 3.0 and 3.1</span>
        <span class="s0"># versions.</span>
        <span class="s1">sources = [f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">sources </span><span class="s3">if </span><span class="s1">os.path.isfile(f)]</span>
        <span class="s1">info = {</span><span class="s4">'sources'</span><span class="s1">: sources</span><span class="s3">, </span><span class="s4">'language'</span><span class="s1">: </span><span class="s4">'f77'</span><span class="s1">}</span>
        <span class="s1">self.set_info(**info)</span>

<span class="s1">atlas_version_c_text = </span><span class="s4">r''' 
/* This file is generated from numpy/distutils/system_info.py */ 
void ATL_buildinfo(void); 
int main(void) { 
  ATL_buildinfo(); 
  return 0; 
} 
'''</span>

<span class="s1">_cached_atlas_version = {}</span>


<span class="s3">def </span><span class="s1">get_atlas_version(**config):</span>
    <span class="s1">libraries = config.get(</span><span class="s4">'libraries'</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s1">library_dirs = config.get(</span><span class="s4">'library_dirs'</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s1">key = (tuple(libraries)</span><span class="s3">, </span><span class="s1">tuple(library_dirs))</span>
    <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">_cached_atlas_version:</span>
        <span class="s3">return </span><span class="s1">_cached_atlas_version[key]</span>
    <span class="s1">c = cmd_config(Distribution())</span>
    <span class="s1">atlas_version = </span><span class="s3">None</span>
    <span class="s1">info = {}</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = c.get_output(atlas_version_c_text</span><span class="s3">,</span>
                            <span class="s1">libraries=libraries</span><span class="s3">, </span><span class="s1">library_dirs=library_dirs</span><span class="s3">,</span>
                           <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">s </span><span class="s3">and </span><span class="s1">re.search(</span><span class="s4">r'undefined reference to `_gfortran'</span><span class="s3">, </span><span class="s1">o</span><span class="s3">, </span><span class="s1">re.M):</span>
            <span class="s1">s</span><span class="s3">, </span><span class="s1">o = c.get_output(atlas_version_c_text</span><span class="s3">,</span>
                                <span class="s1">libraries=libraries + [</span><span class="s4">'gfortran'</span><span class="s1">]</span><span class="s3">,</span>
                                <span class="s1">library_dirs=library_dirs</span><span class="s3">,</span>
                               <span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">s:</span>
                <span class="s1">warnings.warn(textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
                    ***************************************************** 
                    Linkage with ATLAS requires gfortran. Use 
 
                      python setup.py config_fc --fcompiler=gnu95 ... 
 
                    when building extension libraries that use ATLAS. 
                    Make sure that -lgfortran is used for C++ extensions. 
                    ***************************************************** 
                    &quot;&quot;&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">language=</span><span class="s4">'f90'</span><span class="s3">,</span>
                            <span class="s1">define_macros=[(</span><span class="s4">'ATLAS_REQUIRES_GFORTRAN'</span><span class="s3">, None</span><span class="s1">)])</span>
    <span class="s3">except </span><span class="s1">Exception:  </span><span class="s0"># failed to get version from file -- maybe on Windows</span>
        <span class="s0"># look at directory name</span>
        <span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">library_dirs:</span>
            <span class="s1">m = re.search(</span><span class="s4">r'ATLAS_(?P&lt;version&gt;\d+[.]\d+[.]\d+)_'</span><span class="s3">, </span><span class="s1">o)</span>
            <span class="s3">if </span><span class="s1">m:</span>
                <span class="s1">atlas_version = m.group(</span><span class="s4">'version'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">atlas_version </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">break</span>

        <span class="s0"># final choice --- look at ATLAS_VERSION environment</span>
        <span class="s0">#   variable</span>
        <span class="s3">if </span><span class="s1">atlas_version </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">atlas_version = os.environ.get(</span><span class="s4">'ATLAS_VERSION'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">atlas_version:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span>
                <span class="s4">'ATLAS_INFO'</span><span class="s3">, </span><span class="s1">_c_string_literal(atlas_version))</span>
            <span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span><span class="s4">'NO_ATLAS_INFO'</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)])</span>
        <span class="s3">return </span><span class="s1">atlas_version </span><span class="s3">or </span><span class="s4">'?.?.?'</span><span class="s3">, </span><span class="s1">info</span>

    <span class="s3">if not </span><span class="s1">s:</span>
        <span class="s1">m = re.search(</span><span class="s4">r'ATLAS version (?P&lt;version&gt;\d+[.]\d+[.]\d+)'</span><span class="s3">, </span><span class="s1">o)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">atlas_version = m.group(</span><span class="s4">'version'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">atlas_version </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">re.search(</span><span class="s4">r'undefined symbol: ATL_buildinfo'</span><span class="s3">, </span><span class="s1">o</span><span class="s3">, </span><span class="s1">re.M):</span>
            <span class="s1">atlas_version = </span><span class="s4">'3.2.1_pre3.3.6'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">log.info(</span><span class="s4">'Status: %d'</span><span class="s3">, </span><span class="s1">s)</span>
            <span class="s1">log.info(</span><span class="s4">'Output: %s'</span><span class="s3">, </span><span class="s1">o)</span>

    <span class="s3">elif </span><span class="s1">atlas_version == </span><span class="s4">'3.2.1_pre3.3.6'</span><span class="s1">:</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span><span class="s4">'NO_ATLAS_INFO'</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span>
            <span class="s4">'ATLAS_INFO'</span><span class="s3">, </span><span class="s1">_c_string_literal(atlas_version))</span>
        <span class="s1">])</span>
    <span class="s1">result = _cached_atlas_version[key] = atlas_version</span><span class="s3">, </span><span class="s1">info</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">lapack_opt_info(system_info):</span>
    <span class="s1">notfounderror = LapackNotFoundError</span>

    <span class="s0"># List of all known LAPACK libraries, in the default order</span>
    <span class="s1">lapack_order = [</span><span class="s4">'armpl'</span><span class="s3">, </span><span class="s4">'mkl'</span><span class="s3">, </span><span class="s4">'openblas'</span><span class="s3">, </span><span class="s4">'flame'</span><span class="s3">,</span>
                    <span class="s4">'accelerate'</span><span class="s3">, </span><span class="s4">'atlas'</span><span class="s3">, </span><span class="s4">'lapack'</span><span class="s1">]</span>
    <span class="s1">order_env_var_name = </span><span class="s4">'NPY_LAPACK_ORDER'</span>
    
    <span class="s3">def </span><span class="s1">_calc_info_armpl(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'lapack_armpl'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_mkl(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'lapack_mkl'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_openblas(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'openblas_lapack'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s1">info = get_info(</span><span class="s4">'openblas_clapack'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_flame(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'flame'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_atlas(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'atlas_3_10_threads'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">info = get_info(</span><span class="s4">'atlas_3_10'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">info = get_info(</span><span class="s4">'atlas_threads'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">info = get_info(</span><span class="s4">'atlas'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s0"># Figure out if ATLAS has lapack...</span>
            <span class="s0"># If not we need the lapack library, but not BLAS!</span>
            <span class="s1">l = info.get(</span><span class="s4">'define_macros'</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'ATLAS_WITH_LAPACK_ATLAS'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">in </span><span class="s1">l \</span>
               <span class="s3">or </span><span class="s1">(</span><span class="s4">'ATLAS_WITHOUT_LAPACK'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">in </span><span class="s1">l:</span>
                <span class="s0"># Get LAPACK (with possible warnings)</span>
                <span class="s0"># If not found we don't accept anything</span>
                <span class="s0"># since we can't use ATLAS with LAPACK!</span>
                <span class="s1">lapack_info = self._get_info_lapack()</span>
                <span class="s3">if not </span><span class="s1">lapack_info:</span>
                    <span class="s3">return False</span>
                <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**lapack_info)</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_accelerate(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'accelerate'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_get_info_blas(self):</span>
        <span class="s0"># Default to get the optimized BLAS implementation</span>
        <span class="s1">info = get_info(</span><span class="s4">'blas_opt'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">warnings.warn(BlasNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
            <span class="s1">info_src = get_info(</span><span class="s4">'blas_src'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">info_src:</span>
                <span class="s1">warnings.warn(BlasSrcNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">{}</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">libraries=[(</span><span class="s4">'fblas_src'</span><span class="s3">, </span><span class="s1">info_src)])</span>
        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">_get_info_lapack(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'lapack'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">warnings.warn(LapackNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
            <span class="s1">info_src = get_info(</span><span class="s4">'lapack_src'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">info_src:</span>
                <span class="s1">warnings.warn(LapackSrcNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">{}</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">libraries=[(</span><span class="s4">'flapack_src'</span><span class="s3">, </span><span class="s1">info_src)])</span>
        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">_calc_info_lapack(self):</span>
        <span class="s1">info = self._get_info_lapack()</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">info_blas = self._get_info_blas()</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**info_blas)</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span><span class="s4">'NO_ATLAS_INFO'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)])</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_from_envvar(self):</span>
        <span class="s1">info = {}</span>
        <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'f77'</span>
        <span class="s1">info[</span><span class="s4">'libraries'</span><span class="s1">] = []</span>
        <span class="s1">info[</span><span class="s4">'include_dirs'</span><span class="s1">] = []</span>
        <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = []</span>
        <span class="s1">info[</span><span class="s4">'extra_link_args'</span><span class="s1">] = os.environ[</span><span class="s4">'NPY_LAPACK_LIBS'</span><span class="s1">].split()</span>
        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_calc_info(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s4">'_calc_info_{}'</span><span class="s1">.format(name))()</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lapack_order</span><span class="s3">, </span><span class="s1">unknown_order = _parse_env_order(self.lapack_order</span><span class="s3">, </span><span class="s1">self.order_env_var_name)</span>
        <span class="s3">if </span><span class="s1">len(unknown_order) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;lapack_opt_info user defined &quot;</span>
                             <span class="s4">&quot;LAPACK order has unacceptable &quot;</span>
                             <span class="s4">&quot;values: {}&quot;</span><span class="s1">.format(unknown_order))</span>

        <span class="s3">if </span><span class="s4">'NPY_LAPACK_LIBS' </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s0"># Bypass autodetection, set language to F77 and use env var linker</span>
            <span class="s0"># flags directly</span>
            <span class="s1">self._calc_info_from_envvar()</span>
            <span class="s3">return</span>

        <span class="s3">for </span><span class="s1">lapack </span><span class="s3">in </span><span class="s1">lapack_order:</span>
            <span class="s3">if </span><span class="s1">self._calc_info(lapack):</span>
                <span class="s3">return</span>

        <span class="s3">if </span><span class="s4">'lapack' </span><span class="s3">not in </span><span class="s1">lapack_order:</span>
            <span class="s0"># Since the user may request *not* to use any library, we still need</span>
            <span class="s0"># to raise warnings to signal missing packages!</span>
            <span class="s1">warnings.warn(LapackNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">warnings.warn(LapackSrcNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">_ilp64_opt_info_mixin:</span>
    <span class="s1">symbol_suffix = </span><span class="s3">None</span>
    <span class="s1">symbol_prefix = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">_check_info(self</span><span class="s3">, </span><span class="s1">info):</span>
        <span class="s1">macros = dict(info.get(</span><span class="s4">'define_macros'</span><span class="s3">, </span><span class="s1">[]))</span>
        <span class="s1">prefix = macros.get(</span><span class="s4">'BLAS_SYMBOL_PREFIX'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">suffix = macros.get(</span><span class="s4">'BLAS_SYMBOL_SUFFIX'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.symbol_prefix </span><span class="s3">not in </span><span class="s1">(</span><span class="s3">None, </span><span class="s1">prefix):</span>
            <span class="s3">return False</span>

        <span class="s3">if </span><span class="s1">self.symbol_suffix </span><span class="s3">not in </span><span class="s1">(</span><span class="s3">None, </span><span class="s1">suffix):</span>
            <span class="s3">return False</span>

        <span class="s3">return </span><span class="s1">bool(info)</span>


<span class="s3">class </span><span class="s1">lapack_ilp64_opt_info(lapack_opt_info</span><span class="s3">, </span><span class="s1">_ilp64_opt_info_mixin):</span>
    <span class="s1">notfounderror = LapackILP64NotFoundError</span>
    <span class="s1">lapack_order = [</span><span class="s4">'openblas64_'</span><span class="s3">, </span><span class="s4">'openblas_ilp64'</span><span class="s1">]</span>
    <span class="s1">order_env_var_name = </span><span class="s4">'NPY_LAPACK_ILP64_ORDER'</span>

    <span class="s3">def </span><span class="s1">_calc_info(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">info = get_info(name + </span><span class="s4">'_lapack'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self._check_info(info):</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>


<span class="s3">class </span><span class="s1">lapack_ilp64_plain_opt_info(lapack_ilp64_opt_info):</span>
    <span class="s0"># Same as lapack_ilp64_opt_info, but fix symbol names</span>
    <span class="s1">symbol_prefix = </span><span class="s4">''</span>
    <span class="s1">symbol_suffix = </span><span class="s4">''</span>


<span class="s3">class </span><span class="s1">lapack64__opt_info(lapack_ilp64_opt_info):</span>
    <span class="s1">symbol_prefix = </span><span class="s4">''</span>
    <span class="s1">symbol_suffix = </span><span class="s4">'64_'</span>


<span class="s3">class </span><span class="s1">blas_opt_info(system_info):</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>
    <span class="s0"># List of all known BLAS libraries, in the default order</span>

    <span class="s1">blas_order = [</span><span class="s4">'armpl'</span><span class="s3">, </span><span class="s4">'mkl'</span><span class="s3">, </span><span class="s4">'blis'</span><span class="s3">, </span><span class="s4">'openblas'</span><span class="s3">,</span>
                  <span class="s4">'accelerate'</span><span class="s3">, </span><span class="s4">'atlas'</span><span class="s3">, </span><span class="s4">'blas'</span><span class="s1">]</span>
    <span class="s1">order_env_var_name = </span><span class="s4">'NPY_BLAS_ORDER'</span>
    
    <span class="s3">def </span><span class="s1">_calc_info_armpl(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'blas_armpl'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_mkl(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'blas_mkl'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_blis(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'blis'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_openblas(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'openblas'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_atlas(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'atlas_3_10_blas_threads'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">info = get_info(</span><span class="s4">'atlas_3_10_blas'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">info = get_info(</span><span class="s4">'atlas_blas_threads'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">info:</span>
            <span class="s1">info = get_info(</span><span class="s4">'atlas_blas'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_accelerate(self):</span>
        <span class="s1">info = get_info(</span><span class="s4">'accelerate'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_calc_info_blas(self):</span>
        <span class="s0"># Warn about a non-optimized BLAS library</span>
        <span class="s1">warnings.warn(BlasOptNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">info = {}</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=[(</span><span class="s4">'NO_ATLAS_INFO'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)])</span>

        <span class="s1">blas = get_info(</span><span class="s4">'blas'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">blas:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**blas)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Not even BLAS was found!</span>
            <span class="s1">warnings.warn(BlasNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>

            <span class="s1">blas_src = get_info(</span><span class="s4">'blas_src'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">blas_src:</span>
                <span class="s1">warnings.warn(BlasSrcNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
                <span class="s3">return False</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">libraries=[(</span><span class="s4">'fblas_src'</span><span class="s3">, </span><span class="s1">blas_src)])</span>

        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_calc_info_from_envvar(self):</span>
        <span class="s1">info = {}</span>
        <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'f77'</span>
        <span class="s1">info[</span><span class="s4">'libraries'</span><span class="s1">] = []</span>
        <span class="s1">info[</span><span class="s4">'include_dirs'</span><span class="s1">] = []</span>
        <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = []</span>
        <span class="s1">info[</span><span class="s4">'extra_link_args'</span><span class="s1">] = os.environ[</span><span class="s4">'NPY_BLAS_LIBS'</span><span class="s1">].split()</span>
        <span class="s3">if </span><span class="s4">'NPY_CBLAS_LIBS' </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">].append((</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">))</span>
            <span class="s1">info[</span><span class="s4">'extra_link_args'</span><span class="s1">].extend(</span>
                                        <span class="s1">os.environ[</span><span class="s4">'NPY_CBLAS_LIBS'</span><span class="s1">].split())</span>
        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_calc_info(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s4">'_calc_info_{}'</span><span class="s1">.format(name))()</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">blas_order</span><span class="s3">, </span><span class="s1">unknown_order = _parse_env_order(self.blas_order</span><span class="s3">, </span><span class="s1">self.order_env_var_name)</span>
        <span class="s3">if </span><span class="s1">len(unknown_order) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;blas_opt_info user defined BLAS order has unacceptable values: {}&quot;</span><span class="s1">.format(unknown_order))</span>

        <span class="s3">if </span><span class="s4">'NPY_BLAS_LIBS' </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s0"># Bypass autodetection, set language to F77 and use env var linker</span>
            <span class="s0"># flags directly</span>
            <span class="s1">self._calc_info_from_envvar()</span>
            <span class="s3">return</span>

        <span class="s3">for </span><span class="s1">blas </span><span class="s3">in </span><span class="s1">blas_order:</span>
            <span class="s3">if </span><span class="s1">self._calc_info(blas):</span>
                <span class="s3">return</span>

        <span class="s3">if </span><span class="s4">'blas' </span><span class="s3">not in </span><span class="s1">blas_order:</span>
            <span class="s0"># Since the user may request *not* to use any library, we still need</span>
            <span class="s0"># to raise warnings to signal missing packages!</span>
            <span class="s1">warnings.warn(BlasNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">warnings.warn(BlasSrcNotFoundError.__doc__ </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">blas_ilp64_opt_info(blas_opt_info</span><span class="s3">, </span><span class="s1">_ilp64_opt_info_mixin):</span>
    <span class="s1">notfounderror = BlasILP64NotFoundError</span>
    <span class="s1">blas_order = [</span><span class="s4">'openblas64_'</span><span class="s3">, </span><span class="s4">'openblas_ilp64'</span><span class="s1">]</span>
    <span class="s1">order_env_var_name = </span><span class="s4">'NPY_BLAS_ILP64_ORDER'</span>

    <span class="s3">def </span><span class="s1">_calc_info(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">info = get_info(name)</span>
        <span class="s3">if </span><span class="s1">self._check_info(info):</span>
            <span class="s1">self.set_info(**info)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>


<span class="s3">class </span><span class="s1">blas_ilp64_plain_opt_info(blas_ilp64_opt_info):</span>
    <span class="s1">symbol_prefix = </span><span class="s4">''</span>
    <span class="s1">symbol_suffix = </span><span class="s4">''</span>


<span class="s3">class </span><span class="s1">blas64__opt_info(blas_ilp64_opt_info):</span>
    <span class="s1">symbol_prefix = </span><span class="s4">''</span>
    <span class="s1">symbol_suffix = </span><span class="s4">'64_'</span>


<span class="s3">class </span><span class="s1">cblas_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'cblas'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'CBLAS'</span>
    <span class="s0"># No default as it's used only in blas_info</span>
    <span class="s1">_lib_names = []</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>


<span class="s3">class </span><span class="s1">blas_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'blas'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'BLAS'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'blas'</span><span class="s1">]</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'blas_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">blas_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">blas_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">info[</span><span class="s4">'include_dirs'</span><span class="s1">] = self.get_include_dirs()</span>
        <span class="s3">if </span><span class="s1">platform.system() == </span><span class="s4">'Windows'</span><span class="s1">:</span>
            <span class="s0"># The check for windows is needed because get_cblas_libs uses the</span>
            <span class="s0"># same compiler that was used to compile Python and msvc is</span>
            <span class="s0"># often not installed when mingw is being used. This rough</span>
            <span class="s0"># treatment is not desirable, but windows is tricky.</span>
            <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'f77'  </span><span class="s0"># XXX: is it generally true?</span>
            <span class="s0"># If cblas is given as an option, use those</span>
            <span class="s1">cblas_info_obj = cblas_info()</span>
            <span class="s1">cblas_opt = cblas_info_obj.get_option_single(</span><span class="s4">'cblas_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
            <span class="s1">cblas_libs = cblas_info_obj.get_libs(cblas_opt</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">cblas_libs:</span>
                <span class="s1">info[</span><span class="s4">'libraries'</span><span class="s1">] = cblas_libs + blas_libs</span>
                <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = [(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">lib = self.get_cblas_libs(info)</span>
            <span class="s3">if </span><span class="s1">lib </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'c'</span>
                <span class="s1">info[</span><span class="s4">'libraries'</span><span class="s1">] = lib</span>
                <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = [(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span>
        <span class="s1">self.set_info(**info)</span>

    <span class="s3">def </span><span class="s1">get_cblas_libs(self</span><span class="s3">, </span><span class="s1">info):</span>
        <span class="s2">&quot;&quot;&quot; Check whether we can link with CBLAS interface 
 
        This method will search through several combinations of libraries 
        to check whether CBLAS is present: 
 
        1. Libraries in ``info['libraries']``, as is 
        2. As 1. but also explicitly adding ``'cblas'`` as a library 
        3. As 1. but also explicitly adding ``'blas'`` as a library 
        4. Check only library ``'cblas'`` 
        5. Check only library ``'blas'`` 
 
        Parameters 
        ---------- 
        info : dict 
           system information dictionary for compilation and linking 
 
        Returns 
        ------- 
        libraries : list of str or None 
            a list of libraries that enables the use of CBLAS interface. 
            Returns None if not found or a compilation error occurs. 
 
            Since 1.17 returns a list. 
        &quot;&quot;&quot;</span>
        <span class="s0"># primitive cblas check by looking for the header and trying to link</span>
        <span class="s0"># cblas or blas</span>
        <span class="s1">c = customized_ccompiler()</span>
        <span class="s1">tmpdir = tempfile.mkdtemp()</span>
        <span class="s1">s = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
            </span><span class="s4">#include &lt;cblas.h&gt; 
            int main(int argc, const char *argv[]) 
            { 
                double a[4] = {1,2,3,4}; 
                double b[4] = {5,6,7,8}; 
                return cblas_ddot(4, a, 1, b, 1) &gt; 10; 
            }&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">src = os.path.join(tmpdir</span><span class="s3">, </span><span class="s4">'source.c'</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">open(src</span><span class="s3">, </span><span class="s4">'wt'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">f.write(s)</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s0"># check we can compile (find headers)</span>
                <span class="s1">obj = c.compile([src]</span><span class="s3">, </span><span class="s1">output_dir=tmpdir</span><span class="s3">,</span>
                                <span class="s1">include_dirs=self.get_include_dirs())</span>
            <span class="s3">except </span><span class="s1">(distutils.ccompiler.CompileError</span><span class="s3">, </span><span class="s1">distutils.ccompiler.LinkError):</span>
                <span class="s3">return None</span>

            <span class="s0"># check we can link (find library)</span>
            <span class="s0"># some systems have separate cblas and blas libs.</span>
            <span class="s3">for </span><span class="s1">libs </span><span class="s3">in </span><span class="s1">[info[</span><span class="s4">'libraries'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'cblas'</span><span class="s1">] + info[</span><span class="s4">'libraries'</span><span class="s1">]</span><span class="s3">,</span>
                         <span class="s1">[</span><span class="s4">'blas'</span><span class="s1">] + info[</span><span class="s4">'libraries'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'cblas'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'blas'</span><span class="s1">]]:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">c.link_executable(obj</span><span class="s3">, </span><span class="s1">os.path.join(tmpdir</span><span class="s3">, </span><span class="s4">&quot;a.out&quot;</span><span class="s1">)</span><span class="s3">,</span>
                                      <span class="s1">libraries=libs</span><span class="s3">,</span>
                                      <span class="s1">library_dirs=info[</span><span class="s4">'library_dirs'</span><span class="s1">]</span><span class="s3">,</span>
                                      <span class="s1">extra_postargs=info.get(</span><span class="s4">'extra_link_args'</span><span class="s3">, </span><span class="s1">[]))</span>
                    <span class="s3">return </span><span class="s1">libs</span>
                <span class="s3">except </span><span class="s1">distutils.ccompiler.LinkError:</span>
                    <span class="s3">pass</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">shutil.rmtree(tmpdir)</span>
        <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">openblas_info(blas_info):</span>
    <span class="s1">section = </span><span class="s4">'openblas'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'OPENBLAS'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'openblas'</span><span class="s1">]</span>
    <span class="s1">_require_symbols = []</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">symbol_prefix(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.cp.get(self.section</span><span class="s3">, </span><span class="s4">'symbol_prefix'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">NoOptionError:</span>
            <span class="s3">return </span><span class="s4">''</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">symbol_suffix(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.cp.get(self.section</span><span class="s3">, </span><span class="s4">'symbol_suffix'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">NoOptionError:</span>
            <span class="s3">return </span><span class="s4">''</span>

    <span class="s3">def </span><span class="s1">_calc_info(self):</span>
        <span class="s1">c = customized_ccompiler()</span>

        <span class="s1">lib_dirs = self.get_lib_dirs()</span>

        <span class="s0"># Prefer to use libraries over openblas_libs</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'openblas_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">openblas_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>

        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">openblas_libs</span><span class="s3">, </span><span class="s1">[])</span>

        <span class="s3">if </span><span class="s1">c.compiler_type == </span><span class="s4">&quot;msvc&quot; </span><span class="s3">and </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">from </span><span class="s1">numpy.distutils.fcompiler </span><span class="s3">import </span><span class="s1">new_fcompiler</span>
            <span class="s1">f = new_fcompiler(c_compiler=c)</span>
            <span class="s3">if </span><span class="s1">f </span><span class="s3">and </span><span class="s1">f.compiler_type == </span><span class="s4">'gnu95'</span><span class="s1">:</span>
                <span class="s0"># Try gfortran-compatible library files</span>
                <span class="s1">info = self.check_msvc_gfortran_libs(lib_dirs</span><span class="s3">, </span><span class="s1">openblas_libs)</span>
                <span class="s0"># Skip lapack check, we'd need build_ext to do it</span>
                <span class="s1">skip_symbol_check = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">info:</span>
            <span class="s1">skip_symbol_check = </span><span class="s3">False</span>
            <span class="s1">info[</span><span class="s4">'language'</span><span class="s1">] = </span><span class="s4">'c'</span>

        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s0"># Add extra info for OpenBLAS</span>
        <span class="s1">extra_info = self.calc_extra_info()</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**extra_info)</span>

        <span class="s3">if not </span><span class="s1">(skip_symbol_check </span><span class="s3">or </span><span class="s1">self.check_symbols(info)):</span>
            <span class="s3">return None</span>

        <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] = [(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span>
        <span class="s3">if </span><span class="s1">self.symbol_prefix:</span>
            <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] += [(</span><span class="s4">'BLAS_SYMBOL_PREFIX'</span><span class="s3">, </span><span class="s1">self.symbol_prefix)]</span>
        <span class="s3">if </span><span class="s1">self.symbol_suffix:</span>
            <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] += [(</span><span class="s4">'BLAS_SYMBOL_SUFFIX'</span><span class="s3">, </span><span class="s1">self.symbol_suffix)]</span>

        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">info = self._calc_info()</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_info(**info)</span>

    <span class="s3">def </span><span class="s1">check_msvc_gfortran_libs(self</span><span class="s3">, </span><span class="s1">library_dirs</span><span class="s3">, </span><span class="s1">libraries):</span>
        <span class="s0"># First, find the full path to each library directory</span>
        <span class="s1">library_paths = []</span>
        <span class="s3">for </span><span class="s1">library </span><span class="s3">in </span><span class="s1">libraries:</span>
            <span class="s3">for </span><span class="s1">library_dir </span><span class="s3">in </span><span class="s1">library_dirs:</span>
                <span class="s0"># MinGW static ext will be .a</span>
                <span class="s1">fullpath = os.path.join(library_dir</span><span class="s3">, </span><span class="s1">library + </span><span class="s4">'.a'</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">os.path.isfile(fullpath):</span>
                    <span class="s1">library_paths.append(fullpath)</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return None</span>

        <span class="s0"># Generate numpy.distutils virtual static library file</span>
        <span class="s1">basename = self.__class__.__name__</span>
        <span class="s1">tmpdir = os.path.join(os.getcwd()</span><span class="s3">, </span><span class="s4">'build'</span><span class="s3">, </span><span class="s1">basename)</span>
        <span class="s3">if not </span><span class="s1">os.path.isdir(tmpdir):</span>
            <span class="s1">os.makedirs(tmpdir)</span>

        <span class="s1">info = {</span><span class="s4">'library_dirs'</span><span class="s1">: [tmpdir]</span><span class="s3">,</span>
                <span class="s4">'libraries'</span><span class="s1">: [basename]</span><span class="s3">,</span>
                <span class="s4">'language'</span><span class="s1">: </span><span class="s4">'f77'</span><span class="s1">}</span>

        <span class="s1">fake_lib_file = os.path.join(tmpdir</span><span class="s3">, </span><span class="s1">basename + </span><span class="s4">'.fobjects'</span><span class="s1">)</span>
        <span class="s1">fake_clib_file = os.path.join(tmpdir</span><span class="s3">, </span><span class="s1">basename + </span><span class="s4">'.cobjects'</span><span class="s1">)</span>
        <span class="s3">with </span><span class="s1">open(fake_lib_file</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(library_paths))</span>
        <span class="s3">with </span><span class="s1">open(fake_clib_file</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">pass</span>

        <span class="s3">return </span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">check_symbols(self</span><span class="s3">, </span><span class="s1">info):</span>
        <span class="s1">res = </span><span class="s3">False</span>
        <span class="s1">c = customized_ccompiler()</span>

        <span class="s1">tmpdir = tempfile.mkdtemp()</span>

        <span class="s1">prototypes = </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span><span class="s4">&quot;void %s%s%s();&quot; </span><span class="s1">% (self.symbol_prefix</span><span class="s3">,</span>
                                                   <span class="s1">symbol_name</span><span class="s3">,</span>
                                                   <span class="s1">self.symbol_suffix)</span>
                               <span class="s3">for </span><span class="s1">symbol_name </span><span class="s3">in </span><span class="s1">self._require_symbols)</span>
        <span class="s1">calls = </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span><span class="s4">&quot;%s%s%s();&quot; </span><span class="s1">% (self.symbol_prefix</span><span class="s3">,</span>
                                         <span class="s1">symbol_name</span><span class="s3">,</span>
                                         <span class="s1">self.symbol_suffix)</span>
                          <span class="s3">for </span><span class="s1">symbol_name </span><span class="s3">in </span><span class="s1">self._require_symbols)</span>
        <span class="s1">s = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
            </span><span class="s4">%(prototypes)s 
            int main(int argc, const char *argv[]) 
            { 
                %(calls)s 
                return 0; 
            }&quot;&quot;&quot;</span><span class="s1">) % dict(prototypes=prototypes</span><span class="s3">, </span><span class="s1">calls=calls)</span>
        <span class="s1">src = os.path.join(tmpdir</span><span class="s3">, </span><span class="s4">'source.c'</span><span class="s1">)</span>
        <span class="s1">out = os.path.join(tmpdir</span><span class="s3">, </span><span class="s4">'a.out'</span><span class="s1">)</span>
        <span class="s0"># Add the additional &quot;extra&quot; arguments</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">extra_args = info[</span><span class="s4">'extra_link_args'</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s1">extra_args = []</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">open(src</span><span class="s3">, </span><span class="s4">'wt'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">f.write(s)</span>
            <span class="s1">obj = c.compile([src]</span><span class="s3">, </span><span class="s1">output_dir=tmpdir)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">c.link_executable(obj</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">libraries=info[</span><span class="s4">'libraries'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">library_dirs=info[</span><span class="s4">'library_dirs'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">extra_postargs=extra_args)</span>
                <span class="s1">res = </span><span class="s3">True</span>
            <span class="s3">except </span><span class="s1">distutils.ccompiler.LinkError:</span>
                <span class="s1">res = </span><span class="s3">False</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">shutil.rmtree(tmpdir)</span>
        <span class="s3">return </span><span class="s1">res</span>

<span class="s3">class </span><span class="s1">openblas_lapack_info(openblas_info):</span>
    <span class="s1">section = </span><span class="s4">'openblas'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'OPENBLAS'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'openblas'</span><span class="s1">]</span>
    <span class="s1">_require_symbols = [</span><span class="s4">'zungqr_'</span><span class="s1">]</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>

<span class="s3">class </span><span class="s1">openblas_clapack_info(openblas_lapack_info):</span>
    <span class="s1">_lib_names = [</span><span class="s4">'openblas'</span><span class="s3">, </span><span class="s4">'lapack'</span><span class="s1">]</span>

<span class="s3">class </span><span class="s1">openblas_ilp64_info(openblas_info):</span>
    <span class="s1">section = </span><span class="s4">'openblas_ilp64'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'OPENBLAS_ILP64'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'openblas64'</span><span class="s1">]</span>
    <span class="s1">_require_symbols = [</span><span class="s4">'dgemm_'</span><span class="s3">, </span><span class="s4">'cblas_dgemm'</span><span class="s1">]</span>
    <span class="s1">notfounderror = BlasILP64NotFoundError</span>

    <span class="s3">def </span><span class="s1">_calc_info(self):</span>
        <span class="s1">info = super()._calc_info()</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] += [(</span><span class="s4">'HAVE_BLAS_ILP64'</span><span class="s3">, None</span><span class="s1">)]</span>
        <span class="s3">return </span><span class="s1">info</span>

<span class="s3">class </span><span class="s1">openblas_ilp64_lapack_info(openblas_ilp64_info):</span>
    <span class="s1">_require_symbols = [</span><span class="s4">'dgemm_'</span><span class="s3">, </span><span class="s4">'cblas_dgemm'</span><span class="s3">, </span><span class="s4">'zungqr_'</span><span class="s3">, </span><span class="s4">'LAPACKE_zungqr'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">_calc_info(self):</span>
        <span class="s1">info = super()._calc_info()</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">info[</span><span class="s4">'define_macros'</span><span class="s1">] += [(</span><span class="s4">'HAVE_LAPACKE'</span><span class="s3">, None</span><span class="s1">)]</span>
        <span class="s3">return </span><span class="s1">info</span>

<span class="s3">class </span><span class="s1">openblas64__info(openblas_ilp64_info):</span>
    <span class="s0"># ILP64 Openblas, with default symbol suffix</span>
    <span class="s1">section = </span><span class="s4">'openblas64_'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'OPENBLAS64_'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'openblas64_'</span><span class="s1">]</span>
    <span class="s1">symbol_suffix = </span><span class="s4">'64_'</span>
    <span class="s1">symbol_prefix = </span><span class="s4">''</span>

<span class="s3">class </span><span class="s1">openblas64__lapack_info(openblas_ilp64_lapack_info</span><span class="s3">, </span><span class="s1">openblas64__info):</span>
    <span class="s3">pass</span>

<span class="s3">class </span><span class="s1">blis_info(blas_info):</span>
    <span class="s1">section = </span><span class="s4">'blis'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'BLIS'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'blis'</span><span class="s1">]</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'blis_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">blis_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">info = self.check_libs2(lib_dirs</span><span class="s3">, </span><span class="s1">blis_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s0"># Add include dirs</span>
        <span class="s1">incl_dirs = self.get_include_dirs()</span>
        <span class="s1">dict_append(info</span><span class="s3">,</span>
                    <span class="s1">language=</span><span class="s4">'c'</span><span class="s3">,</span>
                    <span class="s1">define_macros=[(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)]</span><span class="s3">,</span>
                    <span class="s1">include_dirs=incl_dirs)</span>
        <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">flame_info(system_info):</span>
    <span class="s2">&quot;&quot;&quot; Usage of libflame for LAPACK operations 
 
    This requires libflame to be compiled with lapack wrappers: 
 
    ./configure --enable-lapack2flame ... 
 
    Be aware that libflame 5.1.0 has some missing names in the shared library, so 
    if you have problems, try the static flame library. 
    &quot;&quot;&quot;</span>
    <span class="s1">section = </span><span class="s4">'flame'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'flame'</span><span class="s1">]</span>
    <span class="s1">notfounderror = FlameNotFoundError</span>

    <span class="s3">def </span><span class="s1">check_embedded_lapack(self</span><span class="s3">, </span><span class="s1">info):</span>
        <span class="s2">&quot;&quot;&quot; libflame does not necessarily have a wrapper for fortran LAPACK, we need to check &quot;&quot;&quot;</span>
        <span class="s1">c = customized_ccompiler()</span>

        <span class="s1">tmpdir = tempfile.mkdtemp()</span>
        <span class="s1">s = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
            </span><span class="s4">void zungqr_(); 
            int main(int argc, const char *argv[]) 
            { 
                zungqr_(); 
                return 0; 
            }&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">src = os.path.join(tmpdir</span><span class="s3">, </span><span class="s4">'source.c'</span><span class="s1">)</span>
        <span class="s1">out = os.path.join(tmpdir</span><span class="s3">, </span><span class="s4">'a.out'</span><span class="s1">)</span>
        <span class="s0"># Add the additional &quot;extra&quot; arguments</span>
        <span class="s1">extra_args = info.get(</span><span class="s4">'extra_link_args'</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">open(src</span><span class="s3">, </span><span class="s4">'wt'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">f.write(s)</span>
            <span class="s1">obj = c.compile([src]</span><span class="s3">, </span><span class="s1">output_dir=tmpdir)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">c.link_executable(obj</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">libraries=info[</span><span class="s4">'libraries'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">library_dirs=info[</span><span class="s4">'library_dirs'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">extra_postargs=extra_args)</span>
                <span class="s3">return True</span>
            <span class="s3">except </span><span class="s1">distutils.ccompiler.LinkError:</span>
                <span class="s3">return False</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">shutil.rmtree(tmpdir)</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">flame_libs = self.get_libs(</span><span class="s4">'libraries'</span><span class="s3">, </span><span class="s1">self._lib_names)</span>

        <span class="s1">info = self.check_libs2(lib_dirs</span><span class="s3">, </span><span class="s1">flame_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s0"># Add the extra flag args to info</span>
        <span class="s1">extra_info = self.calc_extra_info()</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**extra_info)</span>

        <span class="s3">if </span><span class="s1">self.check_embedded_lapack(info):</span>
            <span class="s0"># check if the user has supplied all information required</span>
            <span class="s1">self.set_info(**info)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Try and get the BLAS lib to see if we can get it to work</span>
            <span class="s1">blas_info = get_info(</span><span class="s4">'blas_opt'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">blas_info:</span>
                <span class="s0"># since we already failed once, this ain't going to work either</span>
                <span class="s3">return</span>

            <span class="s0"># Now we need to merge the two dictionaries</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">blas_info:</span>
                <span class="s3">if </span><span class="s1">isinstance(blas_info[key]</span><span class="s3">, </span><span class="s1">list):</span>
                    <span class="s1">info[key] = info.get(key</span><span class="s3">, </span><span class="s1">[]) + blas_info[key]</span>
                <span class="s3">elif </span><span class="s1">isinstance(blas_info[key]</span><span class="s3">, </span><span class="s1">tuple):</span>
                    <span class="s1">info[key] = info.get(key</span><span class="s3">, </span><span class="s1">()) + blas_info[key]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">info[key] = info.get(key</span><span class="s3">, </span><span class="s4">''</span><span class="s1">) + blas_info[key]</span>

            <span class="s0"># Now check again</span>
            <span class="s3">if </span><span class="s1">self.check_embedded_lapack(info):</span>
                <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">accelerate_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'accelerate'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'accelerate'</span><span class="s3">, </span><span class="s4">'veclib'</span><span class="s1">]</span>
    <span class="s1">notfounderror = BlasNotFoundError</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s0"># Make possible to enable/disable from config file/env var</span>
        <span class="s1">libraries = os.environ.get(</span><span class="s4">'ACCELERATE'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">libraries:</span>
            <span class="s1">libraries = [libraries]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">libraries = self.get_libs(</span><span class="s4">'libraries'</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">libraries = [lib.strip().lower() </span><span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">libraries]</span>

        <span class="s3">if </span><span class="s1">(sys.platform == </span><span class="s4">'darwin' </span><span class="s3">and</span>
                <span class="s3">not </span><span class="s1">os.getenv(</span><span class="s4">'_PYTHON_HOST_PLATFORM'</span><span class="s3">, None</span><span class="s1">)):</span>
            <span class="s0"># Use the system BLAS from Accelerate or vecLib under OSX</span>
            <span class="s1">args = []</span>
            <span class="s1">link_args = []</span>
            <span class="s3">if </span><span class="s1">get_platform()[-</span><span class="s5">4</span><span class="s1">:] == </span><span class="s4">'i386' </span><span class="s3">or </span><span class="s4">'intel' </span><span class="s3">in </span><span class="s1">get_platform() </span><span class="s3">or </span><span class="s1">\</span>
               <span class="s4">'x86_64' </span><span class="s3">in </span><span class="s1">get_platform() </span><span class="s3">or </span><span class="s1">\</span>
               <span class="s4">'i386' </span><span class="s3">in </span><span class="s1">platform.platform():</span>
                <span class="s1">intel = </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">intel = </span><span class="s5">0</span>
            <span class="s3">if </span><span class="s1">(os.path.exists(</span><span class="s4">'/System/Library/Frameworks'</span>
                              <span class="s4">'/Accelerate.framework/'</span><span class="s1">) </span><span class="s3">and</span>
                    <span class="s4">'accelerate' </span><span class="s3">in </span><span class="s1">libraries):</span>
                <span class="s3">if </span><span class="s1">intel:</span>
                    <span class="s1">args.extend([</span><span class="s4">'-msse3'</span><span class="s1">])</span>
                <span class="s1">args.extend([</span>
                    <span class="s4">'-I/System/Library/Frameworks/vecLib.framework/Headers'</span><span class="s1">])</span>
                <span class="s1">link_args.extend([</span><span class="s4">'-Wl,-framework'</span><span class="s3">, </span><span class="s4">'-Wl,Accelerate'</span><span class="s1">])</span>
            <span class="s3">elif </span><span class="s1">(os.path.exists(</span><span class="s4">'/System/Library/Frameworks'</span>
                                 <span class="s4">'/vecLib.framework/'</span><span class="s1">) </span><span class="s3">and</span>
                      <span class="s4">'veclib' </span><span class="s3">in </span><span class="s1">libraries):</span>
                <span class="s3">if </span><span class="s1">intel:</span>
                    <span class="s1">args.extend([</span><span class="s4">'-msse3'</span><span class="s1">])</span>
                <span class="s1">args.extend([</span>
                    <span class="s4">'-I/System/Library/Frameworks/vecLib.framework/Headers'</span><span class="s1">])</span>
                <span class="s1">link_args.extend([</span><span class="s4">'-Wl,-framework'</span><span class="s3">, </span><span class="s4">'-Wl,vecLib'</span><span class="s1">])</span>

            <span class="s3">if </span><span class="s1">args:</span>
                <span class="s1">self.set_info(extra_compile_args=args</span><span class="s3">,</span>
                              <span class="s1">extra_link_args=link_args</span><span class="s3">,</span>
                              <span class="s1">define_macros=[(</span><span class="s4">'NO_ATLAS_INFO'</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                                             <span class="s1">(</span><span class="s4">'HAVE_CBLAS'</span><span class="s3">, None</span><span class="s1">)])</span>

        <span class="s3">return</span>

<span class="s3">class </span><span class="s1">blas_src_info(system_info):</span>
    <span class="s0"># BLAS_SRC is deprecated, please do not use this!</span>
    <span class="s0"># Build or install a BLAS library via your package manager or from</span>
    <span class="s0"># source separately.</span>
    <span class="s1">section = </span><span class="s4">'blas_src'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'BLAS_SRC'</span>
    <span class="s1">notfounderror = BlasSrcNotFoundError</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">pre_dirs = system_info.get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">dirs = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">pre_dirs:</span>
            <span class="s1">dirs.extend([d] + self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'blas'</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(d)]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">src_dirs = self.get_src_dirs()</span>
        <span class="s1">src_dir = </span><span class="s4">''</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">src_dirs:</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(os.path.join(d</span><span class="s3">, </span><span class="s4">'daxpy.f'</span><span class="s1">)):</span>
                <span class="s1">src_dir = d</span>
                <span class="s3">break</span>
        <span class="s3">if not </span><span class="s1">src_dir:</span>
            <span class="s0">#XXX: Get sources from netlib. May be ask first.</span>
            <span class="s3">return</span>
        <span class="s1">blas1 = </span><span class="s4">''' 
        caxpy csscal dnrm2 dzasum saxpy srotg zdotc ccopy cswap drot 
        dznrm2 scasum srotm zdotu cdotc dasum drotg icamax scnrm2 
        srotmg zdrot cdotu daxpy drotm idamax scopy sscal zdscal crotg 
        dcabs1 drotmg isamax sdot sswap zrotg cscal dcopy dscal izamax 
        snrm2 zaxpy zscal csrot ddot dswap sasum srot zcopy zswap 
        scabs1 
        '''</span>
        <span class="s1">blas2 = </span><span class="s4">''' 
        cgbmv chpmv ctrsv dsymv dtrsv sspr2 strmv zhemv ztpmv cgemv 
        chpr dgbmv dsyr lsame ssymv strsv zher ztpsv cgerc chpr2 dgemv 
        dsyr2 sgbmv ssyr xerbla zher2 ztrmv cgeru ctbmv dger dtbmv 
        sgemv ssyr2 zgbmv zhpmv ztrsv chbmv ctbsv dsbmv dtbsv sger 
        stbmv zgemv zhpr chemv ctpmv dspmv dtpmv ssbmv stbsv zgerc 
        zhpr2 cher ctpsv dspr dtpsv sspmv stpmv zgeru ztbmv cher2 
        ctrmv dspr2 dtrmv sspr stpsv zhbmv ztbsv 
        '''</span>
        <span class="s1">blas3 = </span><span class="s4">''' 
        cgemm csymm ctrsm dsyrk sgemm strmm zhemm zsyr2k chemm csyr2k 
        dgemm dtrmm ssymm strsm zher2k zsyrk cher2k csyrk dsymm dtrsm 
        ssyr2k zherk ztrmm cherk ctrmm dsyr2k ssyrk zgemm zsymm ztrsm 
        '''</span>
        <span class="s1">sources = [os.path.join(src_dir</span><span class="s3">, </span><span class="s1">f + </span><span class="s4">'.f'</span><span class="s1">) \</span>
                   <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">(blas1 + blas2 + blas3).split()]</span>
        <span class="s0">#XXX: should we check here actual existence of source files?</span>
        <span class="s1">sources = [f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">sources </span><span class="s3">if </span><span class="s1">os.path.isfile(f)]</span>
        <span class="s1">info = {</span><span class="s4">'sources'</span><span class="s1">: sources</span><span class="s3">, </span><span class="s4">'language'</span><span class="s1">: </span><span class="s4">'f77'</span><span class="s1">}</span>
        <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">x11_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'x11'</span>
    <span class="s1">notfounderror = X11NotFoundError</span>
    <span class="s1">_lib_names = [</span><span class="s4">'X11'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">system_info.__init__(self</span><span class="s3">,</span>
                             <span class="s1">default_lib_dirs=default_x11_lib_dirs</span><span class="s3">,</span>
                             <span class="s1">default_include_dirs=default_x11_include_dirs)</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s3">if </span><span class="s1">sys.platform  </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'win32'</span><span class="s1">]:</span>
            <span class="s3">return</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>
        <span class="s1">include_dirs = self.get_include_dirs()</span>
        <span class="s1">opt = self.get_option_single(</span><span class="s4">'x11_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">x11_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">x11_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">inc_dir = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">include_dirs:</span>
            <span class="s3">if </span><span class="s1">self.combine_paths(d</span><span class="s3">, </span><span class="s4">'X11/X.h'</span><span class="s1">):</span>
                <span class="s1">inc_dir = d</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">inc_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[inc_dir])</span>
        <span class="s1">self.set_info(**info)</span>


<span class="s3">class </span><span class="s1">_numpy_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'Numeric'</span>
    <span class="s1">modulename = </span><span class="s4">'Numeric'</span>
    <span class="s1">notfounderror = NumericNotFoundError</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">include_dirs = []</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">module = __import__(self.modulename)</span>
            <span class="s1">prefix = []</span>
            <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">module.__file__.split(os.sep):</span>
                <span class="s3">if </span><span class="s1">name == </span><span class="s4">'lib'</span><span class="s1">:</span>
                    <span class="s3">break</span>
                <span class="s1">prefix.append(name)</span>

            <span class="s0"># Ask numpy for its own include path before attempting</span>
            <span class="s0"># anything else</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">include_dirs.append(getattr(module</span><span class="s3">, </span><span class="s4">'get_include'</span><span class="s1">)())</span>
            <span class="s3">except </span><span class="s1">AttributeError:</span>
                <span class="s3">pass</span>

            <span class="s1">include_dirs.append(sysconfig.get_path(</span><span class="s4">'include'</span><span class="s1">))</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s3">pass</span>
        <span class="s1">py_incl_dir = sysconfig.get_path(</span><span class="s4">'include'</span><span class="s1">)</span>
        <span class="s1">include_dirs.append(py_incl_dir)</span>
        <span class="s1">py_pincl_dir = sysconfig.get_path(</span><span class="s4">'platinclude'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">py_pincl_dir </span><span class="s3">not in </span><span class="s1">include_dirs:</span>
            <span class="s1">include_dirs.append(py_pincl_dir)</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">default_include_dirs:</span>
            <span class="s1">d = os.path.join(d</span><span class="s3">, </span><span class="s1">os.path.basename(py_incl_dir))</span>
            <span class="s3">if </span><span class="s1">d </span><span class="s3">not in </span><span class="s1">include_dirs:</span>
                <span class="s1">include_dirs.append(d)</span>
        <span class="s1">system_info.__init__(self</span><span class="s3">,</span>
                             <span class="s1">default_lib_dirs=[]</span><span class="s3">,</span>
                             <span class="s1">default_include_dirs=include_dirs)</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">module = __import__(self.modulename)</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s3">return</span>
        <span class="s1">info = {}</span>
        <span class="s1">macros = []</span>
        <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'__version__'</span><span class="s3">, </span><span class="s4">'version'</span><span class="s1">]:</span>
            <span class="s1">vrs = getattr(module</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">vrs </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">macros = [(self.modulename.upper() + </span><span class="s4">'_VERSION'</span><span class="s3">,</span>
                      <span class="s1">_c_string_literal(vrs))</span><span class="s3">,</span>
                      <span class="s1">(self.modulename.upper()</span><span class="s3">, None</span><span class="s1">)]</span>
            <span class="s3">break</span>
        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=macros)</span>
        <span class="s1">include_dirs = self.get_include_dirs()</span>
        <span class="s1">inc_dir = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">include_dirs:</span>
            <span class="s3">if </span><span class="s1">self.combine_paths(d</span><span class="s3">,</span>
                                  <span class="s1">os.path.join(self.modulename</span><span class="s3">,</span>
                                               <span class="s4">'arrayobject.h'</span><span class="s1">)):</span>
                <span class="s1">inc_dir = d</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">inc_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[inc_dir])</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">numarray_info(_numpy_info):</span>
    <span class="s1">section = </span><span class="s4">'numarray'</span>
    <span class="s1">modulename = </span><span class="s4">'numarray'</span>


<span class="s3">class </span><span class="s1">Numeric_info(_numpy_info):</span>
    <span class="s1">section = </span><span class="s4">'Numeric'</span>
    <span class="s1">modulename = </span><span class="s4">'Numeric'</span>


<span class="s3">class </span><span class="s1">numpy_info(_numpy_info):</span>
    <span class="s1">section = </span><span class="s4">'numpy'</span>
    <span class="s1">modulename = </span><span class="s4">'numpy'</span>


<span class="s3">class </span><span class="s1">numerix_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'numerix'</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">which = </span><span class="s3">None, None</span>
        <span class="s3">if </span><span class="s1">os.getenv(</span><span class="s4">&quot;NUMERIX&quot;</span><span class="s1">):</span>
            <span class="s1">which = os.getenv(</span><span class="s4">&quot;NUMERIX&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;environment var&quot;</span>
        <span class="s0"># If all the above fail, default to numpy.</span>
        <span class="s3">if </span><span class="s1">which[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">which = </span><span class="s4">&quot;numpy&quot;</span><span class="s3">, </span><span class="s4">&quot;defaulted&quot;</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">import </span><span class="s1">numpy  </span><span class="s0"># noqa: F401</span>
                <span class="s1">which = </span><span class="s4">&quot;numpy&quot;</span><span class="s3">, </span><span class="s4">&quot;defaulted&quot;</span>
            <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s1">msg1 = str(e)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">import </span><span class="s1">Numeric  </span><span class="s0"># noqa: F401</span>
                    <span class="s1">which = </span><span class="s4">&quot;numeric&quot;</span><span class="s3">, </span><span class="s4">&quot;defaulted&quot;</span>
                <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">e:</span>
                    <span class="s1">msg2 = str(e)</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s3">import </span><span class="s1">numarray  </span><span class="s0"># noqa: F401</span>
                        <span class="s1">which = </span><span class="s4">&quot;numarray&quot;</span><span class="s3">, </span><span class="s4">&quot;defaulted&quot;</span>
                    <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">e:</span>
                        <span class="s1">msg3 = str(e)</span>
                        <span class="s1">log.info(msg1)</span>
                        <span class="s1">log.info(msg2)</span>
                        <span class="s1">log.info(msg3)</span>
        <span class="s1">which = which[</span><span class="s5">0</span><span class="s1">].strip().lower()</span><span class="s3">, </span><span class="s1">which[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">which[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;numeric&quot;</span><span class="s3">, </span><span class="s4">&quot;numarray&quot;</span><span class="s3">, </span><span class="s4">&quot;numpy&quot;</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;numerix selector must be either 'Numeric' &quot;</span>
                             <span class="s4">&quot;or 'numarray' or 'numpy' but the value obtained&quot;</span>
                             <span class="s4">&quot; from the %s was '%s'.&quot; </span><span class="s1">% (which[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">which[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">os.environ[</span><span class="s4">'NUMERIX'</span><span class="s1">] = which[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.set_info(**get_info(which[</span><span class="s5">0</span><span class="s1">]))</span>


<span class="s3">class </span><span class="s1">f2py_info(system_info):</span>
    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">import </span><span class="s1">numpy.f2py </span><span class="s3">as </span><span class="s1">f2py</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s3">return</span>
        <span class="s1">f2py_dir = os.path.join(os.path.dirname(f2py.__file__)</span><span class="s3">, </span><span class="s4">'src'</span><span class="s1">)</span>
        <span class="s1">self.set_info(sources=[os.path.join(f2py_dir</span><span class="s3">, </span><span class="s4">'fortranobject.c'</span><span class="s1">)]</span><span class="s3">,</span>
                      <span class="s1">include_dirs=[f2py_dir])</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">boost_python_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'boost_python'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'BOOST'</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">pre_dirs = system_info.get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">dirs = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">pre_dirs:</span>
            <span class="s1">dirs.extend([d] + self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'boost*'</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(d)]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">src_dirs = self.get_src_dirs()</span>
        <span class="s1">src_dir = </span><span class="s4">''</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">src_dirs:</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(os.path.join(d</span><span class="s3">, </span><span class="s4">'libs'</span><span class="s3">, </span><span class="s4">'python'</span><span class="s3">, </span><span class="s4">'src'</span><span class="s3">,</span>
                                           <span class="s4">'module.cpp'</span><span class="s1">)):</span>
                <span class="s1">src_dir = d</span>
                <span class="s3">break</span>
        <span class="s3">if not </span><span class="s1">src_dir:</span>
            <span class="s3">return</span>
        <span class="s1">py_incl_dirs = [sysconfig.get_path(</span><span class="s4">'include'</span><span class="s1">)]</span>
        <span class="s1">py_pincl_dir = sysconfig.get_path(</span><span class="s4">'platinclude'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">py_pincl_dir </span><span class="s3">not in </span><span class="s1">py_incl_dirs:</span>
            <span class="s1">py_incl_dirs.append(py_pincl_dir)</span>
        <span class="s1">srcs_dir = os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'libs'</span><span class="s3">, </span><span class="s4">'python'</span><span class="s3">, </span><span class="s4">'src'</span><span class="s1">)</span>
        <span class="s1">bpl_srcs = glob(os.path.join(srcs_dir</span><span class="s3">, </span><span class="s4">'*.cpp'</span><span class="s1">))</span>
        <span class="s1">bpl_srcs += glob(os.path.join(srcs_dir</span><span class="s3">, </span><span class="s4">'*'</span><span class="s3">, </span><span class="s4">'*.cpp'</span><span class="s1">))</span>
        <span class="s1">info = {</span><span class="s4">'libraries'</span><span class="s1">: [(</span><span class="s4">'boost_python_src'</span><span class="s3">,</span>
                               <span class="s1">{</span><span class="s4">'include_dirs'</span><span class="s1">: [src_dir] + py_incl_dirs</span><span class="s3">,</span>
                                <span class="s4">'sources'</span><span class="s1">:bpl_srcs}</span>
                              <span class="s1">)]</span><span class="s3">,</span>
                <span class="s4">'include_dirs'</span><span class="s1">: [src_dir]</span><span class="s3">,</span>
                <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">agg2_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'agg2'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'AGG2'</span>

    <span class="s3">def </span><span class="s1">get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">pre_dirs = system_info.get_paths(self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">dirs = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">pre_dirs:</span>
            <span class="s1">dirs.extend([d] + self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'agg2*'</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dirs </span><span class="s3">if </span><span class="s1">os.path.isdir(d)]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">src_dirs = self.get_src_dirs()</span>
        <span class="s1">src_dir = </span><span class="s4">''</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">src_dirs:</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(os.path.join(d</span><span class="s3">, </span><span class="s4">'src'</span><span class="s3">, </span><span class="s4">'agg_affine_matrix.cpp'</span><span class="s1">)):</span>
                <span class="s1">src_dir = d</span>
                <span class="s3">break</span>
        <span class="s3">if not </span><span class="s1">src_dir:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'win32'</span><span class="s1">:</span>
            <span class="s1">agg2_srcs = glob(os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'src'</span><span class="s3">, </span><span class="s4">'platform'</span><span class="s3">,</span>
                                          <span class="s4">'win32'</span><span class="s3">, </span><span class="s4">'agg_win32_bmp.cpp'</span><span class="s1">))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">agg2_srcs = glob(os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'src'</span><span class="s3">, </span><span class="s4">'*.cpp'</span><span class="s1">))</span>
            <span class="s1">agg2_srcs += [os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'src'</span><span class="s3">, </span><span class="s4">'platform'</span><span class="s3">,</span>
                                       <span class="s4">'X11'</span><span class="s3">,</span>
                                       <span class="s4">'agg_platform_support.cpp'</span><span class="s1">)]</span>

        <span class="s1">info = {</span><span class="s4">'libraries'</span><span class="s1">:</span>
                <span class="s1">[(</span><span class="s4">'agg2_src'</span><span class="s3">,</span>
                  <span class="s1">{</span><span class="s4">'sources'</span><span class="s1">: agg2_srcs</span><span class="s3">,</span>
                   <span class="s4">'include_dirs'</span><span class="s1">: [os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'include'</span><span class="s1">)]</span><span class="s3">,</span>
                  <span class="s1">}</span>
                 <span class="s1">)]</span><span class="s3">,</span>
                <span class="s4">'include_dirs'</span><span class="s1">: [os.path.join(src_dir</span><span class="s3">, </span><span class="s4">'include'</span><span class="s1">)]</span><span class="s3">,</span>
                <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">_pkg_config_info(system_info):</span>
    <span class="s1">section = </span><span class="s3">None</span>
    <span class="s1">config_env_var = </span><span class="s4">'PKG_CONFIG'</span>
    <span class="s1">default_config_exe = </span><span class="s4">'pkg-config'</span>
    <span class="s1">append_config_exe = </span><span class="s4">''</span>
    <span class="s1">version_macro_name = </span><span class="s3">None</span>
    <span class="s1">release_macro_name = </span><span class="s3">None</span>
    <span class="s1">version_flag = </span><span class="s4">'--modversion'</span>
    <span class="s1">cflags_flag = </span><span class="s4">'--cflags'</span>

    <span class="s3">def </span><span class="s1">get_config_exe(self):</span>
        <span class="s3">if </span><span class="s1">self.config_env_var </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s3">return </span><span class="s1">os.environ[self.config_env_var]</span>
        <span class="s3">return </span><span class="s1">self.default_config_exe</span>

    <span class="s3">def </span><span class="s1">get_config_output(self</span><span class="s3">, </span><span class="s1">config_exe</span><span class="s3">, </span><span class="s1">option):</span>
        <span class="s1">cmd = config_exe + </span><span class="s4">' ' </span><span class="s1">+ self.append_config_exe + </span><span class="s4">' ' </span><span class="s1">+ option</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">o = subprocess.check_output(cmd)</span>
        <span class="s3">except </span><span class="s1">(OSError</span><span class="s3">, </span><span class="s1">subprocess.CalledProcessError):</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">o = filepath_from_subprocess_output(o)</span>
            <span class="s3">return </span><span class="s1">o</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">config_exe = find_executable(self.get_config_exe())</span>
        <span class="s3">if not </span><span class="s1">config_exe:</span>
            <span class="s1">log.warn(</span><span class="s4">'File not found: %s. Cannot determine %s info.' </span><span class="s1">\</span>
                  <span class="s1">% (config_exe</span><span class="s3">, </span><span class="s1">self.section))</span>
            <span class="s3">return</span>
        <span class="s1">info = {}</span>
        <span class="s1">macros = []</span>
        <span class="s1">libraries = []</span>
        <span class="s1">library_dirs = []</span>
        <span class="s1">include_dirs = []</span>
        <span class="s1">extra_link_args = []</span>
        <span class="s1">extra_compile_args = []</span>
        <span class="s1">version = self.get_config_output(config_exe</span><span class="s3">, </span><span class="s1">self.version_flag)</span>
        <span class="s3">if </span><span class="s1">version:</span>
            <span class="s1">macros.append((self.__class__.__name__.split(</span><span class="s4">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">].upper()</span><span class="s3">,</span>
                           <span class="s1">_c_string_literal(version)))</span>
            <span class="s3">if </span><span class="s1">self.version_macro_name:</span>
                <span class="s1">macros.append((self.version_macro_name + </span><span class="s4">'_%s'</span>
                               <span class="s1">% (version.replace(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s1">))</span><span class="s3">, None</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">self.release_macro_name:</span>
            <span class="s1">release = self.get_config_output(config_exe</span><span class="s3">, </span><span class="s4">'--release'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">release:</span>
                <span class="s1">macros.append((self.release_macro_name + </span><span class="s4">'_%s'</span>
                               <span class="s1">% (release.replace(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s1">))</span><span class="s3">, None</span><span class="s1">))</span>
        <span class="s1">opts = self.get_config_output(config_exe</span><span class="s3">, </span><span class="s4">'--libs'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">opts:</span>
            <span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">opts.split():</span>
                <span class="s3">if </span><span class="s1">opt[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'-l'</span><span class="s1">:</span>
                    <span class="s1">libraries.append(opt[</span><span class="s5">2</span><span class="s1">:])</span>
                <span class="s3">elif </span><span class="s1">opt[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'-L'</span><span class="s1">:</span>
                    <span class="s1">library_dirs.append(opt[</span><span class="s5">2</span><span class="s1">:])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">extra_link_args.append(opt)</span>
        <span class="s1">opts = self.get_config_output(config_exe</span><span class="s3">, </span><span class="s1">self.cflags_flag)</span>
        <span class="s3">if </span><span class="s1">opts:</span>
            <span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">opts.split():</span>
                <span class="s3">if </span><span class="s1">opt[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'-I'</span><span class="s1">:</span>
                    <span class="s1">include_dirs.append(opt[</span><span class="s5">2</span><span class="s1">:])</span>
                <span class="s3">elif </span><span class="s1">opt[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'-D'</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s4">'=' </span><span class="s3">in </span><span class="s1">opt:</span>
                        <span class="s1">n</span><span class="s3">, </span><span class="s1">v = opt[</span><span class="s5">2</span><span class="s1">:].split(</span><span class="s4">'='</span><span class="s1">)</span>
                        <span class="s1">macros.append((n</span><span class="s3">, </span><span class="s1">v))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">macros.append((opt[</span><span class="s5">2</span><span class="s1">:]</span><span class="s3">, None</span><span class="s1">))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">extra_compile_args.append(opt)</span>
        <span class="s3">if </span><span class="s1">macros:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">define_macros=macros)</span>
        <span class="s3">if </span><span class="s1">libraries:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">libraries=libraries)</span>
        <span class="s3">if </span><span class="s1">library_dirs:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">library_dirs=library_dirs)</span>
        <span class="s3">if </span><span class="s1">include_dirs:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=include_dirs)</span>
        <span class="s3">if </span><span class="s1">extra_link_args:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">extra_link_args=extra_link_args)</span>
        <span class="s3">if </span><span class="s1">extra_compile_args:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">extra_compile_args=extra_compile_args)</span>
        <span class="s3">if </span><span class="s1">info:</span>
            <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">wx_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'wx'</span>
    <span class="s1">config_env_var = </span><span class="s4">'WX_CONFIG'</span>
    <span class="s1">default_config_exe = </span><span class="s4">'wx-config'</span>
    <span class="s1">append_config_exe = </span><span class="s4">''</span>
    <span class="s1">version_macro_name = </span><span class="s4">'WX_VERSION'</span>
    <span class="s1">release_macro_name = </span><span class="s4">'WX_RELEASE'</span>
    <span class="s1">version_flag = </span><span class="s4">'--version'</span>
    <span class="s1">cflags_flag = </span><span class="s4">'--cxxflags'</span>


<span class="s3">class </span><span class="s1">gdk_pixbuf_xlib_2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gdk_pixbuf_xlib_2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gdk-pixbuf-xlib-2.0'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GDK_PIXBUF_XLIB_VERSION'</span>


<span class="s3">class </span><span class="s1">gdk_pixbuf_2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gdk_pixbuf_2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gdk-pixbuf-2.0'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GDK_PIXBUF_VERSION'</span>


<span class="s3">class </span><span class="s1">gdk_x11_2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gdk_x11_2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gdk-x11-2.0'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GDK_X11_VERSION'</span>


<span class="s3">class </span><span class="s1">gdk_2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gdk_2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gdk-2.0'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GDK_VERSION'</span>


<span class="s3">class </span><span class="s1">gdk_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gdk'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gdk'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GDK_VERSION'</span>


<span class="s3">class </span><span class="s1">gtkp_x11_2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gtkp_x11_2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gtk+-x11-2.0'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GTK_X11_VERSION'</span>


<span class="s3">class </span><span class="s1">gtkp_2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'gtkp_2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'gtk+-2.0'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'GTK_VERSION'</span>


<span class="s3">class </span><span class="s1">xft_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'xft'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'xft'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'XFT_VERSION'</span>


<span class="s3">class </span><span class="s1">freetype2_info(_pkg_config_info):</span>
    <span class="s1">section = </span><span class="s4">'freetype2'</span>
    <span class="s1">append_config_exe = </span><span class="s4">'freetype2'</span>
    <span class="s1">version_macro_name = </span><span class="s4">'FREETYPE2_VERSION'</span>


<span class="s3">class </span><span class="s1">amd_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'amd'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'AMD'</span>
    <span class="s1">_lib_names = [</span><span class="s4">'amd'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>

        <span class="s1">opt = self.get_option_single(</span><span class="s4">'amd_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">amd_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">amd_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s1">include_dirs = self.get_include_dirs()</span>

        <span class="s1">inc_dir = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">include_dirs:</span>
            <span class="s1">p = self.combine_paths(d</span><span class="s3">, </span><span class="s4">'amd.h'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">p:</span>
                <span class="s1">inc_dir = os.path.dirname(p[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">inc_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[inc_dir]</span><span class="s3">,</span>
                        <span class="s1">define_macros=[(</span><span class="s4">'SCIPY_AMD_H'</span><span class="s3">, None</span><span class="s1">)]</span><span class="s3">,</span>
                        <span class="s1">swig_opts=[</span><span class="s4">'-I' </span><span class="s1">+ inc_dir])</span>

        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">umfpack_info(system_info):</span>
    <span class="s1">section = </span><span class="s4">'umfpack'</span>
    <span class="s1">dir_env_var = </span><span class="s4">'UMFPACK'</span>
    <span class="s1">notfounderror = UmfpackNotFoundError</span>
    <span class="s1">_lib_names = [</span><span class="s4">'umfpack'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">calc_info(self):</span>
        <span class="s1">lib_dirs = self.get_lib_dirs()</span>

        <span class="s1">opt = self.get_option_single(</span><span class="s4">'umfpack_libs'</span><span class="s3">, </span><span class="s4">'libraries'</span><span class="s1">)</span>
        <span class="s1">umfpack_libs = self.get_libs(opt</span><span class="s3">, </span><span class="s1">self._lib_names)</span>
        <span class="s1">info = self.check_libs(lib_dirs</span><span class="s3">, </span><span class="s1">umfpack_libs</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s1">include_dirs = self.get_include_dirs()</span>

        <span class="s1">inc_dir = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">include_dirs:</span>
            <span class="s1">p = self.combine_paths(d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">''</span><span class="s3">, </span><span class="s4">'umfpack'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'umfpack.h'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">p:</span>
                <span class="s1">inc_dir = os.path.dirname(p[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">inc_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">include_dirs=[inc_dir]</span><span class="s3">,</span>
                        <span class="s1">define_macros=[(</span><span class="s4">'SCIPY_UMFPACK_H'</span><span class="s3">, None</span><span class="s1">)]</span><span class="s3">,</span>
                        <span class="s1">swig_opts=[</span><span class="s4">'-I' </span><span class="s1">+ inc_dir])</span>

        <span class="s1">dict_append(info</span><span class="s3">, </span><span class="s1">**get_info(</span><span class="s4">'amd'</span><span class="s1">))</span>

        <span class="s1">self.set_info(**info)</span>
        <span class="s3">return</span>


<span class="s3">def </span><span class="s1">combine_paths(*args</span><span class="s3">, </span><span class="s1">**kws):</span>
    <span class="s2">&quot;&quot;&quot; Return a list of existing paths composed by all combinations of 
        items from arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">r = []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s3">if not </span><span class="s1">a:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">is_string(a):</span>
            <span class="s1">a = [a]</span>
        <span class="s1">r.append(a)</span>
    <span class="s1">args = r</span>
    <span class="s3">if not </span><span class="s1">args:</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">result = reduce(</span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b: a + b</span><span class="s3">, </span><span class="s1">map(glob</span><span class="s3">, </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s3">elif </span><span class="s1">len(args) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">result = []</span>
        <span class="s3">for </span><span class="s1">a0 </span><span class="s3">in </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">for </span><span class="s1">a1 </span><span class="s3">in </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">result.extend(glob(os.path.join(a0</span><span class="s3">, </span><span class="s1">a1)))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">result = combine_paths(*(combine_paths(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">]) + args[</span><span class="s5">2</span><span class="s1">:]))</span>
    <span class="s1">log.debug(</span><span class="s4">'(paths: %s)'</span><span class="s3">, </span><span class="s4">','</span><span class="s1">.join(result))</span>
    <span class="s3">return </span><span class="s1">result</span>

<span class="s1">language_map = {</span><span class="s4">'c'</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'c++'</span><span class="s1">: </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'f77'</span><span class="s1">: </span><span class="s5">2</span><span class="s3">, </span><span class="s4">'f90'</span><span class="s1">: </span><span class="s5">3</span><span class="s1">}</span>
<span class="s1">inv_language_map = {</span><span class="s5">0</span><span class="s1">: </span><span class="s4">'c'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">: </span><span class="s4">'c++'</span><span class="s3">, </span><span class="s5">2</span><span class="s1">: </span><span class="s4">'f77'</span><span class="s3">, </span><span class="s5">3</span><span class="s1">: </span><span class="s4">'f90'</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">dict_append(d</span><span class="s3">, </span><span class="s1">**kws):</span>
    <span class="s1">languages = []</span>
    <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">kws.items():</span>
        <span class="s3">if </span><span class="s1">k == </span><span class="s4">'language'</span><span class="s1">:</span>
            <span class="s1">languages.append(v)</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">d:</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'library_dirs'</span><span class="s3">, </span><span class="s4">'include_dirs'</span><span class="s3">,</span>
                     <span class="s4">'extra_compile_args'</span><span class="s3">, </span><span class="s4">'extra_link_args'</span><span class="s3">,</span>
                     <span class="s4">'runtime_library_dirs'</span><span class="s3">, </span><span class="s4">'define_macros'</span><span class="s1">]:</span>
                <span class="s1">[d[k].append(vv) </span><span class="s3">for </span><span class="s1">vv </span><span class="s3">in </span><span class="s1">v </span><span class="s3">if </span><span class="s1">vv </span><span class="s3">not in </span><span class="s1">d[k]]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">d[k].extend(v)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">d[k] = v</span>
    <span class="s3">if </span><span class="s1">languages:</span>
        <span class="s1">l = inv_language_map[max([language_map.get(l</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">languages])]</span>
        <span class="s1">d[</span><span class="s4">'language'</span><span class="s1">] = l</span>
    <span class="s3">return</span>


<span class="s3">def </span><span class="s1">parseCmdLine(argv=(</span><span class="s3">None,</span><span class="s1">)):</span>
    <span class="s3">import </span><span class="s1">optparse</span>
    <span class="s1">parser = optparse.OptionParser(</span><span class="s4">&quot;usage: %prog [-v] [info objs]&quot;</span><span class="s1">)</span>
    <span class="s1">parser.add_option(</span><span class="s4">'-v'</span><span class="s3">, </span><span class="s4">'--verbose'</span><span class="s3">, </span><span class="s1">action=</span><span class="s4">'store_true'</span><span class="s3">, </span><span class="s1">dest=</span><span class="s4">'verbose'</span><span class="s3">,</span>
                      <span class="s1">default=</span><span class="s3">False,</span>
                      <span class="s1">help=</span><span class="s4">'be verbose and print more messages'</span><span class="s1">)</span>

    <span class="s1">opts</span><span class="s3">, </span><span class="s1">args = parser.parse_args(args=argv[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s3">return </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">args</span>


<span class="s3">def </span><span class="s1">show_all(argv=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">import </span><span class="s1">inspect</span>
    <span class="s3">if </span><span class="s1">argv </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">argv = sys.argv</span>
    <span class="s1">opts</span><span class="s3">, </span><span class="s1">args = parseCmdLine(argv)</span>
    <span class="s3">if </span><span class="s1">opts.verbose:</span>
        <span class="s1">log.set_threshold(log.DEBUG)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">log.set_threshold(log.INFO)</span>
    <span class="s1">show_only = []</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s3">if </span><span class="s1">n[-</span><span class="s5">5</span><span class="s1">:] != </span><span class="s4">'_info'</span><span class="s1">:</span>
            <span class="s1">n = n + </span><span class="s4">'_info'</span>
        <span class="s1">show_only.append(n)</span>
    <span class="s1">show_all = </span><span class="s3">not </span><span class="s1">show_only</span>
    <span class="s1">_gdict_ = globals().copy()</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">_gdict_.items():</span>
        <span class="s3">if not </span><span class="s1">inspect.isclass(c):</span>
            <span class="s3">continue</span>
        <span class="s3">if not </span><span class="s1">issubclass(c</span><span class="s3">, </span><span class="s1">system_info) </span><span class="s3">or </span><span class="s1">c </span><span class="s3">is </span><span class="s1">system_info:</span>
            <span class="s3">continue</span>
        <span class="s3">if not </span><span class="s1">show_all:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">show_only:</span>
                <span class="s3">continue</span>
            <span class="s3">del </span><span class="s1">show_only[show_only.index(name)]</span>
        <span class="s1">conf = c()</span>
        <span class="s1">conf.verbosity = </span><span class="s5">2</span>
        <span class="s0"># we don't need the result, but we want</span>
        <span class="s0"># the side effect of printing diagnostics</span>
        <span class="s1">conf.get_info()</span>
    <span class="s3">if </span><span class="s1">show_only:</span>
        <span class="s1">log.info(</span><span class="s4">'Info classes not defined: %s'</span><span class="s3">, </span><span class="s4">','</span><span class="s1">.join(show_only))</span>

<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">show_all()</span>
</pre>
</body>
</html>