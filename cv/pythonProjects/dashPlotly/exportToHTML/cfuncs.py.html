<html>
<head>
<title>cfuncs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cfuncs.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
 
C declarations, CPP macros, and C functions for f2py2e. 
Only required declarations/macros/functions will be used. 
 
Copyright 1999,2000 Pearu Peterson all rights reserved, 
Pearu Peterson &lt;pearu@ioc.ee&gt; 
Permission to use, modify, and distribute this software is given under the 
terms of the NumPy License. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
$Date: 2005/05/06 11:42:34 $ 
Pearu Peterson 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">copy</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">__version__</span>

<span class="s1">f2py_version = __version__.version</span>
<span class="s1">errmess = sys.stderr.write</span>

<span class="s0">##################### Definitions ##################</span>

<span class="s1">outneeds = {</span><span class="s4">'includes0'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'includes'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'typedefs'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'typedefs_generated'</span><span class="s1">: []</span><span class="s3">,</span>
            <span class="s4">'userincludes'</span><span class="s1">: []</span><span class="s3">,</span>
            <span class="s4">'cppmacros'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'cfuncs'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'callbacks'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'f90modhooks'</span><span class="s1">: []</span><span class="s3">,</span>
            <span class="s4">'commonhooks'</span><span class="s1">: []}</span>
<span class="s1">needs = {}</span>
<span class="s1">includes0 = {</span><span class="s4">'includes0'</span><span class="s1">: </span><span class="s4">'/*need_includes0*/'</span><span class="s1">}</span>
<span class="s1">includes = {</span><span class="s4">'includes'</span><span class="s1">: </span><span class="s4">'/*need_includes*/'</span><span class="s1">}</span>
<span class="s1">userincludes = {</span><span class="s4">'userincludes'</span><span class="s1">: </span><span class="s4">'/*need_userincludes*/'</span><span class="s1">}</span>
<span class="s1">typedefs = {</span><span class="s4">'typedefs'</span><span class="s1">: </span><span class="s4">'/*need_typedefs*/'</span><span class="s1">}</span>
<span class="s1">typedefs_generated = {</span><span class="s4">'typedefs_generated'</span><span class="s1">: </span><span class="s4">'/*need_typedefs_generated*/'</span><span class="s1">}</span>
<span class="s1">cppmacros = {</span><span class="s4">'cppmacros'</span><span class="s1">: </span><span class="s4">'/*need_cppmacros*/'</span><span class="s1">}</span>
<span class="s1">cfuncs = {</span><span class="s4">'cfuncs'</span><span class="s1">: </span><span class="s4">'/*need_cfuncs*/'</span><span class="s1">}</span>
<span class="s1">callbacks = {</span><span class="s4">'callbacks'</span><span class="s1">: </span><span class="s4">'/*need_callbacks*/'</span><span class="s1">}</span>
<span class="s1">f90modhooks = {</span><span class="s4">'f90modhooks'</span><span class="s1">: </span><span class="s4">'/*need_f90modhooks*/'</span><span class="s3">,</span>
               <span class="s4">'initf90modhooksstatic'</span><span class="s1">: </span><span class="s4">'/*initf90modhooksstatic*/'</span><span class="s3">,</span>
               <span class="s4">'initf90modhooksdynamic'</span><span class="s1">: </span><span class="s4">'/*initf90modhooksdynamic*/'</span><span class="s3">,</span>
               <span class="s1">}</span>
<span class="s1">commonhooks = {</span><span class="s4">'commonhooks'</span><span class="s1">: </span><span class="s4">'/*need_commonhooks*/'</span><span class="s3">,</span>
               <span class="s4">'initcommonhooks'</span><span class="s1">: </span><span class="s4">'/*need_initcommonhooks*/'</span><span class="s3">,</span>
               <span class="s1">}</span>

<span class="s0">############ Includes ###################</span>

<span class="s1">includes0[</span><span class="s4">'math.h'</span><span class="s1">] = </span><span class="s4">'#include &lt;math.h&gt;'</span>
<span class="s1">includes0[</span><span class="s4">'string.h'</span><span class="s1">] = </span><span class="s4">'#include &lt;string.h&gt;'</span>
<span class="s1">includes0[</span><span class="s4">'setjmp.h'</span><span class="s1">] = </span><span class="s4">'#include &lt;setjmp.h&gt;'</span>

<span class="s1">includes[</span><span class="s4">'Python.h'</span><span class="s1">] = </span><span class="s4">'#include &lt;Python.h&gt;'</span>
<span class="s1">needs[</span><span class="s4">'arrayobject.h'</span><span class="s1">] = [</span><span class="s4">'Python.h'</span><span class="s1">]</span>
<span class="s1">includes[</span><span class="s4">'arrayobject.h'</span><span class="s1">] = </span><span class="s4">'''#define PY_ARRAY_UNIQUE_SYMBOL PyArray_API 
#include &quot;arrayobject.h&quot;'''</span>

<span class="s1">includes[</span><span class="s4">'arrayobject.h'</span><span class="s1">] = </span><span class="s4">'#include &quot;fortranobject.h&quot;'</span>
<span class="s1">includes[</span><span class="s4">'stdarg.h'</span><span class="s1">] = </span><span class="s4">'#include &lt;stdarg.h&gt;'</span>

<span class="s0">############# Type definitions ###############</span>

<span class="s1">typedefs[</span><span class="s4">'unsigned_char'</span><span class="s1">] = </span><span class="s4">'typedef unsigned char unsigned_char;'</span>
<span class="s1">typedefs[</span><span class="s4">'unsigned_short'</span><span class="s1">] = </span><span class="s4">'typedef unsigned short unsigned_short;'</span>
<span class="s1">typedefs[</span><span class="s4">'unsigned_long'</span><span class="s1">] = </span><span class="s4">'typedef unsigned long unsigned_long;'</span>
<span class="s1">typedefs[</span><span class="s4">'signed_char'</span><span class="s1">] = </span><span class="s4">'typedef signed char signed_char;'</span>
<span class="s1">typedefs[</span><span class="s4">'long_long'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef _WIN32 
typedef __int64 long_long; 
#else 
typedef long long long_long; 
typedef unsigned long long unsigned_long_long; 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">typedefs[</span><span class="s4">'unsigned_long_long'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef _WIN32 
typedef __uint64 long_long; 
#else 
typedef unsigned long long unsigned_long_long; 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">typedefs[</span><span class="s4">'long_double'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifndef _LONG_DOUBLE 
typedef long double long_double; 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">typedefs[</span>
    <span class="s4">'complex_long_double'</span><span class="s1">] = </span><span class="s4">'typedef struct {long double r,i;} complex_long_double;'</span>
<span class="s1">typedefs[</span><span class="s4">'complex_float'</span><span class="s1">] = </span><span class="s4">'typedef struct {float r,i;} complex_float;'</span>
<span class="s1">typedefs[</span><span class="s4">'complex_double'</span><span class="s1">] = </span><span class="s4">'typedef struct {double r,i;} complex_double;'</span>
<span class="s1">typedefs[</span><span class="s4">'string'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;typedef char * string;&quot;&quot;&quot;</span>


<span class="s0">############### CPP macros ####################</span>
<span class="s1">cppmacros[</span><span class="s4">'CFUNCSMESS'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef DEBUGCFUNCS 
#define CFUNCSMESS(mess) fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">debug-capi:</span><span class="s3">\&quot;</span><span class="s4">mess); 
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) </span><span class="s3">\\</span>
    <span class="s4">PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);</span><span class="s3">\\</span>
    <span class="s4">fprintf(stderr,</span><span class="s3">\&quot;\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#else 
#define CFUNCSMESS(mess) 
#define CFUNCSMESSPY(mess,obj) 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'F_FUNC'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#if defined(PREPEND_FORTRAN) 
#if defined(NO_APPEND_FORTRAN) 
#if defined(UPPERCASE_FORTRAN) 
#define F_FUNC(f,F) _##F 
#else 
#define F_FUNC(f,F) _##f 
#endif 
#else 
#if defined(UPPERCASE_FORTRAN) 
#define F_FUNC(f,F) _##F##_ 
#else 
#define F_FUNC(f,F) _##f##_ 
#endif 
#endif 
#else 
#if defined(NO_APPEND_FORTRAN) 
#if defined(UPPERCASE_FORTRAN) 
#define F_FUNC(f,F) F 
#else 
#define F_FUNC(f,F) f 
#endif 
#else 
#if defined(UPPERCASE_FORTRAN) 
#define F_FUNC(f,F) F##_ 
#else 
#define F_FUNC(f,F) f##_ 
#endif 
#endif 
#endif 
#if defined(UNDERSCORE_G77) 
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_) 
#else 
#define F_FUNC_US(f,F) F_FUNC(f,F) 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'F_WRAPPEDFUNC'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#if defined(PREPEND_FORTRAN) 
#if defined(NO_APPEND_FORTRAN) 
#if defined(UPPERCASE_FORTRAN) 
#define F_WRAPPEDFUNC(f,F) _F2PYWRAP##F 
#else 
#define F_WRAPPEDFUNC(f,F) _f2pywrap##f 
#endif 
#else 
#if defined(UPPERCASE_FORTRAN) 
#define F_WRAPPEDFUNC(f,F) _F2PYWRAP##F##_ 
#else 
#define F_WRAPPEDFUNC(f,F) _f2pywrap##f##_ 
#endif 
#endif 
#else 
#if defined(NO_APPEND_FORTRAN) 
#if defined(UPPERCASE_FORTRAN) 
#define F_WRAPPEDFUNC(f,F) F2PYWRAP##F 
#else 
#define F_WRAPPEDFUNC(f,F) f2pywrap##f 
#endif 
#else 
#if defined(UPPERCASE_FORTRAN) 
#define F_WRAPPEDFUNC(f,F) F2PYWRAP##F##_ 
#else 
#define F_WRAPPEDFUNC(f,F) f2pywrap##f##_ 
#endif 
#endif 
#endif 
#if defined(UNDERSCORE_G77) 
#define F_WRAPPEDFUNC_US(f,F) F_WRAPPEDFUNC(f##_,F##_) 
#else 
#define F_WRAPPEDFUNC_US(f,F) F_WRAPPEDFUNC(f,F) 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'F_MODFUNC'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#if defined(F90MOD2CCONV1) /*E.g. Compaq Fortran */ 
#if defined(NO_APPEND_FORTRAN) 
#define F_MODFUNCNAME(m,f) $ ## m ## $ ## f 
#else 
#define F_MODFUNCNAME(m,f) $ ## m ## $ ## f ## _ 
#endif 
#endif 
 
#if defined(F90MOD2CCONV2) /*E.g. IBM XL Fortran, not tested though */ 
#if defined(NO_APPEND_FORTRAN) 
#define F_MODFUNCNAME(m,f)  __ ## m ## _MOD_ ## f 
#else 
#define F_MODFUNCNAME(m,f)  __ ## m ## _MOD_ ## f ## _ 
#endif 
#endif 
 
#if defined(F90MOD2CCONV3) /*E.g. MIPSPro Compilers */ 
#if defined(NO_APPEND_FORTRAN) 
#define F_MODFUNCNAME(m,f)  f ## .in. ## m 
#else 
#define F_MODFUNCNAME(m,f)  f ## .in. ## m ## _ 
#endif 
#endif 
/* 
#if defined(UPPERCASE_FORTRAN) 
#define F_MODFUNC(m,M,f,F) F_MODFUNCNAME(M,F) 
#else 
#define F_MODFUNC(m,M,f,F) F_MODFUNCNAME(m,f) 
#endif 
*/ 
 
#define F_MODFUNC(m,f) (*(f2pymodstruct##m##.##f)) 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'SWAPUNSAFE'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define SWAP(a,b) (size_t)(a) = ((size_t)(a) ^ (size_t)(b));</span><span class="s3">\\</span>
 <span class="s4">(size_t)(b) = ((size_t)(a) ^ (size_t)(b));</span><span class="s3">\\</span>
 <span class="s4">(size_t)(a) = ((size_t)(a) ^ (size_t)(b)) 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'SWAP'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define SWAP(a,b,t) {</span><span class="s3">\\</span>
    <span class="s4">t *c;</span><span class="s3">\\</span>
    <span class="s4">c = a;</span><span class="s3">\\</span>
    <span class="s4">a = b;</span><span class="s3">\\</span>
    <span class="s4">b = c;} 
&quot;&quot;&quot;</span>
<span class="s0"># cppmacros['ISCONTIGUOUS']='#define ISCONTIGUOUS(m) (PyArray_FLAGS(m) &amp;</span>
<span class="s0"># NPY_ARRAY_C_CONTIGUOUS)'</span>
<span class="s1">cppmacros[</span><span class="s4">'PRINTPYOBJERR'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define PRINTPYOBJERR(obj)</span><span class="s3">\\</span>
    <span class="s4">fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">#modulename#.error is related to </span><span class="s3">\&quot;</span><span class="s4">);</span><span class="s3">\\</span>
    <span class="s4">PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);</span><span class="s3">\\</span>
    <span class="s4">fprintf(stderr,</span><span class="s3">\&quot;\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'MINMAX'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifndef max 
#define max(a,b) ((a &gt; b) ? (a) : (b)) 
#endif 
#ifndef min 
#define min(a,b) ((a &lt; b) ? (a) : (b)) 
#endif 
#ifndef MAX 
#define MAX(a,b) ((a &gt; b) ? (a) : (b)) 
#endif 
#ifndef MIN 
#define MIN(a,b) ((a &lt; b) ? (a) : (b)) 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'len..'</span><span class="s1">] = [</span><span class="s4">'f2py_size'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'len..'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define rank(var) var ## _Rank 
#define shape(var,dim) var ## _Dims[dim] 
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp))) 
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim) 
#define fshape(var,dim) shape(var,rank(var)-dim-1) 
#define len(var) shape(var,0) 
#define flen(var) fshape(var,0) 
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp)) 
/* #define index(i) capi_i ## i */ 
#define slen(var) capi_ ## var ## _len 
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1) 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'f2py_size'</span><span class="s1">] = [</span><span class="s4">'stdarg.h'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'f2py_size'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int f2py_size(PyArrayObject* var, ...) 
{ 
  npy_int sz = 0; 
  npy_int dim; 
  npy_int rank; 
  va_list argp; 
  va_start(argp, var); 
  dim = va_arg(argp, npy_int); 
  if (dim==-1) 
    { 
      sz = PyArray_SIZE(var); 
    } 
  else 
    { 
      rank = PyArray_NDIM(var); 
      if (dim&gt;=1 &amp;&amp; dim&lt;=rank) 
        sz = PyArray_DIM(var, dim-1); 
      else 
        fprintf(stderr, </span><span class="s3">\&quot;</span><span class="s4">f2py_size: 2nd argument value=%d fails to satisfy 1&lt;=value&lt;=%d. Result will be 0.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">, dim, rank); 
    } 
  va_end(argp); 
  return sz; 
} 
&quot;&quot;&quot;</span>

<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_char1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_char1(v) (PyLong_FromLong(v))'</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_short1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_short1(v) (PyLong_FromLong(v))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_int1'</span><span class="s1">] = [</span><span class="s4">'signed_char'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'pyobj_from_int1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_int1(v) (PyLong_FromLong(v))'</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_long1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_long1(v) (PyLong_FromLong(v))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_long_long1'</span><span class="s1">] = [</span><span class="s4">'long_long'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'pyobj_from_long_long1'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef HAVE_LONG_LONG 
#define pyobj_from_long_long1(v) (PyLong_FromLongLong(v)) 
#else 
#warning HAVE_LONG_LONG is not available. Redefining pyobj_from_long_long. 
#define pyobj_from_long_long1(v) (PyLong_FromLong(v)) 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_long_double1'</span><span class="s1">] = [</span><span class="s4">'long_double'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_long_double1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_long_double1(v) (PyFloat_FromDouble(v))'</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_double1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_double1(v) (PyFloat_FromDouble(v))'</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_float1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_float1(v) (PyFloat_FromDouble(v))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_complex_long_double1'</span><span class="s1">] = [</span><span class="s4">'complex_long_double'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_complex_long_double1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_complex_long_double1(v) (PyComplex_FromDoubles(v.r,v.i))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_complex_double1'</span><span class="s1">] = [</span><span class="s4">'complex_double'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_complex_double1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_complex_double1(v) (PyComplex_FromDoubles(v.r,v.i))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_complex_float1'</span><span class="s1">] = [</span><span class="s4">'complex_float'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_complex_float1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_complex_float1(v) (PyComplex_FromDoubles(v.r,v.i))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_string1'</span><span class="s1">] = [</span><span class="s4">'string'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_string1'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_string1(v) (PyUnicode_FromString((char *)v))'</span>
<span class="s1">needs[</span><span class="s4">'pyobj_from_string1size'</span><span class="s1">] = [</span><span class="s4">'string'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'pyobj_from_string1size'</span><span class="s1">] = </span><span class="s4">'#define pyobj_from_string1size(v,len) (PyUnicode_FromStringAndSize((char *)v, len))'</span>
<span class="s1">needs[</span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">] = [</span><span class="s4">'PRINTPYOBJERR'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">/* New SciPy */ 
#define TRYPYARRAYTEMPLATECHAR case NPY_STRING: *(char *)(PyArray_DATA(arr))=*v; break; 
#define TRYPYARRAYTEMPLATELONG case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break; 
#define TRYPYARRAYTEMPLATEOBJECT case NPY_OBJECT: PyArray_SETITEM(arr,PyArray_DATA(arr),pyobj_from_ ## ctype ## 1(*v)); break; 
 
#define TRYPYARRAYTEMPLATE(ctype,typecode) </span><span class="s3">\\</span>
        <span class="s4">PyArrayObject *arr = NULL;</span><span class="s3">\\</span>
        <span class="s4">if (!obj) return -2;</span><span class="s3">\\</span>
        <span class="s4">if (!PyArray_Check(obj)) return -1;</span><span class="s3">\\</span>
        <span class="s4">if (!(arr=(PyArrayObject *)obj)) {fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">TRYPYARRAYTEMPLATE:</span><span class="s3">\&quot;</span><span class="s4">);PRINTPYOBJERR(obj);return 0;}</span><span class="s3">\\</span>
        <span class="s4">if (PyArray_DESCR(arr)-&gt;type==typecode)  {*(ctype *)(PyArray_DATA(arr))=*v; return 1;}</span><span class="s3">\\</span>
        <span class="s4">switch (PyArray_TYPE(arr)) {</span><span class="s3">\\</span>
                <span class="s4">case NPY_DOUBLE: *(npy_double *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_INT: *(npy_int *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_LONG: *(npy_long *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_FLOAT: *(npy_float *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_CDOUBLE: *(npy_double *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_CFLOAT: *(npy_float *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_BOOL: *(npy_bool *)(PyArray_DATA(arr))=(*v!=0); break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_UBYTE: *(npy_ubyte *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_BYTE: *(npy_byte *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_SHORT: *(npy_short *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_USHORT: *(npy_ushort *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_UINT: *(npy_uint *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_ULONG: *(npy_ulong *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_LONGLONG: *(npy_longlong *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_ULONGLONG: *(npy_ulonglong *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_LONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_CLONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_OBJECT: PyArray_SETITEM(arr, PyArray_DATA(arr), pyobj_from_ ## ctype ## 1(*v)); break;</span><span class="s3">\\</span>
        <span class="s4">default: return -2;</span><span class="s3">\\</span>
        <span class="s4">};</span><span class="s3">\\</span>
        <span class="s4">return 1 
&quot;&quot;&quot;</span>

<span class="s1">needs[</span><span class="s4">'TRYCOMPLEXPYARRAYTEMPLATE'</span><span class="s1">] = [</span><span class="s4">'PRINTPYOBJERR'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'TRYCOMPLEXPYARRAYTEMPLATE'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define TRYCOMPLEXPYARRAYTEMPLATEOBJECT case NPY_OBJECT: PyArray_SETITEM(arr, PyArray_DATA(arr), pyobj_from_complex_ ## ctype ## 1((*v))); break; 
#define TRYCOMPLEXPYARRAYTEMPLATE(ctype,typecode)</span><span class="s3">\\</span>
        <span class="s4">PyArrayObject *arr = NULL;</span><span class="s3">\\</span>
        <span class="s4">if (!obj) return -2;</span><span class="s3">\\</span>
        <span class="s4">if (!PyArray_Check(obj)) return -1;</span><span class="s3">\\</span>
        <span class="s4">if (!(arr=(PyArrayObject *)obj)) {fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">TRYCOMPLEXPYARRAYTEMPLATE:</span><span class="s3">\&quot;</span><span class="s4">);PRINTPYOBJERR(obj);return 0;}</span><span class="s3">\\</span>
        <span class="s4">if (PyArray_DESCR(arr)-&gt;type==typecode) {</span><span class="s3">\\</span>
            <span class="s4">*(ctype *)(PyArray_DATA(arr))=(*v).r;</span><span class="s3">\\</span>
            <span class="s4">*(ctype *)(PyArray_DATA(arr)+sizeof(ctype))=(*v).i;</span><span class="s3">\\</span>
            <span class="s4">return 1;</span><span class="s3">\\</span>
        <span class="s4">}</span><span class="s3">\\</span>
        <span class="s4">switch (PyArray_TYPE(arr)) {</span><span class="s3">\\</span>
                <span class="s4">case NPY_CDOUBLE: *(npy_double *)(PyArray_DATA(arr))=(*v).r;</span><span class="s3">\\</span>
                                  <span class="s4">*(npy_double *)(PyArray_DATA(arr)+sizeof(npy_double))=(*v).i;</span><span class="s3">\\</span>
                                  <span class="s4">break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_CFLOAT: *(npy_float *)(PyArray_DATA(arr))=(*v).r;</span><span class="s3">\\</span>
                                 <span class="s4">*(npy_float *)(PyArray_DATA(arr)+sizeof(npy_float))=(*v).i;</span><span class="s3">\\</span>
                                 <span class="s4">break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_DOUBLE: *(npy_double *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_LONG: *(npy_long *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_FLOAT: *(npy_float *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_INT: *(npy_int *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_SHORT: *(npy_short *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_UBYTE: *(npy_ubyte *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_BYTE: *(npy_byte *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_BOOL: *(npy_bool *)(PyArray_DATA(arr))=((*v).r!=0 &amp;&amp; (*v).i!=0); break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_USHORT: *(npy_ushort *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_UINT: *(npy_uint *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_ULONG: *(npy_ulong *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_LONGLONG: *(npy_longlong *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_ULONGLONG: *(npy_ulonglong *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_LONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=(*v).r; break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_CLONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=(*v).r;</span><span class="s3">\\</span>
                                      <span class="s4">*(npy_longdouble *)(PyArray_DATA(arr)+sizeof(npy_longdouble))=(*v).i;</span><span class="s3">\\</span>
                                      <span class="s4">break;</span><span class="s3">\\</span>
                <span class="s4">case NPY_OBJECT: PyArray_SETITEM(arr, PyArray_DATA(arr), pyobj_from_complex_ ## ctype ## 1((*v))); break;</span><span class="s3">\\</span>
                <span class="s4">default: return -2;</span><span class="s3">\\</span>
        <span class="s4">};</span><span class="s3">\\</span>
        <span class="s4">return -1; 
&quot;&quot;&quot;</span>
<span class="s0"># cppmacros['NUMFROMARROBJ']=&quot;&quot;&quot;\</span>
<span class="s0"># define NUMFROMARROBJ(typenum,ctype) \\</span>
<span class="s0">#     if (PyArray_Check(obj)) arr = (PyArrayObject *)obj;\\</span>
<span class="s0">#     else arr = (PyArrayObject *)PyArray_ContiguousFromObject(obj,typenum,0,0);\\</span>
<span class="s0">#     if (arr) {\\</span>
<span class="s0">#         if (PyArray_TYPE(arr)==NPY_OBJECT) {\\</span>
<span class="s0">#             if (!ctype ## _from_pyobj(v,(PyArray_DESCR(arr)-&gt;getitem)(PyArray_DATA(arr)),\&quot;\&quot;))\\</span>
<span class="s0">#             goto capi_fail;\\</span>
<span class="s0">#         } else {\\</span>
<span class="s0">#             (PyArray_DESCR(arr)-&gt;cast[typenum])(PyArray_DATA(arr),1,(char*)v,1,1);\\</span>
<span class="s0">#         }\\</span>
<span class="s0">#         if ((PyObject *)arr != obj) { Py_DECREF(arr); }\\</span>
<span class="s0">#         return 1;\\</span>
<span class="s0">#     }</span>
<span class="s0"># &quot;&quot;&quot;</span>
<span class="s0"># XXX: Note that CNUMFROMARROBJ is identical with NUMFROMARROBJ</span>
<span class="s0"># cppmacros['CNUMFROMARROBJ']=&quot;&quot;&quot;\</span>
<span class="s0"># define CNUMFROMARROBJ(typenum,ctype) \\</span>
<span class="s0">#     if (PyArray_Check(obj)) arr = (PyArrayObject *)obj;\\</span>
<span class="s0">#     else arr = (PyArrayObject *)PyArray_ContiguousFromObject(obj,typenum,0,0);\\</span>
<span class="s0">#     if (arr) {\\</span>
<span class="s0">#         if (PyArray_TYPE(arr)==NPY_OBJECT) {\\</span>
<span class="s0">#             if (!ctype ## _from_pyobj(v,(PyArray_DESCR(arr)-&gt;getitem)(PyArray_DATA(arr)),\&quot;\&quot;))\\</span>
<span class="s0">#             goto capi_fail;\\</span>
<span class="s0">#         } else {\\</span>
<span class="s0">#             (PyArray_DESCR(arr)-&gt;cast[typenum])((void *)(PyArray_DATA(arr)),1,(void *)(v),1,1);\\</span>
<span class="s0">#         }\\</span>
<span class="s0">#         if ((PyObject *)arr != obj) { Py_DECREF(arr); }\\</span>
<span class="s0">#         return 1;\\</span>
<span class="s0">#     }</span>
<span class="s0"># &quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'GETSTRFROMPYTUPLE'</span><span class="s1">] = [</span><span class="s4">'STRINGCOPYN'</span><span class="s3">, </span><span class="s4">'PRINTPYOBJERR'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'GETSTRFROMPYTUPLE'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define GETSTRFROMPYTUPLE(tuple,index,str,len) {</span><span class="s3">\\</span>
        <span class="s4">PyObject *rv_cb_str = PyTuple_GetItem((tuple),(index));</span><span class="s3">\\</span>
        <span class="s4">if (rv_cb_str == NULL)</span><span class="s3">\\</span>
            <span class="s4">goto capi_fail;</span><span class="s3">\\</span>
        <span class="s4">if (PyBytes_Check(rv_cb_str)) {</span><span class="s3">\\</span>
            <span class="s4">str[len-1]='</span><span class="s3">\\</span><span class="s4">0';</span><span class="s3">\\</span>
            <span class="s4">STRINGCOPYN((str),PyBytes_AS_STRING((PyBytesObject*)rv_cb_str),(len));</span><span class="s3">\\</span>
        <span class="s4">} else {</span><span class="s3">\\</span>
            <span class="s4">PRINTPYOBJERR(rv_cb_str);</span><span class="s3">\\</span>
            <span class="s4">PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">string object expected</span><span class="s3">\&quot;</span><span class="s4">);</span><span class="s3">\\</span>
            <span class="s4">goto capi_fail;</span><span class="s3">\\</span>
        <span class="s4">}</span><span class="s3">\\</span>
    <span class="s4">} 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'GETSCALARFROMPYTUPLE'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define GETSCALARFROMPYTUPLE(tuple,index,var,ctype,mess) {</span><span class="s3">\\</span>
        <span class="s4">if ((capi_tmp = PyTuple_GetItem((tuple),(index)))==NULL) goto capi_fail;</span><span class="s3">\\</span>
        <span class="s4">if (!(ctype ## _from_pyobj((var),capi_tmp,mess)))</span><span class="s3">\\</span>
            <span class="s4">goto capi_fail;</span><span class="s3">\\</span>
    <span class="s4">} 
&quot;&quot;&quot;</span>

<span class="s1">cppmacros[</span><span class="s4">'FAILNULL'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\\</span>
<span class="s4">#define FAILNULL(p) do {                                            </span><span class="s3">\\</span>
    <span class="s4">if ((p) == NULL) {                                              </span><span class="s3">\\</span>
        <span class="s4">PyErr_SetString(PyExc_MemoryError, &quot;NULL pointer found&quot;);   </span><span class="s3">\\</span>
        <span class="s4">goto capi_fail;                                             </span><span class="s3">\\</span>
    <span class="s4">}                                                               </span><span class="s3">\\</span>
<span class="s4">} while (0) 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'MEMCOPY'</span><span class="s1">] = [</span><span class="s4">'string.h'</span><span class="s3">, </span><span class="s4">'FAILNULL'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'MEMCOPY'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define MEMCOPY(to,from,n)</span><span class="s3">\\</span>
    <span class="s4">do { FAILNULL(to); FAILNULL(from); (void)memcpy(to,from,n); } while (0) 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'STRINGMALLOC'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define STRINGMALLOC(str,len)</span><span class="s3">\\</span>
    <span class="s4">if ((str = (string)malloc(len+1)) == NULL) {</span><span class="s3">\\</span>
        <span class="s4">PyErr_SetString(PyExc_MemoryError, </span><span class="s3">\&quot;</span><span class="s4">out of memory</span><span class="s3">\&quot;</span><span class="s4">);</span><span class="s3">\\</span>
        <span class="s4">goto capi_fail;</span><span class="s3">\\</span>
    <span class="s4">} else {</span><span class="s3">\\</span>
        <span class="s4">(str)[len] = '</span><span class="s3">\\</span><span class="s4">0';</span><span class="s3">\\</span>
    <span class="s4">} 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'STRINGFREE'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define STRINGFREE(str) do {if (!(str == NULL)) free(str);} while (0) 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'STRINGPADN'</span><span class="s1">] = [</span><span class="s4">'string.h'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'STRINGPADN'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">/* 
STRINGPADN replaces null values with padding values from the right. 
 
`to` must have size of at least N bytes. 
 
If the `to[N-1]` has null value, then replace it and all the 
preceding, nulls with the given padding. 
 
STRINGPADN(to, N, PADDING, NULLVALUE) is an inverse operation. 
*/ 
#define STRINGPADN(to, N, NULLVALUE, PADDING)                   </span><span class="s3">\\</span>
    <span class="s4">do {                                                        </span><span class="s3">\\</span>
        <span class="s4">int _m = (N);                                           </span><span class="s3">\\</span>
        <span class="s4">char *_to = (to);                                       </span><span class="s3">\\</span>
        <span class="s4">for (_m -= 1; _m &gt;= 0 &amp;&amp; _to[_m] == NULLVALUE; _m--) {  </span><span class="s3">\\</span>
             <span class="s4">_to[_m] = PADDING;                                 </span><span class="s3">\\</span>
        <span class="s4">}                                                       </span><span class="s3">\\</span>
    <span class="s4">} while (0) 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'STRINGCOPYN'</span><span class="s1">] = [</span><span class="s4">'string.h'</span><span class="s3">, </span><span class="s4">'FAILNULL'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'STRINGCOPYN'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">/* 
STRINGCOPYN copies N bytes. 
 
`to` and `from` buffers must have sizes of at least N bytes. 
*/ 
#define STRINGCOPYN(to,from,N)                                  </span><span class="s3">\\</span>
    <span class="s4">do {                                                        </span><span class="s3">\\</span>
        <span class="s4">int _m = (N);                                           </span><span class="s3">\\</span>
        <span class="s4">char *_to = (to);                                       </span><span class="s3">\\</span>
        <span class="s4">char *_from = (from);                                   </span><span class="s3">\\</span>
        <span class="s4">FAILNULL(_to); FAILNULL(_from);                         </span><span class="s3">\\</span>
        <span class="s4">(void)strncpy(_to, _from, _m);             </span><span class="s3">\\</span>
    <span class="s4">} while (0) 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'STRINGCOPY'</span><span class="s1">] = [</span><span class="s4">'string.h'</span><span class="s3">, </span><span class="s4">'FAILNULL'</span><span class="s1">]</span>
<span class="s1">cppmacros[</span><span class="s4">'STRINGCOPY'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define STRINGCOPY(to,from)</span><span class="s3">\\</span>
    <span class="s4">do { FAILNULL(to); FAILNULL(from); (void)strcpy(to,from); } while (0) 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'CHECKGENERIC'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define CHECKGENERIC(check,tcheck,name) </span><span class="s3">\\</span>
    <span class="s4">if (!(check)) {</span><span class="s3">\\</span>
        <span class="s4">PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">(</span><span class="s3">\&quot;</span><span class="s4">tcheck</span><span class="s3">\&quot;</span><span class="s4">) failed for </span><span class="s3">\&quot;</span><span class="s4">name);</span><span class="s3">\\</span>
        <span class="s4">/*goto capi_fail;*/</span><span class="s3">\\</span>
    <span class="s4">} else &quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'CHECKARRAY'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define CHECKARRAY(check,tcheck,name) </span><span class="s3">\\</span>
    <span class="s4">if (!(check)) {</span><span class="s3">\\</span>
        <span class="s4">PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">(</span><span class="s3">\&quot;</span><span class="s4">tcheck</span><span class="s3">\&quot;</span><span class="s4">) failed for </span><span class="s3">\&quot;</span><span class="s4">name);</span><span class="s3">\\</span>
        <span class="s4">/*goto capi_fail;*/</span><span class="s3">\\</span>
    <span class="s4">} else &quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'CHECKSTRING'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define CHECKSTRING(check,tcheck,name,show,var)</span><span class="s3">\\</span>
    <span class="s4">if (!(check)) {</span><span class="s3">\\</span>
        <span class="s4">char errstring[256];</span><span class="s3">\\</span>
        <span class="s4">sprintf(errstring, </span><span class="s3">\&quot;</span><span class="s4">%s: </span><span class="s3">\&quot;</span><span class="s4">show, </span><span class="s3">\&quot;</span><span class="s4">(</span><span class="s3">\&quot;</span><span class="s4">tcheck</span><span class="s3">\&quot;</span><span class="s4">) failed for </span><span class="s3">\&quot;</span><span class="s4">name, slen(var), var);</span><span class="s3">\\</span>
        <span class="s4">PyErr_SetString(#modulename#_error, errstring);</span><span class="s3">\\</span>
        <span class="s4">/*goto capi_fail;*/</span><span class="s3">\\</span>
    <span class="s4">} else &quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">'CHECKSCALAR'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#define CHECKSCALAR(check,tcheck,name,show,var)</span><span class="s3">\\</span>
    <span class="s4">if (!(check)) {</span><span class="s3">\\</span>
        <span class="s4">char errstring[256];</span><span class="s3">\\</span>
        <span class="s4">sprintf(errstring, </span><span class="s3">\&quot;</span><span class="s4">%s: </span><span class="s3">\&quot;</span><span class="s4">show, </span><span class="s3">\&quot;</span><span class="s4">(</span><span class="s3">\&quot;</span><span class="s4">tcheck</span><span class="s3">\&quot;</span><span class="s4">) failed for </span><span class="s3">\&quot;</span><span class="s4">name, var);</span><span class="s3">\\</span>
        <span class="s4">PyErr_SetString(#modulename#_error,errstring);</span><span class="s3">\\</span>
        <span class="s4">/*goto capi_fail;*/</span><span class="s3">\\</span>
    <span class="s4">} else &quot;&quot;&quot;</span>
<span class="s0"># cppmacros['CHECKDIMS']=&quot;&quot;&quot;\</span>
<span class="s0"># define CHECKDIMS(dims,rank) \\</span>
<span class="s0">#     for (int i=0;i&lt;(rank);i++)\\</span>
<span class="s0">#         if (dims[i]&lt;0) {\\</span>
<span class="s0">#             fprintf(stderr,\&quot;Unspecified array argument requires a complete dimension specification.\\n\&quot;);\\</span>
<span class="s0">#             goto capi_fail;\\</span>
<span class="s0">#         }</span>
<span class="s0"># &quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span>
    <span class="s4">'ARRSIZE'</span><span class="s1">] = </span><span class="s4">'#define ARRSIZE(dims,rank) (_PyArray_multiply_list(dims,rank))'</span>
<span class="s1">cppmacros[</span><span class="s4">'OLDPYNUM'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifdef OLDPYNUM 
#error You need to install NumPy version 0.13 or higher. See https://scipy.org/install.html 
#endif 
&quot;&quot;&quot;</span>
<span class="s1">cppmacros[</span><span class="s4">&quot;F2PY_THREAD_LOCAL_DECL&quot;</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">#ifndef F2PY_THREAD_LOCAL_DECL 
#if defined(_MSC_VER) </span><span class="s3">\\</span>
      <span class="s4">|| defined(_WIN32) || defined(_WIN64) </span><span class="s3">\\</span>
      <span class="s4">|| defined(__MINGW32__) || defined(__MINGW64__) 
#define F2PY_THREAD_LOCAL_DECL __declspec(thread) 
#elif defined(__STDC_VERSION__) </span><span class="s3">\\</span>
      <span class="s4">&amp;&amp; (__STDC_VERSION__ &gt;= 201112L) </span><span class="s3">\\</span>
      <span class="s4">&amp;&amp; !defined(__STDC_NO_THREADS__) </span><span class="s3">\\</span>
      <span class="s4">&amp;&amp; (!defined(__GLIBC__) || __GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt; 12)) 
/* __STDC_NO_THREADS__ was first defined in a maintenance release of glibc 2.12, 
   see https://lists.gnu.org/archive/html/commit-hurd/2012-07/msg00180.html, 
   so `!defined(__STDC_NO_THREADS__)` may give false positive for the existence 
   of `threads.h` when using an older release of glibc 2.12 */ 
#include &lt;threads.h&gt; 
#define F2PY_THREAD_LOCAL_DECL thread_local 
#elif defined(__GNUC__) </span><span class="s3">\\</span>
      <span class="s4">&amp;&amp; (__GNUC__ &gt; 4 || (__GNUC__ == 4 &amp;&amp; (__GNUC_MINOR__ &gt;= 4))) 
#define F2PY_THREAD_LOCAL_DECL __thread 
#endif 
#endif 
&quot;&quot;&quot;</span>
<span class="s0">################# C functions ###############</span>

<span class="s1">cfuncs[</span><span class="s4">'calcarrindex'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int calcarrindex(int *i,PyArrayObject *arr) { 
    int k,ii = i[0]; 
    for (k=1; k &lt; PyArray_NDIM(arr); k++) 
        ii += (ii*(PyArray_DIM(arr,k) - 1)+i[k]); /* assuming contiguous arr */ 
    return ii; 
}&quot;&quot;&quot;</span>
<span class="s1">cfuncs[</span><span class="s4">'calcarrindextr'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int calcarrindextr(int *i,PyArrayObject *arr) { 
    int k,ii = i[PyArray_NDIM(arr)-1]; 
    for (k=1; k &lt; PyArray_NDIM(arr); k++) 
        ii += (ii*(PyArray_DIM(arr,PyArray_NDIM(arr)-k-1) - 1)+i[PyArray_NDIM(arr)-k-1]); /* assuming contiguous arr */ 
    return ii; 
}&quot;&quot;&quot;</span>
<span class="s1">cfuncs[</span><span class="s4">'forcomb'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static struct { int nd;npy_intp *d;int *i,*i_tr,tr; } forcombcache; 
static int initforcomb(npy_intp *dims,int nd,int tr) { 
  int k; 
  if (dims==NULL) return 0; 
  if (nd&lt;0) return 0; 
  forcombcache.nd = nd; 
  forcombcache.d = dims; 
  forcombcache.tr = tr; 
  if ((forcombcache.i = (int *)malloc(sizeof(int)*nd))==NULL) return 0; 
  if ((forcombcache.i_tr = (int *)malloc(sizeof(int)*nd))==NULL) return 0; 
  for (k=1;k&lt;nd;k++) { 
    forcombcache.i[k] = forcombcache.i_tr[nd-k-1] = 0; 
  } 
  forcombcache.i[0] = forcombcache.i_tr[nd-1] = -1; 
  return 1; 
} 
static int *nextforcomb(void) { 
  int j,*i,*i_tr,k; 
  int nd=forcombcache.nd; 
  if ((i=forcombcache.i) == NULL) return NULL; 
  if ((i_tr=forcombcache.i_tr) == NULL) return NULL; 
  if (forcombcache.d == NULL) return NULL; 
  i[0]++; 
  if (i[0]==forcombcache.d[0]) { 
    j=1; 
    while ((j&lt;nd) &amp;&amp; (i[j]==forcombcache.d[j]-1)) j++; 
    if (j==nd) { 
      free(i); 
      free(i_tr); 
      return NULL; 
    } 
    for (k=0;k&lt;j;k++) i[k] = i_tr[nd-k-1] = 0; 
    i[j]++; 
    i_tr[nd-j-1]++; 
  } else 
    i_tr[nd-1]++; 
  if (forcombcache.tr) return i_tr; 
  return i; 
}&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_string'</span><span class="s1">] = [</span><span class="s4">'STRINGCOPYN'</span><span class="s3">, </span><span class="s4">'PRINTPYOBJERR'</span><span class="s3">, </span><span class="s4">'string'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'try_pyarr_from_string'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">/* 
  try_pyarr_from_string copies str[:len(obj)] to the data of an `ndarray`. 
 
  If obj is an `ndarray`, it is assumed to be contiguous. 
 
  If the specified len==-1, str must be null-terminated. 
*/ 
static int try_pyarr_from_string(PyObject *obj, 
                                 const string str, const int len) { 
#ifdef DEBUGCFUNCS 
fprintf(stderr, &quot;try_pyarr_from_string(str='%s', len=%d, obj=%p)</span><span class="s3">\\</span><span class="s4">n&quot;, 
        (char*)str,len, obj); 
#endif 
    if (PyArray_Check(obj)) { 
        PyArrayObject *arr = (PyArrayObject *)obj; 
        assert(ISCONTIGUOUS(arr)); 
        string buf = PyArray_DATA(arr); 
        npy_intp n = len; 
        if (n == -1) { 
            /* Assuming null-terminated str. */ 
            n = strlen(str); 
        } 
        if (n &gt; PyArray_NBYTES(arr)) { 
            n = PyArray_NBYTES(arr); 
        } 
        STRINGCOPYN(buf, str, n); 
        return 1; 
    } 
capi_fail: 
    PRINTPYOBJERR(obj); 
    PyErr_SetString(#modulename#_error, </span><span class="s3">\&quot;</span><span class="s4">try_pyarr_from_string failed</span><span class="s3">\&quot;</span><span class="s4">); 
    return 0; 
} 
&quot;&quot;&quot;</span>
<span class="s1">needs[</span><span class="s4">'string_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'string'</span><span class="s3">, </span><span class="s4">'STRINGMALLOC'</span><span class="s3">, </span><span class="s4">'STRINGCOPYN'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'string_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">/* 
  Create a new string buffer `str` of at most length `len` from a 
  Python string-like object `obj`. 
 
  The string buffer has given size (len) or the size of inistr when len==-1. 
 
  The string buffer is padded with blanks: in Fortran, trailing blanks 
  are insignificant contrary to C nulls. 
 */ 
static int 
string_from_pyobj(string *str, int *len, const string inistr, PyObject *obj, 
                  const char *errmess) 
{ 
    PyObject *tmp = NULL; 
    string buf = NULL; 
    npy_intp n = -1; 
#ifdef DEBUGCFUNCS 
fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">string_from_pyobj(str='%s',len=%d,inistr='%s',obj=%p)</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">, 
               (char*)str, *len, (char *)inistr, obj); 
#endif 
    if (obj == Py_None) { 
        n = strlen(inistr); 
        buf = inistr; 
    } 
    else if (PyArray_Check(obj)) { 
        PyArrayObject *arr = (PyArrayObject *)obj; 
        if (!ISCONTIGUOUS(arr)) { 
            PyErr_SetString(PyExc_ValueError, 
                            </span><span class="s3">\&quot;</span><span class="s4">array object is non-contiguous.</span><span class="s3">\&quot;</span><span class="s4">); 
            goto capi_fail; 
        } 
        n = PyArray_NBYTES(arr); 
        buf = PyArray_DATA(arr); 
        n = strnlen(buf, n); 
    } 
    else { 
        if (PyBytes_Check(obj)) { 
            tmp = obj; 
            Py_INCREF(tmp); 
        } 
        else if (PyUnicode_Check(obj)) { 
            tmp = PyUnicode_AsASCIIString(obj); 
        } 
        else { 
            PyObject *tmp2; 
            tmp2 = PyObject_Str(obj); 
            if (tmp2) { 
                tmp = PyUnicode_AsASCIIString(tmp2); 
                Py_DECREF(tmp2); 
            } 
            else { 
                tmp = NULL; 
            } 
        } 
        if (tmp == NULL) goto capi_fail; 
        n = PyBytes_GET_SIZE(tmp); 
        buf = PyBytes_AS_STRING(tmp); 
    } 
    if (*len == -1) { 
        /* TODO: change the type of `len` so that we can remove this */ 
        if (n &gt; NPY_MAX_INT) { 
            PyErr_SetString(PyExc_OverflowError, 
                            &quot;object too large for a 32-bit int&quot;); 
            goto capi_fail; 
        } 
        *len = n; 
    } 
    else if (*len &lt; n) { 
        /* discard the last (len-n) bytes of input buf */ 
        n = *len; 
    } 
    if (n &lt; 0 || *len &lt; 0 || buf == NULL) { 
        goto capi_fail; 
    } 
    STRINGMALLOC(*str, *len);  // *str is allocated with size (*len + 1) 
    if (n &lt; *len) { 
        /* 
          Pad fixed-width string with nulls. The caller will replace 
          nulls with blanks when the corresponding argument is not 
          intent(c). 
        */ 
        memset(*str + n, '</span><span class="s3">\\</span><span class="s4">0', *len - n); 
    } 
    STRINGCOPYN(*str, buf, n); 
    Py_XDECREF(tmp); 
    return 1; 
capi_fail: 
    Py_XDECREF(tmp); 
    { 
        PyObject* err = PyErr_Occurred(); 
        if (err == NULL) { 
            err = #modulename#_error; 
        } 
        PyErr_SetString(err, errmess); 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>

<span class="s1">needs[</span><span class="s4">'char_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'int_from_pyobj'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'char_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
char_from_pyobj(char* v, PyObject *obj, const char *errmess) { 
    int i = 0; 
    if (int_from_pyobj(&amp;i, obj, errmess)) { 
        *v = (char)i; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'signed_char_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'int_from_pyobj'</span><span class="s3">, </span><span class="s4">'signed_char'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'signed_char_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
signed_char_from_pyobj(signed_char* v, PyObject *obj, const char *errmess) { 
    int i = 0; 
    if (int_from_pyobj(&amp;i, obj, errmess)) { 
        *v = (signed_char)i; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'short_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'int_from_pyobj'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'short_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
short_from_pyobj(short* v, PyObject *obj, const char *errmess) { 
    int i = 0; 
    if (int_from_pyobj(&amp;i, obj, errmess)) { 
        *v = (short)i; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">cfuncs[</span><span class="s4">'int_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
int_from_pyobj(int* v, PyObject *obj, const char *errmess) 
{ 
    PyObject* tmp = NULL; 
 
    if (PyLong_Check(obj)) { 
        *v = Npy__PyLong_AsInt(obj); 
        return !(*v == -1 &amp;&amp; PyErr_Occurred()); 
    } 
 
    tmp = PyNumber_Long(obj); 
    if (tmp) { 
        *v = Npy__PyLong_AsInt(tmp); 
        Py_DECREF(tmp); 
        return !(*v == -1 &amp;&amp; PyErr_Occurred()); 
    } 
 
    if (PyComplex_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PyObject_GetAttrString(obj,</span><span class="s3">\&quot;</span><span class="s4">real</span><span class="s3">\&quot;</span><span class="s4">); 
    } 
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) { 
        /*pass*/; 
    } 
    else if (PySequence_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PySequence_GetItem(obj, 0); 
    } 
 
    if (tmp) { 
        if (int_from_pyobj(v, tmp, errmess)) { 
            Py_DECREF(tmp); 
            return 1; 
        } 
        Py_DECREF(tmp); 
    } 
 
    { 
        PyObject* err = PyErr_Occurred(); 
        if (err == NULL) { 
            err = #modulename#_error; 
        } 
        PyErr_SetString(err, errmess); 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">cfuncs[</span><span class="s4">'long_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
long_from_pyobj(long* v, PyObject *obj, const char *errmess) { 
    PyObject* tmp = NULL; 
 
    if (PyLong_Check(obj)) { 
        *v = PyLong_AsLong(obj); 
        return !(*v == -1 &amp;&amp; PyErr_Occurred()); 
    } 
 
    tmp = PyNumber_Long(obj); 
    if (tmp) { 
        *v = PyLong_AsLong(tmp); 
        Py_DECREF(tmp); 
        return !(*v == -1 &amp;&amp; PyErr_Occurred()); 
    } 
 
    if (PyComplex_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PyObject_GetAttrString(obj,</span><span class="s3">\&quot;</span><span class="s4">real</span><span class="s3">\&quot;</span><span class="s4">); 
    } 
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) { 
        /*pass*/; 
    } 
    else if (PySequence_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PySequence_GetItem(obj, 0); 
    } 
 
    if (tmp) { 
        if (long_from_pyobj(v, tmp, errmess)) { 
            Py_DECREF(tmp); 
            return 1; 
        } 
        Py_DECREF(tmp); 
    } 
    { 
        PyObject* err = PyErr_Occurred(); 
        if (err == NULL) { 
            err = #modulename#_error; 
        } 
        PyErr_SetString(err, errmess); 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'long_long_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'long_long'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'long_long_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
long_long_from_pyobj(long_long* v, PyObject *obj, const char *errmess) 
{ 
    PyObject* tmp = NULL; 
 
    if (PyLong_Check(obj)) { 
        *v = PyLong_AsLongLong(obj); 
        return !(*v == -1 &amp;&amp; PyErr_Occurred()); 
    } 
 
    tmp = PyNumber_Long(obj); 
    if (tmp) { 
        *v = PyLong_AsLongLong(tmp); 
        Py_DECREF(tmp); 
        return !(*v == -1 &amp;&amp; PyErr_Occurred()); 
    } 
 
    if (PyComplex_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PyObject_GetAttrString(obj,</span><span class="s3">\&quot;</span><span class="s4">real</span><span class="s3">\&quot;</span><span class="s4">); 
    } 
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) { 
        /*pass*/; 
    } 
    else if (PySequence_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PySequence_GetItem(obj, 0); 
    } 
 
    if (tmp) { 
        if (long_long_from_pyobj(v, tmp, errmess)) { 
            Py_DECREF(tmp); 
            return 1; 
        } 
        Py_DECREF(tmp); 
    } 
    { 
        PyObject* err = PyErr_Occurred(); 
        if (err == NULL) { 
            err = #modulename#_error; 
        } 
        PyErr_SetString(err,errmess); 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'long_double_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'double_from_pyobj'</span><span class="s3">, </span><span class="s4">'long_double'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'long_double_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
long_double_from_pyobj(long_double* v, PyObject *obj, const char *errmess) 
{ 
    double d=0; 
    if (PyArray_CheckScalar(obj)){ 
        if PyArray_IsScalar(obj, LongDouble) { 
            PyArray_ScalarAsCtype(obj, v); 
            return 1; 
        } 
        else if (PyArray_Check(obj) &amp;&amp; PyArray_TYPE(obj) == NPY_LONGDOUBLE) { 
            (*v) = *((npy_longdouble *)PyArray_DATA(obj)); 
            return 1; 
        } 
    } 
    if (double_from_pyobj(&amp;d, obj, errmess)) { 
        *v = (long_double)d; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">cfuncs[</span><span class="s4">'double_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
double_from_pyobj(double* v, PyObject *obj, const char *errmess) 
{ 
    PyObject* tmp = NULL; 
    if (PyFloat_Check(obj)) { 
        *v = PyFloat_AsDouble(obj); 
        return !(*v == -1.0 &amp;&amp; PyErr_Occurred()); 
    } 
 
    tmp = PyNumber_Float(obj); 
    if (tmp) { 
        *v = PyFloat_AsDouble(tmp); 
        Py_DECREF(tmp); 
        return !(*v == -1.0 &amp;&amp; PyErr_Occurred()); 
    } 
 
    if (PyComplex_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PyObject_GetAttrString(obj,</span><span class="s3">\&quot;</span><span class="s4">real</span><span class="s3">\&quot;</span><span class="s4">); 
    } 
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) { 
        /*pass*/; 
    } 
    else if (PySequence_Check(obj)) { 
        PyErr_Clear(); 
        tmp = PySequence_GetItem(obj, 0); 
    } 
 
    if (tmp) { 
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;} 
        Py_DECREF(tmp); 
    } 
    { 
        PyObject* err = PyErr_Occurred(); 
        if (err==NULL) err = #modulename#_error; 
        PyErr_SetString(err,errmess); 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'float_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'double_from_pyobj'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'float_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
float_from_pyobj(float* v, PyObject *obj, const char *errmess) 
{ 
    double d=0.0; 
    if (double_from_pyobj(&amp;d,obj,errmess)) { 
        *v = (float)d; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'complex_long_double_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'complex_long_double'</span><span class="s3">, </span><span class="s4">'long_double'</span><span class="s3">,</span>
                                           <span class="s4">'complex_double_from_pyobj'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'complex_long_double_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
complex_long_double_from_pyobj(complex_long_double* v, PyObject *obj, const char *errmess) 
{ 
    complex_double cd = {0.0,0.0}; 
    if (PyArray_CheckScalar(obj)){ 
        if PyArray_IsScalar(obj, CLongDouble) { 
            PyArray_ScalarAsCtype(obj, v); 
            return 1; 
        } 
        else if (PyArray_Check(obj) &amp;&amp; PyArray_TYPE(obj)==NPY_CLONGDOUBLE) { 
            (*v).r = ((npy_clongdouble *)PyArray_DATA(obj))-&gt;real; 
            (*v).i = ((npy_clongdouble *)PyArray_DATA(obj))-&gt;imag; 
            return 1; 
        } 
    } 
    if (complex_double_from_pyobj(&amp;cd,obj,errmess)) { 
        (*v).r = (long_double)cd.r; 
        (*v).i = (long_double)cd.i; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'complex_double_from_pyobj'</span><span class="s1">] = [</span><span class="s4">'complex_double'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'complex_double_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
complex_double_from_pyobj(complex_double* v, PyObject *obj, const char *errmess) { 
    Py_complex c; 
    if (PyComplex_Check(obj)) { 
        c = PyComplex_AsCComplex(obj); 
        (*v).r = c.real; 
        (*v).i = c.imag; 
        return 1; 
    } 
    if (PyArray_IsScalar(obj, ComplexFloating)) { 
        if (PyArray_IsScalar(obj, CFloat)) { 
            npy_cfloat new; 
            PyArray_ScalarAsCtype(obj, &amp;new); 
            (*v).r = (double)new.real; 
            (*v).i = (double)new.imag; 
        } 
        else if (PyArray_IsScalar(obj, CLongDouble)) { 
            npy_clongdouble new; 
            PyArray_ScalarAsCtype(obj, &amp;new); 
            (*v).r = (double)new.real; 
            (*v).i = (double)new.imag; 
        } 
        else { /* if (PyArray_IsScalar(obj, CDouble)) */ 
            PyArray_ScalarAsCtype(obj, v); 
        } 
        return 1; 
    } 
    if (PyArray_CheckScalar(obj)) { /* 0-dim array or still array scalar */ 
        PyObject *arr; 
        if (PyArray_Check(obj)) { 
            arr = PyArray_Cast((PyArrayObject *)obj, NPY_CDOUBLE); 
        } 
        else { 
            arr = PyArray_FromScalar(obj, PyArray_DescrFromType(NPY_CDOUBLE)); 
        } 
        if (arr == NULL) { 
            return 0; 
        } 
        (*v).r = ((npy_cdouble *)PyArray_DATA(arr))-&gt;real; 
        (*v).i = ((npy_cdouble *)PyArray_DATA(arr))-&gt;imag; 
        Py_DECREF(arr); 
        return 1; 
    } 
    /* Python does not provide PyNumber_Complex function :-( */ 
    (*v).i = 0.0; 
    if (PyFloat_Check(obj)) { 
        (*v).r = PyFloat_AsDouble(obj); 
        return !((*v).r == -1.0 &amp;&amp; PyErr_Occurred()); 
    } 
    if (PyLong_Check(obj)) { 
        (*v).r = PyLong_AsDouble(obj); 
        return !((*v).r == -1.0 &amp;&amp; PyErr_Occurred()); 
    } 
    if (PySequence_Check(obj) &amp;&amp; !(PyBytes_Check(obj) || PyUnicode_Check(obj))) { 
        PyObject *tmp = PySequence_GetItem(obj,0); 
        if (tmp) { 
            if (complex_double_from_pyobj(v,tmp,errmess)) { 
                Py_DECREF(tmp); 
                return 1; 
            } 
            Py_DECREF(tmp); 
        } 
    } 
    { 
        PyObject* err = PyErr_Occurred(); 
        if (err==NULL) 
            err = PyExc_TypeError; 
        PyErr_SetString(err,errmess); 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'complex_float_from_pyobj'</span><span class="s1">] = [</span>
    <span class="s4">'complex_float'</span><span class="s3">, </span><span class="s4">'complex_double_from_pyobj'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span><span class="s4">'complex_float_from_pyobj'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
complex_float_from_pyobj(complex_float* v,PyObject *obj,const char *errmess) 
{ 
    complex_double cd={0.0,0.0}; 
    if (complex_double_from_pyobj(&amp;cd,obj,errmess)) { 
        (*v).r = (float)cd.r; 
        (*v).i = (float)cd.i; 
        return 1; 
    } 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s1">needs[</span><span class="s4">'try_pyarr_from_char'</span><span class="s1">] = [</span><span class="s4">'pyobj_from_char1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_char'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_char(PyObject* obj,char* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(char,</span><span class="s3">\'</span><span class="s4">c</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_signed_char'</span><span class="s1">] = [</span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s3">, </span><span class="s4">'unsigned_char'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_unsigned_char'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_unsigned_char(PyObject* obj,unsigned_char* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(unsigned_char,</span><span class="s3">\'</span><span class="s4">b</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_signed_char'</span><span class="s1">] = [</span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s3">, </span><span class="s4">'signed_char'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_signed_char'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_signed_char(PyObject* obj,signed_char* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(signed_char,</span><span class="s3">\'</span><span class="s4">1</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_short'</span><span class="s1">] = [</span><span class="s4">'pyobj_from_short1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_short'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_short(PyObject* obj,short* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(short,</span><span class="s3">\'</span><span class="s4">s</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_int'</span><span class="s1">] = [</span><span class="s4">'pyobj_from_int1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_int'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_int(PyObject* obj,int* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(int,</span><span class="s3">\'</span><span class="s4">i</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_long'</span><span class="s1">] = [</span><span class="s4">'pyobj_from_long1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_long'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_long(PyObject* obj,long* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(long,</span><span class="s3">\'</span><span class="s4">l</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_long_long'</span><span class="s1">] = [</span>
    <span class="s4">'pyobj_from_long_long1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s3">, </span><span class="s4">'long_long'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_long_long'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_long_long(PyObject* obj,long_long* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(long_long,</span><span class="s3">\'</span><span class="s4">L</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_float'</span><span class="s1">] = [</span><span class="s4">'pyobj_from_float1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_float'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_float(PyObject* obj,float* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(float,</span><span class="s3">\'</span><span class="s4">f</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_double'</span><span class="s1">] = [</span><span class="s4">'pyobj_from_double1'</span><span class="s3">, </span><span class="s4">'TRYPYARRAYTEMPLATE'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_double'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_double(PyObject* obj,double* v) {</span><span class="s3">\n    </span><span class="s4">TRYPYARRAYTEMPLATE(double,</span><span class="s3">\'</span><span class="s4">d</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_complex_float'</span><span class="s1">] = [</span>
    <span class="s4">'pyobj_from_complex_float1'</span><span class="s3">, </span><span class="s4">'TRYCOMPLEXPYARRAYTEMPLATE'</span><span class="s3">, </span><span class="s4">'complex_float'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_complex_float'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_complex_float(PyObject* obj,complex_float* v) {</span><span class="s3">\n    </span><span class="s4">TRYCOMPLEXPYARRAYTEMPLATE(float,</span><span class="s3">\'</span><span class="s4">F</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>
<span class="s1">needs[</span><span class="s4">'try_pyarr_from_complex_double'</span><span class="s1">] = [</span>
    <span class="s4">'pyobj_from_complex_double1'</span><span class="s3">, </span><span class="s4">'TRYCOMPLEXPYARRAYTEMPLATE'</span><span class="s3">, </span><span class="s4">'complex_double'</span><span class="s1">]</span>
<span class="s1">cfuncs[</span>
    <span class="s4">'try_pyarr_from_complex_double'</span><span class="s1">] = </span><span class="s4">'static int try_pyarr_from_complex_double(PyObject* obj,complex_double* v) {</span><span class="s3">\n    </span><span class="s4">TRYCOMPLEXPYARRAYTEMPLATE(double,</span><span class="s3">\'</span><span class="s4">D</span><span class="s3">\'</span><span class="s4">);</span><span class="s3">\n</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>


<span class="s1">needs[</span><span class="s4">'create_cb_arglist'</span><span class="s1">] = [</span><span class="s4">'CFUNCSMESS'</span><span class="s3">, </span><span class="s4">'PRINTPYOBJERR'</span><span class="s3">, </span><span class="s4">'MINMAX'</span><span class="s1">]</span>
<span class="s0"># create the list of arguments to be used when calling back to python</span>
<span class="s1">cfuncs[</span><span class="s4">'create_cb_arglist'</span><span class="s1">] = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">static int 
create_cb_arglist(PyObject* fun, PyTupleObject* xa , const int maxnofargs, 
                  const int nofoptargs, int *nofargs, PyTupleObject **args, 
                  const char *errmess) 
{ 
    PyObject *tmp = NULL; 
    PyObject *tmp_fun = NULL; 
    Py_ssize_t tot, opt, ext, siz, i, di = 0; 
    CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">create_cb_arglist</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
    tot=opt=ext=siz=0; 
    /* Get the total number of arguments */ 
    if (PyFunction_Check(fun)) { 
        tmp_fun = fun; 
        Py_INCREF(tmp_fun); 
    } 
    else { 
        di = 1; 
        if (PyObject_HasAttrString(fun,</span><span class="s3">\&quot;</span><span class="s4">im_func</span><span class="s3">\&quot;</span><span class="s4">)) { 
            tmp_fun = PyObject_GetAttrString(fun,</span><span class="s3">\&quot;</span><span class="s4">im_func</span><span class="s3">\&quot;</span><span class="s4">); 
        } 
        else if (PyObject_HasAttrString(fun,</span><span class="s3">\&quot;</span><span class="s4">__call__</span><span class="s3">\&quot;</span><span class="s4">)) { 
            tmp = PyObject_GetAttrString(fun,</span><span class="s3">\&quot;</span><span class="s4">__call__</span><span class="s3">\&quot;</span><span class="s4">); 
            if (PyObject_HasAttrString(tmp,</span><span class="s3">\&quot;</span><span class="s4">im_func</span><span class="s3">\&quot;</span><span class="s4">)) 
                tmp_fun = PyObject_GetAttrString(tmp,</span><span class="s3">\&quot;</span><span class="s4">im_func</span><span class="s3">\&quot;</span><span class="s4">); 
            else { 
                tmp_fun = fun; /* built-in function */ 
                Py_INCREF(tmp_fun); 
                tot = maxnofargs; 
                if (PyCFunction_Check(fun)) { 
                    /* In case the function has a co_argcount (like on PyPy) */ 
                    di = 0; 
                } 
                if (xa != NULL) 
                    tot += PyTuple_Size((PyObject *)xa); 
            } 
            Py_XDECREF(tmp); 
        } 
        else if (PyFortran_Check(fun) || PyFortran_Check1(fun)) { 
            tot = maxnofargs; 
            if (xa != NULL) 
                tot += PyTuple_Size((PyObject *)xa); 
            tmp_fun = fun; 
            Py_INCREF(tmp_fun); 
        } 
        else if (F2PyCapsule_Check(fun)) { 
            tot = maxnofargs; 
            if (xa != NULL) 
                ext = PyTuple_Size((PyObject *)xa); 
            if(ext&gt;0) { 
                fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">extra arguments tuple cannot be used with CObject call-back</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
                goto capi_fail; 
            } 
            tmp_fun = fun; 
            Py_INCREF(tmp_fun); 
        } 
    } 
 
    if (tmp_fun == NULL) { 
        fprintf(stderr, 
                </span><span class="s3">\&quot;</span><span class="s4">Call-back argument must be function|instance|instance.__call__|f2py-function </span><span class="s3">\&quot;</span>
                <span class="s3">\&quot;</span><span class="s4">but got %s.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">, 
                ((fun == NULL) ? </span><span class="s3">\&quot;</span><span class="s4">NULL</span><span class="s3">\&quot; </span><span class="s4">: Py_TYPE(fun)-&gt;tp_name)); 
        goto capi_fail; 
    } 
 
    if (PyObject_HasAttrString(tmp_fun,</span><span class="s3">\&quot;</span><span class="s4">__code__</span><span class="s3">\&quot;</span><span class="s4">)) { 
        if (PyObject_HasAttrString(tmp = PyObject_GetAttrString(tmp_fun,</span><span class="s3">\&quot;</span><span class="s4">__code__</span><span class="s3">\&quot;</span><span class="s4">),</span><span class="s3">\&quot;</span><span class="s4">co_argcount</span><span class="s3">\&quot;</span><span class="s4">)) { 
            PyObject *tmp_argcount = PyObject_GetAttrString(tmp,</span><span class="s3">\&quot;</span><span class="s4">co_argcount</span><span class="s3">\&quot;</span><span class="s4">); 
            Py_DECREF(tmp); 
            if (tmp_argcount == NULL) { 
                goto capi_fail; 
            } 
            tot = PyLong_AsSsize_t(tmp_argcount) - di; 
            Py_DECREF(tmp_argcount); 
        } 
    } 
    /* Get the number of optional arguments */ 
    if (PyObject_HasAttrString(tmp_fun,</span><span class="s3">\&quot;</span><span class="s4">__defaults__</span><span class="s3">\&quot;</span><span class="s4">)) { 
        if (PyTuple_Check(tmp = PyObject_GetAttrString(tmp_fun,</span><span class="s3">\&quot;</span><span class="s4">__defaults__</span><span class="s3">\&quot;</span><span class="s4">))) 
            opt = PyTuple_Size(tmp); 
        Py_XDECREF(tmp); 
    } 
    /* Get the number of extra arguments */ 
    if (xa != NULL) 
        ext = PyTuple_Size((PyObject *)xa); 
    /* Calculate the size of call-backs argument list */ 
    siz = MIN(maxnofargs+ext,tot); 
    *nofargs = MAX(0,siz-ext); 
 
#ifdef DEBUGCFUNCS 
    fprintf(stderr, 
            </span><span class="s3">\&quot;</span><span class="s4">debug-capi:create_cb_arglist:maxnofargs(-nofoptargs),</span><span class="s3">\&quot;</span>
            <span class="s3">\&quot;</span><span class="s4">tot,opt,ext,siz,nofargs = %d(-%d), %zd, %zd, %zd, %zd, %d</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">, 
            maxnofargs, nofoptargs, tot, opt, ext, siz, *nofargs); 
#endif 
 
    if (siz &lt; tot-opt) { 
        fprintf(stderr, 
                </span><span class="s3">\&quot;</span><span class="s4">create_cb_arglist: Failed to build argument list </span><span class="s3">\&quot;</span>
                <span class="s3">\&quot;</span><span class="s4">(siz) with enough arguments (tot-opt) required by </span><span class="s3">\&quot;</span>
                <span class="s3">\&quot;</span><span class="s4">user-supplied function (siz,tot,opt=%zd, %zd, %zd).</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">, 
                siz, tot, opt); 
        goto capi_fail; 
    } 
 
    /* Initialize argument list */ 
    *args = (PyTupleObject *)PyTuple_New(siz); 
    for (i=0;i&lt;*nofargs;i++) { 
        Py_INCREF(Py_None); 
        PyTuple_SET_ITEM((PyObject *)(*args),i,Py_None); 
    } 
    if (xa != NULL) 
        for (i=(*nofargs);i&lt;siz;i++) { 
            tmp = PyTuple_GetItem((PyObject *)xa,i-(*nofargs)); 
            Py_INCREF(tmp); 
            PyTuple_SET_ITEM(*args,i,tmp); 
        } 
    CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">create_cb_arglist-end</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
    Py_DECREF(tmp_fun); 
    return 1; 
 
capi_fail: 
    if (PyErr_Occurred() == NULL) 
        PyErr_SetString(#modulename#_error, errmess); 
    Py_XDECREF(tmp_fun); 
    return 0; 
} 
&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">buildcfuncs():</span>
    <span class="s3">from </span><span class="s1">.capi_maps </span><span class="s3">import </span><span class="s1">c2capi_map</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">c2capi_map.keys():</span>
        <span class="s1">m = </span><span class="s4">'pyarr_from_p_%s1' </span><span class="s1">% k</span>
        <span class="s1">cppmacros[</span>
            <span class="s1">m] = </span><span class="s4">'#define %s(v) (PyArray_SimpleNewFromData(0,NULL,%s,(char *)v))' </span><span class="s1">% (m</span><span class="s3">, </span><span class="s1">c2capi_map[k])</span>
    <span class="s1">k = </span><span class="s4">'string'</span>
    <span class="s1">m = </span><span class="s4">'pyarr_from_p_%s1' </span><span class="s1">% k</span>
    <span class="s0"># NPY_CHAR compatibility, NPY_STRING with itemsize 1</span>
    <span class="s1">cppmacros[</span>
        <span class="s1">m] = </span><span class="s4">'#define %s(v,dims) (PyArray_New(&amp;PyArray_Type, 1, dims, NPY_STRING, NULL, v, 1, NPY_ARRAY_CARRAY, NULL))' </span><span class="s1">% (m)</span>


<span class="s0">############ Auxiliary functions for sorting needs ###################</span>

<span class="s3">def </span><span class="s1">append_needs(need</span><span class="s3">, </span><span class="s1">flag=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s0"># This function modifies the contents of the global `outneeds` dict.</span>
    <span class="s3">if </span><span class="s1">isinstance(need</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">need:</span>
            <span class="s1">append_needs(n</span><span class="s3">, </span><span class="s1">flag)</span>
    <span class="s3">elif </span><span class="s1">isinstance(need</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s3">if not </span><span class="s1">need:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">need </span><span class="s3">in </span><span class="s1">includes0:</span>
            <span class="s1">n = </span><span class="s4">'includes0'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">includes:</span>
            <span class="s1">n = </span><span class="s4">'includes'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">typedefs:</span>
            <span class="s1">n = </span><span class="s4">'typedefs'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">typedefs_generated:</span>
            <span class="s1">n = </span><span class="s4">'typedefs_generated'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">cppmacros:</span>
            <span class="s1">n = </span><span class="s4">'cppmacros'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">cfuncs:</span>
            <span class="s1">n = </span><span class="s4">'cfuncs'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">callbacks:</span>
            <span class="s1">n = </span><span class="s4">'callbacks'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">f90modhooks:</span>
            <span class="s1">n = </span><span class="s4">'f90modhooks'</span>
        <span class="s3">elif </span><span class="s1">need </span><span class="s3">in </span><span class="s1">commonhooks:</span>
            <span class="s1">n = </span><span class="s4">'commonhooks'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">errmess(</span><span class="s4">'append_needs: unknown need %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (repr(need)))</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">need </span><span class="s3">in </span><span class="s1">outneeds[n]:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">flag:</span>
            <span class="s1">tmp = {}</span>
            <span class="s3">if </span><span class="s1">need </span><span class="s3">in </span><span class="s1">needs:</span>
                <span class="s3">for </span><span class="s1">nn </span><span class="s3">in </span><span class="s1">needs[need]:</span>
                    <span class="s1">t = append_needs(nn</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">isinstance(t</span><span class="s3">, </span><span class="s1">dict):</span>
                        <span class="s3">for </span><span class="s1">nnn </span><span class="s3">in </span><span class="s1">t.keys():</span>
                            <span class="s3">if </span><span class="s1">nnn </span><span class="s3">in </span><span class="s1">tmp:</span>
                                <span class="s1">tmp[nnn] = tmp[nnn] + t[nnn]</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s1">tmp[nnn] = t[nnn]</span>
            <span class="s3">for </span><span class="s1">nn </span><span class="s3">in </span><span class="s1">tmp.keys():</span>
                <span class="s3">for </span><span class="s1">nnn </span><span class="s3">in </span><span class="s1">tmp[nn]:</span>
                    <span class="s3">if </span><span class="s1">nnn </span><span class="s3">not in </span><span class="s1">outneeds[nn]:</span>
                        <span class="s1">outneeds[nn] = [nnn] + outneeds[nn]</span>
            <span class="s1">outneeds[n].append(need)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">tmp = {}</span>
            <span class="s3">if </span><span class="s1">need </span><span class="s3">in </span><span class="s1">needs:</span>
                <span class="s3">for </span><span class="s1">nn </span><span class="s3">in </span><span class="s1">needs[need]:</span>
                    <span class="s1">t = append_needs(nn</span><span class="s3">, </span><span class="s1">flag)</span>
                    <span class="s3">if </span><span class="s1">isinstance(t</span><span class="s3">, </span><span class="s1">dict):</span>
                        <span class="s3">for </span><span class="s1">nnn </span><span class="s3">in </span><span class="s1">t.keys():</span>
                            <span class="s3">if </span><span class="s1">nnn </span><span class="s3">in </span><span class="s1">tmp:</span>
                                <span class="s1">tmp[nnn] = t[nnn] + tmp[nnn]</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s1">tmp[nnn] = t[nnn]</span>
            <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">tmp:</span>
                <span class="s1">tmp[n] = []</span>
            <span class="s1">tmp[n].append(need)</span>
            <span class="s3">return </span><span class="s1">tmp</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">errmess(</span><span class="s4">'append_needs: expected list or string but got :%s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                <span class="s1">(repr(need)))</span>


<span class="s3">def </span><span class="s1">get_needs():</span>
    <span class="s0"># This function modifies the contents of the global `outneeds` dict.</span>
    <span class="s1">res = {}</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">outneeds.keys():</span>
        <span class="s1">out = []</span>
        <span class="s1">saveout = copy.copy(outneeds[n])</span>
        <span class="s3">while </span><span class="s1">len(outneeds[n]) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">outneeds[n][</span><span class="s5">0</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">needs:</span>
                <span class="s1">out.append(outneeds[n][</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">del </span><span class="s1">outneeds[n][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">flag = </span><span class="s5">0</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">outneeds[n][</span><span class="s5">1</span><span class="s1">:]:</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">needs[outneeds[n][</span><span class="s5">0</span><span class="s1">]]:</span>
                        <span class="s1">flag = </span><span class="s5">1</span>
                        <span class="s3">break</span>
                <span class="s3">if </span><span class="s1">flag:</span>
                    <span class="s1">outneeds[n] = outneeds[n][</span><span class="s5">1</span><span class="s1">:] + [outneeds[n][</span><span class="s5">0</span><span class="s1">]]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">out.append(outneeds[n][</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s3">del </span><span class="s1">outneeds[n][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">saveout </span><span class="s3">and </span><span class="s1">(</span><span class="s5">0 </span><span class="s3">not in </span><span class="s1">map(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y: x == y</span><span class="s3">, </span><span class="s1">saveout</span><span class="s3">, </span><span class="s1">outneeds[n])) \</span>
                    <span class="s3">and </span><span class="s1">outneeds[n] != []:</span>
                <span class="s1">print(n</span><span class="s3">, </span><span class="s1">saveout)</span>
                <span class="s1">errmess(</span>
                    <span class="s4">'get_needs: no progress in sorting needs, probably circular dependence, skipping.</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s1">out = out + saveout</span>
                <span class="s3">break</span>
            <span class="s1">saveout = copy.copy(outneeds[n])</span>
        <span class="s3">if </span><span class="s1">out == []:</span>
            <span class="s1">out = [n]</span>
        <span class="s1">res[n] = out</span>
    <span class="s3">return </span><span class="s1">res</span>
</pre>
</body>
</html>