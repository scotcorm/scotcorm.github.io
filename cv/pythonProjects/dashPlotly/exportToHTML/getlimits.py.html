<html>
<head>
<title>getlimits.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
getlimits.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Machine limits for Float32 and Float64 and (long double) if available... 
 
&quot;&quot;&quot;</span>
<span class="s1">__all__ = [</span><span class="s2">'finfo'</span><span class="s3">, </span><span class="s2">'iinfo'</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">from </span><span class="s1">._machar </span><span class="s3">import </span><span class="s1">MachAr</span>
<span class="s3">from </span><span class="s1">.overrides </span><span class="s3">import </span><span class="s1">set_module</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">numeric</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">numerictypes </span><span class="s3">as </span><span class="s1">ntypes</span>
<span class="s3">from </span><span class="s1">.numeric </span><span class="s3">import </span><span class="s1">array</span><span class="s3">, </span><span class="s1">inf</span><span class="s3">, </span><span class="s1">NaN</span>
<span class="s3">from </span><span class="s1">.umath </span><span class="s3">import </span><span class="s1">log10</span><span class="s3">, </span><span class="s1">exp2</span><span class="s3">, </span><span class="s1">nextafter</span><span class="s3">, </span><span class="s1">isnan</span>


<span class="s3">def </span><span class="s1">_fr0(a):</span>
    <span class="s0">&quot;&quot;&quot;fix rank-0 --&gt; rank-1&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">a.ndim == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">a = a.copy()</span>
        <span class="s1">a.shape = (</span><span class="s4">1</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">def </span><span class="s1">_fr1(a):</span>
    <span class="s0">&quot;&quot;&quot;fix rank &gt; 0 --&gt; rank-0&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">a.size == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">a = a.copy()</span>
        <span class="s1">a.shape = ()</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">class </span><span class="s1">MachArLike:</span>
    <span class="s0">&quot;&quot;&quot; Object to simulate MachAr instance &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">epsneg</span><span class="s3">, </span><span class="s1">huge</span><span class="s3">, </span><span class="s1">tiny</span><span class="s3">,</span>
                 <span class="s1">ibeta</span><span class="s3">, </span><span class="s1">smallest_subnormal=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.params = _MACHAR_PARAMS[ftype]</span>
        <span class="s1">self.ftype = ftype</span>
        <span class="s1">self.title = self.params[</span><span class="s2">'title'</span><span class="s1">]</span>
        <span class="s5"># Parameter types same as for discovered MachAr object.</span>
        <span class="s3">if not </span><span class="s1">smallest_subnormal:</span>
            <span class="s1">self._smallest_subnormal = nextafter(</span>
                <span class="s1">self.ftype(</span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.ftype(</span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=self.ftype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._smallest_subnormal = smallest_subnormal</span>
        <span class="s1">self.epsilon = self.eps = self._float_to_float(eps)</span>
        <span class="s1">self.epsneg = self._float_to_float(epsneg)</span>
        <span class="s1">self.xmax = self.huge = self._float_to_float(huge)</span>
        <span class="s1">self.xmin = self._float_to_float(tiny)</span>
        <span class="s1">self.smallest_normal = self.tiny = self._float_to_float(tiny)</span>
        <span class="s1">self.ibeta = self.params[</span><span class="s2">'itype'</span><span class="s1">](ibeta)</span>
        <span class="s1">self.__dict__.update(kwargs)</span>
        <span class="s1">self.precision = int(-log10(self.eps))</span>
        <span class="s1">self.resolution = self._float_to_float(</span>
            <span class="s1">self._float_conv(</span><span class="s4">10</span><span class="s1">) ** (-self.precision))</span>
        <span class="s1">self._str_eps = self._float_to_str(self.eps)</span>
        <span class="s1">self._str_epsneg = self._float_to_str(self.epsneg)</span>
        <span class="s1">self._str_xmin = self._float_to_str(self.xmin)</span>
        <span class="s1">self._str_xmax = self._float_to_str(self.xmax)</span>
        <span class="s1">self._str_resolution = self._float_to_str(self.resolution)</span>
        <span class="s1">self._str_smallest_normal = self._float_to_str(self.xmin)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">smallest_subnormal(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the value for the smallest subnormal. 
 
        Returns 
        ------- 
        smallest_subnormal : float 
            value for the smallest subnormal. 
 
        Warns 
        ----- 
        UserWarning 
            If the calculated value for the smallest subnormal is zero. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Check that the calculated value is not zero, in case it raises a</span>
        <span class="s5"># warning.</span>
        <span class="s1">value = self._smallest_subnormal</span>
        <span class="s3">if </span><span class="s1">self.ftype(</span><span class="s4">0</span><span class="s1">) == value:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">'The value of the smallest subnormal for {} type '</span>
                <span class="s2">'is zero.'</span><span class="s1">.format(self.ftype)</span><span class="s3">, </span><span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">self._float_to_float(value)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_str_smallest_subnormal(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the string representation of the smallest subnormal.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._float_to_str(self.smallest_subnormal)</span>

    <span class="s3">def </span><span class="s1">_float_to_float(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Converts float to float. 
 
        Parameters 
        ---------- 
        value : float 
            value to be converted. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_fr1(self._float_conv(value))</span>

    <span class="s3">def </span><span class="s1">_float_conv(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Converts float to conv. 
 
        Parameters 
        ---------- 
        value : float 
            value to be converted. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">array([value]</span><span class="s3">, </span><span class="s1">self.ftype)</span>

    <span class="s3">def </span><span class="s1">_float_to_str(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Converts float to str. 
 
        Parameters 
        ---------- 
        value : float 
            value to be converted. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.params[</span><span class="s2">'fmt'</span><span class="s1">] % array(_fr0(value)[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.ftype)</span>


<span class="s1">_convert_to_float = {</span>
    <span class="s1">ntypes.csingle: ntypes.single</span><span class="s3">,</span>
    <span class="s1">ntypes.complex_: ntypes.float_</span><span class="s3">,</span>
    <span class="s1">ntypes.clongfloat: ntypes.longfloat</span>
    <span class="s1">}</span>

<span class="s5"># Parameters for creating MachAr / MachAr-like objects</span>
<span class="s1">_title_fmt = </span><span class="s2">'numpy {} precision floating point number'</span>
<span class="s1">_MACHAR_PARAMS = {</span>
    <span class="s1">ntypes.double: dict(</span>
        <span class="s1">itype = ntypes.int64</span><span class="s3">,</span>
        <span class="s1">fmt = </span><span class="s2">'%24.16e'</span><span class="s3">,</span>
        <span class="s1">title = _title_fmt.format(</span><span class="s2">'double'</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">ntypes.single: dict(</span>
        <span class="s1">itype = ntypes.int32</span><span class="s3">,</span>
        <span class="s1">fmt = </span><span class="s2">'%15.7e'</span><span class="s3">,</span>
        <span class="s1">title = _title_fmt.format(</span><span class="s2">'single'</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">ntypes.longdouble: dict(</span>
        <span class="s1">itype = ntypes.longlong</span><span class="s3">,</span>
        <span class="s1">fmt = </span><span class="s2">'%s'</span><span class="s3">,</span>
        <span class="s1">title = _title_fmt.format(</span><span class="s2">'long double'</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">ntypes.half: dict(</span>
        <span class="s1">itype = ntypes.int16</span><span class="s3">,</span>
        <span class="s1">fmt = </span><span class="s2">'%12.5e'</span><span class="s3">,</span>
        <span class="s1">title = _title_fmt.format(</span><span class="s2">'half'</span><span class="s1">))}</span>

<span class="s5"># Key to identify the floating point type.  Key is result of</span>
<span class="s5"># ftype('-0.1').newbyteorder('&lt;').tobytes()</span>
<span class="s5"># See:</span>
<span class="s5"># https://perl5.git.perl.org/perl.git/blob/3118d7d684b56cbeb702af874f4326683c45f045:/Configure</span>
<span class="s1">_KNOWN_TYPES = {}</span>
<span class="s3">def </span><span class="s1">_register_type(machar</span><span class="s3">, </span><span class="s1">bytepat):</span>
    <span class="s1">_KNOWN_TYPES[bytepat] = machar</span>
<span class="s1">_float_ma = {}</span>


<span class="s3">def </span><span class="s1">_register_known_types():</span>
    <span class="s5"># Known parameters for float16</span>
    <span class="s5"># See docstring of MachAr class for description of parameters.</span>
    <span class="s1">f16 = ntypes.float16</span>
    <span class="s1">float16_ma = MachArLike(f16</span><span class="s3">,</span>
                            <span class="s1">machep=-</span><span class="s4">10</span><span class="s3">,</span>
                            <span class="s1">negep=-</span><span class="s4">11</span><span class="s3">,</span>
                            <span class="s1">minexp=-</span><span class="s4">14</span><span class="s3">,</span>
                            <span class="s1">maxexp=</span><span class="s4">16</span><span class="s3">,</span>
                            <span class="s1">it=</span><span class="s4">10</span><span class="s3">,</span>
                            <span class="s1">iexp=</span><span class="s4">5</span><span class="s3">,</span>
                            <span class="s1">ibeta=</span><span class="s4">2</span><span class="s3">,</span>
                            <span class="s1">irnd=</span><span class="s4">5</span><span class="s3">,</span>
                            <span class="s1">ngrd=</span><span class="s4">0</span><span class="s3">,</span>
                            <span class="s1">eps=exp2(f16(-</span><span class="s4">10</span><span class="s1">))</span><span class="s3">,</span>
                            <span class="s1">epsneg=exp2(f16(-</span><span class="s4">11</span><span class="s1">))</span><span class="s3">,</span>
                            <span class="s1">huge=f16(</span><span class="s4">65504</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">tiny=f16(</span><span class="s4">2 </span><span class="s1">** -</span><span class="s4">14</span><span class="s1">))</span>
    <span class="s1">_register_type(float16_ma</span><span class="s3">, </span><span class="s6">b'f</span><span class="s3">\xae</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s1">_float_ma[</span><span class="s4">16</span><span class="s1">] = float16_ma</span>

    <span class="s5"># Known parameters for float32</span>
    <span class="s1">f32 = ntypes.float32</span>
    <span class="s1">float32_ma = MachArLike(f32</span><span class="s3">,</span>
                            <span class="s1">machep=-</span><span class="s4">23</span><span class="s3">,</span>
                            <span class="s1">negep=-</span><span class="s4">24</span><span class="s3">,</span>
                            <span class="s1">minexp=-</span><span class="s4">126</span><span class="s3">,</span>
                            <span class="s1">maxexp=</span><span class="s4">128</span><span class="s3">,</span>
                            <span class="s1">it=</span><span class="s4">23</span><span class="s3">,</span>
                            <span class="s1">iexp=</span><span class="s4">8</span><span class="s3">,</span>
                            <span class="s1">ibeta=</span><span class="s4">2</span><span class="s3">,</span>
                            <span class="s1">irnd=</span><span class="s4">5</span><span class="s3">,</span>
                            <span class="s1">ngrd=</span><span class="s4">0</span><span class="s3">,</span>
                            <span class="s1">eps=exp2(f32(-</span><span class="s4">23</span><span class="s1">))</span><span class="s3">,</span>
                            <span class="s1">epsneg=exp2(f32(-</span><span class="s4">24</span><span class="s1">))</span><span class="s3">,</span>
                            <span class="s1">huge=f32((</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2 </span><span class="s1">** -</span><span class="s4">24</span><span class="s1">) * </span><span class="s4">2</span><span class="s1">**</span><span class="s4">128</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">tiny=exp2(f32(-</span><span class="s4">126</span><span class="s1">)))</span>
    <span class="s1">_register_type(float32_ma</span><span class="s3">, </span><span class="s6">b'</span><span class="s3">\xcd\xcc\xcc\xbd</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s1">_float_ma[</span><span class="s4">32</span><span class="s1">] = float32_ma</span>

    <span class="s5"># Known parameters for float64</span>
    <span class="s1">f64 = ntypes.float64</span>
    <span class="s1">epsneg_f64 = </span><span class="s4">2.0 </span><span class="s1">** -</span><span class="s4">53.0</span>
    <span class="s1">tiny_f64 = </span><span class="s4">2.0 </span><span class="s1">** -</span><span class="s4">1022.0</span>
    <span class="s1">float64_ma = MachArLike(f64</span><span class="s3">,</span>
                            <span class="s1">machep=-</span><span class="s4">52</span><span class="s3">,</span>
                            <span class="s1">negep=-</span><span class="s4">53</span><span class="s3">,</span>
                            <span class="s1">minexp=-</span><span class="s4">1022</span><span class="s3">,</span>
                            <span class="s1">maxexp=</span><span class="s4">1024</span><span class="s3">,</span>
                            <span class="s1">it=</span><span class="s4">52</span><span class="s3">,</span>
                            <span class="s1">iexp=</span><span class="s4">11</span><span class="s3">,</span>
                            <span class="s1">ibeta=</span><span class="s4">2</span><span class="s3">,</span>
                            <span class="s1">irnd=</span><span class="s4">5</span><span class="s3">,</span>
                            <span class="s1">ngrd=</span><span class="s4">0</span><span class="s3">,</span>
                            <span class="s1">eps=</span><span class="s4">2.0 </span><span class="s1">** -</span><span class="s4">52.0</span><span class="s3">,</span>
                            <span class="s1">epsneg=epsneg_f64</span><span class="s3">,</span>
                            <span class="s1">huge=(</span><span class="s4">1.0 </span><span class="s1">- epsneg_f64) / tiny_f64 * f64(</span><span class="s4">4</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">tiny=tiny_f64)</span>
    <span class="s1">_register_type(float64_ma</span><span class="s3">, </span><span class="s6">b'</span><span class="s3">\x9a\x99\x99\x99\x99\x99\xb9\xbf</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s1">_float_ma[</span><span class="s4">64</span><span class="s1">] = float64_ma</span>

    <span class="s5"># Known parameters for IEEE 754 128-bit binary float</span>
    <span class="s1">ld = ntypes.longdouble</span>
    <span class="s1">epsneg_f128 = exp2(ld(-</span><span class="s4">113</span><span class="s1">))</span>
    <span class="s1">tiny_f128 = exp2(ld(-</span><span class="s4">16382</span><span class="s1">))</span>
    <span class="s5"># Ignore runtime error when this is not f128</span>
    <span class="s3">with </span><span class="s1">numeric.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
        <span class="s1">huge_f128 = (ld(</span><span class="s4">1</span><span class="s1">) - epsneg_f128) / tiny_f128 * ld(</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">float128_ma = MachArLike(ld</span><span class="s3">,</span>
                             <span class="s1">machep=-</span><span class="s4">112</span><span class="s3">,</span>
                             <span class="s1">negep=-</span><span class="s4">113</span><span class="s3">,</span>
                             <span class="s1">minexp=-</span><span class="s4">16382</span><span class="s3">,</span>
                             <span class="s1">maxexp=</span><span class="s4">16384</span><span class="s3">,</span>
                             <span class="s1">it=</span><span class="s4">112</span><span class="s3">,</span>
                             <span class="s1">iexp=</span><span class="s4">15</span><span class="s3">,</span>
                             <span class="s1">ibeta=</span><span class="s4">2</span><span class="s3">,</span>
                             <span class="s1">irnd=</span><span class="s4">5</span><span class="s3">,</span>
                             <span class="s1">ngrd=</span><span class="s4">0</span><span class="s3">,</span>
                             <span class="s1">eps=exp2(ld(-</span><span class="s4">112</span><span class="s1">))</span><span class="s3">,</span>
                             <span class="s1">epsneg=epsneg_f128</span><span class="s3">,</span>
                             <span class="s1">huge=huge_f128</span><span class="s3">,</span>
                             <span class="s1">tiny=tiny_f128)</span>
    <span class="s5"># IEEE 754 128-bit binary float</span>
    <span class="s1">_register_type(float128_ma</span><span class="s3">,</span>
        <span class="s6">b'</span><span class="s3">\x9a\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\xfb\xbf</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s1">_register_type(float128_ma</span><span class="s3">,</span>
        <span class="s6">b'</span><span class="s3">\x9a\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\xfb\xbf</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s1">_float_ma[</span><span class="s4">128</span><span class="s1">] = float128_ma</span>

    <span class="s5"># Known parameters for float80 (Intel 80-bit extended precision)</span>
    <span class="s1">epsneg_f80 = exp2(ld(-</span><span class="s4">64</span><span class="s1">))</span>
    <span class="s1">tiny_f80 = exp2(ld(-</span><span class="s4">16382</span><span class="s1">))</span>
    <span class="s5"># Ignore runtime error when this is not f80</span>
    <span class="s3">with </span><span class="s1">numeric.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
        <span class="s1">huge_f80 = (ld(</span><span class="s4">1</span><span class="s1">) - epsneg_f80) / tiny_f80 * ld(</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">float80_ma = MachArLike(ld</span><span class="s3">,</span>
                            <span class="s1">machep=-</span><span class="s4">63</span><span class="s3">,</span>
                            <span class="s1">negep=-</span><span class="s4">64</span><span class="s3">,</span>
                            <span class="s1">minexp=-</span><span class="s4">16382</span><span class="s3">,</span>
                            <span class="s1">maxexp=</span><span class="s4">16384</span><span class="s3">,</span>
                            <span class="s1">it=</span><span class="s4">63</span><span class="s3">,</span>
                            <span class="s1">iexp=</span><span class="s4">15</span><span class="s3">,</span>
                            <span class="s1">ibeta=</span><span class="s4">2</span><span class="s3">,</span>
                            <span class="s1">irnd=</span><span class="s4">5</span><span class="s3">,</span>
                            <span class="s1">ngrd=</span><span class="s4">0</span><span class="s3">,</span>
                            <span class="s1">eps=exp2(ld(-</span><span class="s4">63</span><span class="s1">))</span><span class="s3">,</span>
                            <span class="s1">epsneg=epsneg_f80</span><span class="s3">,</span>
                            <span class="s1">huge=huge_f80</span><span class="s3">,</span>
                            <span class="s1">tiny=tiny_f80)</span>
    <span class="s5"># float80, first 10 bytes containing actual storage</span>
    <span class="s1">_register_type(float80_ma</span><span class="s3">, </span><span class="s6">b'</span><span class="s3">\xcd\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xfb\xbf</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s1">_float_ma[</span><span class="s4">80</span><span class="s1">] = float80_ma</span>

    <span class="s5"># Guessed / known parameters for double double; see:</span>
    <span class="s5"># https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic</span>
    <span class="s5"># These numbers have the same exponent range as float64, but extended number of</span>
    <span class="s5"># digits in the significand.</span>
    <span class="s1">huge_dd = nextafter(ld(inf)</span><span class="s3">, </span><span class="s1">ld(</span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=ld)</span>
    <span class="s5"># As the smallest_normal in double double is so hard to calculate we set</span>
    <span class="s5"># it to NaN.</span>
    <span class="s1">smallest_normal_dd = NaN</span>
    <span class="s5"># Leave the same value for the smallest subnormal as double</span>
    <span class="s1">smallest_subnormal_dd = ld(nextafter(</span><span class="s4">0.</span><span class="s3">, </span><span class="s4">1.</span><span class="s1">))</span>
    <span class="s1">float_dd_ma = MachArLike(ld</span><span class="s3">,</span>
                             <span class="s1">machep=-</span><span class="s4">105</span><span class="s3">,</span>
                             <span class="s1">negep=-</span><span class="s4">106</span><span class="s3">,</span>
                             <span class="s1">minexp=-</span><span class="s4">1022</span><span class="s3">,</span>
                             <span class="s1">maxexp=</span><span class="s4">1024</span><span class="s3">,</span>
                             <span class="s1">it=</span><span class="s4">105</span><span class="s3">,</span>
                             <span class="s1">iexp=</span><span class="s4">11</span><span class="s3">,</span>
                             <span class="s1">ibeta=</span><span class="s4">2</span><span class="s3">,</span>
                             <span class="s1">irnd=</span><span class="s4">5</span><span class="s3">,</span>
                             <span class="s1">ngrd=</span><span class="s4">0</span><span class="s3">,</span>
                             <span class="s1">eps=exp2(ld(-</span><span class="s4">105</span><span class="s1">))</span><span class="s3">,</span>
                             <span class="s1">epsneg=exp2(ld(-</span><span class="s4">106</span><span class="s1">))</span><span class="s3">,</span>
                             <span class="s1">huge=huge_dd</span><span class="s3">,</span>
                             <span class="s1">tiny=smallest_normal_dd</span><span class="s3">,</span>
                             <span class="s1">smallest_subnormal=smallest_subnormal_dd)</span>
    <span class="s5"># double double; low, high order (e.g. PPC 64)</span>
    <span class="s1">_register_type(float_dd_ma</span><span class="s3">,</span>
        <span class="s6">b'</span><span class="s3">\x9a\x99\x99\x99\x99\x99</span><span class="s6">Y&lt;</span><span class="s3">\x9a\x99\x99\x99\x99\x99\xb9\xbf</span><span class="s6">'</span><span class="s1">)</span>
    <span class="s5"># double double; high, low order (e.g. PPC 64 le)</span>
    <span class="s1">_register_type(float_dd_ma</span><span class="s3">,</span>
        <span class="s6">b'</span><span class="s3">\x9a\x99\x99\x99\x99\x99\xb9\xbf\x9a\x99\x99\x99\x99\x99</span><span class="s6">Y&lt;'</span><span class="s1">)</span>
    <span class="s1">_float_ma[</span><span class="s2">'dd'</span><span class="s1">] = float_dd_ma</span>


<span class="s3">def </span><span class="s1">_get_machar(ftype):</span>
    <span class="s0">&quot;&quot;&quot; Get MachAr instance or MachAr-like instance 
 
    Get parameters for floating point type, by first trying signatures of 
    various known floating point types, then, if none match, attempting to 
    identify parameters by analysis. 
 
    Parameters 
    ---------- 
    ftype : class 
        Numpy floating point type class (e.g. ``np.float64``) 
 
    Returns 
    ------- 
    ma_like : instance of :class:`MachAr` or :class:`MachArLike` 
        Object giving floating point parameters for `ftype`. 
 
    Warns 
    ----- 
    UserWarning 
        If the binary signature of the float type is not in the dictionary of 
        known float types. 
    &quot;&quot;&quot;</span>
    <span class="s1">params = _MACHAR_PARAMS.get(ftype)</span>
    <span class="s3">if </span><span class="s1">params </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(repr(ftype))</span>
    <span class="s5"># Detect known / suspected types</span>
    <span class="s1">key = ftype(</span><span class="s2">'-0.1'</span><span class="s1">).newbyteorder(</span><span class="s2">'&lt;'</span><span class="s1">).tobytes()</span>
    <span class="s1">ma_like = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">ftype == ntypes.longdouble:</span>
        <span class="s5"># Could be 80 bit == 10 byte extended precision, where last bytes can</span>
        <span class="s5"># be random garbage.</span>
        <span class="s5"># Comparing first 10 bytes to pattern first to avoid branching on the</span>
        <span class="s5"># random garbage.</span>
        <span class="s1">ma_like = _KNOWN_TYPES.get(key[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">ma_like </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">ma_like = _KNOWN_TYPES.get(key)</span>
    <span class="s3">if </span><span class="s1">ma_like </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">ma_like</span>
    <span class="s5"># Fall back to parameter discovery</span>
    <span class="s1">warnings.warn(</span>
        <span class="s2">'Signature {} for {} does not match any known type: '</span>
        <span class="s2">'falling back to type probe function'</span><span class="s1">.format(key</span><span class="s3">, </span><span class="s1">ftype)</span><span class="s3">,</span>
        <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_discovered_machar(ftype)</span>


<span class="s3">def </span><span class="s1">_discovered_machar(ftype):</span>
    <span class="s0">&quot;&quot;&quot; Create MachAr instance with found information on float types 
    &quot;&quot;&quot;</span>
    <span class="s1">params = _MACHAR_PARAMS[ftype]</span>
    <span class="s3">return </span><span class="s1">MachAr(</span><span class="s3">lambda </span><span class="s1">v: array([v]</span><span class="s3">, </span><span class="s1">ftype)</span><span class="s3">,</span>
                  <span class="s3">lambda </span><span class="s1">v:_fr0(v.astype(params[</span><span class="s2">'itype'</span><span class="s1">]))[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                  <span class="s3">lambda </span><span class="s1">v:array(_fr0(v)[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ftype)</span><span class="s3">,</span>
                  <span class="s3">lambda </span><span class="s1">v: params[</span><span class="s2">'fmt'</span><span class="s1">] % array(_fr0(v)[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ftype)</span><span class="s3">,</span>
                  <span class="s1">params[</span><span class="s2">'title'</span><span class="s1">])</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">class </span><span class="s1">finfo:</span>
    <span class="s0">&quot;&quot;&quot; 
    finfo(dtype) 
 
    Machine limits for floating point types. 
 
    Attributes 
    ---------- 
    bits : int 
        The number of bits occupied by the type. 
    eps : float 
        The difference between 1.0 and the next smallest representable float 
        larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 
        standard, ``eps = 2**-52``, approximately 2.22e-16. 
    epsneg : float 
        The difference between 1.0 and the next smallest representable float 
        less than 1.0. For example, for 64-bit binary floats in the IEEE-754 
        standard, ``epsneg = 2**-53``, approximately 1.11e-16. 
    iexp : int 
        The number of bits in the exponent portion of the floating point 
        representation. 
    machar : MachAr 
        The object which calculated these parameters and holds more 
        detailed information. 
 
        .. deprecated:: 1.22 
    machep : int 
        The exponent that yields `eps`. 
    max : floating point number of the appropriate type 
        The largest representable number. 
    maxexp : int 
        The smallest positive power of the base (2) that causes overflow. 
    min : floating point number of the appropriate type 
        The smallest representable number, typically ``-max``. 
    minexp : int 
        The most negative power of the base (2) consistent with there 
        being no leading 0's in the mantissa. 
    negep : int 
        The exponent that yields `epsneg`. 
    nexp : int 
        The number of bits in the exponent including its sign and bias. 
    nmant : int 
        The number of bits in the mantissa. 
    precision : int 
        The approximate number of decimal digits to which this kind of 
        float is precise. 
    resolution : floating point number of the appropriate type 
        The approximate decimal resolution of this type, i.e., 
        ``10**-precision``. 
    tiny : float 
        An alias for `smallest_normal`, kept for backwards compatibility. 
    smallest_normal : float 
        The smallest positive floating point number with 1 as leading bit in 
        the mantissa following IEEE-754 (see Notes). 
    smallest_subnormal : float 
        The smallest positive floating point number with 0 as leading bit in 
        the mantissa following IEEE-754. 
 
    Parameters 
    ---------- 
    dtype : float, dtype, or instance 
        Kind of floating point data-type about which to get information. 
 
    See Also 
    -------- 
    MachAr : The implementation of the tests that produce this information. 
    iinfo : The equivalent for integer data types. 
    spacing : The distance between a value and the nearest adjacent number 
    nextafter : The next floating point value after x1 towards x2 
 
    Notes 
    ----- 
    For developers of NumPy: do not instantiate this at the module level. 
    The initial calculation of these parameters is expensive and negatively 
    impacts import times.  These objects are cached, so calling ``finfo()`` 
    repeatedly inside your functions is not a problem. 
 
    Note that ``smallest_normal`` is not actually the smallest positive 
    representable value in a NumPy floating point type. As in the IEEE-754 
    standard [1]_, NumPy floating point types make use of subnormal numbers to 
    fill the gap between 0 and ``smallest_normal``. However, subnormal numbers 
    may have significantly reduced precision [2]_. 
 
    References 
    ---------- 
    .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008, 
           pp.1-70, 2008, http://www.doi.org/10.1109/IEEESTD.2008.4610935 
    .. [2] Wikipedia, &quot;Denormal Numbers&quot;, 
           https://en.wikipedia.org/wiki/Denormal_number 
    &quot;&quot;&quot;</span>

    <span class="s1">_finfo_cache = {}</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">dtype):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">dtype = numeric.dtype(dtype)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s5"># In case a float instance was given</span>
            <span class="s1">dtype = numeric.dtype(type(dtype))</span>

        <span class="s1">obj = cls._finfo_cache.get(dtype</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">obj</span>
        <span class="s1">dtypes = [dtype]</span>
        <span class="s1">newdtype = numeric.obj2sctype(dtype)</span>
        <span class="s3">if </span><span class="s1">newdtype </span><span class="s3">is not </span><span class="s1">dtype:</span>
            <span class="s1">dtypes.append(newdtype)</span>
            <span class="s1">dtype = newdtype</span>
        <span class="s3">if not </span><span class="s1">issubclass(dtype</span><span class="s3">, </span><span class="s1">numeric.inexact):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;data type %r not inexact&quot; </span><span class="s1">% (dtype))</span>
        <span class="s1">obj = cls._finfo_cache.get(dtype</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">obj</span>
        <span class="s3">if not </span><span class="s1">issubclass(dtype</span><span class="s3">, </span><span class="s1">numeric.floating):</span>
            <span class="s1">newdtype = _convert_to_float[dtype]</span>
            <span class="s3">if </span><span class="s1">newdtype </span><span class="s3">is not </span><span class="s1">dtype:</span>
                <span class="s1">dtypes.append(newdtype)</span>
                <span class="s1">dtype = newdtype</span>
        <span class="s1">obj = cls._finfo_cache.get(dtype</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">obj</span>
        <span class="s1">obj = object.__new__(cls)._init(dtype)</span>
        <span class="s3">for </span><span class="s1">dt </span><span class="s3">in </span><span class="s1">dtypes:</span>
            <span class="s1">cls._finfo_cache[dt] = obj</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">_init(self</span><span class="s3">, </span><span class="s1">dtype):</span>
        <span class="s1">self.dtype = numeric.dtype(dtype)</span>
        <span class="s1">machar = _get_machar(dtype)</span>

        <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'precision'</span><span class="s3">, </span><span class="s2">'iexp'</span><span class="s3">,</span>
                     <span class="s2">'maxexp'</span><span class="s3">, </span><span class="s2">'minexp'</span><span class="s3">, </span><span class="s2">'negep'</span><span class="s3">,</span>
                     <span class="s2">'machep'</span><span class="s1">]:</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">getattr(machar</span><span class="s3">, </span><span class="s1">word))</span>
        <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'resolution'</span><span class="s3">, </span><span class="s2">'epsneg'</span><span class="s3">, </span><span class="s2">'smallest_subnormal'</span><span class="s1">]:</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">word</span><span class="s3">, </span><span class="s1">getattr(machar</span><span class="s3">, </span><span class="s1">word).flat[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">self.bits = self.dtype.itemsize * </span><span class="s4">8</span>
        <span class="s1">self.max = machar.huge.flat[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.min = -self.max</span>
        <span class="s1">self.eps = machar.eps.flat[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.nexp = machar.iexp</span>
        <span class="s1">self.nmant = machar.it</span>
        <span class="s1">self._machar = machar</span>
        <span class="s1">self._str_tiny = machar._str_xmin.strip()</span>
        <span class="s1">self._str_max = machar._str_xmax.strip()</span>
        <span class="s1">self._str_epsneg = machar._str_epsneg.strip()</span>
        <span class="s1">self._str_eps = machar._str_eps.strip()</span>
        <span class="s1">self._str_resolution = machar._str_resolution.strip()</span>
        <span class="s1">self._str_smallest_normal = machar._str_smallest_normal.strip()</span>
        <span class="s1">self._str_smallest_subnormal = machar._str_smallest_subnormal.strip()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s1">fmt = (</span>
            <span class="s2">'Machine parameters for %(dtype)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'---------------------------------------------------------------</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'precision = %(precision)3s   resolution = %(_str_resolution)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'machep = %(machep)6s   eps =        %(_str_eps)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'negep =  %(negep)6s   epsneg =     %(_str_epsneg)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'minexp = %(minexp)6s   tiny =       %(_str_tiny)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'maxexp = %(maxexp)6s   max =        %(_str_max)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'nexp =   %(nexp)6s   min =        -max</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'smallest_normal = %(_str_smallest_normal)s   '</span>
            <span class="s2">'smallest_subnormal = %(_str_smallest_subnormal)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'---------------------------------------------------------------</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">fmt % self.__dict__</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">c = self.__class__.__name__</span>
        <span class="s1">d = self.__dict__.copy()</span>
        <span class="s1">d[</span><span class="s2">'klass'</span><span class="s1">] = c</span>
        <span class="s3">return </span><span class="s1">((</span><span class="s2">&quot;%(klass)s(resolution=%(resolution)s, min=-%(_str_max)s,&quot;</span>
                 <span class="s2">&quot; max=%(_str_max)s, dtype=%(dtype)s)&quot;</span><span class="s1">) % d)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">smallest_normal(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the value for the smallest normal. 
 
        Returns 
        ------- 
        smallest_normal : float 
            Value for the smallest normal. 
 
        Warns 
        ----- 
        UserWarning 
            If the calculated value for the smallest normal is requested for 
            double-double. 
        &quot;&quot;&quot;</span>
        <span class="s5"># This check is necessary because the value for smallest_normal is</span>
        <span class="s5"># platform dependent for longdouble types.</span>
        <span class="s3">if </span><span class="s1">isnan(self._machar.smallest_normal.flat[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">'The value of smallest normal is undefined for double double'</span><span class="s3">,</span>
                <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._machar.smallest_normal.flat[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">tiny(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the value for tiny, alias of smallest_normal. 
 
        Returns 
        ------- 
        tiny : float 
            Value for the smallest normal, alias of smallest_normal. 
 
        Warns 
        ----- 
        UserWarning 
            If the calculated value for the smallest normal is requested for 
            double-double. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.smallest_normal</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">machar(self):</span>
        <span class="s0">&quot;&quot;&quot;The object which calculated these parameters and holds more 
        detailed information. 
 
        .. deprecated:: 1.22 
        &quot;&quot;&quot;</span>
        <span class="s5"># Deprecated 2021-10-27, NumPy 1.22</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;`finfo.machar` is deprecated (NumPy 1.22)&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._machar</span>


<span class="s1">@set_module(</span><span class="s2">'numpy'</span><span class="s1">)</span>
<span class="s3">class </span><span class="s1">iinfo:</span>
    <span class="s0">&quot;&quot;&quot; 
    iinfo(type) 
 
    Machine limits for integer types. 
 
    Attributes 
    ---------- 
    bits : int 
        The number of bits occupied by the type. 
    min : int 
        The smallest integer expressible by the type. 
    max : int 
        The largest integer expressible by the type. 
 
    Parameters 
    ---------- 
    int_type : integer type, dtype, or instance 
        The kind of integer data type to get information about. 
 
    See Also 
    -------- 
    finfo : The equivalent for floating point data types. 
 
    Examples 
    -------- 
    With types: 
 
    &gt;&gt;&gt; ii16 = np.iinfo(np.int16) 
    &gt;&gt;&gt; ii16.min 
    -32768 
    &gt;&gt;&gt; ii16.max 
    32767 
    &gt;&gt;&gt; ii32 = np.iinfo(np.int32) 
    &gt;&gt;&gt; ii32.min 
    -2147483648 
    &gt;&gt;&gt; ii32.max 
    2147483647 
 
    With instances: 
 
    &gt;&gt;&gt; ii32 = np.iinfo(np.int32(10)) 
    &gt;&gt;&gt; ii32.min 
    -2147483648 
    &gt;&gt;&gt; ii32.max 
    2147483647 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_min_vals = {}</span>
    <span class="s1">_max_vals = {}</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">int_type):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.dtype = numeric.dtype(int_type)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s1">self.dtype = numeric.dtype(type(int_type))</span>
        <span class="s1">self.kind = self.dtype.kind</span>
        <span class="s1">self.bits = self.dtype.itemsize * </span><span class="s4">8</span>
        <span class="s1">self.key = </span><span class="s2">&quot;%s%d&quot; </span><span class="s1">% (self.kind</span><span class="s3">, </span><span class="s1">self.bits)</span>
        <span class="s3">if </span><span class="s1">self.kind </span><span class="s3">not in </span><span class="s2">'iu'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid integer data type %r.&quot; </span><span class="s1">% (self.kind</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">min(self):</span>
        <span class="s0">&quot;&quot;&quot;Minimum value of given dtype.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.kind == </span><span class="s2">'u'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">val = iinfo._min_vals[self.key]</span>
            <span class="s3">except </span><span class="s1">KeyError:</span>
                <span class="s1">val = int(-(</span><span class="s4">1 </span><span class="s1">&lt;&lt; (self.bits-</span><span class="s4">1</span><span class="s1">)))</span>
                <span class="s1">iinfo._min_vals[self.key] = val</span>
            <span class="s3">return </span><span class="s1">val</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">max(self):</span>
        <span class="s0">&quot;&quot;&quot;Maximum value of given dtype.&quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">val = iinfo._max_vals[self.key]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">if </span><span class="s1">self.kind == </span><span class="s2">'u'</span><span class="s1">:</span>
                <span class="s1">val = int((</span><span class="s4">1 </span><span class="s1">&lt;&lt; self.bits) - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">val = int((</span><span class="s4">1 </span><span class="s1">&lt;&lt; (self.bits-</span><span class="s4">1</span><span class="s1">)) - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">iinfo._max_vals[self.key] = val</span>
        <span class="s3">return </span><span class="s1">val</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s0">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="s1">fmt = (</span>
            <span class="s2">'Machine parameters for %(dtype)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'---------------------------------------------------------------</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'min = %(min)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'max = %(max)s</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s2">'---------------------------------------------------------------</span><span class="s3">\n</span><span class="s2">'</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">fmt % {</span><span class="s2">'dtype'</span><span class="s1">: self.dtype</span><span class="s3">, </span><span class="s2">'min'</span><span class="s1">: self.min</span><span class="s3">, </span><span class="s2">'max'</span><span class="s1">: self.max}</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s2">&quot;%s(min=%s, max=%s, dtype=%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">,</span>
                                    <span class="s1">self.min</span><span class="s3">, </span><span class="s1">self.max</span><span class="s3">, </span><span class="s1">self.dtype)</span>
</pre>
</body>
</html>