<html>
<head>
<title>ccompiler_opt.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ccompiler_opt.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Provides the `CCompilerOpt` class, used for handling the CPU/hardware 
optimization, starting from parsing the command arguments, to managing the 
relation between the CPU baseline and dispatch-able features, 
also generating the required C headers and ending with compiling 
the sources with proper compiler's flags. 
 
`CCompilerOpt` doesn't provide runtime detection for the CPU features, 
instead only focuses on the compiler side, but it creates abstract C headers 
that can be used later for the final runtime dispatching process.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">atexit</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pprint</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">textwrap</span>


<span class="s2">class </span><span class="s1">_Config:</span>
    <span class="s0">&quot;&quot;&quot;An abstract class holds all configurable attributes of `CCompilerOpt`, 
    these class attributes can be used to change the default behavior 
    of `CCompilerOpt` in order to fit other requirements. 
 
    Attributes 
    ---------- 
    conf_nocache : bool 
        Set True to disable memory and file cache. 
        Default is False. 
 
    conf_noopt : bool 
        Set True to forces the optimization to be disabled, 
        in this case `CCompilerOpt` tends to generate all 
        expected headers in order to 'not' break the build. 
        Default is False. 
 
    conf_cache_factors : list 
        Add extra factors to the primary caching factors. The caching factors 
        are utilized to determine if there are changes had happened that 
        requires to discard the cache and re-updating it. The primary factors 
        are the arguments of `CCompilerOpt` and `CCompiler`'s properties(type, flags, etc). 
        Default is list of two items, containing the time of last modification 
        of `ccompiler_opt` and value of attribute &quot;conf_noopt&quot; 
 
    conf_tmp_path : str, 
        The path of temporary directory. Default is auto-created 
        temporary directory via ``tempfile.mkdtemp()``. 
 
    conf_check_path : str 
        The path of testing files. Each added CPU feature must have a 
        **C** source file contains at least one intrinsic or instruction that 
        related to this feature, so it can be tested against the compiler. 
        Default is ``./distutils/checks``. 
 
    conf_target_groups : dict 
        Extra tokens that can be reached from dispatch-able sources through 
        the special mark ``@targets``. Default is an empty dictionary. 
 
        **Notes**: 
            - case-insensitive for tokens and group names 
            - sign '#' must stick in the begin of group name and only within ``@targets`` 
 
        **Example**: 
            .. code-block:: console 
 
                $ &quot;@targets #avx_group other_tokens&quot; &gt; group_inside.c 
 
            &gt;&gt;&gt; CCompilerOpt.conf_target_groups[&quot;avx_group&quot;] = \\ 
            &quot;$werror $maxopt avx2 avx512f avx512_skx&quot; 
            &gt;&gt;&gt; cco = CCompilerOpt(cc_instance) 
            &gt;&gt;&gt; cco.try_dispatch([&quot;group_inside.c&quot;]) 
 
    conf_c_prefix : str 
        The prefix of public C definitions. Default is ``&quot;NPY_&quot;``. 
 
    conf_c_prefix_ : str 
        The prefix of internal C definitions. Default is ``&quot;NPY__&quot;``. 
 
    conf_cc_flags : dict 
        Nested dictionaries defining several compiler flags 
        that linked to some major functions, the main key 
        represent the compiler name and sub-keys represent 
        flags names. Default is already covers all supported 
        **C** compilers. 
 
        Sub-keys explained as follows: 
 
        &quot;native&quot;: str or None 
            used by argument option `native`, to detect the current 
            machine support via the compiler. 
        &quot;werror&quot;: str or None 
            utilized to treat warning as errors during testing CPU features 
            against the compiler and also for target's policy `$werror` 
            via dispatch-able sources. 
        &quot;maxopt&quot;: str or None 
            utilized for target's policy '$maxopt' and the value should 
            contains the maximum acceptable optimization by the compiler. 
            e.g. in gcc `'-O3'` 
 
        **Notes**: 
            * case-sensitive for compiler names and flags 
            * use space to separate multiple flags 
            * any flag will tested against the compiler and it will skipped 
              if it's not applicable. 
 
    conf_min_features : dict 
        A dictionary defines the used CPU features for 
        argument option `'min'`, the key represent the CPU architecture 
        name e.g. `'x86'`. Default values provide the best effort 
        on wide range of users platforms. 
 
        **Note**: case-sensitive for architecture names. 
 
    conf_features : dict 
        Nested dictionaries used for identifying the CPU features. 
        the primary key is represented as a feature name or group name 
        that gathers several features. Default values covers all 
        supported features but without the major options like &quot;flags&quot;, 
        these undefined options handle it by method `conf_features_partial()`. 
        Default value is covers almost all CPU features for *X86*, *IBM/Power64* 
        and *ARM 7/8*. 
 
        Sub-keys explained as follows: 
 
        &quot;implies&quot; : str or list, optional, 
            List of CPU feature names to be implied by it, 
            the feature name must be defined within `conf_features`. 
            Default is None. 
 
        &quot;flags&quot;: str or list, optional 
            List of compiler flags. Default is None. 
 
        &quot;detect&quot;: str or list, optional 
            List of CPU feature names that required to be detected 
            in runtime. By default, its the feature name or features 
            in &quot;group&quot; if its specified. 
 
        &quot;implies_detect&quot;: bool, optional 
            If True, all &quot;detect&quot; of implied features will be combined. 
            Default is True. see `feature_detect()`. 
 
        &quot;group&quot;: str or list, optional 
            Same as &quot;implies&quot; but doesn't require the feature name to be 
            defined within `conf_features`. 
 
        &quot;interest&quot;: int, required 
            a key for sorting CPU features 
 
        &quot;headers&quot;: str or list, optional 
            intrinsics C header file 
 
        &quot;disable&quot;: str, optional 
            force disable feature, the string value should contains the 
            reason of disabling. 
 
        &quot;autovec&quot;: bool or None, optional 
            True or False to declare that CPU feature can be auto-vectorized 
            by the compiler. 
            By default(None), treated as True if the feature contains at 
            least one applicable flag. see `feature_can_autovec()` 
 
        &quot;extra_checks&quot;: str or list, optional 
            Extra test case names for the CPU feature that need to be tested 
            against the compiler. 
 
            Each test case must have a C file named ``extra_xxxx.c``, where 
            ``xxxx`` is the case name in lower case, under 'conf_check_path'. 
            It should contain at least one intrinsic or function related to the test case. 
 
            If the compiler able to successfully compile the C file then `CCompilerOpt` 
            will add a C ``#define`` for it into the main dispatch header, e.g. 
            ```#define {conf_c_prefix}_XXXX`` where ``XXXX`` is the case name in upper case. 
 
        **NOTES**: 
            * space can be used as separator with options that supports &quot;str or list&quot; 
            * case-sensitive for all values and feature name must be in upper-case. 
            * if flags aren't applicable, its will skipped rather than disable the 
              CPU feature 
            * the CPU feature will disabled if the compiler fail to compile 
              the test file 
    &quot;&quot;&quot;</span>
    <span class="s1">conf_nocache = </span><span class="s2">False</span>
    <span class="s1">conf_noopt = </span><span class="s2">False</span>
    <span class="s1">conf_cache_factors = </span><span class="s2">None</span>
    <span class="s1">conf_tmp_path = </span><span class="s2">None</span>
    <span class="s1">conf_check_path = os.path.join(</span>
        <span class="s1">os.path.dirname(os.path.realpath(__file__))</span><span class="s2">, </span><span class="s3">&quot;checks&quot;</span>
    <span class="s1">)</span>
    <span class="s1">conf_target_groups = {}</span>
    <span class="s1">conf_c_prefix = </span><span class="s3">'NPY_'</span>
    <span class="s1">conf_c_prefix_ = </span><span class="s3">'NPY__'</span>
    <span class="s1">conf_cc_flags = dict(</span>
        <span class="s1">gcc = dict(</span>
            <span class="s4"># native should always fail on arm and ppc64,</span>
            <span class="s4"># native usually works only with x86</span>
            <span class="s1">native = </span><span class="s3">'-march=native'</span><span class="s2">,</span>
            <span class="s1">opt = </span><span class="s3">'-O3'</span><span class="s2">,</span>
            <span class="s1">werror = </span><span class="s3">'-Werror'</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">clang = dict(</span>
            <span class="s1">native = </span><span class="s3">'-march=native'</span><span class="s2">,</span>
            <span class="s1">opt = </span><span class="s3">&quot;-O3&quot;</span><span class="s2">,</span>
            <span class="s4"># One of the following flags needs to be applicable for Clang to</span>
            <span class="s4"># guarantee the sanity of the testing process, however in certain</span>
            <span class="s4"># cases `-Werror` gets skipped during the availability test due to</span>
            <span class="s4"># &quot;unused arguments&quot; warnings.</span>
            <span class="s4"># see https://github.com/numpy/numpy/issues/19624</span>
            <span class="s1">werror = </span><span class="s3">'-Werror=switch -Werror'</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">icc = dict(</span>
            <span class="s1">native = </span><span class="s3">'-xHost'</span><span class="s2">,</span>
            <span class="s1">opt = </span><span class="s3">'-O3'</span><span class="s2">,</span>
            <span class="s1">werror = </span><span class="s3">'-Werror'</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">iccw = dict(</span>
            <span class="s1">native = </span><span class="s3">'/QxHost'</span><span class="s2">,</span>
            <span class="s1">opt = </span><span class="s3">'/O3'</span><span class="s2">,</span>
            <span class="s1">werror = </span><span class="s3">'/Werror'</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">msvc = dict(</span>
            <span class="s1">native = </span><span class="s2">None,</span>
            <span class="s1">opt = </span><span class="s3">'/O2'</span><span class="s2">,</span>
            <span class="s1">werror = </span><span class="s3">'/WX'</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">conf_min_features = dict(</span>
        <span class="s1">x86 = </span><span class="s3">&quot;SSE SSE2&quot;</span><span class="s2">,</span>
        <span class="s1">x64 = </span><span class="s3">&quot;SSE SSE2 SSE3&quot;</span><span class="s2">,</span>
        <span class="s1">ppc64 = </span><span class="s3">''</span><span class="s2">, </span><span class="s4"># play it safe</span>
        <span class="s1">ppc64le = </span><span class="s3">&quot;VSX VSX2&quot;</span><span class="s2">,</span>
        <span class="s1">armhf = </span><span class="s3">''</span><span class="s2">, </span><span class="s4"># play it safe</span>
        <span class="s1">aarch64 = </span><span class="s3">&quot;NEON NEON_FP16 NEON_VFPV4 ASIMD&quot;</span>
    <span class="s1">)</span>
    <span class="s1">conf_features = dict(</span>
        <span class="s4"># X86</span>
        <span class="s1">SSE = dict(</span>
            <span class="s1">interest=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;xmmintrin.h&quot;</span><span class="s2">,</span>
            <span class="s4"># enabling SSE without SSE2 is useless also</span>
            <span class="s4"># it's non-optional for x86_64</span>
            <span class="s1">implies=</span><span class="s3">&quot;SSE2&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">SSE2   = dict(interest=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;SSE&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;emmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">SSE3   = dict(interest=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;SSE2&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;pmmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">SSSE3  = dict(interest=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;SSE3&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;tmmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">SSE41  = dict(interest=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;SSSE3&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;smmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">POPCNT = dict(interest=</span><span class="s5">6</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;SSE41&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;popcntintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">SSE42  = dict(interest=</span><span class="s5">7</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;POPCNT&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX    = dict(</span>
            <span class="s1">interest=</span><span class="s5">8</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;SSE42&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;immintrin.h&quot;</span><span class="s2">,</span>
            <span class="s1">implies_detect=</span><span class="s2">False</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">XOP    = dict(interest=</span><span class="s5">9</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;x86intrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">FMA4   = dict(interest=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX&quot;</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;x86intrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">F16C   = dict(interest=</span><span class="s5">11</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">FMA3   = dict(interest=</span><span class="s5">12</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;F16C&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX2   = dict(interest=</span><span class="s5">13</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;F16C&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512F = dict(</span>
            <span class="s1">interest=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;FMA3 AVX2&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False,</span>
            <span class="s1">extra_checks=</span><span class="s3">&quot;AVX512F_REDUCE&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512CD = dict(interest=</span><span class="s5">21</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512F&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512_KNL = dict(</span>
            <span class="s1">interest=</span><span class="s5">40</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512CD&quot;</span><span class="s2">, </span><span class="s1">group=</span><span class="s3">&quot;AVX512ER AVX512PF&quot;</span><span class="s2">,</span>
            <span class="s1">detect=</span><span class="s3">&quot;AVX512_KNL&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512_KNM = dict(</span>
            <span class="s1">interest=</span><span class="s5">41</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512_KNL&quot;</span><span class="s2">,</span>
            <span class="s1">group=</span><span class="s3">&quot;AVX5124FMAPS AVX5124VNNIW AVX512VPOPCNTDQ&quot;</span><span class="s2">,</span>
            <span class="s1">detect=</span><span class="s3">&quot;AVX512_KNM&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512_SKX = dict(</span>
            <span class="s1">interest=</span><span class="s5">42</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512CD&quot;</span><span class="s2">, </span><span class="s1">group=</span><span class="s3">&quot;AVX512VL AVX512BW AVX512DQ&quot;</span><span class="s2">,</span>
            <span class="s1">detect=</span><span class="s3">&quot;AVX512_SKX&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False,</span>
            <span class="s1">extra_checks=</span><span class="s3">&quot;AVX512BW_MASK AVX512DQ_MASK&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512_CLX = dict(</span>
            <span class="s1">interest=</span><span class="s5">43</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512_SKX&quot;</span><span class="s2">, </span><span class="s1">group=</span><span class="s3">&quot;AVX512VNNI&quot;</span><span class="s2">,</span>
            <span class="s1">detect=</span><span class="s3">&quot;AVX512_CLX&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512_CNL = dict(</span>
            <span class="s1">interest=</span><span class="s5">44</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512_SKX&quot;</span><span class="s2">, </span><span class="s1">group=</span><span class="s3">&quot;AVX512IFMA AVX512VBMI&quot;</span><span class="s2">,</span>
            <span class="s1">detect=</span><span class="s3">&quot;AVX512_CNL&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">AVX512_ICL = dict(</span>
            <span class="s1">interest=</span><span class="s5">45</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;AVX512_CLX AVX512_CNL&quot;</span><span class="s2">,</span>
            <span class="s1">group=</span><span class="s3">&quot;AVX512VBMI2 AVX512BITALG AVX512VPOPCNTDQ&quot;</span><span class="s2">,</span>
            <span class="s1">detect=</span><span class="s3">&quot;AVX512_ICL&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s4"># IBM/Power</span>
        <span class="s4">## Power7/ISA 2.06</span>
        <span class="s1">VSX = dict(interest=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;altivec.h&quot;</span><span class="s2">, </span><span class="s1">extra_checks=</span><span class="s3">&quot;VSX_ASM&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## Power8/ISA 2.07</span>
        <span class="s1">VSX2 = dict(interest=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;VSX&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## Power9/ISA 3.00</span>
        <span class="s1">VSX3 = dict(interest=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;VSX2&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4"># ARM</span>
        <span class="s1">NEON  = dict(interest=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">headers=</span><span class="s3">&quot;arm_neon.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">NEON_FP16 = dict(interest=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;NEON&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## FMA</span>
        <span class="s1">NEON_VFPV4 = dict(interest=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;NEON_FP16&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## Advanced SIMD</span>
        <span class="s1">ASIMD = dict(interest=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;NEON_FP16 NEON_VFPV4&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## ARMv8.2 half-precision &amp; vector arithm</span>
        <span class="s1">ASIMDHP = dict(interest=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;ASIMD&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## ARMv8.2 dot product</span>
        <span class="s1">ASIMDDP = dict(interest=</span><span class="s5">6</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;ASIMD&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">## ARMv8.2 Single &amp; half-precision Multiply</span>
        <span class="s1">ASIMDFHM = dict(interest=</span><span class="s5">7</span><span class="s2">, </span><span class="s1">implies=</span><span class="s3">&quot;ASIMDHP&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">conf_features_partial(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of supported CPU features by the platform, 
        and accumulate the rest of undefined options in `conf_features`, 
        the returned dict has same rules and notes in 
        class attribute `conf_features`, also its override 
        any options that been set in 'conf_features'. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.cc_noopt:</span>
            <span class="s4"># optimization is disabled</span>
            <span class="s2">return </span><span class="s1">{}</span>

        <span class="s1">on_x86 = self.cc_on_x86 </span><span class="s2">or </span><span class="s1">self.cc_on_x64</span>
        <span class="s1">is_unix = self.cc_is_gcc </span><span class="s2">or </span><span class="s1">self.cc_is_clang</span>

        <span class="s2">if </span><span class="s1">on_x86 </span><span class="s2">and </span><span class="s1">is_unix: </span><span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">SSE    = dict(flags=</span><span class="s3">&quot;-msse&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE2   = dict(flags=</span><span class="s3">&quot;-msse2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE3   = dict(flags=</span><span class="s3">&quot;-msse3&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSSE3  = dict(flags=</span><span class="s3">&quot;-mssse3&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE41  = dict(flags=</span><span class="s3">&quot;-msse4.1&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">POPCNT = dict(flags=</span><span class="s3">&quot;-mpopcnt&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE42  = dict(flags=</span><span class="s3">&quot;-msse4.2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX    = dict(flags=</span><span class="s3">&quot;-mavx&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">F16C   = dict(flags=</span><span class="s3">&quot;-mf16c&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">XOP    = dict(flags=</span><span class="s3">&quot;-mxop&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">FMA4   = dict(flags=</span><span class="s3">&quot;-mfma4&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">FMA3   = dict(flags=</span><span class="s3">&quot;-mfma&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX2   = dict(flags=</span><span class="s3">&quot;-mavx2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512F = dict(flags=</span><span class="s3">&quot;-mavx512f&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512CD = dict(flags=</span><span class="s3">&quot;-mavx512cd&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNL = dict(flags=</span><span class="s3">&quot;-mavx512er -mavx512pf&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNM = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_SKX = dict(flags=</span><span class="s3">&quot;-mavx512vl -mavx512bw -mavx512dq&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CLX = dict(flags=</span><span class="s3">&quot;-mavx512vnni&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CNL = dict(flags=</span><span class="s3">&quot;-mavx512ifma -mavx512vbmi&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_ICL = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-mavx512vbmi2 -mavx512bitalg -mavx512vpopcntdq&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">on_x86 </span><span class="s2">and </span><span class="s1">self.cc_is_icc: </span><span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">SSE    = dict(flags=</span><span class="s3">&quot;-msse&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE2   = dict(flags=</span><span class="s3">&quot;-msse2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE3   = dict(flags=</span><span class="s3">&quot;-msse3&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSSE3  = dict(flags=</span><span class="s3">&quot;-mssse3&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE41  = dict(flags=</span><span class="s3">&quot;-msse4.1&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">POPCNT = {}</span><span class="s2">,</span>
            <span class="s1">SSE42  = dict(flags=</span><span class="s3">&quot;-msse4.2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX    = dict(flags=</span><span class="s3">&quot;-mavx&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">F16C   = {}</span><span class="s2">,</span>
            <span class="s1">XOP    = dict(disable=</span><span class="s3">&quot;Intel Compiler doesn't support it&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">FMA4   = dict(disable=</span><span class="s3">&quot;Intel Compiler doesn't support it&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># Intel Compiler doesn't support AVX2 or FMA3 independently</span>
            <span class="s1">FMA3 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;F16C AVX2&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;-march=core-avx2&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX2 = dict(implies=</span><span class="s3">&quot;FMA3&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;-march=core-avx2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># Intel Compiler doesn't support AVX512F or AVX512CD independently</span>
            <span class="s1">AVX512F = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;AVX2 AVX512CD&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;-march=common-avx512&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512CD = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;AVX2 AVX512F&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;-march=common-avx512&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNL = dict(flags=</span><span class="s3">&quot;-xKNL&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNM = dict(flags=</span><span class="s3">&quot;-xKNM&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_SKX = dict(flags=</span><span class="s3">&quot;-xSKYLAKE-AVX512&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CLX = dict(flags=</span><span class="s3">&quot;-xCASCADELAKE&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CNL = dict(flags=</span><span class="s3">&quot;-xCANNONLAKE&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_ICL = dict(flags=</span><span class="s3">&quot;-xICELAKE-CLIENT&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">on_x86 </span><span class="s2">and </span><span class="s1">self.cc_is_iccw: </span><span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">SSE    = dict(flags=</span><span class="s3">&quot;/arch:SSE&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE2   = dict(flags=</span><span class="s3">&quot;/arch:SSE2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE3   = dict(flags=</span><span class="s3">&quot;/arch:SSE3&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSSE3  = dict(flags=</span><span class="s3">&quot;/arch:SSSE3&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE41  = dict(flags=</span><span class="s3">&quot;/arch:SSE4.1&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">POPCNT = {}</span><span class="s2">,</span>
            <span class="s1">SSE42  = dict(flags=</span><span class="s3">&quot;/arch:SSE4.2&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX    = dict(flags=</span><span class="s3">&quot;/arch:AVX&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">F16C   = {}</span><span class="s2">,</span>
            <span class="s1">XOP    = dict(disable=</span><span class="s3">&quot;Intel Compiler doesn't support it&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">FMA4   = dict(disable=</span><span class="s3">&quot;Intel Compiler doesn't support it&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># Intel Compiler doesn't support FMA3 or AVX2 independently</span>
            <span class="s1">FMA3 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;F16C AVX2&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/arch:CORE-AVX2&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX2 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;FMA3&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/arch:CORE-AVX2&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># Intel Compiler doesn't support AVX512F or AVX512CD independently</span>
            <span class="s1">AVX512F = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;AVX2 AVX512CD&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/Qx:COMMON-AVX512&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512CD = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;AVX2 AVX512F&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/Qx:COMMON-AVX512&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNL = dict(flags=</span><span class="s3">&quot;/Qx:KNL&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNM = dict(flags=</span><span class="s3">&quot;/Qx:KNM&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_SKX = dict(flags=</span><span class="s3">&quot;/Qx:SKYLAKE-AVX512&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CLX = dict(flags=</span><span class="s3">&quot;/Qx:CASCADELAKE&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CNL = dict(flags=</span><span class="s3">&quot;/Qx:CANNONLAKE&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_ICL = dict(flags=</span><span class="s3">&quot;/Qx:ICELAKE-CLIENT&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">on_x86 </span><span class="s2">and </span><span class="s1">self.cc_is_msvc: </span><span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">SSE = dict(flags=</span><span class="s3">&quot;/arch:SSE&quot;</span><span class="s1">) </span><span class="s2">if </span><span class="s1">self.cc_on_x86 </span><span class="s2">else </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">SSE2 = dict(flags=</span><span class="s3">&quot;/arch:SSE2&quot;</span><span class="s1">) </span><span class="s2">if </span><span class="s1">self.cc_on_x86 </span><span class="s2">else </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">SSE3   = {}</span><span class="s2">,</span>
            <span class="s1">SSSE3  = {}</span><span class="s2">,</span>
            <span class="s1">SSE41  = {}</span><span class="s2">,</span>
            <span class="s1">POPCNT = dict(headers=</span><span class="s3">&quot;nmmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">SSE42  = {}</span><span class="s2">,</span>
            <span class="s1">AVX    = dict(flags=</span><span class="s3">&quot;/arch:AVX&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">F16C   = {}</span><span class="s2">,</span>
            <span class="s1">XOP    = dict(headers=</span><span class="s3">&quot;ammintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">FMA4   = dict(headers=</span><span class="s3">&quot;ammintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># MSVC doesn't support FMA3 or AVX2 independently</span>
            <span class="s1">FMA3 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;F16C AVX2&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/arch:AVX2&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX2 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;F16C FMA3&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/arch:AVX2&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># MSVC doesn't support AVX512F or AVX512CD independently,</span>
            <span class="s4"># always generate instructions belong to (VL/VW/DQ)</span>
            <span class="s1">AVX512F = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;AVX2 AVX512CD AVX512_SKX&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/arch:AVX512&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512CD = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;AVX512F AVX512_SKX&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s3">&quot;/arch:AVX512&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNL = dict(</span>
                <span class="s1">disable=</span><span class="s3">&quot;MSVC compiler doesn't support it&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_KNM = dict(</span>
                <span class="s1">disable=</span><span class="s3">&quot;MSVC compiler doesn't support it&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_SKX = dict(flags=</span><span class="s3">&quot;/arch:AVX512&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AVX512_CLX = {}</span><span class="s2">,</span>
            <span class="s1">AVX512_CNL = {}</span><span class="s2">,</span>
            <span class="s1">AVX512_ICL = {}</span>
        <span class="s1">)</span>

        <span class="s1">on_power = self.cc_on_ppc64le </span><span class="s2">or </span><span class="s1">self.cc_on_ppc64</span>
        <span class="s2">if </span><span class="s1">on_power:</span>
            <span class="s1">partial = dict(</span>
                <span class="s1">VSX = dict(</span>
                    <span class="s1">implies=(</span><span class="s3">&quot;VSX2&quot; </span><span class="s2">if </span><span class="s1">self.cc_on_ppc64le </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">flags=</span><span class="s3">&quot;-mvsx&quot;</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">VSX2 = dict(</span>
                    <span class="s1">flags=</span><span class="s3">&quot;-mcpu=power8&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">VSX3 = dict(</span>
                    <span class="s1">flags=</span><span class="s3">&quot;-mcpu=power9 -mtune=power9&quot;</span><span class="s2">, </span><span class="s1">implies_detect=</span><span class="s2">False</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.cc_is_clang:</span>
                <span class="s1">partial[</span><span class="s3">&quot;VSX&quot;</span><span class="s1">][</span><span class="s3">&quot;flags&quot;</span><span class="s1">]  = </span><span class="s3">&quot;-maltivec -mvsx&quot;</span>
                <span class="s1">partial[</span><span class="s3">&quot;VSX2&quot;</span><span class="s1">][</span><span class="s3">&quot;flags&quot;</span><span class="s1">] = </span><span class="s3">&quot;-mpower8-vector&quot;</span>
                <span class="s1">partial[</span><span class="s3">&quot;VSX3&quot;</span><span class="s1">][</span><span class="s3">&quot;flags&quot;</span><span class="s1">] = </span><span class="s3">&quot;-mpower9-vector&quot;</span>

            <span class="s2">return </span><span class="s1">partial</span>

        <span class="s2">if </span><span class="s1">self.cc_on_aarch64 </span><span class="s2">and </span><span class="s1">is_unix: </span><span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">NEON = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;NEON_FP16 NEON_VFPV4 ASIMD&quot;</span><span class="s2">, </span><span class="s1">autovec=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">NEON_FP16 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;NEON NEON_VFPV4 ASIMD&quot;</span><span class="s2">, </span><span class="s1">autovec=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">NEON_VFPV4 = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;NEON NEON_FP16 ASIMD&quot;</span><span class="s2">, </span><span class="s1">autovec=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMD = dict(</span>
                <span class="s1">implies=</span><span class="s3">&quot;NEON NEON_FP16 NEON_VFPV4&quot;</span><span class="s2">, </span><span class="s1">autovec=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMDHP = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-march=armv8.2-a+fp16&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMDDP = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-march=armv8.2-a+dotprod&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMDFHM = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-march=armv8.2-a+fp16fml&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.cc_on_armhf </span><span class="s2">and </span><span class="s1">is_unix: </span><span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">NEON = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-mfpu=neon&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">NEON_FP16 = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-mfpu=neon-fp16 -mfp16-format=ieee&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">NEON_VFPV4 = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-mfpu=neon-vfpv4&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMD = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-mfpu=neon-fp-armv8 -march=armv8-a+simd&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMDHP = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-march=armv8.2-a+fp16&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMDDP = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-march=armv8.2-a+dotprod&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">ASIMDFHM = dict(</span>
                <span class="s1">flags=</span><span class="s3">&quot;-march=armv8.2-a+fp16fml&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s4"># TODO: ARM MSVC</span>
        <span class="s2">return </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">self.conf_tmp_path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">shutil</span>
            <span class="s2">import </span><span class="s1">tempfile</span>
            <span class="s1">tmp = tempfile.mkdtemp()</span>
            <span class="s2">def </span><span class="s1">rm_temp():</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">shutil.rmtree(tmp)</span>
                <span class="s2">except </span><span class="s1">OSError:</span>
                    <span class="s2">pass</span>
            <span class="s1">atexit.register(rm_temp)</span>
            <span class="s1">self.conf_tmp_path = tmp</span>

        <span class="s2">if </span><span class="s1">self.conf_cache_factors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.conf_cache_factors = [</span>
                <span class="s1">os.path.getmtime(__file__)</span><span class="s2">,</span>
                <span class="s1">self.conf_nocache</span>
            <span class="s1">]</span>

<span class="s2">class </span><span class="s1">_Distutils:</span>
    <span class="s0">&quot;&quot;&quot;A helper class that provides a collection of fundamental methods 
    implemented in a top of Python and NumPy Distutils. 
 
    The idea behind this class is to gather all methods that it may 
    need to override in case of reuse 'CCompilerOpt' in environment 
    different than of what NumPy has. 
 
    Parameters 
    ---------- 
    ccompiler : `CCompiler` 
        The generate instance that returned from `distutils.ccompiler.new_compiler()`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ccompiler):</span>
        <span class="s1">self._ccompiler = ccompiler</span>

    <span class="s2">def </span><span class="s1">dist_compile(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">ccompiler=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Wrap CCompiler.compile()&quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(isinstance(sources</span><span class="s2">, </span><span class="s1">list))</span>
        <span class="s2">assert</span><span class="s1">(isinstance(flags</span><span class="s2">, </span><span class="s1">list))</span>
        <span class="s1">flags = kwargs.pop(</span><span class="s3">&quot;extra_postargs&quot;</span><span class="s2">, </span><span class="s1">[]) + flags</span>
        <span class="s2">if not </span><span class="s1">ccompiler:</span>
            <span class="s1">ccompiler = self._ccompiler</span>

        <span class="s2">return </span><span class="s1">ccompiler.compile(sources</span><span class="s2">, </span><span class="s1">extra_postargs=flags</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">dist_test(self</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">macros=[]):</span>
        <span class="s0">&quot;&quot;&quot;Return True if 'CCompiler.compile()' able to compile 
        a source file with certain flags. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(isinstance(source</span><span class="s2">, </span><span class="s1">str))</span>
        <span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">CompileError</span>
        <span class="s1">cc = self._ccompiler;</span>
        <span class="s1">bk_spawn = getattr(cc</span><span class="s2">, </span><span class="s3">'spawn'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">bk_spawn:</span>
            <span class="s1">cc_type = getattr(self._ccompiler</span><span class="s2">, </span><span class="s3">&quot;compiler_type&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">cc_type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;msvc&quot;</span><span class="s2">,</span><span class="s1">):</span>
                <span class="s1">setattr(cc</span><span class="s2">, </span><span class="s3">'spawn'</span><span class="s2">, </span><span class="s1">self._dist_test_spawn_paths)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">setattr(cc</span><span class="s2">, </span><span class="s3">'spawn'</span><span class="s2">, </span><span class="s1">self._dist_test_spawn)</span>
        <span class="s1">test = </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.dist_compile(</span>
                <span class="s1">[source]</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">macros=macros</span><span class="s2">, </span><span class="s1">output_dir=self.conf_tmp_path</span>
            <span class="s1">)</span>
            <span class="s1">test = </span><span class="s2">True</span>
        <span class="s2">except </span><span class="s1">CompileError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">self.dist_log(str(e)</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">bk_spawn:</span>
            <span class="s1">setattr(cc</span><span class="s2">, </span><span class="s3">'spawn'</span><span class="s2">, </span><span class="s1">bk_spawn)</span>
        <span class="s2">return </span><span class="s1">test</span>

    <span class="s2">def </span><span class="s1">dist_info(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a tuple containing info about (platform, compiler, extra_args), 
        required by the abstract class '_CCompiler' for discovering the 
        platform environment. This is also used as a cache factor in order 
        to detect any changes happening from outside. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;_dist_info&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._dist_info</span>

        <span class="s1">cc_type = getattr(self._ccompiler</span><span class="s2">, </span><span class="s3">&quot;compiler_type&quot;</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">cc_type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;intelem&quot;</span><span class="s2">, </span><span class="s3">&quot;intelemw&quot;</span><span class="s1">):</span>
            <span class="s1">platform = </span><span class="s3">&quot;x86_64&quot;</span>
        <span class="s2">elif </span><span class="s1">cc_type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;intel&quot;</span><span class="s2">, </span><span class="s3">&quot;intelw&quot;</span><span class="s2">, </span><span class="s3">&quot;intele&quot;</span><span class="s1">):</span>
            <span class="s1">platform = </span><span class="s3">&quot;x86&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">get_platform</span>
            <span class="s1">platform = get_platform()</span>

        <span class="s1">cc_info = getattr(self._ccompiler</span><span class="s2">, </span><span class="s3">&quot;compiler&quot;</span><span class="s2">, </span><span class="s1">getattr(self._ccompiler</span><span class="s2">, </span><span class="s3">&quot;compiler_so&quot;</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s2">if not </span><span class="s1">cc_type </span><span class="s2">or </span><span class="s1">cc_type == </span><span class="s3">&quot;unix&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hasattr(cc_info</span><span class="s2">, </span><span class="s3">&quot;__iter__&quot;</span><span class="s1">):</span>
                <span class="s1">compiler = cc_info[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">compiler = str(cc_info)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">compiler = cc_type</span>

        <span class="s2">if </span><span class="s1">hasattr(cc_info</span><span class="s2">, </span><span class="s3">&quot;__iter__&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">len(cc_info) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">extra_args = </span><span class="s3">' '</span><span class="s1">.join(cc_info[</span><span class="s5">1</span><span class="s1">:])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">extra_args  = os.environ.get(</span><span class="s3">&quot;CFLAGS&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">extra_args += os.environ.get(</span><span class="s3">&quot;CPPFLAGS&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">self._dist_info = (platform</span><span class="s2">, </span><span class="s1">compiler</span><span class="s2">, </span><span class="s1">extra_args)</span>
        <span class="s2">return </span><span class="s1">self._dist_info</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">dist_error(*args):</span>
        <span class="s0">&quot;&quot;&quot;Raise a compiler error&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">CompileError</span>
        <span class="s2">raise </span><span class="s1">CompileError(_Distutils._dist_str(*args))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">dist_fatal(*args):</span>
        <span class="s0">&quot;&quot;&quot;Raise a distutils error&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsError</span>
        <span class="s2">raise </span><span class="s1">DistutilsError(_Distutils._dist_str(*args))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">dist_log(*args</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Print a console message&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">numpy.distutils </span><span class="s2">import </span><span class="s1">log</span>
        <span class="s1">out = _Distutils._dist_str(*args)</span>
        <span class="s2">if </span><span class="s1">stderr:</span>
            <span class="s1">log.warn(out)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.info(out)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">dist_load_module(name</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s0">&quot;&quot;&quot;Load a module from file, required by the abstract class '_Cache'.&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.misc_util </span><span class="s2">import </span><span class="s1">exec_mod_from_location</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">exec_mod_from_location(name</span><span class="s2">, </span><span class="s1">path)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">_Distutils.dist_log(e</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return None</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_dist_str(*args):</span>
        <span class="s0">&quot;&quot;&quot;Return a string to print by log and errors.&quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">to_str(arg):</span>
            <span class="s2">if not </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">hasattr(arg</span><span class="s2">, </span><span class="s3">'__iter__'</span><span class="s1">):</span>
                <span class="s1">ret = []</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arg:</span>
                    <span class="s1">ret.append(to_str(a))</span>
                <span class="s2">return </span><span class="s3">'('</span><span class="s1">+ </span><span class="s3">' '</span><span class="s1">.join(ret) + </span><span class="s3">')'</span>
            <span class="s2">return </span><span class="s1">str(arg)</span>

        <span class="s1">stack = inspect.stack()[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">start = </span><span class="s3">&quot;CCompilerOpt.%s[%d] : &quot; </span><span class="s1">% (stack.function</span><span class="s2">, </span><span class="s1">stack.lineno)</span>
        <span class="s1">out = </span><span class="s3">' '</span><span class="s1">.join([</span>
            <span class="s1">to_str(a)</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">(*args</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">])</span>
        <span class="s2">return </span><span class="s1">start + out</span>

    <span class="s2">def </span><span class="s1">_dist_test_spawn_paths(self</span><span class="s2">, </span><span class="s1">cmd</span><span class="s2">, </span><span class="s1">display=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fix msvc SDK ENV path same as distutils do 
        without it we get c1: fatal error C1356: unable to find mspdbcore.dll 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr(self._ccompiler</span><span class="s2">, </span><span class="s3">&quot;_paths&quot;</span><span class="s1">):</span>
            <span class="s1">self._dist_test_spawn(cmd)</span>
            <span class="s2">return</span>
        <span class="s1">old_path = os.getenv(</span><span class="s3">&quot;path&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">os.environ[</span><span class="s3">&quot;path&quot;</span><span class="s1">] = self._ccompiler._paths</span>
            <span class="s1">self._dist_test_spawn(cmd)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">os.environ[</span><span class="s3">&quot;path&quot;</span><span class="s1">] = old_path</span>

    <span class="s1">_dist_warn_regex = re.compile(</span>
        <span class="s4"># intel and msvc compilers don't raise</span>
        <span class="s4"># fatal errors when flags are wrong or unsupported</span>
        <span class="s3">&quot;.*(&quot;</span>
        <span class="s3">&quot;warning D9002|&quot;  </span><span class="s4"># msvc, it should be work with any language.</span>
        <span class="s3">&quot;invalid argument for option&quot; </span><span class="s4"># intel</span>
        <span class="s3">&quot;).*&quot;</span>
    <span class="s1">)</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_dist_test_spawn(cmd</span><span class="s2">, </span><span class="s1">display=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">o = subprocess.check_output(cmd</span><span class="s2">, </span><span class="s1">stderr=subprocess.STDOUT</span><span class="s2">,</span>
                                        <span class="s1">universal_newlines=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">o </span><span class="s2">and </span><span class="s1">re.match(_Distutils._dist_warn_regex</span><span class="s2">, </span><span class="s1">o):</span>
                <span class="s1">_Distutils.dist_error(</span>
                    <span class="s3">&quot;Flags in command&quot;</span><span class="s2">, </span><span class="s1">cmd </span><span class="s2">,</span><span class="s3">&quot;aren't supported by the compiler&quot;</span>
                    <span class="s3">&quot;, output -&gt; </span><span class="s2">\n</span><span class="s3">%s&quot; </span><span class="s1">% o</span>
                <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">subprocess.CalledProcessError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">o = exc.output</span>
            <span class="s1">s = exc.returncode</span>
        <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">o = e</span>
            <span class="s1">s = </span><span class="s5">127</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s1">_Distutils.dist_error(</span>
            <span class="s3">&quot;Command&quot;</span><span class="s2">, </span><span class="s1">cmd</span><span class="s2">, </span><span class="s3">&quot;failed with exit status %d output -&gt; </span><span class="s2">\n</span><span class="s3">%s&quot; </span><span class="s1">% (</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">o</span>
        <span class="s1">))</span>

<span class="s1">_share_cache = {}</span>
<span class="s2">class </span><span class="s1">_Cache:</span>
    <span class="s0">&quot;&quot;&quot;An abstract class handles caching functionality, provides two 
    levels of caching, in-memory by share instances attributes among 
    each other and by store attributes into files. 
 
    **Note**: 
        any attributes that start with ``_`` or ``conf_`` will be ignored. 
 
    Parameters 
    ---------- 
    cache_path: str or None 
        The path of cache file, if None then cache in file will disabled. 
 
    *factors: 
        The caching factors that need to utilize next to `conf_cache_factors`. 
 
    Attributes 
    ---------- 
    cache_private: set 
        Hold the attributes that need be skipped from &quot;in-memory cache&quot;. 
 
    cache_infile: bool 
        Utilized during initializing this class, to determine if the cache was able 
        to loaded from the specified cache path in 'cache_path'. 
    &quot;&quot;&quot;</span>

    <span class="s4"># skip attributes from cache</span>
    <span class="s1">_cache_ignore = re.compile(</span><span class="s3">&quot;^(_|conf_)&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">cache_path=</span><span class="s2">None, </span><span class="s1">*factors):</span>
        <span class="s1">self.cache_me = {}</span>
        <span class="s1">self.cache_private = set()</span>
        <span class="s1">self.cache_infile = </span><span class="s2">False</span>
        <span class="s1">self._cache_path = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.conf_nocache:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;cache is disabled by `Config`&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>

        <span class="s1">self._cache_hash = self.cache_hash(*factors</span><span class="s2">, </span><span class="s1">*self.conf_cache_factors)</span>
        <span class="s1">self._cache_path = cache_path</span>
        <span class="s2">if </span><span class="s1">cache_path:</span>
            <span class="s2">if </span><span class="s1">os.path.exists(cache_path):</span>
                <span class="s1">self.dist_log(</span><span class="s3">&quot;load cache from file -&gt;&quot;</span><span class="s2">, </span><span class="s1">cache_path)</span>
                <span class="s1">cache_mod = self.dist_load_module(</span><span class="s3">&quot;cache&quot;</span><span class="s2">, </span><span class="s1">cache_path)</span>
                <span class="s2">if not </span><span class="s1">cache_mod:</span>
                    <span class="s1">self.dist_log(</span>
                        <span class="s3">&quot;unable to load the cache file as a module&quot;</span><span class="s2">,</span>
                        <span class="s1">stderr=</span><span class="s2">True</span>
                    <span class="s1">)</span>
                <span class="s2">elif not </span><span class="s1">hasattr(cache_mod</span><span class="s2">, </span><span class="s3">&quot;hash&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">\</span>
                     <span class="s2">not </span><span class="s1">hasattr(cache_mod</span><span class="s2">, </span><span class="s3">&quot;data&quot;</span><span class="s1">):</span>
                    <span class="s1">self.dist_log(</span><span class="s3">&quot;invalid cache file&quot;</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">self._cache_hash == cache_mod.hash:</span>
                    <span class="s1">self.dist_log(</span><span class="s3">&quot;hit the file cache&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">cache_mod.data.items():</span>
                        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>
                    <span class="s1">self.cache_infile = </span><span class="s2">True</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.dist_log(</span><span class="s3">&quot;miss the file cache&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">self.cache_infile:</span>
            <span class="s1">other_cache = _share_cache.get(self._cache_hash)</span>
            <span class="s2">if </span><span class="s1">other_cache:</span>
                <span class="s1">self.dist_log(</span><span class="s3">&quot;hit the memory cache&quot;</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">other_cache.__dict__.items():</span>
                    <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">other_cache.cache_private </span><span class="s2">or </span><span class="s1">\</span>
                               <span class="s1">re.match(self._cache_ignore</span><span class="s2">, </span><span class="s1">attr):</span>
                        <span class="s2">continue</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>

        <span class="s1">_share_cache[self._cache_hash] = self</span>
        <span class="s1">atexit.register(self.cache_flush)</span>

    <span class="s2">def </span><span class="s1">__del__(self):</span>
        <span class="s2">for </span><span class="s1">h</span><span class="s2">, </span><span class="s1">o </span><span class="s2">in </span><span class="s1">_share_cache.items():</span>
            <span class="s2">if </span><span class="s1">o == self:</span>
                <span class="s1">_share_cache.pop(h)</span>
                <span class="s2">break</span>

    <span class="s2">def </span><span class="s1">cache_flush(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Force update the cache. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._cache_path:</span>
            <span class="s2">return</span>
        <span class="s4"># TODO: don't write if the cache doesn't change</span>
        <span class="s1">self.dist_log(</span><span class="s3">&quot;write cache to path -&gt;&quot;</span><span class="s2">, </span><span class="s1">self._cache_path)</span>
        <span class="s1">cdict = self.__dict__.copy()</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.__dict__.keys():</span>
            <span class="s2">if </span><span class="s1">re.match(self._cache_ignore</span><span class="s2">, </span><span class="s1">attr):</span>
                <span class="s1">cdict.pop(attr)</span>

        <span class="s1">d = os.path.dirname(self._cache_path)</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(d):</span>
            <span class="s1">os.makedirs(d)</span>

        <span class="s1">repr_dict = pprint.pformat(cdict</span><span class="s2">, </span><span class="s1">compact=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">open(self._cache_path</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
            </span><span class="s3"># AUTOGENERATED DON'T EDIT 
            # Please make changes to the code generator </span><span class="s2">\ 
            </span><span class="s3">(distutils/ccompiler_opt.py) 
            hash = {} 
            data = </span><span class="s2">\\</span>
            <span class="s3">&quot;&quot;&quot;</span><span class="s1">).format(self._cache_hash))</span>
            <span class="s1">f.write(repr_dict)</span>

    <span class="s2">def </span><span class="s1">cache_hash(self</span><span class="s2">, </span><span class="s1">*factors):</span>
        <span class="s4"># is there a built-in non-crypto hash?</span>
        <span class="s4"># sdbm</span>
        <span class="s1">chash = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">factors:</span>
            <span class="s2">for </span><span class="s1">char </span><span class="s2">in </span><span class="s1">str(f):</span>
                <span class="s1">chash  = ord(char) + (chash &lt;&lt; </span><span class="s5">6</span><span class="s1">) + (chash &lt;&lt; </span><span class="s5">16</span><span class="s1">) - chash</span>
                <span class="s1">chash &amp;= </span><span class="s5">0xFFFFFFFF</span>
        <span class="s2">return </span><span class="s1">chash</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">me(cb):</span>
        <span class="s0">&quot;&quot;&quot; 
        A static method that can be treated as a decorator to 
        dynamically cache certain methods. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">cache_wrap_me(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s4"># good for normal args</span>
            <span class="s1">cache_key = str((</span>
                <span class="s1">cb.__name__</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">*kwargs.keys()</span><span class="s2">, </span><span class="s1">*kwargs.values()</span>
            <span class="s1">))</span>
            <span class="s2">if </span><span class="s1">cache_key </span><span class="s2">in </span><span class="s1">self.cache_me:</span>
                <span class="s2">return </span><span class="s1">self.cache_me[cache_key]</span>
            <span class="s1">ccb = cb(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.cache_me[cache_key] = ccb</span>
            <span class="s2">return </span><span class="s1">ccb</span>
        <span class="s2">return </span><span class="s1">cache_wrap_me</span>

<span class="s2">class </span><span class="s1">_CCompiler:</span>
    <span class="s0">&quot;&quot;&quot;A helper class for `CCompilerOpt` containing all utilities that 
    related to the fundamental compiler's functions. 
 
    Attributes 
    ---------- 
    cc_on_x86 : bool 
        True when the target architecture is 32-bit x86 
    cc_on_x64 : bool 
        True when the target architecture is 64-bit x86 
    cc_on_ppc64 : bool 
        True when the target architecture is 64-bit big-endian PowerPC 
    cc_on_armhf : bool 
        True when the target architecture is 32-bit ARMv7+ 
    cc_on_aarch64 : bool 
        True when the target architecture is 64-bit Armv8-a+ 
    cc_on_noarch : bool 
        True when the target architecture is unknown or not supported 
    cc_is_gcc : bool 
        True if the compiler is GNU or 
        if the compiler is unknown 
    cc_is_clang : bool 
        True if the compiler is Clang 
    cc_is_icc : bool 
        True if the compiler is Intel compiler (unix like) 
    cc_is_iccw : bool 
        True if the compiler is Intel compiler (msvc like) 
    cc_is_nocc : bool 
        True if the compiler isn't supported directly, 
        Note: that cause a fail-back to gcc 
    cc_has_debug : bool 
        True if the compiler has debug flags 
    cc_has_native : bool 
        True if the compiler has native flags 
    cc_noopt : bool 
        True if the compiler has definition 'DISABLE_OPT*', 
        or 'cc_on_noarch' is True 
    cc_march : str 
        The target architecture name, or &quot;unknown&quot; if 
        the architecture isn't supported 
    cc_name : str 
        The compiler name, or &quot;unknown&quot; if the compiler isn't supported 
    cc_flags : dict 
        Dictionary containing the initialized flags of `_Config.conf_cc_flags` 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;cc_is_cached&quot;</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s4">#      attr                regex</span>
        <span class="s1">detect_arch = (</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_x64&quot;</span><span class="s2">,      </span><span class="s3">&quot;.*(x|x86_|amd)64.*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_x86&quot;</span><span class="s2">,      </span><span class="s3">&quot;.*(win32|x86|i386|i686).*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_ppc64le&quot;</span><span class="s2">,  </span><span class="s3">&quot;.*(powerpc|ppc)64(el|le).*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_ppc64&quot;</span><span class="s2">,    </span><span class="s3">&quot;.*(powerpc|ppc)64.*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_aarch64&quot;</span><span class="s2">,  </span><span class="s3">&quot;.*(aarch64|arm64).*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_armhf&quot;</span><span class="s2">,    </span><span class="s3">&quot;.*arm.*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># undefined platform</span>
            <span class="s1">(</span><span class="s3">&quot;cc_on_noarch&quot;</span><span class="s2">,    </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">detect_compiler = (</span>
            <span class="s1">(</span><span class="s3">&quot;cc_is_gcc&quot;</span><span class="s2">,     </span><span class="s3">r&quot;.*(gcc|gnu\-g).*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_is_clang&quot;</span><span class="s2">,    </span><span class="s3">&quot;.*clang.*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;cc_is_iccw&quot;</span><span class="s2">,     </span><span class="s3">&quot;.*(intelw|intelemw|iccw).*&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4"># intel msvc like</span>
            <span class="s1">(</span><span class="s3">&quot;cc_is_icc&quot;</span><span class="s2">,      </span><span class="s3">&quot;.*(intel|icc).*&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4"># intel unix like</span>
            <span class="s1">(</span><span class="s3">&quot;cc_is_msvc&quot;</span><span class="s2">,     </span><span class="s3">&quot;.*msvc.*&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4"># undefined compiler will be treat it as gcc</span>
            <span class="s1">(</span><span class="s3">&quot;cc_is_nocc&quot;</span><span class="s2">,     </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">detect_args = (</span>
           <span class="s1">(</span><span class="s3">&quot;cc_has_debug&quot;</span><span class="s2">,  </span><span class="s3">&quot;.*(O0|Od|ggdb|coverage|debug:full).*&quot;</span><span class="s1">)</span><span class="s2">,</span>
           <span class="s1">(</span><span class="s3">&quot;cc_has_native&quot;</span><span class="s2">, </span><span class="s3">&quot;.*(-march=native|-xHost|/QxHost).*&quot;</span><span class="s1">)</span><span class="s2">,</span>
           <span class="s4"># in case if the class run with -DNPY_DISABLE_OPTIMIZATION</span>
           <span class="s1">(</span><span class="s3">&quot;cc_noopt&quot;</span><span class="s2">, </span><span class="s3">&quot;.*DISABLE_OPT.*&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">dist_info = self.dist_info()</span>
        <span class="s1">platform</span><span class="s2">, </span><span class="s1">compiler_info</span><span class="s2">, </span><span class="s1">extra_args = dist_info</span>
        <span class="s4"># set False to all attrs</span>
        <span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">(detect_arch</span><span class="s2">, </span><span class="s1">detect_compiler</span><span class="s2">, </span><span class="s1">detect_args):</span>
            <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">rgex </span><span class="s2">in </span><span class="s1">section:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">detect</span><span class="s2">, </span><span class="s1">searchin </span><span class="s2">in </span><span class="s1">((detect_arch</span><span class="s2">, </span><span class="s1">platform)</span><span class="s2">, </span><span class="s1">(detect_compiler</span><span class="s2">, </span><span class="s1">compiler_info)):</span>
            <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">rgex </span><span class="s2">in </span><span class="s1">detect:</span>
                <span class="s2">if </span><span class="s1">rgex </span><span class="s2">and not </span><span class="s1">re.match(rgex</span><span class="s2">, </span><span class="s1">searchin</span><span class="s2">, </span><span class="s1">re.IGNORECASE):</span>
                    <span class="s2">continue</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s2">break</span>

        <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">rgex </span><span class="s2">in </span><span class="s1">detect_args:</span>
            <span class="s2">if </span><span class="s1">rgex </span><span class="s2">and not </span><span class="s1">re.match(rgex</span><span class="s2">, </span><span class="s1">extra_args</span><span class="s2">, </span><span class="s1">re.IGNORECASE):</span>
                <span class="s2">continue</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.cc_on_noarch:</span>
            <span class="s1">self.dist_log(</span>
                <span class="s3">&quot;unable to detect CPU architecture which lead to disable the optimization. &quot;</span>
                <span class="s3">f&quot;check dist_info:&lt;&lt;</span><span class="s2">\n{</span><span class="s1">dist_info</span><span class="s2">}\n</span><span class="s3">&gt;&gt;&quot;</span><span class="s2">,</span>
                <span class="s1">stderr=</span><span class="s2">True</span>
            <span class="s1">)</span>
            <span class="s1">self.cc_noopt = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">self.conf_noopt:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;Optimization is disabled by the Config&quot;</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.cc_noopt = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">self.cc_is_nocc:</span>
            <span class="s3">&quot;&quot;&quot; 
            mingw can be treated as a gcc, and also xlc even if it based on clang, 
            but still has the same gcc optimization flags. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.dist_log(</span>
                <span class="s3">&quot;unable to detect compiler type which leads to treating it as GCC. &quot;</span>
                <span class="s3">&quot;this is a normal behavior if you're using gcc-like compiler such as MinGW or IBM/XLC.&quot;</span>
                <span class="s3">f&quot;check dist_info:&lt;&lt;</span><span class="s2">\n{</span><span class="s1">dist_info</span><span class="s2">}\n</span><span class="s3">&gt;&gt;&quot;</span><span class="s2">,</span>
                <span class="s1">stderr=</span><span class="s2">True</span>
            <span class="s1">)</span>
            <span class="s1">self.cc_is_gcc = </span><span class="s2">True</span>

        <span class="s1">self.cc_march = </span><span class="s3">&quot;unknown&quot;</span>
        <span class="s2">for </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;x86&quot;</span><span class="s2">, </span><span class="s3">&quot;x64&quot;</span><span class="s2">, </span><span class="s3">&quot;ppc64&quot;</span><span class="s2">, </span><span class="s3">&quot;ppc64le&quot;</span><span class="s2">, </span><span class="s3">&quot;armhf&quot;</span><span class="s2">, </span><span class="s3">&quot;aarch64&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;cc_on_&quot; </span><span class="s1">+ arch):</span>
                <span class="s1">self.cc_march = arch</span>
                <span class="s2">break</span>

        <span class="s1">self.cc_name = </span><span class="s3">&quot;unknown&quot;</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;gcc&quot;</span><span class="s2">, </span><span class="s3">&quot;clang&quot;</span><span class="s2">, </span><span class="s3">&quot;iccw&quot;</span><span class="s2">, </span><span class="s3">&quot;icc&quot;</span><span class="s2">, </span><span class="s3">&quot;msvc&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;cc_is_&quot; </span><span class="s1">+ name):</span>
                <span class="s1">self.cc_name = name</span>
                <span class="s2">break</span>

        <span class="s1">self.cc_flags = {}</span>
        <span class="s1">compiler_flags = self.conf_cc_flags.get(self.cc_name)</span>
        <span class="s2">if </span><span class="s1">compiler_flags </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.dist_fatal(</span>
                <span class="s3">&quot;undefined flag for compiler '%s', &quot;</span>
                <span class="s3">&quot;leave an empty dict instead&quot; </span><span class="s1">% self.cc_name</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">flags </span><span class="s2">in </span><span class="s1">compiler_flags.items():</span>
            <span class="s1">self.cc_flags[name] = nflags = []</span>
            <span class="s2">if </span><span class="s1">flags:</span>
                <span class="s2">assert</span><span class="s1">(isinstance(flags</span><span class="s2">, </span><span class="s1">str))</span>
                <span class="s1">flags = flags.split()</span>
                <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">flags:</span>
                    <span class="s2">if </span><span class="s1">self.cc_test_flags([f]):</span>
                        <span class="s1">nflags.append(f)</span>

        <span class="s1">self.cc_is_cached = </span><span class="s2">True</span>

    <span class="s1">@_Cache.me</span>
    <span class="s2">def </span><span class="s1">cc_test_flags(self</span><span class="s2">, </span><span class="s1">flags):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns True if the compiler supports 'flags'. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(isinstance(flags</span><span class="s2">, </span><span class="s1">list))</span>
        <span class="s1">self.dist_log(</span><span class="s3">&quot;testing flags&quot;</span><span class="s2">, </span><span class="s1">flags)</span>
        <span class="s1">test_path = os.path.join(self.conf_check_path</span><span class="s2">, </span><span class="s3">&quot;test_flags.c&quot;</span><span class="s1">)</span>
        <span class="s1">test = self.dist_test(test_path</span><span class="s2">, </span><span class="s1">flags)</span>
        <span class="s2">if not </span><span class="s1">test:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;testing failed&quot;</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">test</span>

    <span class="s2">def </span><span class="s1">cc_normalize_flags(self</span><span class="s2">, </span><span class="s1">flags):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove the conflicts that caused due gathering implied features flags. 
 
        Parameters 
        ---------- 
        'flags' list, compiler flags 
            flags should be sorted from the lowest to the highest interest. 
 
        Returns 
        ------- 
        list, filtered from any conflicts. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; self.cc_normalize_flags(['-march=armv8.2-a+fp16', '-march=armv8.2-a+dotprod']) 
        ['armv8.2-a+fp16+dotprod'] 
 
        &gt;&gt;&gt; self.cc_normalize_flags( 
            ['-msse', '-msse2', '-msse3', '-mssse3', '-msse4.1', '-msse4.2', '-mavx', '-march=core-avx2'] 
        ) 
        ['-march=core-avx2'] 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(isinstance(flags</span><span class="s2">, </span><span class="s1">list))</span>
        <span class="s2">if </span><span class="s1">self.cc_is_gcc </span><span class="s2">or </span><span class="s1">self.cc_is_clang </span><span class="s2">or </span><span class="s1">self.cc_is_icc:</span>
            <span class="s2">return </span><span class="s1">self._cc_normalize_unix(flags)</span>

        <span class="s2">if </span><span class="s1">self.cc_is_msvc </span><span class="s2">or </span><span class="s1">self.cc_is_iccw:</span>
            <span class="s2">return </span><span class="s1">self._cc_normalize_win(flags)</span>
        <span class="s2">return </span><span class="s1">flags</span>

    <span class="s1">_cc_normalize_unix_mrgx = re.compile(</span>
        <span class="s4"># 1- to check the highest of</span>
        <span class="s3">r&quot;^(-mcpu=|-march=|-x[A-Z0-9\-])&quot;</span>
    <span class="s1">)</span>
    <span class="s1">_cc_normalize_unix_frgx = re.compile(</span>
        <span class="s4"># 2- to remove any flags starts with</span>
        <span class="s4"># -march, -mcpu, -x(INTEL) and '-m' without '='</span>
        <span class="s3">r&quot;^(?!(-mcpu=|-march=|-x[A-Z0-9\-]))(?!-m[a-z0-9\-\.]*.$)&quot;</span>
    <span class="s1">)</span>
    <span class="s1">_cc_normalize_unix_krgx = re.compile(</span>
        <span class="s4"># 3- keep only the highest of</span>
        <span class="s3">r&quot;^(-mfpu|-mtune)&quot;</span>
    <span class="s1">)</span>
    <span class="s1">_cc_normalize_arch_ver = re.compile(</span>
        <span class="s3">r&quot;[0-9.]&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">_cc_normalize_unix(self</span><span class="s2">, </span><span class="s1">flags):</span>
        <span class="s2">def </span><span class="s1">ver_flags(f):</span>
            <span class="s4">#        arch ver  subflag</span>
            <span class="s4"># -march=armv8.2-a+fp16fml</span>
            <span class="s1">tokens = f.split(</span><span class="s3">'+'</span><span class="s1">)</span>
            <span class="s1">ver = float(</span><span class="s3">'0' </span><span class="s1">+ </span><span class="s3">''</span><span class="s1">.join(</span>
                <span class="s1">re.findall(self._cc_normalize_arch_ver</span><span class="s2">, </span><span class="s1">tokens[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">))</span>
            <span class="s2">return </span><span class="s1">ver</span><span class="s2">, </span><span class="s1">tokens[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tokens[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s2">if </span><span class="s1">len(flags) &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">flags</span>
        <span class="s4"># get the highest matched flag</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">cur_flag </span><span class="s2">in </span><span class="s1">enumerate(reversed(flags)):</span>
            <span class="s2">if not </span><span class="s1">re.match(self._cc_normalize_unix_mrgx</span><span class="s2">, </span><span class="s1">cur_flag):</span>
                <span class="s2">continue</span>
            <span class="s1">lower_flags = flags[:-(i+</span><span class="s5">1</span><span class="s1">)]</span>
            <span class="s1">upper_flags = flags[-i:]</span>
            <span class="s1">filterd = list(filter(</span>
                <span class="s1">self._cc_normalize_unix_frgx.search</span><span class="s2">, </span><span class="s1">lower_flags</span>
            <span class="s1">))</span>
            <span class="s4"># gather subflags</span>
            <span class="s1">ver</span><span class="s2">, </span><span class="s1">arch</span><span class="s2">, </span><span class="s1">subflags = ver_flags(cur_flag)</span>
            <span class="s2">if </span><span class="s1">ver &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">len(subflags) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">xflag </span><span class="s2">in </span><span class="s1">lower_flags:</span>
                    <span class="s1">xver</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">xsubflags = ver_flags(xflag)</span>
                    <span class="s2">if </span><span class="s1">ver == xver:</span>
                        <span class="s1">subflags = xsubflags + subflags</span>
                <span class="s1">cur_flag = arch + </span><span class="s3">'+' </span><span class="s1">+ </span><span class="s3">'+'</span><span class="s1">.join(subflags)</span>

            <span class="s1">flags = filterd + [cur_flag]</span>
            <span class="s2">if </span><span class="s1">i &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">flags += upper_flags</span>
            <span class="s2">break</span>

        <span class="s4"># to remove overridable flags</span>
        <span class="s1">final_flags = []</span>
        <span class="s1">matched = set()</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">reversed(flags):</span>
            <span class="s1">match = re.match(self._cc_normalize_unix_krgx</span><span class="s2">, </span><span class="s1">f)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">match[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">matched:</span>
                <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">matched.add(match[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">final_flags.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">f)</span>
        <span class="s2">return </span><span class="s1">final_flags</span>

    <span class="s1">_cc_normalize_win_frgx = re.compile(</span>
        <span class="s3">r&quot;^(?!(/arch\:|/Qx\:))&quot;</span>
    <span class="s1">)</span>
    <span class="s1">_cc_normalize_win_mrgx = re.compile(</span>
        <span class="s3">r&quot;^(/arch|/Qx:)&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">_cc_normalize_win(self</span><span class="s2">, </span><span class="s1">flags):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">enumerate(reversed(flags)):</span>
            <span class="s2">if not </span><span class="s1">re.match(self._cc_normalize_win_mrgx</span><span class="s2">, </span><span class="s1">f):</span>
                <span class="s2">continue</span>
            <span class="s1">i += </span><span class="s5">1</span>
            <span class="s2">return </span><span class="s1">list(filter(</span>
                <span class="s1">self._cc_normalize_win_frgx.search</span><span class="s2">, </span><span class="s1">flags[:-i]</span>
            <span class="s1">)) + flags[-i:]</span>
        <span class="s2">return </span><span class="s1">flags</span>

<span class="s2">class </span><span class="s1">_Feature:</span>
    <span class="s0">&quot;&quot;&quot;A helper class for `CCompilerOpt` that managing CPU features. 
 
    Attributes 
    ---------- 
    feature_supported : dict 
        Dictionary containing all CPU features that supported 
        by the platform, according to the specified values in attribute 
        `_Config.conf_features` and `_Config.conf_features_partial()` 
 
    feature_min : set 
        The minimum support of CPU features, according to 
        the specified values in attribute `_Config.conf_min_features`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;feature_is_cached&quot;</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">self.feature_supported = pfeatures = self.conf_features_partial()</span>
        <span class="s2">for </span><span class="s1">feature_name </span><span class="s2">in </span><span class="s1">list(pfeatures.keys()):</span>
            <span class="s1">feature  = pfeatures[feature_name]</span>
            <span class="s1">cfeature = self.conf_features[feature_name]</span>
            <span class="s1">feature.update({</span>
                <span class="s1">k:v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">,</span><span class="s1">v </span><span class="s2">in </span><span class="s1">cfeature.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">feature</span>
            <span class="s1">})</span>
            <span class="s1">disabled = feature.get(</span><span class="s3">&quot;disable&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">disabled </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">pfeatures.pop(feature_name)</span>
                <span class="s1">self.dist_log(</span>
                    <span class="s3">&quot;feature '%s' is disabled,&quot; </span><span class="s1">% feature_name</span><span class="s2">,</span>
                    <span class="s1">disabled</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span>
                <span class="s1">)</span>
                <span class="s2">continue</span>
            <span class="s4"># list is used internally for these options</span>
            <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">(</span>
                <span class="s3">&quot;implies&quot;</span><span class="s2">, </span><span class="s3">&quot;group&quot;</span><span class="s2">, </span><span class="s3">&quot;detect&quot;</span><span class="s2">, </span><span class="s3">&quot;headers&quot;</span><span class="s2">, </span><span class="s3">&quot;flags&quot;</span><span class="s2">, </span><span class="s3">&quot;extra_checks&quot;</span>
            <span class="s1">) :</span>
                <span class="s1">oval = feature.get(option)</span>
                <span class="s2">if </span><span class="s1">isinstance(oval</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">feature[option] = oval.split()</span>

        <span class="s1">self.feature_min = set()</span>
        <span class="s1">min_f = self.conf_min_features.get(self.cc_march</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">F </span><span class="s2">in </span><span class="s1">min_f.upper().split():</span>
            <span class="s2">if </span><span class="s1">F </span><span class="s2">in </span><span class="s1">self.feature_supported:</span>
                <span class="s1">self.feature_min.add(F)</span>

        <span class="s1">self.feature_is_cached = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">feature_names(self</span><span class="s2">, </span><span class="s1">names=</span><span class="s2">None, </span><span class="s1">force_flags=</span><span class="s2">None, </span><span class="s1">macros=[]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a set of CPU feature names that supported by platform and the **C** compiler. 
 
        Parameters 
        ---------- 
        names: sequence or None, optional 
            Specify certain CPU features to test it against the **C** compiler. 
            if None(default), it will test all current supported features. 
            **Note**: feature names must be in upper-case. 
 
        force_flags: list or None, optional 
            If None(default), default compiler flags for every CPU feature will 
            be used during the test. 
 
        macros : list of tuples, optional 
            A list of C macro definitions. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(</span>
            <span class="s1">names </span><span class="s2">is None or </span><span class="s1">(</span>
                <span class="s2">not </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and</span>
                <span class="s1">hasattr(names</span><span class="s2">, </span><span class="s3">&quot;__iter__&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">assert</span><span class="s1">(force_flags </span><span class="s2">is None or </span><span class="s1">isinstance(force_flags</span><span class="s2">, </span><span class="s1">list))</span>
        <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">names = self.feature_supported.keys()</span>
        <span class="s1">supported_names = set()</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s2">if </span><span class="s1">self.feature_is_supported(</span>
                <span class="s1">f</span><span class="s2">, </span><span class="s1">force_flags=force_flags</span><span class="s2">, </span><span class="s1">macros=macros</span>
            <span class="s1">):</span>
                <span class="s1">supported_names.add(f)</span>
        <span class="s2">return </span><span class="s1">supported_names</span>

    <span class="s2">def </span><span class="s1">feature_is_exist(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns True if a certain feature is exist and covered within 
        `_Config.conf_features`. 
 
        Parameters 
        ---------- 
        'name': str 
            feature name in uppercase. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(name.isupper())</span>
        <span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.conf_features</span>

    <span class="s2">def </span><span class="s1">feature_sorted(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sort a list of CPU features ordered by the lowest interest. 
 
        Parameters 
        ---------- 
        'names': sequence 
            sequence of supported feature names in uppercase. 
        'reverse': bool, optional 
            If true, the sorted features is reversed. (highest interest) 
 
        Returns 
        ------- 
        list, sorted CPU features 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">sort_cb(k):</span>
            <span class="s2">if </span><span class="s1">isinstance(k</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">return </span><span class="s1">self.feature_supported[k][</span><span class="s3">&quot;interest&quot;</span><span class="s1">]</span>
            <span class="s4"># multiple features</span>
            <span class="s1">rank = max([self.feature_supported[f][</span><span class="s3">&quot;interest&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">k])</span>
            <span class="s4"># FIXME: that's not a safe way to increase the rank for</span>
            <span class="s4"># multi targets</span>
            <span class="s1">rank += len(k) -</span><span class="s5">1</span>
            <span class="s2">return </span><span class="s1">rank</span>
        <span class="s2">return </span><span class="s1">sorted(names</span><span class="s2">, </span><span class="s1">reverse=reverse</span><span class="s2">, </span><span class="s1">key=sort_cb)</span>

    <span class="s2">def </span><span class="s1">feature_implies(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">keep_origins=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a set of CPU features that implied by 'names' 
 
        Parameters 
        ---------- 
        names: str or sequence of str 
            CPU feature name(s) in uppercase. 
 
        keep_origins: bool 
            if False(default) then the returned set will not contain any 
            features from 'names'. This case happens only when two features 
            imply each other. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; self.feature_implies(&quot;SSE3&quot;) 
        {'SSE', 'SSE2'} 
        &gt;&gt;&gt; self.feature_implies(&quot;SSE2&quot;) 
        {'SSE'} 
        &gt;&gt;&gt; self.feature_implies(&quot;SSE2&quot;, keep_origins=True) 
        # 'SSE2' found here since 'SSE' and 'SSE2' imply each other 
        {'SSE', 'SSE2'} 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">get_implies(name</span><span class="s2">, </span><span class="s1">_caller=set()):</span>
            <span class="s1">implies = set()</span>
            <span class="s1">d = self.feature_supported[name]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">d.get(</span><span class="s3">&quot;implies&quot;</span><span class="s2">, </span><span class="s1">[]):</span>
                <span class="s1">implies.add(i)</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">_caller:</span>
                    <span class="s4"># infinity recursive guard since</span>
                    <span class="s4"># features can imply each other</span>
                    <span class="s2">continue</span>
                <span class="s1">_caller.add(name)</span>
                <span class="s1">implies = implies.union(get_implies(i</span><span class="s2">, </span><span class="s1">_caller))</span>
            <span class="s2">return </span><span class="s1">implies</span>

        <span class="s2">if </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">implies = get_implies(names)</span>
            <span class="s1">names = [names]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert</span><span class="s1">(hasattr(names</span><span class="s2">, </span><span class="s3">&quot;__iter__&quot;</span><span class="s1">))</span>
            <span class="s1">implies = set()</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names:</span>
                <span class="s1">implies = implies.union(get_implies(n))</span>
        <span class="s2">if not </span><span class="s1">keep_origins:</span>
            <span class="s1">implies.difference_update(names)</span>
        <span class="s2">return </span><span class="s1">implies</span>

    <span class="s2">def </span><span class="s1">feature_implies_c(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot;same as feature_implies() but combining 'names'&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">names = set((names</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">names = set(names)</span>
        <span class="s2">return </span><span class="s1">names.union(self.feature_implies(names))</span>

    <span class="s2">def </span><span class="s1">feature_ahead(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return list of features in 'names' after remove any 
        implied features and keep the origins. 
 
        Parameters 
        ---------- 
        'names': sequence 
            sequence of CPU feature names in uppercase. 
 
        Returns 
        ------- 
        list of CPU features sorted as-is 'names' 
 
        Examples 
        -------- 
        &gt;&gt;&gt; self.feature_ahead([&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;]) 
        [&quot;SSE41&quot;] 
        # assume AVX2 and FMA3 implies each other and AVX2 
        # is the highest interest 
        &gt;&gt;&gt; self.feature_ahead([&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;, &quot;AVX2&quot;, &quot;FMA3&quot;]) 
        [&quot;AVX2&quot;] 
        # assume AVX2 and FMA3 don't implies each other 
        &gt;&gt;&gt; self.feature_ahead([&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;, &quot;AVX2&quot;, &quot;FMA3&quot;]) 
        [&quot;AVX2&quot;, &quot;FMA3&quot;] 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s2">and </span><span class="s1">hasattr(names</span><span class="s2">, </span><span class="s3">'__iter__'</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">implies = self.feature_implies(names</span><span class="s2">, </span><span class="s1">keep_origins=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">ahead = [n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names </span><span class="s2">if </span><span class="s1">n </span><span class="s2">not in </span><span class="s1">implies]</span>
        <span class="s2">if </span><span class="s1">len(ahead) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># return the highest interested feature</span>
            <span class="s4"># if all features imply each other</span>
            <span class="s1">ahead = self.feature_sorted(names</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)[:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">ahead</span>

    <span class="s2">def </span><span class="s1">feature_untied(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot; 
        same as 'feature_ahead()' but if both features implied each other 
        and keep the highest interest. 
 
        Parameters 
        ---------- 
        'names': sequence 
            sequence of CPU feature names in uppercase. 
 
        Returns 
        ------- 
        list of CPU features sorted as-is 'names' 
 
        Examples 
        -------- 
        &gt;&gt;&gt; self.feature_untied([&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;]) 
        [&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;] 
        # assume AVX2 and FMA3 implies each other 
        &gt;&gt;&gt; self.feature_untied([&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;, &quot;FMA3&quot;, &quot;AVX2&quot;]) 
        [&quot;SSE2&quot;, &quot;SSE3&quot;, &quot;SSE41&quot;, &quot;AVX2&quot;] 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s2">and </span><span class="s1">hasattr(names</span><span class="s2">, </span><span class="s3">'__iter__'</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">final = []</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">implies = self.feature_implies(n)</span>
            <span class="s1">tied = [</span>
                <span class="s1">nn </span><span class="s2">for </span><span class="s1">nn </span><span class="s2">in </span><span class="s1">final</span>
                <span class="s2">if </span><span class="s1">nn </span><span class="s2">in </span><span class="s1">implies </span><span class="s2">and </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.feature_implies(nn)</span>
            <span class="s1">]</span>
            <span class="s2">if </span><span class="s1">tied:</span>
                <span class="s1">tied = self.feature_sorted(tied + [n])</span>
                <span class="s2">if </span><span class="s1">n </span><span class="s2">not in </span><span class="s1">tied[</span><span class="s5">1</span><span class="s1">:]:</span>
                    <span class="s2">continue</span>
                <span class="s1">final.remove(tied[:</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">final.append(n)</span>
        <span class="s2">return </span><span class="s1">final</span>

    <span class="s2">def </span><span class="s1">feature_get_til(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">keyisfalse):</span>
        <span class="s0">&quot;&quot;&quot; 
        same as `feature_implies_c()` but stop collecting implied 
        features when feature's option that provided through 
        parameter 'keyisfalse' is False, also sorting the returned 
        features. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">til(tnames):</span>
            <span class="s4"># sort from highest to lowest interest then cut if &quot;key&quot; is False</span>
            <span class="s1">tnames = self.feature_implies_c(tnames)</span>
            <span class="s1">tnames = self.feature_sorted(tnames</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">enumerate(tnames):</span>
                <span class="s2">if not </span><span class="s1">self.feature_supported[n].get(keyisfalse</span><span class="s2">, True</span><span class="s1">):</span>
                    <span class="s1">tnames = tnames[:i+</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s2">break</span>
            <span class="s2">return </span><span class="s1">tnames</span>

        <span class="s2">if </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">len(names) &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">names = til(names)</span>
            <span class="s4"># normalize the sort</span>
            <span class="s1">names.reverse()</span>
            <span class="s2">return </span><span class="s1">names</span>

        <span class="s1">names = self.feature_ahead(names)</span>
        <span class="s1">names = {t </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">til(n)}</span>
        <span class="s2">return </span><span class="s1">self.feature_sorted(names)</span>

    <span class="s2">def </span><span class="s1">feature_detect(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of CPU features that required to be detected 
        sorted from the lowest to highest interest. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = self.feature_get_til(names</span><span class="s2">, </span><span class="s3">&quot;implies_detect&quot;</span><span class="s1">)</span>
        <span class="s1">detect = []</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">d = self.feature_supported[n]</span>
            <span class="s1">detect += d.get(</span><span class="s3">&quot;detect&quot;</span><span class="s2">, </span><span class="s1">d.get(</span><span class="s3">&quot;group&quot;</span><span class="s2">, </span><span class="s1">[n]))</span>
        <span class="s2">return </span><span class="s1">detect</span>

    <span class="s1">@_Cache.me</span>
    <span class="s2">def </span><span class="s1">feature_flags(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of CPU features flags sorted from the lowest 
        to highest interest. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = self.feature_sorted(self.feature_implies_c(names))</span>
        <span class="s1">flags = []</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">d = self.feature_supported[n]</span>
            <span class="s1">f = d.get(</span><span class="s3">&quot;flags&quot;</span><span class="s2">, </span><span class="s1">[])</span>
            <span class="s2">if not </span><span class="s1">f </span><span class="s2">or not </span><span class="s1">self.cc_test_flags(f):</span>
                <span class="s2">continue</span>
            <span class="s1">flags += f</span>
        <span class="s2">return </span><span class="s1">self.cc_normalize_flags(flags)</span>

    <span class="s1">@_Cache.me</span>
    <span class="s2">def </span><span class="s1">feature_test(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">force_flags=</span><span class="s2">None, </span><span class="s1">macros=[]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test a certain CPU feature against the compiler through its own 
        check file. 
 
        Parameters 
        ---------- 
        name: str 
            Supported CPU feature name. 
 
        force_flags: list or None, optional 
            If None(default), the returned flags from `feature_flags()` 
            will be used. 
 
        macros : list of tuples, optional 
            A list of C macro definitions. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">force_flags </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">force_flags = self.feature_flags(name)</span>

        <span class="s1">self.dist_log(</span>
            <span class="s3">&quot;testing feature '%s' with flags (%s)&quot; </span><span class="s1">% (</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">.join(force_flags)</span>
        <span class="s1">))</span>
        <span class="s4"># Each CPU feature must have C source code contains at</span>
        <span class="s4"># least one intrinsic or instruction related to this feature.</span>
        <span class="s1">test_path = os.path.join(</span>
            <span class="s1">self.conf_check_path</span><span class="s2">, </span><span class="s3">&quot;cpu_%s.c&quot; </span><span class="s1">% name.lower()</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(test_path):</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;feature test file is not exist&quot;</span><span class="s2">, </span><span class="s1">test_path)</span>

        <span class="s1">test = self.dist_test(</span>
            <span class="s1">test_path</span><span class="s2">, </span><span class="s1">force_flags + self.cc_flags[</span><span class="s3">&quot;werror&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">macros=macros</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">test:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;testing failed&quot;</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">test</span>

    <span class="s1">@_Cache.me</span>
    <span class="s2">def </span><span class="s1">feature_is_supported(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">force_flags=</span><span class="s2">None, </span><span class="s1">macros=[]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if a certain CPU feature is supported by the platform and compiler. 
 
        Parameters 
        ---------- 
        name: str 
            CPU feature name in uppercase. 
 
        force_flags: list or None, optional 
            If None(default), default compiler flags for every CPU feature will 
            be used during test. 
 
        macros : list of tuples, optional 
            A list of C macro definitions. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(name.isupper())</span>
        <span class="s2">assert</span><span class="s1">(force_flags </span><span class="s2">is None or </span><span class="s1">isinstance(force_flags</span><span class="s2">, </span><span class="s1">list))</span>

        <span class="s1">supported = name </span><span class="s2">in </span><span class="s1">self.feature_supported</span>
        <span class="s2">if </span><span class="s1">supported:</span>
            <span class="s2">for </span><span class="s1">impl </span><span class="s2">in </span><span class="s1">self.feature_implies(name):</span>
                <span class="s2">if not </span><span class="s1">self.feature_test(impl</span><span class="s2">, </span><span class="s1">force_flags</span><span class="s2">, </span><span class="s1">macros=macros):</span>
                    <span class="s2">return False</span>
            <span class="s2">if not </span><span class="s1">self.feature_test(name</span><span class="s2">, </span><span class="s1">force_flags</span><span class="s2">, </span><span class="s1">macros=macros):</span>
                <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">supported</span>

    <span class="s1">@_Cache.me</span>
    <span class="s2">def </span><span class="s1">feature_can_autovec(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        check if the feature can be auto-vectorized by the compiler 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(isinstance(name</span><span class="s2">, </span><span class="s1">str))</span>
        <span class="s1">d = self.feature_supported[name]</span>
        <span class="s1">can = d.get(</span><span class="s3">&quot;autovec&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">can </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">valid_flags = [</span>
                <span class="s1">self.cc_test_flags([f]) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">d.get(</span><span class="s3">&quot;flags&quot;</span><span class="s2">, </span><span class="s1">[])</span>
            <span class="s1">]</span>
            <span class="s1">can = valid_flags </span><span class="s2">and </span><span class="s1">any(valid_flags)</span>
        <span class="s2">return </span><span class="s1">can</span>

    <span class="s1">@_Cache.me</span>
    <span class="s2">def </span><span class="s1">feature_extra_checks(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of supported extra checks after testing them against 
        the compiler. 
 
        Parameters 
        ---------- 
        names: str 
            CPU feature name in uppercase. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">str)</span>
        <span class="s1">d = self.feature_supported[name]</span>
        <span class="s1">extra_checks = d.get(</span><span class="s3">&quot;extra_checks&quot;</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">if not </span><span class="s1">extra_checks:</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">self.dist_log(</span><span class="s3">&quot;Testing extra checks for feature '%s'&quot; </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">extra_checks)</span>
        <span class="s1">flags = self.feature_flags(name)</span>
        <span class="s1">available = []</span>
        <span class="s1">not_available = []</span>
        <span class="s2">for </span><span class="s1">chk </span><span class="s2">in </span><span class="s1">extra_checks:</span>
            <span class="s1">test_path = os.path.join(</span>
                <span class="s1">self.conf_check_path</span><span class="s2">, </span><span class="s3">&quot;extra_%s.c&quot; </span><span class="s1">% chk.lower()</span>
            <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">os.path.exists(test_path):</span>
                <span class="s1">self.dist_fatal(</span><span class="s3">&quot;extra check file does not exist&quot;</span><span class="s2">, </span><span class="s1">test_path)</span>

            <span class="s1">is_supported = self.dist_test(test_path</span><span class="s2">, </span><span class="s1">flags + self.cc_flags[</span><span class="s3">&quot;werror&quot;</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">is_supported:</span>
                <span class="s1">available.append(chk)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">not_available.append(chk)</span>

        <span class="s2">if </span><span class="s1">not_available:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;testing failed for checks&quot;</span><span class="s2">, </span><span class="s1">not_available</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">available</span>


    <span class="s2">def </span><span class="s1">feature_c_preprocessor(self</span><span class="s2">, </span><span class="s1">feature_name</span><span class="s2">, </span><span class="s1">tabs=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate C preprocessor definitions and include headers of a CPU feature. 
 
        Parameters 
        ---------- 
        'feature_name': str 
            CPU feature name in uppercase. 
        'tabs': int 
            if &gt; 0, align the generated strings to the right depend on number of tabs. 
 
        Returns 
        ------- 
        str, generated C preprocessor 
 
        Examples 
        -------- 
        &gt;&gt;&gt; self.feature_c_preprocessor(&quot;SSE3&quot;) 
        /** SSE3 **/ 
        #define NPY_HAVE_SSE3 1 
        #include &lt;pmmintrin.h&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">assert</span><span class="s1">(feature_name.isupper())</span>
        <span class="s1">feature = self.feature_supported.get(feature_name)</span>
        <span class="s2">assert</span><span class="s1">(feature </span><span class="s2">is not None</span><span class="s1">)</span>

        <span class="s1">prepr = [</span>
            <span class="s3">&quot;/** %s **/&quot; </span><span class="s1">% feature_name</span><span class="s2">,</span>
            <span class="s3">&quot;#define %sHAVE_%s 1&quot; </span><span class="s1">% (self.conf_c_prefix</span><span class="s2">, </span><span class="s1">feature_name)</span>
        <span class="s1">]</span>
        <span class="s1">prepr += [</span>
            <span class="s3">&quot;#include &lt;%s&gt;&quot; </span><span class="s1">% h </span><span class="s2">for </span><span class="s1">h </span><span class="s2">in </span><span class="s1">feature.get(</span><span class="s3">&quot;headers&quot;</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">]</span>

        <span class="s1">extra_defs = feature.get(</span><span class="s3">&quot;group&quot;</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">extra_defs += self.feature_extra_checks(feature_name)</span>
        <span class="s2">for </span><span class="s1">edef </span><span class="s2">in </span><span class="s1">extra_defs:</span>
            <span class="s4"># Guard extra definitions in case of duplicate with</span>
            <span class="s4"># another feature</span>
            <span class="s1">prepr += [</span>
                <span class="s3">&quot;#ifndef %sHAVE_%s&quot; </span><span class="s1">% (self.conf_c_prefix</span><span class="s2">, </span><span class="s1">edef)</span><span class="s2">,</span>
                <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">#define %sHAVE_%s 1&quot; </span><span class="s1">% (self.conf_c_prefix</span><span class="s2">, </span><span class="s1">edef)</span><span class="s2">,</span>
                <span class="s3">&quot;#endif&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">tabs &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">prepr = [(</span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s1">*tabs) + l </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">prepr]</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(prepr)</span>

<span class="s2">class </span><span class="s1">_Parse:</span>
    <span class="s0">&quot;&quot;&quot;A helper class that parsing main arguments of `CCompilerOpt`, 
    also parsing configuration statements in dispatch-able sources. 
 
    Parameters 
    ---------- 
    cpu_baseline: str or None 
        minimal set of required CPU features or special options. 
 
    cpu_dispatch: str or None 
        dispatched set of additional CPU features or special options. 
 
    Special options can be: 
        - **MIN**: Enables the minimum CPU features that utilized via `_Config.conf_min_features` 
        - **MAX**: Enables all supported CPU features by the Compiler and platform. 
        - **NATIVE**: Enables all CPU features that supported by the current machine. 
        - **NONE**: Enables nothing 
        - **Operand +/-**: remove or add features, useful with options **MAX**, **MIN** and **NATIVE**. 
            NOTE: operand + is only added for nominal reason. 
 
    NOTES: 
        - Case-insensitive among all CPU features and special options. 
        - Comma or space can be used as a separator. 
        - If the CPU feature is not supported by the user platform or compiler, 
          it will be skipped rather than raising a fatal error. 
        - Any specified CPU features to 'cpu_dispatch' will be skipped if its part of CPU baseline features 
        - 'cpu_baseline' force enables implied features. 
 
    Attributes 
    ---------- 
    parse_baseline_names : list 
        Final CPU baseline's feature names(sorted from low to high) 
    parse_baseline_flags : list 
        Compiler flags of baseline features 
    parse_dispatch_names : list 
        Final CPU dispatch-able feature names(sorted from low to high) 
    parse_target_groups : dict 
        Dictionary containing initialized target groups that configured 
        through class attribute `conf_target_groups`. 
 
        The key is represent the group name and value is a tuple 
        contains three items : 
            - bool, True if group has the 'baseline' option. 
            - list, list of CPU features. 
            - list, list of extra compiler flags. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">cpu_baseline</span><span class="s2">, </span><span class="s1">cpu_dispatch):</span>
        <span class="s1">self._parse_policies = dict(</span>
            <span class="s4"># POLICY NAME, (HAVE, NOT HAVE, [DEB])</span>
            <span class="s1">KEEP_BASELINE = (</span>
                <span class="s2">None, </span><span class="s1">self._parse_policy_not_keepbase</span><span class="s2">,</span>
                <span class="s1">[]</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">KEEP_SORT = (</span>
                <span class="s1">self._parse_policy_keepsort</span><span class="s2">,</span>
                <span class="s1">self._parse_policy_not_keepsort</span><span class="s2">,</span>
                <span class="s1">[]</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">MAXOPT = (</span>
                <span class="s1">self._parse_policy_maxopt</span><span class="s2">, None,</span>
                <span class="s1">[]</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">WERROR = (</span>
                <span class="s1">self._parse_policy_werror</span><span class="s2">, None,</span>
                <span class="s1">[]</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">AUTOVEC = (</span>
                <span class="s1">self._parse_policy_autovec</span><span class="s2">, None,</span>
                <span class="s1">[</span><span class="s3">&quot;MAXOPT&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;parse_is_cached&quot;</span><span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s1">self.parse_baseline_names = []</span>
        <span class="s1">self.parse_baseline_flags = []</span>
        <span class="s1">self.parse_dispatch_names = []</span>
        <span class="s1">self.parse_target_groups = {}</span>

        <span class="s2">if </span><span class="s1">self.cc_noopt:</span>
            <span class="s4"># skip parsing baseline and dispatch args and keep parsing target groups</span>
            <span class="s1">cpu_baseline = cpu_dispatch = </span><span class="s2">None</span>

        <span class="s1">self.dist_log(</span><span class="s3">&quot;check requested baseline&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">cpu_baseline </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">cpu_baseline = self._parse_arg_features(</span><span class="s3">&quot;cpu_baseline&quot;</span><span class="s2">, </span><span class="s1">cpu_baseline)</span>
            <span class="s1">baseline_names = self.feature_names(cpu_baseline)</span>
            <span class="s1">self.parse_baseline_flags = self.feature_flags(baseline_names)</span>
            <span class="s1">self.parse_baseline_names = self.feature_sorted(</span>
                <span class="s1">self.feature_implies_c(baseline_names)</span>
            <span class="s1">)</span>

        <span class="s1">self.dist_log(</span><span class="s3">&quot;check requested dispatch-able features&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">cpu_dispatch </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">cpu_dispatch_ = self._parse_arg_features(</span><span class="s3">&quot;cpu_dispatch&quot;</span><span class="s2">, </span><span class="s1">cpu_dispatch)</span>
            <span class="s1">cpu_dispatch = {</span>
                <span class="s1">f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">cpu_dispatch_</span>
                <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self.parse_baseline_names</span>
            <span class="s1">}</span>
            <span class="s1">conflict_baseline = cpu_dispatch_.difference(cpu_dispatch)</span>
            <span class="s1">self.parse_dispatch_names = self.feature_sorted(</span>
                <span class="s1">self.feature_names(cpu_dispatch)</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(conflict_baseline) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.dist_log(</span>
                    <span class="s3">&quot;skip features&quot;</span><span class="s2">, </span><span class="s1">conflict_baseline</span><span class="s2">, </span><span class="s3">&quot;since its part of baseline&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self.dist_log(</span><span class="s3">&quot;initialize targets groups&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">group_name</span><span class="s2">, </span><span class="s1">tokens </span><span class="s2">in </span><span class="s1">self.conf_target_groups.items():</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;parse target group&quot;</span><span class="s2">, </span><span class="s1">group_name)</span>
            <span class="s1">GROUP_NAME = group_name.upper()</span>
            <span class="s2">if not </span><span class="s1">tokens </span><span class="s2">or not </span><span class="s1">tokens.strip():</span>
                <span class="s4"># allow empty groups, useful in case if there's a need</span>
                <span class="s4"># to disable certain group since '_parse_target_tokens()'</span>
                <span class="s4"># requires at least one valid target</span>
                <span class="s1">self.parse_target_groups[GROUP_NAME] = (</span>
                    <span class="s2">False, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>
                <span class="s1">)</span>
                <span class="s2">continue</span>
            <span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">features</span><span class="s2">, </span><span class="s1">extra_flags = \</span>
                <span class="s1">self._parse_target_tokens(tokens)</span>
            <span class="s1">self.parse_target_groups[GROUP_NAME] = (</span>
                <span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">features</span><span class="s2">, </span><span class="s1">extra_flags</span>
            <span class="s1">)</span>

        <span class="s1">self.parse_is_cached = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">parse_targets(self</span><span class="s2">, </span><span class="s1">source):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fetch and parse configuration statements that required for 
        defining the targeted CPU features, statements should be declared 
        in the top of source in between **C** comment and start 
        with a special mark **@targets**. 
 
        Configuration statements are sort of keywords representing 
        CPU features names, group of statements and policies, combined 
        together to determine the required optimization. 
 
        Parameters 
        ---------- 
        source: str 
            the path of **C** source file. 
 
        Returns 
        ------- 
        - bool, True if group has the 'baseline' option 
        - list, list of CPU features 
        - list, list of extra compiler flags 
        &quot;&quot;&quot;</span>
        <span class="s1">self.dist_log(</span><span class="s3">&quot;looking for '@targets' inside -&gt; &quot;</span><span class="s2">, </span><span class="s1">source)</span>
        <span class="s4"># get lines between /*@targets and */</span>
        <span class="s2">with </span><span class="s1">open(source) </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">tokens = </span><span class="s3">&quot;&quot;</span>
            <span class="s1">max_to_reach = </span><span class="s5">1000 </span><span class="s4"># good enough, isn't?</span>
            <span class="s1">start_with = </span><span class="s3">&quot;@targets&quot;</span>
            <span class="s1">start_pos = -</span><span class="s5">1</span>
            <span class="s1">end_with = </span><span class="s3">&quot;*/&quot;</span>
            <span class="s1">end_pos = -</span><span class="s5">1</span>
            <span class="s2">for </span><span class="s1">current_line</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(fd):</span>
                <span class="s2">if </span><span class="s1">current_line == max_to_reach:</span>
                    <span class="s1">self.dist_fatal(</span><span class="s3">&quot;reached the max of lines&quot;</span><span class="s1">)</span>
                    <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">start_pos == -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">start_pos = line.find(start_with)</span>
                    <span class="s2">if </span><span class="s1">start_pos == -</span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s2">continue</span>
                    <span class="s1">start_pos += len(start_with)</span>
                <span class="s1">tokens += line</span>
                <span class="s1">end_pos = line.find(end_with)</span>
                <span class="s2">if </span><span class="s1">end_pos != -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">end_pos += len(tokens) - len(line)</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">start_pos == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;expected to find '%s' within a C comment&quot; </span><span class="s1">% start_with)</span>
        <span class="s2">if </span><span class="s1">end_pos == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;expected to end with '%s'&quot; </span><span class="s1">% end_with)</span>

        <span class="s1">tokens = tokens[start_pos:end_pos]</span>
        <span class="s2">return </span><span class="s1">self._parse_target_tokens(tokens)</span>

    <span class="s1">_parse_regex_arg = re.compile(</span><span class="s3">r'\s|,|([+-])'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">_parse_arg_features(self</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">req_features):</span>
        <span class="s2">if not </span><span class="s1">isinstance(req_features</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;expected a string in '%s'&quot; </span><span class="s1">% arg_name)</span>

        <span class="s1">final_features = set()</span>
        <span class="s4"># space and comma can be used as a separator</span>
        <span class="s1">tokens = list(filter(</span><span class="s2">None, </span><span class="s1">re.split(self._parse_regex_arg</span><span class="s2">, </span><span class="s1">req_features)))</span>
        <span class="s1">append = </span><span class="s2">True </span><span class="s4"># append is the default</span>
        <span class="s2">for </span><span class="s1">tok </span><span class="s2">in </span><span class="s1">tokens:</span>
            <span class="s2">if </span><span class="s1">tok[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s3">&quot;$&quot;</span><span class="s1">):</span>
                <span class="s1">self.dist_fatal(</span>
                    <span class="s1">arg_name</span><span class="s2">, </span><span class="s3">&quot;target groups and policies &quot;</span>
                    <span class="s3">&quot;aren't allowed from arguments, &quot;</span>
                    <span class="s3">&quot;only from dispatch-able sources&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">tok == </span><span class="s3">'+'</span><span class="s1">:</span>
                <span class="s1">append = </span><span class="s2">True</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">tok == </span><span class="s3">'-'</span><span class="s1">:</span>
                <span class="s1">append = </span><span class="s2">False</span>
                <span class="s2">continue</span>

            <span class="s1">TOK = tok.upper() </span><span class="s4"># we use upper-case internally</span>
            <span class="s1">features_to = set()</span>
            <span class="s2">if </span><span class="s1">TOK == </span><span class="s3">&quot;NONE&quot;</span><span class="s1">:</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">TOK == </span><span class="s3">&quot;NATIVE&quot;</span><span class="s1">:</span>
                <span class="s1">native = self.cc_flags[</span><span class="s3">&quot;native&quot;</span><span class="s1">]</span>
                <span class="s2">if not </span><span class="s1">native:</span>
                    <span class="s1">self.dist_fatal(arg_name</span><span class="s2">,</span>
                        <span class="s3">&quot;native option isn't supported by the compiler&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">features_to = self.feature_names(</span>
                    <span class="s1">force_flags=native</span><span class="s2">, </span><span class="s1">macros=[(</span><span class="s3">&quot;DETECT_FEATURES&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">TOK == </span><span class="s3">&quot;MAX&quot;</span><span class="s1">:</span>
                <span class="s1">features_to = self.feature_supported.keys()</span>
            <span class="s2">elif </span><span class="s1">TOK == </span><span class="s3">&quot;MIN&quot;</span><span class="s1">:</span>
                <span class="s1">features_to = self.feature_min</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">TOK </span><span class="s2">in </span><span class="s1">self.feature_supported:</span>
                    <span class="s1">features_to.add(TOK)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">self.feature_is_exist(TOK):</span>
                        <span class="s1">self.dist_fatal(arg_name</span><span class="s2">,</span>
                            <span class="s3">&quot;, '%s' isn't a known feature or option&quot; </span><span class="s1">% tok</span>
                        <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">append:</span>
                <span class="s1">final_features = final_features.union(features_to)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">final_features = final_features.difference(features_to)</span>

            <span class="s1">append = </span><span class="s2">True </span><span class="s4"># back to default</span>

        <span class="s2">return </span><span class="s1">final_features</span>

    <span class="s1">_parse_regex_target = re.compile(</span><span class="s3">r'\s|[*,/]|([()])'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">_parse_target_tokens(self</span><span class="s2">, </span><span class="s1">tokens):</span>
        <span class="s2">assert</span><span class="s1">(isinstance(tokens</span><span class="s2">, </span><span class="s1">str))</span>
        <span class="s1">final_targets = [] </span><span class="s4"># to keep it sorted as specified</span>
        <span class="s1">extra_flags = []</span>
        <span class="s1">has_baseline = </span><span class="s2">False</span>

        <span class="s1">skipped  = set()</span>
        <span class="s1">policies = set()</span>
        <span class="s1">multi_target = </span><span class="s2">None</span>

        <span class="s1">tokens = list(filter(</span><span class="s2">None, </span><span class="s1">re.split(self._parse_regex_target</span><span class="s2">, </span><span class="s1">tokens)))</span>
        <span class="s2">if not </span><span class="s1">tokens:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;expected one token at least&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">tok </span><span class="s2">in </span><span class="s1">tokens:</span>
            <span class="s1">TOK = tok.upper()</span>
            <span class="s1">ch = tok[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">ch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'+'</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">):</span>
                <span class="s1">self.dist_fatal(</span>
                    <span class="s3">&quot;+/- are 'not' allowed from target's groups or @targets, &quot;</span>
                    <span class="s3">&quot;only from cpu_baseline and cpu_dispatch parms&quot;</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">ch == </span><span class="s3">'$'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.dist_fatal(</span>
                        <span class="s3">&quot;policies aren't allowed inside multi-target '()'&quot;</span>
                        <span class="s3">&quot;, only CPU features&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">policies.add(self._parse_token_policy(TOK))</span>
            <span class="s2">elif </span><span class="s1">ch == </span><span class="s3">'#'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.dist_fatal(</span>
                        <span class="s3">&quot;target groups aren't allowed inside multi-target '()'&quot;</span>
                        <span class="s3">&quot;, only CPU features&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags = \</span>
                <span class="s1">self._parse_token_group(TOK</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags)</span>
            <span class="s2">elif </span><span class="s1">ch == </span><span class="s3">'('</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.dist_fatal(</span><span class="s3">&quot;unclosed multi-target, missing ')'&quot;</span><span class="s1">)</span>
                <span class="s1">multi_target = set()</span>
            <span class="s2">elif </span><span class="s1">ch == </span><span class="s3">')'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">self.dist_fatal(</span><span class="s3">&quot;multi-target opener '(' wasn't found&quot;</span><span class="s1">)</span>
                <span class="s1">targets = self._parse_multi_target(multi_target)</span>
                <span class="s2">if </span><span class="s1">targets </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">skipped.add(tuple(multi_target))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">len(targets) == </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">targets = targets[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">targets </span><span class="s2">and </span><span class="s1">targets </span><span class="s2">not in </span><span class="s1">final_targets:</span>
                        <span class="s1">final_targets.append(targets)</span>
                <span class="s1">multi_target = </span><span class="s2">None </span><span class="s4"># back to default</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">TOK == </span><span class="s3">&quot;BASELINE&quot;</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">self.dist_fatal(</span><span class="s3">&quot;baseline isn't allowed inside multi-target '()'&quot;</span><span class="s1">)</span>
                    <span class="s1">has_baseline = </span><span class="s2">True</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">multi_target.add(TOK)</span>
                    <span class="s2">continue</span>

                <span class="s2">if not </span><span class="s1">self.feature_is_exist(TOK):</span>
                    <span class="s1">self.dist_fatal(</span><span class="s3">&quot;invalid target name '%s'&quot; </span><span class="s1">% TOK)</span>

                <span class="s1">is_enabled = (</span>
                    <span class="s1">TOK </span><span class="s2">in </span><span class="s1">self.parse_baseline_names </span><span class="s2">or</span>
                    <span class="s1">TOK </span><span class="s2">in </span><span class="s1">self.parse_dispatch_names</span>
                <span class="s1">)</span>
                <span class="s2">if  </span><span class="s1">is_enabled:</span>
                    <span class="s2">if </span><span class="s1">TOK </span><span class="s2">not in </span><span class="s1">final_targets:</span>
                        <span class="s1">final_targets.append(TOK)</span>
                    <span class="s2">continue</span>

                <span class="s1">skipped.add(TOK)</span>

        <span class="s2">if </span><span class="s1">multi_target </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;unclosed multi-target, missing ')'&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">skipped:</span>
            <span class="s1">self.dist_log(</span>
                <span class="s3">&quot;skip targets&quot;</span><span class="s2">, </span><span class="s1">skipped</span><span class="s2">,</span>
                <span class="s3">&quot;not part of baseline or dispatch-able features&quot;</span>
            <span class="s1">)</span>

        <span class="s1">final_targets = self.feature_untied(final_targets)</span>

        <span class="s4"># add polices dependencies</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">list(policies):</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">deps = self._parse_policies[p]</span>
            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">deps:</span>
                <span class="s2">if </span><span class="s1">d </span><span class="s2">in </span><span class="s1">policies:</span>
                    <span class="s2">continue</span>
                <span class="s1">self.dist_log(</span>
                    <span class="s3">&quot;policy '%s' force enables '%s'&quot; </span><span class="s1">% (</span>
                    <span class="s1">p</span><span class="s2">, </span><span class="s1">d</span>
                <span class="s1">))</span>
                <span class="s1">policies.add(d)</span>

        <span class="s4"># release policies filtrations</span>
        <span class="s2">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">(have</span><span class="s2">, </span><span class="s1">nhave</span><span class="s2">, </span><span class="s1">_) </span><span class="s2">in </span><span class="s1">self._parse_policies.items():</span>
            <span class="s1">func = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">in </span><span class="s1">policies:</span>
                <span class="s1">func = have</span>
                <span class="s1">self.dist_log(</span><span class="s3">&quot;policy '%s' is ON&quot; </span><span class="s1">% p)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">func = nhave</span>
            <span class="s2">if not </span><span class="s1">func:</span>
                <span class="s2">continue</span>
            <span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags = func(</span>
                <span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_token_policy(self</span><span class="s2">, </span><span class="s1">token):</span>
        <span class="s0">&quot;&quot;&quot;validate policy token&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(token) &lt;= </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">token[-</span><span class="s5">1</span><span class="s1">:] == token[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;'$' must stuck in the begin of policy name&quot;</span><span class="s1">)</span>
        <span class="s1">token = token[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">if </span><span class="s1">token </span><span class="s2">not in </span><span class="s1">self._parse_policies:</span>
            <span class="s1">self.dist_fatal(</span>
                <span class="s3">&quot;'%s' is an invalid policy name, available policies are&quot; </span><span class="s1">% token</span><span class="s2">,</span>
                <span class="s1">self._parse_policies.keys()</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">token</span>

    <span class="s2">def </span><span class="s1">_parse_token_group(self</span><span class="s2">, </span><span class="s1">token</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;validate group token&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(token) &lt;= </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">token[-</span><span class="s5">1</span><span class="s1">:] == token[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;'#' must stuck in the begin of group name&quot;</span><span class="s1">)</span>

        <span class="s1">token = token[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">ghas_baseline</span><span class="s2">, </span><span class="s1">gtargets</span><span class="s2">, </span><span class="s1">gextra_flags = self.parse_target_groups.get(</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, None, </span><span class="s1">[])</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">gtargets </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.dist_fatal(</span>
                <span class="s3">&quot;'%s' is an invalid target group name, &quot; </span><span class="s1">% token + \</span>
                <span class="s3">&quot;available target groups are&quot;</span><span class="s2">,</span>
                <span class="s1">self.parse_target_groups.keys()</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ghas_baseline:</span>
            <span class="s1">has_baseline = </span><span class="s2">True</span>
        <span class="s4"># always keep sorting as specified</span>
        <span class="s1">final_targets += [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">gtargets </span><span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">final_targets]</span>
        <span class="s1">extra_flags += [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">gextra_flags </span><span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">extra_flags]</span>
        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_multi_target(self</span><span class="s2">, </span><span class="s1">targets):</span>
        <span class="s0">&quot;&quot;&quot;validate multi targets that defined between parentheses()&quot;&quot;&quot;</span>
        <span class="s4"># remove any implied features and keep the origins</span>
        <span class="s2">if not </span><span class="s1">targets:</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;empty multi-target '()'&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">all([</span>
            <span class="s1">self.feature_is_exist(tar) </span><span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">targets</span>
        <span class="s1">]) :</span>
            <span class="s1">self.dist_fatal(</span><span class="s3">&quot;invalid target name in multi-target&quot;</span><span class="s2">, </span><span class="s1">targets)</span>
        <span class="s2">if not </span><span class="s1">all([</span>
            <span class="s1">(</span>
                <span class="s1">tar </span><span class="s2">in </span><span class="s1">self.parse_baseline_names </span><span class="s2">or</span>
                <span class="s1">tar </span><span class="s2">in </span><span class="s1">self.parse_dispatch_names</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">targets</span>
        <span class="s1">]) :</span>
            <span class="s2">return None</span>
        <span class="s1">targets = self.feature_ahead(targets)</span>
        <span class="s2">if not </span><span class="s1">targets:</span>
            <span class="s2">return None</span>
        <span class="s4"># force sort multi targets, so it can be comparable</span>
        <span class="s1">targets = self.feature_sorted(targets)</span>
        <span class="s1">targets = tuple(targets) </span><span class="s4"># hashable</span>
        <span class="s2">return </span><span class="s1">targets</span>

    <span class="s2">def </span><span class="s1">_parse_policy_not_keepbase(self</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;skip all baseline features&quot;&quot;&quot;</span>
        <span class="s1">skipped = []</span>
        <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">final_targets[:]:</span>
            <span class="s1">is_base = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">isinstance(tar</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">is_base = tar </span><span class="s2">in </span><span class="s1">self.parse_baseline_names</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># multi targets</span>
                <span class="s1">is_base = all([</span>
                    <span class="s1">f </span><span class="s2">in </span><span class="s1">self.parse_baseline_names</span>
                    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">tar</span>
                <span class="s1">])</span>
            <span class="s2">if </span><span class="s1">is_base:</span>
                <span class="s1">skipped.append(tar)</span>
                <span class="s1">final_targets.remove(tar)</span>

        <span class="s2">if </span><span class="s1">skipped:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;skip baseline features&quot;</span><span class="s2">, </span><span class="s1">skipped)</span>

        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_policy_keepsort(self</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;leave a notice that $keep_sort is on&quot;&quot;&quot;</span>
        <span class="s1">self.dist_log(</span>
            <span class="s3">&quot;policy 'keep_sort' is on, dispatch-able targets&quot;</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;are 'not' sorted depend on the highest interest but&quot;</span>
            <span class="s3">&quot;as specified in the dispatch-able source or the extra group&quot;</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_policy_not_keepsort(self</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;sorted depend on the highest interest&quot;&quot;&quot;</span>
        <span class="s1">final_targets = self.feature_sorted(final_targets</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_policy_maxopt(self</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;append the compiler optimization flags&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.cc_has_debug:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;debug mode is detected, policy 'maxopt' is skipped.&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.cc_noopt:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;optimization is disabled, policy 'maxopt' is skipped.&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">flags = self.cc_flags[</span><span class="s3">&quot;opt&quot;</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">flags:</span>
                <span class="s1">self.dist_log(</span>
                    <span class="s3">&quot;current compiler doesn't support optimization flags, &quot;</span>
                    <span class="s3">&quot;policy 'maxopt' is skipped&quot;</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">extra_flags += flags</span>
        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_policy_werror(self</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;force warnings to treated as errors&quot;&quot;&quot;</span>
        <span class="s1">flags = self.cc_flags[</span><span class="s3">&quot;werror&quot;</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">flags:</span>
            <span class="s1">self.dist_log(</span>
                <span class="s3">&quot;current compiler doesn't support werror flags, &quot;</span>
                <span class="s3">&quot;warnings will 'not' treated as errors&quot;</span><span class="s2">, </span><span class="s1">stderr=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;compiler warnings are treated as errors&quot;</span><span class="s1">)</span>
            <span class="s1">extra_flags += flags</span>
        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

    <span class="s2">def </span><span class="s1">_parse_policy_autovec(self</span><span class="s2">, </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags):</span>
        <span class="s0">&quot;&quot;&quot;skip features that has no auto-vectorized support by compiler&quot;&quot;&quot;</span>
        <span class="s1">skipped = []</span>
        <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">final_targets[:]:</span>
            <span class="s2">if </span><span class="s1">isinstance(tar</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">can = self.feature_can_autovec(tar)</span>
            <span class="s2">else</span><span class="s1">: </span><span class="s4"># multiple target</span>
                <span class="s1">can = all([</span>
                    <span class="s1">self.feature_can_autovec(t)</span>
                    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tar</span>
                <span class="s1">])</span>
            <span class="s2">if not </span><span class="s1">can:</span>
                <span class="s1">final_targets.remove(tar)</span>
                <span class="s1">skipped.append(tar)</span>

        <span class="s2">if </span><span class="s1">skipped:</span>
            <span class="s1">self.dist_log(</span><span class="s3">&quot;skip non auto-vectorized features&quot;</span><span class="s2">, </span><span class="s1">skipped)</span>

        <span class="s2">return </span><span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">final_targets</span><span class="s2">, </span><span class="s1">extra_flags</span>

<span class="s2">class </span><span class="s1">CCompilerOpt(_Config</span><span class="s2">, </span><span class="s1">_Distutils</span><span class="s2">, </span><span class="s1">_Cache</span><span class="s2">, </span><span class="s1">_CCompiler</span><span class="s2">, </span><span class="s1">_Feature</span><span class="s2">, </span><span class="s1">_Parse):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper class for `CCompiler` aims to provide extra build options 
    to effectively control of compiler optimizations that are directly 
    related to CPU features. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ccompiler</span><span class="s2">, </span><span class="s1">cpu_baseline=</span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s1">cpu_dispatch=</span><span class="s3">&quot;max&quot;</span><span class="s2">, </span><span class="s1">cache_path=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">_Config.__init__(self)</span>
        <span class="s1">_Distutils.__init__(self</span><span class="s2">, </span><span class="s1">ccompiler)</span>
        <span class="s1">_Cache.__init__(self</span><span class="s2">, </span><span class="s1">cache_path</span><span class="s2">, </span><span class="s1">self.dist_info()</span><span class="s2">, </span><span class="s1">cpu_baseline</span><span class="s2">, </span><span class="s1">cpu_dispatch)</span>
        <span class="s1">_CCompiler.__init__(self)</span>
        <span class="s1">_Feature.__init__(self)</span>
        <span class="s2">if not </span><span class="s1">self.cc_noopt </span><span class="s2">and </span><span class="s1">self.cc_has_native:</span>
            <span class="s1">self.dist_log(</span>
                <span class="s3">&quot;native flag is specified through environment variables. &quot;</span>
                <span class="s3">&quot;force cpu-baseline='native'&quot;</span>
            <span class="s1">)</span>
            <span class="s1">cpu_baseline = </span><span class="s3">&quot;native&quot;</span>
        <span class="s1">_Parse.__init__(self</span><span class="s2">, </span><span class="s1">cpu_baseline</span><span class="s2">, </span><span class="s1">cpu_dispatch)</span>
        <span class="s4"># keep the requested features untouched, need it later for report</span>
        <span class="s4"># and trace purposes</span>
        <span class="s1">self._requested_baseline = cpu_baseline</span>
        <span class="s1">self._requested_dispatch = cpu_dispatch</span>
        <span class="s4"># key is the dispatch-able source and value is a tuple</span>
        <span class="s4"># contains two items (has_baseline[boolean], dispatched-features[list])</span>
        <span class="s1">self.sources_status = getattr(self</span><span class="s2">, </span><span class="s3">&quot;sources_status&quot;</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s4"># every instance should has a separate one</span>
        <span class="s1">self.cache_private.add(</span><span class="s3">&quot;sources_status&quot;</span><span class="s1">)</span>
        <span class="s4"># set it at the end to make sure the cache writing was done after init</span>
        <span class="s4"># this class</span>
        <span class="s1">self.hit_cache = hasattr(self</span><span class="s2">, </span><span class="s3">&quot;hit_cache&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">is_cached(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns True if the class loaded from the cache file 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.cache_infile </span><span class="s2">and </span><span class="s1">self.hit_cache</span>

    <span class="s2">def </span><span class="s1">cpu_baseline_flags(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of final CPU baseline compiler flags 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parse_baseline_flags</span>

    <span class="s2">def </span><span class="s1">cpu_baseline_names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        return a list of final CPU baseline feature names 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parse_baseline_names</span>

    <span class="s2">def </span><span class="s1">cpu_dispatch_names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        return a list of final CPU dispatch feature names 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parse_dispatch_names</span>

    <span class="s2">def </span><span class="s1">try_dispatch(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">src_dir=</span><span class="s2">None, </span><span class="s1">ccompiler=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compile one or more dispatch-able sources and generates object files, 
        also generates abstract C config headers and macros that 
        used later for the final runtime dispatching process. 
 
        The mechanism behind it is to takes each source file that specified 
        in 'sources' and branching it into several files depend on 
        special configuration statements that must be declared in the 
        top of each source which contains targeted CPU features, 
        then it compiles every branched source with the proper compiler flags. 
 
        Parameters 
        ---------- 
        sources : list 
            Must be a list of dispatch-able sources file paths, 
            and configuration statements must be declared inside 
            each file. 
 
        src_dir : str 
            Path of parent directory for the generated headers and wrapped sources. 
            If None(default) the files will generated in-place. 
 
        ccompiler: CCompiler 
            Distutils `CCompiler` instance to be used for compilation. 
            If None (default), the provided instance during the initialization 
            will be used instead. 
 
        **kwargs : any 
            Arguments to pass on to the `CCompiler.compile()` 
 
        Returns 
        ------- 
        list : generated object files 
 
        Raises 
        ------ 
        CompileError 
            Raises by `CCompiler.compile()` on compiling failure. 
        DistutilsError 
            Some errors during checking the sanity of configuration statements. 
 
        See Also 
        -------- 
        parse_targets : 
            Parsing the configuration statements of dispatch-able sources. 
        &quot;&quot;&quot;</span>
        <span class="s1">to_compile = {}</span>
        <span class="s1">baseline_flags = self.cpu_baseline_flags()</span>
        <span class="s1">include_dirs = kwargs.setdefault(</span><span class="s3">&quot;include_dirs&quot;</span><span class="s2">, </span><span class="s1">[])</span>

        <span class="s2">for </span><span class="s1">src </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s1">output_dir = os.path.dirname(src)</span>
            <span class="s2">if </span><span class="s1">src_dir:</span>
                <span class="s2">if not </span><span class="s1">output_dir.startswith(src_dir):</span>
                    <span class="s1">output_dir = os.path.join(src_dir</span><span class="s2">, </span><span class="s1">output_dir)</span>
                <span class="s2">if </span><span class="s1">output_dir </span><span class="s2">not in </span><span class="s1">include_dirs:</span>
                    <span class="s4"># To allow including the generated config header(*.dispatch.h)</span>
                    <span class="s4"># by the dispatch-able sources</span>
                    <span class="s1">include_dirs.append(output_dir)</span>

            <span class="s1">has_baseline</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">extra_flags = self.parse_targets(src)</span>
            <span class="s1">nochange = self._generate_config(output_dir</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">has_baseline)</span>
            <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">targets:</span>
                <span class="s1">tar_src = self._wrap_target(output_dir</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">tar</span><span class="s2">, </span><span class="s1">nochange=nochange)</span>
                <span class="s1">flags = tuple(extra_flags + self.feature_flags(tar))</span>
                <span class="s1">to_compile.setdefault(flags</span><span class="s2">, </span><span class="s1">[]).append(tar_src)</span>

            <span class="s2">if </span><span class="s1">has_baseline:</span>
                <span class="s1">flags = tuple(extra_flags + baseline_flags)</span>
                <span class="s1">to_compile.setdefault(flags</span><span class="s2">, </span><span class="s1">[]).append(src)</span>

            <span class="s1">self.sources_status[src] = (has_baseline</span><span class="s2">, </span><span class="s1">targets)</span>

        <span class="s4"># For these reasons, the sources are compiled in a separate loop:</span>
        <span class="s4"># - Gathering all sources with the same flags to benefit from</span>
        <span class="s4">#   the parallel compiling as much as possible.</span>
        <span class="s4"># - To generate all config headers of the dispatchable sources,</span>
        <span class="s4">#   before the compilation in case if there are dependency relationships</span>
        <span class="s4">#   among them.</span>
        <span class="s1">objects = []</span>
        <span class="s2">for </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">srcs </span><span class="s2">in </span><span class="s1">to_compile.items():</span>
            <span class="s1">objects += self.dist_compile(</span>
                <span class="s1">srcs</span><span class="s2">, </span><span class="s1">list(flags)</span><span class="s2">, </span><span class="s1">ccompiler=ccompiler</span><span class="s2">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">objects</span>

    <span class="s2">def </span><span class="s1">generate_dispatch_header(self</span><span class="s2">, </span><span class="s1">header_path):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate the dispatch header which contains the #definitions and headers 
        for platform-specific instruction-sets for the enabled CPU baseline and 
        dispatch-able features. 
 
        Its highly recommended to take a look at the generated header 
        also the generated source files via `try_dispatch()` 
        in order to get the full picture. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.dist_log(</span><span class="s3">&quot;generate CPU dispatch header: (%s)&quot; </span><span class="s1">% header_path)</span>

        <span class="s1">baseline_names = self.cpu_baseline_names()</span>
        <span class="s1">dispatch_names = self.cpu_dispatch_names()</span>
        <span class="s1">baseline_len = len(baseline_names)</span>
        <span class="s1">dispatch_len = len(dispatch_names)</span>

        <span class="s1">header_dir = os.path.dirname(header_path)</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(header_dir):</span>
            <span class="s1">self.dist_log(</span>
                <span class="s3">f&quot;dispatch header dir </span><span class="s2">{</span><span class="s1">header_dir</span><span class="s2">} </span><span class="s3">does not exist, creating it&quot;</span><span class="s2">,</span>
                <span class="s1">stderr=</span><span class="s2">True</span>
            <span class="s1">)</span>
            <span class="s1">os.makedirs(header_dir)</span>

        <span class="s2">with </span><span class="s1">open(header_path</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">baseline_calls = </span><span class="s3">' </span><span class="s2">\\\n</span><span class="s3">'</span><span class="s1">.join([</span>
                <span class="s1">(</span>
                    <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">%sWITH_CPU_EXPAND_(MACRO_TO_CALL(%s, __VA_ARGS__))&quot;</span>
                <span class="s1">) % (self.conf_c_prefix</span><span class="s2">, </span><span class="s1">f)</span>
                <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">baseline_names</span>
            <span class="s1">])</span>
            <span class="s1">dispatch_calls = </span><span class="s3">' </span><span class="s2">\\\n</span><span class="s3">'</span><span class="s1">.join([</span>
                <span class="s1">(</span>
                    <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">%sWITH_CPU_EXPAND_(MACRO_TO_CALL(%s, __VA_ARGS__))&quot;</span>
                <span class="s1">) % (self.conf_c_prefix</span><span class="s2">, </span><span class="s1">f)</span>
                <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">dispatch_names</span>
            <span class="s1">])</span>
            <span class="s1">f.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
                </span><span class="s3">/* 
                 * AUTOGENERATED DON'T EDIT 
                 * Please make changes to the code generator (distutils/ccompiler_opt.py) 
                */ 
                #define {pfx}WITH_CPU_BASELINE  &quot;{baseline_str}&quot; 
                #define {pfx}WITH_CPU_DISPATCH  &quot;{dispatch_str}&quot; 
                #define {pfx}WITH_CPU_BASELINE_N {baseline_len} 
                #define {pfx}WITH_CPU_DISPATCH_N {dispatch_len} 
                #define {pfx}WITH_CPU_EXPAND_(X) X 
                #define {pfx}WITH_CPU_BASELINE_CALL(MACRO_TO_CALL, ...) </span><span class="s2">\\</span>
                <span class="s3">{baseline_calls} 
                #define {pfx}WITH_CPU_DISPATCH_CALL(MACRO_TO_CALL, ...) </span><span class="s2">\\</span>
                <span class="s3">{dispatch_calls} 
            &quot;&quot;&quot;</span><span class="s1">).format(</span>
                <span class="s1">pfx=self.conf_c_prefix</span><span class="s2">, </span><span class="s1">baseline_str=</span><span class="s3">&quot; &quot;</span><span class="s1">.join(baseline_names)</span><span class="s2">,</span>
                <span class="s1">dispatch_str=</span><span class="s3">&quot; &quot;</span><span class="s1">.join(dispatch_names)</span><span class="s2">, </span><span class="s1">baseline_len=baseline_len</span><span class="s2">,</span>
                <span class="s1">dispatch_len=dispatch_len</span><span class="s2">, </span><span class="s1">baseline_calls=baseline_calls</span><span class="s2">,</span>
                <span class="s1">dispatch_calls=dispatch_calls</span>
            <span class="s1">))</span>
            <span class="s1">baseline_pre = </span><span class="s3">''</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">baseline_names:</span>
                <span class="s1">baseline_pre += self.feature_c_preprocessor(name</span><span class="s2">, </span><span class="s1">tabs=</span><span class="s5">1</span><span class="s1">) + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span>

            <span class="s1">dispatch_pre = </span><span class="s3">''</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">dispatch_names:</span>
                <span class="s1">dispatch_pre += textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
                </span><span class="s3">#ifdef {pfx}CPU_TARGET_{name} 
                {pre} 
                #endif /*{pfx}CPU_TARGET_{name}*/ 
                &quot;&quot;&quot;</span><span class="s1">).format(</span>
                    <span class="s1">pfx=self.conf_c_prefix_</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">pre=self.feature_c_preprocessor(</span>
                    <span class="s1">name</span><span class="s2">, </span><span class="s1">tabs=</span><span class="s5">1</span>
                <span class="s1">))</span>

            <span class="s1">f.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
            </span><span class="s3">/******* baseline features *******/ 
            {baseline_pre} 
            /******* dispatch features *******/ 
            {dispatch_pre} 
            &quot;&quot;&quot;</span><span class="s1">).format(</span>
                <span class="s1">pfx=self.conf_c_prefix_</span><span class="s2">, </span><span class="s1">baseline_pre=baseline_pre</span><span class="s2">,</span>
                <span class="s1">dispatch_pre=dispatch_pre</span>
            <span class="s1">))</span>

    <span class="s2">def </span><span class="s1">report(self</span><span class="s2">, </span><span class="s1">full=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">report = []</span>
        <span class="s1">platform_rows = []</span>
        <span class="s1">baseline_rows = []</span>
        <span class="s1">dispatch_rows = []</span>
        <span class="s1">report.append((</span><span class="s3">&quot;Platform&quot;</span><span class="s2">, </span><span class="s1">platform_rows))</span>
        <span class="s1">report.append((</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">report.append((</span><span class="s3">&quot;CPU baseline&quot;</span><span class="s2">, </span><span class="s1">baseline_rows))</span>
        <span class="s1">report.append((</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">report.append((</span><span class="s3">&quot;CPU dispatch&quot;</span><span class="s2">, </span><span class="s1">dispatch_rows))</span>

        <span class="s4">########## platform ##########</span>
        <span class="s1">platform_rows.append((</span><span class="s3">&quot;Architecture&quot;</span><span class="s2">, </span><span class="s1">(</span>
            <span class="s3">&quot;unsupported&quot; </span><span class="s2">if </span><span class="s1">self.cc_on_noarch </span><span class="s2">else </span><span class="s1">self.cc_march)</span>
        <span class="s1">))</span>
        <span class="s1">platform_rows.append((</span><span class="s3">&quot;Compiler&quot;</span><span class="s2">, </span><span class="s1">(</span>
            <span class="s3">&quot;unix-like&quot;   </span><span class="s2">if </span><span class="s1">self.cc_is_nocc   </span><span class="s2">else </span><span class="s1">self.cc_name)</span>
        <span class="s1">))</span>
        <span class="s4">########## baseline ##########</span>
        <span class="s2">if </span><span class="s1">self.cc_noopt:</span>
            <span class="s1">baseline_rows.append((</span><span class="s3">&quot;Requested&quot;</span><span class="s2">, </span><span class="s3">&quot;optimization disabled&quot;</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">baseline_rows.append((</span><span class="s3">&quot;Requested&quot;</span><span class="s2">, </span><span class="s1">repr(self._requested_baseline)))</span>

        <span class="s1">baseline_names = self.cpu_baseline_names()</span>
        <span class="s1">baseline_rows.append((</span>
            <span class="s3">&quot;Enabled&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">' '</span><span class="s1">.join(baseline_names) </span><span class="s2">if </span><span class="s1">baseline_names </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s1">))</span>
        <span class="s1">baseline_flags = self.cpu_baseline_flags()</span>
        <span class="s1">baseline_rows.append((</span>
            <span class="s3">&quot;Flags&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">' '</span><span class="s1">.join(baseline_flags) </span><span class="s2">if </span><span class="s1">baseline_flags </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s1">))</span>
        <span class="s1">extra_checks = []</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">baseline_names:</span>
            <span class="s1">extra_checks += self.feature_extra_checks(name)</span>
        <span class="s1">baseline_rows.append((</span>
            <span class="s3">&quot;Extra checks&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">' '</span><span class="s1">.join(extra_checks) </span><span class="s2">if </span><span class="s1">extra_checks </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s1">))</span>

        <span class="s4">########## dispatch ##########</span>
        <span class="s2">if </span><span class="s1">self.cc_noopt:</span>
            <span class="s1">baseline_rows.append((</span><span class="s3">&quot;Requested&quot;</span><span class="s2">, </span><span class="s3">&quot;optimization disabled&quot;</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;Requested&quot;</span><span class="s2">, </span><span class="s1">repr(self._requested_dispatch)))</span>

        <span class="s1">dispatch_names = self.cpu_dispatch_names()</span>
        <span class="s1">dispatch_rows.append((</span>
            <span class="s3">&quot;Enabled&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">' '</span><span class="s1">.join(dispatch_names) </span><span class="s2">if </span><span class="s1">dispatch_names </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s1">))</span>
        <span class="s4">########## Generated ##########</span>
        <span class="s4"># TODO:</span>
        <span class="s4"># - collect object names from 'try_dispatch()'</span>
        <span class="s4">#   then get size of each object and printed</span>
        <span class="s4"># - give more details about the features that not</span>
        <span class="s4">#   generated due compiler support</span>
        <span class="s4"># - find a better output's design.</span>
        <span class="s4">#</span>
        <span class="s1">target_sources = {}</span>
        <span class="s2">for </span><span class="s1">source</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">targets) </span><span class="s2">in </span><span class="s1">self.sources_status.items():</span>
            <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">targets:</span>
                <span class="s1">target_sources.setdefault(tar</span><span class="s2">, </span><span class="s1">[]).append(source)</span>

        <span class="s2">if not </span><span class="s1">full </span><span class="s2">or not </span><span class="s1">target_sources:</span>
            <span class="s1">generated = </span><span class="s3">&quot;&quot;</span>
            <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">self.feature_sorted(target_sources):</span>
                <span class="s1">sources = target_sources[tar]</span>
                <span class="s1">name = tar </span><span class="s2">if </span><span class="s1">isinstance(tar</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s3">'(%s)' </span><span class="s1">% </span><span class="s3">' '</span><span class="s1">.join(tar)</span>
                <span class="s1">generated += name + </span><span class="s3">&quot;[%d] &quot; </span><span class="s1">% len(sources)</span>
            <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;Generated&quot;</span><span class="s2">, </span><span class="s1">generated[:-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">generated </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;Generated&quot;</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
            <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">self.feature_sorted(target_sources):</span>
                <span class="s1">sources = target_sources[tar]</span>
                <span class="s1">pretty_name = tar </span><span class="s2">if </span><span class="s1">isinstance(tar</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s3">'(%s)' </span><span class="s1">% </span><span class="s3">' '</span><span class="s1">.join(tar)</span>
                <span class="s1">flags = </span><span class="s3">' '</span><span class="s1">.join(self.feature_flags(tar))</span>
                <span class="s1">implies = </span><span class="s3">' '</span><span class="s1">.join(self.feature_sorted(self.feature_implies(tar)))</span>
                <span class="s1">detect = </span><span class="s3">' '</span><span class="s1">.join(self.feature_detect(tar))</span>
                <span class="s1">extra_checks = []</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">((tar</span><span class="s2">,</span><span class="s1">) </span><span class="s2">if </span><span class="s1">isinstance(tar</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s1">tar):</span>
                    <span class="s1">extra_checks += self.feature_extra_checks(name)</span>
                <span class="s1">extra_checks = (</span><span class="s3">' '</span><span class="s1">.join(extra_checks) </span><span class="s2">if </span><span class="s1">extra_checks </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s1">)</span>

                <span class="s1">dispatch_rows.append((</span><span class="s3">''</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
                <span class="s1">dispatch_rows.append((pretty_name</span><span class="s2">, </span><span class="s1">implies))</span>
                <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;Flags&quot;</span><span class="s2">, </span><span class="s1">flags))</span>
                <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;Extra checks&quot;</span><span class="s2">, </span><span class="s1">extra_checks))</span>
                <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;Detect&quot;</span><span class="s2">, </span><span class="s1">detect))</span>
                <span class="s2">for </span><span class="s1">src </span><span class="s2">in </span><span class="s1">sources:</span>
                    <span class="s1">dispatch_rows.append((</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">src))</span>

        <span class="s4">###############################</span>
        <span class="s4"># TODO: add support for 'markdown' format</span>
        <span class="s1">text = []</span>
        <span class="s1">secs_len = [len(secs) </span><span class="s2">for </span><span class="s1">secs</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">report]</span>
        <span class="s1">cols_len = [len(col) </span><span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">rows </span><span class="s2">in </span><span class="s1">report </span><span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">rows]</span>
        <span class="s1">tab = </span><span class="s3">' ' </span><span class="s1">* </span><span class="s5">2</span>
        <span class="s1">pad =  max(max(secs_len)</span><span class="s2">, </span><span class="s1">max(cols_len))</span>
        <span class="s2">for </span><span class="s1">sec</span><span class="s2">, </span><span class="s1">rows </span><span class="s2">in </span><span class="s1">report:</span>
            <span class="s2">if not </span><span class="s1">sec:</span>
                <span class="s1">text.append(</span><span class="s3">&quot;&quot;</span><span class="s1">) </span><span class="s4"># empty line</span>
                <span class="s2">continue</span>
            <span class="s1">sec += </span><span class="s3">' ' </span><span class="s1">* (pad - len(sec))</span>
            <span class="s1">text.append(sec + tab + </span><span class="s3">': '</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">rows:</span>
                <span class="s1">col += </span><span class="s3">' ' </span><span class="s1">* (pad - len(col))</span>
                <span class="s1">text.append(tab + col + </span><span class="s3">': ' </span><span class="s1">+ val)</span>

        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(text)</span>

    <span class="s2">def </span><span class="s1">_wrap_target(self</span><span class="s2">, </span><span class="s1">output_dir</span><span class="s2">, </span><span class="s1">dispatch_src</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">nochange=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">assert</span><span class="s1">(isinstance(target</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">tuple)))</span>
        <span class="s2">if </span><span class="s1">isinstance(target</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">ext_name = target_name = target</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># multi-target</span>
            <span class="s1">ext_name = </span><span class="s3">'.'</span><span class="s1">.join(target)</span>
            <span class="s1">target_name = </span><span class="s3">'__'</span><span class="s1">.join(target)</span>

        <span class="s1">wrap_path = os.path.join(output_dir</span><span class="s2">, </span><span class="s1">os.path.basename(dispatch_src))</span>
        <span class="s1">wrap_path = </span><span class="s3">&quot;{0}.{2}{1}&quot;</span><span class="s1">.format(*os.path.splitext(wrap_path)</span><span class="s2">, </span><span class="s1">ext_name.lower())</span>
        <span class="s2">if </span><span class="s1">nochange </span><span class="s2">and </span><span class="s1">os.path.exists(wrap_path):</span>
            <span class="s2">return </span><span class="s1">wrap_path</span>

        <span class="s1">self.dist_log(</span><span class="s3">&quot;wrap dispatch-able target -&gt; &quot;</span><span class="s2">, </span><span class="s1">wrap_path)</span>
        <span class="s4"># sorting for readability</span>
        <span class="s1">features = self.feature_sorted(self.feature_implies_c(target))</span>
        <span class="s1">target_join = </span><span class="s3">&quot;#define %sCPU_TARGET_&quot; </span><span class="s1">% self.conf_c_prefix_</span>
        <span class="s1">target_defs = [target_join + f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">features]</span>
        <span class="s1">target_defs = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(target_defs)</span>

        <span class="s2">with </span><span class="s1">open(wrap_path</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
            </span><span class="s3">/** 
             * AUTOGENERATED DON'T EDIT 
             * Please make changes to the code generator </span><span class="s2">\ 
             </span><span class="s3">(distutils/ccompiler_opt.py) 
             */ 
            #define {pfx}CPU_TARGET_MODE 
            #define {pfx}CPU_TARGET_CURRENT {target_name} 
            {target_defs} 
            #include &quot;{path}&quot; 
            &quot;&quot;&quot;</span><span class="s1">).format(</span>
                <span class="s1">pfx=self.conf_c_prefix_</span><span class="s2">, </span><span class="s1">target_name=target_name</span><span class="s2">,</span>
                <span class="s1">path=os.path.abspath(dispatch_src)</span><span class="s2">, </span><span class="s1">target_defs=target_defs</span>
            <span class="s1">))</span>
        <span class="s2">return </span><span class="s1">wrap_path</span>

    <span class="s2">def </span><span class="s1">_generate_config(self</span><span class="s2">, </span><span class="s1">output_dir</span><span class="s2">, </span><span class="s1">dispatch_src</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">has_baseline=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">config_path = os.path.basename(dispatch_src)</span>
        <span class="s1">config_path = os.path.splitext(config_path)[</span><span class="s5">0</span><span class="s1">] + </span><span class="s3">'.h'</span>
        <span class="s1">config_path = os.path.join(output_dir</span><span class="s2">, </span><span class="s1">config_path)</span>
        <span class="s4"># check if targets didn't change to avoid recompiling</span>
        <span class="s1">cache_hash = self.cache_hash(targets</span><span class="s2">, </span><span class="s1">has_baseline)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">open(config_path) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">last_hash = f.readline().split(</span><span class="s3">&quot;cache_hash:&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">len(last_hash) == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">int(last_hash[</span><span class="s5">1</span><span class="s1">]) == cache_hash:</span>
                    <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">OSError:</span>
            <span class="s2">pass</span>

        <span class="s1">self.dist_log(</span><span class="s3">&quot;generate dispatched config -&gt; &quot;</span><span class="s2">, </span><span class="s1">config_path)</span>
        <span class="s1">dispatch_calls = []</span>
        <span class="s2">for </span><span class="s1">tar </span><span class="s2">in </span><span class="s1">targets:</span>
            <span class="s2">if </span><span class="s1">isinstance(tar</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">target_name = tar</span>
            <span class="s2">else</span><span class="s1">: </span><span class="s4"># multi target</span>
                <span class="s1">target_name = </span><span class="s3">'__'</span><span class="s1">.join([t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tar])</span>
            <span class="s1">req_detect = self.feature_detect(tar)</span>
            <span class="s1">req_detect = </span><span class="s3">'&amp;&amp;'</span><span class="s1">.join([</span>
                <span class="s3">&quot;CHK(%s)&quot; </span><span class="s1">% f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">req_detect</span>
            <span class="s1">])</span>
            <span class="s1">dispatch_calls.append(</span>
                <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">%sCPU_DISPATCH_EXPAND_(CB((%s), %s, __VA_ARGS__))&quot; </span><span class="s1">% (</span>
                <span class="s1">self.conf_c_prefix_</span><span class="s2">, </span><span class="s1">req_detect</span><span class="s2">, </span><span class="s1">target_name</span>
            <span class="s1">))</span>
        <span class="s1">dispatch_calls = </span><span class="s3">' </span><span class="s2">\\\n</span><span class="s3">'</span><span class="s1">.join(dispatch_calls)</span>

        <span class="s2">if </span><span class="s1">has_baseline:</span>
            <span class="s1">baseline_calls = (</span>
                <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">%sCPU_DISPATCH_EXPAND_(CB(__VA_ARGS__))&quot;</span>
            <span class="s1">) % self.conf_c_prefix_</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">baseline_calls = </span><span class="s3">''</span>

        <span class="s2">with </span><span class="s1">open(config_path</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
            </span><span class="s3">// cache_hash:{cache_hash} 
            /** 
             * AUTOGENERATED DON'T EDIT 
             * Please make changes to the code generator (distutils/ccompiler_opt.py) 
             */ 
            #ifndef {pfx}CPU_DISPATCH_EXPAND_ 
                #define {pfx}CPU_DISPATCH_EXPAND_(X) X 
            #endif 
            #undef {pfx}CPU_DISPATCH_BASELINE_CALL 
            #undef {pfx}CPU_DISPATCH_CALL 
            #define {pfx}CPU_DISPATCH_BASELINE_CALL(CB, ...) </span><span class="s2">\\</span>
            <span class="s3">{baseline_calls} 
            #define {pfx}CPU_DISPATCH_CALL(CHK, CB, ...) </span><span class="s2">\\</span>
            <span class="s3">{dispatch_calls} 
            &quot;&quot;&quot;</span><span class="s1">).format(</span>
                <span class="s1">pfx=self.conf_c_prefix_</span><span class="s2">, </span><span class="s1">baseline_calls=baseline_calls</span><span class="s2">,</span>
                <span class="s1">dispatch_calls=dispatch_calls</span><span class="s2">, </span><span class="s1">cache_hash=cache_hash</span>
            <span class="s1">))</span>
        <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">new_ccompiler_opt(compiler</span><span class="s2">, </span><span class="s1">dispatch_hpath</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a new instance of 'CCompilerOpt' and generate the dispatch header 
    which contains the #definitions and headers of platform-specific instruction-sets for 
    the enabled CPU baseline and dispatch-able features. 
 
    Parameters 
    ---------- 
    compiler : CCompiler instance 
    dispatch_hpath : str 
        path of the dispatch header 
 
    **kwargs: passed as-is to `CCompilerOpt(...)` 
    Returns 
    ------- 
    new instance of CCompilerOpt 
    &quot;&quot;&quot;</span>
    <span class="s1">opt = CCompilerOpt(compiler</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">if not </span><span class="s1">os.path.exists(dispatch_hpath) </span><span class="s2">or not </span><span class="s1">opt.is_cached():</span>
        <span class="s1">opt.generate_dispatch_header(dispatch_hpath)</span>
    <span class="s2">return </span><span class="s1">opt</span>
</pre>
</body>
</html>