<html>
<head>
<title>sparse_op_helper.pxi.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sparse_op_helper.pxi.in</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Template for each `dtype` helper function for sparse ops</span>

<span class="s0">WARNING: DO NOT edit .pxi FILE directly, .pxi is generated from .pxi.in</span>
<span class="s0">&quot;&quot;&quot;</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Sparse op</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">ctypedef fused sparse_t:</span>
    <span class="s0">float64_t</span>
    <span class="s0">int64_t</span>


<span class="s0">cdef inline float64_t __div__(sparse_t a, sparse_t b):</span>
    <span class="s0">if b == 0:</span>
        <span class="s0">if a &gt; 0:</span>
            <span class="s0">return INF</span>
        <span class="s0">elif a &lt; 0:</span>
            <span class="s0">return -INF</span>
        <span class="s0">else:</span>
            <span class="s0">return NaN</span>
    <span class="s0">else:</span>
        <span class="s0">return float(a) / b</span>


<span class="s0">cdef inline float64_t __truediv__(sparse_t a, sparse_t b):</span>
    <span class="s0">return __div__(a, b)</span>


<span class="s0">cdef inline sparse_t __mod__(sparse_t a, sparse_t b):</span>
    <span class="s0">if b == 0:</span>
        <span class="s0">if sparse_t is float64_t:</span>
            <span class="s0">return NaN</span>
        <span class="s0">else:</span>
            <span class="s0">return 0</span>
    <span class="s0">else:</span>
        <span class="s0">return a % b</span>


<span class="s0">cdef inline sparse_t __floordiv__(sparse_t a, sparse_t b):</span>
    <span class="s0">if b == 0:</span>
        <span class="s0">if sparse_t is float64_t:</span>
            <span class="s0"># Match non-sparse Series behavior implemented in mask_zero_div_zero</span>
            <span class="s0">if a &gt; 0:</span>
                <span class="s0">return INF</span>
            <span class="s0">elif a &lt; 0:</span>
                <span class="s0">return -INF</span>
            <span class="s0">return NaN</span>
        <span class="s0">else:</span>
            <span class="s0">return 0</span>
    <span class="s0">else:</span>
        <span class="s0">return a // b</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># sparse array op</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">{{py:</span>

<span class="s0"># dtype, arith_comp_group, logical_group</span>
<span class="s0">dtypes = [('float64', True, False),</span>
          <span class="s0">('int64', True, True),</span>
          <span class="s0">('uint8', False, True)]</span>
<span class="s0"># do not generate arithmetic / comparison template for uint8,</span>
<span class="s0"># it should be done in fused types</span>

<span class="s0">def get_op(tup):</span>
    <span class="s0">assert isinstance(tup, tuple)</span>
    <span class="s0">assert len(tup) == 4</span>

    <span class="s0">opname, lval, rval, dtype = tup</span>

    <span class="s0">ops_dict = {'add': '{0} + {1}',</span>
                <span class="s0">'sub': '{0} - {1}',</span>
                <span class="s0">'mul': '{0} * {1}',</span>
                <span class="s0">'div': '__div__({0}, {1})',</span>
                <span class="s0">'mod': '__mod__({0}, {1})',</span>
                <span class="s0">'truediv': '__truediv__({0}, {1})',</span>
                <span class="s0">'floordiv': '__floordiv__({0}, {1})',</span>
                <span class="s0">'pow': '{0} ** {1}',</span>
                <span class="s0">'eq': '{0} == {1}',</span>
                <span class="s0">'ne': '{0} != {1}',</span>
                <span class="s0">'lt': '{0} &lt; {1}',</span>
                <span class="s0">'gt': '{0} &gt; {1}',</span>
                <span class="s0">'le': '{0} &lt;= {1}',</span>
                <span class="s0">'ge': '{0} &gt;= {1}',</span>

                <span class="s0">'and': '{0} &amp; {1}',     # logical op</span>
                <span class="s0">'or': '{0} | {1}',</span>
                <span class="s0">'xor': '{0} ^ {1}'}</span>

    <span class="s0">return ops_dict[opname].format(lval, rval)</span>


<span class="s0">def get_dispatch(dtypes):</span>

    <span class="s0">ops_list = ['add', 'sub', 'mul', 'div', 'mod', 'truediv',</span>
                <span class="s0">'floordiv', 'pow',</span>
                <span class="s0">'eq', 'ne', 'lt', 'gt', 'le', 'ge',</span>
                <span class="s0">'and', 'or', 'xor']</span>

    <span class="s0">for opname in ops_list:</span>
        <span class="s0">for dtype, arith_comp_group, logical_group in dtypes:</span>

            <span class="s0">if opname in ('div', 'truediv'):</span>
                <span class="s0">rdtype = 'float64'</span>
            <span class="s0">elif opname in ('eq', 'ne', 'lt', 'gt', 'le', 'ge'):</span>
                <span class="s0"># comparison op</span>
                <span class="s0">rdtype = 'uint8'</span>
            <span class="s0">elif opname in ('and', 'or', 'xor'):</span>
                <span class="s0"># logical op</span>
                <span class="s0">rdtype = 'uint8'</span>
            <span class="s0">else:</span>
                <span class="s0">rdtype = dtype</span>

            <span class="s0">if opname in ('and', 'or', 'xor'):</span>
                <span class="s0">if logical_group:</span>
                    <span class="s0">yield opname, dtype, rdtype</span>
            <span class="s0">else:</span>
                <span class="s0">if arith_comp_group:</span>
                    <span class="s0">yield opname, dtype, rdtype</span>

<span class="s0">}}</span>


<span class="s0">{{for opname, dtype, rdtype in get_dispatch(dtypes)}}</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef inline tuple block_op_{{opname}}_{{dtype}}({{dtype}}_t[:] x_,</span>
                                                <span class="s0">BlockIndex xindex,</span>
                                                <span class="s0">{{dtype}}_t xfill,</span>
                                                <span class="s0">{{dtype}}_t[:] y_,</span>
                                                <span class="s0">BlockIndex yindex,</span>
                                                <span class="s0">{{dtype}}_t yfill):</span>
    <span class="s0">'''</span>
    <span class="s0">Binary operator on BlockIndex objects with fill values</span>
    <span class="s0">'''</span>

    <span class="s0">cdef:</span>
        <span class="s0">BlockIndex out_index</span>
        <span class="s0">Py_ssize_t xi = 0, yi = 0, out_i = 0 # fp buf indices</span>
        <span class="s0">int32_t xbp = 0, ybp = 0 # block positions</span>
        <span class="s0">int32_t xloc, yloc</span>
        <span class="s0">Py_ssize_t xblock = 0, yblock = 0 # block numbers</span>

        <span class="s0">{{dtype}}_t[:] x, y</span>
        <span class="s0">ndarray[{{rdtype}}_t, ndim=1] out</span>

    <span class="s0"># to suppress Cython warning</span>
    <span class="s0">x = x_</span>
    <span class="s0">y = y_</span>

    <span class="s0">out_index = xindex.make_union(yindex)</span>
    <span class="s0">out = np.empty(out_index.npoints, dtype=np.{{rdtype}})</span>

    <span class="s0"># Wow, what a hack job. Need to do something about this</span>

    <span class="s0"># walk the two SparseVectors, adding matched locations...</span>
    <span class="s0">for out_i in range(out_index.npoints):</span>
        <span class="s0">if yblock == yindex.nblocks:</span>
            <span class="s0"># use y fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'x[xi]', 'yfill', dtype) | get_op}}</span>
            <span class="s0">xi += 1</span>

            <span class="s0"># advance x location</span>
            <span class="s0">xbp += 1</span>
            <span class="s0">if xbp == xindex.lenbuf[xblock]:</span>
                <span class="s0">xblock += 1</span>
                <span class="s0">xbp = 0</span>
            <span class="s0">continue</span>

        <span class="s0">if xblock == xindex.nblocks:</span>
            <span class="s0"># use x fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'xfill', 'y[yi]', dtype) | get_op}}</span>
            <span class="s0">yi += 1</span>

            <span class="s0"># advance y location</span>
            <span class="s0">ybp += 1</span>
            <span class="s0">if ybp == yindex.lenbuf[yblock]:</span>
                <span class="s0">yblock += 1</span>
                <span class="s0">ybp = 0</span>
            <span class="s0">continue</span>

        <span class="s0">yloc = yindex.locbuf[yblock] + ybp</span>
        <span class="s0">xloc = xindex.locbuf[xblock] + xbp</span>

        <span class="s0"># each index in the out_index had to come from either x, y, or both</span>
        <span class="s0">if xloc == yloc:</span>
            <span class="s0">out[out_i] = {{(opname, 'x[xi]', 'y[yi]', dtype) | get_op}}</span>
            <span class="s0">xi += 1</span>
            <span class="s0">yi += 1</span>

            <span class="s0"># advance both locations</span>
            <span class="s0">xbp += 1</span>
            <span class="s0">if xbp == xindex.lenbuf[xblock]:</span>
                <span class="s0">xblock += 1</span>
                <span class="s0">xbp = 0</span>

            <span class="s0">ybp += 1</span>
            <span class="s0">if ybp == yindex.lenbuf[yblock]:</span>
                <span class="s0">yblock += 1</span>
                <span class="s0">ybp = 0</span>

        <span class="s0">elif xloc &lt; yloc:</span>
            <span class="s0"># use y fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'x[xi]', 'yfill', dtype) | get_op}}</span>
            <span class="s0">xi += 1</span>

            <span class="s0"># advance x location</span>
            <span class="s0">xbp += 1</span>
            <span class="s0">if xbp == xindex.lenbuf[xblock]:</span>
                <span class="s0">xblock += 1</span>
                <span class="s0">xbp = 0</span>
        <span class="s0">else:</span>
            <span class="s0"># use x fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'xfill', 'y[yi]', dtype) | get_op}}</span>
            <span class="s0">yi += 1</span>

            <span class="s0"># advance y location</span>
            <span class="s0">ybp += 1</span>
            <span class="s0">if ybp == yindex.lenbuf[yblock]:</span>
                <span class="s0">yblock += 1</span>
                <span class="s0">ybp = 0</span>

    <span class="s0">return out, out_index, {{(opname, 'xfill', 'yfill', dtype) | get_op}}</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef inline tuple int_op_{{opname}}_{{dtype}}({{dtype}}_t[:] x_,</span>
                                              <span class="s0">IntIndex xindex,</span>
                                              <span class="s0">{{dtype}}_t xfill,</span>
                                              <span class="s0">{{dtype}}_t[:] y_,</span>
                                              <span class="s0">IntIndex yindex,</span>
                                              <span class="s0">{{dtype}}_t yfill):</span>
    <span class="s0">cdef:</span>
        <span class="s0">IntIndex out_index</span>
        <span class="s0">Py_ssize_t xi = 0, yi = 0, out_i = 0  # fp buf indices</span>
        <span class="s0">int32_t xloc, yloc</span>
        <span class="s0">int32_t[:] xindices, yindices, out_indices</span>
        <span class="s0">{{dtype}}_t[:] x, y</span>
        <span class="s0">ndarray[{{rdtype}}_t, ndim=1] out</span>

    <span class="s0"># suppress Cython compiler warnings due to inlining</span>
    <span class="s0">x = x_</span>
    <span class="s0">y = y_</span>

    <span class="s0"># need to do this first to know size of result array</span>
    <span class="s0">out_index = xindex.make_union(yindex)</span>
    <span class="s0">out = np.empty(out_index.npoints, dtype=np.{{rdtype}})</span>

    <span class="s0">xindices = xindex.indices</span>
    <span class="s0">yindices = yindex.indices</span>
    <span class="s0">out_indices = out_index.indices</span>

    <span class="s0"># walk the two SparseVectors, adding matched locations...</span>
    <span class="s0">for out_i in range(out_index.npoints):</span>
        <span class="s0">if xi == xindex.npoints:</span>
            <span class="s0"># use x fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'xfill', 'y[yi]', dtype) | get_op}}</span>
            <span class="s0">yi += 1</span>
            <span class="s0">continue</span>

        <span class="s0">if yi == yindex.npoints:</span>
            <span class="s0"># use y fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'x[xi]', 'yfill', dtype) | get_op}}</span>
            <span class="s0">xi += 1</span>
            <span class="s0">continue</span>

        <span class="s0">xloc = xindices[xi]</span>
        <span class="s0">yloc = yindices[yi]</span>

        <span class="s0"># each index in the out_index had to come from either x, y, or both</span>
        <span class="s0">if xloc == yloc:</span>
            <span class="s0">out[out_i] = {{(opname, 'x[xi]', 'y[yi]', dtype) | get_op}}</span>
            <span class="s0">xi += 1</span>
            <span class="s0">yi += 1</span>
        <span class="s0">elif xloc &lt; yloc:</span>
            <span class="s0"># use y fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'x[xi]', 'yfill', dtype) | get_op}}</span>
            <span class="s0">xi += 1</span>
        <span class="s0">else:</span>
            <span class="s0"># use x fill value</span>
            <span class="s0">out[out_i] = {{(opname, 'xfill', 'y[yi]', dtype) | get_op}}</span>
            <span class="s0">yi += 1</span>

    <span class="s0">return out, out_index, {{(opname, 'xfill', 'yfill', dtype) | get_op}}</span>


<span class="s0">cpdef sparse_{{opname}}_{{dtype}}({{dtype}}_t[:] x,</span>
                                  <span class="s0">SparseIndex xindex, {{dtype}}_t xfill,</span>
                                  <span class="s0">{{dtype}}_t[:] y,</span>
                                  <span class="s0">SparseIndex yindex, {{dtype}}_t yfill):</span>

    <span class="s0">if isinstance(xindex, BlockIndex):</span>
        <span class="s0">return block_op_{{opname}}_{{dtype}}(x, xindex.to_block_index(), xfill,</span>
                                             <span class="s0">y, yindex.to_block_index(), yfill)</span>
    <span class="s0">elif isinstance(xindex, IntIndex):</span>
        <span class="s0">return int_op_{{opname}}_{{dtype}}(x, xindex.to_int_index(), xfill,</span>
                                           <span class="s0">y, yindex.to_int_index(), yfill)</span>
    <span class="s0">else:</span>
        <span class="s0">raise NotImplementedError</span>

<span class="s0">{{endfor}}</span>
</pre>
</body>
</html>