<html>
<head>
<title>basevalidators.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
basevalidators.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">numbers</span>
<span class="s0">import </span><span class="s1">textwrap</span>
<span class="s0">import </span><span class="s1">uuid</span>
<span class="s0">from </span><span class="s1">importlib </span><span class="s0">import </span><span class="s1">import_module</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">from </span><span class="s1">six </span><span class="s0">import </span><span class="s1">string_types</span>

<span class="s0">from </span><span class="s1">_plotly_utils.optional_imports </span><span class="s0">import </span><span class="s1">get_module</span>


<span class="s2"># back-port of fullmatch from Py3.4+</span>
<span class="s0">def </span><span class="s1">fullmatch(regex</span><span class="s0">, </span><span class="s1">string</span><span class="s0">, </span><span class="s1">flags=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Emulate python-3.4 re.fullmatch().&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s5">&quot;pattern&quot; </span><span class="s0">in </span><span class="s1">dir(regex):</span>
        <span class="s1">regex_string = regex.pattern</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">regex_string = regex</span>
    <span class="s0">return </span><span class="s1">re.match(</span><span class="s5">&quot;(?:&quot; </span><span class="s1">+ regex_string + </span><span class="s5">r&quot;)\Z&quot;</span><span class="s0">, </span><span class="s1">string</span><span class="s0">, </span><span class="s1">flags=flags)</span>


<span class="s2"># Utility functions</span>
<span class="s2"># -----------------</span>
<span class="s0">def </span><span class="s1">to_scalar_or_list(v):</span>
    <span class="s2"># Handle the case where 'v' is a non-native scalar-like type,</span>
    <span class="s2"># such as numpy.float32. Without this case, the object might be</span>
    <span class="s2"># considered numpy-convertable and therefore promoted to a</span>
    <span class="s2"># 0-dimensional array, but we instead want it converted to a</span>
    <span class="s2"># Python native scalar type ('float' in the example above).</span>
    <span class="s2"># We explicitly check if is has the 'item' method, which conventionally</span>
    <span class="s2"># converts these types to native scalars.</span>
    <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">pd = get_module(</span><span class="s5">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">np </span><span class="s0">and </span><span class="s1">np.isscalar(v) </span><span class="s0">and </span><span class="s1">hasattr(v</span><span class="s0">, </span><span class="s5">&quot;item&quot;</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">v.item()</span>
    <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
        <span class="s0">return </span><span class="s1">[to_scalar_or_list(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>
    <span class="s0">elif </span><span class="s1">np </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s0">if </span><span class="s1">v.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">v.item()</span>
        <span class="s0">return </span><span class="s1">[to_scalar_or_list(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>
    <span class="s0">elif </span><span class="s1">pd </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(pd.Series</span><span class="s0">, </span><span class="s1">pd.Index)):</span>
        <span class="s0">return </span><span class="s1">[to_scalar_or_list(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>
    <span class="s0">elif </span><span class="s1">is_numpy_convertable(v):</span>
        <span class="s0">return </span><span class="s1">to_scalar_or_list(np.array(v))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">def </span><span class="s1">copy_to_readonly_numpy_array(v</span><span class="s0">, </span><span class="s1">kind=</span><span class="s0">None, </span><span class="s1">force_numeric=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Convert an array-like value into a read-only numpy array 
 
    Parameters 
    ---------- 
    v : array like 
        Array like value (list, tuple, numpy array, pandas series, etc.) 
    kind : str or tuple of str 
        If specified, the numpy dtype kind (or kinds) that the array should 
        have, or be converted to if possible. 
        If not specified then let numpy infer the datatype 
    force_numeric : bool 
        If true, raise an exception if the resulting numpy array does not 
        have a numeric dtype (i.e. dtype.kind not in ['u', 'i', 'f']) 
    Returns 
    ------- 
    np.ndarray 
        Numpy array with the 'WRITEABLE' flag set to False 
    &quot;&quot;&quot;</span>
    <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s1">)</span>

    <span class="s2"># Don't force pandas to be loaded, we only want to know if it's already loaded</span>
    <span class="s1">pd = get_module(</span><span class="s5">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np </span><span class="s0">is not None</span>

    <span class="s2"># ### Process kind ###</span>
    <span class="s0">if not </span><span class="s1">kind:</span>
        <span class="s1">kind = ()</span>
    <span class="s0">elif </span><span class="s1">isinstance(kind</span><span class="s0">, </span><span class="s1">string_types):</span>
        <span class="s1">kind = (kind</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">first_kind = kind[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">kind </span><span class="s0">else None</span>

    <span class="s2"># u: unsigned int, i: signed int, f: float</span>
    <span class="s1">numeric_kinds = {</span><span class="s5">&quot;u&quot;</span><span class="s0">, </span><span class="s5">&quot;i&quot;</span><span class="s0">, </span><span class="s5">&quot;f&quot;</span><span class="s1">}</span>
    <span class="s1">kind_default_dtypes = {</span>
        <span class="s5">&quot;u&quot;</span><span class="s1">: </span><span class="s5">&quot;uint32&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;i&quot;</span><span class="s1">: </span><span class="s5">&quot;int32&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;f&quot;</span><span class="s1">: </span><span class="s5">&quot;float64&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;O&quot;</span><span class="s1">: </span><span class="s5">&quot;object&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s2"># Handle pandas Series and Index objects</span>
    <span class="s0">if </span><span class="s1">pd </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(pd.Series</span><span class="s0">, </span><span class="s1">pd.Index)):</span>
        <span class="s0">if </span><span class="s1">v.dtype.kind </span><span class="s0">in </span><span class="s1">numeric_kinds:</span>
            <span class="s2"># Get the numeric numpy array so we use fast path below</span>
            <span class="s1">v = v.values</span>
        <span class="s0">elif </span><span class="s1">v.dtype.kind == </span><span class="s5">&quot;M&quot;</span><span class="s1">:</span>
            <span class="s2"># Convert datetime Series/Index to numpy array of datetimes</span>
            <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">pd.Series):</span>
                <span class="s1">v = v.dt.to_pydatetime()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># DatetimeIndex</span>
                <span class="s1">v = v.to_pydatetime()</span>
    <span class="s0">elif </span><span class="s1">pd </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">pd.DataFrame) </span><span class="s0">and </span><span class="s1">len(set(v.dtypes)) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">dtype = v.dtypes.tolist()[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">dtype.kind </span><span class="s0">in </span><span class="s1">numeric_kinds:</span>
            <span class="s1">v = v.values</span>
        <span class="s0">elif </span><span class="s1">dtype.kind == </span><span class="s5">&quot;M&quot;</span><span class="s1">:</span>
            <span class="s1">v = [row.dt.to_pydatetime().tolist() </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row </span><span class="s0">in </span><span class="s1">v.iterrows()]</span>

    <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s2"># v has its own logic on how to convert itself into a numpy array</span>
        <span class="s0">if </span><span class="s1">is_numpy_convertable(v):</span>
            <span class="s0">return </span><span class="s1">copy_to_readonly_numpy_array(</span>
                <span class="s1">np.array(v)</span><span class="s0">, </span><span class="s1">kind=kind</span><span class="s0">, </span><span class="s1">force_numeric=force_numeric</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># v is not homogenous array</span>
            <span class="s1">v_list = [to_scalar_or_list(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>

            <span class="s2"># Lookup dtype for requested kind, if any</span>
            <span class="s1">dtype = kind_default_dtypes.get(first_kind</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s2"># construct new array from list</span>
            <span class="s1">new_v = np.array(v_list</span><span class="s0">, </span><span class="s1">order=</span><span class="s5">&quot;C&quot;</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">elif </span><span class="s1">v.dtype.kind </span><span class="s0">in </span><span class="s1">numeric_kinds:</span>
        <span class="s2"># v is a homogenous numeric array</span>
        <span class="s0">if </span><span class="s1">kind </span><span class="s0">and </span><span class="s1">v.dtype.kind </span><span class="s0">not in </span><span class="s1">kind:</span>
            <span class="s2"># Kind(s) were specified and this array doesn't match</span>
            <span class="s2"># Convert to the default dtype for the first kind</span>
            <span class="s1">dtype = kind_default_dtypes.get(first_kind</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">new_v = np.ascontiguousarray(v.astype(dtype))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Either no kind was requested or requested kind is satisfied</span>
            <span class="s1">new_v = np.ascontiguousarray(v.copy())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># v is a non-numeric homogenous array</span>
        <span class="s1">new_v = v.copy()</span>

    <span class="s2"># Handle force numeric param</span>
    <span class="s2"># --------------------------</span>
    <span class="s0">if </span><span class="s1">force_numeric </span><span class="s0">and </span><span class="s1">new_v.dtype.kind </span><span class="s0">not in </span><span class="s1">numeric_kinds:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s5">&quot;Input value is not numeric and&quot; &quot;force_numeric parameter set to True&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s5">&quot;U&quot; </span><span class="s0">not in </span><span class="s1">kind:</span>
        <span class="s2"># Force non-numeric arrays to have object type</span>
        <span class="s2"># --------------------------------------------</span>
        <span class="s2"># Here we make sure that non-numeric arrays have the object</span>
        <span class="s2"># datatype. This works around cases like np.array([1, 2, '3']) where</span>
        <span class="s2"># numpy converts the integers to strings and returns array of dtype</span>
        <span class="s2"># '&lt;U21'</span>
        <span class="s0">if </span><span class="s1">new_v.dtype.kind </span><span class="s0">not in </span><span class="s1">[</span><span class="s5">&quot;u&quot;</span><span class="s0">, </span><span class="s5">&quot;i&quot;</span><span class="s0">, </span><span class="s5">&quot;f&quot;</span><span class="s0">, </span><span class="s5">&quot;O&quot;</span><span class="s0">, </span><span class="s5">&quot;M&quot;</span><span class="s1">]:</span>
            <span class="s1">new_v = np.array(v</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s5">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s2"># Set new array to be read-only</span>
    <span class="s2"># -----------------------------</span>
    <span class="s1">new_v.flags[</span><span class="s5">&quot;WRITEABLE&quot;</span><span class="s1">] = </span><span class="s0">False</span>

    <span class="s0">return </span><span class="s1">new_v</span>


<span class="s0">def </span><span class="s1">is_numpy_convertable(v):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return whether a value is meaningfully convertable to a numpy array 
    via 'numpy.array' 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">hasattr(v</span><span class="s0">, </span><span class="s5">&quot;__array__&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">hasattr(v</span><span class="s0">, </span><span class="s5">&quot;__array_interface__&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">is_homogeneous_array(v):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return whether a value is considered to be a homogeneous array 
    &quot;&quot;&quot;</span>
    <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">pd = get_module(</span><span class="s5">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">np</span>
        <span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s0">or </span><span class="s1">(pd </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(pd.Series</span><span class="s0">, </span><span class="s1">pd.Index)))</span>
    <span class="s1">):</span>
        <span class="s0">return True</span>
    <span class="s0">if </span><span class="s1">is_numpy_convertable(v):</span>
        <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">np:</span>
            <span class="s1">v_numpy = np.array(v)</span>
            <span class="s2"># v is essentially a scalar and so shouldn't count as an array</span>
            <span class="s0">if </span><span class="s1">v_numpy.shape == ():</span>
                <span class="s0">return False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return True  </span><span class="s2"># v_numpy.dtype.kind in [&quot;u&quot;, &quot;i&quot;, &quot;f&quot;, &quot;M&quot;, &quot;U&quot;]</span>
    <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">is_simple_array(v):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return whether a value is considered to be an simple array 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple))</span>


<span class="s0">def </span><span class="s1">is_array(v):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return whether a value is considered to be an array 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">is_simple_array(v) </span><span class="s0">or </span><span class="s1">is_homogeneous_array(v)</span>


<span class="s0">def </span><span class="s1">type_str(v):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return a type string of the form module.name for the input value v 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">type):</span>
        <span class="s1">v = type(v)</span>

    <span class="s0">return </span><span class="s5">&quot;'{module}.{name}'&quot;</span><span class="s1">.format(module=v.__module__</span><span class="s0">, </span><span class="s1">name=v.__name__)</span>


<span class="s2"># Validators</span>
<span class="s2"># ----------</span>
<span class="s0">class </span><span class="s1">BaseValidator(object):</span>
    <span class="s4">&quot;&quot;&quot; 
    Base class for all validator classes 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">role=</span><span class="s0">None, </span><span class="s1">**_):</span>
        <span class="s4">&quot;&quot;&quot; 
        Construct a validator instance 
 
        Parameters 
        ---------- 
        plotly_name : str 
            Name of the property being validated 
        parent_name : str 
            Names of all of the ancestors of this property joined on '.' 
            characters. e.g. 
            plotly_name == 'range' and parent_name == 'layout.xaxis' 
        role : str 
            The role string for the property as specified in 
            plot-schema.json 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parent_name = parent_name</span>
        <span class="s1">self.plotly_name = plotly_name</span>
        <span class="s1">self.role = role</span>
        <span class="s1">self.array_ok = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns a string that describes the values that are acceptable 
        to the validator 
 
        Should start with: 
            The '{plotly_name}' property is a... 
 
        For consistancy, string should have leading 4-space indent 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">raise_invalid_val(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">inds=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Helper method to raise an informative exception when an invalid 
        value is passed to the validate_coerce method. 
 
        Parameters 
        ---------- 
        v : 
            Value that was input to validate_coerce and could not be coerced 
        inds: list of int or None (default) 
            Indexes to display after property name. e.g. if self.plotly_name 
            is 'prop' and inds=[2, 1] then the name in the validation error 
            message will be 'prop[2][1]` 
        Raises 
        ------- 
        ValueError 
        &quot;&quot;&quot;</span>
        <span class="s1">name = self.plotly_name</span>
        <span class="s0">if </span><span class="s1">inds:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">inds:</span>
                <span class="s1">name += </span><span class="s5">&quot;[&quot; </span><span class="s1">+ str(i) + </span><span class="s5">&quot;]&quot;</span>

        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s5">&quot;&quot;&quot; 
    Invalid value of type {typ} received for the '{name}' property of {pname} 
        Received value: {v} 
 
{valid_clr_desc}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">name=name</span><span class="s0">,</span>
                <span class="s1">pname=self.parent_name</span><span class="s0">,</span>
                <span class="s1">typ=type_str(v)</span><span class="s0">,</span>
                <span class="s1">v=repr(v)</span><span class="s0">,</span>
                <span class="s1">valid_clr_desc=self.description()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">raise_invalid_elements(self</span><span class="s0">, </span><span class="s1">invalid_els):</span>
        <span class="s0">if </span><span class="s1">invalid_els:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;&quot;&quot; 
    Invalid element(s) received for the '{name}' property of {pname} 
        Invalid elements include: {invalid} 
 
{valid_clr_desc}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">name=self.plotly_name</span><span class="s0">,</span>
                    <span class="s1">pname=self.parent_name</span><span class="s0">,</span>
                    <span class="s1">invalid=invalid_els[:</span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">valid_clr_desc=self.description()</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate whether an input value is compatible with this property, 
        and coerce the value to be compatible of possible. 
 
        Parameters 
        ---------- 
        v 
            The input value to be validated 
 
        Raises 
        ------ 
        ValueError 
            if `v` cannot be coerced into a compatible form 
 
        Returns 
        ------- 
        The input `v` in a form that's compatible with this property 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">present(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert output value of a previous call to `validate_coerce` into a 
        form suitable to be returned to the user on upon property 
        access. 
 
        Note: The value returned by present must be either immutable or an 
        instance of BasePlotlyType, otherwise the value could be mutated by 
        the user and we wouldn't get notified about the change. 
 
        Parameters 
        ---------- 
        v 
            A value that was the ouput of a previous call the 
            `validate_coerce` method on the same object 
 
        Returns 
        ------- 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">is_homogeneous_array(v):</span>
            <span class="s2"># Note: numpy array was already coerced into read-only form so</span>
            <span class="s2"># we don't need to copy it here.</span>
            <span class="s0">return </span><span class="s1">v</span>
        <span class="s0">elif </span><span class="s1">is_simple_array(v):</span>
            <span class="s0">return </span><span class="s1">tuple(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">DataArrayValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;data_array&quot;: { 
        &quot;description&quot;: &quot;An {array} of data. The value MUST be an 
                        {array}, or we ignore it.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(DataArrayValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">self.array_ok = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s0">return </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is an array that may be specified as a tuple, 
    list, numpy array, or pandas Series&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>

        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">is_homogeneous_array(v):</span>
            <span class="s1">v = copy_to_readonly_numpy_array(v)</span>
        <span class="s0">elif </span><span class="s1">is_simple_array(v):</span>
            <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">EnumeratedValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;enumerated&quot;: { 
        &quot;description&quot;: &quot;Enumerated value type. The available values are 
                        listed in `values`.&quot;, 
        &quot;requiredOpts&quot;: [ 
            &quot;values&quot; 
        ], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;coerceNumber&quot;, 
            &quot;arrayOk&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">plotly_name</span><span class="s0">,</span>
        <span class="s1">parent_name</span><span class="s0">,</span>
        <span class="s1">values</span><span class="s0">,</span>
        <span class="s1">array_ok=</span><span class="s0">False,</span>
        <span class="s1">coerce_number=</span><span class="s0">False,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(EnumeratedValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2"># Save params</span>
        <span class="s2"># -----------</span>
        <span class="s1">self.values = values</span>
        <span class="s1">self.array_ok = array_ok</span>
        <span class="s2"># coerce_number is rarely used and not implemented</span>
        <span class="s1">self.coerce_number = coerce_number</span>
        <span class="s1">self.kwargs = kwargs</span>

        <span class="s2"># Handle regular expressions</span>
        <span class="s2"># --------------------------</span>
        <span class="s2"># Compiled regexs</span>
        <span class="s1">self.val_regexs = []</span>

        <span class="s2"># regex replacements that run before the matching regex</span>
        <span class="s2"># So far, this is only used to cast 'x1' -&gt; 'x' for anchor-style</span>
        <span class="s2"># enumeration properties</span>
        <span class="s1">self.regex_replacements = []</span>

        <span class="s2"># Loop over enumeration values</span>
        <span class="s2"># ----------------------------</span>
        <span class="s2"># Look for regular expressions</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self.values:</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">v</span>
                <span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types)</span>
                <span class="s0">and </span><span class="s1">v[</span><span class="s3">0</span><span class="s1">] == </span><span class="s5">&quot;/&quot;</span>
                <span class="s0">and </span><span class="s1">v[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s5">&quot;/&quot;</span>
                <span class="s0">and </span><span class="s1">len(v) &gt; </span><span class="s3">1</span>
            <span class="s1">):</span>
                <span class="s2"># String is a regex with leading and trailing '/' character</span>
                <span class="s1">regex_str = v[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">self.val_regexs.append(re.compile(regex_str))</span>
                <span class="s1">self.regex_replacements.append(</span>
                    <span class="s1">EnumeratedValidator.build_regex_replacement(regex_str)</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.val_regexs.append(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">self.regex_replacements.append(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__deepcopy__(self</span><span class="s0">, </span><span class="s1">memodict={}):</span>
        <span class="s4">&quot;&quot;&quot; 
        A custom deepcopy method is needed here because compiled regex 
        objects don't support deepcopy 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = self.__class__</span>
        <span class="s0">return </span><span class="s1">cls(self.plotly_name</span><span class="s0">, </span><span class="s1">self.parent_name</span><span class="s0">, </span><span class="s1">values=self.values)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">build_regex_replacement(regex_str):</span>
        <span class="s2"># Example: regex_str == r&quot;^y([2-9]|[1-9][0-9]+)?$&quot;</span>
        <span class="s2">#</span>
        <span class="s2"># When we see a regular expression like the one above, we want to</span>
        <span class="s2"># build regular expression replacement params that will remove a</span>
        <span class="s2"># suffix of 1 from the input string ('y1' -&gt; 'y' in this example)</span>
        <span class="s2">#</span>
        <span class="s2"># Why?: Regular expressions like this one are used in enumeration</span>
        <span class="s2"># properties that refer to subplotids (e.g. layout.annotation.xref)</span>
        <span class="s2"># The regular expressions forbid suffixes of 1, like 'x1'. But we</span>
        <span class="s2"># want to accept 'x1' and coerce it into 'x'</span>
        <span class="s2">#</span>
        <span class="s2"># To be cautious, we only perform this conversion for enumerated</span>
        <span class="s2"># values that match the anchor-style regex</span>
        <span class="s1">match = re.match(</span>
            <span class="s5">r&quot;\^(\w)\(\[2\-9\]\|\[1\-9\]\[0\-9\]\+\)\?\( domain\)\?\$&quot;</span><span class="s0">, </span><span class="s1">regex_str</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">match:</span>
            <span class="s1">anchor_char = match.group(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s5">&quot;^&quot; </span><span class="s1">+ anchor_char + </span><span class="s5">&quot;1$&quot;</span><span class="s0">, </span><span class="s1">anchor_char</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">perform_replacemenet(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return v with any applicable regex replacements applied 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s0">for </span><span class="s1">repl_args </span><span class="s0">in </span><span class="s1">self.regex_replacements:</span>
                <span class="s0">if </span><span class="s1">repl_args:</span>
                    <span class="s1">v = re.sub(repl_args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repl_args[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">v)</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s2"># Separate regular values from regular expressions</span>
        <span class="s1">enum_vals = []</span>
        <span class="s1">enum_regexs = []</span>
        <span class="s0">for </span><span class="s1">v</span><span class="s0">, </span><span class="s1">regex </span><span class="s0">in </span><span class="s1">zip(self.values</span><span class="s0">, </span><span class="s1">self.val_regexs):</span>
            <span class="s0">if </span><span class="s1">regex </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">enum_regexs.append(regex.pattern)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">enum_vals.append(v)</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{name}' property is an enumeration that may be specified as:&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">enum_vals:</span>
            <span class="s1">enum_vals_str = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
                <span class="s1">textwrap.wrap(</span>
                    <span class="s1">repr(enum_vals)</span><span class="s0">,</span>
                    <span class="s1">initial_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">break_on_hyphens=</span><span class="s0">False,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - One of the following enumeration values: 
{enum_vals_str}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">enum_vals_str=enum_vals_str</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">enum_regexs:</span>
            <span class="s1">enum_regexs_str = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
                <span class="s1">textwrap.wrap(</span>
                    <span class="s1">repr(enum_regexs)</span><span class="s0">,</span>
                    <span class="s1">initial_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">break_on_hyphens=</span><span class="s0">False,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A string that matches one of the following regular expressions: 
{enum_regexs_str}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">enum_regexs_str=enum_regexs_str</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.array_ok:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A tuple, list, or one-dimensional numpy array of the above&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">in_values(self</span><span class="s0">, </span><span class="s1">e):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return whether a value matches one of the enumeration options 
        &quot;&quot;&quot;</span>
        <span class="s1">is_str = isinstance(e</span><span class="s0">, </span><span class="s1">string_types)</span>
        <span class="s0">for </span><span class="s1">v</span><span class="s0">, </span><span class="s1">regex </span><span class="s0">in </span><span class="s1">zip(self.values</span><span class="s0">, </span><span class="s1">self.val_regexs):</span>
            <span class="s0">if </span><span class="s1">is_str </span><span class="s0">and </span><span class="s1">regex:</span>
                <span class="s1">in_values = fullmatch(regex</span><span class="s0">, </span><span class="s1">e) </span><span class="s0">is not None</span>
                <span class="s2"># in_values = regex.fullmatch(e) is not None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">in_values = e == v</span>

            <span class="s0">if </span><span class="s1">in_values:</span>
                <span class="s0">return True</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_array(v):</span>
            <span class="s1">v_replaced = [self.perform_replacemenet(v_el) </span><span class="s0">for </span><span class="s1">v_el </span><span class="s0">in </span><span class="s1">v]</span>

            <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v_replaced </span><span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">self.in_values(e))]</span>
            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els[:</span><span class="s3">10</span><span class="s1">])</span>

            <span class="s0">if </span><span class="s1">is_homogeneous_array(v):</span>
                <span class="s1">v = copy_to_readonly_numpy_array(v)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">v = self.perform_replacemenet(v)</span>
            <span class="s0">if not </span><span class="s1">self.in_values(v):</span>
                <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">BooleanValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;boolean&quot;: { 
        &quot;description&quot;: &quot;A boolean (true/false) value.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(BooleanValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s0">return </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property must be specified as a bool 
    (either True, or False)&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">bool):</span>
            <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">SrcValidator(BaseValidator):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(SrcValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">self.chart_studio = get_module(</span><span class="s5">&quot;chart_studio&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s0">return </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property must be specified as a string or 
    as a plotly.grid_objs.Column object&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.chart_studio </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">self.chart_studio.grid_objs.Column):</span>
            <span class="s2"># Convert to id string</span>
            <span class="s1">v = v.id</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">NumberValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;number&quot;: { 
        &quot;description&quot;: &quot;A number or a numeric value (e.g. a number 
                        inside a string). When applicable, values 
                        greater (less) than `max` (`min`) are coerced to 
                        the `dflt`.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;min&quot;, 
            &quot;max&quot;, 
            &quot;arrayOk&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">min=</span><span class="s0">None, </span><span class="s1">max=</span><span class="s0">None, </span><span class="s1">array_ok=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(NumberValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2"># Handle min</span>
        <span class="s0">if </span><span class="s1">min </span><span class="s0">is None and </span><span class="s1">max </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Max was specified, so make min -inf</span>
            <span class="s1">self.min_val = float(</span><span class="s5">&quot;-inf&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.min_val = min</span>

        <span class="s2"># Handle max</span>
        <span class="s0">if </span><span class="s1">max </span><span class="s0">is None and </span><span class="s1">min </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Min was specified, so make min inf</span>
            <span class="s1">self.max_val = float(</span><span class="s5">&quot;inf&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.max_val = max</span>

        <span class="s0">if </span><span class="s1">min </span><span class="s0">is not None or </span><span class="s1">max </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.has_min_max = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.has_min_max = </span><span class="s0">False</span>

        <span class="s1">self.array_ok = array_ok</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a number and may be specified as:&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">self.has_min_max:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - An int or float&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - An int or float in the interval [{min_val}, {max_val}]&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">min_val=self.min_val</span><span class="s0">, </span><span class="s1">max_val=self.max_val</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.array_ok:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A tuple, list, or one-dimensional numpy array of the above&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_homogeneous_array(v):</span>
            <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">v_array = copy_to_readonly_numpy_array(v</span><span class="s0">, </span><span class="s1">force_numeric=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">OverflowError):</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s2"># Check min/max</span>
            <span class="s0">if </span><span class="s1">self.has_min_max:</span>
                <span class="s1">v_valid = np.logical_and(</span>
                    <span class="s1">self.min_val &lt;= v_array</span><span class="s0">, </span><span class="s1">v_array &lt;= self.max_val</span>
                <span class="s1">)</span>

                <span class="s0">if not </span><span class="s1">np.all(v_valid):</span>
                    <span class="s2"># Grab up to the first 10 invalid values</span>
                    <span class="s1">v_invalid = np.logical_not(v_valid)</span>
                    <span class="s1">some_invalid_els = np.array(v</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s5">&quot;object&quot;</span><span class="s1">)[v_invalid][</span>
                        <span class="s1">:</span><span class="s3">10</span>
                    <span class="s1">].tolist()</span>

                    <span class="s1">self.raise_invalid_elements(some_invalid_els)</span>

            <span class="s1">v = v_array  </span><span class="s2"># Always numeric numpy array</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_simple_array(v):</span>
            <span class="s2"># Check numeric</span>
            <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">numbers.Number)]</span>

            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els[:</span><span class="s3">10</span><span class="s1">])</span>

            <span class="s2"># Check min/max</span>
            <span class="s0">if </span><span class="s1">self.has_min_max:</span>
                <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if not </span><span class="s1">(self.min_val &lt;= e &lt;= self.max_val)]</span>

                <span class="s0">if </span><span class="s1">invalid_els:</span>
                    <span class="s1">self.raise_invalid_elements(invalid_els[:</span><span class="s3">10</span><span class="s1">])</span>

            <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Check numeric</span>
            <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">numbers.Number):</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s2"># Check min/max</span>
            <span class="s0">if </span><span class="s1">self.has_min_max:</span>
                <span class="s0">if not </span><span class="s1">(self.min_val &lt;= v &lt;= self.max_val):</span>
                    <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">IntegerValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;integer&quot;: { 
        &quot;description&quot;: &quot;An integer or an integer inside a string. When 
                        applicable, values greater (less) than `max` 
                        (`min`) are coerced to the `dflt`.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;min&quot;, 
            &quot;max&quot;, 
            &quot;arrayOk&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">min=</span><span class="s0">None, </span><span class="s1">max=</span><span class="s0">None, </span><span class="s1">array_ok=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(IntegerValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2"># Handle min</span>
        <span class="s0">if </span><span class="s1">min </span><span class="s0">is None and </span><span class="s1">max </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Max was specified, so make min -inf</span>
            <span class="s1">self.min_val = -sys.maxsize - </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.min_val = min</span>

        <span class="s2"># Handle max</span>
        <span class="s0">if </span><span class="s1">max </span><span class="s0">is None and </span><span class="s1">min </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Min was specified, so make min inf</span>
            <span class="s1">self.max_val = sys.maxsize</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.max_val = max</span>

        <span class="s0">if </span><span class="s1">min </span><span class="s0">is not None or </span><span class="s1">max </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.has_min_max = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.has_min_max = </span><span class="s0">False</span>

        <span class="s1">self.array_ok = array_ok</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a integer and may be specified as:&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">self.has_min_max:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - An int (or float that will be cast to an int)&quot;&quot;&quot;</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">desc = desc + (</span>
                <span class="s5">&quot;&quot;&quot; 
      - An int (or float that will be cast to an int) 
        in the interval [{min_val}, {max_val}]&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">min_val=self.min_val</span><span class="s0">, </span><span class="s1">max_val=self.max_val</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.array_ok:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A tuple, list, or one-dimensional numpy array of the above&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_homogeneous_array(v):</span>
            <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s1">)</span>
            <span class="s1">v_array = copy_to_readonly_numpy_array(</span>
                <span class="s1">v</span><span class="s0">, </span><span class="s1">kind=(</span><span class="s5">&quot;i&quot;</span><span class="s0">, </span><span class="s5">&quot;u&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">force_numeric=</span><span class="s0">True</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">v_array.dtype.kind </span><span class="s0">not in </span><span class="s1">[</span><span class="s5">&quot;i&quot;</span><span class="s0">, </span><span class="s5">&quot;u&quot;</span><span class="s1">]:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s2"># Check min/max</span>
            <span class="s0">if </span><span class="s1">self.has_min_max:</span>
                <span class="s1">v_valid = np.logical_and(</span>
                    <span class="s1">self.min_val &lt;= v_array</span><span class="s0">, </span><span class="s1">v_array &lt;= self.max_val</span>
                <span class="s1">)</span>

                <span class="s0">if not </span><span class="s1">np.all(v_valid):</span>
                    <span class="s2"># Grab up to the first 10 invalid values</span>
                    <span class="s1">v_invalid = np.logical_not(v_valid)</span>
                    <span class="s1">some_invalid_els = np.array(v</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s5">&quot;object&quot;</span><span class="s1">)[v_invalid][</span>
                        <span class="s1">:</span><span class="s3">10</span>
                    <span class="s1">].tolist()</span>
                    <span class="s1">self.raise_invalid_elements(some_invalid_els)</span>

            <span class="s1">v = v_array</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_simple_array(v):</span>
            <span class="s2"># Check integer type</span>
            <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">int)]</span>

            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els[:</span><span class="s3">10</span><span class="s1">])</span>

            <span class="s2"># Check min/max</span>
            <span class="s0">if </span><span class="s1">self.has_min_max:</span>
                <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if not </span><span class="s1">(self.min_val &lt;= e &lt;= self.max_val)]</span>

                <span class="s0">if </span><span class="s1">invalid_els:</span>
                    <span class="s1">self.raise_invalid_elements(invalid_els[:</span><span class="s3">10</span><span class="s1">])</span>

            <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Check int</span>
            <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s2"># don't let int() cast strings to ints</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s2"># Check min/max</span>
            <span class="s0">if </span><span class="s1">self.has_min_max:</span>
                <span class="s0">if not </span><span class="s1">(self.min_val &lt;= v &lt;= self.max_val):</span>
                    <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">StringValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;string&quot;: { 
        &quot;description&quot;: &quot;A string value. Numbers are converted to strings 
                        except for attributes with `strict` set to true.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;noBlank&quot;, 
            &quot;strict&quot;, 
            &quot;arrayOk&quot;, 
            &quot;values&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">plotly_name</span><span class="s0">,</span>
        <span class="s1">parent_name</span><span class="s0">,</span>
        <span class="s1">no_blank=</span><span class="s0">False,</span>
        <span class="s1">strict=</span><span class="s0">False,</span>
        <span class="s1">array_ok=</span><span class="s0">False,</span>
        <span class="s1">values=</span><span class="s0">None,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(StringValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">self.no_blank = no_blank</span>
        <span class="s1">self.strict = strict</span>
        <span class="s1">self.array_ok = array_ok</span>
        <span class="s1">self.values = values</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">to_str_or_unicode_or_none(v):</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert a value to a string if it's not None, a string, 
        or a unicode (on Python 2). 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None or </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s0">return </span><span class="s1">v</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">str(v)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a string and must be specified as:&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.no_blank:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A non-empty string&quot;&quot;&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">self.values:</span>
            <span class="s1">valid_str = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
                <span class="s1">textwrap.wrap(</span>
                    <span class="s1">repr(self.values)</span><span class="s0">,</span>
                    <span class="s1">initial_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">break_on_hyphens=</span><span class="s0">False,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - One of the following strings: 
{valid_str}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">valid_str=valid_str</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A string&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">self.strict:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A number that will be converted to a string&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.array_ok:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A tuple, list, or one-dimensional numpy array of the above&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_array(v):</span>

            <span class="s2"># If strict, make sure all elements are strings.</span>
            <span class="s0">if </span><span class="s1">self.strict:</span>
                <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">string_types)]</span>
                <span class="s0">if </span><span class="s1">invalid_els:</span>
                    <span class="s1">self.raise_invalid_elements(invalid_els)</span>

            <span class="s0">if </span><span class="s1">is_homogeneous_array(v):</span>
                <span class="s1">np = get_module(</span><span class="s5">&quot;numpy&quot;</span><span class="s1">)</span>

                <span class="s2"># If not strict, let numpy cast elements to strings</span>
                <span class="s1">v = copy_to_readonly_numpy_array(v</span><span class="s0">, </span><span class="s1">kind=</span><span class="s5">&quot;U&quot;</span><span class="s1">)</span>

                <span class="s2"># Check no_blank</span>
                <span class="s0">if </span><span class="s1">self.no_blank:</span>
                    <span class="s1">invalid_els = v[v == </span><span class="s5">&quot;&quot;</span><span class="s1">][:</span><span class="s3">10</span><span class="s1">].tolist()</span>
                    <span class="s0">if </span><span class="s1">invalid_els:</span>
                        <span class="s1">self.raise_invalid_elements(invalid_els)</span>

                <span class="s2"># Check values</span>
                <span class="s0">if </span><span class="s1">self.values:</span>
                    <span class="s1">invalid_inds = np.logical_not(np.isin(v</span><span class="s0">, </span><span class="s1">self.values))</span>
                    <span class="s1">invalid_els = v[invalid_inds][:</span><span class="s3">10</span><span class="s1">].tolist()</span>
                    <span class="s0">if </span><span class="s1">invalid_els:</span>
                        <span class="s1">self.raise_invalid_elements(invalid_els)</span>
            <span class="s0">elif </span><span class="s1">is_simple_array(v):</span>
                <span class="s0">if not </span><span class="s1">self.strict:</span>
                    <span class="s1">v = [StringValidator.to_str_or_unicode_or_none(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>

                <span class="s2"># Check no_blank</span>
                <span class="s0">if </span><span class="s1">self.no_blank:</span>
                    <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if </span><span class="s1">e == </span><span class="s5">&quot;&quot;</span><span class="s1">]</span>
                    <span class="s0">if </span><span class="s1">invalid_els:</span>
                        <span class="s1">self.raise_invalid_elements(invalid_els)</span>

                <span class="s2"># Check values</span>
                <span class="s0">if </span><span class="s1">self.values:</span>
                    <span class="s1">invalid_els = [e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if </span><span class="s1">v </span><span class="s0">not in </span><span class="s1">self.values]</span>
                    <span class="s0">if </span><span class="s1">invalid_els:</span>
                        <span class="s1">self.raise_invalid_elements(invalid_els)</span>

                <span class="s1">v = to_scalar_or_list(v)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.strict:</span>
                <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
                    <span class="s1">self.raise_invalid_val(v)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
                    <span class="s0">pass</span>
                <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">float)):</span>
                    <span class="s2"># Convert value to a string</span>
                    <span class="s1">v = str(v)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s0">if </span><span class="s1">self.no_blank </span><span class="s0">and </span><span class="s1">len(v) == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s0">if </span><span class="s1">self.values </span><span class="s0">and </span><span class="s1">v </span><span class="s0">not in </span><span class="s1">self.values:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">ColorValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;color&quot;: { 
        &quot;description&quot;: &quot;A string describing color. Supported formats: 
                        - hex (e.g. '#d3d3d3') 
                        - rgb (e.g. 'rgb(255, 0, 0)') 
                        - rgba (e.g. 'rgb(255, 0, 0, 0.5)') 
                        - hsl (e.g. 'hsl(0, 100%, 50%)') 
                        - hsv (e.g. 'hsv(0, 100%, 100%)') 
                        - named colors(full list: 
                          http://www.w3.org/TR/css3-color/#svg-color)&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;arrayOk&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s1">re_hex = re.compile(</span><span class="s5">r&quot;#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})&quot;</span><span class="s1">)</span>
    <span class="s1">re_rgb_etc = re.compile(</span><span class="s5">r&quot;(rgb|hsl|hsv)a?\([\d.]+%?(,[\d.]+%?){2,3}\)&quot;</span><span class="s1">)</span>
    <span class="s1">re_ddk = re.compile(</span><span class="s5">r&quot;var\(\-\-.*\)&quot;</span><span class="s1">)</span>

    <span class="s1">named_colors = [</span>
        <span class="s5">&quot;aliceblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;antiquewhite&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;aqua&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;aquamarine&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;azure&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;beige&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;bisque&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;black&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;blanchedalmond&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;blue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;blueviolet&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;brown&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;burlywood&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;cadetblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;chartreuse&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;chocolate&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;coral&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;cornflowerblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;cornsilk&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;crimson&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;cyan&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkcyan&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkgoldenrod&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkgray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkgrey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkgreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkkhaki&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkmagenta&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkolivegreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkorange&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkorchid&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkred&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darksalmon&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkseagreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkslateblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkslategray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkslategrey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkturquoise&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;darkviolet&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;deeppink&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;deepskyblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;dimgray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;dimgrey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;dodgerblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;firebrick&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;floralwhite&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;forestgreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;fuchsia&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;gainsboro&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;ghostwhite&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;gold&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;goldenrod&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;gray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;grey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;green&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;greenyellow&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;honeydew&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;hotpink&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;indianred&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;indigo&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;ivory&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;khaki&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lavender&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lavenderblush&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lawngreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lemonchiffon&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightcoral&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightcyan&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightgoldenrodyellow&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightgray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightgrey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightgreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightpink&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightsalmon&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightseagreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightskyblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightslategray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightslategrey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightsteelblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lightyellow&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;lime&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;limegreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;linen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;magenta&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;maroon&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumaquamarine&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumorchid&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumpurple&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumseagreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumslateblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumspringgreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumturquoise&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mediumvioletred&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;midnightblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mintcream&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;mistyrose&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;moccasin&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;navajowhite&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;navy&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;oldlace&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;olive&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;olivedrab&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;orange&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;orangered&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;orchid&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;palegoldenrod&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;palegreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;paleturquoise&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;palevioletred&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;papayawhip&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;peachpuff&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;peru&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;pink&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;plum&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;powderblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;purple&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;red&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;rosybrown&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;royalblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;rebeccapurple&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;saddlebrown&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;salmon&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;sandybrown&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;seagreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;seashell&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;sienna&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;silver&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;skyblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;slateblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;slategray&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;slategrey&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;snow&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;springgreen&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;steelblue&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;tan&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;teal&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;thistle&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;tomato&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;turquoise&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;violet&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;wheat&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;white&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;whitesmoke&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;yellow&quot;</span><span class="s0">,</span>
        <span class="s5">&quot;yellowgreen&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">array_ok=</span><span class="s0">False, </span><span class="s1">colorscale_path=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(ColorValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">self.array_ok = array_ok</span>

        <span class="s2"># colorscale_path is the path to the colorscale associated with this</span>
        <span class="s2"># color property, or None if no such colorscale exists. Only colors</span>
        <span class="s2"># with an associated colorscale may take on numeric values</span>
        <span class="s1">self.colorscale_path = colorscale_path</span>

    <span class="s0">def </span><span class="s1">numbers_allowed(self):</span>
        <span class="s0">return </span><span class="s1">self.colorscale_path </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">named_clrs_str = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
            <span class="s1">textwrap.wrap(</span>
                <span class="s5">&quot;, &quot;</span><span class="s1">.join(self.named_colors)</span><span class="s0">,</span>
                <span class="s1">width=</span><span class="s3">79 </span><span class="s1">- </span><span class="s3">16</span><span class="s0">,</span>
                <span class="s1">initial_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">valid_color_description = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a color and may be specified as: 
      - A hex string (e.g. '#ff0000') 
      - An rgb/rgba string (e.g. 'rgb(255,0,0)') 
      - An hsl/hsla string (e.g. 'hsl(0,100%,50%)') 
      - An hsv/hsva string (e.g. 'hsv(0,100%,100%)') 
      - A named CSS color: 
{clrs}&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span><span class="s0">, </span><span class="s1">clrs=named_clrs_str</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.colorscale_path:</span>
            <span class="s1">valid_color_description = (</span>
                <span class="s1">valid_color_description</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A number that will be interpreted as a color 
        according to {colorscale_path}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">colorscale_path=self.colorscale_path</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.array_ok:</span>
            <span class="s1">valid_color_description = (</span>
                <span class="s1">valid_color_description</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A list or array of any of the above&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">valid_color_description</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">should_raise=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_homogeneous_array(v):</span>
            <span class="s1">v = copy_to_readonly_numpy_array(v)</span>
            <span class="s0">if </span><span class="s1">self.numbers_allowed() </span><span class="s0">and </span><span class="s1">v.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s5">&quot;u&quot;</span><span class="s0">, </span><span class="s5">&quot;i&quot;</span><span class="s0">, </span><span class="s5">&quot;f&quot;</span><span class="s1">]:</span>
                <span class="s2"># Numbers are allowed and we have an array of numbers.</span>
                <span class="s2"># All good</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">validated_v = [self.validate_coerce(e</span><span class="s0">, </span><span class="s1">should_raise=</span><span class="s0">False</span><span class="s1">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>

                <span class="s1">invalid_els = self.find_invalid_els(v</span><span class="s0">, </span><span class="s1">validated_v)</span>

                <span class="s0">if </span><span class="s1">invalid_els </span><span class="s0">and </span><span class="s1">should_raise:</span>
                    <span class="s1">self.raise_invalid_elements(invalid_els)</span>

                <span class="s2"># ### Check that elements have valid colors types ###</span>
                <span class="s0">elif </span><span class="s1">self.numbers_allowed() </span><span class="s0">or </span><span class="s1">invalid_els:</span>
                    <span class="s1">v = copy_to_readonly_numpy_array(validated_v</span><span class="s0">, </span><span class="s1">kind=</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">v = copy_to_readonly_numpy_array(validated_v</span><span class="s0">, </span><span class="s1">kind=</span><span class="s5">&quot;U&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_simple_array(v):</span>
            <span class="s1">validated_v = [self.validate_coerce(e</span><span class="s0">, </span><span class="s1">should_raise=</span><span class="s0">False</span><span class="s1">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>

            <span class="s1">invalid_els = self.find_invalid_els(v</span><span class="s0">, </span><span class="s1">validated_v)</span>

            <span class="s0">if </span><span class="s1">invalid_els </span><span class="s0">and </span><span class="s1">should_raise:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">v = validated_v</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Validate scalar color</span>
            <span class="s1">validated_v = self.vc_scalar(v)</span>
            <span class="s0">if </span><span class="s1">validated_v </span><span class="s0">is None and </span><span class="s1">should_raise:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s1">v = validated_v</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">find_invalid_els(self</span><span class="s0">, </span><span class="s1">orig</span><span class="s0">, </span><span class="s1">validated</span><span class="s0">, </span><span class="s1">invalid_els=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Helper method to find invalid elements in orig array. 
        Elements are invalid if their corresponding element in 
        the validated array is None. 
 
        This method handles deeply nested list structures 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">invalid_els </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">invalid_els = []</span>

        <span class="s0">for </span><span class="s1">orig_el</span><span class="s0">, </span><span class="s1">validated_el </span><span class="s0">in </span><span class="s1">zip(orig</span><span class="s0">, </span><span class="s1">validated):</span>
            <span class="s0">if </span><span class="s1">is_array(orig_el):</span>
                <span class="s1">self.find_invalid_els(orig_el</span><span class="s0">, </span><span class="s1">validated_el</span><span class="s0">, </span><span class="s1">invalid_els)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">validated_el </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">invalid_els.append(orig_el)</span>

        <span class="s0">return </span><span class="s1">invalid_els</span>

    <span class="s0">def </span><span class="s1">vc_scalar(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s4">&quot;&quot;&quot; Helper to validate/coerce a scalar color &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ColorValidator.perform_validate_coerce(</span>
            <span class="s1">v</span><span class="s0">, </span><span class="s1">allow_number=self.numbers_allowed()</span>
        <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">perform_validate_coerce(v</span><span class="s0">, </span><span class="s1">allow_number=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Validate, coerce, and return a single color value. If input cannot be 
        coerced to a valid color then return None. 
 
        Parameters 
        ---------- 
        v : number or str 
            Candidate color value 
 
        allow_number : bool 
            True if numbers are allowed as colors 
 
        Returns 
        ------- 
        number or str or None 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">numbers.Number) </span><span class="s0">and </span><span class="s1">allow_number:</span>
            <span class="s2"># If allow_numbers then any number is ok</span>
            <span class="s0">return </span><span class="s1">v</span>
        <span class="s0">elif not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s2"># If not allow_numbers then value must be a string</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Remove spaces so regexes don't need to bother with them.</span>
            <span class="s1">v_normalized = v.replace(</span><span class="s5">&quot; &quot;</span><span class="s0">, </span><span class="s5">&quot;&quot;</span><span class="s1">).lower()</span>

            <span class="s2"># if ColorValidator.re_hex.fullmatch(v_normalized):</span>
            <span class="s0">if </span><span class="s1">fullmatch(ColorValidator.re_hex</span><span class="s0">, </span><span class="s1">v_normalized):</span>
                <span class="s2"># valid hex color (e.g. #f34ab3)</span>
                <span class="s0">return </span><span class="s1">v</span>
            <span class="s0">elif </span><span class="s1">fullmatch(ColorValidator.re_rgb_etc</span><span class="s0">, </span><span class="s1">v_normalized):</span>
                <span class="s2"># elif ColorValidator.re_rgb_etc.fullmatch(v_normalized):</span>
                <span class="s2"># Valid rgb(a), hsl(a), hsv(a) color</span>
                <span class="s2"># (e.g. rgba(10, 234, 200, 50%)</span>
                <span class="s0">return </span><span class="s1">v</span>
            <span class="s0">elif </span><span class="s1">fullmatch(ColorValidator.re_ddk</span><span class="s0">, </span><span class="s1">v_normalized):</span>
                <span class="s2"># Valid var(--*) DDK theme variable, inspired by CSS syntax</span>
                <span class="s2"># (e.g. var(--accent) )</span>
                <span class="s2"># DDK will crawl &amp; eval var(-- colors for Graph theming</span>
                <span class="s0">return </span><span class="s1">v</span>
            <span class="s0">elif </span><span class="s1">v_normalized </span><span class="s0">in </span><span class="s1">ColorValidator.named_colors:</span>
                <span class="s2"># Valid named color (e.g. 'coral')</span>
                <span class="s0">return </span><span class="s1">v</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Not a valid color</span>
                <span class="s0">return None</span>


<span class="s0">class </span><span class="s1">ColorlistValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;colorlist&quot;: { 
      &quot;description&quot;: &quot;A list of colors. Must be an {array} containing 
                      valid colors.&quot;, 
      &quot;requiredOpts&quot;: [], 
      &quot;otherOpts&quot;: [ 
        &quot;dflt&quot; 
      ] 
    } 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(ColorlistValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s0">return </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a colorlist that may be specified 
    as a tuple, list, one-dimensional numpy array, or pandas Series of valid 
    color strings&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>

        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">is_array(v):</span>
            <span class="s1">validated_v = [</span>
                <span class="s1">ColorValidator.perform_validate_coerce(e</span><span class="s0">, </span><span class="s1">allow_number=</span><span class="s0">False</span><span class="s1">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v</span>
            <span class="s1">]</span>

            <span class="s1">invalid_els = [</span>
                <span class="s1">el </span><span class="s0">for </span><span class="s1">el</span><span class="s0">, </span><span class="s1">validated_el </span><span class="s0">in </span><span class="s1">zip(v</span><span class="s0">, </span><span class="s1">validated_v) </span><span class="s0">if </span><span class="s1">validated_el </span><span class="s0">is None</span>
            <span class="s1">]</span>
            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els)</span>

            <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">ColorscaleValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;colorscale&quot;: { 
        &quot;description&quot;: &quot;A Plotly colorscale either picked by a name: 
                        (any of Greys, YlGnBu, Greens, YlOrRd, Bluered, 
                        RdBu, Reds, Blues, Picnic, Rainbow, Portland, 
                        Jet, Hot, Blackbody, Earth, Electric, Viridis) 
                        customized as an {array} of 2-element {arrays} 
                        where the first element is the normalized color 
                        level value (starting at *0* and ending at *1*), 
                        and the second item is a valid color string.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(ColorscaleValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2"># named colorscales initialized on first use</span>
        <span class="s1">self._named_colorscales = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">named_colorscales(self):</span>
        <span class="s0">if </span><span class="s1">self._named_colorscales </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">inspect</span>
            <span class="s0">import </span><span class="s1">itertools</span>
            <span class="s0">from </span><span class="s1">plotly </span><span class="s0">import </span><span class="s1">colors</span>

            <span class="s1">colorscale_members = itertools.chain(</span>
                <span class="s1">inspect.getmembers(colors.sequential)</span><span class="s0">,</span>
                <span class="s1">inspect.getmembers(colors.diverging)</span><span class="s0">,</span>
                <span class="s1">inspect.getmembers(colors.cyclical)</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">self._named_colorscales = {</span>
                <span class="s1">c[</span><span class="s3">0</span><span class="s1">].lower(): c[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">colorscale_members</span>
                <span class="s0">if </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">tuple)</span>
                <span class="s0">and </span><span class="s1">len(c) == </span><span class="s3">2</span>
                <span class="s0">and </span><span class="s1">isinstance(c[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str)</span>
                <span class="s0">and </span><span class="s1">isinstance(c[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list)</span>
                <span class="s0">and not </span><span class="s1">c[</span><span class="s3">0</span><span class="s1">].endswith(</span><span class="s5">&quot;_r&quot;</span><span class="s1">)</span>
                <span class="s0">and not </span><span class="s1">c[</span><span class="s3">0</span><span class="s1">].startswith(</span><span class="s5">&quot;_&quot;</span><span class="s1">)</span>
            <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">self._named_colorscales</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s1">colorscales_str = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
            <span class="s1">textwrap.wrap(</span>
                <span class="s1">repr(sorted(list(self.named_colorscales)))</span><span class="s0">,</span>
                <span class="s1">initial_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">13</span><span class="s0">,</span>
                <span class="s1">break_on_hyphens=</span><span class="s0">False,</span>
                <span class="s1">width=</span><span class="s3">80</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a colorscale and may be 
    specified as: 
      - A list of colors that will be spaced evenly to create the colorscale. 
        Many predefined colorscale lists are included in the sequential, diverging, 
        and cyclical modules in the plotly.colors package. 
      - A list of 2-element lists where the first element is the 
        normalized color level value (starting at 0 and ending at 1), 
        and the second item is a valid color string. 
        (e.g. [[0, 'green'], [0.5, 'red'], [1.0, 'rgb(0, 0, 255)']]) 
      - One of the following named colorscales: 
{colorscales_str}. 
        Appending '_r' to a named colorscale reverses it. 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span><span class="s0">, </span><span class="s1">colorscales_str=colorscales_str</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s1">v_valid = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">v_valid = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s1">v_lower = v.lower()</span>
            <span class="s0">if </span><span class="s1">v_lower </span><span class="s0">in </span><span class="s1">self.named_colorscales:</span>
                <span class="s2"># Convert to color list</span>
                <span class="s1">v = self.named_colorscales[v_lower]</span>
                <span class="s1">v_valid = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">v_lower.endswith(</span><span class="s5">&quot;_r&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">v_lower[:-</span><span class="s3">2</span><span class="s1">] </span><span class="s0">in </span><span class="s1">self.named_colorscales:</span>
                <span class="s1">v = self.named_colorscales[v_lower[:-</span><span class="s3">2</span><span class="s1">]][::-</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">v_valid = </span><span class="s0">True</span>
            <span class="s2">#</span>
            <span class="s0">if </span><span class="s1">v_valid:</span>
                <span class="s2"># Convert to list of lists colorscale</span>
                <span class="s1">d = len(v) - </span><span class="s3">1</span>
                <span class="s1">v = [[(</span><span class="s3">1.0 </span><span class="s1">* i) / (</span><span class="s3">1.0 </span><span class="s1">* d)</span><span class="s0">, </span><span class="s1">x] </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(v)]</span>

        <span class="s0">elif </span><span class="s1">is_array(v) </span><span class="s0">and </span><span class="s1">len(v) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2"># If firset element is a string, treat as colorsequence</span>
            <span class="s0">if </span><span class="s1">isinstance(v[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">string_types):</span>
                <span class="s1">invalid_els = [</span>
                    <span class="s1">e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v </span><span class="s0">if </span><span class="s1">ColorValidator.perform_validate_coerce(e) </span><span class="s0">is None</span>
                <span class="s1">]</span>

                <span class="s0">if </span><span class="s1">len(invalid_els) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">v_valid = </span><span class="s0">True</span>

                    <span class="s2"># Convert to list of lists colorscale</span>
                    <span class="s1">d = len(v) - </span><span class="s3">1</span>
                    <span class="s1">v = [[(</span><span class="s3">1.0 </span><span class="s1">* i) / (</span><span class="s3">1.0 </span><span class="s1">* d)</span><span class="s0">, </span><span class="s1">x] </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(v)]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">invalid_els = [</span>
                    <span class="s1">e</span>
                    <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s0">not </span><span class="s1">is_array(e)</span>
                        <span class="s0">or </span><span class="s1">len(e) != </span><span class="s3">2</span>
                        <span class="s0">or not </span><span class="s1">isinstance(e[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">numbers.Number)</span>
                        <span class="s0">or not </span><span class="s1">(</span><span class="s3">0 </span><span class="s1">&lt;= e[</span><span class="s3">0</span><span class="s1">] &lt;= </span><span class="s3">1</span><span class="s1">)</span>
                        <span class="s0">or not </span><span class="s1">isinstance(e[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">string_types)</span>
                        <span class="s0">or </span><span class="s1">ColorValidator.perform_validate_coerce(e[</span><span class="s3">1</span><span class="s1">]) </span><span class="s0">is None</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>

                <span class="s0">if </span><span class="s1">len(invalid_els) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">v_valid = </span><span class="s0">True</span>

                    <span class="s2"># Convert to list of lists</span>
                    <span class="s1">v = [</span>
                        <span class="s1">[e[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ColorValidator.perform_validate_coerce(e[</span><span class="s3">1</span><span class="s1">])] </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v</span>
                    <span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">v_valid:</span>
            <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">present(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s2"># Return-type must be immutable</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s0">return </span><span class="s1">v</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">tuple([tuple(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v])</span>


<span class="s0">class </span><span class="s1">AngleValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;angle&quot;: { 
        &quot;description&quot;: &quot;A number (in degree) between -180 and 180.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(AngleValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a angle (in degrees) that may be 
    specified as a number between -180 and 180. Numeric values outside this 
    range are converted to the equivalent value 
    (e.g. 270 is converted to -90). 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">numbers.Number):</span>
            <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Normalize v onto the interval [-180, 180)</span>
            <span class="s1">v = (v + </span><span class="s3">180</span><span class="s1">) % </span><span class="s3">360 </span><span class="s1">- </span><span class="s3">180</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">SubplotidValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;subplotid&quot;: { 
        &quot;description&quot;: &quot;An id string of a subplot type (given by dflt), 
                        optionally followed by an integer &gt;1. e.g. if 
                        dflt='geo', we can have 'geo', 'geo2', 'geo3', 
                        ...&quot;, 
        &quot;requiredOpts&quot;: [ 
            &quot;dflt&quot; 
        ], 
        &quot;otherOpts&quot;: [ 
            &quot;regex&quot; 
        ] 
    } 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">dflt=</span><span class="s0">None, </span><span class="s1">regex=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>

        <span class="s0">if </span><span class="s1">dflt </span><span class="s0">is None and </span><span class="s1">regex </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;One or both of regex and deflt must be specified&quot;</span><span class="s1">)</span>

        <span class="s1">super(SubplotidValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">dflt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.base = dflt</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># e.g. regex == '/^y([2-9]|[1-9][0-9]+)?$/'</span>
            <span class="s1">self.base = re.match(</span><span class="s5">r&quot;/\^(\w+)&quot;</span><span class="s0">, </span><span class="s1">regex).group(</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">self.regex = self.base + </span><span class="s5">r&quot;(\d*)&quot;</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is an identifier of a particular 
    subplot, of type '{base}', that may be specified as the string '{base}' 
    optionally followed by an integer &gt;= 1 
    (e.g. '{base}', '{base}1', '{base}2', '{base}3', etc.) 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span><span class="s0">, </span><span class="s1">base=self.base</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">pass</span>
        <span class="s0">elif not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># match = re.fullmatch(self.regex, v)</span>
            <span class="s1">match = fullmatch(self.regex</span><span class="s0">, </span><span class="s1">v)</span>
            <span class="s0">if not </span><span class="s1">match:</span>
                <span class="s1">is_valid = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">digit_str = match.group(</span><span class="s3">1</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(digit_str) &gt; </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">int(digit_str) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">is_valid = </span><span class="s0">False</span>
                <span class="s0">elif </span><span class="s1">len(digit_str) &gt; </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">int(digit_str) == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2"># Remove 1 suffix (e.g. x1 -&gt; x)</span>
                    <span class="s1">v = self.base</span>
                    <span class="s1">is_valid = </span><span class="s0">True</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">is_valid = </span><span class="s0">True</span>

            <span class="s0">if not </span><span class="s1">is_valid:</span>
                <span class="s1">self.raise_invalid_val(v)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">FlaglistValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;flaglist&quot;: { 
        &quot;description&quot;: &quot;A string representing a combination of flags 
                        (order does not matter here). Combine any of the 
                        available `flags` with *+*. 
                        (e.g. ('lines+markers')). Values in `extras` 
                        cannot be combined.&quot;, 
        &quot;requiredOpts&quot;: [ 
            &quot;flags&quot; 
        ], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;extras&quot;, 
            &quot;arrayOk&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">extras=</span><span class="s0">None, </span><span class="s1">array_ok=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(FlaglistValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">self.flags = flags</span>
        <span class="s1">self.extras = extras </span><span class="s0">if </span><span class="s1">extras </span><span class="s0">is not None else </span><span class="s1">[]</span>
        <span class="s1">self.array_ok = array_ok</span>

        <span class="s1">self.all_flags = self.flags + self.extras</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">desc = (</span>
            <span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a flaglist and may be specified 
    as a string containing:&quot;&quot;&quot;</span>
        <span class="s1">).format(plotly_name=self.plotly_name)</span>

        <span class="s2"># Flags</span>
        <span class="s1">desc = (</span>
            <span class="s1">desc</span>
            <span class="s1">+ (</span>
                <span class="s5">&quot;&quot;&quot; 
      - Any combination of {flags} joined with '+' characters 
        (e.g. '{eg_flag}')&quot;&quot;&quot;</span>
            <span class="s1">).format(flags=self.flags</span><span class="s0">, </span><span class="s1">eg_flag=</span><span class="s5">&quot;+&quot;</span><span class="s1">.join(self.flags[:</span><span class="s3">2</span><span class="s1">]))</span>
        <span class="s1">)</span>

        <span class="s2"># Extras</span>
        <span class="s0">if </span><span class="s1">self.extras:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ (</span>
                    <span class="s5">&quot;&quot;&quot; 
        OR exactly one of {extras} (e.g. '{eg_extra}')&quot;&quot;&quot;</span>
                <span class="s1">).format(extras=self.extras</span><span class="s0">, </span><span class="s1">eg_extra=self.extras[-</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.array_ok:</span>
            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A list or array of the above&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">vc_scalar(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s0">return None</span>

        <span class="s2"># To be generous we accept flags separated on plus ('+'),</span>
        <span class="s2"># or comma (',')</span>
        <span class="s1">split_vals = [e.strip() </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">re.split(</span><span class="s5">&quot;[,+]&quot;</span><span class="s0">, </span><span class="s1">v)]</span>

        <span class="s2"># Are all flags valid names?</span>
        <span class="s1">all_flags_valid = all([f </span><span class="s0">in </span><span class="s1">self.all_flags </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">split_vals])</span>

        <span class="s2"># Are any 'extras' flags present?</span>
        <span class="s1">has_extras = any([f </span><span class="s0">in </span><span class="s1">self.extras </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">split_vals])</span>

        <span class="s2"># For flaglist to be valid all flags must be valid, and if we have</span>
        <span class="s2"># any extras present, there must be only one flag (the single extras</span>
        <span class="s2"># flag)</span>
        <span class="s1">is_valid = all_flags_valid </span><span class="s0">and </span><span class="s1">(</span><span class="s0">not </span><span class="s1">has_extras </span><span class="s0">or </span><span class="s1">len(split_vals) == </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_valid:</span>
            <span class="s0">return </span><span class="s5">&quot;+&quot;</span><span class="s1">.join(split_vals)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_array(v):</span>

            <span class="s2"># Coerce individual strings</span>
            <span class="s1">validated_v = [self.vc_scalar(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">v]</span>

            <span class="s1">invalid_els = [</span>
                <span class="s1">el </span><span class="s0">for </span><span class="s1">el</span><span class="s0">, </span><span class="s1">validated_el </span><span class="s0">in </span><span class="s1">zip(v</span><span class="s0">, </span><span class="s1">validated_v) </span><span class="s0">if </span><span class="s1">validated_el </span><span class="s0">is None</span>
            <span class="s1">]</span>
            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els)</span>

            <span class="s0">if </span><span class="s1">is_homogeneous_array(v):</span>
                <span class="s1">v = copy_to_readonly_numpy_array(validated_v</span><span class="s0">, </span><span class="s1">kind=</span><span class="s5">&quot;U&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">else</span><span class="s1">:</span>

            <span class="s1">validated_v = self.vc_scalar(v)</span>
            <span class="s0">if </span><span class="s1">validated_v </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

            <span class="s1">v = validated_v</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">AnyValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;any&quot;: { 
        &quot;description&quot;: &quot;Any type.&quot;, 
        &quot;requiredOpts&quot;: [], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;values&quot;, 
            &quot;arrayOk&quot; 
        ] 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">values=</span><span class="s0">None, </span><span class="s1">array_ok=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(AnyValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">self.values = values</span>
        <span class="s1">self.array_ok = array_ok</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property accepts values of any type 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_homogeneous_array(v):</span>
            <span class="s1">v = copy_to_readonly_numpy_array(v</span><span class="s0">, </span><span class="s1">kind=</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">self.array_ok </span><span class="s0">and </span><span class="s1">is_simple_array(v):</span>
            <span class="s1">v = to_scalar_or_list(v)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">InfoArrayValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;info_array&quot;: { 
        &quot;description&quot;: &quot;An {array} of plot information.&quot;, 
        &quot;requiredOpts&quot;: [ 
            &quot;items&quot; 
        ], 
        &quot;otherOpts&quot;: [ 
            &quot;dflt&quot;, 
            &quot;freeLength&quot;, 
            &quot;dimensions&quot; 
        ] 
    } 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">plotly_name</span><span class="s0">,</span>
        <span class="s1">parent_name</span><span class="s0">,</span>
        <span class="s1">items</span><span class="s0">,</span>
        <span class="s1">free_length=</span><span class="s0">None,</span>
        <span class="s1">dimensions=</span><span class="s0">None,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(InfoArrayValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">self.items = items</span>
        <span class="s1">self.dimensions = dimensions </span><span class="s0">if </span><span class="s1">dimensions </span><span class="s0">else </span><span class="s3">1</span>
        <span class="s1">self.free_length = free_length</span>

        <span class="s2"># Instantiate validators for each info array element</span>
        <span class="s1">self.item_validators = []</span>
        <span class="s1">info_array_items = self.items </span><span class="s0">if </span><span class="s1">isinstance(self.items</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">else </span><span class="s1">[self.items]</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate(info_array_items):</span>
            <span class="s1">element_name = </span><span class="s5">&quot;{name}[{i}]&quot;</span><span class="s1">.format(name=plotly_name</span><span class="s0">, </span><span class="s1">i=i)</span>
            <span class="s1">item_validator = InfoArrayValidator.build_validator(</span>
                <span class="s1">item</span><span class="s0">, </span><span class="s1">element_name</span><span class="s0">, </span><span class="s1">parent_name</span>
            <span class="s1">)</span>
            <span class="s1">self.item_validators.append(item_validator)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s2"># Cases</span>
        <span class="s2">#  1) self.items is array, self.dimensions is 1</span>
        <span class="s2">#       a) free_length=True</span>
        <span class="s2">#       b) free_length=False</span>
        <span class="s2">#  2) self.items is array, self.dimensions is 2</span>
        <span class="s2">#     (requires free_length=True)</span>
        <span class="s2">#  3) self.items is scalar (requires free_length=True)</span>
        <span class="s2">#       a) dimensions=1</span>
        <span class="s2">#       b) dimensions=2</span>
        <span class="s2">#</span>
        <span class="s2"># dimensions can be set to '1-2' to indicate the both are accepted</span>
        <span class="s2">#</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is an info array that may be specified as:</span><span class="s0">\ 
</span><span class="s5">&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(self.items</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s2"># ### Case 1 ###</span>
            <span class="s0">if </span><span class="s1">self.dimensions </span><span class="s0">in </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s5">&quot;1-2&quot;</span><span class="s1">):</span>
                <span class="s1">upto = </span><span class="s5">&quot; up to&quot; </span><span class="s0">if </span><span class="s1">self.free_length </span><span class="s0">and </span><span class="s1">self.dimensions == </span><span class="s3">1 </span><span class="s0">else </span><span class="s5">&quot;&quot;</span>
                <span class="s1">desc += </span><span class="s5">&quot;&quot;&quot; 
 
    * a list or tuple of{upto} {N} elements where:</span><span class="s0">\ 
</span><span class="s5">&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">upto=upto</span><span class="s0">, </span><span class="s1">N=len(self.item_validators)</span>
                <span class="s1">)</span>

                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item_validator </span><span class="s0">in </span><span class="s1">enumerate(self.item_validators):</span>
                    <span class="s1">el_desc = item_validator.description().strip()</span>
                    <span class="s1">desc = (</span>
                        <span class="s1">desc</span>
                        <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
({i}) {el_desc}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                            <span class="s1">i=i</span><span class="s0">, </span><span class="s1">el_desc=el_desc</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

            <span class="s2"># ### Case 2 ###</span>
            <span class="s0">if </span><span class="s1">self.dimensions </span><span class="s0">in </span><span class="s1">(</span><span class="s5">&quot;1-2&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
                <span class="s0">assert </span><span class="s1">self.free_length</span>

                <span class="s1">desc += </span><span class="s5">&quot;&quot;&quot; 
 
    * a 2D list where:&quot;&quot;&quot;</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item_validator </span><span class="s0">in </span><span class="s1">enumerate(self.item_validators):</span>
                    <span class="s2"># Update name for 2d</span>
                    <span class="s1">orig_name = item_validator.plotly_name</span>
                    <span class="s1">item_validator.plotly_name = </span><span class="s5">&quot;{name}[i][{i}]&quot;</span><span class="s1">.format(</span>
                        <span class="s1">name=self.plotly_name</span><span class="s0">, </span><span class="s1">i=i</span>
                    <span class="s1">)</span>

                    <span class="s1">el_desc = item_validator.description().strip()</span>
                    <span class="s1">desc = (</span>
                        <span class="s1">desc</span>
                        <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
({i}) {el_desc}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                            <span class="s1">i=i</span><span class="s0">, </span><span class="s1">el_desc=el_desc</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s1">item_validator.plotly_name = orig_name</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># ### Case 3 ###</span>
            <span class="s0">assert </span><span class="s1">self.free_length</span>
            <span class="s1">item_validator = self.item_validators[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">orig_name = item_validator.plotly_name</span>

            <span class="s0">if </span><span class="s1">self.dimensions </span><span class="s0">in </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s5">&quot;1-2&quot;</span><span class="s1">):</span>
                <span class="s1">item_validator.plotly_name = </span><span class="s5">&quot;{name}[i]&quot;</span><span class="s1">.format(name=self.plotly_name)</span>

                <span class="s1">el_desc = item_validator.description().strip()</span>

                <span class="s1">desc += </span><span class="s5">&quot;&quot;&quot; 
    * a list of elements where: 
      {el_desc} 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">el_desc=el_desc</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.dimensions </span><span class="s0">in </span><span class="s1">(</span><span class="s5">&quot;1-2&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
                <span class="s1">item_validator.plotly_name = </span><span class="s5">&quot;{name}[i][j]&quot;</span><span class="s1">.format(</span>
                    <span class="s1">name=self.plotly_name</span>
                <span class="s1">)</span>

                <span class="s1">el_desc = item_validator.description().strip()</span>
                <span class="s1">desc += </span><span class="s5">&quot;&quot;&quot; 
    * a 2D list where: 
      {el_desc} 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">el_desc=el_desc</span>
                <span class="s1">)</span>

            <span class="s1">item_validator.plotly_name = orig_name</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">build_validator(validator_info</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name):</span>
        <span class="s1">datatype = validator_info[</span><span class="s5">&quot;valType&quot;</span><span class="s1">]  </span><span class="s2"># type: str</span>
        <span class="s1">validator_classname = datatype.title().replace(</span><span class="s5">&quot;_&quot;</span><span class="s0">, </span><span class="s5">&quot;&quot;</span><span class="s1">) + </span><span class="s5">&quot;Validator&quot;</span>
        <span class="s1">validator_class = eval(validator_classname)</span>

        <span class="s1">kwargs = {</span>
            <span class="s1">k: validator_info[k]</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">validator_info</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">[</span><span class="s5">&quot;valType&quot;</span><span class="s0">, </span><span class="s5">&quot;description&quot;</span><span class="s0">, </span><span class="s5">&quot;role&quot;</span><span class="s1">]</span>
        <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">validator_class(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">validate_element_with_indexed_name(self</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">validator</span><span class="s0">, </span><span class="s1">inds):</span>
        <span class="s4">&quot;&quot;&quot; 
        Helper to add indexes to a validator's name, call validate_coerce on 
        a value, then restore the original validator name. 
 
        This makes sure that if a validation error message is raised, the 
        property name the user sees includes the index(es) of the offending 
        element. 
 
        Parameters 
        ---------- 
        val: 
            A value to be validated 
        validator 
            A validator 
        inds 
            List of one or more non-negative integers that represent the 
            nested index of the value being validated 
        Returns 
        ------- 
        val 
            validated value 
 
        Raises 
        ------ 
        ValueError 
            if val fails validation 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_name = validator.plotly_name</span>
        <span class="s1">new_name = self.plotly_name</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">inds:</span>
            <span class="s1">new_name += </span><span class="s5">&quot;[&quot; </span><span class="s1">+ str(i) + </span><span class="s5">&quot;]&quot;</span>
        <span class="s1">validator.plotly_name = new_name</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">val = validator.validate_coerce(val)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">validator.plotly_name = orig_name</span>

        <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Pass None through</span>
            <span class="s0">return None</span>
        <span class="s0">elif not </span><span class="s1">is_array(v):</span>
            <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s2"># Save off original v value to use in error reporting</span>
        <span class="s1">orig_v = v</span>

        <span class="s2"># Convert everything into nested lists</span>
        <span class="s2"># This way we don't need to worry about nested numpy arrays</span>
        <span class="s1">v = to_scalar_or_list(v)</span>

        <span class="s1">is_v_2d = v </span><span class="s0">and </span><span class="s1">is_array(v[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">is_v_2d </span><span class="s0">and </span><span class="s1">self.dimensions </span><span class="s0">in </span><span class="s1">(</span><span class="s5">&quot;1-2&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">is_array(self.items):</span>
                <span class="s2"># e.g. 2D list as parcoords.dimensions.constraintrange</span>
                <span class="s2"># check that all items are there for each nested element</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row </span><span class="s0">in </span><span class="s1">enumerate(v):</span>
                    <span class="s2"># Check row length</span>
                    <span class="s0">if not </span><span class="s1">is_array(row) </span><span class="s0">or </span><span class="s1">len(row) != len(self.items):</span>
                        <span class="s1">self.raise_invalid_val(orig_v[i]</span><span class="s0">, </span><span class="s1">[i])</span>

                    <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">validator </span><span class="s0">in </span><span class="s1">enumerate(self.item_validators):</span>
                        <span class="s1">row[j] = self.validate_element_with_indexed_name(</span>
                            <span class="s1">v[i][j]</span><span class="s0">, </span><span class="s1">validator</span><span class="s0">, </span><span class="s1">[i</span><span class="s0">, </span><span class="s1">j]</span>
                        <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># e.g. 2D list as layout.grid.subplots</span>
                <span class="s2"># check that all elements match individual validator</span>
                <span class="s1">validator = self.item_validators[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row </span><span class="s0">in </span><span class="s1">enumerate(v):</span>
                    <span class="s0">if not </span><span class="s1">is_array(row):</span>
                        <span class="s1">self.raise_invalid_val(orig_v[i]</span><span class="s0">, </span><span class="s1">[i])</span>

                    <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">el </span><span class="s0">in </span><span class="s1">enumerate(row):</span>
                        <span class="s1">row[j] = self.validate_element_with_indexed_name(</span>
                            <span class="s1">el</span><span class="s0">, </span><span class="s1">validator</span><span class="s0">, </span><span class="s1">[i</span><span class="s0">, </span><span class="s1">j]</span>
                        <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">v </span><span class="s0">and </span><span class="s1">self.dimensions == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2"># e.g. 1D list passed as layout.grid.subplots</span>
            <span class="s1">self.raise_invalid_val(orig_v[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">elif not </span><span class="s1">is_array(self.items):</span>
            <span class="s2"># e.g. 1D list passed as layout.grid.xaxes</span>
            <span class="s1">validator = self.item_validators[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">el </span><span class="s0">in </span><span class="s1">enumerate(v):</span>
                <span class="s1">v[i] = self.validate_element_with_indexed_name(el</span><span class="s0">, </span><span class="s1">validator</span><span class="s0">, </span><span class="s1">[i])</span>

        <span class="s0">elif not </span><span class="s1">self.free_length </span><span class="s0">and </span><span class="s1">len(v) != len(self.item_validators):</span>
            <span class="s2"># e.g. 3 element list as layout.xaxis.range</span>
            <span class="s1">self.raise_invalid_val(orig_v)</span>
        <span class="s0">elif </span><span class="s1">self.free_length </span><span class="s0">and </span><span class="s1">len(v) &gt; len(self.item_validators):</span>
            <span class="s2"># e.g. 4 element list as layout.updatemenu.button.args</span>
            <span class="s1">self.raise_invalid_val(orig_v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># We have a 1D array of the correct length</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(el</span><span class="s0">, </span><span class="s1">validator) </span><span class="s0">in </span><span class="s1">enumerate(zip(v</span><span class="s0">, </span><span class="s1">self.item_validators)):</span>
                <span class="s2"># Validate coerce elements</span>
                <span class="s1">v[i] = validator.validate_coerce(el)</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">present(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">self.dimensions == </span><span class="s3">2</span>
                <span class="s0">or </span><span class="s1">self.dimensions == </span><span class="s5">&quot;1-2&quot;</span>
                <span class="s0">and </span><span class="s1">v</span>
                <span class="s0">and </span><span class="s1">is_array(v[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">):</span>

                <span class="s2"># 2D case</span>
                <span class="s1">v = copy.deepcopy(v)</span>
                <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">v:</span>
                    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(el</span><span class="s0">, </span><span class="s1">validator) </span><span class="s0">in </span><span class="s1">enumerate(zip(row</span><span class="s0">, </span><span class="s1">self.item_validators)):</span>
                        <span class="s1">row[i] = validator.present(el)</span>

                <span class="s0">return </span><span class="s1">tuple(tuple(row) </span><span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">v)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># 1D case</span>
                <span class="s1">v = copy.copy(v)</span>
                <span class="s2"># Call present on each of the item validators</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(el</span><span class="s0">, </span><span class="s1">validator) </span><span class="s0">in </span><span class="s1">enumerate(zip(v</span><span class="s0">, </span><span class="s1">self.item_validators)):</span>
                    <span class="s2"># Validate coerce elements</span>
                    <span class="s1">v[i] = validator.present(el)</span>

                <span class="s2"># Return tuple form of</span>
                <span class="s0">return </span><span class="s1">tuple(v)</span>


<span class="s0">class </span><span class="s1">LiteralValidator(BaseValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    Validator for readonly literal values 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(LiteralValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">self.val = val</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v != self.val:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property of {parent_name} is read-only&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">plotly_name=self.plotly_name</span><span class="s0">, </span><span class="s1">parent_name=self.parent_name</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">DashValidator(EnumeratedValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    Special case validator for handling dash properties that may be specified 
    as lists of dash lengths.  These are not currently specified in the 
    schema. 
 
    &quot;dash&quot;: { 
        &quot;valType&quot;: &quot;string&quot;, 
        &quot;values&quot;: [ 
            &quot;solid&quot;, 
            &quot;dot&quot;, 
            &quot;dash&quot;, 
            &quot;longdash&quot;, 
            &quot;dashdot&quot;, 
            &quot;longdashdot&quot; 
        ], 
        &quot;dflt&quot;: &quot;solid&quot;, 
        &quot;role&quot;: &quot;style&quot;, 
        &quot;editType&quot;: &quot;style&quot;, 
        &quot;description&quot;: &quot;Sets the dash style of lines. Set to a dash type 
        string (*solid*, *dot*, *dash*, *longdash*, *dashdot*, or 
        *longdashdot*) or a dash length list in px (eg *5px,10px,2px,2px*).&quot; 
    }, 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">**kwargs):</span>

        <span class="s2"># Add regex to handle dash length lists</span>
        <span class="s1">dash_list_regex = </span><span class="s5">r&quot;/^\d+(\.\d+)?(px|%)?((,|\s)\s*\d+(\.\d+)?(px|%)?)*$/&quot;</span>

        <span class="s1">values = values + [dash_list_regex]</span>

        <span class="s2"># Call EnumeratedValidator superclass</span>
        <span class="s1">super(DashValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">values=values</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s2"># Separate regular values from regular expressions</span>
        <span class="s1">enum_vals = []</span>
        <span class="s1">enum_regexs = []</span>
        <span class="s0">for </span><span class="s1">v</span><span class="s0">, </span><span class="s1">regex </span><span class="s0">in </span><span class="s1">zip(self.values</span><span class="s0">, </span><span class="s1">self.val_regexs):</span>
            <span class="s0">if </span><span class="s1">regex </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">enum_regexs.append(regex.pattern)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">enum_vals.append(v)</span>
        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{name}' property is an enumeration that may be specified as:&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">name=self.plotly_name</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">enum_vals:</span>
            <span class="s1">enum_vals_str = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
                <span class="s1">textwrap.wrap(</span>
                    <span class="s1">repr(enum_vals)</span><span class="s0">,</span>
                    <span class="s1">initial_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">12</span><span class="s0">,</span>
                    <span class="s1">break_on_hyphens=</span><span class="s0">False,</span>
                    <span class="s1">width=</span><span class="s3">80</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">desc = (</span>
                <span class="s1">desc</span>
                <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - One of the following dash styles: 
{enum_vals_str}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">enum_vals_str=enum_vals_str</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">desc = (</span>
            <span class="s1">desc</span>
            <span class="s1">+ </span><span class="s5">&quot;&quot;&quot; 
      - A string containing a dash length list in pixels or percentages 
            (e.g. '5px 10px 2px 2px', '5, 10, 2, 2', '10% 20% 40%', etc.) 
&quot;&quot;&quot;</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">desc</span>


<span class="s0">class </span><span class="s1">ImageUriValidator(BaseValidator):</span>
    <span class="s1">_PIL = </span><span class="s0">None</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">_PIL = import_module(</span><span class="s5">&quot;PIL&quot;</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(ImageUriValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">desc = </span><span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is an image URI that may be specified as: 
      - A remote image URI string 
        (e.g. 'http://www.somewhere.com/image.png') 
      - A data URI image string 
        (e.g. 'data:image/png;base64,iVBORw0KGgoAAAANSU') 
      - A PIL.Image.Image object which will be immediately converted 
        to a data URI image string 
        See http://pillow.readthedocs.io/en/latest/reference/Image.html 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">plotly_name=self.plotly_name</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s2"># Future possibilities:</span>
            <span class="s2">#   - Detect filesystem system paths and convert to URI</span>
            <span class="s2">#   - Validate either url or data uri</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self._PIL </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">self._PIL.Image.Image):</span>
            <span class="s2"># Convert PIL image to png data uri string</span>
            <span class="s1">v = self.pil_image_to_uri(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">pil_image_to_uri(v):</span>
        <span class="s1">in_mem_file = io.BytesIO()</span>
        <span class="s1">v.save(in_mem_file</span><span class="s0">, </span><span class="s1">format=</span><span class="s5">&quot;PNG&quot;</span><span class="s1">)</span>
        <span class="s1">in_mem_file.seek(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">img_bytes = in_mem_file.read()</span>
        <span class="s1">base64_encoded_result_bytes = base64.b64encode(img_bytes)</span>
        <span class="s1">base64_encoded_result_str = base64_encoded_result_bytes.decode(</span><span class="s5">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s1">v = </span><span class="s5">&quot;data:image/png;base64,{base64_encoded_result_str}&quot;</span><span class="s1">.format(</span>
            <span class="s1">base64_encoded_result_str=base64_encoded_result_str</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">CompoundValidator(BaseValidator):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">data_class_str</span><span class="s0">, </span><span class="s1">data_docs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(CompoundValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2"># Save element class string</span>
        <span class="s1">self.data_class_str = data_class_str</span>
        <span class="s1">self._data_class = </span><span class="s0">None</span>
        <span class="s1">self.data_docs = data_docs</span>
        <span class="s1">self.module_str = CompoundValidator.compute_graph_obj_module_str(</span>
            <span class="s1">self.data_class_str</span><span class="s0">, </span><span class="s1">parent_name</span>
        <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">compute_graph_obj_module_str(data_class_str</span><span class="s0">, </span><span class="s1">parent_name):</span>
        <span class="s0">if </span><span class="s1">parent_name == </span><span class="s5">&quot;frame&quot; </span><span class="s0">and </span><span class="s1">data_class_str </span><span class="s0">in </span><span class="s1">[</span><span class="s5">&quot;Data&quot;</span><span class="s0">, </span><span class="s5">&quot;Layout&quot;</span><span class="s1">]:</span>
            <span class="s2"># Special case. There are no graph_objs.frame.Data or</span>
            <span class="s2"># graph_objs.frame.Layout classes. These are remapped to</span>
            <span class="s2"># graph_objs.Data and graph_objs.Layout</span>

            <span class="s1">parent_parts = parent_name.split(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s1">module_str = </span><span class="s5">&quot;.&quot;</span><span class="s1">.join([</span><span class="s5">&quot;plotly.graph_objs&quot;</span><span class="s1">] + parent_parts[</span><span class="s3">1</span><span class="s1">:])</span>
        <span class="s0">elif </span><span class="s1">parent_name == </span><span class="s5">&quot;layout.template&quot; </span><span class="s0">and </span><span class="s1">data_class_str == </span><span class="s5">&quot;Layout&quot;</span><span class="s1">:</span>
            <span class="s2"># Remap template's layout to regular layout</span>
            <span class="s1">module_str = </span><span class="s5">&quot;plotly.graph_objs&quot;</span>
        <span class="s0">elif </span><span class="s5">&quot;layout.template.data&quot; </span><span class="s0">in </span><span class="s1">parent_name:</span>
            <span class="s2"># Remap template's traces to regular traces</span>
            <span class="s1">parent_name = parent_name.replace(</span><span class="s5">&quot;layout.template.data.&quot;</span><span class="s0">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">parent_name:</span>
                <span class="s1">module_str = </span><span class="s5">&quot;plotly.graph_objs.&quot; </span><span class="s1">+ parent_name</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">module_str = </span><span class="s5">&quot;plotly.graph_objs&quot;</span>
        <span class="s0">elif </span><span class="s1">parent_name:</span>
            <span class="s1">module_str = </span><span class="s5">&quot;plotly.graph_objs.&quot; </span><span class="s1">+ parent_name</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">module_str = </span><span class="s5">&quot;plotly.graph_objs&quot;</span>

        <span class="s0">return </span><span class="s1">module_str</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">data_class(self):</span>
        <span class="s0">if </span><span class="s1">self._data_class </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">module = import_module(self.module_str)</span>
            <span class="s1">self._data_class = getattr(module</span><span class="s0">, </span><span class="s1">self.data_class_str)</span>

        <span class="s0">return </span><span class="s1">self._data_class</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">desc = (</span>
            <span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is an instance of {class_str} 
    that may be specified as: 
      - An instance of :class:`{module_str}.{class_str}` 
      - A dict of string/value properties that will be passed 
        to the {class_str} constructor 
 
        Supported dict properties: 
            {constructor_params_str}&quot;&quot;&quot;</span>
        <span class="s1">).format(</span>
            <span class="s1">plotly_name=self.plotly_name</span><span class="s0">,</span>
            <span class="s1">class_str=self.data_class_str</span><span class="s0">,</span>
            <span class="s1">module_str=self.module_str</span><span class="s0">,</span>
            <span class="s1">constructor_params_str=self.data_docs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">skip_invalid=</span><span class="s0">False, </span><span class="s1">_validate=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">v = self.data_class()</span>

        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">v = self.data_class(v</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid</span><span class="s0">, </span><span class="s1">_validate=_validate)</span>

        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">self.data_class):</span>
            <span class="s2"># Copy object</span>
            <span class="s1">v = self.data_class(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">skip_invalid:</span>
                <span class="s1">v = self.data_class()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s1">v._plotly_name = self.plotly_name</span>
        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">present(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s2"># Return compound object as-is</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">TitleValidator(CompoundValidator):</span>
    <span class="s4">&quot;&quot;&quot; 
    This is a special validator to allow compound title properties 
    (e.g. layout.title, layout.xaxis.title, etc.) to be set as strings 
    or numbers.  These strings are mapped to the 'text' property of the 
    compound validator. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TitleValidator</span><span class="s0">, </span><span class="s1">self).__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">skip_invalid=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types + (int</span><span class="s0">, </span><span class="s1">float)):</span>
            <span class="s1">v = {</span><span class="s5">&quot;text&quot;</span><span class="s1">: v}</span>
        <span class="s0">return </span><span class="s1">super(TitleValidator</span><span class="s0">, </span><span class="s1">self).validate_coerce(v</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid)</span>


<span class="s0">class </span><span class="s1">CompoundArrayValidator(BaseValidator):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">data_class_str</span><span class="s0">, </span><span class="s1">data_docs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(CompoundArrayValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2"># Save element class string</span>
        <span class="s1">self.data_class_str = data_class_str</span>
        <span class="s1">self._data_class = </span><span class="s0">None</span>

        <span class="s1">self.data_docs = data_docs</span>
        <span class="s1">self.module_str = CompoundValidator.compute_graph_obj_module_str(</span>
            <span class="s1">self.data_class_str</span><span class="s0">, </span><span class="s1">parent_name</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">desc = (</span>
            <span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a tuple of instances of 
    {class_str} that may be specified as: 
      - A list or tuple of instances of {module_str}.{class_str} 
      - A list or tuple of dicts of string/value properties that 
        will be passed to the {class_str} constructor 
 
        Supported dict properties: 
            {constructor_params_str}&quot;&quot;&quot;</span>
        <span class="s1">).format(</span>
            <span class="s1">plotly_name=self.plotly_name</span><span class="s0">,</span>
            <span class="s1">class_str=self.data_class_str</span><span class="s0">,</span>
            <span class="s1">module_str=self.module_str</span><span class="s0">,</span>
            <span class="s1">constructor_params_str=self.data_docs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">data_class(self):</span>
        <span class="s0">if </span><span class="s1">self._data_class </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">module = import_module(self.module_str)</span>
            <span class="s1">self._data_class = getattr(module</span><span class="s0">, </span><span class="s1">self.data_class_str)</span>

        <span class="s0">return </span><span class="s1">self._data_class</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">skip_invalid=</span><span class="s0">False</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">v = []</span>

        <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">res = []</span>
            <span class="s1">invalid_els = []</span>
            <span class="s0">for </span><span class="s1">v_el </span><span class="s0">in </span><span class="s1">v:</span>
                <span class="s0">if </span><span class="s1">isinstance(v_el</span><span class="s0">, </span><span class="s1">self.data_class):</span>
                    <span class="s1">res.append(self.data_class(v_el))</span>
                <span class="s0">elif </span><span class="s1">isinstance(v_el</span><span class="s0">, </span><span class="s1">dict):</span>
                    <span class="s1">res.append(self.data_class(v_el</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">skip_invalid:</span>
                        <span class="s1">res.append(self.data_class())</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">res.append(</span><span class="s0">None</span><span class="s1">)</span>
                        <span class="s1">invalid_els.append(v_el)</span>

            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els)</span>

            <span class="s1">v = to_scalar_or_list(res)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">skip_invalid:</span>
                <span class="s1">v = []</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.raise_invalid_val(v)</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">present(self</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s2"># Return compound object as tuple</span>
        <span class="s0">return </span><span class="s1">tuple(v)</span>


<span class="s0">class </span><span class="s1">BaseDataValidator(BaseValidator):</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">class_strs_map</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">set_uid=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super(BaseDataValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">, </span><span class="s1">parent_name=parent_name</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">self.class_strs_map = class_strs_map</span>
        <span class="s1">self._class_map = {}</span>
        <span class="s1">self.set_uid = set_uid</span>

    <span class="s0">def </span><span class="s1">description(self):</span>

        <span class="s1">trace_types = str(list(self.class_strs_map.keys()))</span>

        <span class="s1">trace_types_wrapped = </span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s1">.join(</span>
            <span class="s1">textwrap.wrap(</span>
                <span class="s1">trace_types</span><span class="s0">,</span>
                <span class="s1">initial_indent=</span><span class="s5">&quot;            One of: &quot;</span><span class="s0">,</span>
                <span class="s1">subsequent_indent=</span><span class="s5">&quot; &quot; </span><span class="s1">* </span><span class="s3">21</span><span class="s0">,</span>
                <span class="s1">width=</span><span class="s3">79 </span><span class="s1">- </span><span class="s3">12</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">desc = (</span>
            <span class="s5">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s5">The '{plotly_name}' property is a tuple of trace instances 
    that may be specified as: 
      - A list or tuple of trace instances 
        (e.g. [Scatter(...), Bar(...)]) 
      - A single trace instance 
        (e.g. Scatter(...), Bar(...), etc.) 
      - A list or tuple of dicts of string/value properties where: 
        - The 'type' property specifies the trace type 
{trace_types} 
 
        - All remaining properties are passed to the constructor of 
          the specified trace type 
 
        (e.g. [{{'type': 'scatter', ...}}, {{'type': 'bar, ...}}])&quot;&quot;&quot;</span>
        <span class="s1">).format(plotly_name=self.plotly_name</span><span class="s0">, </span><span class="s1">trace_types=trace_types_wrapped)</span>

        <span class="s0">return </span><span class="s1">desc</span>

    <span class="s0">def </span><span class="s1">get_trace_class(self</span><span class="s0">, </span><span class="s1">trace_name):</span>
        <span class="s2"># Import trace classes</span>
        <span class="s0">if </span><span class="s1">trace_name </span><span class="s0">not in </span><span class="s1">self._class_map:</span>
            <span class="s1">trace_module = import_module(</span><span class="s5">&quot;plotly.graph_objs&quot;</span><span class="s1">)</span>
            <span class="s1">trace_class_name = self.class_strs_map[trace_name]</span>
            <span class="s1">self._class_map[trace_name] = getattr(trace_module</span><span class="s0">, </span><span class="s1">trace_class_name)</span>

        <span class="s0">return </span><span class="s1">self._class_map[trace_name]</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">skip_invalid=</span><span class="s0">False, </span><span class="s1">_validate=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">plotly.basedatatypes </span><span class="s0">import </span><span class="s1">BaseTraceType</span>

        <span class="s2"># Import Histogram2dcontour, this is the deprecated name of the</span>
        <span class="s2"># Histogram2dContour trace.</span>
        <span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">Histogram2dcontour</span>

        <span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">v = []</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
                <span class="s1">v = [v]</span>

            <span class="s1">res = []</span>
            <span class="s1">invalid_els = []</span>
            <span class="s0">for </span><span class="s1">v_el </span><span class="s0">in </span><span class="s1">v:</span>

                <span class="s0">if </span><span class="s1">isinstance(v_el</span><span class="s0">, </span><span class="s1">BaseTraceType):</span>
                    <span class="s2"># Clone input traces</span>
                    <span class="s1">v_el = v_el.to_plotly_json()</span>

                <span class="s0">if </span><span class="s1">isinstance(v_el</span><span class="s0">, </span><span class="s1">dict):</span>
                    <span class="s1">v_copy = deepcopy(v_el)</span>

                    <span class="s0">if </span><span class="s5">&quot;type&quot; </span><span class="s0">in </span><span class="s1">v_copy:</span>
                        <span class="s1">trace_type = v_copy.pop(</span><span class="s5">&quot;type&quot;</span><span class="s1">)</span>
                    <span class="s0">elif </span><span class="s1">isinstance(v_el</span><span class="s0">, </span><span class="s1">Histogram2dcontour):</span>
                        <span class="s1">trace_type = </span><span class="s5">&quot;histogram2dcontour&quot;</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">trace_type = </span><span class="s5">&quot;scatter&quot;</span>

                    <span class="s0">if </span><span class="s1">trace_type </span><span class="s0">not in </span><span class="s1">self.class_strs_map:</span>
                        <span class="s0">if </span><span class="s1">skip_invalid:</span>
                            <span class="s2"># Treat as scatter trace</span>
                            <span class="s1">trace = self.get_trace_class(</span><span class="s5">&quot;scatter&quot;</span><span class="s1">)(</span>
                                <span class="s1">skip_invalid=skip_invalid</span><span class="s0">, </span><span class="s1">_validate=_validate</span><span class="s0">, </span><span class="s1">**v_copy</span>
                            <span class="s1">)</span>
                            <span class="s1">res.append(trace)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">res.append(</span><span class="s0">None</span><span class="s1">)</span>
                            <span class="s1">invalid_els.append(v_el)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">trace = self.get_trace_class(trace_type)(</span>
                            <span class="s1">skip_invalid=skip_invalid</span><span class="s0">, </span><span class="s1">_validate=_validate</span><span class="s0">, </span><span class="s1">**v_copy</span>
                        <span class="s1">)</span>
                        <span class="s1">res.append(trace)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">skip_invalid:</span>
                        <span class="s2"># Add empty scatter trace</span>
                        <span class="s1">trace = self.get_trace_class(</span><span class="s5">&quot;scatter&quot;</span><span class="s1">)()</span>
                        <span class="s1">res.append(trace)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">res.append(</span><span class="s0">None</span><span class="s1">)</span>
                        <span class="s1">invalid_els.append(v_el)</span>

            <span class="s0">if </span><span class="s1">invalid_els:</span>
                <span class="s1">self.raise_invalid_elements(invalid_els)</span>

            <span class="s1">v = to_scalar_or_list(res)</span>

            <span class="s2"># Set new UIDs</span>
            <span class="s0">if </span><span class="s1">self.set_uid:</span>
                <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">v:</span>
                    <span class="s1">trace.uid = str(uuid.uuid4())</span>

        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">class </span><span class="s1">BaseTemplateValidator(CompoundValidator):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">data_class_str</span><span class="s0">, </span><span class="s1">data_docs</span><span class="s0">, </span><span class="s1">**kwargs):</span>

        <span class="s1">super(BaseTemplateValidator</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">plotly_name=plotly_name</span><span class="s0">,</span>
            <span class="s1">parent_name=parent_name</span><span class="s0">,</span>
            <span class="s1">data_class_str=data_class_str</span><span class="s0">,</span>
            <span class="s1">data_docs=data_docs</span><span class="s0">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">description(self):</span>
        <span class="s1">compound_description = super(BaseTemplateValidator</span><span class="s0">, </span><span class="s1">self).description()</span>
        <span class="s1">compound_description += </span><span class="s5">&quot;&quot;&quot; 
      - The name of a registered template where current registered templates 
        are stored in the plotly.io.templates configuration object. The names 
        of all registered templates can be retrieved with: 
            &gt;&gt;&gt; import plotly.io as pio 
            &gt;&gt;&gt; list(pio.templates)  # doctest: +ELLIPSIS 
            ['ggplot2', 'seaborn', 'simple_white', 'plotly', 'plotly_white', ...] 
 
      - A string containing multiple registered template names, joined on '+' 
        characters (e.g. 'template1+template2'). In this case the resulting 
        template is computed by merging together the collection of registered 
        templates&quot;&quot;&quot;</span>

        <span class="s0">return </span><span class="s1">compound_description</span>

    <span class="s0">def </span><span class="s1">validate_coerce(self</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">skip_invalid=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Check if v is a template identifier</span>
            <span class="s2"># (could be any hashable object)</span>
            <span class="s0">if </span><span class="s1">v </span><span class="s0">in </span><span class="s1">pio.templates:</span>
                <span class="s0">return </span><span class="s1">copy.deepcopy(pio.templates[v])</span>
            <span class="s2"># Otherwise, if v is a string, check to see if it consists of</span>
            <span class="s2"># multiple template names joined on '+' characters</span>
            <span class="s0">elif </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">string_types):</span>
                <span class="s1">template_names = v.split(</span><span class="s5">&quot;+&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">all([name </span><span class="s0">in </span><span class="s1">pio.templates </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">template_names]):</span>
                    <span class="s0">return </span><span class="s1">pio.templates.merge_templates(*template_names)</span>

        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s2"># v is un-hashable</span>
            <span class="s0">pass</span>

        <span class="s2"># Check for empty template</span>
        <span class="s0">if </span><span class="s1">v == {} </span><span class="s0">or </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">self.data_class) </span><span class="s0">and </span><span class="s1">v.to_plotly_json() == {}:</span>
            <span class="s2"># Replace empty template with {'data': {'scatter': [{}]}} so that we can</span>
            <span class="s2"># tell the difference between an un-initialized template and a template</span>
            <span class="s2"># explicitly set to empty.</span>
            <span class="s0">return </span><span class="s1">self.data_class(data_scatter=[{}])</span>

        <span class="s0">return </span><span class="s1">super(BaseTemplateValidator</span><span class="s0">, </span><span class="s1">self).validate_coerce(</span>
            <span class="s1">v</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid</span>
        <span class="s1">)</span>
</pre>
</body>
</html>