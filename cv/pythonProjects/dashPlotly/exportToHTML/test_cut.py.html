<html>
<head>
<title>test_cut.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_cut.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">Interval</span><span class="s0">,</span>
    <span class="s1">IntervalIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">cut</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">qcut</span><span class="s0">,</span>
    <span class="s1">timedelta_range</span><span class="s0">,</span>
    <span class="s1">to_datetime</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.api.types </span><span class="s0">import </span><span class="s1">CategoricalDtype </span><span class="s0">as </span><span class="s1">CDT</span>
<span class="s0">import </span><span class="s1">pandas.core.reshape.tile </span><span class="s0">as </span><span class="s1">tmod</span>


<span class="s0">def </span><span class="s1">test_simple():</span>
    <span class="s1">data = np.ones(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
    <span class="s1">result = cut(data</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">expected = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s0">, </span><span class="s1">[list</span><span class="s0">, </span><span class="s1">np.array])</span>
<span class="s0">def </span><span class="s1">test_bins(func):</span>
    <span class="s1">data = func([</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">6.2</span><span class="s0">, </span><span class="s2">9.7</span><span class="s0">, </span><span class="s2">2.1</span><span class="s1">])</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">bins = cut(data</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">intervals = IntervalIndex.from_breaks(bins.round(</span><span class="s2">3</span><span class="s1">))</span>
    <span class="s1">intervals = intervals.take([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">expected = Categorical(intervals</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_almost_equal(bins</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.1905</span><span class="s0">, </span><span class="s2">3.36666667</span><span class="s0">, </span><span class="s2">6.53333333</span><span class="s0">, </span><span class="s2">9.7</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_right():</span>
    <span class="s1">data = np.array([</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">6.2</span><span class="s0">, </span><span class="s2">9.7</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">2.575</span><span class="s1">])</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">bins = cut(data</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">right=</span><span class="s0">True, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">intervals = IntervalIndex.from_breaks(bins.round(</span><span class="s2">3</span><span class="s1">))</span>
    <span class="s1">expected = Categorical(intervals</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = expected.take([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_almost_equal(bins</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.1905</span><span class="s0">, </span><span class="s2">2.575</span><span class="s0">, </span><span class="s2">4.95</span><span class="s0">, </span><span class="s2">7.325</span><span class="s0">, </span><span class="s2">9.7</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_no_right():</span>
    <span class="s1">data = np.array([</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">6.2</span><span class="s0">, </span><span class="s2">9.7</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">2.575</span><span class="s1">])</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">bins = cut(data</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">right=</span><span class="s0">False, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">intervals = IntervalIndex.from_breaks(bins.round(</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span>
    <span class="s1">intervals = intervals.take([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">expected = Categorical(intervals</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_almost_equal(bins</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">2.575</span><span class="s0">, </span><span class="s2">4.95</span><span class="s0">, </span><span class="s2">7.325</span><span class="s0">, </span><span class="s2">9.7095</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_bins_from_interval_index():</span>
    <span class="s1">c = cut(range(</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
    <span class="s1">expected = c</span>
    <span class="s1">result = cut(range(</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">bins=expected.categories)</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = Categorical.from_codes(</span>
        <span class="s1">np.append(c.codes</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=c.categories</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span>
    <span class="s1">)</span>
    <span class="s1">result = cut(range(</span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">bins=expected.categories)</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_bins_from_interval_index_doc_example():</span>
    <span class="s4"># Make sure we preserve the bins.</span>
    <span class="s1">ages = np.array([</span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">25</span><span class="s0">, </span><span class="s2">28</span><span class="s0">, </span><span class="s2">59</span><span class="s0">, </span><span class="s2">60</span><span class="s1">])</span>
    <span class="s1">c = cut(ages</span><span class="s0">, </span><span class="s1">bins=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">35</span><span class="s0">, </span><span class="s2">70</span><span class="s1">])</span>
    <span class="s1">expected = IntervalIndex.from_tuples([(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">18</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">18</span><span class="s0">, </span><span class="s2">35</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">35</span><span class="s0">, </span><span class="s2">70</span><span class="s1">)])</span>
    <span class="s1">tm.assert_index_equal(c.categories</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = cut([</span><span class="s2">25</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">50</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bins=c.categories)</span>
    <span class="s1">tm.assert_index_equal(result.categories</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_numpy_array_equal(result.codes</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int8&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_bins_not_overlapping_from_interval_index():</span>
    <span class="s4"># see gh-23980</span>
    <span class="s1">msg = </span><span class="s3">&quot;Overlapping IntervalIndex is not accepted&quot;</span>
    <span class="s1">ii = IntervalIndex.from_tuples([(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">12</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">14</span><span class="s1">)])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bins=ii)</span>


<span class="s0">def </span><span class="s1">test_bins_not_monotonic():</span>
    <span class="s1">msg = </span><span class="s3">&quot;bins must increase monotonically&quot;</span>
    <span class="s1">data = [</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">6.2</span><span class="s0">, </span><span class="s2">9.7</span><span class="s0">, </span><span class="s2">2.1</span><span class="s1">]</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut(data</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;x, bins, expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">date_range(</span><span class="s3">&quot;2017-12-31&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">[Timestamp.min</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp.max]</span><span class="s0">,</span>
            <span class="s1">IntervalIndex.from_tuples(</span>
                <span class="s1">[</span>
                    <span class="s1">(Timestamp.min</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp.max)</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">np.array(</span>
                <span class="s1">[np.iinfo(np.int64).min</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.iinfo(np.int64).max]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">IntervalIndex.from_tuples(</span>
                <span class="s1">[(np.iinfo(np.int64).min</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.iinfo(np.int64).max)]</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[</span>
                <span class="s1">np.timedelta64(-</span><span class="s2">1</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">np.timedelta64(</span><span class="s2">0</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">np.timedelta64(</span><span class="s2">1</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span>
                    <span class="s1">np.timedelta64(-np.iinfo(np.int64).max</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">np.timedelta64(</span><span class="s2">0</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">np.timedelta64(np.iinfo(np.int64).max</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">IntervalIndex.from_tuples(</span>
                <span class="s1">[</span>
                    <span class="s1">(</span>
                        <span class="s1">np.timedelta64(-np.iinfo(np.int64).max</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.timedelta64(</span><span class="s2">0</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span>
                        <span class="s1">np.timedelta64(</span><span class="s2">0</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.timedelta64(np.iinfo(np.int64).max</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_bins_monotonic_not_overflowing(x</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s4"># GH 26045</span>
    <span class="s1">result = cut(x</span><span class="s0">, </span><span class="s1">bins)</span>
    <span class="s1">tm.assert_index_equal(result.categories</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_wrong_num_labels():</span>
    <span class="s1">msg = </span><span class="s3">&quot;Bin labels must be one fewer than the number of bin edges&quot;</span>
    <span class="s1">data = [</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">6.2</span><span class="s0">, </span><span class="s2">9.7</span><span class="s0">, </span><span class="s2">2.1</span><span class="s1">]</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut(data</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">labels=[</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s0">, </span><span class="s3">&quot;baz&quot;</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;x,bins,msg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s3">&quot;Cannot cut empty array&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s3">&quot;`bins` should be a positive integer&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_corner(x</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut(x</span><span class="s0">, </span><span class="s1">bins)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.eye(</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">DataFrame(np.eye(</span><span class="s2">2</span><span class="s1">))])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;cut_func&quot;</span><span class="s0">, </span><span class="s1">[cut</span><span class="s0">, </span><span class="s1">qcut])</span>
<span class="s0">def </span><span class="s1">test_cut_not_1d_arg(arg</span><span class="s0">, </span><span class="s1">cut_func):</span>
    <span class="s1">msg = </span><span class="s3">&quot;Input array must be 1 dimensional&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut_func(arg</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
        <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_int_bins_with_inf(data):</span>
    <span class="s4"># GH 24314</span>
    <span class="s1">msg = </span><span class="s3">&quot;cannot specify integer `bins` when input data contains infinity&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut(data</span><span class="s0">, </span><span class="s1">bins=</span><span class="s2">3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_cut_out_of_range_more():</span>
    <span class="s4"># see gh-1511</span>
    <span class="s1">name = </span><span class="s3">&quot;x&quot;</span>

    <span class="s1">ser = Series([</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s1">ind = cut(ser</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">exp = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s1">tm.assert_series_equal(ind</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;right,breaks,closed&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s0">True, </span><span class="s1">[-</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s0">False, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1e-3</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;left&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_labels(right</span><span class="s0">, </span><span class="s1">breaks</span><span class="s0">, </span><span class="s1">closed):</span>
    <span class="s1">arr = np.tile(np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>

    <span class="s1">result</span><span class="s0">, </span><span class="s1">bins = cut(arr</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">retbins=</span><span class="s0">True, </span><span class="s1">right=right)</span>
    <span class="s1">ex_levels = IntervalIndex.from_breaks(breaks</span><span class="s0">, </span><span class="s1">closed=closed)</span>
    <span class="s1">tm.assert_index_equal(result.categories</span><span class="s0">, </span><span class="s1">ex_levels)</span>


<span class="s0">def </span><span class="s1">test_cut_pass_series_name_to_factor():</span>
    <span class="s1">name = </span><span class="s3">&quot;foo&quot;</span>
    <span class="s1">ser = Series(np.random.randn(</span><span class="s2">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s1">factor = cut(ser</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">factor.name == name</span>


<span class="s0">def </span><span class="s1">test_label_precision():</span>
    <span class="s1">arr = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.73</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">)</span>
    <span class="s1">result = cut(arr</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">precision=</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s1">ex_levels = IntervalIndex.from_breaks([-</span><span class="s2">0.00072</span><span class="s0">, </span><span class="s2">0.18</span><span class="s0">, </span><span class="s2">0.36</span><span class="s0">, </span><span class="s2">0.54</span><span class="s0">, </span><span class="s2">0.72</span><span class="s1">])</span>
    <span class="s1">tm.assert_index_equal(result.categories</span><span class="s0">, </span><span class="s1">ex_levels)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;labels&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_na_handling(labels):</span>
    <span class="s1">arr = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">)</span>
    <span class="s1">arr[::</span><span class="s2">3</span><span class="s1">] = np.nan</span>

    <span class="s1">result = cut(arr</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">labels=labels)</span>
    <span class="s1">result = np.asarray(result)</span>

    <span class="s1">expected = np.where(isna(arr)</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">result)</span>
    <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_inf_handling():</span>
    <span class="s1">data = np.arange(</span><span class="s2">6</span><span class="s1">)</span>
    <span class="s1">data_ser = Series(data</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s1">bins = [-np.inf</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.inf]</span>
    <span class="s1">result = cut(data</span><span class="s0">, </span><span class="s1">bins)</span>
    <span class="s1">result_ser = cut(data_ser</span><span class="s0">, </span><span class="s1">bins)</span>

    <span class="s1">ex_uniques = IntervalIndex.from_breaks(bins)</span>
    <span class="s1">tm.assert_index_equal(result.categories</span><span class="s0">, </span><span class="s1">ex_uniques)</span>

    <span class="s0">assert </span><span class="s1">result[</span><span class="s2">5</span><span class="s1">] == Interval(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.inf)</span>
    <span class="s0">assert </span><span class="s1">result[</span><span class="s2">0</span><span class="s1">] == Interval(-np.inf</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result_ser[</span><span class="s2">5</span><span class="s1">] == Interval(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.inf)</span>
    <span class="s0">assert </span><span class="s1">result_ser[</span><span class="s2">0</span><span class="s1">] == Interval(-np.inf</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_cut_out_of_bounds():</span>
    <span class="s1">arr = np.random.randn(</span><span class="s2">100</span><span class="s1">)</span>
    <span class="s1">result = cut(arr</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s1">mask = isna(result)</span>
    <span class="s1">ex_mask = (arr &lt; -</span><span class="s2">1</span><span class="s1">) | (arr &gt; </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(mask</span><span class="s0">, </span><span class="s1">ex_mask)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;get_labels,get_expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s0">lambda </span><span class="s1">labels: labels</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">labels: Categorical(</span>
                <span class="s1">[</span><span class="s3">&quot;Medium&quot;</span><span class="s1">] + </span><span class="s2">4 </span><span class="s1">* [</span><span class="s3">&quot;Small&quot;</span><span class="s1">] + [</span><span class="s3">&quot;Medium&quot;</span><span class="s0">, </span><span class="s3">&quot;Large&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">categories=labels</span><span class="s0">,</span>
                <span class="s1">ordered=</span><span class="s0">True,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">lambda </span><span class="s1">labels: Categorical.from_codes([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">labels)</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">labels: Categorical.from_codes([</span><span class="s2">1</span><span class="s1">] + </span><span class="s2">4 </span><span class="s1">* [</span><span class="s2">0</span><span class="s1">] + [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">labels)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_pass_labels(get_labels</span><span class="s0">, </span><span class="s1">get_expected):</span>
    <span class="s1">bins = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">25</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]</span>
    <span class="s1">arr = [</span><span class="s2">50</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">70</span><span class="s1">]</span>
    <span class="s1">labels = [</span><span class="s3">&quot;Small&quot;</span><span class="s0">, </span><span class="s3">&quot;Medium&quot;</span><span class="s0">, </span><span class="s3">&quot;Large&quot;</span><span class="s1">]</span>

    <span class="s1">result = cut(arr</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">labels=get_labels(labels))</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">get_expected(labels))</span>


<span class="s0">def </span><span class="s1">test_cut_pass_labels_compat():</span>
    <span class="s4"># see gh-16459</span>
    <span class="s1">arr = [</span><span class="s2">50</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">70</span><span class="s1">]</span>
    <span class="s1">labels = [</span><span class="s3">&quot;Good&quot;</span><span class="s0">, </span><span class="s3">&quot;Medium&quot;</span><span class="s0">, </span><span class="s3">&quot;Bad&quot;</span><span class="s1">]</span>

    <span class="s1">result = cut(arr</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">labels=labels)</span>
    <span class="s1">exp = cut(arr</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">labels=Categorical(labels</span><span class="s0">, </span><span class="s1">categories=labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s1">[np.arange(</span><span class="s2">11.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">11.0</span><span class="s1">) / </span><span class="s2">1e10</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_round_frac_just_works(x):</span>
    <span class="s4"># It works.</span>
    <span class="s1">cut(x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;val,precision,expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(-</span><span class="s2">117.9998</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">118</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">117.9998</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">118</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">117.9998</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">118</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">0.000123456</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.00012</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_round_frac(val</span><span class="s0">, </span><span class="s1">precision</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s4"># see gh-1979</span>
    <span class="s1">result = tmod._round_frac(val</span><span class="s0">, </span><span class="s1">precision=precision)</span>
    <span class="s0">assert </span><span class="s1">result == expected</span>


<span class="s0">def </span><span class="s1">test_cut_return_intervals():</span>
    <span class="s1">ser = Series([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>
    <span class="s1">result = cut(ser</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>

    <span class="s1">exp_bins = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s1">num=</span><span class="s2">4</span><span class="s1">).round(</span><span class="s2">3</span><span class="s1">)</span>
    <span class="s1">exp_bins[</span><span class="s2">0</span><span class="s1">] -= </span><span class="s2">0.008</span>

    <span class="s1">expected = Series(</span>
        <span class="s1">IntervalIndex.from_breaks(exp_bins</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">).take(</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">).astype(CDT(ordered=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_series_ret_bins():</span>
    <span class="s4"># see gh-8589</span>
    <span class="s1">ser = Series(np.arange(</span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">bins = cut(ser</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">expected = Series(</span>
        <span class="s1">IntervalIndex.from_breaks([-</span><span class="s2">0.003</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">).repeat(</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">).astype(CDT(ordered=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;kwargs,msg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">({</span><span class="s3">&quot;duplicates&quot;</span><span class="s1">: </span><span class="s3">&quot;drop&quot;</span><span class="s1">}</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">({}</span><span class="s0">, </span><span class="s3">&quot;Bin edges must be unique&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s3">&quot;duplicates&quot;</span><span class="s1">: </span><span class="s3">&quot;raise&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s3">&quot;Bin edges must be unique&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s3">&quot;duplicates&quot;</span><span class="s1">: </span><span class="s3">&quot;foo&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s3">&quot;invalid value for 'duplicates' parameter&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_duplicates_bin(kwargs</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s4"># see gh-20947</span>
    <span class="s1">bins = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span>
    <span class="s1">values = Series(np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;e&quot;</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">msg </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">cut(values</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = cut(values</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">expected = cut(values</span><span class="s0">, </span><span class="s1">pd.unique(bins))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">9.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;length&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_single_bin(data</span><span class="s0">, </span><span class="s1">length):</span>
    <span class="s4"># see gh-14652, gh-15428</span>
    <span class="s1">ser = Series([data] * length)</span>
    <span class="s1">result = cut(ser</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">expected = Series([</span><span class="s2">0</span><span class="s1">] * length</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;array_1_writeable,array_2_writeable&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s0">True, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s0">False, False</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_read_only(array_1_writeable</span><span class="s0">, </span><span class="s1">array_2_writeable):</span>
    <span class="s4"># issue 18773</span>
    <span class="s1">array_1 = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">array_1.flags.writeable = array_1_writeable</span>

    <span class="s1">array_2 = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">array_2.flags.writeable = array_2_writeable</span>

    <span class="s1">hundred_elements = np.arange(</span><span class="s2">100</span><span class="s1">)</span>
    <span class="s1">tm.assert_categorical_equal(</span>
        <span class="s1">cut(hundred_elements</span><span class="s0">, </span><span class="s1">array_1)</span><span class="s0">, </span><span class="s1">cut(hundred_elements</span><span class="s0">, </span><span class="s1">array_2)</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;conv&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s0">lambda </span><span class="s1">v: Timestamp(v)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">v: to_datetime(v)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">v: np.datetime64(v)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">v: Timestamp(v).to_pydatetime()</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_datetime_bin(conv):</span>
    <span class="s1">data = [np.datetime64(</span><span class="s3">&quot;2012-12-13&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2012-12-15&quot;</span><span class="s1">)]</span>
    <span class="s1">bin_data = [</span><span class="s3">&quot;2012-12-12&quot;</span><span class="s0">, </span><span class="s3">&quot;2012-12-14&quot;</span><span class="s0">, </span><span class="s3">&quot;2012-12-16&quot;</span><span class="s1">]</span>

    <span class="s1">expected = Series(</span>
        <span class="s1">IntervalIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Interval(Timestamp(bin_data[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">Timestamp(bin_data[</span><span class="s2">1</span><span class="s1">]))</span><span class="s0">,</span>
                <span class="s1">Interval(Timestamp(bin_data[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">Timestamp(bin_data[</span><span class="s2">2</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">).astype(CDT(ordered=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s1">bins = [conv(v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">bin_data]</span>
    <span class="s1">result = Series(cut(data</span><span class="s0">, </span><span class="s1">bins=bins))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">to_datetime(Series([</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-02&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-03&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-02&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-03&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">np.array(</span>
            <span class="s1">[</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-02&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-03&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">DatetimeIndex([</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-02&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-03&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_datetime_cut(data):</span>
    <span class="s4"># see gh-14714</span>
    <span class="s4">#</span>
    <span class="s4"># Testing time data when it comes in various collection types.</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">_ = cut(data</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">IntervalIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Interval(</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2012-12-31 23:57:07.200000&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 16:00:00&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Interval(</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 16:00:00&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 08:00:00&quot;</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Interval(</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 08:00:00&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-03 00:00:00&quot;</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">).astype(CDT(ordered=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(Series(result)</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;bins&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2">3</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 04:57:07.200000&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 21:00:00&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 13:00:00&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-03 05:00:00&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;box&quot;</span><span class="s0">, </span><span class="s1">[list</span><span class="s0">, </span><span class="s1">np.array</span><span class="s0">, </span><span class="s1">Index</span><span class="s0">, </span><span class="s1">Series])</span>
<span class="s0">def </span><span class="s1">test_datetime_tz_cut(bins</span><span class="s0">, </span><span class="s1">box):</span>
    <span class="s4"># see gh-19872</span>
    <span class="s1">tz = </span><span class="s3">&quot;US/Eastern&quot;</span>
    <span class="s1">s = Series(date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">tz=tz))</span>

    <span class="s0">if not </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">int):</span>
        <span class="s1">bins = box(bins)</span>

    <span class="s1">result = cut(s</span><span class="s0">, </span><span class="s1">bins)</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">IntervalIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Interval(</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2012-12-31 23:57:07.200000&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 16:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Interval(</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 16:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 08:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Interval(</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 08:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-03 00:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">).astype(CDT(ordered=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_datetime_nan_error():</span>
    <span class="s1">msg = </span><span class="s3">&quot;bins must be of datetime64 dtype&quot;</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut(date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">bins=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_datetime_nan_mask():</span>
    <span class="s1">result = cut(</span>
        <span class="s1">date_range(</span><span class="s3">&quot;20130102&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">bins=date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">mask = result.categories.isna()</span>
    <span class="s1">tm.assert_numpy_array_equal(mask</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False</span><span class="s1">]))</span>

    <span class="s1">mask = result.isna()</span>
    <span class="s1">tm.assert_numpy_array_equal(mask</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False, True, True, True, True</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">&quot;UTC&quot;</span><span class="s0">, </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_datetime_cut_roundtrip(tz):</span>
    <span class="s4"># see gh-19891</span>
    <span class="s1">ser = Series(date_range(</span><span class="s3">&quot;20180101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">tz=tz))</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">result_bins = cut(ser</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">expected = cut(ser</span><span class="s0">, </span><span class="s1">result_bins)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected_bins = DatetimeIndex(</span>
        <span class="s1">[</span><span class="s3">&quot;2017-12-31 23:57:07.200000&quot;</span><span class="s0">, </span><span class="s3">&quot;2018-01-02 00:00:00&quot;</span><span class="s0">, </span><span class="s3">&quot;2018-01-03 00:00:00&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">expected_bins = expected_bins.tz_localize(tz)</span>
    <span class="s1">tm.assert_index_equal(result_bins</span><span class="s0">, </span><span class="s1">expected_bins)</span>


<span class="s0">def </span><span class="s1">test_timedelta_cut_roundtrip():</span>
    <span class="s4"># see gh-19891</span>
    <span class="s1">ser = Series(timedelta_range(</span><span class="s3">&quot;1day&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">3</span><span class="s1">))</span>
    <span class="s1">result</span><span class="s0">, </span><span class="s1">result_bins = cut(ser</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">retbins=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">expected = cut(ser</span><span class="s0">, </span><span class="s1">result_bins)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected_bins = TimedeltaIndex(</span>
        <span class="s1">[</span><span class="s3">&quot;0 days 23:57:07.200000&quot;</span><span class="s0">, </span><span class="s3">&quot;2 days 00:00:00&quot;</span><span class="s0">, </span><span class="s3">&quot;3 days 00:00:00&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result_bins</span><span class="s0">, </span><span class="s1">expected_bins)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bins&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;box, compare&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(Series</span><span class="s0">, </span><span class="s1">tm.assert_series_equal)</span><span class="s0">,</span>
        <span class="s1">(np.array</span><span class="s0">, </span><span class="s1">tm.assert_categorical_equal)</span><span class="s0">,</span>
        <span class="s1">(list</span><span class="s0">, </span><span class="s1">tm.assert_equal)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_bool_coercion_to_int(bins</span><span class="s0">, </span><span class="s1">box</span><span class="s0">, </span><span class="s1">compare):</span>
    <span class="s4"># issue 20303</span>
    <span class="s1">data_expected = box([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] * </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">data_result = box([</span><span class="s0">False, True, True, False, True</span><span class="s1">] * </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">expected = cut(data_expected</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">duplicates=</span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span>
    <span class="s1">result = cut(data_result</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">duplicates=</span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span>
    <span class="s1">compare(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;labels&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, True</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_cut_incorrect_labels(labels):</span>
    <span class="s4"># GH 13318</span>
    <span class="s1">values = range(</span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;Bin labels must either be False, None or passed in as a list-like argument&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut(values</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">labels=labels)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bins&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">15</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;right&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;include_lowest&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_cut_nullable_integer(bins</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">include_lowest):</span>
    <span class="s1">a = np.random.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">50</span><span class="s1">).astype(float)</span>
    <span class="s1">a[::</span><span class="s2">2</span><span class="s1">] = np.nan</span>
    <span class="s1">result = cut(</span>
        <span class="s1">pd.array(a</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">right=right</span><span class="s0">, </span><span class="s1">include_lowest=include_lowest</span>
    <span class="s1">)</span>
    <span class="s1">expected = cut(a</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">right=right</span><span class="s0">, </span><span class="s1">include_lowest=include_lowest)</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data, bins, labels, expected_codes, expected_labels&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s2">15</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">19</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">14</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_non_unique_labels(data</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">expected_codes</span><span class="s0">, </span><span class="s1">expected_labels):</span>
    <span class="s4"># GH 33141</span>
    <span class="s1">result = cut(data</span><span class="s0">, </span><span class="s1">bins=bins</span><span class="s0">, </span><span class="s1">labels=labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Categorical.from_codes(</span>
        <span class="s1">expected_codes</span><span class="s0">, </span><span class="s1">categories=expected_labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data, bins, labels, expected_codes, expected_labels&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s2">15</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">19</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">14</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;A&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cut_unordered_labels(data</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">expected_codes</span><span class="s0">, </span><span class="s1">expected_labels):</span>
    <span class="s4"># GH 33141</span>
    <span class="s1">result = cut(data</span><span class="s0">, </span><span class="s1">bins=bins</span><span class="s0">, </span><span class="s1">labels=labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Categorical.from_codes(</span>
        <span class="s1">expected_codes</span><span class="s0">, </span><span class="s1">categories=expected_labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_cut_unordered_with_missing_labels_raises_error():</span>
    <span class="s4"># GH 33141</span>
    <span class="s1">msg = </span><span class="s3">&quot;'labels' must be provided if 'ordered = False'&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">cut([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bins=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_cut_unordered_with_series_labels():</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/36603</span>
    <span class="s1">s = Series([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
    <span class="s1">bins = Series([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
    <span class="s1">labels = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">result = cut(s</span><span class="s0">, </span><span class="s1">bins=bins</span><span class="s0">, </span><span class="s1">labels=labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_cut_no_warnings():</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;value&quot;</span><span class="s1">: np.random.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)})</span>
    <span class="s1">labels = [</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">i</span><span class="s0">} </span><span class="s3">- </span><span class="s0">{</span><span class="s1">i + </span><span class="s2">9</span><span class="s0">}</span><span class="s3">&quot; </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)]</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">df[</span><span class="s3">&quot;group&quot;</span><span class="s1">] = cut(df.value</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">105</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">right=</span><span class="s0">False, </span><span class="s1">labels=labels)</span>


<span class="s0">def </span><span class="s1">test_cut_with_duplicated_index_lowest_included():</span>
    <span class="s4"># GH 42185</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">[Interval(-</span><span class="s2">0.001</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)] * </span><span class="s2">3</span>
        <span class="s1">+ [Interval(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Interval(-</span><span class="s2">0.001</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s0">,</span>
    <span class="s1">).cat.as_ordered()</span>

    <span class="s1">s = Series([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">result = cut(s</span><span class="s0">, </span><span class="s1">bins=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">include_lowest=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_cut_with_nonexact_categorical_indices():</span>
    <span class="s4"># GH 42424</span>

    <span class="s1">ser = Series(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s1">))</span>
    <span class="s1">ser1 = cut(ser</span><span class="s0">, </span><span class="s2">10</span><span class="s1">).value_counts().head(</span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">ser2 = cut(ser</span><span class="s0">, </span><span class="s2">10</span><span class="s1">).value_counts().tail(</span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">result = DataFrame({</span><span class="s3">&quot;1&quot;</span><span class="s1">: ser1</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">: ser2})</span>

    <span class="s1">index = pd.CategoricalIndex(</span>
        <span class="s1">[</span>
            <span class="s1">Interval(-</span><span class="s2">0.099</span><span class="s0">, </span><span class="s2">9.9</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">9.9</span><span class="s0">, </span><span class="s2">19.8</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">19.8</span><span class="s0">, </span><span class="s2">29.7</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">29.7</span><span class="s0">, </span><span class="s2">39.6</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">39.6</span><span class="s0">, </span><span class="s2">49.5</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">49.5</span><span class="s0">, </span><span class="s2">59.4</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">59.4</span><span class="s0">, </span><span class="s2">69.3</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">69.3</span><span class="s0">, </span><span class="s2">79.2</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">79.2</span><span class="s0">, </span><span class="s2">89.1</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Interval(</span><span class="s2">89.1</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">ordered=</span><span class="s0">True,</span>
    <span class="s1">)</span>

    <span class="s1">expected = DataFrame(</span>
        <span class="s1">{</span><span class="s3">&quot;1&quot;</span><span class="s1">: [</span><span class="s2">10</span><span class="s1">] * </span><span class="s2">5 </span><span class="s1">+ [np.nan] * </span><span class="s2">5</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">: [np.nan] * </span><span class="s2">5 </span><span class="s1">+ [</span><span class="s2">10</span><span class="s1">] * </span><span class="s2">5</span><span class="s1">}</span><span class="s0">, </span><span class="s1">index=index</span>
    <span class="s1">)</span>

    <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>


<span class="s0">def </span><span class="s1">test_cut_with_timestamp_tuple_labels():</span>
    <span class="s4"># GH 40661</span>
    <span class="s1">labels = [(Timestamp(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(Timestamp(</span><span class="s2">20</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(Timestamp(</span><span class="s2">30</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)]</span>
    <span class="s1">result = cut([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bins=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">labels=labels)</span>

    <span class="s1">expected = Categorical.from_codes([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">tm.assert_categorical_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>