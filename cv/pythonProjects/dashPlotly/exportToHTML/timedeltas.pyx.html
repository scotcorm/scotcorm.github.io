<html>
<head>
<title>timedeltas.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
timedeltas.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import collections</span>
<span class="s0">import warnings</span>

<span class="s0">import cython</span>

<span class="s0">from cpython.object cimport (</span>
    <span class="s0">Py_EQ,</span>
    <span class="s0">Py_NE,</span>
    <span class="s0">PyObject_RichCompare,</span>
<span class="s0">)</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
    <span class="s0">timedelta,</span>
<span class="s0">)</span>

<span class="s0">PyDateTime_IMPORT</span>


<span class="s0">cimport pandas._libs.tslibs.util as util</span>
<span class="s0">from pandas._libs.tslibs.base cimport ABCTimestamp</span>
<span class="s0">from pandas._libs.tslibs.conversion cimport (</span>
    <span class="s0">cast_from_unit,</span>
    <span class="s0">precision_from_unit,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">c_NaT as NaT,</span>
    <span class="s0">c_nat_strings as nat_strings,</span>
    <span class="s0">checknull_with_nat,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">NPY_DATETIMEUNIT,</span>
    <span class="s0">cmp_scalar,</span>
    <span class="s0">get_datetime64_unit,</span>
    <span class="s0">get_timedelta64_value,</span>
    <span class="s0">pandas_timedeltastruct,</span>
    <span class="s0">td64_to_tdstruct,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.offsets cimport is_tick_object</span>
<span class="s0">from pandas._libs.tslibs.util cimport (</span>
    <span class="s0">is_array,</span>
    <span class="s0">is_datetime64_object,</span>
    <span class="s0">is_float_object,</span>
    <span class="s0">is_integer_object,</span>
    <span class="s0">is_timedelta64_object,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.fields import (</span>
    <span class="s0">RoundTo,</span>
    <span class="s0">round_nsint64,</span>
<span class="s0">)</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Constants</span>

<span class="s0"># components named tuple</span>
<span class="s0">Components = collections.namedtuple(</span>
    <span class="s0">&quot;Components&quot;,</span>
    <span class="s0">[</span>
        <span class="s0">&quot;days&quot;,</span>
        <span class="s0">&quot;hours&quot;,</span>
        <span class="s0">&quot;minutes&quot;,</span>
        <span class="s0">&quot;seconds&quot;,</span>
        <span class="s0">&quot;milliseconds&quot;,</span>
        <span class="s0">&quot;microseconds&quot;,</span>
        <span class="s0">&quot;nanoseconds&quot;,</span>
    <span class="s0">],</span>
<span class="s0">)</span>

<span class="s0">cdef dict timedelta_abbrevs = {</span>
    <span class="s0">&quot;Y&quot;: &quot;Y&quot;,</span>
    <span class="s0">&quot;y&quot;: &quot;Y&quot;,</span>
    <span class="s0">&quot;M&quot;: &quot;M&quot;,</span>
    <span class="s0">&quot;W&quot;: &quot;W&quot;,</span>
    <span class="s0">&quot;w&quot;: &quot;W&quot;,</span>
    <span class="s0">&quot;D&quot;: &quot;D&quot;,</span>
    <span class="s0">&quot;d&quot;: &quot;D&quot;,</span>
    <span class="s0">&quot;days&quot;: &quot;D&quot;,</span>
    <span class="s0">&quot;day&quot;: &quot;D&quot;,</span>
    <span class="s0">&quot;hours&quot;: &quot;h&quot;,</span>
    <span class="s0">&quot;hour&quot;: &quot;h&quot;,</span>
    <span class="s0">&quot;hr&quot;: &quot;h&quot;,</span>
    <span class="s0">&quot;h&quot;: &quot;h&quot;,</span>
    <span class="s0">&quot;m&quot;: &quot;m&quot;,</span>
    <span class="s0">&quot;minute&quot;: &quot;m&quot;,</span>
    <span class="s0">&quot;min&quot;: &quot;m&quot;,</span>
    <span class="s0">&quot;minutes&quot;: &quot;m&quot;,</span>
    <span class="s0">&quot;t&quot;: &quot;m&quot;,</span>
    <span class="s0">&quot;s&quot;: &quot;s&quot;,</span>
    <span class="s0">&quot;seconds&quot;: &quot;s&quot;,</span>
    <span class="s0">&quot;sec&quot;: &quot;s&quot;,</span>
    <span class="s0">&quot;second&quot;: &quot;s&quot;,</span>
    <span class="s0">&quot;ms&quot;: &quot;ms&quot;,</span>
    <span class="s0">&quot;milliseconds&quot;: &quot;ms&quot;,</span>
    <span class="s0">&quot;millisecond&quot;: &quot;ms&quot;,</span>
    <span class="s0">&quot;milli&quot;: &quot;ms&quot;,</span>
    <span class="s0">&quot;millis&quot;: &quot;ms&quot;,</span>
    <span class="s0">&quot;l&quot;: &quot;ms&quot;,</span>
    <span class="s0">&quot;us&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;microseconds&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;microsecond&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;Âµs&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;micro&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;micros&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;u&quot;: &quot;us&quot;,</span>
    <span class="s0">&quot;ns&quot;: &quot;ns&quot;,</span>
    <span class="s0">&quot;nanoseconds&quot;: &quot;ns&quot;,</span>
    <span class="s0">&quot;nano&quot;: &quot;ns&quot;,</span>
    <span class="s0">&quot;nanos&quot;: &quot;ns&quot;,</span>
    <span class="s0">&quot;nanosecond&quot;: &quot;ns&quot;,</span>
    <span class="s0">&quot;n&quot;: &quot;ns&quot;,</span>
<span class="s0">}</span>

<span class="s0">_no_input = object()</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># API</span>

<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def ints_to_pytimedelta(const int64_t[:] arr, box=False):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">convert an i8 repr to an ndarray of timedelta or Timedelta (if box ==</span>
    <span class="s0">True)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray[int64_t]</span>
    <span class="s0">box : bool, default False</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">result : ndarray[object]</span>
        <span class="s0">array of Timedelta or timedeltas objects</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(arr)</span>
        <span class="s0">int64_t value</span>
        <span class="s0">object[:] result = np.empty(n, dtype=object)</span>

    <span class="s0">for i in range(n):</span>

        <span class="s0">value = arr[i]</span>
        <span class="s0">if value == NPY_NAT:</span>
            <span class="s0">result[i] = &lt;object&gt;NaT</span>
        <span class="s0">else:</span>
            <span class="s0">if box:</span>
                <span class="s0">result[i] = Timedelta(value)</span>
            <span class="s0">else:</span>
                <span class="s0">result[i] = timedelta(microseconds=int(value) / 1000)</span>

    <span class="s0">return result.base  # .base to access underlying np.ndarray</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cpdef int64_t delta_to_nanoseconds(delta) except? -1:</span>
    <span class="s0">if is_tick_object(delta):</span>
        <span class="s0">return delta.nanos</span>
    <span class="s0">if isinstance(delta, _Timedelta):</span>
        <span class="s0">delta = delta.value</span>
    <span class="s0">if is_timedelta64_object(delta):</span>
        <span class="s0">return get_timedelta64_value(ensure_td64ns(delta))</span>
    <span class="s0">if is_integer_object(delta):</span>
        <span class="s0">return delta</span>
    <span class="s0">if PyDelta_Check(delta):</span>
        <span class="s0">try:</span>
            <span class="s0">return (</span>
                <span class="s0">delta.days * 24 * 3600 * 1_000_000</span>
                <span class="s0">+ delta.seconds * 1_000_000</span>
                <span class="s0">+ delta.microseconds</span>
            <span class="s0">) * 1000</span>
        <span class="s0">except OverflowError as err:</span>
            <span class="s0">from pandas._libs.tslibs.conversion import OutOfBoundsTimedelta</span>
            <span class="s0">raise OutOfBoundsTimedelta(*err.args) from err</span>

    <span class="s0">raise TypeError(type(delta))</span>


<span class="s0">cdef str npy_unit_to_abbrev(NPY_DATETIMEUNIT unit):</span>
    <span class="s0">if unit == NPY_DATETIMEUNIT.NPY_FR_ns or unit == NPY_DATETIMEUNIT.NPY_FR_GENERIC:</span>
        <span class="s0"># generic -&gt; default to nanoseconds</span>
        <span class="s0">return &quot;ns&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_us:</span>
        <span class="s0">return &quot;us&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_ms:</span>
        <span class="s0">return &quot;ms&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_s:</span>
        <span class="s0">return &quot;s&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_m:</span>
        <span class="s0">return &quot;m&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_h:</span>
        <span class="s0">return &quot;h&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_D:</span>
        <span class="s0">return &quot;D&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_W:</span>
        <span class="s0">return &quot;W&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_M:</span>
        <span class="s0">return &quot;M&quot;</span>
    <span class="s0">elif unit == NPY_DATETIMEUNIT.NPY_FR_Y:</span>
        <span class="s0">return &quot;Y&quot;</span>
    <span class="s0">else:</span>
        <span class="s0">raise NotImplementedError(unit)</span>


<span class="s0">@cython.overflowcheck(True)</span>
<span class="s0">cdef object ensure_td64ns(object ts):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Overflow-safe implementation of td64.astype(&quot;m8[ns]&quot;)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">ts : np.timedelta64</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.timedelta64[ns]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">NPY_DATETIMEUNIT td64_unit</span>
        <span class="s0">int64_t td64_value, mult</span>
        <span class="s0">str unitstr</span>

    <span class="s0">td64_unit = get_datetime64_unit(ts)</span>
    <span class="s0">if (</span>
        <span class="s0">td64_unit != NPY_DATETIMEUNIT.NPY_FR_ns</span>
        <span class="s0">and td64_unit != NPY_DATETIMEUNIT.NPY_FR_GENERIC</span>
    <span class="s0">):</span>
        <span class="s0">unitstr = npy_unit_to_abbrev(td64_unit)</span>

        <span class="s0">td64_value = get_timedelta64_value(ts)</span>

        <span class="s0">mult = precision_from_unit(unitstr)[0]</span>
        <span class="s0">try:</span>
            <span class="s0"># NB: cython#1381 this cannot be *=</span>
            <span class="s0">td64_value = td64_value * mult</span>
        <span class="s0">except OverflowError as err:</span>
            <span class="s0">from pandas._libs.tslibs.conversion import OutOfBoundsTimedelta</span>
            <span class="s0">raise OutOfBoundsTimedelta(ts) from err</span>

        <span class="s0">return np.timedelta64(td64_value, &quot;ns&quot;)</span>

    <span class="s0">return ts</span>


<span class="s0">cdef convert_to_timedelta64(object ts, str unit):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert an incoming object to a timedelta64 if possible.</span>
    <span class="s0">Before calling, unit must be standardized to avoid repeated unit conversion</span>

    <span class="s0">Handle these types of objects:</span>
        <span class="s0">- timedelta/Timedelta</span>
        <span class="s0">- timedelta64</span>
        <span class="s0">- an offset</span>
        <span class="s0">- np.int64 (with unit providing a possible modifier)</span>
        <span class="s0">- None/NaT</span>

    <span class="s0">Return an ns based int64</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if checknull_with_nat(ts):</span>
        <span class="s0">return np.timedelta64(NPY_NAT, &quot;ns&quot;)</span>
    <span class="s0">elif isinstance(ts, _Timedelta):</span>
        <span class="s0"># already in the proper format</span>
        <span class="s0">ts = np.timedelta64(ts.value, &quot;ns&quot;)</span>
    <span class="s0">elif is_timedelta64_object(ts):</span>
        <span class="s0">ts = ensure_td64ns(ts)</span>
    <span class="s0">elif is_integer_object(ts):</span>
        <span class="s0">if ts == NPY_NAT:</span>
            <span class="s0">return np.timedelta64(NPY_NAT, &quot;ns&quot;)</span>
        <span class="s0">else:</span>
            <span class="s0">if unit in [&quot;Y&quot;, &quot;M&quot;, &quot;W&quot;]:</span>
                <span class="s0">ts = np.timedelta64(ts, unit)</span>
            <span class="s0">else:</span>
                <span class="s0">ts = cast_from_unit(ts, unit)</span>
                <span class="s0">ts = np.timedelta64(ts, &quot;ns&quot;)</span>
    <span class="s0">elif is_float_object(ts):</span>
        <span class="s0">if unit in [&quot;Y&quot;, &quot;M&quot;, &quot;W&quot;]:</span>
            <span class="s0">ts = np.timedelta64(int(ts), unit)</span>
        <span class="s0">else:</span>
            <span class="s0">ts = cast_from_unit(ts, unit)</span>
            <span class="s0">ts = np.timedelta64(ts, &quot;ns&quot;)</span>
    <span class="s0">elif isinstance(ts, str):</span>
        <span class="s0">if (len(ts) &gt; 0 and ts[0] == &quot;P&quot;) or (len(ts) &gt; 1 and ts[:2] == &quot;-P&quot;):</span>
            <span class="s0">ts = parse_iso_format_string(ts)</span>
        <span class="s0">else:</span>
            <span class="s0">ts = parse_timedelta_string(ts)</span>
        <span class="s0">ts = np.timedelta64(ts, &quot;ns&quot;)</span>
    <span class="s0">elif is_tick_object(ts):</span>
        <span class="s0">ts = np.timedelta64(ts.nanos, &quot;ns&quot;)</span>

    <span class="s0">if PyDelta_Check(ts):</span>
        <span class="s0">ts = np.timedelta64(delta_to_nanoseconds(ts), &quot;ns&quot;)</span>
    <span class="s0">elif not is_timedelta64_object(ts):</span>
        <span class="s0">raise ValueError(f&quot;Invalid type for timedelta scalar: {type(ts)}&quot;)</span>
    <span class="s0">return ts.astype(&quot;timedelta64[ns]&quot;)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def array_to_timedelta64(</span>
    <span class="s0">ndarray[object] values, str unit=None, str errors=&quot;raise&quot;</span>
<span class="s0">) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert an ndarray to an array of timedeltas. If errors == 'coerce',</span>
    <span class="s0">coerce non-convertible objects to NaT. Otherwise, raise.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[timedelta64ns]</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">int64_t[:] iresult</span>

    <span class="s0">if errors not in {'ignore', 'raise', 'coerce'}:</span>
        <span class="s0">raise ValueError(&quot;errors must be one of {'ignore', 'raise', or 'coerce'}&quot;)</span>

    <span class="s0">n = values.shape[0]</span>
    <span class="s0">result = np.empty(n, dtype='m8[ns]')</span>
    <span class="s0">iresult = result.view('i8')</span>

    <span class="s0">if unit is not None:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">if isinstance(values[i], str) and errors != &quot;coerce&quot;:</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;unit must not be specified if the input contains a str&quot;</span>
                <span class="s0">)</span>

    <span class="s0"># Usually, we have all strings. If so, we hit the fast path.</span>
    <span class="s0"># If this path fails, we try conversion a different way, and</span>
    <span class="s0"># this is where all of the error handling will take place.</span>
    <span class="s0">try:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">if values[i] is NaT:</span>
                <span class="s0"># we allow this check in the fast-path because NaT is a C-object</span>
                <span class="s0">#  so this is an inexpensive check</span>
                <span class="s0">iresult[i] = NPY_NAT</span>
            <span class="s0">else:</span>
                <span class="s0">result[i] = parse_timedelta_string(values[i])</span>
    <span class="s0">except (TypeError, ValueError):</span>
        <span class="s0">parsed_unit = parse_timedelta_unit(unit or 'ns')</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">try:</span>
                <span class="s0">result[i] = convert_to_timedelta64(values[i], parsed_unit)</span>
            <span class="s0">except ValueError as err:</span>
                <span class="s0">if errors == 'coerce':</span>
                    <span class="s0">result[i] = NPY_NAT</span>
                <span class="s0">elif &quot;unit abbreviation w/o a number&quot; in str(err):</span>
                    <span class="s0"># re-raise with more pertinent message</span>
                    <span class="s0">msg = f&quot;Could not convert '{values[i]}' to NumPy timedelta&quot;</span>
                    <span class="s0">raise ValueError(msg) from err</span>
                <span class="s0">else:</span>
                    <span class="s0">raise</span>

    <span class="s0">return iresult.base  # .base to access underlying np.ndarray</span>


<span class="s0">cdef inline int64_t parse_timedelta_string(str ts) except? -1:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parse a regular format timedelta string. Return an int64_t (in ns)</span>
    <span class="s0">or raise a ValueError on an invalid parse.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">unicode c</span>
        <span class="s0">bint neg = 0, have_dot = 0, have_value = 0, have_hhmmss = 0</span>
        <span class="s0">object current_unit = None</span>
        <span class="s0">int64_t result = 0, m = 0, r</span>
        <span class="s0">list number = [], frac = [], unit = []</span>

    <span class="s0"># neg : tracks if we have a leading negative for the value</span>
    <span class="s0"># have_dot : tracks if we are processing a dot (either post hhmmss or</span>
    <span class="s0">#            inside an expression)</span>
    <span class="s0"># have_value : track if we have at least 1 leading unit</span>
    <span class="s0"># have_hhmmss : tracks if we have a regular format hh:mm:ss</span>

    <span class="s0">if len(ts) == 0 or ts in nat_strings:</span>
        <span class="s0">return NPY_NAT</span>

    <span class="s0">for c in ts:</span>

        <span class="s0"># skip whitespace / commas</span>
        <span class="s0">if c == ' ' or c == ',':</span>
            <span class="s0">pass</span>

        <span class="s0"># positive signs are ignored</span>
        <span class="s0">elif c == '+':</span>
            <span class="s0">pass</span>

        <span class="s0"># neg</span>
        <span class="s0">elif c == '-':</span>

            <span class="s0">if neg or have_value or have_hhmmss:</span>
                <span class="s0">raise ValueError(&quot;only leading negative signs are allowed&quot;)</span>

            <span class="s0">neg = 1</span>

        <span class="s0"># number (ascii codes)</span>
        <span class="s0">elif ord(c) &gt;= 48 and ord(c) &lt;= 57:</span>

            <span class="s0">if have_dot:</span>

                <span class="s0"># we found a dot, but now its just a fraction</span>
                <span class="s0">if len(unit):</span>
                    <span class="s0">number.append(c)</span>
                    <span class="s0">have_dot = 0</span>
                <span class="s0">else:</span>
                    <span class="s0">frac.append(c)</span>

            <span class="s0">elif not len(unit):</span>
                <span class="s0">number.append(c)</span>

            <span class="s0">else:</span>
                <span class="s0">r = timedelta_from_spec(number, frac, unit)</span>
                <span class="s0">unit, number, frac = [], [c], []</span>

                <span class="s0">result += timedelta_as_neg(r, neg)</span>

        <span class="s0"># hh:mm:ss.</span>
        <span class="s0">elif c == ':':</span>

            <span class="s0"># we flip this off if we have a leading value</span>
            <span class="s0">if have_value:</span>
                <span class="s0">neg = 0</span>

            <span class="s0"># we are in the pattern hh:mm:ss pattern</span>
            <span class="s0">if len(number):</span>
                <span class="s0">if current_unit is None:</span>
                    <span class="s0">current_unit = 'h'</span>
                    <span class="s0">m = 1000000000 * 3600</span>
                <span class="s0">elif current_unit == 'h':</span>
                    <span class="s0">current_unit = 'm'</span>
                    <span class="s0">m = 1000000000 * 60</span>
                <span class="s0">elif current_unit == 'm':</span>
                    <span class="s0">current_unit = 's'</span>
                    <span class="s0">m = 1000000000</span>
                <span class="s0">r = &lt;int64_t&gt;int(''.join(number)) * m</span>
                <span class="s0">result += timedelta_as_neg(r, neg)</span>
                <span class="s0">have_hhmmss = 1</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(f&quot;expecting hh:mm:ss format, received: {ts}&quot;)</span>

            <span class="s0">unit, number = [], []</span>

        <span class="s0"># after the decimal point</span>
        <span class="s0">elif c == '.':</span>

            <span class="s0">if len(number) and current_unit is not None:</span>

                <span class="s0"># by definition we had something like</span>
                <span class="s0"># so we need to evaluate the final field from a</span>
                <span class="s0"># hh:mm:ss (so current_unit is 'm')</span>
                <span class="s0">if current_unit != 'm':</span>
                    <span class="s0">raise ValueError(&quot;expected hh:mm:ss format before .&quot;)</span>
                <span class="s0">m = 1000000000</span>
                <span class="s0">r = &lt;int64_t&gt;int(''.join(number)) * m</span>
                <span class="s0">result += timedelta_as_neg(r, neg)</span>
                <span class="s0">have_value = 1</span>
                <span class="s0">unit, number, frac = [], [], []</span>

            <span class="s0">have_dot = 1</span>

        <span class="s0"># unit</span>
        <span class="s0">else:</span>
            <span class="s0">unit.append(c)</span>
            <span class="s0">have_value = 1</span>
            <span class="s0">have_dot = 0</span>

    <span class="s0"># we had a dot, but we have a fractional</span>
    <span class="s0"># value since we have an unit</span>
    <span class="s0">if have_dot and len(unit):</span>
        <span class="s0">r = timedelta_from_spec(number, frac, unit)</span>
        <span class="s0">result += timedelta_as_neg(r, neg)</span>

    <span class="s0"># we have a dot as part of a regular format</span>
    <span class="s0"># e.g. hh:mm:ss.fffffff</span>
    <span class="s0">elif have_dot:</span>

        <span class="s0">if ((len(number) or len(frac)) and not len(unit)</span>
                <span class="s0">and current_unit is None):</span>
            <span class="s0">raise ValueError(&quot;no units specified&quot;)</span>

        <span class="s0">if len(frac) &gt; 0 and len(frac) &lt;= 3:</span>
            <span class="s0">m = 10**(3 -len(frac)) * 1000 * 1000</span>
        <span class="s0">elif len(frac) &gt; 3 and len(frac) &lt;= 6:</span>
            <span class="s0">m = 10**(6 -len(frac)) * 1000</span>
        <span class="s0">elif len(frac) &gt; 6 and len(frac) &lt;= 9:</span>
            <span class="s0">m = 10**(9 -len(frac))</span>
        <span class="s0">else:</span>
            <span class="s0">m = 1</span>
            <span class="s0">frac = frac[:9]</span>
        <span class="s0">r = &lt;int64_t&gt;int(''.join(frac)) * m</span>
        <span class="s0">result += timedelta_as_neg(r, neg)</span>

    <span class="s0"># we have a regular format</span>
    <span class="s0"># we must have seconds at this point (hence the unit is still 'm')</span>
    <span class="s0">elif current_unit is not None:</span>
        <span class="s0">if current_unit != 'm':</span>
            <span class="s0">raise ValueError(&quot;expected hh:mm:ss format&quot;)</span>
        <span class="s0">m = 1000000000</span>
        <span class="s0">r = &lt;int64_t&gt;int(''.join(number)) * m</span>
        <span class="s0">result += timedelta_as_neg(r, neg)</span>

    <span class="s0"># we have a last abbreviation</span>
    <span class="s0">elif len(unit):</span>
        <span class="s0">if len(number):</span>
            <span class="s0">r = timedelta_from_spec(number, frac, unit)</span>
            <span class="s0">result += timedelta_as_neg(r, neg)</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(&quot;unit abbreviation w/o a number&quot;)</span>

    <span class="s0"># we only have symbols and no numbers</span>
    <span class="s0">elif len(number) == 0:</span>
        <span class="s0">raise ValueError(&quot;symbols w/o a number&quot;)</span>

    <span class="s0"># treat as nanoseconds</span>
    <span class="s0"># but only if we don't have anything else</span>
    <span class="s0">else:</span>
        <span class="s0">if have_value:</span>
            <span class="s0">raise ValueError(&quot;have leftover units&quot;)</span>
        <span class="s0">if len(number):</span>
            <span class="s0">r = timedelta_from_spec(number, frac, 'ns')</span>
            <span class="s0">result += timedelta_as_neg(r, neg)</span>

    <span class="s0">return result</span>


<span class="s0">cdef inline int64_t timedelta_as_neg(int64_t value, bint neg):</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">value : int64_t of the timedelta value</span>
    <span class="s0">neg : bool if the a negative value</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if neg:</span>
        <span class="s0">return -value</span>
    <span class="s0">return value</span>


<span class="s0">cdef inline timedelta_from_spec(object number, object frac, object unit):</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">number : a list of number digits</span>
    <span class="s0">frac : a list of frac digits</span>
    <span class="s0">unit : a list of unit characters</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">str n</span>

    <span class="s0">try:</span>
        <span class="s0">unit = ''.join(unit)</span>

        <span class="s0">if unit in [&quot;M&quot;, &quot;Y&quot;, &quot;y&quot;]:</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;Units 'M', 'Y' and 'y' do not represent unambiguous &quot;</span>
                <span class="s0">&quot;timedelta values and will be removed in a future version.&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=2,</span>
            <span class="s0">)</span>

        <span class="s0">if unit == 'M':</span>
            <span class="s0"># To parse ISO 8601 string, 'M' should be treated as minute,</span>
            <span class="s0"># not month</span>
            <span class="s0">unit = 'm'</span>
        <span class="s0">unit = parse_timedelta_unit(unit)</span>
    <span class="s0">except KeyError:</span>
        <span class="s0">raise ValueError(f&quot;invalid abbreviation: {unit}&quot;)</span>

    <span class="s0">n = ''.join(number) + '.' + ''.join(frac)</span>
    <span class="s0">return cast_from_unit(float(n), unit)</span>


<span class="s0">cpdef inline str parse_timedelta_unit(str unit):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">unit : str or None</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">str</span>
        <span class="s0">Canonical unit string.</span>

    <span class="s0">Raises</span>
    <span class="s0">------</span>
    <span class="s0">ValueError : on non-parseable input</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if unit is None:</span>
        <span class="s0">return &quot;ns&quot;</span>
    <span class="s0">elif unit == &quot;M&quot;:</span>
        <span class="s0">return unit</span>
    <span class="s0">try:</span>
        <span class="s0">return timedelta_abbrevs[unit.lower()]</span>
    <span class="s0">except (KeyError, AttributeError):</span>
        <span class="s0">raise ValueError(f&quot;invalid unit abbreviation: {unit}&quot;)</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Timedelta ops utilities</span>

<span class="s0">cdef bint _validate_ops_compat(other):</span>
    <span class="s0"># return True if we are compat with operating</span>
    <span class="s0">if checknull_with_nat(other):</span>
        <span class="s0">return True</span>
    <span class="s0">elif is_any_td_scalar(other):</span>
        <span class="s0">return True</span>
    <span class="s0">elif isinstance(other, str):</span>
        <span class="s0">return True</span>
    <span class="s0">return False</span>


<span class="s0">def _op_unary_method(func, name):</span>
    <span class="s0">def f(self):</span>
        <span class="s0">return Timedelta(func(self.value), unit='ns')</span>
    <span class="s0">f.__name__ = name</span>
    <span class="s0">return f</span>


<span class="s0">def _binary_op_method_timedeltalike(op, name):</span>
    <span class="s0"># define a binary operation that only works if the other argument is</span>
    <span class="s0"># timedelta like or an array of timedeltalike</span>
    <span class="s0">def f(self, other):</span>
        <span class="s0">if other is NaT:</span>
            <span class="s0">return NaT</span>

        <span class="s0">elif is_datetime64_object(other) or (</span>
            <span class="s0">PyDateTime_Check(other) and not isinstance(other, ABCTimestamp)</span>
        <span class="s0">):</span>
            <span class="s0"># this case is for a datetime object that is specifically</span>
            <span class="s0"># *not* a Timestamp, as the Timestamp case will be</span>
            <span class="s0"># handled after `_validate_ops_compat` returns False below</span>
            <span class="s0">from pandas._libs.tslibs.timestamps import Timestamp</span>
            <span class="s0">return op(self, Timestamp(other))</span>
            <span class="s0"># We are implicitly requiring the canonical behavior to be</span>
            <span class="s0"># defined by Timestamp methods.</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0"># nd-array like</span>
            <span class="s0">if other.dtype.kind in ['m', 'M']:</span>
                <span class="s0">return op(self.to_timedelta64(), other)</span>
            <span class="s0">elif other.dtype.kind == 'O':</span>
                <span class="s0">return np.array([op(self, x) for x in other])</span>
            <span class="s0">else:</span>
                <span class="s0">return NotImplemented</span>

        <span class="s0">elif not _validate_ops_compat(other):</span>
            <span class="s0"># Includes any of our non-cython classes</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">try:</span>
            <span class="s0">other = Timedelta(other)</span>
        <span class="s0">except ValueError:</span>
            <span class="s0"># failed to parse as timedelta</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">if other is NaT:</span>
            <span class="s0"># e.g. if original other was timedelta64('NaT')</span>
            <span class="s0">return NaT</span>
        <span class="s0">return Timedelta(op(self.value, other.value), unit='ns')</span>

    <span class="s0">f.__name__ = name</span>
    <span class="s0">return f</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Timedelta Construction</span>

<span class="s0">cdef inline int64_t parse_iso_format_string(str ts) except? -1:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Extracts and cleanses the appropriate values from a match object with</span>
    <span class="s0">groups for each component of an ISO 8601 duration</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">ts: str</span>
        <span class="s0">ISO 8601 Duration formatted string</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ns: int64_t</span>
        <span class="s0">Precision in nanoseconds of matched ISO 8601 duration</span>

    <span class="s0">Raises</span>
    <span class="s0">------</span>
    <span class="s0">ValueError</span>
        <span class="s0">If ``ts`` cannot be parsed</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">unicode c</span>
        <span class="s0">int64_t result = 0, r</span>
        <span class="s0">int p = 0, sign = 1</span>
        <span class="s0">object dec_unit = 'ms', err_msg</span>
        <span class="s0">bint have_dot = 0, have_value = 0, neg = 0</span>
        <span class="s0">list number = [], unit = []</span>

    <span class="s0">err_msg = f&quot;Invalid ISO 8601 Duration format - {ts}&quot;</span>

    <span class="s0">if ts[0] == &quot;-&quot;:</span>
        <span class="s0">sign = -1</span>
        <span class="s0">ts = ts[1:]</span>

    <span class="s0">for c in ts:</span>
        <span class="s0"># number (ascii codes)</span>
        <span class="s0">if 48 &lt;= ord(c) &lt;= 57:</span>

            <span class="s0">have_value = 1</span>
            <span class="s0">if have_dot:</span>
                <span class="s0">if p == 3 and dec_unit != 'ns':</span>
                    <span class="s0">unit.append(dec_unit)</span>
                    <span class="s0">if dec_unit == 'ms':</span>
                        <span class="s0">dec_unit = 'us'</span>
                    <span class="s0">elif dec_unit == 'us':</span>
                        <span class="s0">dec_unit = 'ns'</span>
                    <span class="s0">p = 0</span>
                <span class="s0">p += 1</span>

            <span class="s0">if not len(unit):</span>
                <span class="s0">number.append(c)</span>
            <span class="s0">else:</span>
                <span class="s0">r = timedelta_from_spec(number, '0', unit)</span>
                <span class="s0">result += timedelta_as_neg(r, neg)</span>

                <span class="s0">neg = 0</span>
                <span class="s0">unit, number = [], [c]</span>
        <span class="s0">else:</span>
            <span class="s0">if c == 'P' or c == 'T':</span>
                <span class="s0">pass  # ignore marking characters P and T</span>
            <span class="s0">elif c == '-':</span>
                <span class="s0">if neg or have_value:</span>
                    <span class="s0">raise ValueError(err_msg)</span>
                <span class="s0">else:</span>
                    <span class="s0">neg = 1</span>
            <span class="s0">elif c == &quot;+&quot;:</span>
                <span class="s0">pass</span>
            <span class="s0">elif c in ['W', 'D', 'H', 'M']:</span>
                <span class="s0">if c in ['H', 'M'] and len(number) &gt; 2:</span>
                    <span class="s0">raise ValueError(err_msg)</span>
                <span class="s0">if c == 'M':</span>
                    <span class="s0">c = 'min'</span>
                <span class="s0">unit.append(c)</span>
                <span class="s0">r = timedelta_from_spec(number, '0', unit)</span>
                <span class="s0">result += timedelta_as_neg(r, neg)</span>

                <span class="s0">neg = 0</span>
                <span class="s0">unit, number = [], []</span>
            <span class="s0">elif c == '.':</span>
                <span class="s0"># append any seconds</span>
                <span class="s0">if len(number):</span>
                    <span class="s0">r = timedelta_from_spec(number, '0', 'S')</span>
                    <span class="s0">result += timedelta_as_neg(r, neg)</span>
                    <span class="s0">unit, number = [], []</span>
                <span class="s0">have_dot = 1</span>
            <span class="s0">elif c == 'S':</span>
                <span class="s0">if have_dot:  # ms, us, or ns</span>
                    <span class="s0">if not len(number) or p &gt; 3:</span>
                        <span class="s0">raise ValueError(err_msg)</span>
                    <span class="s0"># pad to 3 digits as required</span>
                    <span class="s0">pad = 3 - p</span>
                    <span class="s0">while pad &gt; 0:</span>
                        <span class="s0">number.append('0')</span>
                        <span class="s0">pad -= 1</span>

                    <span class="s0">r = timedelta_from_spec(number, '0', dec_unit)</span>
                    <span class="s0">result += timedelta_as_neg(r, neg)</span>
                <span class="s0">else:  # seconds</span>
                    <span class="s0">r = timedelta_from_spec(number, '0', 'S')</span>
                    <span class="s0">result += timedelta_as_neg(r, neg)</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(err_msg)</span>

    <span class="s0">if not have_value:</span>
        <span class="s0"># Received string only - never parsed any values</span>
        <span class="s0">raise ValueError(err_msg)</span>

    <span class="s0">return sign*result</span>


<span class="s0">cdef _to_py_int_float(v):</span>
    <span class="s0"># Note: This used to be defined inside Timedelta.__new__</span>
    <span class="s0"># but cython will not allow `cdef` functions to be defined dynamically.</span>
    <span class="s0">if is_integer_object(v):</span>
        <span class="s0">return int(v)</span>
    <span class="s0">elif is_float_object(v):</span>
        <span class="s0">return float(v)</span>
    <span class="s0">raise TypeError(f&quot;Invalid type {type(v)}. Must be int or float.&quot;)</span>


<span class="s0"># Similar to Timestamp/datetime, this is a construction requirement for</span>
<span class="s0"># timedeltas that we need to do object instantiation in python. This will</span>
<span class="s0"># serve as a C extension type that shadows the Python class, where we do any</span>
<span class="s0"># heavy lifting.</span>
<span class="s0">cdef class _Timedelta(timedelta):</span>
    <span class="s0"># cdef readonly:</span>
    <span class="s0">#    int64_t value      # nanoseconds</span>
    <span class="s0">#    object freq        # frequency reference</span>
    <span class="s0">#    bint is_populated  # are my components populated</span>
    <span class="s0">#    int64_t _d, _h, _m, _s, _ms, _us, _ns</span>

    <span class="s0"># higher than np.ndarray and np.matrix</span>
    <span class="s0">__array_priority__ = 100</span>

    <span class="s0">def __hash__(_Timedelta self):</span>
        <span class="s0">if self._has_ns():</span>
            <span class="s0">return hash(self.value)</span>
        <span class="s0">else:</span>
            <span class="s0">return timedelta.__hash__(self)</span>

    <span class="s0">def __richcmp__(_Timedelta self, object other, int op):</span>
        <span class="s0">cdef:</span>
            <span class="s0">_Timedelta ots</span>
            <span class="s0">int ndim</span>

        <span class="s0">if isinstance(other, _Timedelta):</span>
            <span class="s0">ots = other</span>
        <span class="s0">elif is_any_td_scalar(other):</span>
            <span class="s0">ots = Timedelta(other)</span>
            <span class="s0"># TODO: watch out for overflows</span>

        <span class="s0">elif other is NaT:</span>
            <span class="s0">return op == Py_NE</span>

        <span class="s0">elif util.is_array(other):</span>
            <span class="s0"># TODO: watch out for zero-dim</span>
            <span class="s0">if other.dtype.kind == &quot;m&quot;:</span>
                <span class="s0">return PyObject_RichCompare(self.asm8, other, op)</span>
            <span class="s0">elif other.dtype.kind == &quot;O&quot;:</span>
                <span class="s0"># operate element-wise</span>
                <span class="s0">return np.array(</span>
                    <span class="s0">[PyObject_RichCompare(self, x, op) for x in other],</span>
                    <span class="s0">dtype=bool,</span>
                <span class="s0">)</span>
            <span class="s0">if op == Py_EQ:</span>
                <span class="s0">return np.zeros(other.shape, dtype=bool)</span>
            <span class="s0">elif op == Py_NE:</span>
                <span class="s0">return np.ones(other.shape, dtype=bool)</span>
            <span class="s0">return NotImplemented  # let other raise TypeError</span>

        <span class="s0">else:</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">return cmp_scalar(self.value, ots.value, op)</span>

    <span class="s0">cpdef bint _has_ns(self):</span>
        <span class="s0">return self.value % 1000 != 0</span>

    <span class="s0">def _ensure_components(_Timedelta self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">compute the components</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.is_populated:</span>
            <span class="s0">return</span>

        <span class="s0">cdef:</span>
            <span class="s0">pandas_timedeltastruct tds</span>

        <span class="s0">td64_to_tdstruct(self.value, &amp;tds)</span>
        <span class="s0">self._d = tds.days</span>
        <span class="s0">self._h = tds.hrs</span>
        <span class="s0">self._m = tds.min</span>
        <span class="s0">self._s = tds.sec</span>
        <span class="s0">self._ms = tds.ms</span>
        <span class="s0">self._us = tds.us</span>
        <span class="s0">self._ns = tds.ns</span>
        <span class="s0">self._seconds = tds.seconds</span>
        <span class="s0">self._microseconds = tds.microseconds</span>

        <span class="s0">self.is_populated = 1</span>

    <span class="s0">cpdef timedelta to_pytimedelta(_Timedelta self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert a pandas Timedelta object into a python ``datetime.timedelta`` object.</span>

        <span class="s0">Timedelta objects are internally saved as numpy datetime64[ns] dtype.</span>
        <span class="s0">Use to_pytimedelta() to convert to object dtype.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">datetime.timedelta or numpy.array of datetime.timedelta</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">to_timedelta : Convert argument to Timedelta type.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">Any nanosecond resolution will be lost.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return timedelta(microseconds=int(self.value) / 1000)</span>

    <span class="s0">def to_timedelta64(self) -&gt; np.timedelta64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a numpy.timedelta64 object with 'ns' precision.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return np.timedelta64(self.value, 'ns')</span>

    <span class="s0">def to_numpy(self, dtype=None, copy=False) -&gt; np.timedelta64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert the Timedelta to a NumPy timedelta64.</span>

        <span class="s0">.. versionadded:: 0.25.0</span>

        <span class="s0">This is an alias method for `Timedelta.to_timedelta64()`. The dtype and</span>
        <span class="s0">copy parameters are available here only for compatibility. Their values</span>
        <span class="s0">will not affect the return value.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">numpy.timedelta64</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Series.to_numpy : Similar method for Series.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if dtype is not None or copy is not False:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;Timedelta.to_numpy dtype and copy arguments are ignored&quot;</span>
            <span class="s0">)</span>
        <span class="s0">return self.to_timedelta64()</span>

    <span class="s0">def view(self, dtype):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Array view compatibility.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return np.timedelta64(self.value).view(dtype)</span>

    <span class="s0">@property</span>
    <span class="s0">def components(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a components namedtuple-like.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._ensure_components()</span>
        <span class="s0"># return the named tuple</span>
        <span class="s0">return Components(self._d, self._h, self._m, self._s,</span>
                          <span class="s0">self._ms, self._us, self._ns)</span>

    <span class="s0">@property</span>
    <span class="s0">def delta(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the timedelta in nanoseconds (ns), for internal compatibility.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">Timedelta in nanoseconds.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('1 days 42 ns')</span>
        <span class="s0">&gt;&gt;&gt; td.delta</span>
        <span class="s0">86400000000042</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('3 s')</span>
        <span class="s0">&gt;&gt;&gt; td.delta</span>
        <span class="s0">3000000000</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('3 ms 5 us')</span>
        <span class="s0">&gt;&gt;&gt; td.delta</span>
        <span class="s0">3005000</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta(42, unit='ns')</span>
        <span class="s0">&gt;&gt;&gt; td.delta</span>
        <span class="s0">42</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.value</span>

    <span class="s0">@property</span>
    <span class="s0">def asm8(self) -&gt; np.timedelta64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a numpy timedelta64 array scalar view.</span>

        <span class="s0">Provides access to the array scalar view (i.e. a combination of the</span>
        <span class="s0">value and the units) associated with the numpy.timedelta64().view(),</span>
        <span class="s0">including a 64-bit integer representation of the timedelta in</span>
        <span class="s0">nanoseconds (Python int compatible).</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">numpy timedelta64 array scalar view</span>
            <span class="s0">Array scalar view of the timedelta in nanoseconds.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('1 days 2 min 3 us 42 ns')</span>
        <span class="s0">&gt;&gt;&gt; td.asm8</span>
        <span class="s0">numpy.timedelta64(86520000003042,'ns')</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('2 min 3 s')</span>
        <span class="s0">&gt;&gt;&gt; td.asm8</span>
        <span class="s0">numpy.timedelta64(123000000000,'ns')</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('3 ms 5 us')</span>
        <span class="s0">&gt;&gt;&gt; td.asm8</span>
        <span class="s0">numpy.timedelta64(3005000,'ns')</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta(42, unit='ns')</span>
        <span class="s0">&gt;&gt;&gt; td.asm8</span>
        <span class="s0">numpy.timedelta64(42,'ns')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return np.int64(self.value).view('m8[ns]')</span>

    <span class="s0">@property</span>
    <span class="s0">def resolution_string(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a string representing the lowest timedelta resolution.</span>

        <span class="s0">Each timedelta has a defined resolution that represents the lowest OR</span>
        <span class="s0">most granular level of precision. Each level of resolution is</span>
        <span class="s0">represented by a short string as defined below:</span>

        <span class="s0">Resolution:     Return value</span>

        <span class="s0">* Days:         'D'</span>
        <span class="s0">* Hours:        'H'</span>
        <span class="s0">* Minutes:      'T'</span>
        <span class="s0">* Seconds:      'S'</span>
        <span class="s0">* Milliseconds: 'L'</span>
        <span class="s0">* Microseconds: 'U'</span>
        <span class="s0">* Nanoseconds:  'N'</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>
            <span class="s0">Timedelta resolution.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('1 days 2 min 3 us 42 ns')</span>
        <span class="s0">&gt;&gt;&gt; td.resolution_string</span>
        <span class="s0">'N'</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('1 days 2 min 3 us')</span>
        <span class="s0">&gt;&gt;&gt; td.resolution_string</span>
        <span class="s0">'U'</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('2 min 3 s')</span>
        <span class="s0">&gt;&gt;&gt; td.resolution_string</span>
        <span class="s0">'S'</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta(36, unit='us')</span>
        <span class="s0">&gt;&gt;&gt; td.resolution_string</span>
        <span class="s0">'U'</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._ensure_components()</span>
        <span class="s0">if self._ns:</span>
            <span class="s0">return &quot;N&quot;</span>
        <span class="s0">elif self._us:</span>
            <span class="s0">return &quot;U&quot;</span>
        <span class="s0">elif self._ms:</span>
            <span class="s0">return &quot;L&quot;</span>
        <span class="s0">elif self._s:</span>
            <span class="s0">return &quot;S&quot;</span>
        <span class="s0">elif self._m:</span>
            <span class="s0">return &quot;T&quot;</span>
        <span class="s0">elif self._h:</span>
            <span class="s0">return &quot;H&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">return &quot;D&quot;</span>

    <span class="s0">@property</span>
    <span class="s0">def nanoseconds(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the number of nanoseconds (n), where 0 &lt;= n &lt; 1 microsecond.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">Number of nanoseconds.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Timedelta.components : Return all attributes with assigned values</span>
            <span class="s0">(i.e. days, hours, minutes, seconds, milliseconds, microseconds,</span>
            <span class="s0">nanoseconds).</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">**Using string input**</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta('1 days 2 min 3 us 42 ns')</span>

        <span class="s0">&gt;&gt;&gt; td.nanoseconds</span>
        <span class="s0">42</span>

        <span class="s0">**Using integer input**</span>

        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta(42, unit='ns')</span>
        <span class="s0">&gt;&gt;&gt; td.nanoseconds</span>
        <span class="s0">42</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._ensure_components()</span>
        <span class="s0">return self._ns</span>

    <span class="s0">def _repr_base(self, format=None) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">format : None|all|sub_day|long</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">converted : string of a Timedelta</span>

        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef object sign, seconds_pretty, subs, fmt, comp_dict</span>

        <span class="s0">self._ensure_components()</span>

        <span class="s0">if self._d &lt; 0:</span>
            <span class="s0">sign = &quot; +&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">sign = &quot; &quot;</span>

        <span class="s0">if format == 'all':</span>
            <span class="s0">fmt = (&quot;{days} days{sign}{hours:02}:{minutes:02}:{seconds:02}.&quot;</span>
                   <span class="s0">&quot;{milliseconds:03}{microseconds:03}{nanoseconds:03}&quot;)</span>
        <span class="s0">else:</span>
            <span class="s0"># if we have a partial day</span>
            <span class="s0">subs = (self._h or self._m or self._s or</span>
                    <span class="s0">self._ms or self._us or self._ns)</span>

            <span class="s0">if self._ms or self._us or self._ns:</span>
                <span class="s0">seconds_fmt = &quot;{seconds:02}.{milliseconds:03}{microseconds:03}&quot;</span>
                <span class="s0">if self._ns:</span>
                    <span class="s0"># GH#9309</span>
                    <span class="s0">seconds_fmt += &quot;{nanoseconds:03}&quot;</span>
            <span class="s0">else:</span>
                <span class="s0">seconds_fmt = &quot;{seconds:02}&quot;</span>

            <span class="s0">if format == 'sub_day' and not self._d:</span>
                <span class="s0">fmt = &quot;{hours:02}:{minutes:02}:&quot; + seconds_fmt</span>
            <span class="s0">elif subs or format == 'long':</span>
                <span class="s0">fmt = &quot;{days} days{sign}{hours:02}:{minutes:02}:&quot; + seconds_fmt</span>
            <span class="s0">else:</span>
                <span class="s0">fmt = &quot;{days} days&quot;</span>

        <span class="s0">comp_dict = self.components._asdict()</span>
        <span class="s0">comp_dict['sign'] = sign</span>

        <span class="s0">return fmt.format(**comp_dict)</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">repr_based = self._repr_base(format='long')</span>
        <span class="s0">return f&quot;Timedelta('{repr_based}')&quot;</span>

    <span class="s0">def __str__(self) -&gt; str:</span>
        <span class="s0">return self._repr_base(format='long')</span>

    <span class="s0">def __bool__(self) -&gt; bool:</span>
        <span class="s0">return self.value != 0</span>

    <span class="s0">def isoformat(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Format Timedelta as ISO 8601 Duration like</span>
        <span class="s0">``P[n]Y[n]M[n]DT[n]H[n]M[n]S``, where the ``[n]`` s are replaced by the</span>
        <span class="s0">values. See https://en.wikipedia.org/wiki/ISO_8601#Durations.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Timestamp.isoformat : Function is used to convert the given</span>
            <span class="s0">Timestamp object into the ISO format.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">The longest component is days, whose value may be larger than</span>
        <span class="s0">365.</span>
        <span class="s0">Every component is always included, even if its value is 0.</span>
        <span class="s0">Pandas uses nanosecond precision, so up to 9 decimal places may</span>
        <span class="s0">be included in the seconds component.</span>
        <span class="s0">Trailing 0's are removed from the seconds component after the decimal.</span>
        <span class="s0">We do not 0 pad components, so it's `...T5H...`, not `...T05H...`</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; td = pd.Timedelta(days=6, minutes=50, seconds=3,</span>
        <span class="s0">...                   milliseconds=10, microseconds=10, nanoseconds=12)</span>

        <span class="s0">&gt;&gt;&gt; td.isoformat()</span>
        <span class="s0">'P6DT0H50M3.010010012S'</span>
        <span class="s0">&gt;&gt;&gt; pd.Timedelta(hours=1, seconds=10).isoformat()</span>
        <span class="s0">'P0DT1H0M10S'</span>
        <span class="s0">&gt;&gt;&gt; pd.Timedelta(days=500.5).isoformat()</span>
        <span class="s0">'P500DT12H0M0S'</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">components = self.components</span>
        <span class="s0">seconds = (f'{components.seconds}.'</span>
                   <span class="s0">f'{components.milliseconds:0&gt;3}'</span>
                   <span class="s0">f'{components.microseconds:0&gt;3}'</span>
                   <span class="s0">f'{components.nanoseconds:0&gt;3}')</span>
        <span class="s0"># Trim unnecessary 0s, 1.000000000 -&gt; 1</span>
        <span class="s0">seconds = seconds.rstrip('0').rstrip('.')</span>
        <span class="s0">tpl = (f'P{components.days}DT{components.hours}'</span>
               <span class="s0">f'H{components.minutes}M{seconds}S')</span>
        <span class="s0">return tpl</span>


<span class="s0"># Python front end to C extension type _Timedelta</span>
<span class="s0"># This serves as the box for timedelta64</span>

<span class="s0">class Timedelta(_Timedelta):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Represents a duration, the difference between two dates or times.</span>

    <span class="s0">Timedelta is the pandas equivalent of python's ``datetime.timedelta``</span>
    <span class="s0">and is interchangeable with it in most cases.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">value : Timedelta, timedelta, np.timedelta64, str, or int</span>
    <span class="s0">unit : str, default 'ns'</span>
        <span class="s0">Denote the unit of the input, if input is an integer.</span>

        <span class="s0">Possible values:</span>

        <span class="s0">* 'W', 'D', 'T', 'S', 'L', 'U', or 'N'</span>
        <span class="s0">* 'days' or 'day'</span>
        <span class="s0">* 'hours', 'hour', 'hr', or 'h'</span>
        <span class="s0">* 'minutes', 'minute', 'min', or 'm'</span>
        <span class="s0">* 'seconds', 'second', or 'sec'</span>
        <span class="s0">* 'milliseconds', 'millisecond', 'millis', or 'milli'</span>
        <span class="s0">* 'microseconds', 'microsecond', 'micros', or 'micro'</span>
        <span class="s0">* 'nanoseconds', 'nanosecond', 'nanos', 'nano', or 'ns'.</span>

    <span class="s0">**kwargs</span>
        <span class="s0">Available kwargs: {days, seconds, microseconds,</span>
        <span class="s0">milliseconds, minutes, hours, weeks}.</span>
        <span class="s0">Values for construction in compat with datetime.timedelta.</span>
        <span class="s0">Numpy ints and floats will be coerced to python ints and floats.</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">The constructor may take in either both values of value and unit or</span>
    <span class="s0">kwargs as above. Either one of them must be used during initialization</span>

    <span class="s0">The ``.value`` attribute is always in ns.</span>

    <span class="s0">If the precision is higher than nanoseconds, the precision of the duration is</span>
    <span class="s0">truncated to nanoseconds.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">Here we initialize Timedelta object with both value and unit</span>

    <span class="s0">&gt;&gt;&gt; td = pd.Timedelta(1, &quot;d&quot;)</span>
    <span class="s0">&gt;&gt;&gt; td</span>
    <span class="s0">Timedelta('1 days 00:00:00')</span>

    <span class="s0">Here we initialize the Timedelta object with kwargs</span>

    <span class="s0">&gt;&gt;&gt; td2 = pd.Timedelta(days=1)</span>
    <span class="s0">&gt;&gt;&gt; td2</span>
    <span class="s0">Timedelta('1 days 00:00:00')</span>

    <span class="s0">We see that either way we get the same result</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_req_any_kwargs_new = {&quot;weeks&quot;, &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, &quot;seconds&quot;,</span>
                           <span class="s0">&quot;milliseconds&quot;, &quot;microseconds&quot;, &quot;nanoseconds&quot;}</span>

    <span class="s0">def __new__(cls, object value=_no_input, unit=None, **kwargs):</span>
        <span class="s0">cdef _Timedelta td_base</span>

        <span class="s0">if value is _no_input:</span>
            <span class="s0">if not len(kwargs):</span>
                <span class="s0">raise ValueError(&quot;cannot construct a Timedelta without a &quot;</span>
                                 <span class="s0">&quot;value/unit or descriptive keywords &quot;</span>
                                 <span class="s0">&quot;(days,seconds....)&quot;)</span>

            <span class="s0">kwargs = {key: _to_py_int_float(kwargs[key]) for key in kwargs}</span>

            <span class="s0">unsupported_kwargs = set(kwargs)</span>
            <span class="s0">unsupported_kwargs.difference_update(cls._req_any_kwargs_new)</span>
            <span class="s0">if unsupported_kwargs or not cls._req_any_kwargs_new.intersection(kwargs):</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;cannot construct a Timedelta from the passed arguments, &quot;</span>
                    <span class="s0">&quot;allowed keywords are &quot;</span>
                    <span class="s0">&quot;[weeks, days, hours, minutes, seconds, &quot;</span>
                    <span class="s0">&quot;milliseconds, microseconds, nanoseconds]&quot;</span>
                <span class="s0">)</span>

            <span class="s0"># GH43764, convert any input to nanoseconds first and then</span>
            <span class="s0"># create the timestamp. This ensures that any potential</span>
            <span class="s0"># nanosecond contributions from kwargs parsed as floats</span>
            <span class="s0"># are taken into consideration.</span>
            <span class="s0">seconds = int((</span>
                <span class="s0">(</span>
                    <span class="s0">(kwargs.get('days', 0) + kwargs.get('weeks', 0) * 7) * 24</span>
                    <span class="s0">+ kwargs.get('hours', 0)</span>
                <span class="s0">) * 3600</span>
                <span class="s0">+ kwargs.get('minutes', 0) * 60</span>
                <span class="s0">+ kwargs.get('seconds', 0)</span>
                <span class="s0">) * 1_000_000_000</span>
            <span class="s0">)</span>

            <span class="s0">value = np.timedelta64(</span>
                <span class="s0">int(kwargs.get('nanoseconds', 0))</span>
                <span class="s0">+ int(kwargs.get('microseconds', 0) * 1_000)</span>
                <span class="s0">+ int(kwargs.get('milliseconds', 0) * 1_000_000)</span>
                <span class="s0">+ seconds</span>
            <span class="s0">)</span>

        <span class="s0">if unit in {'Y', 'y', 'M'}:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;Units 'M', 'Y', and 'y' are no longer supported, as they do not &quot;</span>
                <span class="s0">&quot;represent unambiguous timedelta values durations.&quot;</span>
            <span class="s0">)</span>

        <span class="s0"># GH 30543 if pd.Timedelta already passed, return it</span>
        <span class="s0"># check that only value is passed</span>
        <span class="s0">if isinstance(value, _Timedelta) and unit is None and len(kwargs) == 0:</span>
            <span class="s0">return value</span>
        <span class="s0">elif isinstance(value, _Timedelta):</span>
            <span class="s0">value = value.value</span>
        <span class="s0">elif isinstance(value, str):</span>
            <span class="s0">if unit is not None:</span>
                <span class="s0">raise ValueError(&quot;unit must not be specified if the value is a str&quot;)</span>
            <span class="s0">if (len(value) &gt; 0 and value[0] == 'P') or (</span>
                <span class="s0">len(value) &gt; 1 and value[:2] == '-P'</span>
            <span class="s0">):</span>
                <span class="s0">value = parse_iso_format_string(value)</span>
            <span class="s0">else:</span>
                <span class="s0">value = parse_timedelta_string(value)</span>
            <span class="s0">value = np.timedelta64(value)</span>
        <span class="s0">elif PyDelta_Check(value):</span>
            <span class="s0">value = convert_to_timedelta64(value, 'ns')</span>
        <span class="s0">elif is_timedelta64_object(value):</span>
            <span class="s0">if unit is not None:</span>
                <span class="s0">value = value.astype(f'timedelta64[{unit}]')</span>
            <span class="s0">value = ensure_td64ns(value)</span>
        <span class="s0">elif is_tick_object(value):</span>
            <span class="s0">value = np.timedelta64(value.nanos, 'ns')</span>
        <span class="s0">elif is_integer_object(value) or is_float_object(value):</span>
            <span class="s0"># unit=None is de-facto 'ns'</span>
            <span class="s0">unit = parse_timedelta_unit(unit)</span>
            <span class="s0">value = convert_to_timedelta64(value, unit)</span>
        <span class="s0">elif checknull_with_nat(value):</span>
            <span class="s0">return NaT</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;Value must be Timedelta, string, integer, &quot;</span>
                <span class="s0">f&quot;float, timedelta or convertible, not {type(value).__name__}&quot;</span>
            <span class="s0">)</span>

        <span class="s0">if is_timedelta64_object(value):</span>
            <span class="s0">value = value.view('i8')</span>

        <span class="s0"># nat</span>
        <span class="s0">if value == NPY_NAT:</span>
            <span class="s0">return NaT</span>

        <span class="s0"># make timedelta happy</span>
        <span class="s0">td_base = _Timedelta.__new__(cls, microseconds=int(value) // 1000)</span>
        <span class="s0">td_base.value = value</span>
        <span class="s0">td_base.is_populated = 0</span>
        <span class="s0">return td_base</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">(value) = state</span>
        <span class="s0">self.value = value</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">object_state = self.value,</span>
        <span class="s0">return (Timedelta, object_state)</span>

    <span class="s0">@cython.cdivision(True)</span>
    <span class="s0">def _round(self, freq, mode):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t result, unit, remainder</span>
            <span class="s0">ndarray[int64_t] arr</span>

        <span class="s0">from pandas._libs.tslibs.offsets import to_offset</span>
        <span class="s0">unit = to_offset(freq).nanos</span>

        <span class="s0">arr = np.array([self.value], dtype=&quot;i8&quot;)</span>
        <span class="s0">result = round_nsint64(arr, mode, unit)[0]</span>
        <span class="s0">return Timedelta(result, unit=&quot;ns&quot;)</span>

    <span class="s0">def round(self, freq):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Round the Timedelta to the specified resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the rounding resolution.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">a new Timedelta rounded to the given resolution of `freq`</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._round(freq, RoundTo.NEAREST_HALF_EVEN)</span>

    <span class="s0">def floor(self, freq):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a new Timedelta floored to this resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the flooring resolution.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._round(freq, RoundTo.MINUS_INFTY)</span>

    <span class="s0">def ceil(self, freq):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a new Timedelta ceiled to this resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the ceiling resolution.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._round(freq, RoundTo.PLUS_INFTY)</span>

    <span class="s0"># ----------------------------------------------------------------</span>
    <span class="s0"># Arithmetic Methods</span>
    <span class="s0"># TODO: Can some of these be defined in the cython class?</span>

    <span class="s0">__neg__ = _op_unary_method(lambda x: -x, '__neg__')</span>
    <span class="s0">__pos__ = _op_unary_method(lambda x: x, '__pos__')</span>
    <span class="s0">__abs__ = _op_unary_method(lambda x: abs(x), '__abs__')</span>

    <span class="s0">__add__ = _binary_op_method_timedeltalike(lambda x, y: x + y, '__add__')</span>
    <span class="s0">__radd__ = _binary_op_method_timedeltalike(lambda x, y: x + y, '__radd__')</span>
    <span class="s0">__sub__ = _binary_op_method_timedeltalike(lambda x, y: x - y, '__sub__')</span>
    <span class="s0">__rsub__ = _binary_op_method_timedeltalike(lambda x, y: y - x, '__rsub__')</span>

    <span class="s0">def __mul__(self, other):</span>
        <span class="s0">if is_integer_object(other) or is_float_object(other):</span>
            <span class="s0">return Timedelta(other * self.value, unit='ns')</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0"># ndarray-like</span>
            <span class="s0">return other * self.to_timedelta64()</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">__rmul__ = __mul__</span>

    <span class="s0">def __truediv__(self, other):</span>
        <span class="s0">if _should_cast_to_timedelta(other):</span>
            <span class="s0"># We interpret NaT as timedelta64(&quot;NaT&quot;)</span>
            <span class="s0">other = Timedelta(other)</span>
            <span class="s0">if other is NaT:</span>
                <span class="s0">return np.nan</span>
            <span class="s0">return self.value / float(other.value)</span>

        <span class="s0">elif is_integer_object(other) or is_float_object(other):</span>
            <span class="s0"># integers or floats</span>
            <span class="s0">return Timedelta(self.value / other, unit='ns')</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0">return self.to_timedelta64() / other</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __rtruediv__(self, other):</span>
        <span class="s0">if _should_cast_to_timedelta(other):</span>
            <span class="s0"># We interpret NaT as timedelta64(&quot;NaT&quot;)</span>
            <span class="s0">other = Timedelta(other)</span>
            <span class="s0">if other is NaT:</span>
                <span class="s0">return np.nan</span>
            <span class="s0">return float(other.value) / self.value</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0">if other.dtype.kind == &quot;O&quot;:</span>
                <span class="s0"># GH#31869</span>
                <span class="s0">return np.array([x / self for x in other])</span>
            <span class="s0">return other / self.to_timedelta64()</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __floordiv__(self, other):</span>
        <span class="s0"># numpy does not implement floordiv for timedelta64 dtype, so we cannot</span>
        <span class="s0"># just defer</span>
        <span class="s0">if _should_cast_to_timedelta(other):</span>
            <span class="s0"># We interpret NaT as timedelta64(&quot;NaT&quot;)</span>
            <span class="s0">other = Timedelta(other)</span>
            <span class="s0">if other is NaT:</span>
                <span class="s0">return np.nan</span>
            <span class="s0">return self.value // other.value</span>

        <span class="s0">elif is_integer_object(other) or is_float_object(other):</span>
            <span class="s0">return Timedelta(self.value // other, unit='ns')</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0">if other.dtype.kind == 'm':</span>
                <span class="s0"># also timedelta-like</span>
                <span class="s0">return _broadcast_floordiv_td64(self.value, other, _floordiv)</span>
            <span class="s0">elif other.dtype.kind in ['i', 'u', 'f']:</span>
                <span class="s0">if other.ndim == 0:</span>
                    <span class="s0">return Timedelta(self.value // other)</span>
                <span class="s0">else:</span>
                    <span class="s0">return self.to_timedelta64() // other</span>

            <span class="s0">raise TypeError(f'Invalid dtype {other.dtype} for __floordiv__')</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __rfloordiv__(self, other):</span>
        <span class="s0"># numpy does not implement floordiv for timedelta64 dtype, so we cannot</span>
        <span class="s0"># just defer</span>
        <span class="s0">if _should_cast_to_timedelta(other):</span>
            <span class="s0"># We interpret NaT as timedelta64(&quot;NaT&quot;)</span>
            <span class="s0">other = Timedelta(other)</span>
            <span class="s0">if other is NaT:</span>
                <span class="s0">return np.nan</span>
            <span class="s0">return other.value // self.value</span>

        <span class="s0">elif is_array(other):</span>
            <span class="s0">if other.dtype.kind == 'm':</span>
                <span class="s0"># also timedelta-like</span>
                <span class="s0">return _broadcast_floordiv_td64(self.value, other, _rfloordiv)</span>

            <span class="s0"># Includes integer array // Timedelta, disallowed in GH#19761</span>
            <span class="s0">raise TypeError(f'Invalid dtype {other.dtype} for __floordiv__')</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __mod__(self, other):</span>
        <span class="s0"># Naive implementation, room for optimization</span>
        <span class="s0">return self.__divmod__(other)[1]</span>

    <span class="s0">def __rmod__(self, other):</span>
        <span class="s0"># Naive implementation, room for optimization</span>
        <span class="s0">return self.__rdivmod__(other)[1]</span>

    <span class="s0">def __divmod__(self, other):</span>
        <span class="s0"># Naive implementation, room for optimization</span>
        <span class="s0">div = self // other</span>
        <span class="s0">return div, self - div * other</span>

    <span class="s0">def __rdivmod__(self, other):</span>
        <span class="s0"># Naive implementation, room for optimization</span>
        <span class="s0">div = other // self</span>
        <span class="s0">return div, other - div * self</span>


<span class="s0">cdef bint is_any_td_scalar(object obj):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Cython equivalent for `isinstance(obj, (timedelta, np.timedelta64, Tick))`</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">obj : object</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return (</span>
        <span class="s0">PyDelta_Check(obj) or is_timedelta64_object(obj) or is_tick_object(obj)</span>
    <span class="s0">)</span>


<span class="s0">cdef bint _should_cast_to_timedelta(object obj):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Should we treat this object as a Timedelta for the purpose of a binary op</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return (</span>
        <span class="s0">is_any_td_scalar(obj) or obj is None or obj is NaT or isinstance(obj, str)</span>
    <span class="s0">)</span>


<span class="s0">cdef _floordiv(int64_t value, right):</span>
    <span class="s0">return value // right</span>


<span class="s0">cdef _rfloordiv(int64_t value, right):</span>
    <span class="s0"># analogous to referencing operator.div, but there is no operator.rfloordiv</span>
    <span class="s0">return right // value</span>


<span class="s0">cdef _broadcast_floordiv_td64(</span>
    <span class="s0">int64_t value,</span>
    <span class="s0">ndarray other,</span>
    <span class="s0">object (*operation)(int64_t value, object right)</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Boilerplate code shared by Timedelta.__floordiv__ and</span>
    <span class="s0">Timedelta.__rfloordiv__ because np.timedelta64 does not implement these.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">value : int64_t; `self.value` from a Timedelta object</span>
    <span class="s0">other : object</span>
    <span class="s0">operation : function, either _floordiv or _rfloordiv</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">result : varies based on `other`</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># assumes other.dtype.kind == 'm', i.e. other is timedelta-like</span>

    <span class="s0"># We need to watch out for np.timedelta64('NaT').</span>
    <span class="s0">mask = other.view('i8') == NPY_NAT</span>

    <span class="s0">if other.ndim == 0:</span>
        <span class="s0">if mask:</span>
            <span class="s0">return np.nan</span>

        <span class="s0">return operation(value, other.astype('m8[ns]').astype('i8'))</span>

    <span class="s0">else:</span>
        <span class="s0">res = operation(value, other.astype('m8[ns]').astype('i8'))</span>

        <span class="s0">if mask.any():</span>
            <span class="s0">res = res.astype('f8')</span>
            <span class="s0">res[mask] = np.nan</span>
        <span class="s0">return res</span>


<span class="s0"># resolution in ns</span>
<span class="s0">Timedelta.min = Timedelta(np.iinfo(np.int64).min + 1)</span>
<span class="s0">Timedelta.max = Timedelta(np.iinfo(np.int64).max)</span>
<span class="s0">Timedelta.resolution = Timedelta(nanoseconds=1)</span>
</pre>
</body>
</html>