<html>
<head>
<title>readers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
readers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Module contains tools for processing files into DataFrames or other objects 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">fill</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IO</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">NamedTuple</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">pandas._libs.lib </span><span class="s2">as </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.parsers </span><span class="s2">import </span><span class="s1">STR_NA_VALUES</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">CompressionOptions</span><span class="s2">,</span>
    <span class="s1">CSVEngine</span><span class="s2">,</span>
    <span class="s1">DtypeArg</span><span class="s2">,</span>
    <span class="s1">FilePath</span><span class="s2">,</span>
    <span class="s1">ReadCsvBuffer</span><span class="s2">,</span>
    <span class="s1">StorageOptions</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">AbstractMethodError</span><span class="s2">,</span>
    <span class="s1">ParserWarning</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s2">,</span>
    <span class="s1">deprecate_nonkeyword_arguments</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>
<span class="s2">from </span><span class="s1">pandas.util._validators </span><span class="s2">import </span><span class="s1">validate_bool_kwarg</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_file_like</span><span class="s2">,</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.frame </span><span class="s2">import </span><span class="s1">DataFrame</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">RangeIndex</span>
<span class="s2">from </span><span class="s1">pandas.core.shared_docs </span><span class="s2">import </span><span class="s1">_shared_docs</span>

<span class="s2">from </span><span class="s1">pandas.io.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IOHandles</span><span class="s2">,</span>
    <span class="s1">get_handle</span><span class="s2">,</span>
    <span class="s1">validate_header_arg</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.io.parsers.arrow_parser_wrapper </span><span class="s2">import </span><span class="s1">ArrowParserWrapper</span>
<span class="s2">from </span><span class="s1">pandas.io.parsers.base_parser </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ParserBase</span><span class="s2">,</span>
    <span class="s1">is_index_col</span><span class="s2">,</span>
    <span class="s1">parser_defaults</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.io.parsers.c_parser_wrapper </span><span class="s2">import </span><span class="s1">CParserWrapper</span>
<span class="s2">from </span><span class="s1">pandas.io.parsers.python_parser </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FixedWidthFieldParser</span><span class="s2">,</span>
    <span class="s1">PythonParser</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">_doc_read_csv_and_table = (</span>
    <span class="s3">r&quot;&quot;&quot; 
{summary} 
 
Also supports optionally iterating or breaking of the file 
into chunks. 
 
Additional help can be found in the online docs for 
`IO Tools &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html&gt;`_. 
 
Parameters 
---------- 
filepath_or_buffer : str, path object or file-like object 
    Any valid string path is acceptable. The string could be a URL. Valid 
    URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is 
    expected. A local file could be: file://localhost/path/to/table.csv. 
 
    If you want to pass in a path object, pandas accepts any ``os.PathLike``. 
 
    By file-like object, we refer to objects with a ``read()`` method, such as 
    a file handle (e.g. via builtin ``open`` function) or ``StringIO``. 
sep : str, default {_default_sep} 
    Delimiter to use. If sep is None, the C engine cannot automatically detect 
    the separator, but the Python parsing engine can, meaning the latter will 
    be used and automatically detect the separator by Python's builtin sniffer 
    tool, ``csv.Sniffer``. In addition, separators longer than 1 character and 
    different from ``'\s+'`` will be interpreted as regular expressions and 
    will also force the use of the Python parsing engine. Note that regex 
    delimiters are prone to ignoring quoted data. Regex example: ``'\r\t'``. 
delimiter : str, default ``None`` 
    Alias for sep. 
header : int, list of int, None, default 'infer' 
    Row number(s) to use as the column names, and the start of the 
    data.  Default behavior is to infer the column names: if no names 
    are passed the behavior is identical to ``header=0`` and column 
    names are inferred from the first line of the file, if column 
    names are passed explicitly then the behavior is identical to 
    ``header=None``. Explicitly pass ``header=0`` to be able to 
    replace existing names. The header can be a list of integers that 
    specify row locations for a multi-index on the columns 
    e.g. [0,1,3]. Intervening rows that are not specified will be 
    skipped (e.g. 2 in this example is skipped). Note that this 
    parameter ignores commented lines and empty lines if 
    ``skip_blank_lines=True``, so ``header=0`` denotes the first line of 
    data rather than the first line of the file. 
names : array-like, optional 
    List of column names to use. If the file contains a header row, 
    then you should explicitly pass ``header=0`` to override the column names. 
    Duplicates in this list are not allowed. 
index_col : int, str, sequence of int / str, or False, optional, default ``None`` 
  Column(s) to use as the row labels of the ``DataFrame``, either given as 
  string name or column index. If a sequence of int / str is given, a 
  MultiIndex is used. 
 
  Note: ``index_col=False`` can be used to force pandas to *not* use the first 
  column as the index, e.g. when you have a malformed file with delimiters at 
  the end of each line. 
usecols : list-like or callable, optional 
    Return a subset of the columns. If list-like, all elements must either 
    be positional (i.e. integer indices into the document columns) or strings 
    that correspond to column names provided either by the user in `names` or 
    inferred from the document header row(s). If ``names`` are given, the document 
    header row(s) are not taken into account. For example, a valid list-like 
    `usecols` parameter would be ``[0, 1, 2]`` or ``['foo', 'bar', 'baz']``. 
    Element order is ignored, so ``usecols=[0, 1]`` is the same as ``[1, 0]``. 
    To instantiate a DataFrame from ``data`` with element order preserved use 
    ``pd.read_csv(data, usecols=['foo', 'bar'])[['foo', 'bar']]`` for columns 
    in ``['foo', 'bar']`` order or 
    ``pd.read_csv(data, usecols=['foo', 'bar'])[['bar', 'foo']]`` 
    for ``['bar', 'foo']`` order. 
 
    If callable, the callable function will be evaluated against the column 
    names, returning names where the callable function evaluates to True. An 
    example of a valid callable argument would be ``lambda x: x.upper() in 
    ['AAA', 'BBB', 'DDD']``. Using this parameter results in much faster 
    parsing time and lower memory usage. 
squeeze : bool, default False 
    If the parsed data only contains one column then return a Series. 
 
    .. deprecated:: 1.4.0 
        Append ``.squeeze(&quot;columns&quot;)`` to the call to ``{func_name}`` to squeeze 
        the data. 
prefix : str, optional 
    Prefix to add to column numbers when no header, e.g. 'X' for X0, X1, ... 
 
    .. deprecated:: 1.4.0 
       Use a list comprehension on the DataFrame's columns after calling ``read_csv``. 
mangle_dupe_cols : bool, default True 
    Duplicate columns will be specified as 'X', 'X.1', ...'X.N', rather than 
    'X'...'X'. Passing in False will cause data to be overwritten if there 
    are duplicate names in the columns. 
dtype : Type name or dict of column -&gt; type, optional 
    Data type for data or columns. E.g. {{'a': np.float64, 'b': np.int32, 
    'c': 'Int64'}} 
    Use `str` or `object` together with suitable `na_values` settings 
    to preserve and not interpret dtype. 
    If converters are specified, they will be applied INSTEAD 
    of dtype conversion. 
engine : {{'c', 'python', 'pyarrow'}}, optional 
    Parser engine to use. The C and pyarrow engines are faster, while the python engine 
    is currently more feature-complete. Multithreading is currently only supported by 
    the pyarrow engine. 
 
    .. versionadded:: 1.4.0 
 
        The &quot;pyarrow&quot; engine was added as an *experimental* engine, and some features 
        are unsupported, or may not work correctly, with this engine. 
converters : dict, optional 
    Dict of functions for converting values in certain columns. Keys can either 
    be integers or column labels. 
true_values : list, optional 
    Values to consider as True. 
false_values : list, optional 
    Values to consider as False. 
skipinitialspace : bool, default False 
    Skip spaces after delimiter. 
skiprows : list-like, int or callable, optional 
    Line numbers to skip (0-indexed) or number of lines to skip (int) 
    at the start of the file. 
 
    If callable, the callable function will be evaluated against the row 
    indices, returning True if the row should be skipped and False otherwise. 
    An example of a valid callable argument would be ``lambda x: x in [0, 2]``. 
skipfooter : int, default 0 
    Number of lines at bottom of file to skip (Unsupported with engine='c'). 
nrows : int, optional 
    Number of rows of file to read. Useful for reading pieces of large files. 
na_values : scalar, str, list-like, or dict, optional 
    Additional strings to recognize as NA/NaN. If dict passed, specific 
    per-column NA values.  By default the following values are interpreted as 
    NaN: '&quot;&quot;&quot;</span>
    <span class="s1">+ fill(</span><span class="s3">&quot;', '&quot;</span><span class="s1">.join(sorted(STR_NA_VALUES))</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s1">subsequent_indent=</span><span class="s3">&quot;    &quot;</span><span class="s1">)</span>
    <span class="s1">+ </span><span class="s3">&quot;&quot;&quot;'. 
keep_default_na : bool, default True 
    Whether or not to include the default NaN values when parsing the data. 
    Depending on whether `na_values` is passed in, the behavior is as follows: 
 
    * If `keep_default_na` is True, and `na_values` are specified, `na_values` 
      is appended to the default NaN values used for parsing. 
    * If `keep_default_na` is True, and `na_values` are not specified, only 
      the default NaN values are used for parsing. 
    * If `keep_default_na` is False, and `na_values` are specified, only 
      the NaN values specified `na_values` are used for parsing. 
    * If `keep_default_na` is False, and `na_values` are not specified, no 
      strings will be parsed as NaN. 
 
    Note that if `na_filter` is passed in as False, the `keep_default_na` and 
    `na_values` parameters will be ignored. 
na_filter : bool, default True 
    Detect missing value markers (empty strings and the value of na_values). In 
    data without any NAs, passing na_filter=False can improve the performance 
    of reading a large file. 
verbose : bool, default False 
    Indicate number of NA values placed in non-numeric columns. 
skip_blank_lines : bool, default True 
    If True, skip over blank lines rather than interpreting as NaN values. 
parse_dates : bool or list of int or names or list of lists or dict, </span><span class="s2">\ 
</span><span class="s3">default False 
    The behavior is as follows: 
 
    * boolean. If True -&gt; try parsing the index. 
    * list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3 
      each as a separate date column. 
    * list of lists. e.g.  If [[1, 3]] -&gt; combine columns 1 and 3 and parse as 
      a single date column. 
    * dict, e.g. {{'foo' : [1, 3]}} -&gt; parse columns 1, 3 as date and call 
      result 'foo' 
 
    If a column or index cannot be represented as an array of datetimes, 
    say because of an unparsable value or a mixture of timezones, the column 
    or index will be returned unaltered as an object data type. For 
    non-standard datetime parsing, use ``pd.to_datetime`` after 
    ``pd.read_csv``. To parse an index or column with a mixture of timezones, 
    specify ``date_parser`` to be a partially-applied 
    :func:`pandas.to_datetime` with ``utc=True``. See 
    :ref:`io.csv.mixed_timezones` for more. 
 
    Note: A fast-path exists for iso8601-formatted dates. 
infer_datetime_format : bool, default False 
    If True and `parse_dates` is enabled, pandas will attempt to infer the 
    format of the datetime strings in the columns, and if it can be inferred, 
    switch to a faster method of parsing them. In some cases this can increase 
    the parsing speed by 5-10x. 
keep_date_col : bool, default False 
    If True and `parse_dates` specifies combining multiple columns then 
    keep the original columns. 
date_parser : function, optional 
    Function to use for converting a sequence of string columns to an array of 
    datetime instances. The default uses ``dateutil.parser.parser`` to do the 
    conversion. Pandas will try to call `date_parser` in three different ways, 
    advancing to the next if an exception occurs: 1) Pass one or more arrays 
    (as defined by `parse_dates`) as arguments; 2) concatenate (row-wise) the 
    string values from the columns defined by `parse_dates` into a single array 
    and pass that; and 3) call `date_parser` once for each row using one or 
    more strings (corresponding to the columns defined by `parse_dates`) as 
    arguments. 
dayfirst : bool, default False 
    DD/MM format dates, international and European format. 
cache_dates : bool, default True 
    If True, use a cache of unique, converted dates to apply the datetime 
    conversion. May produce significant speed-up when parsing duplicate 
    date strings, especially ones with timezone offsets. 
 
    .. versionadded:: 0.25.0 
iterator : bool, default False 
    Return TextFileReader object for iteration or getting chunks with 
    ``get_chunk()``. 
 
    .. versionchanged:: 1.2 
 
       ``TextFileReader`` is a context manager. 
chunksize : int, optional 
    Return TextFileReader object for iteration. 
    See the `IO Tools docs 
    &lt;https://pandas.pydata.org/pandas-docs/stable/io.html#io-chunking&gt;`_ 
    for more information on ``iterator`` and ``chunksize``. 
 
    .. versionchanged:: 1.2 
 
       ``TextFileReader`` is a context manager. 
{decompression_options} 
 
    .. versionchanged:: 1.4.0 Zstandard support. 
 
thousands : str, optional 
    Thousands separator. 
decimal : str, default '.' 
    Character to recognize as decimal point (e.g. use ',' for European data). 
lineterminator : str (length 1), optional 
    Character to break file into lines. Only valid with C parser. 
quotechar : str (length 1), optional 
    The character used to denote the start and end of a quoted item. Quoted 
    items can include the delimiter and it will be ignored. 
quoting : int or csv.QUOTE_* instance, default 0 
    Control field quoting behavior per ``csv.QUOTE_*`` constants. Use one of 
    QUOTE_MINIMAL (0), QUOTE_ALL (1), QUOTE_NONNUMERIC (2) or QUOTE_NONE (3). 
doublequote : bool, default ``True`` 
   When quotechar is specified and quoting is not ``QUOTE_NONE``, indicate 
   whether or not to interpret two consecutive quotechar elements INSIDE a 
   field as a single ``quotechar`` element. 
escapechar : str (length 1), optional 
    One-character string used to escape other characters. 
comment : str, optional 
    Indicates remainder of line should not be parsed. If found at the beginning 
    of a line, the line will be ignored altogether. This parameter must be a 
    single character. Like empty lines (as long as ``skip_blank_lines=True``), 
    fully commented lines are ignored by the parameter `header` but not by 
    `skiprows`. For example, if ``comment='#'``, parsing 
    ``#empty</span><span class="s2">\\</span><span class="s3">na,b,c</span><span class="s2">\\</span><span class="s3">n1,2,3`` with ``header=0`` will result in 'a,b,c' being 
    treated as the header. 
encoding : str, optional 
    Encoding to use for UTF when reading/writing (ex. 'utf-8'). `List of Python 
    standard encodings 
    &lt;https://docs.python.org/3/library/codecs.html#standard-encodings&gt;`_ . 
 
    .. versionchanged:: 1.2 
 
       When ``encoding`` is ``None``, ``errors=&quot;replace&quot;`` is passed to 
       ``open()``. Otherwise, ``errors=&quot;strict&quot;`` is passed to ``open()``. 
       This behavior was previously only the case for ``engine=&quot;python&quot;``. 
 
    .. versionchanged:: 1.3.0 
 
       ``encoding_errors`` is a new argument. ``encoding`` has no longer an 
       influence on how encoding errors are handled. 
 
encoding_errors : str, optional, default &quot;strict&quot; 
    How encoding errors are treated. `List of possible values 
    &lt;https://docs.python.org/3/library/codecs.html#error-handlers&gt;`_ . 
 
    .. versionadded:: 1.3.0 
 
dialect : str or csv.Dialect, optional 
    If provided, this parameter will override values (default or not) for the 
    following parameters: `delimiter`, `doublequote`, `escapechar`, 
    `skipinitialspace`, `quotechar`, and `quoting`. If it is necessary to 
    override values, a ParserWarning will be issued. See csv.Dialect 
    documentation for more details. 
error_bad_lines : bool, optional, default ``None`` 
    Lines with too many fields (e.g. a csv line with too many commas) will by 
    default cause an exception to be raised, and no DataFrame will be returned. 
    If False, then these &quot;bad lines&quot; will be dropped from the DataFrame that is 
    returned. 
 
    .. deprecated:: 1.3.0 
       The ``on_bad_lines`` parameter should be used instead to specify behavior upon 
       encountering a bad line instead. 
warn_bad_lines : bool, optional, default ``None`` 
    If error_bad_lines is False, and warn_bad_lines is True, a warning for each 
    &quot;bad line&quot; will be output. 
 
    .. deprecated:: 1.3.0 
       The ``on_bad_lines`` parameter should be used instead to specify behavior upon 
       encountering a bad line instead. 
on_bad_lines : {{'error', 'warn', 'skip'}} or callable, default 'error' 
    Specifies what to do upon encountering a bad line (a line with too many fields). 
    Allowed values are : 
 
        - 'error', raise an Exception when a bad line is encountered. 
        - 'warn', raise a warning when a bad line is encountered and skip that line. 
        - 'skip', skip bad lines without raising or warning when they are encountered. 
 
    .. versionadded:: 1.3.0 
 
        - callable, function with signature 
          ``(bad_line: list[str]) -&gt; list[str] | None`` that will process a single 
          bad line. ``bad_line`` is a list of strings split by the ``sep``. 
          If the function returns ``None`, the bad line will be ignored. 
          If the function returns a new list of strings with more elements than 
          expected, a ``ParserWarning`` will be emitted while dropping extra elements. 
          Only supported when ``engine=&quot;python&quot;`` 
 
    .. versionadded:: 1.4.0 
 
delim_whitespace : bool, default False 
    Specifies whether or not whitespace (e.g. ``' '`` or ``'</span><span class="s2">\t</span><span class="s3">'``) will be 
    used as the sep. Equivalent to setting ``sep='</span><span class="s2">\\</span><span class="s3">s+'``. If this option 
    is set to True, nothing should be passed in for the ``delimiter`` 
    parameter. 
low_memory : bool, default True 
    Internally process the file in chunks, resulting in lower memory use 
    while parsing, but possibly mixed type inference.  To ensure no mixed 
    types either set False, or specify the type with the `dtype` parameter. 
    Note that the entire file is read into a single DataFrame regardless, 
    use the `chunksize` or `iterator` parameter to return the data in chunks. 
    (Only valid with C parser). 
memory_map : bool, default False 
    If a filepath is provided for `filepath_or_buffer`, map the file object 
    directly onto memory and access the data directly from there. Using this 
    option can improve performance because there is no longer any I/O overhead. 
float_precision : str, optional 
    Specifies which converter the C engine should use for floating-point 
    values. The options are ``None`` or 'high' for the ordinary converter, 
    'legacy' for the original lower precision pandas converter, and 
    'round_trip' for the round-trip converter. 
 
    .. versionchanged:: 1.2 
 
{storage_options} 
 
    .. versionadded:: 1.2 
 
Returns 
------- 
DataFrame or TextParser 
    A comma-separated values (csv) file is returned as two-dimensional 
    data structure with labeled axes. 
 
See Also 
-------- 
DataFrame.to_csv : Write DataFrame to a comma-separated values (csv) file. 
read_csv : Read a comma-separated values (csv) file into DataFrame. 
read_fwf : Read a table of fixed-width formatted lines into DataFrame. 
 
Examples 
-------- 
&gt;&gt;&gt; pd.{func_name}('data.csv')  # doctest: +SKIP 
&quot;&quot;&quot;</span>
<span class="s1">)</span>


<span class="s1">_c_parser_defaults = {</span>
    <span class="s3">&quot;delim_whitespace&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s3">&quot;na_filter&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s3">&quot;low_memory&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s3">&quot;memory_map&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s3">&quot;float_precision&quot;</span><span class="s1">: </span><span class="s2">None,</span>
<span class="s1">}</span>

<span class="s1">_fwf_defaults = {</span><span class="s3">&quot;colspecs&quot;</span><span class="s1">: </span><span class="s3">&quot;infer&quot;</span><span class="s2">, </span><span class="s3">&quot;infer_nrows&quot;</span><span class="s1">: </span><span class="s4">100</span><span class="s2">, </span><span class="s3">&quot;widths&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>

<span class="s1">_c_unsupported = {</span><span class="s3">&quot;skipfooter&quot;</span><span class="s1">}</span>
<span class="s1">_python_unsupported = {</span><span class="s3">&quot;low_memory&quot;</span><span class="s2">, </span><span class="s3">&quot;float_precision&quot;</span><span class="s1">}</span>
<span class="s1">_pyarrow_unsupported = {</span>
    <span class="s3">&quot;skipfooter&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;float_precision&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;chunksize&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;comment&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;nrows&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;thousands&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;memory_map&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;dialect&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;warn_bad_lines&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;error_bad_lines&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;on_bad_lines&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;delim_whitespace&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;quoting&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;lineterminator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;converters&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;decimal&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;iterator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;dayfirst&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;infer_datetime_format&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;verbose&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;skipinitialspace&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;low_memory&quot;</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">_DeprecationConfig(NamedTuple):</span>
    <span class="s1">default_value: Any</span>
    <span class="s1">msg: str | </span><span class="s2">None</span>


<span class="s1">_deprecated_defaults: dict[str</span><span class="s2">, </span><span class="s1">_DeprecationConfig] = {</span>
    <span class="s3">&quot;error_bad_lines&quot;</span><span class="s1">: _DeprecationConfig(</span><span class="s2">None, </span><span class="s3">&quot;Use on_bad_lines in the future.&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s3">&quot;warn_bad_lines&quot;</span><span class="s1">: _DeprecationConfig(</span><span class="s2">None, </span><span class="s3">&quot;Use on_bad_lines in the future.&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s3">&quot;squeeze&quot;</span><span class="s1">: _DeprecationConfig(</span>
        <span class="s2">None, </span><span class="s3">'Append .squeeze(&quot;columns&quot;) to the call to squeeze.'</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s3">&quot;prefix&quot;</span><span class="s1">: _DeprecationConfig(</span>
        <span class="s2">None, </span><span class="s3">&quot;Use a list comprehension on the column names in the future.&quot;</span>
    <span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">validate_integer(name</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">min_val=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks whether the 'name' parameter for parsing is either 
    an integer OR float that can SAFELY be cast to an integer 
    without losing accuracy. Raises a ValueError if that is 
    not the case. 
 
    Parameters 
    ---------- 
    name : str 
        Parameter name (used for error reporting) 
    val : int or float 
        The value to check 
    min_val : int 
        Minimum allowed value (val &lt; min_val will result in a ValueError) 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = </span><span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">:</span><span class="s3">s</span><span class="s2">}</span><span class="s3">' must be an integer &gt;=</span><span class="s2">{</span><span class="s1">min_val</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_float(val):</span>
            <span class="s2">if </span><span class="s1">int(val) != val:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">val = int(val)</span>
        <span class="s2">elif not </span><span class="s1">(is_integer(val) </span><span class="s2">and </span><span class="s1">val &gt;= min_val):</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">return </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">_validate_names(names):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raise ValueError if the `names` parameter contains duplicates or has an 
    invalid data type. 
 
    Parameters 
    ---------- 
    names : array-like or None 
        An array containing a list of the names used for the output DataFrame. 
 
    Raises 
    ------ 
    ValueError 
        If names are not unique or are not ordered (e.g. set). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">names </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">len(names) != len(set(names)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Duplicate names are not allowed.&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">is_list_like(names</span><span class="s2">, </span><span class="s1">allow_sets=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">abc.KeysView)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Names should be an ordered collection.&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_read(</span>
    <span class="s1">filepath_or_buffer: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</span><span class="s2">, </span><span class="s1">kwds</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Generic reader of line files.&quot;&quot;&quot;</span>
    <span class="s5"># if we pass a date_parser and parse_dates=False, we should not parse the</span>
    <span class="s5"># dates GH#44366</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">kwds.get(</span><span class="s3">&quot;date_parser&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span>
        <span class="s2">and </span><span class="s1">kwds.get(</span><span class="s3">&quot;parse_dates&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is None</span>
    <span class="s1">):</span>
        <span class="s1">kwds[</span><span class="s3">&quot;parse_dates&quot;</span><span class="s1">] = </span><span class="s2">True</span>
    <span class="s2">elif </span><span class="s1">kwds.get(</span><span class="s3">&quot;parse_dates&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s3">&quot;parse_dates&quot;</span><span class="s1">] = </span><span class="s2">False</span>

    <span class="s5"># Extract some of the arguments (pass chunksize on).</span>
    <span class="s1">iterator = kwds.get(</span><span class="s3">&quot;iterator&quot;</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">chunksize = kwds.get(</span><span class="s3">&quot;chunksize&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;engine&quot;</span><span class="s1">) == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">iterator:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The 'iterator' option is not supported with the 'pyarrow' engine&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">chunksize </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The 'chunksize' option is not supported with the 'pyarrow' engine&quot;</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">chunksize = validate_integer(</span><span class="s3">&quot;chunksize&quot;</span><span class="s2">, </span><span class="s1">kwds.get(</span><span class="s3">&quot;chunksize&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">nrows = kwds.get(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s5"># Check for duplicates in names.</span>
    <span class="s1">_validate_names(kwds.get(</span><span class="s3">&quot;names&quot;</span><span class="s2">, None</span><span class="s1">))</span>

    <span class="s5"># Create the parser.</span>
    <span class="s1">parser = TextFileReader(filepath_or_buffer</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">if </span><span class="s1">chunksize </span><span class="s2">or </span><span class="s1">iterator:</span>
        <span class="s2">return </span><span class="s1">parser</span>

    <span class="s2">with </span><span class="s1">parser:</span>
        <span class="s2">return </span><span class="s1">parser.read(nrows)</span>


<span class="s1">@deprecate_nonkeyword_arguments(</span>
    <span class="s1">version=</span><span class="s2">None, </span><span class="s1">allowed_args=[</span><span class="s3">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span>
<span class="s1">)</span>
<span class="s1">@Appender(</span>
    <span class="s1">_doc_read_csv_and_table.format(</span>
        <span class="s1">func_name=</span><span class="s3">&quot;read_csv&quot;</span><span class="s2">,</span>
        <span class="s1">summary=</span><span class="s3">&quot;Read a comma-separated values (csv) file into DataFrame.&quot;</span><span class="s2">,</span>
        <span class="s1">_default_sep=</span><span class="s3">&quot;','&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options=_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">decompression_options=_shared_docs[</span><span class="s3">&quot;decompression_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">read_csv(</span>
    <span class="s1">filepath_or_buffer: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</span><span class="s2">,</span>
    <span class="s1">sep=lib.no_default</span><span class="s2">,</span>
    <span class="s1">delimiter=</span><span class="s2">None,</span>
    <span class="s5"># Column and Index Locations and Names</span>
    <span class="s1">header=</span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">names=lib.no_default</span><span class="s2">,</span>
    <span class="s1">index_col=</span><span class="s2">None,</span>
    <span class="s1">usecols=</span><span class="s2">None,</span>
    <span class="s1">squeeze=</span><span class="s2">None,</span>
    <span class="s1">prefix=lib.no_default</span><span class="s2">,</span>
    <span class="s1">mangle_dupe_cols=</span><span class="s2">True,</span>
    <span class="s5"># General Parsing Configuration</span>
    <span class="s1">dtype: DtypeArg | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">engine: CSVEngine | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">converters=</span><span class="s2">None,</span>
    <span class="s1">true_values=</span><span class="s2">None,</span>
    <span class="s1">false_values=</span><span class="s2">None,</span>
    <span class="s1">skipinitialspace=</span><span class="s2">False,</span>
    <span class="s1">skiprows=</span><span class="s2">None,</span>
    <span class="s1">skipfooter=</span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">nrows=</span><span class="s2">None,</span>
    <span class="s5"># NA and Missing Data Handling</span>
    <span class="s1">na_values=</span><span class="s2">None,</span>
    <span class="s1">keep_default_na=</span><span class="s2">True,</span>
    <span class="s1">na_filter=</span><span class="s2">True,</span>
    <span class="s1">verbose=</span><span class="s2">False,</span>
    <span class="s1">skip_blank_lines=</span><span class="s2">True,</span>
    <span class="s5"># Datetime Handling</span>
    <span class="s1">parse_dates=</span><span class="s2">None,</span>
    <span class="s1">infer_datetime_format=</span><span class="s2">False,</span>
    <span class="s1">keep_date_col=</span><span class="s2">False,</span>
    <span class="s1">date_parser=</span><span class="s2">None,</span>
    <span class="s1">dayfirst=</span><span class="s2">False,</span>
    <span class="s1">cache_dates=</span><span class="s2">True,</span>
    <span class="s5"># Iteration</span>
    <span class="s1">iterator=</span><span class="s2">False,</span>
    <span class="s1">chunksize=</span><span class="s2">None,</span>
    <span class="s5"># Quoting, Compression, and File Format</span>
    <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">thousands=</span><span class="s2">None,</span>
    <span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span><span class="s2">,</span>
    <span class="s1">lineterminator=</span><span class="s2">None,</span>
    <span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s2">,</span>
    <span class="s1">quoting=csv.QUOTE_MINIMAL</span><span class="s2">,</span>
    <span class="s1">doublequote=</span><span class="s2">True,</span>
    <span class="s1">escapechar=</span><span class="s2">None,</span>
    <span class="s1">comment=</span><span class="s2">None,</span>
    <span class="s1">encoding=</span><span class="s2">None,</span>
    <span class="s1">encoding_errors: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s3">&quot;strict&quot;</span><span class="s2">,</span>
    <span class="s1">dialect=</span><span class="s2">None,</span>
    <span class="s5"># Error Handling</span>
    <span class="s1">error_bad_lines=</span><span class="s2">None,</span>
    <span class="s1">warn_bad_lines=</span><span class="s2">None,</span>
    <span class="s5"># TODO(2.0): set on_bad_lines to &quot;error&quot;.</span>
    <span class="s5"># See _refine_defaults_read comment for why we do this.</span>
    <span class="s1">on_bad_lines=</span><span class="s2">None,</span>
    <span class="s5"># Internal</span>
    <span class="s1">delim_whitespace=</span><span class="s2">False,</span>
    <span class="s1">low_memory=_c_parser_defaults[</span><span class="s3">&quot;low_memory&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">memory_map=</span><span class="s2">False,</span>
    <span class="s1">float_precision=</span><span class="s2">None,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s5"># locals() should never be modified</span>
    <span class="s1">kwds = locals().copy()</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s3">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s3">&quot;sep&quot;</span><span class="s1">]</span>

    <span class="s1">kwds_defaults = _refine_defaults_read(</span>
        <span class="s1">dialect</span><span class="s2">,</span>
        <span class="s1">delimiter</span><span class="s2">,</span>
        <span class="s1">delim_whitespace</span><span class="s2">,</span>
        <span class="s1">engine</span><span class="s2">,</span>
        <span class="s1">sep</span><span class="s2">,</span>
        <span class="s1">error_bad_lines</span><span class="s2">,</span>
        <span class="s1">warn_bad_lines</span><span class="s2">,</span>
        <span class="s1">on_bad_lines</span><span class="s2">,</span>
        <span class="s1">names</span><span class="s2">,</span>
        <span class="s1">prefix</span><span class="s2">,</span>
        <span class="s1">defaults={</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s3">&quot;,&quot;</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">kwds.update(kwds_defaults)</span>

    <span class="s2">return </span><span class="s1">_read(filepath_or_buffer</span><span class="s2">, </span><span class="s1">kwds)</span>


<span class="s1">@deprecate_nonkeyword_arguments(</span>
    <span class="s1">version=</span><span class="s2">None, </span><span class="s1">allowed_args=[</span><span class="s3">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span>
<span class="s1">)</span>
<span class="s1">@Appender(</span>
    <span class="s1">_doc_read_csv_and_table.format(</span>
        <span class="s1">func_name=</span><span class="s3">&quot;read_table&quot;</span><span class="s2">,</span>
        <span class="s1">summary=</span><span class="s3">&quot;Read general delimited file into DataFrame.&quot;</span><span class="s2">,</span>
        <span class="s1">_default_sep=</span><span class="s3">r&quot;'\\t' (tab-stop)&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options=_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">decompression_options=_shared_docs[</span><span class="s3">&quot;decompression_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">read_table(</span>
    <span class="s1">filepath_or_buffer: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</span><span class="s2">,</span>
    <span class="s1">sep=lib.no_default</span><span class="s2">,</span>
    <span class="s1">delimiter=</span><span class="s2">None,</span>
    <span class="s5"># Column and Index Locations and Names</span>
    <span class="s1">header=</span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">names=lib.no_default</span><span class="s2">,</span>
    <span class="s1">index_col=</span><span class="s2">None,</span>
    <span class="s1">usecols=</span><span class="s2">None,</span>
    <span class="s1">squeeze=</span><span class="s2">None,</span>
    <span class="s1">prefix=lib.no_default</span><span class="s2">,</span>
    <span class="s1">mangle_dupe_cols=</span><span class="s2">True,</span>
    <span class="s5"># General Parsing Configuration</span>
    <span class="s1">dtype: DtypeArg | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">engine: CSVEngine | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">converters=</span><span class="s2">None,</span>
    <span class="s1">true_values=</span><span class="s2">None,</span>
    <span class="s1">false_values=</span><span class="s2">None,</span>
    <span class="s1">skipinitialspace=</span><span class="s2">False,</span>
    <span class="s1">skiprows=</span><span class="s2">None,</span>
    <span class="s1">skipfooter=</span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">nrows=</span><span class="s2">None,</span>
    <span class="s5"># NA and Missing Data Handling</span>
    <span class="s1">na_values=</span><span class="s2">None,</span>
    <span class="s1">keep_default_na=</span><span class="s2">True,</span>
    <span class="s1">na_filter=</span><span class="s2">True,</span>
    <span class="s1">verbose=</span><span class="s2">False,</span>
    <span class="s1">skip_blank_lines=</span><span class="s2">True,</span>
    <span class="s5"># Datetime Handling</span>
    <span class="s1">parse_dates=</span><span class="s2">False,</span>
    <span class="s1">infer_datetime_format=</span><span class="s2">False,</span>
    <span class="s1">keep_date_col=</span><span class="s2">False,</span>
    <span class="s1">date_parser=</span><span class="s2">None,</span>
    <span class="s1">dayfirst=</span><span class="s2">False,</span>
    <span class="s1">cache_dates=</span><span class="s2">True,</span>
    <span class="s5"># Iteration</span>
    <span class="s1">iterator=</span><span class="s2">False,</span>
    <span class="s1">chunksize=</span><span class="s2">None,</span>
    <span class="s5"># Quoting, Compression, and File Format</span>
    <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">thousands=</span><span class="s2">None,</span>
    <span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span><span class="s2">,</span>
    <span class="s1">lineterminator=</span><span class="s2">None,</span>
    <span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s2">,</span>
    <span class="s1">quoting=csv.QUOTE_MINIMAL</span><span class="s2">,</span>
    <span class="s1">doublequote=</span><span class="s2">True,</span>
    <span class="s1">escapechar=</span><span class="s2">None,</span>
    <span class="s1">comment=</span><span class="s2">None,</span>
    <span class="s1">encoding=</span><span class="s2">None,</span>
    <span class="s1">encoding_errors: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s3">&quot;strict&quot;</span><span class="s2">,</span>
    <span class="s1">dialect=</span><span class="s2">None,</span>
    <span class="s5"># Error Handling</span>
    <span class="s1">error_bad_lines=</span><span class="s2">None,</span>
    <span class="s1">warn_bad_lines=</span><span class="s2">None,</span>
    <span class="s5"># TODO(2.0): set on_bad_lines to &quot;error&quot;.</span>
    <span class="s5"># See _refine_defaults_read comment for why we do this.</span>
    <span class="s1">on_bad_lines=</span><span class="s2">None,</span>
    <span class="s5"># Internal</span>
    <span class="s1">delim_whitespace=</span><span class="s2">False,</span>
    <span class="s1">low_memory=_c_parser_defaults[</span><span class="s3">&quot;low_memory&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">memory_map=</span><span class="s2">False,</span>
    <span class="s1">float_precision=</span><span class="s2">None,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s5"># locals() should never be modified</span>
    <span class="s1">kwds = locals().copy()</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s3">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span>
    <span class="s2">del </span><span class="s1">kwds[</span><span class="s3">&quot;sep&quot;</span><span class="s1">]</span>

    <span class="s1">kwds_defaults = _refine_defaults_read(</span>
        <span class="s1">dialect</span><span class="s2">,</span>
        <span class="s1">delimiter</span><span class="s2">,</span>
        <span class="s1">delim_whitespace</span><span class="s2">,</span>
        <span class="s1">engine</span><span class="s2">,</span>
        <span class="s1">sep</span><span class="s2">,</span>
        <span class="s1">error_bad_lines</span><span class="s2">,</span>
        <span class="s1">warn_bad_lines</span><span class="s2">,</span>
        <span class="s1">on_bad_lines</span><span class="s2">,</span>
        <span class="s1">names</span><span class="s2">,</span>
        <span class="s1">prefix</span><span class="s2">,</span>
        <span class="s1">defaults={</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">kwds.update(kwds_defaults)</span>

    <span class="s2">return </span><span class="s1">_read(filepath_or_buffer</span><span class="s2">, </span><span class="s1">kwds)</span>


<span class="s1">@deprecate_nonkeyword_arguments(</span>
    <span class="s1">version=</span><span class="s2">None, </span><span class="s1">allowed_args=[</span><span class="s3">&quot;filepath_or_buffer&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">2</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">read_fwf(</span>
    <span class="s1">filepath_or_buffer: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</span><span class="s2">,</span>
    <span class="s1">colspecs: list[tuple[int</span><span class="s2">, </span><span class="s1">int]] | str | </span><span class="s2">None </span><span class="s1">= </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">widths: list[int] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">infer_nrows: int = </span><span class="s4">100</span><span class="s2">,</span>
    <span class="s1">**kwds</span><span class="s2">,</span>
<span class="s1">) -&gt; DataFrame | TextFileReader:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Read a table of fixed-width formatted lines into DataFrame. 
 
    Also supports optionally iterating or breaking of the file 
    into chunks. 
 
    Additional help can be found in the `online docs for IO Tools 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html&gt;`_. 
 
    Parameters 
    ---------- 
    filepath_or_buffer : str, path object, or file-like object 
        String, path object (implementing ``os.PathLike[str]``), or file-like 
        object implementing a text ``read()`` function.The string could be a URL. 
        Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is 
        expected. A local file could be: 
        ``file://localhost/path/to/table.csv``. 
    colspecs : list of tuple (int, int) or 'infer'. optional 
        A list of tuples giving the extents of the fixed-width 
        fields of each line as half-open intervals (i.e.,  [from, to[ ). 
        String value 'infer' can be used to instruct the parser to try 
        detecting the column specifications from the first 100 rows of 
        the data which are not being skipped via skiprows (default='infer'). 
    widths : list of int, optional 
        A list of field widths which can be used instead of 'colspecs' if 
        the intervals are contiguous. 
    infer_nrows : int, default 100 
        The number of rows to consider when letting the parser determine the 
        `colspecs`. 
    **kwds : optional 
        Optional keyword arguments can be passed to ``TextFileReader``. 
 
    Returns 
    ------- 
    DataFrame or TextFileReader 
        A comma-separated values (csv) file is returned as two-dimensional 
        data structure with labeled axes. 
 
    See Also 
    -------- 
    DataFrame.to_csv : Write DataFrame to a comma-separated values (csv) file. 
    read_csv : Read a comma-separated values (csv) file into DataFrame. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.read_fwf('data.csv')  # doctest: +SKIP 
    &quot;&quot;&quot;</span>
    <span class="s5"># Check input arguments.</span>
    <span class="s2">if </span><span class="s1">colspecs </span><span class="s2">is None and </span><span class="s1">widths </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Must specify either colspecs or widths&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">colspecs </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None, </span><span class="s3">&quot;infer&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">widths </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;You must specify only one of 'widths' and 'colspecs'&quot;</span><span class="s1">)</span>

    <span class="s5"># Compute 'colspecs' from 'widths', if specified.</span>
    <span class="s2">if </span><span class="s1">widths </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">colspecs</span><span class="s2">, </span><span class="s1">col = []</span><span class="s2">, </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">widths:</span>
            <span class="s1">colspecs.append((col</span><span class="s2">, </span><span class="s1">col + w))</span>
            <span class="s1">col += w</span>

    <span class="s5"># for mypy</span>
    <span class="s2">assert </span><span class="s1">colspecs </span><span class="s2">is not None</span>

    <span class="s5"># GH#40830</span>
    <span class="s5"># Ensure length of `colspecs` matches length of `names`</span>
    <span class="s1">names = kwds.get(</span><span class="s3">&quot;names&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">names </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">len(names) != len(colspecs) </span><span class="s2">and </span><span class="s1">colspecs != </span><span class="s3">&quot;infer&quot;</span><span class="s1">:</span>
            <span class="s5"># need to check len(index_col) as it might contain</span>
            <span class="s5"># unnamed indices, in which case it's name is not required</span>
            <span class="s1">len_index = </span><span class="s4">0</span>
            <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;index_col&quot;</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">index_col: Any = kwds.get(</span><span class="s3">&quot;index_col&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is not False</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">is_list_like(index_col):</span>
                        <span class="s1">len_index = </span><span class="s4">1</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">len_index = len(index_col)</span>
            <span class="s2">if </span><span class="s1">len(names) + len_index != len(colspecs):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Length of colspecs must match length of names&quot;</span><span class="s1">)</span>

    <span class="s1">kwds[</span><span class="s3">&quot;colspecs&quot;</span><span class="s1">] = colspecs</span>
    <span class="s1">kwds[</span><span class="s3">&quot;infer_nrows&quot;</span><span class="s1">] = infer_nrows</span>
    <span class="s1">kwds[</span><span class="s3">&quot;engine&quot;</span><span class="s1">] = </span><span class="s3">&quot;python-fwf&quot;</span>
    <span class="s2">return </span><span class="s1">_read(filepath_or_buffer</span><span class="s2">, </span><span class="s1">kwds)</span>


<span class="s2">class </span><span class="s1">TextFileReader(abc.Iterator):</span>
    <span class="s0">&quot;&quot;&quot; 
 
    Passed dialect overrides any of the related parser options 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">f: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str] | list</span><span class="s2">,</span>
        <span class="s1">engine: CSVEngine | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwds</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">engine </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">engine_specified = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">engine = </span><span class="s3">&quot;python&quot;</span>
            <span class="s1">engine_specified = </span><span class="s2">False</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self._engine_specified = kwds.get(</span><span class="s3">&quot;engine_specified&quot;</span><span class="s2">, </span><span class="s1">engine_specified)</span>

        <span class="s1">_validate_skipfooter(kwds)</span>

        <span class="s1">dialect = _extract_dialect(kwds)</span>
        <span class="s2">if </span><span class="s1">dialect </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;The 'dialect' option is not supported with the 'pyarrow' engine&quot;</span>
                <span class="s1">)</span>
            <span class="s1">kwds = _merge_with_dialect_properties(dialect</span><span class="s2">, </span><span class="s1">kwds)</span>

        <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;header&quot;</span><span class="s2">, </span><span class="s3">&quot;infer&quot;</span><span class="s1">) == </span><span class="s3">&quot;infer&quot;</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">&quot;header&quot;</span><span class="s1">] = </span><span class="s4">0 </span><span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;names&quot;</span><span class="s1">) </span><span class="s2">is None else None</span>

        <span class="s1">self.orig_options = kwds</span>

        <span class="s5"># miscellanea</span>
        <span class="s1">self._currow = </span><span class="s4">0</span>

        <span class="s1">options = self._get_options_with_defaults(engine)</span>
        <span class="s1">options[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">] = kwds.get(</span><span class="s3">&quot;storage_options&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">self.chunksize = options.pop(</span><span class="s3">&quot;chunksize&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self.nrows = options.pop(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">self._check_file_or_buffer(f</span><span class="s2">, </span><span class="s1">engine)</span>
        <span class="s1">self.options</span><span class="s2">, </span><span class="s1">self.engine = self._clean_options(options</span><span class="s2">, </span><span class="s1">engine)</span>

        <span class="s1">self.squeeze = self.options.pop(</span><span class="s3">&quot;squeeze&quot;</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s3">&quot;has_index_names&quot; </span><span class="s2">in </span><span class="s1">kwds:</span>
            <span class="s1">self.options[</span><span class="s3">&quot;has_index_names&quot;</span><span class="s1">] = kwds[</span><span class="s3">&quot;has_index_names&quot;</span><span class="s1">]</span>

        <span class="s1">self.handles: IOHandles | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
        <span class="s1">self._engine = self._make_engine(f</span><span class="s2">, </span><span class="s1">self.engine)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s2">if </span><span class="s1">self.handles </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.handles.close()</span>
        <span class="s1">self._engine.close()</span>

    <span class="s2">def </span><span class="s1">_get_options_with_defaults(self</span><span class="s2">, </span><span class="s1">engine):</span>
        <span class="s1">kwds = self.orig_options</span>

        <span class="s1">options = {}</span>
        <span class="s1">default: object | </span><span class="s2">None</span>

        <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">parser_defaults.items():</span>
            <span class="s1">value = kwds.get(argname</span><span class="s2">, </span><span class="s1">default)</span>

            <span class="s5"># see gh-12935</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">engine == </span><span class="s3">&quot;pyarrow&quot;</span>
                <span class="s2">and </span><span class="s1">argname </span><span class="s2">in </span><span class="s1">_pyarrow_unsupported</span>
                <span class="s2">and </span><span class="s1">value != default</span>
                <span class="s2">and </span><span class="s1">value != getattr(value</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s1">default)</span>
            <span class="s1">):</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">argname == </span><span class="s3">&quot;on_bad_lines&quot;</span>
                    <span class="s2">and </span><span class="s1">kwds.get(</span><span class="s3">&quot;error_bad_lines&quot;</span><span class="s1">) </span><span class="s2">is not None</span>
                <span class="s1">):</span>
                    <span class="s1">argname = </span><span class="s3">&quot;error_bad_lines&quot;</span>
                <span class="s2">elif </span><span class="s1">(</span>
                    <span class="s1">argname == </span><span class="s3">&quot;on_bad_lines&quot; </span><span class="s2">and </span><span class="s1">kwds.get(</span><span class="s3">&quot;warn_bad_lines&quot;</span><span class="s1">) </span><span class="s2">is not None</span>
                <span class="s1">):</span>
                    <span class="s1">argname = </span><span class="s3">&quot;warn_bad_lines&quot;</span>

                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">repr(argname)</span><span class="s2">} </span><span class="s3">option is not supported with the &quot;</span>
                    <span class="s3">f&quot;'pyarrow' engine&quot;</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">argname == </span><span class="s3">&quot;mangle_dupe_cols&quot; </span><span class="s2">and </span><span class="s1">value </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s5"># GH12935</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Setting mangle_dupe_cols=False is not supported yet&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">options[argname] = value</span>

        <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">_c_parser_defaults.items():</span>
            <span class="s2">if </span><span class="s1">argname </span><span class="s2">in </span><span class="s1">kwds:</span>
                <span class="s1">value = kwds[argname]</span>

                <span class="s2">if </span><span class="s1">engine != </span><span class="s3">&quot;c&quot; </span><span class="s2">and </span><span class="s1">value != default:</span>
                    <span class="s2">if </span><span class="s3">&quot;python&quot; </span><span class="s2">in </span><span class="s1">engine </span><span class="s2">and </span><span class="s1">argname </span><span class="s2">not in </span><span class="s1">_python_unsupported:</span>
                        <span class="s2">pass</span>
                    <span class="s2">elif </span><span class="s1">(</span>
                        <span class="s1">value</span>
                        <span class="s1">== _deprecated_defaults.get(</span>
                            <span class="s1">argname</span><span class="s2">, </span><span class="s1">_DeprecationConfig(default</span><span class="s2">, None</span><span class="s1">)</span>
                        <span class="s1">).default_value</span>
                    <span class="s1">):</span>
                        <span class="s2">pass</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">repr(argname)</span><span class="s2">} </span><span class="s3">option is not supported with the &quot;</span>
                            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">repr(engine)</span><span class="s2">} </span><span class="s3">engine&quot;</span>
                        <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">value = _deprecated_defaults.get(</span>
                    <span class="s1">argname</span><span class="s2">, </span><span class="s1">_DeprecationConfig(default</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">).default_value</span>
            <span class="s1">options[argname] = value</span>

        <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;python-fwf&quot;</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">_fwf_defaults.items():</span>
                <span class="s1">options[argname] = kwds.get(argname</span><span class="s2">, </span><span class="s1">default)</span>

        <span class="s2">return </span><span class="s1">options</span>

    <span class="s2">def </span><span class="s1">_check_file_or_buffer(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">engine):</span>
        <span class="s5"># see gh-16530</span>
        <span class="s2">if </span><span class="s1">is_file_like(f) </span><span class="s2">and </span><span class="s1">engine != </span><span class="s3">&quot;c&quot; </span><span class="s2">and not </span><span class="s1">hasattr(f</span><span class="s2">, </span><span class="s3">&quot;__iter__&quot;</span><span class="s1">):</span>
            <span class="s5"># The C engine doesn't need the file-like to have the &quot;__iter__&quot;</span>
            <span class="s5"># attribute. However, the Python engine needs &quot;__iter__(...)&quot;</span>
            <span class="s5"># when iterating through such an object, meaning it</span>
            <span class="s5"># needs to have that attribute</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The 'python' engine cannot iterate through this file buffer.&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_clean_options(self</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">engine):</span>
        <span class="s1">result = options.copy()</span>

        <span class="s1">fallback_reason = </span><span class="s2">None</span>

        <span class="s5"># C engine not supported yet</span>
        <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">options[</span><span class="s3">&quot;skipfooter&quot;</span><span class="s1">] &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">fallback_reason = </span><span class="s3">&quot;the 'c' engine does not support skipfooter&quot;</span>
                <span class="s1">engine = </span><span class="s3">&quot;python&quot;</span>

        <span class="s1">sep = options[</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">]</span>
        <span class="s1">delim_whitespace = options[</span><span class="s3">&quot;delim_whitespace&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">sep </span><span class="s2">is None and not </span><span class="s1">delim_whitespace:</span>
            <span class="s2">if </span><span class="s1">engine </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">):</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s3">f&quot;the '</span><span class="s2">{</span><span class="s1">engine</span><span class="s2">}</span><span class="s3">' engine does not support &quot;</span>
                    <span class="s3">&quot;sep=None with delim_whitespace=False&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s3">&quot;python&quot;</span>
        <span class="s2">elif </span><span class="s1">sep </span><span class="s2">is not None and </span><span class="s1">len(sep) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;c&quot; </span><span class="s2">and </span><span class="s1">sep == </span><span class="s3">r&quot;\s+&quot;</span><span class="s1">:</span>
                <span class="s1">result[</span><span class="s3">&quot;delim_whitespace&quot;</span><span class="s1">] = </span><span class="s2">True</span>
                <span class="s2">del </span><span class="s1">result[</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;python&quot;</span><span class="s2">, </span><span class="s3">&quot;python-fwf&quot;</span><span class="s1">):</span>
                <span class="s5"># wait until regex engine integrated</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s3">f&quot;the '</span><span class="s2">{</span><span class="s1">engine</span><span class="s2">}</span><span class="s3">' engine does not support &quot;</span>
                    <span class="s3">&quot;regex separators (separators &gt; 1 char and &quot;</span>
                    <span class="s3">r&quot;different from '\s+' are interpreted as regex)&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s3">&quot;python&quot;</span>
        <span class="s2">elif </span><span class="s1">delim_whitespace:</span>
            <span class="s2">if </span><span class="s3">&quot;python&quot; </span><span class="s2">in </span><span class="s1">engine:</span>
                <span class="s1">result[</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">] = </span><span class="s3">r&quot;\s+&quot;</span>
        <span class="s2">elif </span><span class="s1">sep </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">encodeable = </span><span class="s2">True</span>
            <span class="s1">encoding = sys.getfilesystemencoding() </span><span class="s2">or </span><span class="s3">&quot;utf-8&quot;</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(sep.encode(encoding)) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">encodeable = </span><span class="s2">False</span>
            <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
                <span class="s1">encodeable = </span><span class="s2">False</span>
            <span class="s2">if not </span><span class="s1">encodeable </span><span class="s2">and </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;python&quot;</span><span class="s2">, </span><span class="s3">&quot;python-fwf&quot;</span><span class="s1">):</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s3">f&quot;the separator encoded in </span><span class="s2">{</span><span class="s1">encoding</span><span class="s2">} </span><span class="s3">&quot;</span>
                    <span class="s3">f&quot;is &gt; 1 char long, and the '</span><span class="s2">{</span><span class="s1">engine</span><span class="s2">}</span><span class="s3">' engine &quot;</span>
                    <span class="s3">&quot;does not support such separators&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s3">&quot;python&quot;</span>

        <span class="s1">quotechar = options[</span><span class="s3">&quot;quotechar&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">quotechar </span><span class="s2">is not None and </span><span class="s1">isinstance(quotechar</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">bytes)):</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">len(quotechar) == </span><span class="s4">1</span>
                <span class="s2">and </span><span class="s1">ord(quotechar) &gt; </span><span class="s4">127</span>
                <span class="s2">and </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;python&quot;</span><span class="s2">, </span><span class="s3">&quot;python-fwf&quot;</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">fallback_reason = (</span>
                    <span class="s3">&quot;ord(quotechar) &gt; 127, meaning the &quot;</span>
                    <span class="s3">&quot;quotechar is larger than one byte, &quot;</span>
                    <span class="s3">f&quot;and the '</span><span class="s2">{</span><span class="s1">engine</span><span class="s2">}</span><span class="s3">' engine does not support such quotechars&quot;</span>
                <span class="s1">)</span>
                <span class="s1">engine = </span><span class="s3">&quot;python&quot;</span>

        <span class="s2">if </span><span class="s1">fallback_reason </span><span class="s2">and </span><span class="s1">self._engine_specified:</span>
            <span class="s2">raise </span><span class="s1">ValueError(fallback_reason)</span>

        <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">_c_unsupported:</span>
                <span class="s2">del </span><span class="s1">result[arg]</span>

        <span class="s2">if </span><span class="s3">&quot;python&quot; </span><span class="s2">in </span><span class="s1">engine:</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">_python_unsupported:</span>
                <span class="s2">if </span><span class="s1">fallback_reason </span><span class="s2">and </span><span class="s1">result[arg] != _c_parser_defaults[arg]:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Falling back to the 'python' engine because &quot;</span>
                        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">fallback_reason</span><span class="s2">}</span><span class="s3">, but this causes </span><span class="s2">{</span><span class="s1">repr(arg)</span><span class="s2">} </span><span class="s3">to be &quot;</span>
                        <span class="s3">&quot;ignored as it is not supported by the 'python' engine.&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">del </span><span class="s1">result[arg]</span>

        <span class="s2">if </span><span class="s1">fallback_reason:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">(</span>
                    <span class="s3">&quot;Falling back to the 'python' engine because &quot;</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">fallback_reason</span><span class="s2">}</span><span class="s3">; you can avoid this warning by specifying &quot;</span>
                    <span class="s3">&quot;engine='python'.&quot;</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">ParserWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">index_col = options[</span><span class="s3">&quot;index_col&quot;</span><span class="s1">]</span>
        <span class="s1">names = options[</span><span class="s3">&quot;names&quot;</span><span class="s1">]</span>
        <span class="s1">converters = options[</span><span class="s3">&quot;converters&quot;</span><span class="s1">]</span>
        <span class="s1">na_values = options[</span><span class="s3">&quot;na_values&quot;</span><span class="s1">]</span>
        <span class="s1">skiprows = options[</span><span class="s3">&quot;skiprows&quot;</span><span class="s1">]</span>

        <span class="s1">validate_header_arg(options[</span><span class="s3">&quot;header&quot;</span><span class="s1">])</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">_deprecated_defaults.keys():</span>
            <span class="s1">parser_default = _c_parser_defaults.get(arg</span><span class="s2">, </span><span class="s1">parser_defaults[arg])</span>
            <span class="s1">depr_default = _deprecated_defaults[arg]</span>
            <span class="s2">if </span><span class="s1">result.get(arg</span><span class="s2">, </span><span class="s1">depr_default) != depr_default.default_value:</span>
                <span class="s1">msg = (</span>
                    <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">} </span><span class="s3">argument has been deprecated and will be &quot;</span>
                    <span class="s3">f&quot;removed in a future version. </span><span class="s2">{</span><span class="s1">depr_default.msg</span><span class="s2">}\n\n</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
                <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel=find_stack_level())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result[arg] = parser_default</span>

        <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The value of index_col couldn't be 'True'&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">is_index_col(index_col):</span>
            <span class="s2">if not </span><span class="s1">isinstance(index_col</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray)):</span>
                <span class="s1">index_col = [index_col]</span>
        <span class="s1">result[</span><span class="s3">&quot;index_col&quot;</span><span class="s1">] = index_col</span>

        <span class="s1">names = list(names) </span><span class="s2">if </span><span class="s1">names </span><span class="s2">is not None else </span><span class="s1">names</span>

        <span class="s5"># type conversion-related</span>
        <span class="s2">if </span><span class="s1">converters </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(converters</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Type converters must be a dict or subclass, &quot;</span>
                    <span class="s3">f&quot;input was a </span><span class="s2">{</span><span class="s1">type(converters).__name__</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">converters = {}</span>

        <span class="s5"># Converting values to NA</span>
        <span class="s1">keep_default_na = options[</span><span class="s3">&quot;keep_default_na&quot;</span><span class="s1">]</span>
        <span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues = _clean_na_values(na_values</span><span class="s2">, </span><span class="s1">keep_default_na)</span>

        <span class="s5"># handle skiprows; this is internally handled by the</span>
        <span class="s5"># c-engine, so only need for python and pyarrow parsers</span>
        <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">is_integer(skiprows) </span><span class="s2">and </span><span class="s1">skiprows </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s5"># pyarrow expects skiprows to be passed as an integer</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;skiprows argument must be an integer when using &quot;</span>
                    <span class="s3">&quot;engine='pyarrow'&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">is_integer(skiprows):</span>
                <span class="s1">skiprows = list(range(skiprows))</span>
            <span class="s2">if </span><span class="s1">skiprows </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">skiprows = set()</span>
            <span class="s2">elif not </span><span class="s1">callable(skiprows):</span>
                <span class="s1">skiprows = set(skiprows)</span>

        <span class="s5"># put stuff back</span>
        <span class="s1">result[</span><span class="s3">&quot;names&quot;</span><span class="s1">] = names</span>
        <span class="s1">result[</span><span class="s3">&quot;converters&quot;</span><span class="s1">] = converters</span>
        <span class="s1">result[</span><span class="s3">&quot;na_values&quot;</span><span class="s1">] = na_values</span>
        <span class="s1">result[</span><span class="s3">&quot;na_fvalues&quot;</span><span class="s1">] = na_fvalues</span>
        <span class="s1">result[</span><span class="s3">&quot;skiprows&quot;</span><span class="s1">] = skiprows</span>
        <span class="s5"># Default for squeeze is none since we need to check</span>
        <span class="s5"># if user sets it. We then set to False to preserve</span>
        <span class="s5"># previous behavior.</span>
        <span class="s1">result[</span><span class="s3">&quot;squeeze&quot;</span><span class="s1">] = </span><span class="s2">False if </span><span class="s1">options[</span><span class="s3">&quot;squeeze&quot;</span><span class="s1">] </span><span class="s2">is None else </span><span class="s1">options[</span><span class="s3">&quot;squeeze&quot;</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">engine</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.get_chunk()</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_make_engine(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">f: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str] | list | IO</span><span class="s2">,</span>
        <span class="s1">engine: CSVEngine = </span><span class="s3">&quot;c&quot;</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">mapping: dict[str</span><span class="s2">, </span><span class="s1">type[ParserBase]] = {</span>
            <span class="s3">&quot;c&quot;</span><span class="s1">: CParserWrapper</span><span class="s2">,</span>
            <span class="s3">&quot;python&quot;</span><span class="s1">: PythonParser</span><span class="s2">,</span>
            <span class="s3">&quot;pyarrow&quot;</span><span class="s1">: ArrowParserWrapper</span><span class="s2">,</span>
            <span class="s3">&quot;python-fwf&quot;</span><span class="s1">: FixedWidthFieldParser</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">engine </span><span class="s2">not in </span><span class="s1">mapping:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Unknown engine: </span><span class="s2">{</span><span class="s1">engine</span><span class="s2">} </span><span class="s3">(valid options are </span><span class="s2">{</span><span class="s1">mapping.keys()</span><span class="s2">}</span><span class="s3">)&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s5"># open file here</span>
            <span class="s1">is_text = </span><span class="s2">True</span>
            <span class="s1">mode = </span><span class="s3">&quot;r&quot;</span>
            <span class="s2">if </span><span class="s1">engine == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
                <span class="s1">is_text = </span><span class="s2">False</span>
                <span class="s1">mode = </span><span class="s3">&quot;rb&quot;</span>
            <span class="s5"># error: No overload variant of &quot;get_handle&quot; matches argument types</span>
            <span class="s5"># &quot;Union[str, PathLike[str], ReadCsvBuffer[bytes], ReadCsvBuffer[str]]&quot;</span>
            <span class="s5"># , &quot;str&quot;, &quot;bool&quot;, &quot;Any&quot;, &quot;Any&quot;, &quot;Any&quot;, &quot;Any&quot;, &quot;Any&quot;</span>
            <span class="s1">self.handles = get_handle(  </span><span class="s5"># type: ignore[call-overload]</span>
                <span class="s1">f</span><span class="s2">,</span>
                <span class="s1">mode</span><span class="s2">,</span>
                <span class="s1">encoding=self.options.get(</span><span class="s3">&quot;encoding&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">compression=self.options.get(</span><span class="s3">&quot;compression&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">memory_map=self.options.get(</span><span class="s3">&quot;memory_map&quot;</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">is_text=is_text</span><span class="s2">,</span>
                <span class="s1">errors=self.options.get(</span><span class="s3">&quot;encoding_errors&quot;</span><span class="s2">, </span><span class="s3">&quot;strict&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">storage_options=self.options.get(</span><span class="s3">&quot;storage_options&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">self.handles </span><span class="s2">is not None</span>
            <span class="s1">f = self.handles.handle</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">mapping[engine](f</span><span class="s2">, </span><span class="s1">**self.options)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">if </span><span class="s1">self.handles </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.handles.close()</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_failover_to_python(self):</span>
        <span class="s2">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.engine == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">df = self._engine.read()</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nrows = validate_integer(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, </span><span class="s1">nrows)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_dict = self._engine.read(nrows)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise</span>

            <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">col_dict:</span>
                    <span class="s5"># Any column is actually fine:</span>
                    <span class="s1">new_rows = len(next(iter(col_dict.values())))</span>
                    <span class="s1">index = RangeIndex(self._currow</span><span class="s2">, </span><span class="s1">self._currow + new_rows)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">new_rows = </span><span class="s4">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_rows = len(index)</span>

            <span class="s1">df = DataFrame(col_dict</span><span class="s2">, </span><span class="s1">columns=columns</span><span class="s2">, </span><span class="s1">index=index)</span>

            <span class="s1">self._currow += new_rows</span>

        <span class="s2">if </span><span class="s1">self.squeeze </span><span class="s2">and </span><span class="s1">len(df.columns) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">df.squeeze(</span><span class="s3">&quot;columns&quot;</span><span class="s1">).copy()</span>
        <span class="s2">return </span><span class="s1">df</span>

    <span class="s2">def </span><span class="s1">get_chunk(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">size = self.chunksize</span>
        <span class="s2">if </span><span class="s1">self.nrows </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._currow &gt;= self.nrows:</span>
                <span class="s2">raise </span><span class="s1">StopIteration</span>
            <span class="s1">size = min(size</span><span class="s2">, </span><span class="s1">self.nrows - self._currow)</span>
        <span class="s2">return </span><span class="s1">self.read(nrows=size)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">exc_type</span><span class="s2">, </span><span class="s1">exc_value</span><span class="s2">, </span><span class="s1">traceback):</span>
        <span class="s1">self.close()</span>


<span class="s2">def </span><span class="s1">TextParser(*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
    <span class="s0">&quot;&quot;&quot; 
    Converts lists of lists/tuples into DataFrames with proper type inference 
    and optional (e.g. string to datetime) conversion. Also enables iterating 
    lazily over chunks of large files 
 
    Parameters 
    ---------- 
    data : file-like object or list 
    delimiter : separator character to use 
    dialect : str or csv.Dialect instance, optional 
        Ignored if delimiter is longer than 1 character 
    names : sequence, default 
    header : int, default 0 
        Row to use to parse column labels. Defaults to the first row. Prior 
        rows will be discarded 
    index_col : int or list, optional 
        Column or columns to use as the (possibly hierarchical) index 
    has_index_names: bool, default False 
        True if the cols defined in index_col have an index name and are 
        not in the header. 
    na_values : scalar, str, list-like, or dict, optional 
        Additional strings to recognize as NA/NaN. 
    keep_default_na : bool, default True 
    thousands : str, optional 
        Thousands separator 
    comment : str, optional 
        Comment out remainder of line 
    parse_dates : bool, default False 
    keep_date_col : bool, default False 
    date_parser : function, optional 
    skiprows : list of integers 
        Row numbers to skip 
    skipfooter : int 
        Number of line at bottom of file to skip 
    converters : dict, optional 
        Dict of functions for converting values in certain columns. Keys can 
        either be integers or column labels, values are functions that take one 
        input argument, the cell (not column) content, and return the 
        transformed content. 
    encoding : str, optional 
        Encoding to use for UTF when reading/writing (ex. 'utf-8') 
    squeeze : bool, default False 
        returns Series if only one column. 
    infer_datetime_format: bool, default False 
        If True and `parse_dates` is True for a column, try to infer the 
        datetime format based on the first datetime string. If the format 
        can be inferred, there often will be a large parsing speed-up. 
    float_precision : str, optional 
        Specifies which converter the C engine should use for floating-point 
        values. The options are `None` or `high` for the ordinary converter, 
        `legacy` for the original lower precision pandas converter, and 
        `round_trip` for the round-trip converter. 
 
        .. versionchanged:: 1.2 
    &quot;&quot;&quot;</span>
    <span class="s1">kwds[</span><span class="s3">&quot;engine&quot;</span><span class="s1">] = </span><span class="s3">&quot;python&quot;</span>
    <span class="s2">return </span><span class="s1">TextFileReader(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>


<span class="s2">def </span><span class="s1">_clean_na_values(na_values</span><span class="s2">, </span><span class="s1">keep_default_na=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s1">na_fvalues: set | dict</span>
    <span class="s2">if </span><span class="s1">na_values </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">keep_default_na:</span>
            <span class="s1">na_values = STR_NA_VALUES</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">na_values = set()</span>
        <span class="s1">na_fvalues = set()</span>
    <span class="s2">elif </span><span class="s1">isinstance(na_values</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s1">old_na_values = na_values.copy()</span>
        <span class="s1">na_values = {}  </span><span class="s5"># Prevent aliasing.</span>

        <span class="s5"># Convert the values in the na_values dictionary</span>
        <span class="s5"># into array-likes for further use. This is also</span>
        <span class="s5"># where we append the default NaN values, provided</span>
        <span class="s5"># that `keep_default_na=True`.</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">old_na_values.items():</span>
            <span class="s2">if not </span><span class="s1">is_list_like(v):</span>
                <span class="s1">v = [v]</span>

            <span class="s2">if </span><span class="s1">keep_default_na:</span>
                <span class="s1">v = set(v) | STR_NA_VALUES</span>

            <span class="s1">na_values[k] = v</span>
        <span class="s1">na_fvalues = {k: _floatify_na_values(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">na_values.items()}</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">is_list_like(na_values):</span>
            <span class="s1">na_values = [na_values]</span>
        <span class="s1">na_values = _stringify_na_values(na_values)</span>
        <span class="s2">if </span><span class="s1">keep_default_na:</span>
            <span class="s1">na_values = na_values | STR_NA_VALUES</span>

        <span class="s1">na_fvalues = _floatify_na_values(na_values)</span>

    <span class="s2">return </span><span class="s1">na_values</span><span class="s2">, </span><span class="s1">na_fvalues</span>


<span class="s2">def </span><span class="s1">_floatify_na_values(na_values):</span>
    <span class="s5"># create float versions of the na_values</span>
    <span class="s1">result = set()</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">na_values:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">v = float(v)</span>
            <span class="s2">if not </span><span class="s1">np.isnan(v):</span>
                <span class="s1">result.add(v)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_stringify_na_values(na_values):</span>
    <span class="s0">&quot;&quot;&quot;return a stringified and numeric for these values&quot;&quot;&quot;</span>
    <span class="s1">result: list[int | str | float] = []</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">na_values:</span>
        <span class="s1">result.append(str(x))</span>
        <span class="s1">result.append(x)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">v = float(x)</span>

            <span class="s5"># we are like 999 here</span>
            <span class="s2">if </span><span class="s1">v == int(v):</span>
                <span class="s1">v = int(v)</span>
                <span class="s1">result.append(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s3">.0&quot;</span><span class="s1">)</span>
                <span class="s1">result.append(str(v))</span>

            <span class="s1">result.append(v)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">pass</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">result.append(int(x))</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">set(result)</span>


<span class="s2">def </span><span class="s1">_refine_defaults_read(</span>
    <span class="s1">dialect: str | csv.Dialect</span><span class="s2">,</span>
    <span class="s1">delimiter: str | object</span><span class="s2">,</span>
    <span class="s1">delim_whitespace: bool</span><span class="s2">,</span>
    <span class="s1">engine: CSVEngine | </span><span class="s2">None,</span>
    <span class="s1">sep: str | object</span><span class="s2">,</span>
    <span class="s1">error_bad_lines: bool | </span><span class="s2">None,</span>
    <span class="s1">warn_bad_lines: bool | </span><span class="s2">None,</span>
    <span class="s1">on_bad_lines: str | Callable | </span><span class="s2">None,</span>
    <span class="s1">names: ArrayLike | </span><span class="s2">None </span><span class="s1">| object</span><span class="s2">,</span>
    <span class="s1">prefix: str | </span><span class="s2">None </span><span class="s1">| object</span><span class="s2">,</span>
    <span class="s1">defaults: dict[str</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Validate/refine default values of input parameters of read_csv, read_table. 
 
    Parameters 
    ---------- 
    dialect : str or csv.Dialect 
        If provided, this parameter will override values (default or not) for the 
        following parameters: `delimiter`, `doublequote`, `escapechar`, 
        `skipinitialspace`, `quotechar`, and `quoting`. If it is necessary to 
        override values, a ParserWarning will be issued. See csv.Dialect 
        documentation for more details. 
    delimiter : str or object 
        Alias for sep. 
    delim_whitespace : bool 
        Specifies whether or not whitespace (e.g. ``' '`` or ``'\t'``) will be 
        used as the sep. Equivalent to setting ``sep='\\s+'``. If this option 
        is set to True, nothing should be passed in for the ``delimiter`` 
        parameter. 
    engine : {{'c', 'python'}} 
        Parser engine to use. The C engine is faster while the python engine is 
        currently more feature-complete. 
    sep : str or object 
        A delimiter provided by the user (str) or a sentinel value, i.e. 
        pandas._libs.lib.no_default. 
    error_bad_lines : str or None 
        Whether to error on a bad line or not. 
    warn_bad_lines : str or None 
        Whether to warn on a bad line or not. 
    on_bad_lines : str, callable or None 
        An option for handling bad lines or a sentinel value(None). 
    names : array-like, optional 
        List of column names to use. If the file contains a header row, 
        then you should explicitly pass ``header=0`` to override the column names. 
        Duplicates in this list are not allowed. 
    prefix : str, optional 
        Prefix to add to column numbers when no header, e.g. 'X' for X0, X1, ... 
    defaults: dict 
        Default values of input parameters. 
 
    Returns 
    ------- 
    kwds : dict 
        Input parameters with correct values. 
 
    Raises 
    ------ 
    ValueError : 
        If a delimiter was specified with ``sep`` (or ``delimiter``) and 
        ``delim_whitespace=True``. 
        If on_bad_lines is specified(not ``None``) and ``error_bad_lines``/ 
        ``warn_bad_lines`` is True. 
    &quot;&quot;&quot;</span>
    <span class="s5"># fix types for sep, delimiter to Union(str, Any)</span>
    <span class="s1">delim_default = defaults[</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">]</span>
    <span class="s1">kwds: dict[str</span><span class="s2">, </span><span class="s1">Any] = {}</span>
    <span class="s5"># gh-23761</span>
    <span class="s5">#</span>
    <span class="s5"># When a dialect is passed, it overrides any of the overlapping</span>
    <span class="s5"># parameters passed in directly. We don't want to warn if the</span>
    <span class="s5"># default parameters were passed in (since it probably means</span>
    <span class="s5"># that the user didn't pass them in explicitly in the first place).</span>
    <span class="s5">#</span>
    <span class="s5"># &quot;delimiter&quot; is the annoying corner case because we alias it to</span>
    <span class="s5"># &quot;sep&quot; before doing comparison to the dialect values later on.</span>
    <span class="s5"># Thus, we need a flag to indicate that we need to &quot;override&quot;</span>
    <span class="s5"># the comparison to dialect values by checking if default values</span>
    <span class="s5"># for BOTH &quot;delimiter&quot; and &quot;sep&quot; were provided.</span>
    <span class="s2">if </span><span class="s1">dialect </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s3">&quot;sep_override&quot;</span><span class="s1">] = delimiter </span><span class="s2">is None and </span><span class="s1">(</span>
            <span class="s1">sep </span><span class="s2">is </span><span class="s1">lib.no_default </span><span class="s2">or </span><span class="s1">sep == delim_default</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">delimiter </span><span class="s2">and </span><span class="s1">(sep </span><span class="s2">is not </span><span class="s1">lib.no_default):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Specified a sep and a delimiter; you can only specify one.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">names </span><span class="s2">is not None</span>
        <span class="s2">and </span><span class="s1">names </span><span class="s2">is not </span><span class="s1">lib.no_default</span>
        <span class="s2">and </span><span class="s1">prefix </span><span class="s2">is not None</span>
        <span class="s2">and </span><span class="s1">prefix </span><span class="s2">is not </span><span class="s1">lib.no_default</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Specified named and prefix; you can only specify one.&quot;</span><span class="s1">)</span>

    <span class="s1">kwds[</span><span class="s3">&quot;names&quot;</span><span class="s1">] = </span><span class="s2">None if </span><span class="s1">names </span><span class="s2">is </span><span class="s1">lib.no_default </span><span class="s2">else </span><span class="s1">names</span>
    <span class="s1">kwds[</span><span class="s3">&quot;prefix&quot;</span><span class="s1">] = </span><span class="s2">None if </span><span class="s1">prefix </span><span class="s2">is </span><span class="s1">lib.no_default </span><span class="s2">else </span><span class="s1">prefix</span>

    <span class="s5"># Alias sep -&gt; delimiter.</span>
    <span class="s2">if </span><span class="s1">delimiter </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">delimiter = sep</span>

    <span class="s2">if </span><span class="s1">delim_whitespace </span><span class="s2">and </span><span class="s1">(delimiter </span><span class="s2">is not </span><span class="s1">lib.no_default):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Specified a delimiter with both sep and &quot;</span>
            <span class="s3">&quot;delim_whitespace=True; you can only specify one.&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">delimiter == </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">r&quot;Specified \n as separator or delimiter. This forces the python engine &quot;</span>
            <span class="s3">&quot;which does not accept a line terminator. Hence it is not allowed to use &quot;</span>
            <span class="s3">&quot;the line terminator as separator.&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">delimiter </span><span class="s2">is </span><span class="s1">lib.no_default:</span>
        <span class="s5"># assign default separator value</span>
        <span class="s1">kwds[</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">] = delim_default</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">] = delimiter</span>

    <span class="s2">if </span><span class="s1">engine </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s3">&quot;engine_specified&quot;</span><span class="s1">] = </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">kwds[</span><span class="s3">&quot;engine&quot;</span><span class="s1">] = </span><span class="s3">&quot;c&quot;</span>
        <span class="s1">kwds[</span><span class="s3">&quot;engine_specified&quot;</span><span class="s1">] = </span><span class="s2">False</span>

    <span class="s5"># Ensure that on_bad_lines and error_bad_lines/warn_bad_lines</span>
    <span class="s5"># aren't specified at the same time. If so, raise. Otherwise,</span>
    <span class="s5"># alias on_bad_lines to &quot;error&quot; if error/warn_bad_lines not set</span>
    <span class="s5"># and on_bad_lines is not set. on_bad_lines is defaulted to None</span>
    <span class="s5"># so we can tell if it is set (this is why this hack exists).</span>
    <span class="s2">if </span><span class="s1">on_bad_lines </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">error_bad_lines </span><span class="s2">is not None or </span><span class="s1">warn_bad_lines </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Both on_bad_lines and error_bad_lines/warn_bad_lines are set. &quot;</span>
                <span class="s3">&quot;Please only set on_bad_lines.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">on_bad_lines == </span><span class="s3">&quot;error&quot;</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.ERROR</span>
        <span class="s2">elif </span><span class="s1">on_bad_lines == </span><span class="s3">&quot;warn&quot;</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.WARN</span>
        <span class="s2">elif </span><span class="s1">on_bad_lines == </span><span class="s3">&quot;skip&quot;</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.SKIP</span>
        <span class="s2">elif </span><span class="s1">callable(on_bad_lines):</span>
            <span class="s2">if </span><span class="s1">engine != </span><span class="s3">&quot;python&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;on_bad_line can only be a callable function if engine='python'&quot;</span>
                <span class="s1">)</span>
            <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = on_bad_lines</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Argument </span><span class="s2">{</span><span class="s1">on_bad_lines</span><span class="s2">} </span><span class="s3">is invalid for on_bad_lines&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">error_bad_lines </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># Must check is_bool, because other stuff(e.g. non-empty lists) eval to true</span>
            <span class="s1">validate_bool_kwarg(error_bad_lines</span><span class="s2">, </span><span class="s3">&quot;error_bad_lines&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">error_bad_lines:</span>
                <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.ERROR</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">warn_bad_lines </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s5"># This is the case where error_bad_lines is False</span>
                    <span class="s5"># We can only warn/skip if error_bad_lines is False</span>
                    <span class="s5"># None doesn't work because backwards-compatibility reasons</span>
                    <span class="s1">validate_bool_kwarg(warn_bad_lines</span><span class="s2">, </span><span class="s3">&quot;warn_bad_lines&quot;</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">warn_bad_lines:</span>
                        <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.WARN</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.SKIP</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># Backwards compat, when only error_bad_lines = false, we warn</span>
                    <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.WARN</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Everything None -&gt; Error</span>
            <span class="s1">kwds[</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">] = ParserBase.BadLineHandleMethod.ERROR</span>

    <span class="s2">return </span><span class="s1">kwds</span>


<span class="s2">def </span><span class="s1">_extract_dialect(kwds: dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; csv.Dialect | </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract concrete csv dialect instance. 
 
    Returns 
    ------- 
    csv.Dialect or None 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;dialect&quot;</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return None</span>

    <span class="s1">dialect = kwds[</span><span class="s3">&quot;dialect&quot;</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">dialect </span><span class="s2">in </span><span class="s1">csv.list_dialects():</span>
        <span class="s1">dialect = csv.get_dialect(dialect)</span>

    <span class="s1">_validate_dialect(dialect)</span>

    <span class="s2">return </span><span class="s1">dialect</span>


<span class="s1">MANDATORY_DIALECT_ATTRS = (</span>
    <span class="s3">&quot;delimiter&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;doublequote&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;escapechar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;skipinitialspace&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;quotechar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;quoting&quot;</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_validate_dialect(dialect: csv.Dialect) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Validate csv dialect instance. 
 
    Raises 
    ------ 
    ValueError 
        If incorrect dialect is provided. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">MANDATORY_DIALECT_ATTRS:</span>
        <span class="s2">if not </span><span class="s1">hasattr(dialect</span><span class="s2">, </span><span class="s1">param):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Invalid dialect </span><span class="s2">{</span><span class="s1">dialect</span><span class="s2">} </span><span class="s3">provided&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_merge_with_dialect_properties(</span>
    <span class="s1">dialect: csv.Dialect</span><span class="s2">,</span>
    <span class="s1">defaults: dict[str</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
<span class="s1">) -&gt; dict[str</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Merge default kwargs in TextFileReader with dialect parameters. 
 
    Parameters 
    ---------- 
    dialect : csv.Dialect 
        Concrete csv dialect. See csv.Dialect documentation for more details. 
    defaults : dict 
        Keyword arguments passed to TextFileReader. 
 
    Returns 
    ------- 
    kwds : dict 
        Updated keyword arguments, merged with dialect parameters. 
    &quot;&quot;&quot;</span>
    <span class="s1">kwds = defaults.copy()</span>

    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">MANDATORY_DIALECT_ATTRS:</span>
        <span class="s1">dialect_val = getattr(dialect</span><span class="s2">, </span><span class="s1">param)</span>

        <span class="s1">parser_default = parser_defaults[param]</span>
        <span class="s1">provided = kwds.get(param</span><span class="s2">, </span><span class="s1">parser_default)</span>

        <span class="s5"># Messages for conflicting values between the dialect</span>
        <span class="s5"># instance and the actual parameters provided.</span>
        <span class="s1">conflict_msgs = []</span>

        <span class="s5"># Don't warn if the default parameter was passed in,</span>
        <span class="s5"># even if it conflicts with the dialect (gh-23761).</span>
        <span class="s2">if </span><span class="s1">provided != parser_default </span><span class="s2">and </span><span class="s1">provided != dialect_val:</span>
            <span class="s1">msg = (</span>
                <span class="s3">f&quot;Conflicting values for '</span><span class="s2">{</span><span class="s1">param</span><span class="s2">}</span><span class="s3">': '</span><span class="s2">{</span><span class="s1">provided</span><span class="s2">}</span><span class="s3">' was &quot;</span>
                <span class="s3">f&quot;provided, but the dialect specifies '</span><span class="s2">{</span><span class="s1">dialect_val</span><span class="s2">}</span><span class="s3">'. &quot;</span>
                <span class="s3">&quot;Using the dialect-specified value.&quot;</span>
            <span class="s1">)</span>

            <span class="s5"># Annoying corner case for not warning about</span>
            <span class="s5"># conflicts between dialect and delimiter parameter.</span>
            <span class="s5"># Refer to the outer &quot;_read_&quot; function for more info.</span>
            <span class="s2">if not </span><span class="s1">(param == </span><span class="s3">&quot;delimiter&quot; </span><span class="s2">and </span><span class="s1">kwds.pop(</span><span class="s3">&quot;sep_override&quot;</span><span class="s2">, False</span><span class="s1">)):</span>
                <span class="s1">conflict_msgs.append(msg)</span>

        <span class="s2">if </span><span class="s1">conflict_msgs:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">.join(conflict_msgs)</span><span class="s2">, </span><span class="s1">ParserWarning</span><span class="s2">, </span><span class="s1">stacklevel=find_stack_level()</span>
            <span class="s1">)</span>
        <span class="s1">kwds[param] = dialect_val</span>
    <span class="s2">return </span><span class="s1">kwds</span>


<span class="s2">def </span><span class="s1">_validate_skipfooter(kwds: dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether skipfooter is compatible with other kwargs in TextFileReader. 
 
    Parameters 
    ---------- 
    kwds : dict 
        Keyword arguments passed to TextFileReader. 
 
    Raises 
    ------ 
    ValueError 
        If skipfooter is not compatible with other parameters. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;skipfooter&quot;</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;iterator&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">kwds.get(</span><span class="s3">&quot;chunksize&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'skipfooter' not supported for iteration&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;nrows&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'skipfooter' not supported with 'nrows'&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>