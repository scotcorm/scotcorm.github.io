<html>
<head>
<title>test_get_set.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_get_set.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">DatetimeTZDtype</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CategoricalIndex</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>


<span class="s0">def </span><span class="s1">assert_matching(actual</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s2"># avoid specifying internal representation</span>
    <span class="s2"># as much as possible</span>
    <span class="s0">assert </span><span class="s1">len(actual) == len(expected)</span>
    <span class="s0">for </span><span class="s1">act</span><span class="s0">, </span><span class="s1">exp </span><span class="s0">in </span><span class="s1">zip(actual</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s1">act = np.asarray(act)</span>
        <span class="s1">exp = np.asarray(exp)</span>
        <span class="s1">tm.assert_numpy_array_equal(act</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype)</span>


<span class="s0">def </span><span class="s1">test_get_level_number_integer(idx):</span>
    <span class="s1">idx.names = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">idx._get_level_number(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">idx._get_level_number(</span><span class="s3">0</span><span class="s1">) == </span><span class="s3">1</span>
    <span class="s1">msg = </span><span class="s4">&quot;Too many levels: Index has only 2 levels, not 3&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">idx._get_level_number(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Level fourth not found&quot;</span><span class="s1">):</span>
        <span class="s1">idx._get_level_number(</span><span class="s4">&quot;fourth&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_get_dtypes():</span>
    <span class="s2"># Test MultiIndex.dtypes (# Gh37062)</span>
    <span class="s1">idx_multitype = MultiIndex.from_product(</span>
        <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.date_range(</span><span class="s4">&quot;20200101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">tz=</span><span class="s4">&quot;UTC&quot;</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s4">&quot;int&quot;</span><span class="s0">, </span><span class="s4">&quot;string&quot;</span><span class="s0">, </span><span class="s4">&quot;dt&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">{</span>
            <span class="s4">&quot;int&quot;</span><span class="s1">: np.dtype(</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">&quot;string&quot;</span><span class="s1">: np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">&quot;dt&quot;</span><span class="s1">: DatetimeTZDtype(tz=</span><span class="s4">&quot;utc&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(expected</span><span class="s0">, </span><span class="s1">idx_multitype.dtypes)</span>


<span class="s0">def </span><span class="s1">test_get_dtypes_no_level_name():</span>
    <span class="s2"># Test MultiIndex.dtypes (# GH38580 )</span>
    <span class="s1">idx_multitype = MultiIndex.from_product(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">pd.date_range(</span><span class="s4">&quot;20200101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">tz=</span><span class="s4">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">{</span>
            <span class="s4">&quot;level_0&quot;</span><span class="s1">: np.dtype(</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">&quot;level_1&quot;</span><span class="s1">: np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">&quot;level_2&quot;</span><span class="s1">: DatetimeTZDtype(tz=</span><span class="s4">&quot;utc&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(expected</span><span class="s0">, </span><span class="s1">idx_multitype.dtypes)</span>


<span class="s0">def </span><span class="s1">test_get_dtypes_duplicate_level_names():</span>
    <span class="s2"># Test MultiIndex.dtypes with non-unique level names (# GH45174)</span>
    <span class="s1">result = MultiIndex.from_product(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">pd.date_range(</span><span class="s4">&quot;20200101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">tz=</span><span class="s4">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s4">&quot;A&quot;</span><span class="s0">, </span><span class="s4">&quot;A&quot;</span><span class="s0">, </span><span class="s4">&quot;A&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">).dtypes</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[np.dtype(</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s4">&quot;O&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">DatetimeTZDtype(tz=</span><span class="s4">&quot;utc&quot;</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s4">&quot;A&quot;</span><span class="s0">, </span><span class="s4">&quot;A&quot;</span><span class="s0">, </span><span class="s4">&quot;A&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_get_level_number_out_of_bounds(multiindex_dataframe_random_data):</span>
    <span class="s1">frame = multiindex_dataframe_random_data</span>

    <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Too many levels&quot;</span><span class="s1">):</span>
        <span class="s1">frame.index._get_level_number(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;not a valid level number&quot;</span><span class="s1">):</span>
        <span class="s1">frame.index._get_level_number(-</span><span class="s3">3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_name_methods(idx</span><span class="s0">, </span><span class="s1">index_names):</span>
    <span class="s2"># so long as these are synonyms, we don't need to test set_names</span>
    <span class="s0">assert </span><span class="s1">idx.rename == idx.set_names</span>
    <span class="s1">new_names = [name + </span><span class="s4">&quot;SUFFIX&quot; </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">index_names]</span>
    <span class="s1">ind = idx.set_names(new_names)</span>
    <span class="s0">assert </span><span class="s1">idx.names == index_names</span>
    <span class="s0">assert </span><span class="s1">ind.names == new_names</span>
    <span class="s1">msg = </span><span class="s4">&quot;Length of names must match number of levels in MultiIndex&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ind.set_names(new_names + new_names)</span>
    <span class="s1">new_names2 = [name + </span><span class="s4">&quot;SUFFIX2&quot; </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">new_names]</span>
    <span class="s1">res = ind.set_names(new_names2</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">ind.names == new_names2</span>

    <span class="s2"># set names for specific level (# GH7792)</span>
    <span class="s1">ind = idx.set_names(new_names[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">idx.names == index_names</span>
    <span class="s0">assert </span><span class="s1">ind.names == [new_names[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_names[</span><span class="s3">1</span><span class="s1">]]</span>

    <span class="s1">res = ind.set_names(new_names2[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">ind.names == [new_names2[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_names[</span><span class="s3">1</span><span class="s1">]]</span>

    <span class="s2"># set names for multiple levels</span>
    <span class="s1">ind = idx.set_names(new_names</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">idx.names == index_names</span>
    <span class="s0">assert </span><span class="s1">ind.names == new_names</span>

    <span class="s1">res = ind.set_names(new_names2</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">ind.names == new_names2</span>


<span class="s0">def </span><span class="s1">test_set_levels_codes_directly(idx):</span>
    <span class="s2"># setting levels/codes directly raises AttributeError</span>

    <span class="s1">levels = idx.levels</span>
    <span class="s1">new_levels = [[lev + </span><span class="s4">&quot;a&quot; </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level] </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">levels]</span>

    <span class="s1">codes = idx.codes</span>
    <span class="s1">major_codes</span><span class="s0">, </span><span class="s1">minor_codes = codes</span>
    <span class="s1">major_codes = [(x + </span><span class="s3">1</span><span class="s1">) % </span><span class="s3">3 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">major_codes]</span>
    <span class="s1">minor_codes = [(x + </span><span class="s3">1</span><span class="s1">) % </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">minor_codes]</span>
    <span class="s1">new_codes = [major_codes</span><span class="s0">, </span><span class="s1">minor_codes]</span>

    <span class="s1">msg = </span><span class="s4">&quot;[Cc]an't set attribute&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">idx.levels = new_levels</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">idx.codes = new_codes</span>


<span class="s0">def </span><span class="s1">test_set_levels(idx):</span>
    <span class="s2"># side note - you probably wouldn't want to use levels and codes</span>
    <span class="s2"># directly like this - but it is possible.</span>
    <span class="s1">levels = idx.levels</span>
    <span class="s1">new_levels = [[lev + </span><span class="s4">&quot;a&quot; </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level] </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">levels]</span>

    <span class="s2"># level changing [w/o mutation]</span>
    <span class="s1">ind2 = idx.set_levels(new_levels)</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">new_levels)</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s2"># level changing [w/ mutation]</span>
    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_levels(new_levels</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">new_levels)</span>

    <span class="s2"># level changing specific level [w/o mutation]</span>
    <span class="s1">ind2 = idx.set_levels(new_levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">[new_levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">levels[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s1">ind2 = idx.set_levels(new_levels[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">[levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">new_levels[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s2"># level changing multiple levels [w/o mutation]</span>
    <span class="s1">ind2 = idx.set_levels(new_levels</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">new_levels)</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s2"># level changing specific level [w/ mutation]</span>
    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_levels(new_levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">[new_levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">levels[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_levels(new_levels[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">[levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">new_levels[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s2"># level changing multiple levels [w/ mutation]</span>
    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_levels(new_levels</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.levels</span><span class="s0">, </span><span class="s1">new_levels)</span>
    <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">levels)</span>

    <span class="s2"># illegal level changing should not change levels</span>
    <span class="s2"># GH 13754</span>
    <span class="s1">original_index = idx.copy()</span>
    <span class="s0">for </span><span class="s1">inplace </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^On&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
                <span class="s1">idx.set_levels([</span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>
        <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">original_index.levels</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^On&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
                <span class="s1">idx.set_codes([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>
        <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">original_index.codes</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^Levels&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
                <span class="s1">idx.set_levels(</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>
        <span class="s1">assert_matching(idx.levels</span><span class="s0">, </span><span class="s1">original_index.levels</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^Codes&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
                <span class="s1">idx.set_codes(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>
        <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">original_index.codes</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_codes(idx):</span>
    <span class="s2"># side note - you probably wouldn't want to use levels and codes</span>
    <span class="s2"># directly like this - but it is possible.</span>
    <span class="s1">codes = idx.codes</span>
    <span class="s1">major_codes</span><span class="s0">, </span><span class="s1">minor_codes = codes</span>
    <span class="s1">major_codes = [(x + </span><span class="s3">1</span><span class="s1">) % </span><span class="s3">3 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">major_codes]</span>
    <span class="s1">minor_codes = [(x + </span><span class="s3">1</span><span class="s1">) % </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">minor_codes]</span>
    <span class="s1">new_codes = [major_codes</span><span class="s0">, </span><span class="s1">minor_codes]</span>

    <span class="s2"># changing codes w/o mutation</span>
    <span class="s1">ind2 = idx.set_codes(new_codes)</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">new_codes)</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s2"># changing label w/ mutation</span>
    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_codes(new_codes</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">new_codes)</span>

    <span class="s2"># codes changing specific level w/o mutation</span>
    <span class="s1">ind2 = idx.set_codes(new_codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">[new_codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">codes[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s1">ind2 = idx.set_codes(new_codes[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">[codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">new_codes[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s2"># codes changing multiple levels w/o mutation</span>
    <span class="s1">ind2 = idx.set_codes(new_codes</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">new_codes)</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s2"># label changing specific level w/ mutation</span>
    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_codes(new_codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">[new_codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">codes[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_codes(new_codes[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">[codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">new_codes[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s2"># codes changing multiple levels [w/ mutation]</span>
    <span class="s1">ind2 = idx.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">inplace_return = ind2.set_codes(new_codes</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">inplace_return </span><span class="s0">is None</span>
    <span class="s1">assert_matching(ind2.codes</span><span class="s0">, </span><span class="s1">new_codes)</span>
    <span class="s1">assert_matching(idx.codes</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s2"># label changing for levels of different magnitude of categories</span>
    <span class="s1">ind = MultiIndex.from_tuples([(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">130</span><span class="s1">)])</span>
    <span class="s1">new_codes = range(</span><span class="s3">129</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">expected = MultiIndex.from_tuples([(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">new_codes])</span>

    <span class="s2"># [w/o mutation]</span>
    <span class="s1">result = ind.set_codes(codes=new_codes</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result.equals(expected)</span>

    <span class="s2"># [w/ mutation]</span>
    <span class="s1">result = ind.copy()</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">result.set_codes(codes=new_codes</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result.equals(expected)</span>


<span class="s0">def </span><span class="s1">test_set_levels_codes_names_bad_input(idx):</span>
    <span class="s1">levels</span><span class="s0">, </span><span class="s1">codes = idx.levels</span><span class="s0">, </span><span class="s1">idx.codes</span>
    <span class="s1">names = idx.names</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Length of levels&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_levels([levels[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Length of codes&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_codes([codes[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Length of names&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_names([names[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s2"># shouldn't scalar data error, instead should demand list-like</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list of lists-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_levels(levels[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s2"># shouldn't scalar data error, instead should demand list-like</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list of lists-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_codes(codes[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s2"># shouldn't scalar data error, instead should demand list-like</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_names(names[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s2"># should have equal lengths</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list of lists-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_levels(levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_levels(levels</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># should have equal lengths</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list of lists-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_codes(codes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list-like&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_codes(codes</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># should have equal lengths</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Length of names&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_names(names[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Names must be a&quot;</span><span class="s1">):</span>
        <span class="s1">idx.set_names(names</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;inplace&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_names_with_nlevel_1(inplace):</span>
    <span class="s2"># GH 21149</span>
    <span class="s2"># Ensure that .set_names for MultiIndex with</span>
    <span class="s2"># nlevels == 1 does not raise any errors</span>
    <span class="s1">expected = MultiIndex(levels=[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">codes=[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s4">&quot;first&quot;</span><span class="s1">])</span>
    <span class="s1">m = MultiIndex.from_product([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">result = m.set_names(</span><span class="s4">&quot;first&quot;</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>

    <span class="s0">if </span><span class="s1">inplace:</span>
        <span class="s1">result = m</span>

    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_multi_set_names_pos_args_deprecation():</span>
    <span class="s2"># GH#41485</span>
    <span class="s1">idx = MultiIndex.from_product([[</span><span class="s4">&quot;python&quot;</span><span class="s0">, </span><span class="s4">&quot;cobra&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2018</span><span class="s0">, </span><span class="s3">2019</span><span class="s1">]])</span>
    <span class="s1">msg = (</span>
        <span class="s4">&quot;In a future version of pandas all arguments of MultiIndex.set_names &quot;</span>
        <span class="s4">&quot;except for the argument 'names' will be keyword-only&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = idx.set_names([</span><span class="s4">&quot;kind&quot;</span><span class="s0">, </span><span class="s4">&quot;year&quot;</span><span class="s1">]</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">expected = MultiIndex(</span>
        <span class="s1">levels=[[</span><span class="s4">&quot;python&quot;</span><span class="s0">, </span><span class="s4">&quot;cobra&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2018</span><span class="s0">, </span><span class="s3">2019</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">codes=[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s4">&quot;kind&quot;</span><span class="s0">, </span><span class="s4">&quot;year&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;ordered&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_levels_categorical(ordered):</span>
    <span class="s2"># GH13854</span>
    <span class="s1">index = MultiIndex.from_arrays([list(</span><span class="s4">&quot;xyzx&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]])</span>

    <span class="s1">cidx = CategoricalIndex(list(</span><span class="s4">&quot;bac&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=ordered)</span>
    <span class="s1">result = index.set_levels(cidx</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">expected = MultiIndex(levels=[cidx</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">codes=index.codes)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result_lvl = result.get_level_values(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">expected_lvl = CategoricalIndex(</span>
        <span class="s1">list(</span><span class="s4">&quot;bacb&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=cidx.categories</span><span class="s0">, </span><span class="s1">ordered=cidx.ordered</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result_lvl</span><span class="s0">, </span><span class="s1">expected_lvl)</span>


<span class="s0">def </span><span class="s1">test_set_value_keeps_names():</span>
    <span class="s2"># motivating example from #3742</span>
    <span class="s1">lev1 = [</span><span class="s4">&quot;hans&quot;</span><span class="s0">, </span><span class="s4">&quot;hans&quot;</span><span class="s0">, </span><span class="s4">&quot;hans&quot;</span><span class="s0">, </span><span class="s4">&quot;grethe&quot;</span><span class="s0">, </span><span class="s4">&quot;grethe&quot;</span><span class="s0">, </span><span class="s4">&quot;grethe&quot;</span><span class="s1">]</span>
    <span class="s1">lev2 = [</span><span class="s4">&quot;1&quot;</span><span class="s0">, </span><span class="s4">&quot;2&quot;</span><span class="s0">, </span><span class="s4">&quot;3&quot;</span><span class="s1">] * </span><span class="s3">2</span>
    <span class="s1">idx = MultiIndex.from_arrays([lev1</span><span class="s0">, </span><span class="s1">lev2]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s4">&quot;Name&quot;</span><span class="s0">, </span><span class="s4">&quot;Number&quot;</span><span class="s1">])</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">np.random.randn(</span><span class="s3">6</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s4">&quot;one&quot;</span><span class="s0">, </span><span class="s4">&quot;two&quot;</span><span class="s0">, </span><span class="s4">&quot;three&quot;</span><span class="s0">, </span><span class="s4">&quot;four&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=idx</span>
    <span class="s1">)</span>
    <span class="s1">df = df.sort_index()</span>
    <span class="s0">assert </span><span class="s1">df._is_copy </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">df.index.names == (</span><span class="s4">&quot;Name&quot;</span><span class="s0">, </span><span class="s4">&quot;Number&quot;</span><span class="s1">)</span>
    <span class="s1">df.at[(</span><span class="s4">&quot;grethe&quot;</span><span class="s0">, </span><span class="s4">&quot;4&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">] = </span><span class="s3">99.34</span>
    <span class="s0">assert </span><span class="s1">df._is_copy </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">df.index.names == (</span><span class="s4">&quot;Name&quot;</span><span class="s0">, </span><span class="s4">&quot;Number&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_levels_with_iterable():</span>
    <span class="s2"># GH23273</span>
    <span class="s1">sizes = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">colors = [</span><span class="s4">&quot;black&quot;</span><span class="s1">] * </span><span class="s3">3</span>
    <span class="s1">index = MultiIndex.from_arrays([sizes</span><span class="s0">, </span><span class="s1">colors]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s4">&quot;size&quot;</span><span class="s0">, </span><span class="s4">&quot;color&quot;</span><span class="s1">])</span>

    <span class="s1">result = index.set_levels(map(int</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;3&quot;</span><span class="s0">, </span><span class="s4">&quot;2&quot;</span><span class="s0">, </span><span class="s4">&quot;1&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">level=</span><span class="s4">&quot;size&quot;</span><span class="s1">)</span>

    <span class="s1">expected_sizes = [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">expected = MultiIndex.from_arrays([expected_sizes</span><span class="s0">, </span><span class="s1">colors]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s4">&quot;size&quot;</span><span class="s0">, </span><span class="s4">&quot;color&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;inplace&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_codes_inplace_deprecated(idx</span><span class="s0">, </span><span class="s1">inplace):</span>
    <span class="s1">new_codes = idx.codes[</span><span class="s3">1</span><span class="s1">][::-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">idx.set_codes(codes=new_codes</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;inplace&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_levels_inplace_deprecated(idx</span><span class="s0">, </span><span class="s1">inplace):</span>
    <span class="s1">new_level = idx.levels[</span><span class="s3">1</span><span class="s1">].copy()</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">idx.set_levels(levels=new_level</span><span class="s0">, </span><span class="s1">level=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>


<span class="s0">def </span><span class="s1">test_set_levels_pos_args_deprecation():</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/issues/41485</span>
    <span class="s1">idx = MultiIndex.from_tuples(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">msg = (</span>
        <span class="s4">r&quot;In a future version of pandas all arguments of MultiIndex.set_levels except &quot;</span>
        <span class="s4">r&quot;for the argument 'levels' will be keyword-only&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = idx.set_levels([</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">expected = MultiIndex.from_tuples(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_set_codes_pos_args_depreciation(idx):</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/issues/41485</span>
    <span class="s1">msg = (</span>
        <span class="s4">r&quot;In a future version of pandas all arguments of MultiIndex.set_codes except &quot;</span>
        <span class="s4">r&quot;for the argument 'codes' will be keyword-only&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = idx.set_codes([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">expected = MultiIndex.from_tuples(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;bar&quot;</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;baz&quot;</span><span class="s0">, </span><span class="s4">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;qux&quot;</span><span class="s0">, </span><span class="s4">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;qux&quot;</span><span class="s0">, </span><span class="s4">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s4">&quot;first&quot;</span><span class="s0">, </span><span class="s4">&quot;second&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>