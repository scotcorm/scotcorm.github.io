<html>
<head>
<title>stata.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
stata.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Module contains tools for processing Stata files into DataFrames 
 
The StataReader below was originally written by Joe Presbrey as part of PyDTA. 
It has been extended and improved by Skipper Seabold from the Statsmodels 
project who also developed the StataWriter and was finally added to pandas in 
a once again improved version. 
 
You can find more information on http://presbrey.mit.edu/PyDTA and 
https://www.statsmodels.org/devel/ 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IO</span><span class="s2">,</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">AnyStr</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">dateutil.relativedelta </span><span class="s2">import </span><span class="s1">relativedelta</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs.lib </span><span class="s2">import </span><span class="s1">infer_dtype</span>
<span class="s2">from </span><span class="s1">pandas._libs.writers </span><span class="s2">import </span><span class="s1">max_len_string_array</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CompressionOptions</span><span class="s2">,</span>
    <span class="s1">FilePath</span><span class="s2">,</span>
    <span class="s1">ReadBuffer</span><span class="s2">,</span>
    <span class="s1">StorageOptions</span><span class="s2">,</span>
    <span class="s1">WriteBuffer</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s2">,</span>
    <span class="s1">doc</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_object</span><span class="s2">,</span>
    <span class="s1">is_categorical_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64_dtype</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s2">,</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">to_datetime</span><span class="s2">,</span>
    <span class="s1">to_timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s2">import </span><span class="s1">BooleanDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s2">import </span><span class="s1">_IntegerDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.frame </span><span class="s2">import </span><span class="s1">DataFrame</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.base </span><span class="s2">import </span><span class="s1">Index</span>
<span class="s2">from </span><span class="s1">pandas.core.series </span><span class="s2">import </span><span class="s1">Series</span>
<span class="s2">from </span><span class="s1">pandas.core.shared_docs </span><span class="s2">import </span><span class="s1">_shared_docs</span>

<span class="s2">from </span><span class="s1">pandas.io.common </span><span class="s2">import </span><span class="s1">get_handle</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s1">_version_error = (</span>
    <span class="s3">&quot;Version of given Stata file is {version}. pandas supports importing &quot;</span>
    <span class="s3">&quot;versions 105, 108, 111 (Stata 7SE), 113 (Stata 8/9), &quot;</span>
    <span class="s3">&quot;114 (Stata 10/11), 115 (Stata 12), 117 (Stata 13), 118 (Stata 14/15/16),&quot;</span>
    <span class="s3">&quot;and 119 (Stata 15/16, over 32,767 variables).&quot;</span>
<span class="s1">)</span>

<span class="s1">_statafile_processing_params1 = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">convert_dates : bool, default True 
    Convert date variables to DataFrame time values. 
convert_categoricals : bool, default True 
    Read value labels and convert columns to Categorical/Factor variables.&quot;&quot;&quot;</span>

<span class="s1">_statafile_processing_params2 = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">index_col : str, optional 
    Column to set as index. 
convert_missing : bool, default False 
    Flag indicating whether to convert missing values to their Stata 
    representations.  If False, missing values are replaced with nan. 
    If True, columns containing missing values are returned with 
    object data types and missing values are represented by 
    StataMissingValue objects. 
preserve_dtypes : bool, default True 
    Preserve Stata datatypes. If False, numeric data are upcast to pandas 
    default types for foreign data (float64 or int64). 
columns : list or None 
    Columns to retain.  Columns will be returned in the given order.  None 
    returns all columns. 
order_categoricals : bool, default True 
    Flag indicating whether converted categorical data are ordered.&quot;&quot;&quot;</span>

<span class="s1">_chunksize_params = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">chunksize : int, default None 
    Return StataReader object for iterations, returns chunks with 
    given number of lines.&quot;&quot;&quot;</span>

<span class="s1">_iterator_params = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">iterator : bool, default False 
    Return StataReader object.&quot;&quot;&quot;</span>

<span class="s1">_reader_notes = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Notes 
----- 
Categorical variables read through an iterator may not have the same 
categories and dtype. This occurs when  a variable stored in a DTA 
file is associated to an incomplete set of value labels that only 
label a strict subset of the values.&quot;&quot;&quot;</span>

<span class="s1">_read_stata_doc = </span><span class="s3">f&quot;&quot;&quot;</span>
<span class="s3">Read Stata file into DataFrame.</span>

<span class="s3">Parameters</span>
<span class="s3">----------</span>
<span class="s3">filepath_or_buffer : str, path object or file-like object</span>
    <span class="s3">Any valid string path is acceptable. The string could be a URL. Valid</span>
    <span class="s3">URL schemes include http, ftp, s3, and file. For file URLs, a host is</span>
    <span class="s3">expected. A local file could be: ``file://localhost/path/to/table.dta``.</span>

    <span class="s3">If you want to pass in a path object, pandas accepts any ``os.PathLike``.</span>

    <span class="s3">By file-like object, we refer to objects with a ``read()`` method,</span>
    <span class="s3">such as a file handle (e.g. via builtin ``open`` function)</span>
    <span class="s3">or ``StringIO``.</span>
<span class="s2">{</span><span class="s1">_statafile_processing_params1</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_statafile_processing_params2</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_chunksize_params</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_iterator_params</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_shared_docs[</span><span class="s3">&quot;decompression_options&quot;</span><span class="s1">]</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">}</span>

<span class="s3">Returns</span>
<span class="s3">-------</span>
<span class="s3">DataFrame or StataReader</span>

<span class="s3">See Also</span>
<span class="s3">--------</span>
<span class="s3">io.stata.StataReader : Low-level reader for Stata data files.</span>
<span class="s3">DataFrame.to_stata: Export Stata data files.</span>

<span class="s2">{</span><span class="s1">_reader_notes</span><span class="s2">}</span>

<span class="s3">Examples</span>
<span class="s3">--------</span>

<span class="s3">Creating a dummy stata for this example</span>
<span class="s3">&gt;&gt;&gt; df = pd.DataFrame(</span><span class="s2">{{</span><span class="s3">'animal': ['falcon', 'parrot', 'falcon',</span>
<span class="s3">...                              'parrot'],</span>
<span class="s3">...                   'speed': [350, 18, 361, 15]</span><span class="s2">}}</span><span class="s3">)  # doctest: +SKIP</span>
<span class="s3">&gt;&gt;&gt; df.to_stata('animals.dta')  # doctest: +SKIP</span>

<span class="s3">Read a Stata dta file:</span>

<span class="s3">&gt;&gt;&gt; df = pd.read_stata('animals.dta')  # doctest: +SKIP</span>

<span class="s3">Read a Stata dta file in 10,000 line chunks:</span>
<span class="s3">&gt;&gt;&gt; values = np.random.randint(0, 10, size=(20_000, 1), dtype=&quot;uint8&quot;)  # doctest: +SKIP</span>
<span class="s3">&gt;&gt;&gt; df = pd.DataFrame(values, columns=[&quot;i&quot;])  # doctest: +SKIP</span>
<span class="s3">&gt;&gt;&gt; df.to_stata('filename.dta')  # doctest: +SKIP</span>

<span class="s3">&gt;&gt;&gt; itr = pd.read_stata('filename.dta', chunksize=10000)  # doctest: +SKIP</span>
<span class="s3">&gt;&gt;&gt; for chunk in itr:</span>
<span class="s3">...    # Operate on a single chunk, e.g., chunk.mean()</span>
<span class="s3">...    pass  # doctest: +SKIP</span>
<span class="s3">&quot;&quot;&quot;</span>

<span class="s1">_read_method_doc = </span><span class="s3">f&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Reads observations from Stata file, converting them into a dataframe</span>

<span class="s3">Parameters</span>
<span class="s3">----------</span>
<span class="s3">nrows : int</span>
    <span class="s3">Number of lines to read from data file, if None read whole file.</span>
<span class="s2">{</span><span class="s1">_statafile_processing_params1</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_statafile_processing_params2</span><span class="s2">}</span>

<span class="s3">Returns</span>
<span class="s3">-------</span>
<span class="s3">DataFrame</span>
<span class="s3">&quot;&quot;&quot;</span>

<span class="s1">_stata_reader_doc = </span><span class="s3">f&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Class for reading Stata dta files.</span>

<span class="s3">Parameters</span>
<span class="s3">----------</span>
<span class="s3">path_or_buf : path (string), buffer or path object</span>
    <span class="s3">string, path object (pathlib.Path or py._path.local.LocalPath) or object</span>
    <span class="s3">implementing a binary read() functions.</span>
<span class="s2">{</span><span class="s1">_statafile_processing_params1</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_statafile_processing_params2</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_chunksize_params</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_shared_docs[</span><span class="s3">&quot;decompression_options&quot;</span><span class="s1">]</span><span class="s2">}</span>
<span class="s2">{</span><span class="s1">_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">}</span>

<span class="s2">{</span><span class="s1">_reader_notes</span><span class="s2">}</span>
<span class="s3">&quot;&quot;&quot;</span>


<span class="s1">_date_formats = [</span><span class="s3">&quot;%tc&quot;</span><span class="s2">, </span><span class="s3">&quot;%tC&quot;</span><span class="s2">, </span><span class="s3">&quot;%td&quot;</span><span class="s2">, </span><span class="s3">&quot;%d&quot;</span><span class="s2">, </span><span class="s3">&quot;%tw&quot;</span><span class="s2">, </span><span class="s3">&quot;%tm&quot;</span><span class="s2">, </span><span class="s3">&quot;%tq&quot;</span><span class="s2">, </span><span class="s3">&quot;%th&quot;</span><span class="s2">, </span><span class="s3">&quot;%ty&quot;</span><span class="s1">]</span>


<span class="s1">stata_epoch = datetime.datetime(</span><span class="s4">1960</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s5"># TODO: Add typing. As of January 2020 it is not possible to type this function since</span>
<span class="s5">#  mypy doesn't understand that a Series and an int can be combined using mathematical</span>
<span class="s5">#  operations. (+, -).</span>
<span class="s2">def </span><span class="s1">_stata_elapsed_date_to_datetime_vec(dates</span><span class="s2">, </span><span class="s1">fmt) -&gt; Series:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert from SIF to datetime. https://www.stata.com/help.cgi?datetime 
 
    Parameters 
    ---------- 
    dates : Series 
        The Stata Internal Format date to convert to datetime according to fmt 
    fmt : str 
        The format to convert to. Can be, tc, td, tw, tm, tq, th, ty 
        Returns 
 
    Returns 
    ------- 
    converted : Series 
        The converted dates 
 
    Examples 
    -------- 
    &gt;&gt;&gt; dates = pd.Series([52]) 
    &gt;&gt;&gt; _stata_elapsed_date_to_datetime_vec(dates , &quot;%tw&quot;) 
    0   1961-01-01 
    dtype: datetime64[ns] 
 
    Notes 
    ----- 
    datetime/c - tc 
        milliseconds since 01jan1960 00:00:00.000, assuming 86,400 s/day 
    datetime/C - tC - NOT IMPLEMENTED 
        milliseconds since 01jan1960 00:00:00.000, adjusted for leap seconds 
    date - td 
        days since 01jan1960 (01jan1960 = 0) 
    weekly date - tw 
        weeks since 1960w1 
        This assumes 52 weeks in a year, then adds 7 * remainder of the weeks. 
        The datetime value is the start of the week in terms of days in the 
        year, not ISO calendar weeks. 
    monthly date - tm 
        months since 1960m1 
    quarterly date - tq 
        quarters since 1960q1 
    half-yearly date - th 
        half-years since 1960h1 yearly 
    date - ty 
        years since 0000 
    &quot;&quot;&quot;</span>
    <span class="s1">MIN_YEAR</span><span class="s2">, </span><span class="s1">MAX_YEAR = Timestamp.min.year</span><span class="s2">, </span><span class="s1">Timestamp.max.year</span>
    <span class="s1">MAX_DAY_DELTA = (Timestamp.max - datetime.datetime(</span><span class="s4">1960</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)).days</span>
    <span class="s1">MIN_DAY_DELTA = (Timestamp.min - datetime.datetime(</span><span class="s4">1960</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)).days</span>
    <span class="s1">MIN_MS_DELTA = MIN_DAY_DELTA * </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">1000</span>
    <span class="s1">MAX_MS_DELTA = MAX_DAY_DELTA * </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">1000</span>

    <span class="s2">def </span><span class="s1">convert_year_month_safe(year</span><span class="s2">, </span><span class="s1">month) -&gt; Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert year and month to datetimes, using pandas vectorized versions 
        when the date range falls within the range supported by pandas. 
        Otherwise it falls back to a slower but more robust method 
        using datetime. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">year.max() &lt; MAX_YEAR </span><span class="s2">and </span><span class="s1">year.min() &gt; MIN_YEAR:</span>
            <span class="s2">return </span><span class="s1">to_datetime(</span><span class="s4">100 </span><span class="s1">* year + month</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">index = getattr(year</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">Series(</span>
                <span class="s1">[datetime.datetime(y</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">y</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">zip(year</span><span class="s2">, </span><span class="s1">month)]</span><span class="s2">, </span><span class="s1">index=index</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">convert_year_days_safe(year</span><span class="s2">, </span><span class="s1">days) -&gt; Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts year (e.g. 1999) and days since the start of the year to a 
        datetime or datetime64 Series 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">year.max() &lt; (MAX_YEAR - </span><span class="s4">1</span><span class="s1">) </span><span class="s2">and </span><span class="s1">year.min() &gt; MIN_YEAR:</span>
            <span class="s2">return </span><span class="s1">to_datetime(year</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y&quot;</span><span class="s1">) + to_timedelta(days</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;d&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">index = getattr(year</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">value = [</span>
                <span class="s1">datetime.datetime(y</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + relativedelta(days=int(d))</span>
                <span class="s2">for </span><span class="s1">y</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(year</span><span class="s2">, </span><span class="s1">days)</span>
            <span class="s1">]</span>
            <span class="s2">return </span><span class="s1">Series(value</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s2">def </span><span class="s1">convert_delta_safe(base</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">unit) -&gt; Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert base dates and deltas to datetimes, using pandas vectorized 
        versions if the deltas satisfy restrictions required to be expressed 
        as dates in pandas. 
        &quot;&quot;&quot;</span>
        <span class="s1">index = getattr(deltas</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">unit == </span><span class="s3">&quot;d&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">deltas.max() &gt; MAX_DAY_DELTA </span><span class="s2">or </span><span class="s1">deltas.min() &lt; MIN_DAY_DELTA:</span>
                <span class="s1">values = [base + relativedelta(days=int(d)) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">deltas]</span>
                <span class="s2">return </span><span class="s1">Series(values</span><span class="s2">, </span><span class="s1">index=index)</span>
        <span class="s2">elif </span><span class="s1">unit == </span><span class="s3">&quot;ms&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">deltas.max() &gt; MAX_MS_DELTA </span><span class="s2">or </span><span class="s1">deltas.min() &lt; MIN_MS_DELTA:</span>
                <span class="s1">values = [</span>
                    <span class="s1">base + relativedelta(microseconds=(int(d) * </span><span class="s4">1000</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">deltas</span>
                <span class="s1">]</span>
                <span class="s2">return </span><span class="s1">Series(values</span><span class="s2">, </span><span class="s1">index=index)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;format not understood&quot;</span><span class="s1">)</span>
        <span class="s1">base = to_datetime(base)</span>
        <span class="s1">deltas = to_timedelta(deltas</span><span class="s2">, </span><span class="s1">unit=unit)</span>
        <span class="s2">return </span><span class="s1">base + deltas</span>

    <span class="s5"># TODO(non-nano): If/when pandas supports more than datetime64[ns], this</span>
    <span class="s5">#  should be improved to use correct range, e.g. datetime[Y] for yearly</span>
    <span class="s1">bad_locs = np.isnan(dates)</span>
    <span class="s1">has_bad_values = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">bad_locs.any():</span>
        <span class="s1">has_bad_values = </span><span class="s2">True</span>
        <span class="s1">data_col = Series(dates)</span>
        <span class="s1">data_col[bad_locs] = </span><span class="s4">1.0  </span><span class="s5"># Replace with NaT</span>
    <span class="s1">dates = dates.astype(np.int64)</span>

    <span class="s2">if </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%tc&quot;</span><span class="s2">, </span><span class="s3">&quot;tc&quot;</span><span class="s1">)):  </span><span class="s5"># Delta ms relative to base</span>
        <span class="s1">base = stata_epoch</span>
        <span class="s1">ms = dates</span>
        <span class="s1">conv_dates = convert_delta_safe(base</span><span class="s2">, </span><span class="s1">ms</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%tC&quot;</span><span class="s2">, </span><span class="s3">&quot;tC&quot;</span><span class="s1">)):</span>

        <span class="s1">warnings.warn(</span><span class="s3">&quot;Encountered %tC format. Leaving in Stata Internal Format.&quot;</span><span class="s1">)</span>
        <span class="s1">conv_dates = Series(dates</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">if </span><span class="s1">has_bad_values:</span>
            <span class="s1">conv_dates[bad_locs] = NaT</span>
        <span class="s2">return </span><span class="s1">conv_dates</span>
    <span class="s5"># Delta days relative to base</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%td&quot;</span><span class="s2">, </span><span class="s3">&quot;td&quot;</span><span class="s2">, </span><span class="s3">&quot;%d&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)):</span>
        <span class="s1">base = stata_epoch</span>
        <span class="s1">days = dates</span>
        <span class="s1">conv_dates = convert_delta_safe(base</span><span class="s2">, </span><span class="s1">days</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span>
    <span class="s5"># does not count leap days - 7 days is a week.</span>
    <span class="s5"># 52nd week may have more than 7 days</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%tw&quot;</span><span class="s2">, </span><span class="s3">&quot;tw&quot;</span><span class="s1">)):</span>
        <span class="s1">year = stata_epoch.year + dates // </span><span class="s4">52</span>
        <span class="s1">days = (dates % </span><span class="s4">52</span><span class="s1">) * </span><span class="s4">7</span>
        <span class="s1">conv_dates = convert_year_days_safe(year</span><span class="s2">, </span><span class="s1">days)</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%tm&quot;</span><span class="s2">, </span><span class="s3">&quot;tm&quot;</span><span class="s1">)):  </span><span class="s5"># Delta months relative to base</span>
        <span class="s1">year = stata_epoch.year + dates // </span><span class="s4">12</span>
        <span class="s1">month = (dates % </span><span class="s4">12</span><span class="s1">) + </span><span class="s4">1</span>
        <span class="s1">conv_dates = convert_year_month_safe(year</span><span class="s2">, </span><span class="s1">month)</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%tq&quot;</span><span class="s2">, </span><span class="s3">&quot;tq&quot;</span><span class="s1">)):  </span><span class="s5"># Delta quarters relative to base</span>
        <span class="s1">year = stata_epoch.year + dates // </span><span class="s4">4</span>
        <span class="s1">quarter_month = (dates % </span><span class="s4">4</span><span class="s1">) * </span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">1</span>
        <span class="s1">conv_dates = convert_year_month_safe(year</span><span class="s2">, </span><span class="s1">quarter_month)</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%th&quot;</span><span class="s2">, </span><span class="s3">&quot;th&quot;</span><span class="s1">)):  </span><span class="s5"># Delta half-years relative to base</span>
        <span class="s1">year = stata_epoch.year + dates // </span><span class="s4">2</span>
        <span class="s1">month = (dates % </span><span class="s4">2</span><span class="s1">) * </span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">1</span>
        <span class="s1">conv_dates = convert_year_month_safe(year</span><span class="s2">, </span><span class="s1">month)</span>
    <span class="s2">elif </span><span class="s1">fmt.startswith((</span><span class="s3">&quot;%ty&quot;</span><span class="s2">, </span><span class="s3">&quot;ty&quot;</span><span class="s1">)):  </span><span class="s5"># Years -- not delta</span>
        <span class="s1">year = dates</span>
        <span class="s1">first_month = np.ones_like(dates)</span>
        <span class="s1">conv_dates = convert_year_month_safe(year</span><span class="s2">, </span><span class="s1">first_month)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Date fmt </span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">} </span><span class="s3">not understood&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">has_bad_values:  </span><span class="s5"># Restore NaT for bad values</span>
        <span class="s1">conv_dates[bad_locs] = NaT</span>

    <span class="s2">return </span><span class="s1">conv_dates</span>


<span class="s2">def </span><span class="s1">_datetime_to_stata_elapsed_vec(dates: Series</span><span class="s2">, </span><span class="s1">fmt: str) -&gt; Series:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert from datetime to SIF. https://www.stata.com/help.cgi?datetime 
 
    Parameters 
    ---------- 
    dates : Series 
        Series or array containing datetime.datetime or datetime64[ns] to 
        convert to the Stata Internal Format given by fmt 
    fmt : str 
        The format to convert to. Can be, tc, td, tw, tm, tq, th, ty 
    &quot;&quot;&quot;</span>
    <span class="s1">index = dates.index</span>
    <span class="s1">NS_PER_DAY = </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">1000 </span><span class="s1">* </span><span class="s4">1000 </span><span class="s1">* </span><span class="s4">1000</span>
    <span class="s1">US_PER_DAY = NS_PER_DAY / </span><span class="s4">1000</span>

    <span class="s2">def </span><span class="s1">parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">delta=</span><span class="s2">False, </span><span class="s1">year=</span><span class="s2">False, </span><span class="s1">days=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">d = {}</span>
        <span class="s2">if </span><span class="s1">is_datetime64_dtype(dates.dtype):</span>
            <span class="s2">if </span><span class="s1">delta:</span>
                <span class="s1">time_delta = dates - stata_epoch</span>
                <span class="s1">d[</span><span class="s3">&quot;delta&quot;</span><span class="s1">] = time_delta._values.view(np.int64) // </span><span class="s4">1000  </span><span class="s5"># microseconds</span>
            <span class="s2">if </span><span class="s1">days </span><span class="s2">or </span><span class="s1">year:</span>
                <span class="s1">date_index = DatetimeIndex(dates)</span>
                <span class="s1">d[</span><span class="s3">&quot;year&quot;</span><span class="s1">] = date_index._data.year</span>
                <span class="s1">d[</span><span class="s3">&quot;month&quot;</span><span class="s1">] = date_index._data.month</span>
            <span class="s2">if </span><span class="s1">days:</span>
                <span class="s1">days_in_ns = dates.view(np.int64) - to_datetime(</span>
                    <span class="s1">d[</span><span class="s3">&quot;year&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y&quot;</span>
                <span class="s1">).view(np.int64)</span>
                <span class="s1">d[</span><span class="s3">&quot;days&quot;</span><span class="s1">] = days_in_ns // NS_PER_DAY</span>

        <span class="s2">elif </span><span class="s1">infer_dtype(dates</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">) == </span><span class="s3">&quot;datetime&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">delta:</span>
                <span class="s1">delta = dates._values - stata_epoch</span>

                <span class="s2">def </span><span class="s1">f(x: datetime.timedelta) -&gt; float:</span>
                    <span class="s2">return </span><span class="s1">US_PER_DAY * x.days + </span><span class="s4">1000000 </span><span class="s1">* x.seconds + x.microseconds</span>

                <span class="s1">v = np.vectorize(f)</span>
                <span class="s1">d[</span><span class="s3">&quot;delta&quot;</span><span class="s1">] = v(delta)</span>
            <span class="s2">if </span><span class="s1">year:</span>
                <span class="s1">year_month = dates.apply(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">100 </span><span class="s1">* x.year + x.month)</span>
                <span class="s1">d[</span><span class="s3">&quot;year&quot;</span><span class="s1">] = year_month._values // </span><span class="s4">100</span>
                <span class="s1">d[</span><span class="s3">&quot;month&quot;</span><span class="s1">] = year_month._values - d[</span><span class="s3">&quot;year&quot;</span><span class="s1">] * </span><span class="s4">100</span>
            <span class="s2">if </span><span class="s1">days:</span>

                <span class="s2">def </span><span class="s1">g(x: datetime.datetime) -&gt; int:</span>
                    <span class="s2">return </span><span class="s1">(x - datetime.datetime(x.year</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)).days</span>

                <span class="s1">v = np.vectorize(g)</span>
                <span class="s1">d[</span><span class="s3">&quot;days&quot;</span><span class="s1">] = v(dates)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Columns containing dates must contain either &quot;</span>
                <span class="s3">&quot;datetime64, datetime.datetime or null values.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">DataFrame(d</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">bad_loc = isna(dates)</span>
    <span class="s1">index = dates.index</span>
    <span class="s2">if </span><span class="s1">bad_loc.any():</span>
        <span class="s1">dates = Series(dates)</span>
        <span class="s2">if </span><span class="s1">is_datetime64_dtype(dates):</span>
            <span class="s1">dates[bad_loc] = to_datetime(stata_epoch)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dates[bad_loc] = stata_epoch</span>

    <span class="s2">if </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%tc&quot;</span><span class="s2">, </span><span class="s3">&quot;tc&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">delta=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = d.delta / </span><span class="s4">1000</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%tC&quot;</span><span class="s2">, </span><span class="s3">&quot;tC&quot;</span><span class="s1">]:</span>
        <span class="s1">warnings.warn(</span><span class="s3">&quot;Stata Internal Format tC not supported.&quot;</span><span class="s1">)</span>
        <span class="s1">conv_dates = dates</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%td&quot;</span><span class="s2">, </span><span class="s3">&quot;td&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">delta=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = d.delta // US_PER_DAY</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%tw&quot;</span><span class="s2">, </span><span class="s3">&quot;tw&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">year=</span><span class="s2">True, </span><span class="s1">days=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = </span><span class="s4">52 </span><span class="s1">* (d.year - stata_epoch.year) + d.days // </span><span class="s4">7</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%tm&quot;</span><span class="s2">, </span><span class="s3">&quot;tm&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">year=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = </span><span class="s4">12 </span><span class="s1">* (d.year - stata_epoch.year) + d.month - </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%tq&quot;</span><span class="s2">, </span><span class="s3">&quot;tq&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">year=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = </span><span class="s4">4 </span><span class="s1">* (d.year - stata_epoch.year) + (d.month - </span><span class="s4">1</span><span class="s1">) // </span><span class="s4">3</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%th&quot;</span><span class="s2">, </span><span class="s3">&quot;th&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">year=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = </span><span class="s4">2 </span><span class="s1">* (d.year - stata_epoch.year) + (d.month &gt; </span><span class="s4">6</span><span class="s1">).astype(int)</span>
    <span class="s2">elif </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;%ty&quot;</span><span class="s2">, </span><span class="s3">&quot;ty&quot;</span><span class="s1">]:</span>
        <span class="s1">d = parse_dates_safe(dates</span><span class="s2">, </span><span class="s1">year=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conv_dates = d.year</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Format </span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">} </span><span class="s3">is not a known Stata date format&quot;</span><span class="s1">)</span>

    <span class="s1">conv_dates = Series(conv_dates</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">missing_value = struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x00\x00\x00\xe0\x7f</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">conv_dates[bad_loc] = missing_value</span>

    <span class="s2">return </span><span class="s1">Series(conv_dates</span><span class="s2">, </span><span class="s1">index=index)</span>


<span class="s1">excessive_string_length_error = </span><span class="s3">&quot;&quot;&quot; 
Fixed width strings in Stata .dta files are limited to 244 (or fewer) 
characters.  Column '{0}' does not satisfy this restriction. Use the 
'version=117' parameter to write the newer (Stata 13 and later) format. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">PossiblePrecisionLoss(Warning):</span>
    <span class="s2">pass</span>


<span class="s1">precision_loss_doc = </span><span class="s3">&quot;&quot;&quot; 
Column converted from {0} to {1}, and some data are outside of the lossless 
conversion range. This may result in a loss of precision in the saved data. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">ValueLabelTypeMismatch(Warning):</span>
    <span class="s2">pass</span>


<span class="s1">value_label_mismatch_doc = </span><span class="s3">&quot;&quot;&quot; 
Stata value labels (pandas categories) must be strings. Column {0} contains 
non-string labels which will be converted to strings.  Please check that the 
Stata data file created has not lost information due to duplicate labels. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">InvalidColumnName(Warning):</span>
    <span class="s2">pass</span>


<span class="s1">invalid_name_doc = </span><span class="s3">&quot;&quot;&quot; 
Not all pandas column names were valid Stata variable names. 
The following replacements have been made: 
 
    {0} 
 
If this is not what you expect, please make sure you have Stata-compliant 
column names in your DataFrame (strings only, max 32 characters, only 
alphanumerics and underscores, no Stata reserved words) 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">CategoricalConversionWarning(Warning):</span>
    <span class="s2">pass</span>


<span class="s1">categorical_conversion_warning = </span><span class="s3">&quot;&quot;&quot; 
One or more series with value labels are not fully labeled. Reading this 
dataset with an iterator results in categorical variable with different 
categories. This occurs since it is not possible to know all possible values 
until the entire dataset has been read. To avoid this warning, you can either 
read dataset without an iterator, or manually convert categorical data by 
``convert_categoricals`` to False and then accessing the variable labels 
through the value_labels method of the reader. 
&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_cast_to_stata_types(data: DataFrame) -&gt; DataFrame:</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks the dtypes of the columns of a pandas DataFrame for 
    compatibility with the data types and ranges supported by Stata, and 
    converts if necessary. 
 
    Parameters 
    ---------- 
    data : DataFrame 
        The DataFrame to check and convert 
 
    Notes 
    ----- 
    Numeric columns in Stata must be one of int8, int16, int32, float32 or 
    float64, with some additional value restrictions.  int8 and int16 columns 
    are checked for violations of the value restrictions and upcast if needed. 
    int64 data is not usable in Stata, and so it is downcast to int32 whenever 
    the value are in the int32 range, and sidecast to float64 when larger than 
    this range.  If the int64 values are outside of the range of those 
    perfectly representable as float64 values, a warning is raised. 
 
    bool columns are cast to int8.  uint columns are converted to int of the 
    same size if there is no loss in precision, otherwise are upcast to a 
    larger type.  uint64 is currently not supported since it is concerted to 
    object in a DataFrame. 
    &quot;&quot;&quot;</span>
    <span class="s1">ws = </span><span class="s3">&quot;&quot;</span>
    <span class="s5"># original, if small, if large</span>
    <span class="s1">conversion_data = (</span>
        <span class="s1">(np.bool_</span><span class="s2">, </span><span class="s1">np.int8</span><span class="s2">, </span><span class="s1">np.int8)</span><span class="s2">,</span>
        <span class="s1">(np.uint8</span><span class="s2">, </span><span class="s1">np.int8</span><span class="s2">, </span><span class="s1">np.int16)</span><span class="s2">,</span>
        <span class="s1">(np.uint16</span><span class="s2">, </span><span class="s1">np.int16</span><span class="s2">, </span><span class="s1">np.int32)</span><span class="s2">,</span>
        <span class="s1">(np.uint32</span><span class="s2">, </span><span class="s1">np.int32</span><span class="s2">, </span><span class="s1">np.int64)</span><span class="s2">,</span>
        <span class="s1">(np.uint64</span><span class="s2">, </span><span class="s1">np.int64</span><span class="s2">, </span><span class="s1">np.float64)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">float32_max = struct.unpack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\xff\xff\xff\x7e</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">float64_max = struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\xff\xff\xff\xff\xff\xff\xdf\x7f</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">data:</span>
        <span class="s5"># Cast from unsupported types to supported types</span>
        <span class="s1">is_nullable_int = isinstance(data[col].dtype</span><span class="s2">, </span><span class="s1">(_IntegerDtype</span><span class="s2">, </span><span class="s1">BooleanDtype))</span>
        <span class="s1">orig = data[col]</span>
        <span class="s5"># We need to find orig_missing before altering data below</span>
        <span class="s1">orig_missing = orig.isna()</span>
        <span class="s2">if </span><span class="s1">is_nullable_int:</span>
            <span class="s1">missing_loc = data[col].isna()</span>
            <span class="s2">if </span><span class="s1">missing_loc.any():</span>
                <span class="s5"># Replace with always safe value</span>
                <span class="s1">data.loc[missing_loc</span><span class="s2">, </span><span class="s1">col] = </span><span class="s4">0</span>
            <span class="s5"># Replace with NumPy-compatible column</span>
            <span class="s1">data[col] = data[col].astype(data[col].dtype.numpy_dtype)</span>
        <span class="s1">dtype = data[col].dtype</span>
        <span class="s2">for </span><span class="s1">c_data </span><span class="s2">in </span><span class="s1">conversion_data:</span>
            <span class="s2">if </span><span class="s1">dtype == c_data[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s5"># Value of type variable &quot;_IntType&quot; of &quot;iinfo&quot; cannot be &quot;object&quot;</span>
                <span class="s2">if </span><span class="s1">data[col].max() &lt;= np.iinfo(c_data[</span><span class="s4">1</span><span class="s1">]).max:  </span><span class="s5"># type: ignore[type-var]</span>
                    <span class="s1">dtype = c_data[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">dtype = c_data[</span><span class="s4">2</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">c_data[</span><span class="s4">2</span><span class="s1">] == np.int64:  </span><span class="s5"># Warn if necessary</span>
                    <span class="s2">if </span><span class="s1">data[col].max() &gt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">53</span><span class="s1">:</span>
                        <span class="s1">ws = precision_loss_doc.format(</span><span class="s3">&quot;uint64&quot;</span><span class="s2">, </span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>

                <span class="s1">data[col] = data[col].astype(dtype)</span>

        <span class="s5"># Check values and upcast if necessary</span>
        <span class="s2">if </span><span class="s1">dtype == np.int8:</span>
            <span class="s2">if </span><span class="s1">data[col].max() &gt; </span><span class="s4">100 </span><span class="s2">or </span><span class="s1">data[col].min() &lt; -</span><span class="s4">127</span><span class="s1">:</span>
                <span class="s1">data[col] = data[col].astype(np.int16)</span>
        <span class="s2">elif </span><span class="s1">dtype == np.int16:</span>
            <span class="s2">if </span><span class="s1">data[col].max() &gt; </span><span class="s4">32740 </span><span class="s2">or </span><span class="s1">data[col].min() &lt; -</span><span class="s4">32767</span><span class="s1">:</span>
                <span class="s1">data[col] = data[col].astype(np.int32)</span>
        <span class="s2">elif </span><span class="s1">dtype == np.int64:</span>
            <span class="s2">if </span><span class="s1">data[col].max() &lt;= </span><span class="s4">2147483620 </span><span class="s2">and </span><span class="s1">data[col].min() &gt;= -</span><span class="s4">2147483647</span><span class="s1">:</span>
                <span class="s1">data[col] = data[col].astype(np.int32)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">data[col] = data[col].astype(np.float64)</span>
                <span class="s2">if </span><span class="s1">data[col].max() &gt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">53 </span><span class="s2">or </span><span class="s1">data[col].min() &lt;= -(</span><span class="s4">2 </span><span class="s1">** </span><span class="s4">53</span><span class="s1">):</span>
                    <span class="s1">ws = precision_loss_doc.format(</span><span class="s3">&quot;int64&quot;</span><span class="s2">, </span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(np.float32</span><span class="s2">, </span><span class="s1">np.float64):</span>
            <span class="s1">value = data[col].max()</span>
            <span class="s2">if </span><span class="s1">np.isinf(value):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;Column </span><span class="s2">{</span><span class="s1">col</span><span class="s2">} </span><span class="s3">has a maximum value of infinity which is outside &quot;</span>
                    <span class="s3">&quot;the range supported by Stata.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">dtype == np.float32 </span><span class="s2">and </span><span class="s1">value &gt; float32_max:</span>
                <span class="s1">data[col] = data[col].astype(np.float64)</span>
            <span class="s2">elif </span><span class="s1">dtype == np.float64:</span>
                <span class="s2">if </span><span class="s1">value &gt; float64_max:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">f&quot;Column </span><span class="s2">{</span><span class="s1">col</span><span class="s2">} </span><span class="s3">has a maximum value (</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s3">) outside the range &quot;</span>
                        <span class="s3">f&quot;supported by Stata (</span><span class="s2">{</span><span class="s1">float64_max</span><span class="s2">}</span><span class="s3">)&quot;</span>
                    <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">is_nullable_int:</span>
            <span class="s2">if </span><span class="s1">orig_missing.any():</span>
                <span class="s5"># Replace missing by Stata sentinel value</span>
                <span class="s1">sentinel = StataMissingValue.BASE_MISSING_VALUES[data[col].dtype.name]</span>
                <span class="s1">data.loc[orig_missing</span><span class="s2">, </span><span class="s1">col] = sentinel</span>
    <span class="s2">if </span><span class="s1">ws:</span>
        <span class="s1">warnings.warn(ws</span><span class="s2">, </span><span class="s1">PossiblePrecisionLoss)</span>

    <span class="s2">return </span><span class="s1">data</span>


<span class="s2">class </span><span class="s1">StataValueLabel:</span>
    <span class="s0">&quot;&quot;&quot; 
    Parse a categorical column and prepare formatted output 
 
    Parameters 
    ---------- 
    catarray : Series 
        Categorical Series to encode 
    encoding : {&quot;latin-1&quot;, &quot;utf-8&quot;} 
        Encoding to use for value labels. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">catarray: Series</span><span class="s2">, </span><span class="s1">encoding: str = </span><span class="s3">&quot;latin-1&quot;</span><span class="s1">):</span>

        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Only latin-1 and utf-8 are supported.&quot;</span><span class="s1">)</span>
        <span class="s1">self.labname = catarray.name</span>
        <span class="s1">self._encoding = encoding</span>
        <span class="s1">categories = catarray.cat.categories</span>
        <span class="s1">self.value_labels: list[tuple[int | float</span><span class="s2">, </span><span class="s1">str]] = list(</span>
            <span class="s1">zip(np.arange(len(categories))</span><span class="s2">, </span><span class="s1">categories)</span>
        <span class="s1">)</span>
        <span class="s1">self.value_labels.sort(key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">self._prepare_value_labels()</span>

    <span class="s2">def </span><span class="s1">_prepare_value_labels(self):</span>
        <span class="s0">&quot;&quot;&quot;Encode value labels.&quot;&quot;&quot;</span>

        <span class="s1">self.text_len = </span><span class="s4">0</span>
        <span class="s1">self.txt: list[bytes] = []</span>
        <span class="s1">self.n = </span><span class="s4">0</span>
        <span class="s5"># Offsets (length of categories), converted to int32</span>
        <span class="s1">self.off = np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s5"># Values, converted to int32</span>
        <span class="s1">self.val = np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">self.len = </span><span class="s4">0</span>

        <span class="s5"># Compute lengths and setup lists of offsets and labels</span>
        <span class="s1">offsets: list[int] = []</span>
        <span class="s1">values: list[int | float] = []</span>
        <span class="s2">for </span><span class="s1">vl </span><span class="s2">in </span><span class="s1">self.value_labels:</span>
            <span class="s1">category: str | bytes = vl[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">isinstance(category</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">category = str(category)</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s1">value_label_mismatch_doc.format(self.labname)</span><span class="s2">,</span>
                    <span class="s1">ValueLabelTypeMismatch</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">category = category.encode(self._encoding)</span>
            <span class="s1">offsets.append(self.text_len)</span>
            <span class="s1">self.text_len += len(category) + </span><span class="s4">1  </span><span class="s5"># +1 for the padding</span>
            <span class="s1">values.append(vl[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">self.txt.append(category)</span>
            <span class="s1">self.n += </span><span class="s4">1</span>

        <span class="s2">if </span><span class="s1">self.text_len &gt; </span><span class="s4">32000</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Stata value labels for a single variable must &quot;</span>
                <span class="s3">&quot;have a combined length less than 32,000 characters.&quot;</span>
            <span class="s1">)</span>

        <span class="s5"># Ensure int32</span>
        <span class="s1">self.off = np.array(offsets</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">self.val = np.array(values</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>

        <span class="s5"># Total length</span>
        <span class="s1">self.len = </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* self.n + </span><span class="s4">4 </span><span class="s1">* self.n + self.text_len</span>

    <span class="s2">def </span><span class="s1">generate_value_label(self</span><span class="s2">, </span><span class="s1">byteorder: str) -&gt; bytes:</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate the binary representation of the value labels. 
 
        Parameters 
        ---------- 
        byteorder : str 
            Byte order of the output 
 
        Returns 
        ------- 
        value_label : bytes 
            Bytes containing the formatted value label 
        &quot;&quot;&quot;</span>
        <span class="s1">encoding = self._encoding</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s1">null_byte = </span><span class="s6">b&quot;</span><span class="s2">\x00</span><span class="s6">&quot;</span>

        <span class="s5"># len</span>
        <span class="s1">bio.write(struct.pack(byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">self.len))</span>

        <span class="s5"># labname</span>
        <span class="s1">labname = str(self.labname)[:</span><span class="s4">32</span><span class="s1">].encode(encoding)</span>
        <span class="s1">lab_len = </span><span class="s4">32 </span><span class="s2">if </span><span class="s1">encoding </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s3">&quot;utf8&quot;</span><span class="s1">) </span><span class="s2">else </span><span class="s4">128</span>
        <span class="s1">labname = _pad_bytes(labname</span><span class="s2">, </span><span class="s1">lab_len + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">bio.write(labname)</span>

        <span class="s5"># padding - 3 bytes</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">bio.write(struct.pack(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">null_byte))</span>

        <span class="s5"># value_label_table</span>
        <span class="s5"># n - int32</span>
        <span class="s1">bio.write(struct.pack(byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">self.n))</span>

        <span class="s5"># textlen  - int32</span>
        <span class="s1">bio.write(struct.pack(byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">self.text_len))</span>

        <span class="s5"># off - int32 array (n elements)</span>
        <span class="s2">for </span><span class="s1">offset </span><span class="s2">in </span><span class="s1">self.off:</span>
            <span class="s1">bio.write(struct.pack(byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">offset))</span>

        <span class="s5"># val - int32 array (n elements)</span>
        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.val:</span>
            <span class="s1">bio.write(struct.pack(byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">value))</span>

        <span class="s5"># txt - Text labels, null terminated</span>
        <span class="s2">for </span><span class="s1">text </span><span class="s2">in </span><span class="s1">self.txt:</span>
            <span class="s1">bio.write(text + null_byte)</span>

        <span class="s2">return </span><span class="s1">bio.getvalue()</span>


<span class="s2">class </span><span class="s1">StataNonCatValueLabel(StataValueLabel):</span>
    <span class="s0">&quot;&quot;&quot; 
    Prepare formatted version of value labels 
 
    Parameters 
    ---------- 
    labname : str 
        Value label name 
    value_labels: Dictionary 
        Mapping of values to labels 
    encoding : {&quot;latin-1&quot;, &quot;utf-8&quot;} 
        Encoding to use for value labels. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">labname: str</span><span class="s2">,</span>
        <span class="s1">value_labels: dict[float | int</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">encoding: Literal[</span><span class="s3">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">] = </span><span class="s3">&quot;latin-1&quot;</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Only latin-1 and utf-8 are supported.&quot;</span><span class="s1">)</span>

        <span class="s1">self.labname = labname</span>
        <span class="s1">self._encoding = encoding</span>
        <span class="s1">self.value_labels: list[tuple[int | float</span><span class="s2">, </span><span class="s1">str]] = sorted(</span>
            <span class="s1">value_labels.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">self._prepare_value_labels()</span>


<span class="s2">class </span><span class="s1">StataMissingValue:</span>
    <span class="s0">&quot;&quot;&quot; 
    An observation's missing value. 
 
    Parameters 
    ---------- 
    value : {int, float} 
        The Stata missing value code 
 
    Notes 
    ----- 
    More information: &lt;https://www.stata.com/help.cgi?missing&gt; 
 
    Integer missing values make the code '.', '.a', ..., '.z' to the ranges 
    101 ... 127 (for int8), 32741 ... 32767  (for int16) and 2147483621 ... 
    2147483647 (for int32).  Missing values for floating point data types are 
    more complex but the pattern is simple to discern from the following table. 
 
    np.float32 missing values (float in Stata) 
    0000007f    . 
    0008007f    .a 
    0010007f    .b 
    ... 
    00c0007f    .x 
    00c8007f    .y 
    00d0007f    .z 
 
    np.float64 missing values (double in Stata) 
    000000000000e07f    . 
    000000000001e07f    .a 
    000000000002e07f    .b 
    ... 
    000000000018e07f    .x 
    000000000019e07f    .y 
    00000000001ae07f    .z 
    &quot;&quot;&quot;</span>

    <span class="s5"># Construct a dictionary of missing values</span>
    <span class="s1">MISSING_VALUES: dict[float</span><span class="s2">, </span><span class="s1">str] = {}</span>
    <span class="s1">bases = (</span><span class="s4">101</span><span class="s2">, </span><span class="s4">32741</span><span class="s2">, </span><span class="s4">2147483621</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">bases:</span>
        <span class="s5"># Conversion to long to avoid hash issues on 32 bit platforms #8968</span>
        <span class="s1">MISSING_VALUES[b] = </span><span class="s3">&quot;.&quot;</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">27</span><span class="s1">):</span>
            <span class="s1">MISSING_VALUES[i + b] = </span><span class="s3">&quot;.&quot; </span><span class="s1">+ chr(</span><span class="s4">96 </span><span class="s1">+ i)</span>

    <span class="s1">float32_base = </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x7f</span><span class="s6">&quot;</span>
    <span class="s1">increment = struct.unpack(</span><span class="s3">&quot;&lt;i&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\x00\x08\x00\x00</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">27</span><span class="s1">):</span>
        <span class="s1">key = struct.unpack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s1">float32_base)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">MISSING_VALUES[key] = </span><span class="s3">&quot;.&quot;</span>
        <span class="s2">if </span><span class="s1">i &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">MISSING_VALUES[key] += chr(</span><span class="s4">96 </span><span class="s1">+ i)</span>
        <span class="s1">int_value = struct.unpack(</span><span class="s3">&quot;&lt;i&quot;</span><span class="s2">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s1">key))[</span><span class="s4">0</span><span class="s1">] + increment</span>
        <span class="s1">float32_base = struct.pack(</span><span class="s3">&quot;&lt;i&quot;</span><span class="s2">, </span><span class="s1">int_value)</span>

    <span class="s1">float64_base = </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x00\x00\x00\xe0\x7f</span><span class="s6">&quot;</span>
    <span class="s1">increment = struct.unpack(</span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x00\x00\x01\x00\x00</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">27</span><span class="s1">):</span>
        <span class="s1">key = struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s1">float64_base)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">MISSING_VALUES[key] = </span><span class="s3">&quot;.&quot;</span>
        <span class="s2">if </span><span class="s1">i &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">MISSING_VALUES[key] += chr(</span><span class="s4">96 </span><span class="s1">+ i)</span>
        <span class="s1">int_value = struct.unpack(</span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s1">key))[</span><span class="s4">0</span><span class="s1">] + increment</span>
        <span class="s1">float64_base = struct.pack(</span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">int_value)</span>

    <span class="s1">BASE_MISSING_VALUES = {</span>
        <span class="s3">&quot;int8&quot;</span><span class="s1">: </span><span class="s4">101</span><span class="s2">,</span>
        <span class="s3">&quot;int16&quot;</span><span class="s1">: </span><span class="s4">32741</span><span class="s2">,</span>
        <span class="s3">&quot;int32&quot;</span><span class="s1">: </span><span class="s4">2147483621</span><span class="s2">,</span>
        <span class="s3">&quot;float32&quot;</span><span class="s1">: struct.unpack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s1">float32_base)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;float64&quot;</span><span class="s1">: struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s1">float64_base)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">value: int | float):</span>
        <span class="s1">self._value = value</span>
        <span class="s5"># Conversion to int to avoid hash issues on 32 bit platforms #8968</span>
        <span class="s1">value = int(value) </span><span class="s2">if </span><span class="s1">value &lt; </span><span class="s4">2147483648 </span><span class="s2">else </span><span class="s1">float(value)</span>
        <span class="s1">self._str = self.MISSING_VALUES[value]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">string(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        The Stata representation of the missing value: '.', '.a'..'.z' 
 
        Returns 
        ------- 
        str 
            The representation of the missing value. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._str</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self) -&gt; int | float:</span>
        <span class="s0">&quot;&quot;&quot; 
        The binary representation of the missing value. 
 
        Returns 
        ------- 
        {int, float} 
            The binary representation of the missing value. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._value</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self.string</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">type(self))</span>
            <span class="s2">and </span><span class="s1">self.string == other.string</span>
            <span class="s2">and </span><span class="s1">self.value == other.value</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_base_missing_value(cls</span><span class="s2">, </span><span class="s1">dtype: np.dtype) -&gt; int | float:</span>
        <span class="s2">if </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int8:</span>
            <span class="s1">value = cls.BASE_MISSING_VALUES[</span><span class="s3">&quot;int8&quot;</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int16:</span>
            <span class="s1">value = cls.BASE_MISSING_VALUES[</span><span class="s3">&quot;int16&quot;</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int32:</span>
            <span class="s1">value = cls.BASE_MISSING_VALUES[</span><span class="s3">&quot;int32&quot;</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.float32:</span>
            <span class="s1">value = cls.BASE_MISSING_VALUES[</span><span class="s3">&quot;float32&quot;</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.float64:</span>
            <span class="s1">value = cls.BASE_MISSING_VALUES[</span><span class="s3">&quot;float64&quot;</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported dtype&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">value</span>


<span class="s2">class </span><span class="s1">StataParser:</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>

        <span class="s5"># type          code.</span>
        <span class="s5"># --------------------</span>
        <span class="s5"># str1        1 = 0x01</span>
        <span class="s5"># str2        2 = 0x02</span>
        <span class="s5"># ...</span>
        <span class="s5"># str244    244 = 0xf4</span>
        <span class="s5"># byte      251 = 0xfb  (sic)</span>
        <span class="s5"># int       252 = 0xfc</span>
        <span class="s5"># long      253 = 0xfd</span>
        <span class="s5"># float     254 = 0xfe</span>
        <span class="s5"># double    255 = 0xff</span>
        <span class="s5"># --------------------</span>
        <span class="s5"># NOTE: the byte type seems to be reserved for categorical variables</span>
        <span class="s5"># with a label, but the underlying variable is -127 to 100</span>
        <span class="s5"># we're going to drop the label and cast to int</span>
        <span class="s1">self.DTYPE_MAP = dict(</span>
            <span class="s1">list(zip(range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">245</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[np.dtype(</span><span class="s3">&quot;a&quot; </span><span class="s1">+ str(i)) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">245</span><span class="s1">)]))</span>
            <span class="s1">+ [</span>
                <span class="s1">(</span><span class="s4">251</span><span class="s2">, </span><span class="s1">np.dtype(np.int8))</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">252</span><span class="s2">, </span><span class="s1">np.dtype(np.int16))</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">253</span><span class="s2">, </span><span class="s1">np.dtype(np.int32))</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">254</span><span class="s2">, </span><span class="s1">np.dtype(np.float32))</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">255</span><span class="s2">, </span><span class="s1">np.dtype(np.float64))</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">self.DTYPE_MAP_XML = {</span>
            <span class="s4">32768</span><span class="s1">: np.dtype(np.uint8)</span><span class="s2">,  </span><span class="s5"># Keys to GSO</span>
            <span class="s4">65526</span><span class="s1">: np.dtype(np.float64)</span><span class="s2">,</span>
            <span class="s4">65527</span><span class="s1">: np.dtype(np.float32)</span><span class="s2">,</span>
            <span class="s4">65528</span><span class="s1">: np.dtype(np.int32)</span><span class="s2">,</span>
            <span class="s4">65529</span><span class="s1">: np.dtype(np.int16)</span><span class="s2">,</span>
            <span class="s4">65530</span><span class="s1">: np.dtype(np.int8)</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s5"># error: Argument 1 to &quot;list&quot; has incompatible type &quot;str&quot;;</span>
        <span class="s5">#  expected &quot;Iterable[int]&quot;  [arg-type]</span>
        <span class="s1">self.TYPE_MAP = list(range(</span><span class="s4">251</span><span class="s1">)) + list(</span><span class="s3">&quot;bhlfd&quot;</span><span class="s1">)  </span><span class="s5"># type: ignore[arg-type]</span>
        <span class="s1">self.TYPE_MAP_XML = {</span>
            <span class="s5"># Not really a Q, unclear how to handle byteswap</span>
            <span class="s4">32768</span><span class="s1">: </span><span class="s3">&quot;Q&quot;</span><span class="s2">,</span>
            <span class="s4">65526</span><span class="s1">: </span><span class="s3">&quot;d&quot;</span><span class="s2">,</span>
            <span class="s4">65527</span><span class="s1">: </span><span class="s3">&quot;f&quot;</span><span class="s2">,</span>
            <span class="s4">65528</span><span class="s1">: </span><span class="s3">&quot;l&quot;</span><span class="s2">,</span>
            <span class="s4">65529</span><span class="s1">: </span><span class="s3">&quot;h&quot;</span><span class="s2">,</span>
            <span class="s4">65530</span><span class="s1">: </span><span class="s3">&quot;b&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s5"># NOTE: technically, some of these are wrong. there are more numbers</span>
        <span class="s5"># that can be represented. it's the 27 ABOVE and BELOW the max listed</span>
        <span class="s5"># numeric data type in [U] 12.2.2 of the 11.2 manual</span>
        <span class="s1">float32_min = </span><span class="s6">b&quot;</span><span class="s2">\xff\xff\xff\xfe</span><span class="s6">&quot;</span>
        <span class="s1">float32_max = </span><span class="s6">b&quot;</span><span class="s2">\xff\xff\xff\x7e</span><span class="s6">&quot;</span>
        <span class="s1">float64_min = </span><span class="s6">b&quot;</span><span class="s2">\xff\xff\xff\xff\xff\xff\xef\xff</span><span class="s6">&quot;</span>
        <span class="s1">float64_max = </span><span class="s6">b&quot;</span><span class="s2">\xff\xff\xff\xff\xff\xff\xdf\x7f</span><span class="s6">&quot;</span>
        <span class="s1">self.VALID_RANGE = {</span>
            <span class="s3">&quot;b&quot;</span><span class="s1">: (-</span><span class="s4">127</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;h&quot;</span><span class="s1">: (-</span><span class="s4">32767</span><span class="s2">, </span><span class="s4">32740</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;l&quot;</span><span class="s1">: (-</span><span class="s4">2147483647</span><span class="s2">, </span><span class="s4">2147483620</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;f&quot;</span><span class="s1">: (</span>
                <span class="s1">np.float32(struct.unpack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s1">float32_min)[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">np.float32(struct.unpack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s1">float32_max)[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;d&quot;</span><span class="s1">: (</span>
                <span class="s1">np.float64(struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s1">float64_min)[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">np.float64(struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s1">float64_max)[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s1">self.OLD_TYPE_MAPPING = {</span>
            <span class="s4">98</span><span class="s1">: </span><span class="s4">251</span><span class="s2">,  </span><span class="s5"># byte</span>
            <span class="s4">105</span><span class="s1">: </span><span class="s4">252</span><span class="s2">,  </span><span class="s5"># int</span>
            <span class="s4">108</span><span class="s1">: </span><span class="s4">253</span><span class="s2">,  </span><span class="s5"># long</span>
            <span class="s4">102</span><span class="s1">: </span><span class="s4">254</span><span class="s2">,  </span><span class="s5"># float</span>
            <span class="s4">100</span><span class="s1">: </span><span class="s4">255</span><span class="s2">,  </span><span class="s5"># double</span>
        <span class="s1">}</span>

        <span class="s5"># These missing values are the generic '.' in Stata, and are used</span>
        <span class="s5"># to replace nans</span>
        <span class="s1">self.MISSING_VALUES = {</span>
            <span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s4">101</span><span class="s2">,</span>
            <span class="s3">&quot;h&quot;</span><span class="s1">: </span><span class="s4">32741</span><span class="s2">,</span>
            <span class="s3">&quot;l&quot;</span><span class="s1">: </span><span class="s4">2147483621</span><span class="s2">,</span>
            <span class="s3">&quot;f&quot;</span><span class="s1">: np.float32(struct.unpack(</span><span class="s3">&quot;&lt;f&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x7f</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s3">&quot;d&quot;</span><span class="s1">: np.float64(</span>
                <span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;d&quot;</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x00\x00\x00\xe0\x7f</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">self.NUMPY_TYPE_MAP = {</span>
            <span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s3">&quot;i1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;h&quot;</span><span class="s1">: </span><span class="s3">&quot;i2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;l&quot;</span><span class="s1">: </span><span class="s3">&quot;i4&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;f&quot;</span><span class="s1">: </span><span class="s3">&quot;f4&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;d&quot;</span><span class="s1">: </span><span class="s3">&quot;f8&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Q&quot;</span><span class="s1">: </span><span class="s3">&quot;u8&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s5"># Reserved words cannot be used as variable names</span>
        <span class="s1">self.RESERVED_WORDS = (</span>
            <span class="s3">&quot;aggregate&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;array&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;break&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;byte&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;case&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;catch&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;class&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;colvector&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;complex&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;const&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;continue&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;default&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;delegate&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;delete&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;do&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;double&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;else&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;eltypedef&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;end&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;enum&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;explicit&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;export&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;external&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;float&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;for&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;friend&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;function&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;global&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;goto&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;if&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;inline&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;int&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;local&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;long&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;NULL&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pragma&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;protected&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;quad&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;rowvector&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;short&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;typedef&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;typename&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;virtual&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_all&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_N&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_skip&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_b&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_pi&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;str#&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;in&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_pred&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;strL&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_coef&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_rc&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;using&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_cons&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_se&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;with&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_n&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">StataReader(StataParser</span><span class="s2">, </span><span class="s1">abc.Iterator):</span>
    <span class="s1">__doc__ = _stata_reader_doc</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_or_buf: FilePath | ReadBuffer[bytes]</span><span class="s2">,</span>
        <span class="s1">convert_dates: bool = </span><span class="s2">True,</span>
        <span class="s1">convert_categoricals: bool = </span><span class="s2">True,</span>
        <span class="s1">index_col: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">convert_missing: bool = </span><span class="s2">False,</span>
        <span class="s1">preserve_dtypes: bool = </span><span class="s2">True,</span>
        <span class="s1">columns: Sequence[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">order_categoricals: bool = </span><span class="s2">True,</span>
        <span class="s1">chunksize: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.col_sizes: list[int] = []</span>

        <span class="s5"># Arguments to the reader (can be temporarily overridden in</span>
        <span class="s5"># calls to read).</span>
        <span class="s1">self._convert_dates = convert_dates</span>
        <span class="s1">self._convert_categoricals = convert_categoricals</span>
        <span class="s1">self._index_col = index_col</span>
        <span class="s1">self._convert_missing = convert_missing</span>
        <span class="s1">self._preserve_dtypes = preserve_dtypes</span>
        <span class="s1">self._columns = columns</span>
        <span class="s1">self._order_categoricals = order_categoricals</span>
        <span class="s1">self._encoding = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self._chunksize = chunksize</span>
        <span class="s1">self._using_iterator = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">self._chunksize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._chunksize = </span><span class="s4">1</span>
        <span class="s2">elif not </span><span class="s1">isinstance(chunksize</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">chunksize &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;chunksize must be a positive integer when set.&quot;</span><span class="s1">)</span>

        <span class="s5"># State variables for the file</span>
        <span class="s1">self._has_string_data = </span><span class="s2">False</span>
        <span class="s1">self._missing_values = </span><span class="s2">False</span>
        <span class="s1">self._can_read_value_labels = </span><span class="s2">False</span>
        <span class="s1">self._column_selector_set = </span><span class="s2">False</span>
        <span class="s1">self._value_labels_read = </span><span class="s2">False</span>
        <span class="s1">self._data_read = </span><span class="s2">False</span>
        <span class="s1">self._dtype: np.dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
        <span class="s1">self._lines_read = </span><span class="s4">0</span>

        <span class="s1">self._native_byteorder = _set_endianness(sys.byteorder)</span>
        <span class="s2">with </span><span class="s1">get_handle(</span>
            <span class="s1">path_or_buf</span><span class="s2">,</span>
            <span class="s3">&quot;rb&quot;</span><span class="s2">,</span>
            <span class="s1">storage_options=storage_options</span><span class="s2">,</span>
            <span class="s1">is_text=</span><span class="s2">False,</span>
            <span class="s1">compression=compression</span><span class="s2">,</span>
        <span class="s1">) </span><span class="s2">as </span><span class="s1">handles:</span>
            <span class="s5"># Copy to BytesIO, and ensure no encoding</span>
            <span class="s1">self.path_or_buf = BytesIO(handles.handle.read())</span>

        <span class="s1">self._read_header()</span>
        <span class="s1">self._setup_dtype()</span>

    <span class="s2">def </span><span class="s1">__enter__(self) -&gt; StataReader:</span>
        <span class="s0">&quot;&quot;&quot;enter context manager&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">exc_type</span><span class="s2">, </span><span class="s1">exc_value</span><span class="s2">, </span><span class="s1">traceback) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;exit context manager&quot;&quot;&quot;</span>
        <span class="s1">self.close()</span>

    <span class="s2">def </span><span class="s1">close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;close the handle if its open&quot;&quot;&quot;</span>
        <span class="s1">self.path_or_buf.close()</span>

    <span class="s2">def </span><span class="s1">_set_encoding(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set string encoding which depends on file version 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.format_version &lt; </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">self._encoding = </span><span class="s3">&quot;latin-1&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._encoding = </span><span class="s3">&quot;utf-8&quot;</span>

    <span class="s2">def </span><span class="s1">_read_header(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">first_char = self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">struct.unpack(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">first_char)[</span><span class="s4">0</span><span class="s1">] == </span><span class="s6">b&quot;&lt;&quot;</span><span class="s1">:</span>
            <span class="s1">self._read_new_header()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._read_old_header(first_char)</span>

        <span class="s1">self.has_string_data = len([x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.typlist </span><span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">int]) &gt; </span><span class="s4">0</span>

        <span class="s5"># calculate size of a data record</span>
        <span class="s1">self.col_sizes = [self._calcsize(typ) </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">self.typlist]</span>

    <span class="s2">def </span><span class="s1">_read_new_header(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># The first part of the header is common to 117 - 119.</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">27</span><span class="s1">)  </span><span class="s5"># stata_dta&gt;&lt;header&gt;&lt;release&gt;</span>
        <span class="s1">self.format_version = int(self.path_or_buf.read(</span><span class="s4">3</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self.format_version </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">117</span><span class="s2">, </span><span class="s4">118</span><span class="s2">, </span><span class="s4">119</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(_version_error.format(version=self.format_version))</span>
        <span class="s1">self._set_encoding()</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">21</span><span class="s1">)  </span><span class="s5"># &lt;/release&gt;&lt;byteorder&gt;</span>
        <span class="s1">self.byteorder = self.path_or_buf.read(</span><span class="s4">3</span><span class="s1">) == </span><span class="s6">b&quot;MSF&quot; </span><span class="s2">and </span><span class="s3">&quot;&gt;&quot; </span><span class="s2">or </span><span class="s3">&quot;&lt;&quot;</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">15</span><span class="s1">)  </span><span class="s5"># &lt;/byteorder&gt;&lt;K&gt;</span>
        <span class="s1">nvar_type = </span><span class="s3">&quot;H&quot; </span><span class="s2">if </span><span class="s1">self.format_version &lt;= </span><span class="s4">118 </span><span class="s2">else </span><span class="s3">&quot;I&quot;</span>
        <span class="s1">nvar_size = </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">self.format_version &lt;= </span><span class="s4">118 </span><span class="s2">else </span><span class="s4">4</span>
        <span class="s1">self.nvar = struct.unpack(</span>
            <span class="s1">self.byteorder + nvar_type</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(nvar_size)</span>
        <span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">7</span><span class="s1">)  </span><span class="s5"># &lt;/K&gt;&lt;N&gt;</span>

        <span class="s1">self.nobs = self._get_nobs()</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">11</span><span class="s1">)  </span><span class="s5"># &lt;/N&gt;&lt;label&gt;</span>
        <span class="s1">self._data_label = self._get_data_label()</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">19</span><span class="s1">)  </span><span class="s5"># &lt;/label&gt;&lt;timestamp&gt;</span>
        <span class="s1">self.time_stamp = self._get_time_stamp()</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">26</span><span class="s1">)  </span><span class="s5"># &lt;/timestamp&gt;&lt;/header&gt;&lt;map&gt;</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">)  </span><span class="s5"># 0x0000000000000000</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">)  </span><span class="s5"># position of &lt;map&gt;</span>

        <span class="s1">self._seek_vartypes = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">16</span>
        <span class="s1">)</span>
        <span class="s1">self._seek_varnames = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">10</span>
        <span class="s1">)</span>
        <span class="s1">self._seek_sortlist = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">10</span>
        <span class="s1">)</span>
        <span class="s1">self._seek_formats = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">9</span>
        <span class="s1">)</span>
        <span class="s1">self._seek_value_label_names = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">19</span>
        <span class="s1">)</span>

        <span class="s5"># Requires version-specific treatment</span>
        <span class="s1">self._seek_variable_labels = self._get_seek_variable_labels()</span>

        <span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">)  </span><span class="s5"># &lt;characteristics&gt;</span>
        <span class="s1">self.data_location = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">6</span>
        <span class="s1">)</span>
        <span class="s1">self.seek_strls = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">7</span>
        <span class="s1">)</span>
        <span class="s1">self.seek_value_labels = (</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">14</span>
        <span class="s1">)</span>

        <span class="s1">self.typlist</span><span class="s2">, </span><span class="s1">self.dtyplist = self._get_dtypes(self._seek_vartypes)</span>

        <span class="s1">self.path_or_buf.seek(self._seek_varnames)</span>
        <span class="s1">self.varlist = self._get_varlist()</span>

        <span class="s1">self.path_or_buf.seek(self._seek_sortlist)</span>
        <span class="s1">self.srtlist = struct.unpack(</span>
            <span class="s1">self.byteorder + (</span><span class="s3">&quot;h&quot; </span><span class="s1">* (self.nvar + </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">self.path_or_buf.read(</span><span class="s4">2 </span><span class="s1">* (self.nvar + </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">)[:-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">self.path_or_buf.seek(self._seek_formats)</span>
        <span class="s1">self.fmtlist = self._get_fmtlist()</span>

        <span class="s1">self.path_or_buf.seek(self._seek_value_label_names)</span>
        <span class="s1">self.lbllist = self._get_lbllist()</span>

        <span class="s1">self.path_or_buf.seek(self._seek_variable_labels)</span>
        <span class="s1">self._variable_labels = self._get_variable_labels()</span>

    <span class="s5"># Get data type information, works for versions 117-119.</span>
    <span class="s2">def </span><span class="s1">_get_dtypes(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">seek_vartypes: int</span>
    <span class="s1">) -&gt; tuple[list[int | str]</span><span class="s2">, </span><span class="s1">list[str | np.dtype]]:</span>

        <span class="s1">self.path_or_buf.seek(seek_vartypes)</span>
        <span class="s1">raw_typlist = [</span>
            <span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">2</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)</span>
        <span class="s1">]</span>

        <span class="s2">def </span><span class="s1">f(typ: int) -&gt; int | str:</span>
            <span class="s2">if </span><span class="s1">typ &lt;= </span><span class="s4">2045</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">typ</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.TYPE_MAP_XML[typ]</span>
            <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;cannot convert stata types [</span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s1">typlist = [f(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">raw_typlist]</span>

        <span class="s2">def </span><span class="s1">g(typ: int) -&gt; str | np.dtype:</span>
            <span class="s2">if </span><span class="s1">typ &lt;= </span><span class="s4">2045</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">str(typ)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s5"># error: Incompatible return value type (got &quot;Type[number]&quot;, expected</span>
                <span class="s5"># &quot;Union[str, dtype]&quot;)</span>
                <span class="s2">return </span><span class="s1">self.DTYPE_MAP_XML[typ]  </span><span class="s5"># type: ignore[return-value]</span>
            <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;cannot convert stata dtype [</span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s1">dtyplist = [g(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">raw_typlist]</span>

        <span class="s2">return </span><span class="s1">typlist</span><span class="s2">, </span><span class="s1">dtyplist</span>

    <span class="s2">def </span><span class="s1">_get_varlist(self) -&gt; list[str]:</span>
        <span class="s5"># 33 in order formats, 129 in formats 118 and 119</span>
        <span class="s1">b = </span><span class="s4">33 </span><span class="s2">if </span><span class="s1">self.format_version &lt; </span><span class="s4">118 </span><span class="s2">else </span><span class="s4">129</span>
        <span class="s2">return </span><span class="s1">[self._decode(self.path_or_buf.read(b)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)]</span>

    <span class="s5"># Returns the format list</span>
    <span class="s2">def </span><span class="s1">_get_fmtlist(self) -&gt; list[str]:</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">57</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt; </span><span class="s4">113</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">49</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt; </span><span class="s4">104</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">12</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">7</span>

        <span class="s2">return </span><span class="s1">[self._decode(self.path_or_buf.read(b)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)]</span>

    <span class="s5"># Returns the label list</span>
    <span class="s2">def </span><span class="s1">_get_lbllist(self) -&gt; list[str]:</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">129</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt; </span><span class="s4">108</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">33</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s4">9</span>
        <span class="s2">return </span><span class="s1">[self._decode(self.path_or_buf.read(b)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)]</span>

    <span class="s2">def </span><span class="s1">_get_variable_labels(self) -&gt; list[str]:</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">vlblist = [</span>
                <span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">321</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)</span>
            <span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt; </span><span class="s4">105</span><span class="s1">:</span>
            <span class="s1">vlblist = [</span>
                <span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">81</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vlblist = [</span>
                <span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">32</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)</span>
            <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">vlblist</span>

    <span class="s2">def </span><span class="s1">_get_nobs(self) -&gt; int:</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_get_data_label(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">strlen = struct.unpack(self.byteorder + </span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">2</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">self._decode(self.path_or_buf.read(strlen))</span>
        <span class="s2">elif </span><span class="s1">self.format_version == </span><span class="s4">117</span><span class="s1">:</span>
            <span class="s1">strlen = struct.unpack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">self._decode(self.path_or_buf.read(strlen))</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt; </span><span class="s4">105</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">81</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">32</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_get_time_stamp(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">strlen = struct.unpack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">self.path_or_buf.read(strlen).decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.format_version == </span><span class="s4">117</span><span class="s1">:</span>
            <span class="s1">strlen = struct.unpack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">self._decode(self.path_or_buf.read(strlen))</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt; </span><span class="s4">104</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">18</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError()</span>

    <span class="s2">def </span><span class="s1">_get_seek_variable_labels(self) -&gt; int:</span>
        <span class="s2">if </span><span class="s1">self.format_version == </span><span class="s4">117</span><span class="s1">:</span>
            <span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">)  </span><span class="s5"># &lt;variable_labels&gt;, throw away</span>
            <span class="s5"># Stata 117 data files do not follow the described format.  This is</span>
            <span class="s5"># a work around that uses the previous label, 33 bytes for each</span>
            <span class="s5"># variable, 20 for the closing tag and 17 for the opening tag</span>
            <span class="s2">return </span><span class="s1">self._seek_value_label_names + (</span><span class="s4">33 </span><span class="s1">* self.nvar) + </span><span class="s4">20 </span><span class="s1">+ </span><span class="s4">17</span>
        <span class="s2">elif </span><span class="s1">self.format_version &gt;= </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">struct.unpack(self.byteorder + </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">17</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError()</span>

    <span class="s2">def </span><span class="s1">_read_old_header(self</span><span class="s2">, </span><span class="s1">first_char: bytes) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.format_version = struct.unpack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">first_char)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.format_version </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">104</span><span class="s2">, </span><span class="s4">105</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">111</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">115</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(_version_error.format(version=self.format_version))</span>
        <span class="s1">self._set_encoding()</span>
        <span class="s1">self.byteorder = (</span>
            <span class="s1">struct.unpack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0x1 </span><span class="s2">and </span><span class="s3">&quot;&gt;&quot; </span><span class="s2">or </span><span class="s3">&quot;&lt;&quot;</span>
        <span class="s1">)</span>
        <span class="s1">self.filetype = struct.unpack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># unused</span>

        <span class="s1">self.nvar = struct.unpack(self.byteorder + </span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">2</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.nobs = self._get_nobs()</span>

        <span class="s1">self._data_label = self._get_data_label()</span>

        <span class="s1">self.time_stamp = self._get_time_stamp()</span>

        <span class="s5"># descriptors</span>
        <span class="s2">if </span><span class="s1">self.format_version &gt; </span><span class="s4">108</span><span class="s1">:</span>
            <span class="s1">typlist = [ord(self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buf = self.path_or_buf.read(self.nvar)</span>
            <span class="s1">typlistb = np.frombuffer(buf</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>
            <span class="s1">typlist = []</span>
            <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">typlistb:</span>
                <span class="s2">if </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self.OLD_TYPE_MAPPING:</span>
                    <span class="s1">typlist.append(self.OLD_TYPE_MAPPING[tp])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">typlist.append(tp - </span><span class="s4">127</span><span class="s1">)  </span><span class="s5"># bytes</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.typlist = [self.TYPE_MAP[typ] </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">typlist]</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">invalid_types = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join([str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">typlist])</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;cannot convert stata types [</span><span class="s2">{</span><span class="s1">invalid_types</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.dtyplist = [self.DTYPE_MAP[typ] </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">typlist]</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">invalid_dtypes = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join([str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">typlist])</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;cannot convert stata dtypes [</span><span class="s2">{</span><span class="s1">invalid_dtypes</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s2">if </span><span class="s1">self.format_version &gt; </span><span class="s4">108</span><span class="s1">:</span>
            <span class="s1">self.varlist = [</span>
                <span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">33</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.varlist = [</span>
                <span class="s1">self._decode(self.path_or_buf.read(</span><span class="s4">9</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar)</span>
            <span class="s1">]</span>
        <span class="s1">self.srtlist = struct.unpack(</span>
            <span class="s1">self.byteorder + (</span><span class="s3">&quot;h&quot; </span><span class="s1">* (self.nvar + </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">self.path_or_buf.read(</span><span class="s4">2 </span><span class="s1">* (self.nvar + </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">)[:-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">self.fmtlist = self._get_fmtlist()</span>

        <span class="s1">self.lbllist = self._get_lbllist()</span>

        <span class="s1">self._variable_labels = self._get_variable_labels()</span>

        <span class="s5"># ignore expansion fields (Format 105 and later)</span>
        <span class="s5"># When reading, read five bytes; the last four bytes now tell you</span>
        <span class="s5"># the size of the next read, which you discard.  You then continue</span>
        <span class="s5"># like this until you read 5 bytes of zeros.</span>

        <span class="s2">if </span><span class="s1">self.format_version &gt; </span><span class="s4">104</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">data_type = struct.unpack(</span>
                    <span class="s1">self.byteorder + </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">self.format_version &gt; </span><span class="s4">108</span><span class="s1">:</span>
                    <span class="s1">data_len = struct.unpack(</span>
                        <span class="s1">self.byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">4</span><span class="s1">)</span>
                    <span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">data_len = struct.unpack(</span>
                        <span class="s1">self.byteorder + </span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">2</span><span class="s1">)</span>
                    <span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">data_type == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">break</span>
                <span class="s1">self.path_or_buf.read(data_len)</span>

        <span class="s5"># necessary data to continue parsing</span>
        <span class="s1">self.data_location = self.path_or_buf.tell()</span>

    <span class="s2">def </span><span class="s1">_setup_dtype(self) -&gt; np.dtype:</span>
        <span class="s0">&quot;&quot;&quot;Map between numpy and state dtypes&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._dtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._dtype</span>

        <span class="s1">dtypes = []  </span><span class="s5"># Convert struct data types to numpy data type</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">enumerate(self.typlist):</span>
            <span class="s2">if </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">self.NUMPY_TYPE_MAP:</span>
                <span class="s1">typ = cast(str</span><span class="s2">, </span><span class="s1">typ)  </span><span class="s5"># only strs in NUMPY_TYPE_MAP</span>
                <span class="s1">dtypes.append((</span><span class="s3">&quot;s&quot; </span><span class="s1">+ str(i)</span><span class="s2">, </span><span class="s1">self.byteorder + self.NUMPY_TYPE_MAP[typ]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dtypes.append((</span><span class="s3">&quot;s&quot; </span><span class="s1">+ str(i)</span><span class="s2">, </span><span class="s3">&quot;S&quot; </span><span class="s1">+ str(typ)))</span>
        <span class="s1">self._dtype = np.dtype(dtypes)</span>

        <span class="s2">return </span><span class="s1">self._dtype</span>

    <span class="s2">def </span><span class="s1">_calcsize(self</span><span class="s2">, </span><span class="s1">fmt: int | str) -&gt; int:</span>
        <span class="s2">if </span><span class="s1">isinstance(fmt</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">return </span><span class="s1">fmt</span>
        <span class="s2">return </span><span class="s1">struct.calcsize(self.byteorder + fmt)</span>

    <span class="s2">def </span><span class="s1">_decode(self</span><span class="s2">, </span><span class="s1">s: bytes) -&gt; str:</span>
        <span class="s5"># have bytes not strings, so must decode</span>
        <span class="s1">s = s.partition(</span><span class="s6">b&quot;</span><span class="s2">\0</span><span class="s6">&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">s.decode(self._encoding)</span>
        <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
            <span class="s5"># GH 25960, fallback to handle incorrect format produced when 117</span>
            <span class="s5"># files are converted to 118 files in Stata</span>
            <span class="s1">encoding = self._encoding</span>
            <span class="s1">msg = </span><span class="s3">f&quot;&quot;&quot;</span>
<span class="s3">One or more strings in the dta file could not be decoded using </span><span class="s2">{</span><span class="s1">encoding</span><span class="s2">}</span><span class="s3">, and</span>
<span class="s3">so the fallback encoding of latin-1 is being used.  This can happen when a file</span>
<span class="s3">has been incorrectly encoded by Stata or some other software. You should verify</span>
<span class="s3">the string values returned are correct.&quot;&quot;&quot;</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UnicodeWarning)</span>
            <span class="s2">return </span><span class="s1">s.decode(</span><span class="s3">&quot;latin-1&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_read_value_labels(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._value_labels_read:</span>
            <span class="s5"># Don't read twice</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self.format_version &lt;= </span><span class="s4">108</span><span class="s1">:</span>
            <span class="s5"># Value labels are not supported in version 108 and earlier.</span>
            <span class="s1">self._value_labels_read = </span><span class="s2">True</span>
            <span class="s1">self.value_label_dict: dict[str</span><span class="s2">, </span><span class="s1">dict[float | int</span><span class="s2">, </span><span class="s1">str]] = {}</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">117</span><span class="s1">:</span>
            <span class="s1">self.path_or_buf.seek(self.seek_value_labels)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">self._dtype </span><span class="s2">is not None</span>
            <span class="s1">offset = self.nobs * self._dtype.itemsize</span>
            <span class="s1">self.path_or_buf.seek(self.data_location + offset)</span>

        <span class="s1">self._value_labels_read = </span><span class="s2">True</span>
        <span class="s1">self.value_label_dict = {}</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">117</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self.path_or_buf.read(</span><span class="s4">5</span><span class="s1">) == </span><span class="s6">b&quot;&lt;/val&quot;</span><span class="s1">:  </span><span class="s5"># &lt;lbl&gt;</span>
                    <span class="s2">break  </span><span class="s5"># end of value label table</span>

            <span class="s1">slength = self.path_or_buf.read(</span><span class="s4">4</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">slength:</span>
                <span class="s2">break  </span><span class="s5"># end of value label table (format &lt; 117)</span>
            <span class="s2">if </span><span class="s1">self.format_version &lt;= </span><span class="s4">117</span><span class="s1">:</span>
                <span class="s1">labname = self._decode(self.path_or_buf.read(</span><span class="s4">33</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">labname = self._decode(self.path_or_buf.read(</span><span class="s4">129</span><span class="s1">))</span>
            <span class="s1">self.path_or_buf.read(</span><span class="s4">3</span><span class="s1">)  </span><span class="s5"># padding</span>

            <span class="s1">n = struct.unpack(self.byteorder + </span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">txtlen = struct.unpack(self.byteorder + </span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">off = np.frombuffer(</span>
                <span class="s1">self.path_or_buf.read(</span><span class="s4">4 </span><span class="s1">* n)</span><span class="s2">, </span><span class="s1">dtype=self.byteorder + </span><span class="s3">&quot;i4&quot;</span><span class="s2">, </span><span class="s1">count=n</span>
            <span class="s1">)</span>
            <span class="s1">val = np.frombuffer(</span>
                <span class="s1">self.path_or_buf.read(</span><span class="s4">4 </span><span class="s1">* n)</span><span class="s2">, </span><span class="s1">dtype=self.byteorder + </span><span class="s3">&quot;i4&quot;</span><span class="s2">, </span><span class="s1">count=n</span>
            <span class="s1">)</span>
            <span class="s1">ii = np.argsort(off)</span>
            <span class="s1">off = off[ii]</span>
            <span class="s1">val = val[ii]</span>
            <span class="s1">txt = self.path_or_buf.read(txtlen)</span>
            <span class="s1">self.value_label_dict[labname] = {}</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
                <span class="s1">end = off[i + </span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">i &lt; n - </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">txtlen</span>
                <span class="s1">self.value_label_dict[labname][val[i]] = self._decode(txt[off[i] : end])</span>
            <span class="s2">if </span><span class="s1">self.format_version &gt;= </span><span class="s4">117</span><span class="s1">:</span>
                <span class="s1">self.path_or_buf.read(</span><span class="s4">6</span><span class="s1">)  </span><span class="s5"># &lt;/lbl&gt;</span>
        <span class="s1">self._value_labels_read = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_read_strls(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.path_or_buf.seek(self.seek_strls)</span>
        <span class="s5"># Wrap v_o in a string to allow uint64 values as keys on 32bit OS</span>
        <span class="s1">self.GSO = {</span><span class="s3">&quot;0&quot;</span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">}</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.path_or_buf.read(</span><span class="s4">3</span><span class="s1">) != </span><span class="s6">b&quot;GSO&quot;</span><span class="s1">:</span>
                <span class="s2">break</span>

            <span class="s2">if </span><span class="s1">self.format_version == </span><span class="s4">117</span><span class="s1">:</span>
                <span class="s1">v_o = struct.unpack(self.byteorder + </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">buf = self.path_or_buf.read(</span><span class="s4">12</span><span class="s1">)</span>
                <span class="s5"># Only tested on little endian file on little endian machine.</span>
                <span class="s1">v_size = </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">self.format_version == </span><span class="s4">118 </span><span class="s2">else </span><span class="s4">3</span>
                <span class="s2">if </span><span class="s1">self.byteorder == </span><span class="s3">&quot;&lt;&quot;</span><span class="s1">:</span>
                    <span class="s1">buf = buf[</span><span class="s4">0</span><span class="s1">:v_size] + buf[</span><span class="s4">4 </span><span class="s1">: (</span><span class="s4">12 </span><span class="s1">- v_size)]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># This path may not be correct, impossible to test</span>
                    <span class="s1">buf = buf[</span><span class="s4">0</span><span class="s1">:v_size] + buf[(</span><span class="s4">4 </span><span class="s1">+ v_size) :]</span>
                <span class="s1">v_o = struct.unpack(</span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s1">buf)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">typ = struct.unpack(</span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">length = struct.unpack(self.byteorder + </span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s1">self.path_or_buf.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">va = self.path_or_buf.read(length)</span>
            <span class="s2">if </span><span class="s1">typ == </span><span class="s4">130</span><span class="s1">:</span>
                <span class="s1">decoded_va = va[</span><span class="s4">0</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">].decode(self._encoding)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># Stata says typ 129 can be binary, so use str</span>
                <span class="s1">decoded_va = str(va)</span>
                <span class="s5"># Wrap v_o in a string to allow uint64 values as keys on 32bit OS</span>
            <span class="s1">self.GSO[str(v_o)] = decoded_va</span>

    <span class="s2">def </span><span class="s1">__next__(self) -&gt; DataFrame:</span>
        <span class="s1">self._using_iterator = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self.read(nrows=self._chunksize)</span>

    <span class="s2">def </span><span class="s1">get_chunk(self</span><span class="s2">, </span><span class="s1">size: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot; 
        Reads lines from Stata file and returns as dataframe 
 
        Parameters 
        ---------- 
        size : int, defaults to None 
            Number of lines to read.  If None, reads whole file. 
 
        Returns 
        ------- 
        DataFrame 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">size = self._chunksize</span>
        <span class="s2">return </span><span class="s1">self.read(nrows=size)</span>

    <span class="s1">@Appender(_read_method_doc)</span>
    <span class="s2">def </span><span class="s1">read(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">nrows: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">convert_dates: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">convert_categoricals: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">index_col: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">convert_missing: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">preserve_dtypes: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">columns: Sequence[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">order_categoricals: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; DataFrame:</span>
        <span class="s5"># Handle empty file or chunk.  If reading incrementally raise</span>
        <span class="s5"># StopIteration.  If reading the whole thing return an empty</span>
        <span class="s5"># data frame.</span>
        <span class="s2">if </span><span class="s1">(self.nobs == </span><span class="s4">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(nrows </span><span class="s2">is None</span><span class="s1">):</span>
            <span class="s1">self._can_read_value_labels = </span><span class="s2">True</span>
            <span class="s1">self._data_read = </span><span class="s2">True</span>
            <span class="s1">self.close()</span>
            <span class="s2">return </span><span class="s1">DataFrame(columns=self.varlist)</span>

        <span class="s5"># Handle options</span>
        <span class="s2">if </span><span class="s1">convert_dates </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">convert_dates = self._convert_dates</span>
        <span class="s2">if </span><span class="s1">convert_categoricals </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">convert_categoricals = self._convert_categoricals</span>
        <span class="s2">if </span><span class="s1">convert_missing </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">convert_missing = self._convert_missing</span>
        <span class="s2">if </span><span class="s1">preserve_dtypes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">preserve_dtypes = self._preserve_dtypes</span>
        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">columns = self._columns</span>
        <span class="s2">if </span><span class="s1">order_categoricals </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">order_categoricals = self._order_categoricals</span>
        <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">index_col = self._index_col</span>

        <span class="s2">if </span><span class="s1">nrows </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">nrows = self.nobs</span>

        <span class="s2">if </span><span class="s1">(self.format_version &gt;= </span><span class="s4">117</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">self._value_labels_read):</span>
            <span class="s1">self._can_read_value_labels = </span><span class="s2">True</span>
            <span class="s1">self._read_strls()</span>

        <span class="s5"># Read data</span>
        <span class="s2">assert </span><span class="s1">self._dtype </span><span class="s2">is not None</span>
        <span class="s1">dtype = self._dtype</span>
        <span class="s1">max_read_len = (self.nobs - self._lines_read) * dtype.itemsize</span>
        <span class="s1">read_len = nrows * dtype.itemsize</span>
        <span class="s1">read_len = min(read_len</span><span class="s2">, </span><span class="s1">max_read_len)</span>
        <span class="s2">if </span><span class="s1">read_len &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># Iterator has finished, should never be here unless</span>
            <span class="s5"># we are reading the file incrementally</span>
            <span class="s2">if </span><span class="s1">convert_categoricals:</span>
                <span class="s1">self._read_value_labels()</span>
            <span class="s1">self.close()</span>
            <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s1">offset = self._lines_read * dtype.itemsize</span>
        <span class="s1">self.path_or_buf.seek(self.data_location + offset)</span>
        <span class="s1">read_lines = min(nrows</span><span class="s2">, </span><span class="s1">self.nobs - self._lines_read)</span>
        <span class="s1">raw_data = np.frombuffer(</span>
            <span class="s1">self.path_or_buf.read(read_len)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">count=read_lines</span>
        <span class="s1">)</span>

        <span class="s1">self._lines_read += read_lines</span>
        <span class="s2">if </span><span class="s1">self._lines_read == self.nobs:</span>
            <span class="s1">self._can_read_value_labels = </span><span class="s2">True</span>
            <span class="s1">self._data_read = </span><span class="s2">True</span>
        <span class="s5"># if necessary, swap the byte order to native here</span>
        <span class="s2">if </span><span class="s1">self.byteorder != self._native_byteorder:</span>
            <span class="s1">raw_data = raw_data.byteswap().newbyteorder()</span>

        <span class="s2">if </span><span class="s1">convert_categoricals:</span>
            <span class="s1">self._read_value_labels()</span>

        <span class="s2">if </span><span class="s1">len(raw_data) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">data = DataFrame(columns=self.varlist)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = DataFrame.from_records(raw_data)</span>
            <span class="s1">data.columns = Index(self.varlist)</span>

        <span class="s5"># If index is not specified, use actual row number rather than</span>
        <span class="s5"># restarting at 0 for each chunk.</span>
        <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rng = np.arange(self._lines_read - read_lines</span><span class="s2">, </span><span class="s1">self._lines_read)</span>
            <span class="s1">data.index = Index(rng)  </span><span class="s5"># set attr instead of set_index to avoid copy</span>

        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">data = self._do_select_columns(data</span><span class="s2">, </span><span class="s1">columns)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s1">self.close()</span>
                <span class="s2">raise</span>

        <span class="s5"># Decode strings</span>
        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">zip(data</span><span class="s2">, </span><span class="s1">self.typlist):</span>
            <span class="s2">if </span><span class="s1">type(typ) </span><span class="s2">is </span><span class="s1">int:</span>
                <span class="s1">data[col] = data[col].apply(self._decode</span><span class="s2">, </span><span class="s1">convert_dtype=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">data = self._insert_strls(data)</span>

        <span class="s1">cols_ = np.where([dtyp </span><span class="s2">is not None for </span><span class="s1">dtyp </span><span class="s2">in </span><span class="s1">self.dtyplist])[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s5"># Convert columns (if needed) to match input type</span>
        <span class="s1">ix = data.index</span>
        <span class="s1">requires_type_conversion = </span><span class="s2">False</span>
        <span class="s1">data_formatted = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cols_:</span>
            <span class="s2">if </span><span class="s1">self.dtyplist[i] </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">col = data.columns[i]</span>
                <span class="s1">dtype = data[col].dtype</span>
                <span class="s2">if </span><span class="s1">dtype != np.dtype(object) </span><span class="s2">and </span><span class="s1">dtype != self.dtyplist[i]:</span>
                    <span class="s1">requires_type_conversion = </span><span class="s2">True</span>
                    <span class="s1">data_formatted.append(</span>
                        <span class="s1">(col</span><span class="s2">, </span><span class="s1">Series(data[col]</span><span class="s2">, </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">self.dtyplist[i]))</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">data_formatted.append((col</span><span class="s2">, </span><span class="s1">data[col]))</span>
        <span class="s2">if </span><span class="s1">requires_type_conversion:</span>
            <span class="s1">data = DataFrame.from_dict(dict(data_formatted))</span>
        <span class="s2">del </span><span class="s1">data_formatted</span>

        <span class="s1">data = self._do_convert_missing(data</span><span class="s2">, </span><span class="s1">convert_missing)</span>

        <span class="s2">if </span><span class="s1">convert_dates:</span>

            <span class="s2">def </span><span class="s1">any_startswith(x: str) -&gt; bool:</span>
                <span class="s2">return </span><span class="s1">any(x.startswith(fmt) </span><span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">_date_formats)</span>

            <span class="s1">cols = np.where([any_startswith(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.fmtlist])[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cols:</span>
                <span class="s1">col = data.columns[i]</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">data[col] = _stata_elapsed_date_to_datetime_vec(</span>
                        <span class="s1">data[col]</span><span class="s2">, </span><span class="s1">self.fmtlist[i]</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s1">self.close()</span>
                    <span class="s2">raise</span>

        <span class="s2">if </span><span class="s1">convert_categoricals </span><span class="s2">and </span><span class="s1">self.format_version &gt; </span><span class="s4">108</span><span class="s1">:</span>
            <span class="s1">data = self._do_convert_categoricals(</span>
                <span class="s1">data</span><span class="s2">, </span><span class="s1">self.value_label_dict</span><span class="s2">, </span><span class="s1">self.lbllist</span><span class="s2">, </span><span class="s1">order_categoricals</span>
            <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">preserve_dtypes:</span>
            <span class="s1">retyped_data = []</span>
            <span class="s1">convert = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">data:</span>
                <span class="s1">dtype = data[col].dtype</span>
                <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(np.dtype(np.float16)</span><span class="s2">, </span><span class="s1">np.dtype(np.float32)):</span>
                    <span class="s1">dtype = np.dtype(np.float64)</span>
                    <span class="s1">convert = </span><span class="s2">True</span>
                <span class="s2">elif </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(</span>
                    <span class="s1">np.dtype(np.int8)</span><span class="s2">,</span>
                    <span class="s1">np.dtype(np.int16)</span><span class="s2">,</span>
                    <span class="s1">np.dtype(np.int32)</span><span class="s2">,</span>
                <span class="s1">):</span>
                    <span class="s1">dtype = np.dtype(np.int64)</span>
                    <span class="s1">convert = </span><span class="s2">True</span>
                <span class="s1">retyped_data.append((col</span><span class="s2">, </span><span class="s1">data[col].astype(dtype)))</span>
            <span class="s2">if </span><span class="s1">convert:</span>
                <span class="s1">data = DataFrame.from_dict(dict(retyped_data))</span>

        <span class="s2">if </span><span class="s1">index_col </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">data = data.set_index(data.pop(index_col))</span>

        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_do_convert_missing(self</span><span class="s2">, </span><span class="s1">data: DataFrame</span><span class="s2">, </span><span class="s1">convert_missing: bool) -&gt; DataFrame:</span>
        <span class="s5"># Check for missing values, and replace if found</span>
        <span class="s1">replacements = {}</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">colname </span><span class="s2">in </span><span class="s1">enumerate(data):</span>
            <span class="s1">fmt = self.typlist[i]</span>
            <span class="s2">if </span><span class="s1">fmt </span><span class="s2">not in </span><span class="s1">self.VALID_RANGE:</span>
                <span class="s2">continue</span>

            <span class="s1">fmt = cast(str</span><span class="s2">, </span><span class="s1">fmt)  </span><span class="s5"># only strs in VALID_RANGE</span>
            <span class="s1">nmin</span><span class="s2">, </span><span class="s1">nmax = self.VALID_RANGE[fmt]</span>
            <span class="s1">series = data[colname]</span>

            <span class="s5"># appreciably faster to do this with ndarray instead of Series</span>
            <span class="s1">svals = series._values</span>
            <span class="s1">missing = (svals &lt; nmin) | (svals &gt; nmax)</span>

            <span class="s2">if not </span><span class="s1">missing.any():</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">convert_missing:  </span><span class="s5"># Replacement follows Stata notation</span>
                <span class="s1">missing_loc = np.nonzero(np.asarray(missing))[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">umissing</span><span class="s2">, </span><span class="s1">umissing_loc = np.unique(series[missing]</span><span class="s2">, </span><span class="s1">return_inverse=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">replacement = Series(series</span><span class="s2">, </span><span class="s1">dtype=object)</span>
                <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">um </span><span class="s2">in </span><span class="s1">enumerate(umissing):</span>
                    <span class="s1">missing_value = StataMissingValue(um)</span>

                    <span class="s1">loc = missing_loc[umissing_loc == j]</span>
                    <span class="s1">replacement.iloc[loc] = missing_value</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s5"># All replacements are identical</span>
                <span class="s1">dtype = series.dtype</span>
                <span class="s2">if </span><span class="s1">dtype </span><span class="s2">not in </span><span class="s1">(np.float32</span><span class="s2">, </span><span class="s1">np.float64):</span>
                    <span class="s1">dtype = np.float64</span>
                <span class="s1">replacement = Series(series</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                <span class="s2">if not </span><span class="s1">replacement._values.flags[</span><span class="s3">&quot;WRITEABLE&quot;</span><span class="s1">]:</span>
                    <span class="s5"># only relevant for ArrayManager; construction</span>
                    <span class="s5">#  path for BlockManager ensures writeability</span>
                    <span class="s1">replacement = replacement.copy()</span>
                <span class="s5"># Note: operating on ._values is much faster than directly</span>
                <span class="s5"># TODO: can we fix that?</span>
                <span class="s1">replacement._values[missing] = np.nan</span>
            <span class="s1">replacements[colname] = replacement</span>

        <span class="s2">if </span><span class="s1">replacements:</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">replacements:</span>
                <span class="s1">data[col] = replacements[col]</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_insert_strls(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; DataFrame:</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;GSO&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">len(self.GSO) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">enumerate(self.typlist):</span>
            <span class="s2">if </span><span class="s1">typ != </span><span class="s3">&quot;Q&quot;</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s5"># Wrap v_o in a string to allow uint64 values as keys on 32bit OS</span>
            <span class="s1">data.iloc[:</span><span class="s2">, </span><span class="s1">i] = [self.GSO[str(k)] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">data.iloc[:</span><span class="s2">, </span><span class="s1">i]]</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_do_select_columns(self</span><span class="s2">, </span><span class="s1">data: DataFrame</span><span class="s2">, </span><span class="s1">columns: Sequence[str]) -&gt; DataFrame:</span>

        <span class="s2">if not </span><span class="s1">self._column_selector_set:</span>
            <span class="s1">column_set = set(columns)</span>
            <span class="s2">if </span><span class="s1">len(column_set) != len(columns):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;columns contains duplicate entries&quot;</span><span class="s1">)</span>
            <span class="s1">unmatched = column_set.difference(data.columns)</span>
            <span class="s2">if </span><span class="s1">unmatched:</span>
                <span class="s1">joined = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(list(unmatched))</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;The following columns were not &quot;</span>
                    <span class="s3">f&quot;found in the Stata data set: </span><span class="s2">{</span><span class="s1">joined</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
            <span class="s5"># Copy information for retained columns for later processing</span>
            <span class="s1">dtyplist = []</span>
            <span class="s1">typlist = []</span>
            <span class="s1">fmtlist = []</span>
            <span class="s1">lbllist = []</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">columns:</span>
                <span class="s1">i = data.columns.get_loc(col)</span>
                <span class="s1">dtyplist.append(self.dtyplist[i])</span>
                <span class="s1">typlist.append(self.typlist[i])</span>
                <span class="s1">fmtlist.append(self.fmtlist[i])</span>
                <span class="s1">lbllist.append(self.lbllist[i])</span>

            <span class="s1">self.dtyplist = dtyplist</span>
            <span class="s1">self.typlist = typlist</span>
            <span class="s1">self.fmtlist = fmtlist</span>
            <span class="s1">self.lbllist = lbllist</span>
            <span class="s1">self._column_selector_set = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">data[columns]</span>

    <span class="s2">def </span><span class="s1">_do_convert_categoricals(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">data: DataFrame</span><span class="s2">,</span>
        <span class="s1">value_label_dict: dict[str</span><span class="s2">, </span><span class="s1">dict[float | int</span><span class="s2">, </span><span class="s1">str]]</span><span class="s2">,</span>
        <span class="s1">lbllist: Sequence[str]</span><span class="s2">,</span>
        <span class="s1">order_categoricals: bool</span><span class="s2">,</span>
    <span class="s1">) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts categorical columns to Categorical type. 
        &quot;&quot;&quot;</span>
        <span class="s1">value_labels = list(value_label_dict.keys())</span>
        <span class="s1">cat_converted_data = []</span>
        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">label </span><span class="s2">in </span><span class="s1">zip(data</span><span class="s2">, </span><span class="s1">lbllist):</span>
            <span class="s2">if </span><span class="s1">label </span><span class="s2">in </span><span class="s1">value_labels:</span>
                <span class="s5"># Explicit call with ordered=True</span>
                <span class="s1">vl = value_label_dict[label]</span>
                <span class="s1">keys = np.array(list(vl.keys()))</span>
                <span class="s1">column = data[col]</span>
                <span class="s1">key_matches = column.isin(keys)</span>
                <span class="s2">if </span><span class="s1">self._using_iterator </span><span class="s2">and </span><span class="s1">key_matches.all():</span>
                    <span class="s1">initial_categories: np.ndarray | </span><span class="s2">None </span><span class="s1">= keys</span>
                    <span class="s5"># If all categories are in the keys and we are iterating,</span>
                    <span class="s5"># use the same keys for all chunks. If some are missing</span>
                    <span class="s5"># value labels, then we will fall back to the categories</span>
                    <span class="s5"># varying across chunks.</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">self._using_iterator:</span>
                        <span class="s5"># warn is using an iterator</span>
                        <span class="s1">warnings.warn(</span>
                            <span class="s1">categorical_conversion_warning</span><span class="s2">, </span><span class="s1">CategoricalConversionWarning</span>
                        <span class="s1">)</span>
                    <span class="s1">initial_categories = </span><span class="s2">None</span>
                <span class="s1">cat_data = Categorical(</span>
                    <span class="s1">column</span><span class="s2">, </span><span class="s1">categories=initial_categories</span><span class="s2">, </span><span class="s1">ordered=order_categoricals</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">initial_categories </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s5"># If None here, then we need to match the cats in the Categorical</span>
                    <span class="s1">categories = []</span>
                    <span class="s2">for </span><span class="s1">category </span><span class="s2">in </span><span class="s1">cat_data.categories:</span>
                        <span class="s2">if </span><span class="s1">category </span><span class="s2">in </span><span class="s1">vl:</span>
                            <span class="s1">categories.append(vl[category])</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">categories.append(category)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># If all cats are matched, we can use the values</span>
                    <span class="s1">categories = list(vl.values())</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s5"># Try to catch duplicate categories</span>
                    <span class="s1">cat_data.categories = categories</span>
                <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                    <span class="s1">vc = Series(categories).value_counts()</span>
                    <span class="s1">repeated_cats = list(vc.index[vc &gt; </span><span class="s4">1</span><span class="s1">])</span>
                    <span class="s1">repeats = </span><span class="s3">&quot;-&quot; </span><span class="s1">* </span><span class="s4">80 </span><span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(repeated_cats)</span>
                    <span class="s5"># GH 25772</span>
                    <span class="s1">msg = </span><span class="s3">f&quot;&quot;&quot;</span>
<span class="s3">Value labels for column </span><span class="s2">{</span><span class="s1">col</span><span class="s2">} </span><span class="s3">are not unique. These cannot be converted to</span>
<span class="s3">pandas categoricals.</span>

<span class="s3">Either read the file with `convert_categoricals` set to False or use the</span>
<span class="s3">low level interface in `StataReader` to separately read the values and the</span>
<span class="s3">value_labels.</span>

<span class="s3">The repeated labels are:</span>
<span class="s2">{</span><span class="s1">repeats</span><span class="s2">}</span>
<span class="s3">&quot;&quot;&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">err</span>
                <span class="s5"># TODO: is the next line needed above in the data(...) method?</span>
                <span class="s1">cat_series = Series(cat_data</span><span class="s2">, </span><span class="s1">index=data.index)</span>
                <span class="s1">cat_converted_data.append((col</span><span class="s2">, </span><span class="s1">cat_series))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cat_converted_data.append((col</span><span class="s2">, </span><span class="s1">data[col]))</span>
        <span class="s1">data = DataFrame(dict(cat_converted_data)</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">data_label(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return data label of Stata file. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._data_label</span>

    <span class="s2">def </span><span class="s1">variable_labels(self) -&gt; dict[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return variable labels as a dict, associating each variable name 
        with corresponding label. 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">dict(zip(self.varlist</span><span class="s2">, </span><span class="s1">self._variable_labels))</span>

    <span class="s2">def </span><span class="s1">value_labels(self) -&gt; dict[str</span><span class="s2">, </span><span class="s1">dict[float | int</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a dict, associating each variable name a dict, associating 
        each value its corresponding label. 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._value_labels_read:</span>
            <span class="s1">self._read_value_labels()</span>

        <span class="s2">return </span><span class="s1">self.value_label_dict</span>


<span class="s1">@Appender(_read_stata_doc)</span>
<span class="s2">def </span><span class="s1">read_stata(</span>
    <span class="s1">filepath_or_buffer: FilePath | ReadBuffer[bytes]</span><span class="s2">,</span>
    <span class="s1">convert_dates: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_categoricals: bool = </span><span class="s2">True,</span>
    <span class="s1">index_col: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">convert_missing: bool = </span><span class="s2">False,</span>
    <span class="s1">preserve_dtypes: bool = </span><span class="s2">True,</span>
    <span class="s1">columns: Sequence[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">order_categoricals: bool = </span><span class="s2">True,</span>
    <span class="s1">chunksize: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">iterator: bool = </span><span class="s2">False,</span>
    <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
<span class="s1">) -&gt; DataFrame | StataReader:</span>

    <span class="s1">reader = StataReader(</span>
        <span class="s1">filepath_or_buffer</span><span class="s2">,</span>
        <span class="s1">convert_dates=convert_dates</span><span class="s2">,</span>
        <span class="s1">convert_categoricals=convert_categoricals</span><span class="s2">,</span>
        <span class="s1">index_col=index_col</span><span class="s2">,</span>
        <span class="s1">convert_missing=convert_missing</span><span class="s2">,</span>
        <span class="s1">preserve_dtypes=preserve_dtypes</span><span class="s2">,</span>
        <span class="s1">columns=columns</span><span class="s2">,</span>
        <span class="s1">order_categoricals=order_categoricals</span><span class="s2">,</span>
        <span class="s1">chunksize=chunksize</span><span class="s2">,</span>
        <span class="s1">storage_options=storage_options</span><span class="s2">,</span>
        <span class="s1">compression=compression</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">iterator </span><span class="s2">or </span><span class="s1">chunksize:</span>
        <span class="s2">return </span><span class="s1">reader</span>

    <span class="s2">with </span><span class="s1">reader:</span>
        <span class="s2">return </span><span class="s1">reader.read()</span>


<span class="s2">def </span><span class="s1">_set_endianness(endianness: str) -&gt; str:</span>
    <span class="s2">if </span><span class="s1">endianness.lower() </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;&lt;&quot;</span><span class="s2">, </span><span class="s3">&quot;little&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;&quot;</span>
    <span class="s2">elif </span><span class="s1">endianness.lower() </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;big&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s3">&quot;&gt;&quot;</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s5"># pragma : no cover</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Endianness </span><span class="s2">{</span><span class="s1">endianness</span><span class="s2">} </span><span class="s3">not understood&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_pad_bytes(name: AnyStr</span><span class="s2">, </span><span class="s1">length: int) -&gt; AnyStr:</span>
    <span class="s0">&quot;&quot;&quot; 
    Take a char string and pads it with null bytes until it's length chars. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">bytes):</span>
        <span class="s2">return </span><span class="s1">name + </span><span class="s6">b&quot;</span><span class="s2">\x00</span><span class="s6">&quot; </span><span class="s1">* (length - len(name))</span>
    <span class="s2">return </span><span class="s1">name + </span><span class="s3">&quot;</span><span class="s2">\x00</span><span class="s3">&quot; </span><span class="s1">* (length - len(name))</span>


<span class="s2">def </span><span class="s1">_convert_datetime_to_stata_type(fmt: str) -&gt; np.dtype:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert from one of the stata date formats to a type in TYPE_MAP. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s3">&quot;tc&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%tc&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;td&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%td&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;tw&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%tw&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;tm&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%tm&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;tq&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%tq&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;th&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%th&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;ty&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;%ty&quot;</span><span class="s2">,</span>
    <span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">np.dtype(np.float64)  </span><span class="s5"># Stata expects doubles for SIFs</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;Format </span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">} </span><span class="s3">not implemented&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_maybe_convert_to_int_keys(convert_dates: dict</span><span class="s2">, </span><span class="s1">varlist: list[Hashable]) -&gt; dict:</span>
    <span class="s1">new_dict = {}</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">convert_dates:</span>
        <span class="s2">if not </span><span class="s1">convert_dates[key].startswith(</span><span class="s3">&quot;%&quot;</span><span class="s1">):  </span><span class="s5"># make sure proper fmts</span>
            <span class="s1">convert_dates[key] = </span><span class="s3">&quot;%&quot; </span><span class="s1">+ convert_dates[key]</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">varlist:</span>
            <span class="s1">new_dict.update({varlist.index(key): convert_dates[key]})</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;convert_dates key must be a column or an integer&quot;</span><span class="s1">)</span>
            <span class="s1">new_dict.update({key: convert_dates[key]})</span>
    <span class="s2">return </span><span class="s1">new_dict</span>


<span class="s2">def </span><span class="s1">_dtype_to_stata_type(dtype: np.dtype</span><span class="s2">, </span><span class="s1">column: Series) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert dtype types to stata types. Returns the byte of the given ordinal. 
    See TYPE_MAP and comments for an explanation. This is also explained in 
    the dta spec. 
    1 - 244 are strings of this length 
                         Pandas    Stata 
    251 - for int8      byte 
    252 - for int16     int 
    253 - for int32     long 
    254 - for float32   float 
    255 - for double    double 
 
    If there are dates to convert, then dtype will already have the correct 
    type inserted. 
    &quot;&quot;&quot;</span>
    <span class="s5"># TODO: expand to handle datetime to integer conversion</span>
    <span class="s2">if </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.object_:  </span><span class="s5"># try to coerce it to the biggest string</span>
        <span class="s5"># not memory efficient, what else could we</span>
        <span class="s5"># do?</span>
        <span class="s1">itemsize = max_len_string_array(ensure_object(column._values))</span>
        <span class="s2">return </span><span class="s1">max(itemsize</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.float64:</span>
        <span class="s2">return </span><span class="s4">255</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.float32:</span>
        <span class="s2">return </span><span class="s4">254</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int32:</span>
        <span class="s2">return </span><span class="s4">253</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int16:</span>
        <span class="s2">return </span><span class="s4">252</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int8:</span>
        <span class="s2">return </span><span class="s4">251</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s5"># pragma : no cover</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;Data type </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">not supported.&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_dtype_to_default_stata_fmt(</span>
    <span class="s1">dtype</span><span class="s2">, </span><span class="s1">column: Series</span><span class="s2">, </span><span class="s1">dta_version: int = </span><span class="s4">114</span><span class="s2">, </span><span class="s1">force_strl: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot; 
    Map numpy dtype to stata's default format for this type. Not terribly 
    important since users can change this in Stata. Semantics are 
 
    object  -&gt; &quot;%DDs&quot; where DD is the length of the string.  If not a string, 
                raise ValueError 
    float64 -&gt; &quot;%10.0g&quot; 
    float32 -&gt; &quot;%9.0g&quot; 
    int64   -&gt; &quot;%9.0g&quot; 
    int32   -&gt; &quot;%12.0g&quot; 
    int16   -&gt; &quot;%8.0g&quot; 
    int8    -&gt; &quot;%8.0g&quot; 
    strl    -&gt; &quot;%9s&quot; 
    &quot;&quot;&quot;</span>
    <span class="s5"># TODO: Refactor to combine type with format</span>
    <span class="s5"># TODO: expand this to handle a default datetime format?</span>
    <span class="s2">if </span><span class="s1">dta_version &lt; </span><span class="s4">117</span><span class="s1">:</span>
        <span class="s1">max_str_len = </span><span class="s4">244</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">max_str_len = </span><span class="s4">2045</span>
        <span class="s2">if </span><span class="s1">force_strl:</span>
            <span class="s2">return </span><span class="s3">&quot;%9s&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.object_:</span>
        <span class="s1">itemsize = max_len_string_array(ensure_object(column._values))</span>
        <span class="s2">if </span><span class="s1">itemsize &gt; max_str_len:</span>
            <span class="s2">if </span><span class="s1">dta_version &gt;= </span><span class="s4">117</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">&quot;%9s&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(excessive_string_length_error.format(column.name))</span>
        <span class="s2">return </span><span class="s3">&quot;%&quot; </span><span class="s1">+ str(max(itemsize</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)) + </span><span class="s3">&quot;s&quot;</span>
    <span class="s2">elif </span><span class="s1">dtype == np.float64:</span>
        <span class="s2">return </span><span class="s3">&quot;%10.0g&quot;</span>
    <span class="s2">elif </span><span class="s1">dtype == np.float32:</span>
        <span class="s2">return </span><span class="s3">&quot;%9.0g&quot;</span>
    <span class="s2">elif </span><span class="s1">dtype == np.int32:</span>
        <span class="s2">return </span><span class="s3">&quot;%12.0g&quot;</span>
    <span class="s2">elif </span><span class="s1">dtype == np.int8 </span><span class="s2">or </span><span class="s1">dtype == np.int16:</span>
        <span class="s2">return </span><span class="s3">&quot;%8.0g&quot;</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s5"># pragma : no cover</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;Data type </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">not supported.&quot;</span><span class="s1">)</span>


<span class="s1">@doc(</span>
    <span class="s1">storage_options=_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">compression_options=_shared_docs[</span><span class="s3">&quot;compression_options&quot;</span><span class="s1">] % </span><span class="s3">&quot;fname&quot;</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">class </span><span class="s1">StataWriter(StataParser):</span>
    <span class="s0">&quot;&quot;&quot; 
    A class for writing Stata binary dta files 
 
    Parameters 
    ---------- 
    fname : path (string), buffer or path object 
        string, path object (pathlib.Path or py._path.local.LocalPath) or 
        object implementing a binary write() functions. If using a buffer 
        then the buffer will not be automatically closed after the file 
        is written. 
    data : DataFrame 
        Input to save 
    convert_dates : dict 
        Dictionary mapping columns containing datetime types to stata internal 
        format to use when writing the dates. Options are 'tc', 'td', 'tm', 
        'tw', 'th', 'tq', 'ty'. Column can be either an integer or a name. 
        Datetime columns that do not have a conversion type specified will be 
        converted to 'tc'. Raises NotImplementedError if a datetime column has 
        timezone information 
    write_index : bool 
        Write the index to Stata dataset. 
    byteorder : str 
        Can be &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;little&quot;, or &quot;big&quot;. default is `sys.byteorder` 
    time_stamp : datetime 
        A datetime to use as file creation date.  Default is the current time 
    data_label : str 
        A label for the data set.  Must be 80 characters or smaller. 
    variable_labels : dict 
        Dictionary containing columns as keys and variable labels as values. 
        Each label must be 80 characters or smaller. 
    {compression_options} 
 
        .. versionadded:: 1.1.0 
 
        .. versionchanged:: 1.4.0 Zstandard support. 
 
    {storage_options} 
 
        .. versionadded:: 1.2.0 
 
    value_labels : dict of dicts 
        Dictionary containing columns as keys and dictionaries of column value 
        to labels as values. The combined length of all labels for a single 
        variable must be 32,000 characters or smaller. 
 
        .. versionadded:: 1.4.0 
 
    Returns 
    ------- 
    writer : StataWriter instance 
        The StataWriter instance has a write_file method, which will 
        write the file to the given `fname`. 
 
    Raises 
    ------ 
    NotImplementedError 
        * If datetimes contain timezone information 
    ValueError 
        * Columns listed in convert_dates are neither datetime64[ns] 
          or datetime.datetime 
        * Column dtype is not representable in Stata 
        * Column listed in convert_dates is not in DataFrame 
        * Categorical label contains more than 32,000 characters 
 
    Examples 
    -------- 
    &gt;&gt;&gt; data = pd.DataFrame([[1.0, 1]], columns=['a', 'b']) 
    &gt;&gt;&gt; writer = StataWriter('./data_file.dta', data) 
    &gt;&gt;&gt; writer.write_file() 
 
    Directly write a zip file 
    &gt;&gt;&gt; compression = {{&quot;method&quot;: &quot;zip&quot;, &quot;archive_name&quot;: &quot;data_file.dta&quot;}} 
    &gt;&gt;&gt; writer = StataWriter('./data_file.zip', data, compression=compression) 
    &gt;&gt;&gt; writer.write_file() 
 
    Save a DataFrame with dates 
    &gt;&gt;&gt; from datetime import datetime 
    &gt;&gt;&gt; data = pd.DataFrame([[datetime(2000,1,1)]], columns=['date']) 
    &gt;&gt;&gt; writer = StataWriter('./date_data_file.dta', data, {{'date' : 'tw'}}) 
    &gt;&gt;&gt; writer.write_file() 
    &quot;&quot;&quot;</span>

    <span class="s1">_max_string_length = </span><span class="s4">244</span>
    <span class="s1">_encoding = </span><span class="s3">&quot;latin-1&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fname: FilePath | WriteBuffer[bytes]</span><span class="s2">,</span>
        <span class="s1">data: DataFrame</span><span class="s2">,</span>
        <span class="s1">convert_dates: dict[Hashable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">write_index: bool = </span><span class="s2">True,</span>
        <span class="s1">byteorder: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">time_stamp: datetime.datetime | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">data_label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">variable_labels: dict[Hashable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">value_labels: dict[Hashable</span><span class="s2">, </span><span class="s1">dict[float | int</span><span class="s2">, </span><span class="s1">str]] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self._convert_dates = {} </span><span class="s2">if </span><span class="s1">convert_dates </span><span class="s2">is None else </span><span class="s1">convert_dates</span>
        <span class="s1">self._write_index = write_index</span>
        <span class="s1">self._time_stamp = time_stamp</span>
        <span class="s1">self._data_label = data_label</span>
        <span class="s1">self._variable_labels = variable_labels</span>
        <span class="s1">self._non_cat_value_labels = value_labels</span>
        <span class="s1">self._value_labels: list[StataValueLabel] = []</span>
        <span class="s1">self._has_value_labels = np.array([]</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">self._compression = compression</span>
        <span class="s1">self._output_file: IO[bytes] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
        <span class="s1">self._converted_names: dict[Hashable</span><span class="s2">, </span><span class="s1">str] = {}</span>
        <span class="s5"># attach nobs, nvars, data, varlist, typlist</span>
        <span class="s1">self._prepare_pandas(data)</span>
        <span class="s1">self.storage_options = storage_options</span>

        <span class="s2">if </span><span class="s1">byteorder </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">byteorder = sys.byteorder</span>
        <span class="s1">self._byteorder = _set_endianness(byteorder)</span>
        <span class="s1">self._fname = fname</span>
        <span class="s1">self.type_converters = {</span><span class="s4">253</span><span class="s1">: np.int32</span><span class="s2">, </span><span class="s4">252</span><span class="s1">: np.int16</span><span class="s2">, </span><span class="s4">251</span><span class="s1">: np.int8}</span>

    <span class="s2">def </span><span class="s1">_write(self</span><span class="s2">, </span><span class="s1">to_write: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper to call encode before writing to file for Python 3 compat. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.handles.handle.write(to_write.encode(self._encoding))</span>

    <span class="s2">def </span><span class="s1">_write_bytes(self</span><span class="s2">, </span><span class="s1">value: bytes) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper to assert file is open before writing. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.handles.handle.write(value)</span>

    <span class="s2">def </span><span class="s1">_prepare_non_cat_value_labels(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data: DataFrame</span>
    <span class="s1">) -&gt; list[StataNonCatValueLabel]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check for value labels provided for non-categorical columns. Value 
        labels 
        &quot;&quot;&quot;</span>
        <span class="s1">non_cat_value_labels: list[StataNonCatValueLabel] = []</span>
        <span class="s2">if </span><span class="s1">self._non_cat_value_labels </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">non_cat_value_labels</span>

        <span class="s2">for </span><span class="s1">labname</span><span class="s2">, </span><span class="s1">labels </span><span class="s2">in </span><span class="s1">self._non_cat_value_labels.items():</span>
            <span class="s2">if </span><span class="s1">labname </span><span class="s2">in </span><span class="s1">self._converted_names:</span>
                <span class="s1">colname = self._converted_names[labname]</span>
            <span class="s2">elif </span><span class="s1">labname </span><span class="s2">in </span><span class="s1">data.columns:</span>
                <span class="s1">colname = str(labname)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">KeyError(</span>
                    <span class="s3">f&quot;Can't create value labels for </span><span class="s2">{</span><span class="s1">labname</span><span class="s2">}</span><span class="s3">, it wasn't &quot;</span>
                    <span class="s3">&quot;found in the dataset.&quot;</span>
                <span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">is_numeric_dtype(data[colname].dtype):</span>
                <span class="s5"># Labels should not be passed explicitly for categorical</span>
                <span class="s5"># columns that will be converted to int</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;Can't create value labels for </span><span class="s2">{</span><span class="s1">labname</span><span class="s2">}</span><span class="s3">, value labels &quot;</span>
                    <span class="s3">&quot;can only be applied to numeric columns.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">svl = StataNonCatValueLabel(colname</span><span class="s2">, </span><span class="s1">labels)</span>
            <span class="s1">non_cat_value_labels.append(svl)</span>
        <span class="s2">return </span><span class="s1">non_cat_value_labels</span>

    <span class="s2">def </span><span class="s1">_prepare_categoricals(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check for categorical columns, retain categorical information for 
        Stata file and convert categorical data to int 
        &quot;&quot;&quot;</span>
        <span class="s1">is_cat = [is_categorical_dtype(data[col].dtype) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s2">if not </span><span class="s1">any(is_cat):</span>
            <span class="s2">return </span><span class="s1">data</span>

        <span class="s1">self._has_value_labels |= np.array(is_cat)</span>

        <span class="s1">get_base_missing_value = StataMissingValue.get_base_missing_value</span>
        <span class="s1">data_formatted = []</span>
        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">col_is_cat </span><span class="s2">in </span><span class="s1">zip(data</span><span class="s2">, </span><span class="s1">is_cat):</span>
            <span class="s2">if </span><span class="s1">col_is_cat:</span>
                <span class="s1">svl = StataValueLabel(data[col]</span><span class="s2">, </span><span class="s1">encoding=self._encoding)</span>
                <span class="s1">self._value_labels.append(svl)</span>
                <span class="s1">dtype = data[col].cat.codes.dtype</span>
                <span class="s2">if </span><span class="s1">dtype == np.int64:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;It is not possible to export &quot;</span>
                        <span class="s3">&quot;int64-based categorical data to Stata.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">values = data[col].cat.codes._values.copy()</span>

                <span class="s5"># Upcast if needed so that correct missing values can be set</span>
                <span class="s2">if </span><span class="s1">values.max() &gt;= get_base_missing_value(dtype):</span>
                    <span class="s2">if </span><span class="s1">dtype == np.int8:</span>
                        <span class="s1">dtype = np.dtype(np.int16)</span>
                    <span class="s2">elif </span><span class="s1">dtype == np.int16:</span>
                        <span class="s1">dtype = np.dtype(np.int32)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">dtype = np.dtype(np.float64)</span>
                    <span class="s1">values = np.array(values</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

                <span class="s5"># Replace missing values with Stata missing value for type</span>
                <span class="s1">values[values == -</span><span class="s4">1</span><span class="s1">] = get_base_missing_value(dtype)</span>
                <span class="s1">data_formatted.append((col</span><span class="s2">, </span><span class="s1">values))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">data_formatted.append((col</span><span class="s2">, </span><span class="s1">data[col]))</span>
        <span class="s2">return </span><span class="s1">DataFrame.from_dict(dict(data_formatted))</span>

    <span class="s2">def </span><span class="s1">_replace_nans(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; DataFrame:</span>
        <span class="s5"># return data</span>
        <span class="s0">&quot;&quot;&quot; 
        Checks floating point data columns for nans, and replaces these with 
        the generic Stata for missing value (.) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">data:</span>
            <span class="s1">dtype = data[c].dtype</span>
            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(np.float32</span><span class="s2">, </span><span class="s1">np.float64):</span>
                <span class="s2">if </span><span class="s1">dtype == np.float32:</span>
                    <span class="s1">replacement = self.MISSING_VALUES[</span><span class="s3">&quot;f&quot;</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">replacement = self.MISSING_VALUES[</span><span class="s3">&quot;d&quot;</span><span class="s1">]</span>
                <span class="s1">data[c] = data[c].fillna(replacement)</span>

        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_update_strl_names(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;No-op, forward compatibility&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_validate_variable_name(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate variable names for Stata export. 
 
        Parameters 
        ---------- 
        name : str 
            Variable name 
 
        Returns 
        ------- 
        str 
            The validated name with invalid characters replaced with 
            underscores. 
 
        Notes 
        ----- 
        Stata 114 and 117 support ascii characters in a-z, A-Z, 0-9 
        and _. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">name:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">(c &lt; </span><span class="s3">&quot;A&quot; </span><span class="s2">or </span><span class="s1">c &gt; </span><span class="s3">&quot;Z&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">(c &lt; </span><span class="s3">&quot;a&quot; </span><span class="s2">or </span><span class="s1">c &gt; </span><span class="s3">&quot;z&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">(c &lt; </span><span class="s3">&quot;0&quot; </span><span class="s2">or </span><span class="s1">c &gt; </span><span class="s3">&quot;9&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">c != </span><span class="s3">&quot;_&quot;</span>
            <span class="s1">):</span>
                <span class="s1">name = name.replace(c</span><span class="s2">, </span><span class="s3">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">_check_column_names(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot; 
        Checks column names to ensure that they are valid Stata column names. 
        This includes checks for: 
            * Non-string names 
            * Stata keywords 
            * Variables that start with numbers 
            * Variables with names that are too long 
 
        When an illegal variable name is detected, it is converted, and if 
        dates are exported, the variable name is propagated to the date 
        conversion dictionary 
        &quot;&quot;&quot;</span>
        <span class="s1">converted_names: dict[Hashable</span><span class="s2">, </span><span class="s1">str] = {}</span>
        <span class="s1">columns = list(data.columns)</span>
        <span class="s1">original_columns = columns[:]</span>

        <span class="s1">duplicate_var_id = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(columns):</span>
            <span class="s1">orig_name = name</span>
            <span class="s2">if not </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">name = str(name)</span>

            <span class="s1">name = self._validate_variable_name(name)</span>

            <span class="s5"># Variable name must not be a reserved word</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.RESERVED_WORDS:</span>
                <span class="s1">name = </span><span class="s3">&quot;_&quot; </span><span class="s1">+ name</span>

            <span class="s5"># Variable name may not start with a number</span>
            <span class="s2">if </span><span class="s3">&quot;0&quot; </span><span class="s1">&lt;= name[</span><span class="s4">0</span><span class="s1">] &lt;= </span><span class="s3">&quot;9&quot;</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s3">&quot;_&quot; </span><span class="s1">+ name</span>

            <span class="s1">name = name[: min(len(name)</span><span class="s2">, </span><span class="s4">32</span><span class="s1">)]</span>

            <span class="s2">if not </span><span class="s1">name == orig_name:</span>
                <span class="s5"># check for duplicates</span>
                <span class="s2">while </span><span class="s1">columns.count(name) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s5"># prepend ascending number to avoid duplicates</span>
                    <span class="s1">name = </span><span class="s3">&quot;_&quot; </span><span class="s1">+ str(duplicate_var_id) + name</span>
                    <span class="s1">name = name[: min(len(name)</span><span class="s2">, </span><span class="s4">32</span><span class="s1">)]</span>
                    <span class="s1">duplicate_var_id += </span><span class="s4">1</span>
                <span class="s1">converted_names[orig_name] = name</span>

            <span class="s1">columns[j] = name</span>

        <span class="s1">data.columns = Index(columns)</span>

        <span class="s5"># Check date conversion, and fix key if needed</span>
        <span class="s2">if </span><span class="s1">self._convert_dates:</span>
            <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">o </span><span class="s2">in </span><span class="s1">zip(columns</span><span class="s2">, </span><span class="s1">original_columns):</span>
                <span class="s2">if </span><span class="s1">c != o:</span>
                    <span class="s1">self._convert_dates[c] = self._convert_dates[o]</span>
                    <span class="s2">del </span><span class="s1">self._convert_dates[o]</span>

        <span class="s2">if </span><span class="s1">converted_names:</span>
            <span class="s1">conversion_warning = []</span>
            <span class="s2">for </span><span class="s1">orig_name</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">converted_names.items():</span>
                <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">orig_name</span><span class="s2">}   </span><span class="s3">-&gt;   </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">conversion_warning.append(msg)</span>

            <span class="s1">ws = invalid_name_doc.format(</span><span class="s3">&quot;</span><span class="s2">\n    </span><span class="s3">&quot;</span><span class="s1">.join(conversion_warning))</span>
            <span class="s1">warnings.warn(ws</span><span class="s2">, </span><span class="s1">InvalidColumnName)</span>

        <span class="s1">self._converted_names = converted_names</span>
        <span class="s1">self._update_strl_names()</span>

        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_set_formats_and_types(self</span><span class="s2">, </span><span class="s1">dtypes: Series) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.fmtlist: list[str] = []</span>
        <span class="s1">self.typlist: list[int] = []</span>
        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">dtypes.items():</span>
            <span class="s1">self.fmtlist.append(_dtype_to_default_stata_fmt(dtype</span><span class="s2">, </span><span class="s1">self.data[col]))</span>
            <span class="s1">self.typlist.append(_dtype_to_stata_type(dtype</span><span class="s2">, </span><span class="s1">self.data[col]))</span>

    <span class="s2">def </span><span class="s1">_prepare_pandas(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># NOTE: we might need a different API / class for pandas objects so</span>
        <span class="s5"># we can set different semantics - handle this with a PR to pandas.io</span>

        <span class="s1">data = data.copy()</span>

        <span class="s2">if </span><span class="s1">self._write_index:</span>
            <span class="s1">temp = data.reset_index()</span>
            <span class="s2">if </span><span class="s1">isinstance(temp</span><span class="s2">, </span><span class="s1">DataFrame):</span>
                <span class="s1">data = temp</span>

        <span class="s5"># Ensure column names are strings</span>
        <span class="s1">data = self._check_column_names(data)</span>

        <span class="s5"># Check columns for compatibility with stata, upcast if necessary</span>
        <span class="s5"># Raise if outside the supported range</span>
        <span class="s1">data = _cast_to_stata_types(data)</span>

        <span class="s5"># Replace NaNs with Stata missing values</span>
        <span class="s1">data = self._replace_nans(data)</span>

        <span class="s5"># Set all columns to initially unlabelled</span>
        <span class="s1">self._has_value_labels = np.repeat(</span><span class="s2">False, </span><span class="s1">data.shape[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s5"># Create value labels for non-categorical data</span>
        <span class="s1">non_cat_value_labels = self._prepare_non_cat_value_labels(data)</span>

        <span class="s1">non_cat_columns = [svl.labname </span><span class="s2">for </span><span class="s1">svl </span><span class="s2">in </span><span class="s1">non_cat_value_labels]</span>
        <span class="s1">has_non_cat_val_labels = data.columns.isin(non_cat_columns)</span>
        <span class="s1">self._has_value_labels |= has_non_cat_val_labels</span>
        <span class="s1">self._value_labels.extend(non_cat_value_labels)</span>

        <span class="s5"># Convert categoricals to int data, and strip labels</span>
        <span class="s1">data = self._prepare_categoricals(data)</span>

        <span class="s1">self.nobs</span><span class="s2">, </span><span class="s1">self.nvar = data.shape</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.varlist = data.columns.tolist()</span>

        <span class="s1">dtypes = data.dtypes</span>

        <span class="s5"># Ensure all date columns are converted</span>
        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">data:</span>
            <span class="s2">if </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._convert_dates:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">is_datetime64_dtype(data[col]):</span>
                <span class="s1">self._convert_dates[col] = </span><span class="s3">&quot;tc&quot;</span>

        <span class="s1">self._convert_dates = _maybe_convert_to_int_keys(</span>
            <span class="s1">self._convert_dates</span><span class="s2">, </span><span class="s1">self.varlist</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self._convert_dates:</span>
            <span class="s1">new_type = _convert_datetime_to_stata_type(self._convert_dates[key])</span>
            <span class="s1">dtypes[key] = np.dtype(new_type)</span>

        <span class="s5"># Verify object arrays are strings and encode to bytes</span>
        <span class="s1">self._encode_strings()</span>

        <span class="s1">self._set_formats_and_types(dtypes)</span>

        <span class="s5"># set the given format for the datetime cols</span>
        <span class="s2">if </span><span class="s1">self._convert_dates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self._convert_dates:</span>
                <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">int):</span>
                    <span class="s1">self.fmtlist[key] = self._convert_dates[key]</span>

    <span class="s2">def </span><span class="s1">_encode_strings(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Encode strings in dta-specific encoding 
 
        Do not encode columns marked for date conversion or for strL 
        conversion. The strL converter independently handles conversion and 
        also accepts empty string arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">convert_dates = self._convert_dates</span>
        <span class="s5"># _convert_strl is not available in dta 114</span>
        <span class="s1">convert_strl = getattr(self</span><span class="s2">, </span><span class="s3">&quot;_convert_strl&quot;</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(self.data):</span>
            <span class="s5"># Skip columns marked for date conversion or strl conversion</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">convert_dates </span><span class="s2">or </span><span class="s1">col </span><span class="s2">in </span><span class="s1">convert_strl:</span>
                <span class="s2">continue</span>
            <span class="s1">column = self.data[col]</span>
            <span class="s1">dtype = column.dtype</span>
            <span class="s2">if </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.object_:</span>
                <span class="s1">inferred_dtype = infer_dtype(column</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">((inferred_dtype == </span><span class="s3">&quot;string&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">len(column) == </span><span class="s4">0</span><span class="s1">):</span>
                    <span class="s1">col = column.name</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">f&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Column `</span><span class="s2">{</span><span class="s1">col</span><span class="s2">}</span><span class="s3">` cannot be exported.</span><span class="s2">\n\n</span><span class="s3">Only string-like object arrays</span>
<span class="s3">containing all strings or a mix of strings and None can be exported.</span>
<span class="s3">Object arrays containing only null values are prohibited. Other object</span>
<span class="s3">types cannot be exported and must first be converted to one of the</span>
<span class="s3">supported types.&quot;&quot;&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">encoded = self.data[col].str.encode(self._encoding)</span>
                <span class="s5"># If larger than _max_string_length do nothing</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">max_len_string_array(ensure_object(encoded._values))</span>
                    <span class="s1">&lt;= self._max_string_length</span>
                <span class="s1">):</span>
                    <span class="s1">self.data[col] = encoded</span>

    <span class="s2">def </span><span class="s1">write_file(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Export DataFrame object to Stata dta format. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">get_handle(</span>
            <span class="s1">self._fname</span><span class="s2">,</span>
            <span class="s3">&quot;wb&quot;</span><span class="s2">,</span>
            <span class="s1">compression=self._compression</span><span class="s2">,</span>
            <span class="s1">is_text=</span><span class="s2">False,</span>
            <span class="s1">storage_options=self.storage_options</span><span class="s2">,</span>
        <span class="s1">) </span><span class="s2">as </span><span class="s1">self.handles:</span>

            <span class="s2">if </span><span class="s1">self.handles.compression[</span><span class="s3">&quot;method&quot;</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s5"># ZipFile creates a file (with the same name) for each write call.</span>
                <span class="s5"># Write it first into a buffer and then write the buffer to the ZipFile.</span>
                <span class="s1">self._output_file</span><span class="s2">, </span><span class="s1">self.handles.handle = self.handles.handle</span><span class="s2">, </span><span class="s1">BytesIO()</span>
                <span class="s1">self.handles.created_handles.append(self.handles.handle)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._write_header(</span>
                    <span class="s1">data_label=self._data_label</span><span class="s2">, </span><span class="s1">time_stamp=self._time_stamp</span>
                <span class="s1">)</span>
                <span class="s1">self._write_map()</span>
                <span class="s1">self._write_variable_types()</span>
                <span class="s1">self._write_varnames()</span>
                <span class="s1">self._write_sortlist()</span>
                <span class="s1">self._write_formats()</span>
                <span class="s1">self._write_value_label_names()</span>
                <span class="s1">self._write_variable_labels()</span>
                <span class="s1">self._write_expansion_fields()</span>
                <span class="s1">self._write_characteristics()</span>
                <span class="s1">records = self._prepare_data()</span>
                <span class="s1">self._write_data(records)</span>
                <span class="s1">self._write_strls()</span>
                <span class="s1">self._write_value_labels()</span>
                <span class="s1">self._write_file_close_tag()</span>
                <span class="s1">self._write_map()</span>
                <span class="s1">self._close()</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">self.handles.close()</span>
                <span class="s2">if </span><span class="s1">isinstance(self._fname</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">os.PathLike)) </span><span class="s2">and </span><span class="s1">os.path.isfile(</span>
                    <span class="s1">self._fname</span>
                <span class="s1">):</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">os.unlink(self._fname)</span>
                    <span class="s2">except </span><span class="s1">OSError:</span>
                        <span class="s1">warnings.warn(</span>
                            <span class="s3">f&quot;This save was not successful but </span><span class="s2">{</span><span class="s1">self._fname</span><span class="s2">} </span><span class="s3">could not &quot;</span>
                            <span class="s3">&quot;be deleted. This file is not valid.&quot;</span><span class="s2">,</span>
                            <span class="s1">ResourceWarning</span><span class="s2">,</span>
                        <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">exc</span>

    <span class="s2">def </span><span class="s1">_close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Close the file if it was created by the writer. 
 
        If a buffer or file-like object was passed in, for example a GzipFile, 
        then leave this file open for the caller to close. 
        &quot;&quot;&quot;</span>
        <span class="s5"># write compression</span>
        <span class="s2">if </span><span class="s1">self._output_file </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(self.handles.handle</span><span class="s2">, </span><span class="s1">BytesIO)</span>
            <span class="s1">bio</span><span class="s2">, </span><span class="s1">self.handles.handle = self.handles.handle</span><span class="s2">, </span><span class="s1">self._output_file</span>
            <span class="s1">self.handles.handle.write(bio.getvalue())</span>

    <span class="s2">def </span><span class="s1">_write_map(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;No-op, future compatibility&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_write_file_close_tag(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;No-op, future compatibility&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_write_characteristics(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;No-op, future compatibility&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_write_strls(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;No-op, future compatibility&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_write_expansion_fields(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Write 5 zeros for expansion fields&quot;&quot;&quot;</span>
        <span class="s1">self._write(_pad_bytes(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_value_labels(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">vl </span><span class="s2">in </span><span class="s1">self._value_labels:</span>
            <span class="s1">self._write_bytes(vl.generate_value_label(self._byteorder))</span>

    <span class="s2">def </span><span class="s1">_write_header(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">data_label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">time_stamp: datetime.datetime | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">byteorder = self._byteorder</span>
        <span class="s5"># ds_format - just use 114</span>
        <span class="s1">self._write_bytes(struct.pack(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s4">114</span><span class="s1">))</span>
        <span class="s5"># byteorder</span>
        <span class="s1">self._write(byteorder == </span><span class="s3">&quot;&gt;&quot; </span><span class="s2">and </span><span class="s3">&quot;</span><span class="s2">\x01</span><span class="s3">&quot; </span><span class="s2">or </span><span class="s3">&quot;</span><span class="s2">\x02</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s5"># filetype</span>
        <span class="s1">self._write(</span><span class="s3">&quot;</span><span class="s2">\x01</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s5"># unused</span>
        <span class="s1">self._write(</span><span class="s3">&quot;</span><span class="s2">\x00</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s5"># number of vars, 2 bytes</span>
        <span class="s1">self._write_bytes(struct.pack(byteorder + </span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s1">self.nvar)[:</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s5"># number of obs, 4 bytes</span>
        <span class="s1">self._write_bytes(struct.pack(byteorder + </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">self.nobs)[:</span><span class="s4">4</span><span class="s1">])</span>
        <span class="s5"># data label 81 bytes, char, null terminated</span>
        <span class="s2">if </span><span class="s1">data_label </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._write_bytes(self._null_terminate_bytes(_pad_bytes(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._write_bytes(</span>
                <span class="s1">self._null_terminate_bytes(_pad_bytes(data_label[:</span><span class="s4">80</span><span class="s1">]</span><span class="s2">, </span><span class="s4">80</span><span class="s1">))</span>
            <span class="s1">)</span>
        <span class="s5"># time stamp, 18 bytes, char, null terminated</span>
        <span class="s5"># format dd Mon yyyy hh:mm</span>
        <span class="s2">if </span><span class="s1">time_stamp </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">time_stamp = datetime.datetime.now()</span>
        <span class="s2">elif not </span><span class="s1">isinstance(time_stamp</span><span class="s2">, </span><span class="s1">datetime.datetime):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;time_stamp should be datetime type&quot;</span><span class="s1">)</span>
        <span class="s5"># GH #13856</span>
        <span class="s5"># Avoid locale-specific month conversion</span>
        <span class="s1">months = [</span>
            <span class="s3">&quot;Jan&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Feb&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Mar&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Apr&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;May&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Jun&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Jul&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Aug&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Sep&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Oct&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Nov&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Dec&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">month_lookup = {i + </span><span class="s4">1</span><span class="s1">: month </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">month </span><span class="s2">in </span><span class="s1">enumerate(months)}</span>
        <span class="s1">ts = (</span>
            <span class="s1">time_stamp.strftime(</span><span class="s3">&quot;%d &quot;</span><span class="s1">)</span>
            <span class="s1">+ month_lookup[time_stamp.month]</span>
            <span class="s1">+ time_stamp.strftime(</span><span class="s3">&quot; %Y %H:%M&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self._write_bytes(self._null_terminate_bytes(ts))</span>

    <span class="s2">def </span><span class="s1">_write_variable_types(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">self.typlist:</span>
            <span class="s1">self._write_bytes(struct.pack(</span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s1">typ))</span>

    <span class="s2">def </span><span class="s1">_write_varnames(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># varlist names are checked by _check_column_names</span>
        <span class="s5"># varlist, requires null terminated</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.varlist:</span>
            <span class="s1">name = self._null_terminate_str(name)</span>
            <span class="s1">name = _pad_bytes(name[:</span><span class="s4">32</span><span class="s1">]</span><span class="s2">, </span><span class="s4">33</span><span class="s1">)</span>
            <span class="s1">self._write(name)</span>

    <span class="s2">def </span><span class="s1">_write_sortlist(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># srtlist, 2*(nvar+1), int array, encoded by byteorder</span>
        <span class="s1">srtlist = _pad_bytes(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* (self.nvar + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self._write(srtlist)</span>

    <span class="s2">def </span><span class="s1">_write_formats(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># fmtlist, 49*nvar, char array</span>
        <span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">self.fmtlist:</span>
            <span class="s1">self._write(_pad_bytes(fmt</span><span class="s2">, </span><span class="s4">49</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_value_label_names(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># lbllist, 33*nvar, char array</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.nvar):</span>
            <span class="s5"># Use variable name when categorical</span>
            <span class="s2">if </span><span class="s1">self._has_value_labels[i]:</span>
                <span class="s1">name = self.varlist[i]</span>
                <span class="s1">name = self._null_terminate_str(name)</span>
                <span class="s1">name = _pad_bytes(name[:</span><span class="s4">32</span><span class="s1">]</span><span class="s2">, </span><span class="s4">33</span><span class="s1">)</span>
                <span class="s1">self._write(name)</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s5"># Default is empty label</span>
                <span class="s1">self._write(_pad_bytes(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s4">33</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_variable_labels(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># Missing labels are 80 blank characters plus null termination</span>
        <span class="s1">blank = _pad_bytes(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s4">81</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._variable_labels </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.nvar):</span>
                <span class="s1">self._write(blank)</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.data:</span>
            <span class="s2">if </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._variable_labels:</span>
                <span class="s1">label = self._variable_labels[col]</span>
                <span class="s2">if </span><span class="s1">len(label) &gt; </span><span class="s4">80</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Variable labels must be 80 characters or fewer&quot;</span><span class="s1">)</span>
                <span class="s1">is_latin1 = all(ord(c) &lt; </span><span class="s4">256 </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">label)</span>
                <span class="s2">if not </span><span class="s1">is_latin1:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Variable labels must contain only characters that &quot;</span>
                        <span class="s3">&quot;can be encoded in Latin-1&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">self._write(_pad_bytes(label</span><span class="s2">, </span><span class="s4">81</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._write(blank)</span>

    <span class="s2">def </span><span class="s1">_convert_strls(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot;No-op, future compatibility&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_prepare_data(self) -&gt; np.recarray:</span>
        <span class="s1">data = self.data</span>
        <span class="s1">typlist = self.typlist</span>
        <span class="s1">convert_dates = self._convert_dates</span>
        <span class="s5"># 1. Convert dates</span>
        <span class="s2">if </span><span class="s1">self._convert_dates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(data):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">convert_dates:</span>
                    <span class="s1">data[col] = _datetime_to_stata_elapsed_vec(</span>
                        <span class="s1">data[col]</span><span class="s2">, </span><span class="s1">self.fmtlist[i]</span>
                    <span class="s1">)</span>
        <span class="s5"># 2. Convert strls</span>
        <span class="s1">data = self._convert_strls(data)</span>

        <span class="s5"># 3. Convert bad string data to '' and pad to correct length</span>
        <span class="s1">dtypes = {}</span>
        <span class="s1">native_byteorder = self._byteorder == _set_endianness(sys.byteorder)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(data):</span>
            <span class="s1">typ = typlist[i]</span>
            <span class="s2">if </span><span class="s1">typ &lt;= self._max_string_length:</span>
                <span class="s1">data[col] = data[col].fillna(</span><span class="s3">&quot;&quot;</span><span class="s1">).apply(_pad_bytes</span><span class="s2">, </span><span class="s1">args=(typ</span><span class="s2">,</span><span class="s1">))</span>
                <span class="s1">stype = </span><span class="s3">f&quot;S</span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">dtypes[col] = stype</span>
                <span class="s1">data[col] = data[col].astype(stype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dtype = data[col].dtype</span>
                <span class="s2">if not </span><span class="s1">native_byteorder:</span>
                    <span class="s1">dtype = dtype.newbyteorder(self._byteorder)</span>
                <span class="s1">dtypes[col] = dtype</span>

        <span class="s2">return </span><span class="s1">data.to_records(index=</span><span class="s2">False, </span><span class="s1">column_dtypes=dtypes)</span>

    <span class="s2">def </span><span class="s1">_write_data(self</span><span class="s2">, </span><span class="s1">records: np.recarray) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._write_bytes(records.tobytes())</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_null_terminate_str(s: str) -&gt; str:</span>
        <span class="s1">s += </span><span class="s3">&quot;</span><span class="s2">\x00</span><span class="s3">&quot;</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">_null_terminate_bytes(self</span><span class="s2">, </span><span class="s1">s: str) -&gt; bytes:</span>
        <span class="s2">return </span><span class="s1">self._null_terminate_str(s).encode(self._encoding)</span>


<span class="s2">def </span><span class="s1">_dtype_to_stata_type_117(dtype: np.dtype</span><span class="s2">, </span><span class="s1">column: Series</span><span class="s2">, </span><span class="s1">force_strl: bool) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot; 
    Converts dtype types to stata types. Returns the byte of the given ordinal. 
    See TYPE_MAP and comments for an explanation. This is also explained in 
    the dta spec. 
    1 - 2045 are strings of this length 
                Pandas    Stata 
    32768 - for object    strL 
    65526 - for int8      byte 
    65527 - for int16     int 
    65528 - for int32     long 
    65529 - for float32   float 
    65530 - for double    double 
 
    If there are dates to convert, then dtype will already have the correct 
    type inserted. 
    &quot;&quot;&quot;</span>
    <span class="s5"># TODO: expand to handle datetime to integer conversion</span>
    <span class="s2">if </span><span class="s1">force_strl:</span>
        <span class="s2">return </span><span class="s4">32768</span>
    <span class="s2">if </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.object_:  </span><span class="s5"># try to coerce it to the biggest string</span>
        <span class="s5"># not memory efficient, what else could we</span>
        <span class="s5"># do?</span>
        <span class="s1">itemsize = max_len_string_array(ensure_object(column._values))</span>
        <span class="s1">itemsize = max(itemsize</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">itemsize &lt;= </span><span class="s4">2045</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">itemsize</span>
        <span class="s2">return </span><span class="s4">32768</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.float64:</span>
        <span class="s2">return </span><span class="s4">65526</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.float32:</span>
        <span class="s2">return </span><span class="s4">65527</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int32:</span>
        <span class="s2">return </span><span class="s4">65528</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int16:</span>
        <span class="s2">return </span><span class="s4">65529</span>
    <span class="s2">elif </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.int8:</span>
        <span class="s2">return </span><span class="s4">65530</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s5"># pragma : no cover</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;Data type </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">not supported.&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_pad_bytes_new(name: str | bytes</span><span class="s2">, </span><span class="s1">length: int) -&gt; bytes:</span>
    <span class="s0">&quot;&quot;&quot; 
    Takes a bytes instance and pads it with null bytes until it's length chars. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">name = bytes(name</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">name + </span><span class="s6">b&quot;</span><span class="s2">\x00</span><span class="s6">&quot; </span><span class="s1">* (length - len(name))</span>


<span class="s2">class </span><span class="s1">StataStrLWriter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Converter for Stata StrLs 
 
    Stata StrLs map 8 byte values to strings which are stored using a 
    dictionary-like format where strings are keyed to two values. 
 
    Parameters 
    ---------- 
    df : DataFrame 
        DataFrame to convert 
    columns : Sequence[str] 
        List of columns names to convert to StrL 
    version : int, optional 
        dta version.  Currently supports 117, 118 and 119 
    byteorder : str, optional 
        Can be &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;little&quot;, or &quot;big&quot;. default is `sys.byteorder` 
 
    Notes 
    ----- 
    Supports creation of the StrL block of a dta file for dta versions 
    117, 118 and 119.  These differ in how the GSO is stored.  118 and 
    119 store the GSO lookup value as a uint32 and a uint64, while 117 
    uses two uint32s. 118 and 119 also encode all strings as unicode 
    which is required by the format.  117 uses 'latin-1' a fixed width 
    encoding that extends the 7-bit ascii table with an additional 128 
    characters. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">df: DataFrame</span><span class="s2">,</span>
        <span class="s1">columns: Sequence[str]</span><span class="s2">,</span>
        <span class="s1">version: int = </span><span class="s4">117</span><span class="s2">,</span>
        <span class="s1">byteorder: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">version </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">117</span><span class="s2">, </span><span class="s4">118</span><span class="s2">, </span><span class="s4">119</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Only dta versions 117, 118 and 119 supported&quot;</span><span class="s1">)</span>
        <span class="s1">self._dta_ver = version</span>

        <span class="s1">self.df = df</span>
        <span class="s1">self.columns = columns</span>
        <span class="s1">self._gso_table = {</span><span class="s3">&quot;&quot;</span><span class="s1">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)}</span>
        <span class="s2">if </span><span class="s1">byteorder </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">byteorder = sys.byteorder</span>
        <span class="s1">self._byteorder = _set_endianness(byteorder)</span>

        <span class="s1">gso_v_type = </span><span class="s3">&quot;I&quot;  </span><span class="s5"># uint32</span>
        <span class="s1">gso_o_type = </span><span class="s3">&quot;Q&quot;  </span><span class="s5"># uint64</span>
        <span class="s1">self._encoding = </span><span class="s3">&quot;utf-8&quot;</span>
        <span class="s2">if </span><span class="s1">version == </span><span class="s4">117</span><span class="s1">:</span>
            <span class="s1">o_size = </span><span class="s4">4</span>
            <span class="s1">gso_o_type = </span><span class="s3">&quot;I&quot;  </span><span class="s5"># 117 used uint32</span>
            <span class="s1">self._encoding = </span><span class="s3">&quot;latin-1&quot;</span>
        <span class="s2">elif </span><span class="s1">version == </span><span class="s4">118</span><span class="s1">:</span>
            <span class="s1">o_size = </span><span class="s4">6</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># version == 119</span>
            <span class="s1">o_size = </span><span class="s4">5</span>
        <span class="s1">self._o_offet = </span><span class="s4">2 </span><span class="s1">** (</span><span class="s4">8 </span><span class="s1">* (</span><span class="s4">8 </span><span class="s1">- o_size))</span>
        <span class="s1">self._gso_o_type = gso_o_type</span>
        <span class="s1">self._gso_v_type = gso_v_type</span>

    <span class="s2">def </span><span class="s1">_convert_key(self</span><span class="s2">, </span><span class="s1">key: tuple[int</span><span class="s2">, </span><span class="s1">int]) -&gt; int:</span>
        <span class="s1">v</span><span class="s2">, </span><span class="s1">o = key</span>
        <span class="s2">return </span><span class="s1">v + self._o_offet * o</span>

    <span class="s2">def </span><span class="s1">generate_table(self) -&gt; tuple[dict[str</span><span class="s2">, </span><span class="s1">tuple[int</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">, </span><span class="s1">DataFrame]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Generates the GSO lookup table for the DataFrame 
 
        Returns 
        ------- 
        gso_table : dict 
            Ordered dictionary using the string found as keys 
            and their lookup position (v,o) as values 
        gso_df : DataFrame 
            DataFrame where strl columns have been converted to 
            (v,o) values 
 
        Notes 
        ----- 
        Modifies the DataFrame in-place. 
 
        The DataFrame returned encodes the (v,o) values as uint64s. The 
        encoding depends on the dta version, and can be expressed as 
 
        enc = v + o * 2 ** (o_size * 8) 
 
        so that v is stored in the lower bits and o is in the upper 
        bits. o_size is 
 
          * 117: 4 
          * 118: 6 
          * 119: 5 
        &quot;&quot;&quot;</span>
        <span class="s1">gso_table = self._gso_table</span>
        <span class="s1">gso_df = self.df</span>
        <span class="s1">columns = list(gso_df.columns)</span>
        <span class="s1">selected = gso_df[self.columns]</span>
        <span class="s1">col_index = [(col</span><span class="s2">, </span><span class="s1">columns.index(col)) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.columns]</span>
        <span class="s1">keys = np.empty(selected.shape</span><span class="s2">, </span><span class="s1">dtype=np.uint64)</span>
        <span class="s2">for </span><span class="s1">o</span><span class="s2">, </span><span class="s1">(idx</span><span class="s2">, </span><span class="s1">row) </span><span class="s2">in </span><span class="s1">enumerate(selected.iterrows()):</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">(col</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">enumerate(col_index):</span>
                <span class="s1">val = row[col]</span>
                <span class="s5"># Allow columns with mixed str and None (GH 23633)</span>
                <span class="s1">val = </span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is None else </span><span class="s1">val</span>
                <span class="s1">key = gso_table.get(val</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s5"># Stata prefers human numbers</span>
                    <span class="s1">key = (v + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">o + </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">gso_table[val] = key</span>
                <span class="s1">keys[o</span><span class="s2">, </span><span class="s1">j] = self._convert_key(key)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(self.columns):</span>
            <span class="s1">gso_df[col] = keys[:</span><span class="s2">, </span><span class="s1">i]</span>

        <span class="s2">return </span><span class="s1">gso_table</span><span class="s2">, </span><span class="s1">gso_df</span>

    <span class="s2">def </span><span class="s1">generate_blob(self</span><span class="s2">, </span><span class="s1">gso_table: dict[str</span><span class="s2">, </span><span class="s1">tuple[int</span><span class="s2">, </span><span class="s1">int]]) -&gt; bytes:</span>
        <span class="s0">&quot;&quot;&quot; 
        Generates the binary blob of GSOs that is written to the dta file. 
 
        Parameters 
        ---------- 
        gso_table : dict 
            Ordered dictionary (str, vo) 
 
        Returns 
        ------- 
        gso : bytes 
            Binary content of dta file to be placed between strl tags 
 
        Notes 
        ----- 
        Output format depends on dta version.  117 uses two uint32s to 
        express v and o while 118+ uses a uint32 for v and a uint64 for o. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Format information</span>
        <span class="s5"># Length includes null term</span>
        <span class="s5"># 117</span>
        <span class="s5"># GSOvvvvooootllllxxxxxxxxxxxxxxx...x</span>
        <span class="s5">#  3  u4  u4 u1 u4  string + null term</span>
        <span class="s5">#</span>
        <span class="s5"># 118, 119</span>
        <span class="s5"># GSOvvvvooooooootllllxxxxxxxxxxxxxxx...x</span>
        <span class="s5">#  3  u4   u8   u1 u4    string + null term</span>

        <span class="s1">bio = BytesIO()</span>
        <span class="s1">gso = bytes(</span><span class="s3">&quot;GSO&quot;</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s1">gso_type = struct.pack(self._byteorder + </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s4">130</span><span class="s1">)</span>
        <span class="s1">null = struct.pack(self._byteorder + </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">v_type = self._byteorder + self._gso_v_type</span>
        <span class="s1">o_type = self._byteorder + self._gso_o_type</span>
        <span class="s1">len_type = self._byteorder + </span><span class="s3">&quot;I&quot;</span>
        <span class="s2">for </span><span class="s1">strl</span><span class="s2">, </span><span class="s1">vo </span><span class="s2">in </span><span class="s1">gso_table.items():</span>
            <span class="s2">if </span><span class="s1">vo == (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">o = vo</span>

            <span class="s5"># GSO</span>
            <span class="s1">bio.write(gso)</span>

            <span class="s5"># vvvv</span>
            <span class="s1">bio.write(struct.pack(v_type</span><span class="s2">, </span><span class="s1">v))</span>

            <span class="s5"># oooo / oooooooo</span>
            <span class="s1">bio.write(struct.pack(o_type</span><span class="s2">, </span><span class="s1">o))</span>

            <span class="s5"># t</span>
            <span class="s1">bio.write(gso_type)</span>

            <span class="s5"># llll</span>
            <span class="s1">utf8_string = bytes(strl</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
            <span class="s1">bio.write(struct.pack(len_type</span><span class="s2">, </span><span class="s1">len(utf8_string) + </span><span class="s4">1</span><span class="s1">))</span>

            <span class="s5"># xxx...xxx</span>
            <span class="s1">bio.write(utf8_string)</span>
            <span class="s1">bio.write(null)</span>

        <span class="s2">return </span><span class="s1">bio.getvalue()</span>


<span class="s2">class </span><span class="s1">StataWriter117(StataWriter):</span>
    <span class="s0">&quot;&quot;&quot; 
    A class for writing Stata binary dta files in Stata 13 format (117) 
 
    Parameters 
    ---------- 
    fname : path (string), buffer or path object 
        string, path object (pathlib.Path or py._path.local.LocalPath) or 
        object implementing a binary write() functions. If using a buffer 
        then the buffer will not be automatically closed after the file 
        is written. 
    data : DataFrame 
        Input to save 
    convert_dates : dict 
        Dictionary mapping columns containing datetime types to stata internal 
        format to use when writing the dates. Options are 'tc', 'td', 'tm', 
        'tw', 'th', 'tq', 'ty'. Column can be either an integer or a name. 
        Datetime columns that do not have a conversion type specified will be 
        converted to 'tc'. Raises NotImplementedError if a datetime column has 
        timezone information 
    write_index : bool 
        Write the index to Stata dataset. 
    byteorder : str 
        Can be &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;little&quot;, or &quot;big&quot;. default is `sys.byteorder` 
    time_stamp : datetime 
        A datetime to use as file creation date.  Default is the current time 
    data_label : str 
        A label for the data set.  Must be 80 characters or smaller. 
    variable_labels : dict 
        Dictionary containing columns as keys and variable labels as values. 
        Each label must be 80 characters or smaller. 
    convert_strl : list 
        List of columns names to convert to Stata StrL format.  Columns with 
        more than 2045 characters are automatically written as StrL. 
        Smaller columns can be converted by including the column name.  Using 
        StrLs can reduce output file size when strings are longer than 8 
        characters, and either frequently repeated or sparse. 
    {compression_options} 
 
        .. versionadded:: 1.1.0 
 
        .. versionchanged:: 1.4.0 Zstandard support. 
 
    value_labels : dict of dicts 
        Dictionary containing columns as keys and dictionaries of column value 
        to labels as values. The combined length of all labels for a single 
        variable must be 32,000 characters or smaller. 
 
        .. versionadded:: 1.4.0 
 
    Returns 
    ------- 
    writer : StataWriter117 instance 
        The StataWriter117 instance has a write_file method, which will 
        write the file to the given `fname`. 
 
    Raises 
    ------ 
    NotImplementedError 
        * If datetimes contain timezone information 
    ValueError 
        * Columns listed in convert_dates are neither datetime64[ns] 
          or datetime.datetime 
        * Column dtype is not representable in Stata 
        * Column listed in convert_dates is not in DataFrame 
        * Categorical label contains more than 32,000 characters 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas.io.stata import StataWriter117 
    &gt;&gt;&gt; data = pd.DataFrame([[1.0, 1, 'a']], columns=['a', 'b', 'c']) 
    &gt;&gt;&gt; writer = StataWriter117('./data_file.dta', data) 
    &gt;&gt;&gt; writer.write_file() 
 
    Directly write a zip file 
    &gt;&gt;&gt; compression = {&quot;method&quot;: &quot;zip&quot;, &quot;archive_name&quot;: &quot;data_file.dta&quot;} 
    &gt;&gt;&gt; writer = StataWriter117('./data_file.zip', data, compression=compression) 
    &gt;&gt;&gt; writer.write_file() 
 
    Or with long strings stored in strl format 
    &gt;&gt;&gt; data = pd.DataFrame([['A relatively long string'], [''], ['']], 
    ...                     columns=['strls']) 
    &gt;&gt;&gt; writer = StataWriter117('./data_file_with_long_strings.dta', data, 
    ...                         convert_strl=['strls']) 
    &gt;&gt;&gt; writer.write_file() 
    &quot;&quot;&quot;</span>

    <span class="s1">_max_string_length = </span><span class="s4">2045</span>
    <span class="s1">_dta_version = </span><span class="s4">117</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fname: FilePath | WriteBuffer[bytes]</span><span class="s2">,</span>
        <span class="s1">data: DataFrame</span><span class="s2">,</span>
        <span class="s1">convert_dates: dict[Hashable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">write_index: bool = </span><span class="s2">True,</span>
        <span class="s1">byteorder: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">time_stamp: datetime.datetime | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">data_label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">variable_labels: dict[Hashable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">convert_strl: Sequence[Hashable] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">value_labels: dict[Hashable</span><span class="s2">, </span><span class="s1">dict[float | int</span><span class="s2">, </span><span class="s1">str]] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s5"># Copy to new list since convert_strl might be modified later</span>
        <span class="s1">self._convert_strl: list[Hashable] = []</span>
        <span class="s2">if </span><span class="s1">convert_strl </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._convert_strl.extend(convert_strl)</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">fname</span><span class="s2">,</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">convert_dates</span><span class="s2">,</span>
            <span class="s1">write_index</span><span class="s2">,</span>
            <span class="s1">byteorder=byteorder</span><span class="s2">,</span>
            <span class="s1">time_stamp=time_stamp</span><span class="s2">,</span>
            <span class="s1">data_label=data_label</span><span class="s2">,</span>
            <span class="s1">variable_labels=variable_labels</span><span class="s2">,</span>
            <span class="s1">value_labels=value_labels</span><span class="s2">,</span>
            <span class="s1">compression=compression</span><span class="s2">,</span>
            <span class="s1">storage_options=storage_options</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._map: dict[str</span><span class="s2">, </span><span class="s1">int] = {}</span>
        <span class="s1">self._strl_blob = </span><span class="s6">b&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_tag(val: str | bytes</span><span class="s2">, </span><span class="s1">tag: str) -&gt; bytes:</span>
        <span class="s0">&quot;&quot;&quot;Surround val with &lt;tag&gt;&lt;/tag&gt;&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">val = bytes(val</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">bytes(</span><span class="s3">&quot;&lt;&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">) + val + bytes(</span><span class="s3">&quot;&lt;/&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_update_map(self</span><span class="s2">, </span><span class="s1">tag: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Update map location for tag with file position&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.handles.handle </span><span class="s2">is not None</span>
        <span class="s1">self._map[tag] = self.handles.handle.tell()</span>

    <span class="s2">def </span><span class="s1">_write_header(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">data_label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">time_stamp: datetime.datetime | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Write the file header&quot;&quot;&quot;</span>
        <span class="s1">byteorder = self._byteorder</span>
        <span class="s1">self._write_bytes(bytes(</span><span class="s3">&quot;&lt;stata_dta&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">))</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s5"># ds_format - 117</span>
        <span class="s1">bio.write(self._tag(bytes(str(self._dta_version)</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;release&quot;</span><span class="s1">))</span>
        <span class="s5"># byteorder</span>
        <span class="s1">bio.write(self._tag(byteorder == </span><span class="s3">&quot;&gt;&quot; </span><span class="s2">and </span><span class="s3">&quot;MSF&quot; </span><span class="s2">or </span><span class="s3">&quot;LSF&quot;</span><span class="s2">, </span><span class="s3">&quot;byteorder&quot;</span><span class="s1">))</span>
        <span class="s5"># number of vars, 2 bytes in 117 and 118, 4 byte in 119</span>
        <span class="s1">nvar_type = </span><span class="s3">&quot;H&quot; </span><span class="s2">if </span><span class="s1">self._dta_version &lt;= </span><span class="s4">118 </span><span class="s2">else </span><span class="s3">&quot;I&quot;</span>
        <span class="s1">bio.write(self._tag(struct.pack(byteorder + nvar_type</span><span class="s2">, </span><span class="s1">self.nvar)</span><span class="s2">, </span><span class="s3">&quot;K&quot;</span><span class="s1">))</span>
        <span class="s5"># 117 uses 4 bytes, 118 uses 8</span>
        <span class="s1">nobs_size = </span><span class="s3">&quot;I&quot; </span><span class="s2">if </span><span class="s1">self._dta_version == </span><span class="s4">117 </span><span class="s2">else </span><span class="s3">&quot;Q&quot;</span>
        <span class="s1">bio.write(self._tag(struct.pack(byteorder + nobs_size</span><span class="s2">, </span><span class="s1">self.nobs)</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s1">))</span>
        <span class="s5"># data label 81 bytes, char, null terminated</span>
        <span class="s1">label = data_label[:</span><span class="s4">80</span><span class="s1">] </span><span class="s2">if </span><span class="s1">data_label </span><span class="s2">is not None else </span><span class="s3">&quot;&quot;</span>
        <span class="s1">encoded_label = label.encode(self._encoding)</span>
        <span class="s1">label_size = </span><span class="s3">&quot;B&quot; </span><span class="s2">if </span><span class="s1">self._dta_version == </span><span class="s4">117 </span><span class="s2">else </span><span class="s3">&quot;H&quot;</span>
        <span class="s1">label_len = struct.pack(byteorder + label_size</span><span class="s2">, </span><span class="s1">len(encoded_label))</span>
        <span class="s1">encoded_label = label_len + encoded_label</span>
        <span class="s1">bio.write(self._tag(encoded_label</span><span class="s2">, </span><span class="s3">&quot;label&quot;</span><span class="s1">))</span>
        <span class="s5"># time stamp, 18 bytes, char, null terminated</span>
        <span class="s5"># format dd Mon yyyy hh:mm</span>
        <span class="s2">if </span><span class="s1">time_stamp </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">time_stamp = datetime.datetime.now()</span>
        <span class="s2">elif not </span><span class="s1">isinstance(time_stamp</span><span class="s2">, </span><span class="s1">datetime.datetime):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;time_stamp should be datetime type&quot;</span><span class="s1">)</span>
        <span class="s5"># Avoid locale-specific month conversion</span>
        <span class="s1">months = [</span>
            <span class="s3">&quot;Jan&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Feb&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Mar&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Apr&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;May&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Jun&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Jul&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Aug&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Sep&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Oct&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Nov&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Dec&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">month_lookup = {i + </span><span class="s4">1</span><span class="s1">: month </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">month </span><span class="s2">in </span><span class="s1">enumerate(months)}</span>
        <span class="s1">ts = (</span>
            <span class="s1">time_stamp.strftime(</span><span class="s3">&quot;%d &quot;</span><span class="s1">)</span>
            <span class="s1">+ month_lookup[time_stamp.month]</span>
            <span class="s1">+ time_stamp.strftime(</span><span class="s3">&quot; %Y %H:%M&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s5"># '\x11' added due to inspection of Stata file</span>
        <span class="s1">stata_ts = </span><span class="s6">b&quot;</span><span class="s2">\x11</span><span class="s6">&quot; </span><span class="s1">+ bytes(ts</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">bio.write(self._tag(stata_ts</span><span class="s2">, </span><span class="s3">&quot;timestamp&quot;</span><span class="s1">))</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;header&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_map(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Called twice during file write. The first populates the values in 
        the map with 0s.  The second call writes the final map locations when 
        all blocks have been written. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._map:</span>
            <span class="s1">self._map = {</span>
                <span class="s3">&quot;stata_data&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;map&quot;</span><span class="s1">: self.handles.handle.tell()</span><span class="s2">,</span>
                <span class="s3">&quot;variable_types&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;varnames&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;sortlist&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;formats&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;value_label_names&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;variable_labels&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;characteristics&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;data&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;strls&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;value_labels&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;stata_data_close&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s3">&quot;end-of-file&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s5"># Move to start of map</span>
        <span class="s1">self.handles.handle.seek(self._map[</span><span class="s3">&quot;map&quot;</span><span class="s1">])</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self._map.values():</span>
            <span class="s1">bio.write(struct.pack(self._byteorder + </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s1">val))</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;map&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_variable_types(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;variable_types&quot;</span><span class="s1">)</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">self.typlist:</span>
            <span class="s1">bio.write(struct.pack(self._byteorder + </span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s1">typ))</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;variable_types&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_varnames(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;varnames&quot;</span><span class="s1">)</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s5"># 118 scales by 4 to accommodate utf-8 data worst case encoding</span>
        <span class="s1">vn_len = </span><span class="s4">32 </span><span class="s2">if </span><span class="s1">self._dta_version == </span><span class="s4">117 </span><span class="s2">else </span><span class="s4">128</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.varlist:</span>
            <span class="s1">name = self._null_terminate_str(name)</span>
            <span class="s1">name = _pad_bytes_new(name[:</span><span class="s4">32</span><span class="s1">].encode(self._encoding)</span><span class="s2">, </span><span class="s1">vn_len + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">bio.write(name)</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;varnames&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_sortlist(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;sortlist&quot;</span><span class="s1">)</span>
        <span class="s1">sort_size = </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">self._dta_version &lt; </span><span class="s4">119 </span><span class="s2">else </span><span class="s4">4</span>
        <span class="s1">self._write_bytes(self._tag(</span><span class="s6">b&quot;</span><span class="s2">\x00</span><span class="s6">&quot; </span><span class="s1">* sort_size * (self.nvar + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;sortlist&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_formats(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;formats&quot;</span><span class="s1">)</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s1">fmt_len = </span><span class="s4">49 </span><span class="s2">if </span><span class="s1">self._dta_version == </span><span class="s4">117 </span><span class="s2">else </span><span class="s4">57</span>
        <span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">self.fmtlist:</span>
            <span class="s1">bio.write(_pad_bytes_new(fmt.encode(self._encoding)</span><span class="s2">, </span><span class="s1">fmt_len))</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;formats&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_value_label_names(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;value_label_names&quot;</span><span class="s1">)</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s5"># 118 scales by 4 to accommodate utf-8 data worst case encoding</span>
        <span class="s1">vl_len = </span><span class="s4">32 </span><span class="s2">if </span><span class="s1">self._dta_version == </span><span class="s4">117 </span><span class="s2">else </span><span class="s4">128</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.nvar):</span>
            <span class="s5"># Use variable name when categorical</span>
            <span class="s1">name = </span><span class="s3">&quot;&quot;  </span><span class="s5"># default name</span>
            <span class="s2">if </span><span class="s1">self._has_value_labels[i]:</span>
                <span class="s1">name = self.varlist[i]</span>
            <span class="s1">name = self._null_terminate_str(name)</span>
            <span class="s1">encoded_name = _pad_bytes_new(name[:</span><span class="s4">32</span><span class="s1">].encode(self._encoding)</span><span class="s2">, </span><span class="s1">vl_len + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">bio.write(encoded_name)</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;value_label_names&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_variable_labels(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5"># Missing labels are 80 blank characters plus null termination</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;variable_labels&quot;</span><span class="s1">)</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s5"># 118 scales by 4 to accommodate utf-8 data worst case encoding</span>
        <span class="s1">vl_len = </span><span class="s4">80 </span><span class="s2">if </span><span class="s1">self._dta_version == </span><span class="s4">117 </span><span class="s2">else </span><span class="s4">320</span>
        <span class="s1">blank = _pad_bytes_new(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">vl_len + </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._variable_labels </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.nvar):</span>
                <span class="s1">bio.write(blank)</span>
            <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;variable_labels&quot;</span><span class="s1">))</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.data:</span>
            <span class="s2">if </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._variable_labels:</span>
                <span class="s1">label = self._variable_labels[col]</span>
                <span class="s2">if </span><span class="s1">len(label) &gt; </span><span class="s4">80</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Variable labels must be 80 characters or fewer&quot;</span><span class="s1">)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">encoded = label.encode(self._encoding)</span>
                <span class="s2">except </span><span class="s1">UnicodeEncodeError </span><span class="s2">as </span><span class="s1">err:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Variable labels must contain only characters that &quot;</span>
                        <span class="s3">f&quot;can be encoded in </span><span class="s2">{</span><span class="s1">self._encoding</span><span class="s2">}</span><span class="s3">&quot;</span>
                    <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

                <span class="s1">bio.write(_pad_bytes_new(encoded</span><span class="s2">, </span><span class="s1">vl_len + </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bio.write(blank)</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;variable_labels&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_characteristics(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;characteristics&quot;</span><span class="s1">)</span>
        <span class="s1">self._write_bytes(self._tag(</span><span class="s6">b&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;characteristics&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_data(self</span><span class="s2">, </span><span class="s1">records) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s1">self._write_bytes(</span><span class="s6">b&quot;&lt;data&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self._write_bytes(records.tobytes())</span>
        <span class="s1">self._write_bytes(</span><span class="s6">b&quot;&lt;/data&gt;&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_write_strls(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;strls&quot;</span><span class="s1">)</span>
        <span class="s1">self._write_bytes(self._tag(self._strl_blob</span><span class="s2">, </span><span class="s3">&quot;strls&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_expansion_fields(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;No-op in dta 117+&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_write_value_labels(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;value_labels&quot;</span><span class="s1">)</span>
        <span class="s1">bio = BytesIO()</span>
        <span class="s2">for </span><span class="s1">vl </span><span class="s2">in </span><span class="s1">self._value_labels:</span>
            <span class="s1">lab = vl.generate_value_label(self._byteorder)</span>
            <span class="s1">lab = self._tag(lab</span><span class="s2">, </span><span class="s3">&quot;lbl&quot;</span><span class="s1">)</span>
            <span class="s1">bio.write(lab)</span>
        <span class="s1">self._write_bytes(self._tag(bio.getvalue()</span><span class="s2">, </span><span class="s3">&quot;value_labels&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_write_file_close_tag(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;stata_data_close&quot;</span><span class="s1">)</span>
        <span class="s1">self._write_bytes(bytes(</span><span class="s3">&quot;&lt;/stata_dta&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">))</span>
        <span class="s1">self._update_map(</span><span class="s3">&quot;end-of-file&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_update_strl_names(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Update column names for conversion to strl if they might have been 
        changed to comply with Stata naming rules 
        &quot;&quot;&quot;</span>
        <span class="s5"># Update convert_strl if names changed</span>
        <span class="s2">for </span><span class="s1">orig</span><span class="s2">, </span><span class="s1">new </span><span class="s2">in </span><span class="s1">self._converted_names.items():</span>
            <span class="s2">if </span><span class="s1">orig </span><span class="s2">in </span><span class="s1">self._convert_strl:</span>
                <span class="s1">idx = self._convert_strl.index(orig)</span>
                <span class="s1">self._convert_strl[idx] = new</span>

    <span class="s2">def </span><span class="s1">_convert_strls(self</span><span class="s2">, </span><span class="s1">data: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert columns to StrLs if either very large or in the 
        convert_strl variable 
        &quot;&quot;&quot;</span>
        <span class="s1">convert_cols = [</span>
            <span class="s1">col</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(data)</span>
            <span class="s2">if </span><span class="s1">self.typlist[i] == </span><span class="s4">32768 </span><span class="s2">or </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._convert_strl</span>
        <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">convert_cols:</span>
            <span class="s1">ssw = StataStrLWriter(data</span><span class="s2">, </span><span class="s1">convert_cols</span><span class="s2">, </span><span class="s1">version=self._dta_version)</span>
            <span class="s1">tab</span><span class="s2">, </span><span class="s1">new_data = ssw.generate_table()</span>
            <span class="s1">data = new_data</span>
            <span class="s1">self._strl_blob = ssw.generate_blob(tab)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">_set_formats_and_types(self</span><span class="s2">, </span><span class="s1">dtypes: Series) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.typlist = []</span>
        <span class="s1">self.fmtlist = []</span>
        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">dtypes.items():</span>
            <span class="s1">force_strl = col </span><span class="s2">in </span><span class="s1">self._convert_strl</span>
            <span class="s1">fmt = _dtype_to_default_stata_fmt(</span>
                <span class="s1">dtype</span><span class="s2">,</span>
                <span class="s1">self.data[col]</span><span class="s2">,</span>
                <span class="s1">dta_version=self._dta_version</span><span class="s2">,</span>
                <span class="s1">force_strl=force_strl</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.fmtlist.append(fmt)</span>
            <span class="s1">self.typlist.append(</span>
                <span class="s1">_dtype_to_stata_type_117(dtype</span><span class="s2">, </span><span class="s1">self.data[col]</span><span class="s2">, </span><span class="s1">force_strl)</span>
            <span class="s1">)</span>


<span class="s2">class </span><span class="s1">StataWriterUTF8(StataWriter117):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stata binary dta file writing in Stata 15 (118) and 16 (119) formats 
 
    DTA 118 and 119 format files support unicode string data (both fixed 
    and strL) format. Unicode is also supported in value labels, variable 
    labels and the dataset label. Format 119 is automatically used if the 
    file contains more than 32,767 variables. 
 
    .. versionadded:: 1.0.0 
 
    Parameters 
    ---------- 
    fname : path (string), buffer or path object 
        string, path object (pathlib.Path or py._path.local.LocalPath) or 
        object implementing a binary write() functions. If using a buffer 
        then the buffer will not be automatically closed after the file 
        is written. 
    data : DataFrame 
        Input to save 
    convert_dates : dict, default None 
        Dictionary mapping columns containing datetime types to stata internal 
        format to use when writing the dates. Options are 'tc', 'td', 'tm', 
        'tw', 'th', 'tq', 'ty'. Column can be either an integer or a name. 
        Datetime columns that do not have a conversion type specified will be 
        converted to 'tc'. Raises NotImplementedError if a datetime column has 
        timezone information 
    write_index : bool, default True 
        Write the index to Stata dataset. 
    byteorder : str, default None 
        Can be &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;little&quot;, or &quot;big&quot;. default is `sys.byteorder` 
    time_stamp : datetime, default None 
        A datetime to use as file creation date.  Default is the current time 
    data_label : str, default None 
        A label for the data set.  Must be 80 characters or smaller. 
    variable_labels : dict, default None 
        Dictionary containing columns as keys and variable labels as values. 
        Each label must be 80 characters or smaller. 
    convert_strl : list, default None 
        List of columns names to convert to Stata StrL format.  Columns with 
        more than 2045 characters are automatically written as StrL. 
        Smaller columns can be converted by including the column name.  Using 
        StrLs can reduce output file size when strings are longer than 8 
        characters, and either frequently repeated or sparse. 
    version : int, default None 
        The dta version to use. By default, uses the size of data to determine 
        the version. 118 is used if data.shape[1] &lt;= 32767, and 119 is used 
        for storing larger DataFrames. 
    {compression_options} 
 
        .. versionadded:: 1.1.0 
 
        .. versionchanged:: 1.4.0 Zstandard support. 
 
    value_labels : dict of dicts 
        Dictionary containing columns as keys and dictionaries of column value 
        to labels as values. The combined length of all labels for a single 
        variable must be 32,000 characters or smaller. 
 
        .. versionadded:: 1.4.0 
 
    Returns 
    ------- 
    StataWriterUTF8 
        The instance has a write_file method, which will write the file to the 
        given `fname`. 
 
    Raises 
    ------ 
    NotImplementedError 
        * If datetimes contain timezone information 
    ValueError 
        * Columns listed in convert_dates are neither datetime64[ns] 
          or datetime.datetime 
        * Column dtype is not representable in Stata 
        * Column listed in convert_dates is not in DataFrame 
        * Categorical label contains more than 32,000 characters 
 
    Examples 
    -------- 
    Using Unicode data and column names 
 
    &gt;&gt;&gt; from pandas.io.stata import StataWriterUTF8 
    &gt;&gt;&gt; data = pd.DataFrame([[1.0, 1, 'ᴬ']], columns=['a', 'β', 'ĉ']) 
    &gt;&gt;&gt; writer = StataWriterUTF8('./data_file.dta', data) 
    &gt;&gt;&gt; writer.write_file() 
 
    Directly write a zip file 
    &gt;&gt;&gt; compression = {&quot;method&quot;: &quot;zip&quot;, &quot;archive_name&quot;: &quot;data_file.dta&quot;} 
    &gt;&gt;&gt; writer = StataWriterUTF8('./data_file.zip', data, compression=compression) 
    &gt;&gt;&gt; writer.write_file() 
 
    Or with long strings stored in strl format 
 
    &gt;&gt;&gt; data = pd.DataFrame([['ᴀ relatively long ŝtring'], [''], ['']], 
    ...                     columns=['strls']) 
    &gt;&gt;&gt; writer = StataWriterUTF8('./data_file_with_long_strings.dta', data, 
    ...                          convert_strl=['strls']) 
    &gt;&gt;&gt; writer.write_file() 
    &quot;&quot;&quot;</span>

    <span class="s1">_encoding = </span><span class="s3">&quot;utf-8&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fname: FilePath | WriteBuffer[bytes]</span><span class="s2">,</span>
        <span class="s1">data: DataFrame</span><span class="s2">,</span>
        <span class="s1">convert_dates: dict[Hashable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">write_index: bool = </span><span class="s2">True,</span>
        <span class="s1">byteorder: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">time_stamp: datetime.datetime | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">data_label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">variable_labels: dict[Hashable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">convert_strl: Sequence[Hashable] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">version: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">value_labels: dict[Hashable</span><span class="s2">, </span><span class="s1">dict[float | int</span><span class="s2">, </span><span class="s1">str]] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">version </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">version = </span><span class="s4">118 </span><span class="s2">if </span><span class="s1">data.shape[</span><span class="s4">1</span><span class="s1">] &lt;= </span><span class="s4">32767 </span><span class="s2">else </span><span class="s4">119</span>
        <span class="s2">elif </span><span class="s1">version </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">118</span><span class="s2">, </span><span class="s4">119</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;version must be either 118 or 119.&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">version == </span><span class="s4">118 </span><span class="s2">and </span><span class="s1">data.shape[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">32767</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;You must use version 119 for data sets containing more than&quot;</span>
                <span class="s3">&quot;32,767 variables&quot;</span>
            <span class="s1">)</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">fname</span><span class="s2">,</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">convert_dates=convert_dates</span><span class="s2">,</span>
            <span class="s1">write_index=write_index</span><span class="s2">,</span>
            <span class="s1">byteorder=byteorder</span><span class="s2">,</span>
            <span class="s1">time_stamp=time_stamp</span><span class="s2">,</span>
            <span class="s1">data_label=data_label</span><span class="s2">,</span>
            <span class="s1">variable_labels=variable_labels</span><span class="s2">,</span>
            <span class="s1">value_labels=value_labels</span><span class="s2">,</span>
            <span class="s1">convert_strl=convert_strl</span><span class="s2">,</span>
            <span class="s1">compression=compression</span><span class="s2">,</span>
            <span class="s1">storage_options=storage_options</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s5"># Override version set in StataWriter117 init</span>
        <span class="s1">self._dta_version = version</span>

    <span class="s2">def </span><span class="s1">_validate_variable_name(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate variable names for Stata export. 
 
        Parameters 
        ---------- 
        name : str 
            Variable name 
 
        Returns 
        ------- 
        str 
            The validated name with invalid characters replaced with 
            underscores. 
 
        Notes 
        ----- 
        Stata 118+ support most unicode characters. The only limitation is in 
        the ascii range where the characters supported are a-z, A-Z, 0-9 and _. 
        &quot;&quot;&quot;</span>
        <span class="s5"># High code points appear to be acceptable</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">name:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">ord(c) &lt; </span><span class="s4">128</span>
                <span class="s2">and </span><span class="s1">(c &lt; </span><span class="s3">&quot;A&quot; </span><span class="s2">or </span><span class="s1">c &gt; </span><span class="s3">&quot;Z&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">(c &lt; </span><span class="s3">&quot;a&quot; </span><span class="s2">or </span><span class="s1">c &gt; </span><span class="s3">&quot;z&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">(c &lt; </span><span class="s3">&quot;0&quot; </span><span class="s2">or </span><span class="s1">c &gt; </span><span class="s3">&quot;9&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">c != </span><span class="s3">&quot;_&quot;</span>
            <span class="s1">) </span><span class="s2">or </span><span class="s4">128 </span><span class="s1">&lt;= ord(c) &lt; </span><span class="s4">256</span><span class="s1">:</span>
                <span class="s1">name = name.replace(c</span><span class="s2">, </span><span class="s3">&quot;_&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">name</span>
</pre>
</body>
</html>