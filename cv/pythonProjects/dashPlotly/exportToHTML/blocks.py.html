<html>
<head>
<title>blocks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
blocks.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
    <span class="s1">final</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">algos </span><span class="s0">as </span><span class="s1">libalgos</span><span class="s0">,</span>
    <span class="s1">internals </span><span class="s0">as </span><span class="s1">libinternals</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
    <span class="s1">writers</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.internals </span><span class="s0">import </span><span class="s1">BlockPlacement</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s0">,</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">F</span><span class="s0">,</span>
    <span class="s1">Shape</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">np_version_under1p20</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>
<span class="s0">from </span><span class="s1">pandas.util._validators </span><span class="s0">import </span><span class="s1">validate_bool_kwarg</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">astype_array_safe</span><span class="s0">,</span>
    <span class="s1">can_hold_element</span><span class="s0">,</span>
    <span class="s1">find_common_type</span><span class="s0">,</span>
    <span class="s1">infer_dtype_from</span><span class="s0">,</span>
    <span class="s1">maybe_downcast_numeric</span><span class="s0">,</span>
    <span class="s1">maybe_downcast_to_dtype</span><span class="s0">,</span>
    <span class="s1">maybe_upcast</span><span class="s0">,</span>
    <span class="s1">soft_convert_objects</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s0">,</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s0">,</span>
    <span class="s1">is_1d_only_ea_obj</span><span class="s0">,</span>
    <span class="s1">is_dtype_equal</span><span class="s0">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s0">,</span>
    <span class="s1">is_interval_dtype</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_string_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CategoricalDtype</span><span class="s0">,</span>
    <span class="s1">ExtensionDtype</span><span class="s0">,</span>
    <span class="s1">PandasDtype</span><span class="s0">,</span>
    <span class="s1">PeriodDtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s0">,</span>
    <span class="s1">ABCIndex</span><span class="s0">,</span>
    <span class="s1">ABCPandasArray</span><span class="s0">,</span>
    <span class="s1">ABCSeries</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.inference </span><span class="s0">import </span><span class="s1">is_inferred_bool_dtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_valid_na_for_dtype</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">pandas.core.algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.putmask </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">extract_bool_array</span><span class="s0">,</span>
    <span class="s1">putmask_inplace</span><span class="s0">,</span>
    <span class="s1">putmask_smart</span><span class="s0">,</span>
    <span class="s1">putmask_without_repeat</span><span class="s0">,</span>
    <span class="s1">setitem_datetimelike_compat</span><span class="s0">,</span>
    <span class="s1">validate_putmask</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.quantile </span><span class="s0">import </span><span class="s1">quantile_compat</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.replace </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">compare_or_regex_search</span><span class="s0">,</span>
    <span class="s1">replace_regex</span><span class="s0">,</span>
    <span class="s1">should_use_regex</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.take </span><span class="s0">import </span><span class="s1">take_nd</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.transforms </span><span class="s0">import </span><span class="s1">shift</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
    <span class="s1">ExtensionArray</span><span class="s0">,</span>
    <span class="s1">IntervalArray</span><span class="s0">,</span>
    <span class="s1">PandasArray</span><span class="s0">,</span>
    <span class="s1">PeriodArray</span><span class="s0">,</span>
    <span class="s1">TimedeltaArray</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays._mixins </span><span class="s0">import </span><span class="s1">NDArrayBackedExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.sparse </span><span class="s0">import </span><span class="s1">SparseDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.base </span><span class="s0">import </span><span class="s1">PandasObject</span>
<span class="s0">import </span><span class="s1">pandas.core.common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">import </span><span class="s1">pandas.core.computation.expressions </span><span class="s0">as </span><span class="s1">expressions</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s0">,</span>
    <span class="s1">extract_array</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexers </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">check_setitem_lengths</span><span class="s0">,</span>
    <span class="s1">is_empty_indexer</span><span class="s0">,</span>
    <span class="s1">is_scalar_indexer</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.core.missing </span><span class="s0">as </span><span class="s1">missing</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">Float64Index</span><span class="s0">,</span>
        <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">)</span>

<span class="s2"># comparison is faster than is_object_dtype</span>
<span class="s1">_dtype_obj = np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">maybe_split(meth: F) -&gt; F:</span>
    <span class="s4">&quot;&quot;&quot; 
    If we have a multi-column block, split and operate block-wise.  Otherwise 
    use the original method. 
    &quot;&quot;&quot;</span>

    <span class="s1">@wraps(meth)</span>
    <span class="s0">def </span><span class="s1">newfunc(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; list[Block]:</span>

        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">meth(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Split and operate column-by-column</span>
            <span class="s0">return </span><span class="s1">self.split_and_operate(meth</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">newfunc)</span>


<span class="s0">class </span><span class="s1">Block(PandasObject):</span>
    <span class="s4">&quot;&quot;&quot; 
    Canonical n-dimensional unit of homogeneous dtype contained in a pandas 
    data structure 
 
    Index-ignorant; let the container take care of that 
    &quot;&quot;&quot;</span>

    <span class="s1">values: np.ndarray | ExtensionArray</span>
    <span class="s1">ndim: int</span>
    <span class="s1">__init__: Callable</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">is_numeric = </span><span class="s0">False</span>
    <span class="s1">is_object = </span><span class="s0">False</span>
    <span class="s1">is_extension = </span><span class="s0">False</span>
    <span class="s1">_can_consolidate = </span><span class="s0">True</span>
    <span class="s1">_validate_ndim = </span><span class="s0">True</span>

    <span class="s1">@final</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_consolidate_key(self):</span>
        <span class="s0">return </span><span class="s1">self._can_consolidate</span><span class="s0">, </span><span class="s1">self.dtype.name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_view(self) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot;return a boolean if I am possibly a view&quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>
        <span class="s1">values = cast(np.ndarray</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s0">return </span><span class="s1">values.base </span><span class="s0">is not None</span>

    <span class="s1">@final</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_can_hold_na(self) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Can we store NA values in this Block? 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype = self.dtype</span>
        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s0">return </span><span class="s1">dtype.kind </span><span class="s0">not in </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;i&quot;</span><span class="s0">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">dtype._can_hold_na</span>

    <span class="s1">@final</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_categorical(self) -&gt; bool:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Block.is_categorical is deprecated and will be removed in a &quot;</span>
            <span class="s3">&quot;future version.  Use isinstance(block.values, Categorical) &quot;</span>
            <span class="s3">&quot;instead. See https://github.com/pandas-dev/pandas/issues/40226&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">isinstance(self.values</span><span class="s0">, </span><span class="s1">Categorical)</span>

    <span class="s1">@final</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_bool(self) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        We can be bool if a) we are bool dtype or b) object dtype with bool objects. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">is_inferred_bool_dtype(self.values)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">external_values(self):</span>
        <span class="s0">return </span><span class="s1">external_values(self.values)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">array_values(self) -&gt; ExtensionArray:</span>
        <span class="s4">&quot;&quot;&quot; 
        The array that Series.array returns. Always an ExtensionArray. 
        &quot;&quot;&quot;</span>
        <span class="s2"># error: Argument 1 to &quot;PandasArray&quot; has incompatible type &quot;Union[ndarray,</span>
        <span class="s2"># ExtensionArray]&quot;; expected &quot;Union[ndarray, PandasArray]&quot;</span>
        <span class="s0">return </span><span class="s1">PandasArray(self.values)  </span><span class="s2"># type: ignore[arg-type]</span>

    <span class="s0">def </span><span class="s1">get_values(self</span><span class="s0">, </span><span class="s1">dtype: DtypeObj | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; np.ndarray:</span>
        <span class="s4">&quot;&quot;&quot; 
        return an internal format, currently just the ndarray 
        this is often overridden to handle to_dense like operations 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">dtype == _dtype_obj:</span>
            <span class="s0">return </span><span class="s1">self.values.astype(_dtype_obj)</span>
        <span class="s2"># error: Incompatible return value type (got &quot;Union[ndarray, ExtensionArray]&quot;,</span>
        <span class="s2"># expected &quot;ndarray&quot;)</span>
        <span class="s0">return </span><span class="s1">self.values  </span><span class="s2"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">values_for_json(self) -&gt; np.ndarray:</span>
        <span class="s2"># Incompatible return value type (got &quot;Union[ndarray[Any, Any],</span>
        <span class="s2"># ExtensionArray]&quot;, expected &quot;ndarray[Any, Any]&quot;)</span>
        <span class="s0">return </span><span class="s1">self.values  </span><span class="s2"># type: ignore[return-value]</span>

    <span class="s1">@final</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">fill_value(self):</span>
        <span class="s2"># Used in reindex_indexer</span>
        <span class="s0">return </span><span class="s1">na_value_for_dtype(self.dtype</span><span class="s0">, </span><span class="s1">compat=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">mgr_locs(self) -&gt; BlockPlacement:</span>
        <span class="s0">return </span><span class="s1">self._mgr_locs</span>

    <span class="s1">@mgr_locs.setter</span>
    <span class="s0">def </span><span class="s1">mgr_locs(self</span><span class="s0">, </span><span class="s1">new_mgr_locs: BlockPlacement):</span>
        <span class="s1">self._mgr_locs = new_mgr_locs</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">make_block(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">placement=</span><span class="s0">None</span><span class="s1">) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        Create a new block, with type inference propagate any values that are 
        not specified 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">placement </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">placement = self._mgr_locs</span>
        <span class="s0">if </span><span class="s1">self.is_extension:</span>
            <span class="s1">values = ensure_block_shape(values</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

        <span class="s2"># TODO: perf by not going through new_block</span>
        <span class="s2"># We assume maybe_coerce_values has already been called</span>
        <span class="s0">return </span><span class="s1">new_block(values</span><span class="s0">, </span><span class="s1">placement=placement</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">make_block_same_class(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">placement: BlockPlacement | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot;Wrap given values in a block of same type as self.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">placement </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">placement = self._mgr_locs</span>

        <span class="s0">if </span><span class="s1">values.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s0">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>

            <span class="s1">new_values = ensure_wrapped_if_datetimelike(values)</span>
            <span class="s0">if </span><span class="s1">new_values </span><span class="s0">is not </span><span class="s1">values:</span>
                <span class="s2"># TODO(2.0): remove once fastparquet has stopped relying on it</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s3">&quot;In a future version, Block.make_block_same_class will &quot;</span>
                    <span class="s3">&quot;assume that datetime64 and timedelta64 ndarrays have &quot;</span>
                    <span class="s3">&quot;already been cast to DatetimeArray and TimedeltaArray, &quot;</span>
                    <span class="s3">&quot;respectively.&quot;</span><span class="s0">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s0">,</span>
                    <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">values = new_values</span>

        <span class="s2"># We assume maybe_coerce_values has already been called</span>
        <span class="s0">return </span><span class="s1">type(self)(values</span><span class="s0">, </span><span class="s1">placement=placement</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2"># don't want to print out all of the items here</span>
        <span class="s1">name = type(self).__name__</span>
        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">result = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">: </span><span class="s0">{</span><span class="s1">len(self)</span><span class="s0">} </span><span class="s3">dtype: </span><span class="s0">{</span><span class="s1">self.dtype</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>

            <span class="s1">shape = </span><span class="s3">&quot; x &quot;</span><span class="s1">.join([str(s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self.shape])</span>
            <span class="s1">result = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">: </span><span class="s0">{</span><span class="s1">self.mgr_locs.indexer</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">shape</span><span class="s0">}</span><span class="s3">, dtype: </span><span class="s0">{</span><span class="s1">self.dtype</span><span class="s0">}</span><span class="s3">&quot;</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self.values)</span>

    <span class="s0">def </span><span class="s1">_slice(self</span><span class="s0">, </span><span class="s1">slicer) -&gt; ArrayLike:</span>
        <span class="s4">&quot;&quot;&quot;return a slice of my values&quot;&quot;&quot;</span>

        <span class="s0">return </span><span class="s1">self.values[slicer]</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">getitem_block(self</span><span class="s0">, </span><span class="s1">slicer: slice | npt.NDArray[np.intp]) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        Perform __getitem__-like, return result as block. 
 
        Only supports slices that preserve dimensionality. 
        &quot;&quot;&quot;</span>
        <span class="s1">axis0_slicer = slicer[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">isinstance(slicer</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">else </span><span class="s1">slicer</span>
        <span class="s1">new_mgr_locs = self._mgr_locs[axis0_slicer]</span>

        <span class="s1">new_values = self._slice(slicer)</span>

        <span class="s0">if </span><span class="s1">new_values.ndim != self.values.ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Only same dim slicing is allowed&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">type(self)(new_values</span><span class="s0">, </span><span class="s1">new_mgr_locs</span><span class="s0">, </span><span class="s1">self.ndim)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">getitem_block_columns(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">slicer: slice</span><span class="s0">, </span><span class="s1">new_mgr_locs: BlockPlacement</span>
    <span class="s1">) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        Perform __getitem__-like, return result as block. 
 
        Only supports slices that preserve dimensionality. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values = self._slice(slicer)</span>

        <span class="s0">if </span><span class="s1">new_values.ndim != self.values.ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Only same dim slicing is allowed&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">type(self)(new_values</span><span class="s0">, </span><span class="s1">new_mgr_locs</span><span class="s0">, </span><span class="s1">self.ndim)</span>

    <span class="s2"># NB: this cannot be made cache_readonly because in libreduction we pin</span>
    <span class="s2">#  new .values that can have different shape GH#42631</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">shape(self) -&gt; Shape:</span>
        <span class="s0">return </span><span class="s1">self.values.shape</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; DtypeObj:</span>
        <span class="s0">return </span><span class="s1">self.values.dtype</span>

    <span class="s0">def </span><span class="s1">iget(self</span><span class="s0">, </span><span class="s1">i: int | tuple[int</span><span class="s0">, </span><span class="s1">int] | tuple[slice</span><span class="s0">, </span><span class="s1">int]):</span>
        <span class="s2"># In the case where we have a tuple[slice, int], the slice will always</span>
        <span class="s2">#  be slice(None)</span>
        <span class="s2"># Note: only reached with self.ndim == 2</span>
        <span class="s2"># Invalid index type &quot;Union[int, Tuple[int, int], Tuple[slice, int]]&quot;</span>
        <span class="s2"># for &quot;Union[ndarray[Any, Any], ExtensionArray]&quot;; expected type</span>
        <span class="s2"># &quot;Union[int, integer[Any]]&quot;</span>
        <span class="s0">return </span><span class="s1">self.values[i]  </span><span class="s2"># type: ignore[index]</span>

    <span class="s0">def </span><span class="s1">set_inplace(self</span><span class="s0">, </span><span class="s1">locs</span><span class="s0">, </span><span class="s1">values) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Modify block values in-place with new item value. 
 
        Notes 
        ----- 
        `set` never creates a new array or new Block, whereas `setitem` _may_ 
        create a new array and always creates a new Block. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.values[locs] = values</span>

    <span class="s0">def </span><span class="s1">delete(self</span><span class="s0">, </span><span class="s1">loc) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Delete given loc(-s) from block in-place. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Argument 1 to &quot;delete&quot; has incompatible type &quot;Union[ndarray[Any, Any],</span>
        <span class="s2"># ExtensionArray]&quot;; expected &quot;Union[_SupportsArray[dtype[Any]],</span>
        <span class="s2"># Sequence[_SupportsArray[dtype[Any]]], Sequence[Sequence</span>
        <span class="s2"># [_SupportsArray[dtype[Any]]]], Sequence[Sequence[Sequence[</span>
        <span class="s2"># _SupportsArray[dtype[Any]]]]], Sequence[Sequence[Sequence[Sequence[</span>
        <span class="s2"># _SupportsArray[dtype[Any]]]]]]]&quot;  [arg-type]</span>
        <span class="s1">self.values = np.delete(self.values</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)  </span><span class="s2"># type: ignore[arg-type]</span>
        <span class="s1">self.mgr_locs = self._mgr_locs.delete(loc)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._cache.clear()</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># _cache not yet initialized</span>
            <span class="s0">pass</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">apply(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        apply the function to my values; return a block if we are not 
        one 
        &quot;&quot;&quot;</span>
        <span class="s1">result = func(self.values</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">return </span><span class="s1">self._split_op_result(result)</span>

    <span class="s0">def </span><span class="s1">reduce(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">ignore_failures: bool = </span><span class="s0">False</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s2"># We will apply the function and reshape the result into a single-row</span>
        <span class="s2">#  Block with the same mgr_locs; squeezing will be done at a higher level</span>
        <span class="s0">assert </span><span class="s1">self.ndim == </span><span class="s5">2</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = func(self.values)</span>
        <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">NotImplementedError):</span>
            <span class="s0">if </span><span class="s1">ignore_failures:</span>
                <span class="s0">return </span><span class="s1">[]</span>
            <span class="s0">raise</span>

        <span class="s0">if </span><span class="s1">self.values.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># TODO(EA2D): special case not needed with 2D EAs</span>
            <span class="s1">res_values = np.array([[result]])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">res_values = result.reshape(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">nb = self.make_block(res_values)</span>
        <span class="s0">return </span><span class="s1">[nb]</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_split_op_result(self</span><span class="s0">, </span><span class="s1">result: ArrayLike) -&gt; list[Block]:</span>
        <span class="s2"># See also: split_and_operate</span>
        <span class="s0">if </span><span class="s1">result.ndim &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">isinstance(result.dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s2"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s2"># if we get a 2D ExtensionArray, we need to split it into 1D pieces</span>
            <span class="s1">nbs = []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">enumerate(self._mgr_locs):</span>
                <span class="s0">if not </span><span class="s1">is_1d_only_ea_obj(result):</span>
                    <span class="s1">vals = result[i : i + </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">vals = result[i]</span>

                <span class="s1">block = self.make_block(values=vals</span><span class="s0">, </span><span class="s1">placement=loc)</span>
                <span class="s1">nbs.append(block)</span>
            <span class="s0">return </span><span class="s1">nbs</span>

        <span class="s1">nb = self.make_block(result)</span>

        <span class="s0">return </span><span class="s1">[nb]</span>

    <span class="s0">def </span><span class="s1">fillna(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">limit=</span><span class="s0">None, </span><span class="s1">inplace: bool = </span><span class="s0">False, </span><span class="s1">downcast=</span><span class="s0">None</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        fillna on the block with the value. If we fail, then convert to 
        ObjectBlock and try again 
        &quot;&quot;&quot;</span>
        <span class="s1">inplace = validate_bool_kwarg(inplace</span><span class="s0">, </span><span class="s3">&quot;inplace&quot;</span><span class="s1">)</span>

        <span class="s1">mask = isna(self.values)</span>
        <span class="s1">mask</span><span class="s0">, </span><span class="s1">noop = validate_putmask(self.values</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s0">if </span><span class="s1">limit </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">limit = libalgos.validate_limit(</span><span class="s0">None, </span><span class="s1">limit=limit)</span>
            <span class="s1">mask[mask.cumsum(self.ndim - </span><span class="s5">1</span><span class="s1">) &gt; limit] = </span><span class="s0">False</span>

        <span class="s0">if not </span><span class="s1">self._can_hold_na:</span>
            <span class="s0">if </span><span class="s1">inplace:</span>
                <span class="s0">return </span><span class="s1">[self]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[self.copy()]</span>

        <span class="s0">if </span><span class="s1">self._can_hold_element(value):</span>
            <span class="s1">nb = self </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self.copy()</span>
            <span class="s1">putmask_inplace(nb.values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">return </span><span class="s1">nb._maybe_downcast([nb]</span><span class="s0">, </span><span class="s1">downcast)</span>

        <span class="s0">if </span><span class="s1">noop:</span>
            <span class="s2"># we can't process the value, but nothing to do</span>
            <span class="s0">return </span><span class="s1">[self] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">[self.copy()]</span>

        <span class="s0">elif </span><span class="s1">self.ndim == </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">blk = self.coerce_to_target_dtype(value)</span>
            <span class="s2"># bc we have already cast, inplace=True may avoid an extra copy</span>
            <span class="s0">return </span><span class="s1">blk.fillna(value</span><span class="s0">, </span><span class="s1">limit=limit</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True, </span><span class="s1">downcast=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># operate column-by-column</span>
            <span class="s0">return </span><span class="s1">self.split_and_operate(</span>
                <span class="s1">type(self).fillna</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">limit=limit</span><span class="s0">, </span><span class="s1">inplace=inplace</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s0">None</span>
            <span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_split(self) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Split a block into a list of single-column blocks. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self.ndim == </span><span class="s5">2</span>

        <span class="s1">new_blocks = []</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ref_loc </span><span class="s0">in </span><span class="s1">enumerate(self._mgr_locs):</span>
            <span class="s1">vals = self.values[slice(i</span><span class="s0">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">)]</span>

            <span class="s1">bp = BlockPlacement(ref_loc)</span>
            <span class="s1">nb = type(self)(vals</span><span class="s0">, </span><span class="s1">placement=bp</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">new_blocks.append(nb)</span>
        <span class="s0">return </span><span class="s1">new_blocks</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">split_and_operate(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Split the block and apply func column-by-column. 
 
        Parameters 
        ---------- 
        func : Block method 
        *args 
        **kwargs 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self.ndim == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1</span>

        <span class="s1">res_blocks = []</span>
        <span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">self._split():</span>
            <span class="s1">rbs = func(nb</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">res_blocks.extend(rbs)</span>
        <span class="s0">return </span><span class="s1">res_blocks</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_maybe_downcast(self</span><span class="s0">, </span><span class="s1">blocks: list[Block]</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s0">None</span><span class="s1">) -&gt; list[Block]:</span>

        <span class="s0">if </span><span class="s1">self.dtype == _dtype_obj:</span>
            <span class="s2"># GH#44241 We downcast regardless of the argument;</span>
            <span class="s2">#  respecting 'downcast=None' may be worthwhile at some point,</span>
            <span class="s2">#  but ATM it breaks too much existing code.</span>
            <span class="s2"># split and convert the blocks</span>

            <span class="s0">return </span><span class="s1">extend_blocks(</span>
                <span class="s1">[blk.convert(datetime=</span><span class="s0">True, </span><span class="s1">numeric=</span><span class="s0">False</span><span class="s1">) </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks]</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">downcast </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">blocks</span>
        <span class="s0">if </span><span class="s1">downcast </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s2"># turn if off completely</span>
            <span class="s2"># TODO: not reached, deprecate in favor of downcast=None</span>
            <span class="s0">return </span><span class="s1">blocks</span>

        <span class="s0">return </span><span class="s1">extend_blocks([b._downcast_2d(downcast) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks])</span>

    <span class="s1">@final</span>
    <span class="s1">@maybe_split</span>
    <span class="s0">def </span><span class="s1">_downcast_2d(self</span><span class="s0">, </span><span class="s1">dtype) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        downcast specialized to 2D case post-validation. 
 
        Refactored to allow use of maybe_split. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values = maybe_downcast_to_dtype(self.values</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">return </span><span class="s1">[self.make_block(new_values)]</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: DtypeObj</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False, </span><span class="s1">errors: str = </span><span class="s3">&quot;raise&quot;</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Coerce to the new dtype. 
 
        Parameters 
        ---------- 
        dtype : np.dtype or ExtensionDtype 
        copy : bool, default False 
            copy if indicated 
        errors : str, {'raise', 'ignore'}, default 'raise' 
            - ``raise`` : allow exceptions to be raised 
            - ``ignore`` : suppress exceptions. On error return original object 
 
        Returns 
        ------- 
        Block 
        &quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>

        <span class="s1">new_values = astype_array_safe(values</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">copy=copy</span><span class="s0">, </span><span class="s1">errors=errors)</span>

        <span class="s1">new_values = maybe_coerce_values(new_values)</span>
        <span class="s1">newb = self.make_block(new_values)</span>
        <span class="s0">if </span><span class="s1">newb.shape != self.shape:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;cannot set astype for copy = [</span><span class="s0">{</span><span class="s1">copy</span><span class="s0">}</span><span class="s3">] for dtype &quot;</span>
                <span class="s3">f&quot;(</span><span class="s0">{</span><span class="s1">self.dtype.name</span><span class="s0">} </span><span class="s3">[</span><span class="s0">{</span><span class="s1">self.shape</span><span class="s0">}</span><span class="s3">]) to different shape &quot;</span>
                <span class="s3">f&quot;(</span><span class="s0">{</span><span class="s1">newb.dtype.name</span><span class="s0">} </span><span class="s3">[</span><span class="s0">{</span><span class="s1">newb.shape</span><span class="s0">}</span><span class="s3">])&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">newb</span>

    <span class="s0">def </span><span class="s1">convert(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">copy: bool = </span><span class="s0">True,</span>
        <span class="s1">datetime: bool = </span><span class="s0">True,</span>
        <span class="s1">numeric: bool = </span><span class="s0">True,</span>
        <span class="s1">timedelta: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        attempt to coerce any object types to better types return a copy 
        of the block (if copy = True) by definition we are not an ObjectBlock 
        here! 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">[self.copy()] </span><span class="s0">if </span><span class="s1">copy </span><span class="s0">else </span><span class="s1">[self]</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_can_hold_element(self</span><span class="s0">, </span><span class="s1">element: Any) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot;require the same dtype as ourselves&quot;&quot;&quot;</span>
        <span class="s1">element = extract_array(element</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">can_hold_element(self.values</span><span class="s0">, </span><span class="s1">element)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">should_store(self</span><span class="s0">, </span><span class="s1">value: ArrayLike) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Should we set self.values[indexer] = value inplace or do we need to cast? 
 
        Parameters 
        ---------- 
        value : np.ndarray or ExtensionArray 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s2"># faster equivalent to is_dtype_equal(value.dtype, self.dtype)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">value.dtype == self.dtype</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">return False</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">to_native_types(self</span><span class="s0">, </span><span class="s1">na_rep=</span><span class="s3">&quot;nan&quot;</span><span class="s0">, </span><span class="s1">quoting=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s4">&quot;&quot;&quot;convert to our native types format&quot;&quot;&quot;</span>
        <span class="s1">result = to_native_types(self.values</span><span class="s0">, </span><span class="s1">na_rep=na_rep</span><span class="s0">, </span><span class="s1">quoting=quoting</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self.make_block(result)</span>

    <span class="s2"># block actions #</span>
    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">copy(self</span><span class="s0">, </span><span class="s1">deep: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;copy constructor&quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>
        <span class="s0">if </span><span class="s1">deep:</span>
            <span class="s1">values = values.copy()</span>
        <span class="s0">return </span><span class="s1">type(self)(values</span><span class="s0">, </span><span class="s1">placement=self._mgr_locs</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

    <span class="s2"># ---------------------------------------------------------------------</span>
    <span class="s2"># Replace</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">replace(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">to_replace</span><span class="s0">,</span>
        <span class="s1">value</span><span class="s0">,</span>
        <span class="s1">inplace: bool = </span><span class="s0">False,</span>
        <span class="s2"># mask may be pre-computed if we're called from replace_list</span>
        <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        replace the to_replace value with value, possible to create new 
        blocks here this is just a call to putmask. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Note: the checks we do in NDFrame.replace ensure we never get</span>
        <span class="s2">#  here with listlike to_replace or value, as those cases</span>
        <span class="s2">#  go through replace_list</span>

        <span class="s1">values = self.values</span>

        <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Categorical):</span>
            <span class="s2"># TODO: avoid special-casing</span>
            <span class="s1">blk = self </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self.copy()</span>
            <span class="s1">blk.values._replace(to_replace=to_replace</span><span class="s0">, </span><span class="s1">value=value</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">[blk]</span>

        <span class="s0">if not </span><span class="s1">self._can_hold_element(to_replace):</span>
            <span class="s2"># We cannot hold `to_replace`, so we know immediately that</span>
            <span class="s2">#  replacing it is a no-op.</span>
            <span class="s2"># Note: If to_replace were a list, NDFrame.replace would call</span>
            <span class="s2">#  replace_list instead of replace.</span>
            <span class="s0">return </span><span class="s1">[self] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">[self.copy()]</span>

        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mask = missing.mask_missing(values</span><span class="s0">, </span><span class="s1">to_replace)</span>
        <span class="s0">if not </span><span class="s1">mask.any():</span>
            <span class="s2"># Note: we get here with test_replace_extension_other incorrectly</span>
            <span class="s2">#  bc _can_hold_element is incorrect.</span>
            <span class="s0">return </span><span class="s1">[self] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">[self.copy()]</span>

        <span class="s0">elif </span><span class="s1">self._can_hold_element(value):</span>
            <span class="s1">blk = self </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self.copy()</span>
            <span class="s1">putmask_inplace(blk.values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">if not </span><span class="s1">(self.is_object </span><span class="s0">and </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">):</span>
                <span class="s2"># if the user *explicitly* gave None, we keep None, otherwise</span>
                <span class="s2">#  may downcast to NaN</span>
                <span class="s1">blocks = blk.convert(numeric=</span><span class="s0">False, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">blocks = [blk]</span>
            <span class="s0">return </span><span class="s1">blocks</span>

        <span class="s0">elif </span><span class="s1">self.ndim == </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">blk = self.coerce_to_target_dtype(value)</span>
            <span class="s0">return </span><span class="s1">blk.replace(</span>
                <span class="s1">to_replace=to_replace</span><span class="s0">,</span>
                <span class="s1">value=value</span><span class="s0">,</span>
                <span class="s1">inplace=</span><span class="s0">True,</span>
                <span class="s1">mask=mask</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># split so that we only upcast where necessary</span>
            <span class="s0">return </span><span class="s1">self.split_and_operate(</span>
                <span class="s1">type(self).replace</span><span class="s0">, </span><span class="s1">to_replace</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span>
            <span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_replace_regex(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">to_replace</span><span class="s0">,</span>
        <span class="s1">value</span><span class="s0">,</span>
        <span class="s1">inplace: bool = </span><span class="s0">False,</span>
        <span class="s1">convert: bool = </span><span class="s0">True,</span>
        <span class="s1">mask=</span><span class="s0">None,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Replace elements by the given value. 
 
        Parameters 
        ---------- 
        to_replace : object or pattern 
            Scalar to replace or regular expression to match. 
        value : object 
            Replacement object. 
        inplace : bool, default False 
            Perform inplace modification. 
        convert : bool, default True 
            If true, try to coerce any object types to better types. 
        mask : array-like of bool, optional 
            True indicate corresponding element is ignored. 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self._can_hold_element(to_replace):</span>
            <span class="s2"># i.e. only ObjectBlock, but could in principle include a</span>
            <span class="s2">#  String ExtensionBlock</span>
            <span class="s0">return </span><span class="s1">[self] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">[self.copy()]</span>

        <span class="s1">rx = re.compile(to_replace)</span>

        <span class="s1">new_values = self.values </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self.values.copy()</span>
        <span class="s1">replace_regex(new_values</span><span class="s0">, </span><span class="s1">rx</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s1">block = self.make_block(new_values)</span>
        <span class="s0">return </span><span class="s1">block.convert(numeric=</span><span class="s0">False, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">replace_list(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">src_list: Iterable[Any]</span><span class="s0">,</span>
        <span class="s1">dest_list: Sequence[Any]</span><span class="s0">,</span>
        <span class="s1">inplace: bool = </span><span class="s0">False,</span>
        <span class="s1">regex: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        See BlockManager.replace_list docstring. 
        &quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>

        <span class="s2"># Exclude anything that we know we won't contain</span>
        <span class="s1">pairs = [</span>
            <span class="s1">(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">zip(src_list</span><span class="s0">, </span><span class="s1">dest_list) </span><span class="s0">if </span><span class="s1">self._can_hold_element(x)</span>
        <span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">len(pairs):</span>
            <span class="s2"># shortcut, nothing to replace</span>
            <span class="s0">return </span><span class="s1">[self] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">[self.copy()]</span>

        <span class="s1">src_len = len(pairs) - </span><span class="s5">1</span>

        <span class="s0">if </span><span class="s1">is_string_dtype(values.dtype):</span>
            <span class="s2"># Calculate the mask once, prior to the call of comp</span>
            <span class="s2"># in order to avoid repeating the same computations</span>
            <span class="s1">mask = ~isna(values)</span>
            <span class="s1">masks = [</span>
                <span class="s1">compare_or_regex_search(values</span><span class="s0">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">regex=regex</span><span class="s0">, </span><span class="s1">mask=mask)</span>
                <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pairs</span>
            <span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># GH#38086 faster if we know we dont need to check for regex</span>
            <span class="s1">masks = [missing.mask_missing(values</span><span class="s0">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pairs]</span>

        <span class="s2"># error: Argument 1 to &quot;extract_bool_array&quot; has incompatible type</span>
        <span class="s2"># &quot;Union[ExtensionArray, ndarray, bool]&quot;; expected &quot;Union[ExtensionArray,</span>
        <span class="s2"># ndarray]&quot;</span>
        <span class="s1">masks = [extract_bool_array(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">masks]  </span><span class="s2"># type: ignore[arg-type]</span>

        <span class="s1">rb = [self </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self.copy()]</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(src</span><span class="s0">, </span><span class="s1">dest) </span><span class="s0">in </span><span class="s1">enumerate(pairs):</span>
            <span class="s1">convert = i == src_len  </span><span class="s2"># only convert once at the end</span>
            <span class="s1">new_rb: list[Block] = []</span>

            <span class="s2"># GH-39338: _replace_coerce can split a block into</span>
            <span class="s2"># single-column blocks, so track the index so we know</span>
            <span class="s2"># where to index into the mask</span>
            <span class="s0">for </span><span class="s1">blk_num</span><span class="s0">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">enumerate(rb):</span>
                <span class="s0">if </span><span class="s1">len(rb) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">m = masks[i]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">mib = masks[i]</span>
                    <span class="s0">assert not </span><span class="s1">isinstance(mib</span><span class="s0">, </span><span class="s1">bool)</span>
                    <span class="s1">m = mib[blk_num : blk_num + </span><span class="s5">1</span><span class="s1">]</span>

                <span class="s1">result = blk._replace_coerce(</span>
                    <span class="s1">to_replace=src</span><span class="s0">,</span>
                    <span class="s1">value=dest</span><span class="s0">,</span>
                    <span class="s1">mask=m</span><span class="s0">,</span>
                    <span class="s1">inplace=inplace</span><span class="s0">,</span>
                    <span class="s1">regex=regex</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">convert </span><span class="s0">and </span><span class="s1">blk.is_object </span><span class="s0">and not </span><span class="s1">all(x </span><span class="s0">is None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dest_list):</span>
                    <span class="s2"># GH#44498 avoid unwanted cast-back</span>
                    <span class="s1">result = extend_blocks(</span>
                        <span class="s1">[b.convert(numeric=</span><span class="s0">False, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">result]</span>
                    <span class="s1">)</span>
                <span class="s1">new_rb.extend(result)</span>
            <span class="s1">rb = new_rb</span>
        <span class="s0">return </span><span class="s1">rb</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_replace_coerce(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">to_replace</span><span class="s0">,</span>
        <span class="s1">value</span><span class="s0">,</span>
        <span class="s1">mask: np.ndarray</span><span class="s0">,</span>
        <span class="s1">inplace: bool = </span><span class="s0">True,</span>
        <span class="s1">regex: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Replace value corresponding to the given boolean array with another 
        value. 
 
        Parameters 
        ---------- 
        to_replace : object or pattern 
            Scalar to replace or regular expression to match. 
        value : object 
            Replacement object. 
        mask : np.ndarray[bool] 
            True indicate corresponding element is ignored. 
        inplace : bool, default True 
            Perform inplace modification. 
        regex : bool, default False 
            If true, perform regular expression substitution. 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">should_use_regex(regex</span><span class="s0">, </span><span class="s1">to_replace):</span>
            <span class="s0">return </span><span class="s1">self._replace_regex(</span>
                <span class="s1">to_replace</span><span class="s0">,</span>
                <span class="s1">value</span><span class="s0">,</span>
                <span class="s1">inplace=inplace</span><span class="s0">,</span>
                <span class="s1">convert=</span><span class="s0">False,</span>
                <span class="s1">mask=mask</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.replace(</span>
                <span class="s1">to_replace=to_replace</span><span class="s0">, </span><span class="s1">value=value</span><span class="s0">, </span><span class="s1">inplace=inplace</span><span class="s0">, </span><span class="s1">mask=mask</span>
            <span class="s1">)</span>

    <span class="s2"># ---------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">_maybe_squeeze_arg(self</span><span class="s0">, </span><span class="s1">arg: np.ndarray) -&gt; np.ndarray:</span>
        <span class="s4">&quot;&quot;&quot; 
        For compatibility with 1D-only ExtensionArrays. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">arg</span>

    <span class="s0">def </span><span class="s1">setitem(self</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s4">&quot;&quot;&quot; 
        Attempt self.values[indexer] = value, possibly creating a new array. 
 
        Parameters 
        ---------- 
        indexer : tuple, list-like, array-like, slice, int 
            The subset of self.values to set 
        value : object 
            The value being set 
 
        Returns 
        ------- 
        Block 
 
        Notes 
        ----- 
        `indexer` is a direct slice/positional indexer. `value` must 
        be a compatible shape. 
        &quot;&quot;&quot;</span>
        <span class="s1">transpose = self.ndim == </span><span class="s5">2</span>

        <span class="s0">if </span><span class="s1">isinstance(indexer</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">indexer.ndim &gt; self.ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Cannot set values with ndim &gt; </span><span class="s0">{</span><span class="s1">self.ndim</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s2"># coerce None values, if appropriate</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.is_numeric:</span>
                <span class="s1">value = np.nan</span>

        <span class="s2"># coerce if block dtype can store value</span>
        <span class="s1">values = cast(np.ndarray</span><span class="s0">, </span><span class="s1">self.values)</span>
        <span class="s0">if not </span><span class="s1">self._can_hold_element(value):</span>
            <span class="s2"># current dtype cannot store value, coerce to common dtype</span>
            <span class="s0">return </span><span class="s1">self.coerce_to_target_dtype(value).setitem(indexer</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s2"># value must be storable at this moment</span>
        <span class="s0">if </span><span class="s1">is_extension_array_dtype(getattr(value</span><span class="s0">, </span><span class="s3">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">)):</span>
            <span class="s2"># We need to be careful not to allow through strings that</span>
            <span class="s2">#  can be parsed to EADtypes</span>
            <span class="s1">arr_value = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">arr_value = np.asarray(value)</span>

        <span class="s0">if </span><span class="s1">transpose:</span>
            <span class="s1">values = values.T</span>

        <span class="s2"># length checking</span>
        <span class="s1">check_setitem_lengths(indexer</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">values)</span>

        <span class="s0">if </span><span class="s1">is_empty_indexer(indexer</span><span class="s0">, </span><span class="s1">arr_value):</span>
            <span class="s2"># GH#8669 empty indexers, test_loc_setitem_boolean_mask_allfalse</span>
            <span class="s0">pass</span>

        <span class="s0">elif </span><span class="s1">is_scalar_indexer(indexer</span><span class="s0">, </span><span class="s1">self.ndim):</span>
            <span class="s2"># setting a single element for each dim and with a rhs that could</span>
            <span class="s2">#  be e.g. a list; see GH#6043</span>
            <span class="s1">values[indexer] = value</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">value = setitem_datetimelike_compat(values</span><span class="s0">, </span><span class="s1">len(values[indexer])</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s1">values[indexer] = value</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">putmask(self</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">new) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        putmask the data to the block; it is possible that we may create a 
        new dtype of block 
 
        Return the resulting block(s). 
 
        Parameters 
        ---------- 
        mask : np.ndarray[bool], SparseArray[bool], or BooleanArray 
        new : a ndarray/object 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_mask = mask</span>
        <span class="s1">values = cast(np.ndarray</span><span class="s0">, </span><span class="s1">self.values)</span>
        <span class="s1">mask</span><span class="s0">, </span><span class="s1">noop = validate_putmask(values.T</span><span class="s0">, </span><span class="s1">mask)</span>
        <span class="s0">assert not </span><span class="s1">isinstance(new</span><span class="s0">, </span><span class="s1">(ABCIndex</span><span class="s0">, </span><span class="s1">ABCSeries</span><span class="s0">, </span><span class="s1">ABCDataFrame))</span>

        <span class="s0">if </span><span class="s1">new </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">new = self.fill_value</span>

        <span class="s2"># if we are passed a scalar None, convert it here</span>
        <span class="s0">if not </span><span class="s1">self.is_object </span><span class="s0">and </span><span class="s1">is_valid_na_for_dtype(new</span><span class="s0">, </span><span class="s1">self.dtype):</span>
            <span class="s1">new = self.fill_value</span>

        <span class="s0">if </span><span class="s1">self._can_hold_element(new):</span>
            <span class="s1">putmask_without_repeat(values.T</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">new)</span>
            <span class="s0">return </span><span class="s1">[self]</span>

        <span class="s0">elif </span><span class="s1">np_version_under1p20 </span><span class="s0">and </span><span class="s1">infer_dtype_from(new)[</span><span class="s5">0</span><span class="s1">].kind </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s0">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>
            <span class="s2"># using putmask with object dtype will incorrectly cast to object</span>
            <span class="s2"># Having excluded self._can_hold_element, we know we cannot operate</span>
            <span class="s2">#  in-place, so we are safe using `where`</span>
            <span class="s0">return </span><span class="s1">self.where(new</span><span class="s0">, </span><span class="s1">~mask)</span>

        <span class="s0">elif </span><span class="s1">noop:</span>
            <span class="s0">return </span><span class="s1">[self]</span>

        <span class="s0">elif </span><span class="s1">self.ndim == </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># no need to split columns</span>

            <span class="s0">if not </span><span class="s1">is_list_like(new):</span>
                <span class="s2"># putmask_smart can't save us the need to cast</span>
                <span class="s0">return </span><span class="s1">self.coerce_to_target_dtype(new).putmask(mask</span><span class="s0">, </span><span class="s1">new)</span>

            <span class="s2"># This differs from</span>
            <span class="s2">#  `self.coerce_to_target_dtype(new).putmask(mask, new)`</span>
            <span class="s2"># because putmask_smart will check if new[mask] may be held</span>
            <span class="s2"># by our dtype.</span>
            <span class="s1">nv = putmask_smart(values.T</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">new).T</span>
            <span class="s0">return </span><span class="s1">[self.make_block(nv)]</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">is_array = isinstance(new</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

            <span class="s1">res_blocks = []</span>
            <span class="s1">nbs = self._split()</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate(nbs):</span>
                <span class="s1">n = new</span>
                <span class="s0">if </span><span class="s1">is_array:</span>
                    <span class="s2"># we have a different value per-column</span>
                    <span class="s1">n = new[:</span><span class="s0">, </span><span class="s1">i : i + </span><span class="s5">1</span><span class="s1">]</span>

                <span class="s1">submask = orig_mask[:</span><span class="s0">, </span><span class="s1">i : i + </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">rbs = nb.putmask(submask</span><span class="s0">, </span><span class="s1">n)</span>
                <span class="s1">res_blocks.extend(rbs)</span>
            <span class="s0">return </span><span class="s1">res_blocks</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">coerce_to_target_dtype(self</span><span class="s0">, </span><span class="s1">other) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        coerce the current block to a dtype compat for other 
        we will return a block, possibly object, and not raise 
 
        we can also safely try to coerce to the same dtype 
        and will receive the same block 
        &quot;&quot;&quot;</span>
        <span class="s2"># if we cannot then coerce to object</span>
        <span class="s1">dtype</span><span class="s0">, </span><span class="s1">_ = infer_dtype_from(other</span><span class="s0">, </span><span class="s1">pandas_dtype=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">new_dtype = find_common_type([self.dtype</span><span class="s0">, </span><span class="s1">dtype])</span>

        <span class="s0">return </span><span class="s1">self.astype(new_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">interpolate(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">method: str = </span><span class="s3">&quot;pad&quot;</span><span class="s0">,</span>
        <span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">index: Index | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">inplace: bool = </span><span class="s0">False,</span>
        <span class="s1">limit: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">limit_direction: str = </span><span class="s3">&quot;forward&quot;</span><span class="s0">,</span>
        <span class="s1">limit_area: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">fill_value: Any | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">coerce: bool = </span><span class="s0">False,</span>
        <span class="s1">downcast: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">) -&gt; list[Block]:</span>

        <span class="s1">inplace = validate_bool_kwarg(inplace</span><span class="s0">, </span><span class="s3">&quot;inplace&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">self._can_hold_na:</span>
            <span class="s2"># If there are no NAs, then interpolate is a no-op</span>
            <span class="s0">return </span><span class="s1">[self] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">[self.copy()]</span>

        <span class="s0">if </span><span class="s1">self.is_object </span><span class="s0">and </span><span class="s1">self.ndim == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># split improves performance in ndarray.copy()</span>
            <span class="s0">return </span><span class="s1">self.split_and_operate(</span>
                <span class="s1">type(self).interpolate</span><span class="s0">,</span>
                <span class="s1">method</span><span class="s0">,</span>
                <span class="s1">axis</span><span class="s0">,</span>
                <span class="s1">index</span><span class="s0">,</span>
                <span class="s1">inplace</span><span class="s0">,</span>
                <span class="s1">limit</span><span class="s0">,</span>
                <span class="s1">limit_direction</span><span class="s0">,</span>
                <span class="s1">limit_area</span><span class="s0">,</span>
                <span class="s1">fill_value</span><span class="s0">,</span>
                <span class="s1">coerce</span><span class="s0">,</span>
                <span class="s1">downcast</span><span class="s0">,</span>
                <span class="s1">**kwargs</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">m = missing.clean_fill_method(method)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s1">m = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">m </span><span class="s0">is None and </span><span class="s1">self.dtype.kind != </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s2"># only deal with floats</span>
            <span class="s2"># bc we already checked that can_hold_na, we dont have int dtype here</span>
            <span class="s2"># TODO: make a copy if not inplace?</span>
            <span class="s0">return </span><span class="s1">[self]</span>

        <span class="s1">data = self.values </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self.values.copy()</span>
        <span class="s1">data = cast(np.ndarray</span><span class="s0">, </span><span class="s1">data)  </span><span class="s2"># bc overridden by ExtensionBlock</span>

        <span class="s1">missing.interpolate_array_2d(</span>
            <span class="s1">data</span><span class="s0">,</span>
            <span class="s1">method=method</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
            <span class="s1">index=index</span><span class="s0">,</span>
            <span class="s1">limit=limit</span><span class="s0">,</span>
            <span class="s1">limit_direction=limit_direction</span><span class="s0">,</span>
            <span class="s1">limit_area=limit_area</span><span class="s0">,</span>
            <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">nb = self.make_block_same_class(data)</span>
        <span class="s0">return </span><span class="s1">nb._maybe_downcast([nb]</span><span class="s0">, </span><span class="s1">downcast)</span>

    <span class="s0">def </span><span class="s1">take_nd(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">indexer</span><span class="s0">,</span>
        <span class="s1">axis: int</span><span class="s0">,</span>
        <span class="s1">new_mgr_locs: BlockPlacement | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">fill_value=lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        Take values according to indexer and return them as a block.bb 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># algos.take_nd dispatches for DatetimeTZBlock, CategoricalBlock</span>
        <span class="s2"># so need to preserve types</span>
        <span class="s2"># sparse is treated like an ndarray, but needs .get_values() shaping</span>

        <span class="s1">values = self.values</span>

        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">fill_value = self.fill_value</span>
            <span class="s1">allow_fill = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">allow_fill = </span><span class="s0">True</span>

        <span class="s1">new_values = algos.take_nd(</span>
            <span class="s1">values</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">allow_fill=allow_fill</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span>
        <span class="s1">)</span>

        <span class="s2"># Called from three places in managers, all of which satisfy</span>
        <span class="s2">#  this assertion</span>
        <span class="s0">assert not </span><span class="s1">(axis == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new_mgr_locs = self._mgr_locs</span>

        <span class="s0">if not </span><span class="s1">is_dtype_equal(new_values.dtype</span><span class="s0">, </span><span class="s1">self.dtype):</span>
            <span class="s0">return </span><span class="s1">self.make_block(new_values</span><span class="s0">, </span><span class="s1">new_mgr_locs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.make_block_same_class(new_values</span><span class="s0">, </span><span class="s1">new_mgr_locs)</span>

    <span class="s0">def </span><span class="s1">diff(self</span><span class="s0">, </span><span class="s1">n: int</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">1</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot;return block for the diff of the values&quot;&quot;&quot;</span>
        <span class="s1">new_values = algos.diff(self.values</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">[self.make_block(values=new_values)]</span>

    <span class="s0">def </span><span class="s1">shift(self</span><span class="s0">, </span><span class="s1">periods: int</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">fill_value: Any = </span><span class="s0">None</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot;shift the block by periods, possibly upcast&quot;&quot;&quot;</span>
        <span class="s2"># convert integer to float if necessary. need to do a lot more than</span>
        <span class="s2"># that, handle boolean etc also</span>

        <span class="s1">values = cast(np.ndarray</span><span class="s0">, </span><span class="s1">self.values)</span>

        <span class="s1">new_values</span><span class="s0">, </span><span class="s1">fill_value = maybe_upcast(values</span><span class="s0">, </span><span class="s1">fill_value)</span>

        <span class="s1">new_values = shift(new_values</span><span class="s0">, </span><span class="s1">periods</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">fill_value)</span>

        <span class="s0">return </span><span class="s1">[self.make_block(new_values)]</span>

    <span class="s0">def </span><span class="s1">where(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">cond) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        evaluate the block; return result block(s) from the result 
 
        Parameters 
        ---------- 
        other : a ndarray/object 
        cond : np.ndarray[bool], SparseArray[bool], or BooleanArray 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">cond.ndim == self.ndim</span>
        <span class="s0">assert not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(ABCIndex</span><span class="s0">, </span><span class="s1">ABCSeries</span><span class="s0">, </span><span class="s1">ABCDataFrame))</span>

        <span class="s1">transpose = self.ndim == </span><span class="s5">2</span>

        <span class="s2"># EABlocks override where</span>
        <span class="s1">values = cast(np.ndarray</span><span class="s0">, </span><span class="s1">self.values)</span>
        <span class="s1">orig_other = other</span>
        <span class="s0">if </span><span class="s1">transpose:</span>
            <span class="s1">values = values.T</span>

        <span class="s1">icond</span><span class="s0">, </span><span class="s1">noop = validate_putmask(values</span><span class="s0">, </span><span class="s1">~cond)</span>
        <span class="s0">if </span><span class="s1">noop:</span>
            <span class="s2"># GH-39595: Always return a copy; short-circuit up/downcasting</span>
            <span class="s0">return </span><span class="s1">self.copy()</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">other = self.fill_value</span>

        <span class="s0">if </span><span class="s1">is_valid_na_for_dtype(other</span><span class="s0">, </span><span class="s1">self.dtype) </span><span class="s0">and </span><span class="s1">self.dtype != _dtype_obj:</span>
            <span class="s1">other = self.fill_value</span>

        <span class="s0">if not </span><span class="s1">self._can_hold_element(other):</span>
            <span class="s2"># we cannot coerce, return a compat dtype</span>
            <span class="s1">block = self.coerce_to_target_dtype(other)</span>
            <span class="s1">blocks = block.where(orig_other</span><span class="s0">, </span><span class="s1">cond)</span>
            <span class="s0">return </span><span class="s1">self._maybe_downcast(blocks</span><span class="s0">, </span><span class="s3">&quot;infer&quot;</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">alt = setitem_datetimelike_compat(values</span><span class="s0">, </span><span class="s1">icond.sum()</span><span class="s0">, </span><span class="s1">other)</span>
            <span class="s0">if </span><span class="s1">alt </span><span class="s0">is not </span><span class="s1">other:</span>
                <span class="s0">if </span><span class="s1">is_list_like(other) </span><span class="s0">and </span><span class="s1">len(other) &lt; len(values):</span>
                    <span class="s2"># call np.where with other to get the appropriate ValueError</span>
                    <span class="s1">np.where(~icond</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">other)</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                        <span class="s3">&quot;This should not be reached; call to np.where above is &quot;</span>
                        <span class="s3">&quot;expected to raise ValueError. Please report a bug at &quot;</span>
                        <span class="s3">&quot;github.com/pandas-dev/pandas&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">result = values.copy()</span>
                <span class="s1">np.putmask(result</span><span class="s0">, </span><span class="s1">icond</span><span class="s0">, </span><span class="s1">alt)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># By the time we get here, we should have all Series/Index</span>
                <span class="s2">#  args extracted to ndarray</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">is_list_like(other)</span>
                    <span class="s0">and not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
                    <span class="s0">and </span><span class="s1">len(other) == self.shape[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">):</span>
                    <span class="s2"># If we don't do this broadcasting here, then expressions.where</span>
                    <span class="s2">#  will broadcast a 1D other to be row-like instead of</span>
                    <span class="s2">#  column-like.</span>
                    <span class="s1">other = np.array(other).reshape(values.shape)</span>
                    <span class="s2"># If lengths don't match (or len(other)==1), we will raise</span>
                    <span class="s2">#  inside expressions.where, see test_series_where</span>

                <span class="s2"># Note: expressions.where may upcast.</span>
                <span class="s1">result = expressions.where(~icond</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s0">if </span><span class="s1">self._can_hold_na </span><span class="s0">or </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>

            <span class="s0">if </span><span class="s1">transpose:</span>
                <span class="s1">result = result.T</span>

            <span class="s0">return </span><span class="s1">[self.make_block(result)]</span>

        <span class="s2"># might need to separate out blocks</span>
        <span class="s1">cond = ~icond</span>
        <span class="s1">axis = cond.ndim - </span><span class="s5">1</span>
        <span class="s1">cond = cond.swapaxes(axis</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">mask = cond.all(axis=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">result_blocks: list[Block] = []</span>
        <span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">[mask</span><span class="s0">, </span><span class="s1">~mask]:</span>
            <span class="s0">if </span><span class="s1">m.any():</span>
                <span class="s1">taken = result.take(m.nonzero()[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
                <span class="s1">r = maybe_downcast_numeric(taken</span><span class="s0">, </span><span class="s1">self.dtype)</span>
                <span class="s0">if </span><span class="s1">r.dtype != taken.dtype:</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s3">&quot;Downcasting integer-dtype results in .where is &quot;</span>
                        <span class="s3">&quot;deprecated and will change in a future version. &quot;</span>
                        <span class="s3">&quot;To retain the old behavior, explicitly cast the results &quot;</span>
                        <span class="s3">&quot;to the desired dtype.&quot;</span><span class="s0">,</span>
                        <span class="s1">FutureWarning</span><span class="s0">,</span>
                        <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">nb = self.make_block(r.T</span><span class="s0">, </span><span class="s1">placement=self._mgr_locs[m])</span>
                <span class="s1">result_blocks.append(nb)</span>

        <span class="s0">return </span><span class="s1">result_blocks</span>

    <span class="s0">def </span><span class="s1">_unstack(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">unstacker</span><span class="s0">,</span>
        <span class="s1">fill_value</span><span class="s0">,</span>
        <span class="s1">new_placement: npt.NDArray[np.intp]</span><span class="s0">,</span>
        <span class="s1">needs_masking: npt.NDArray[np.bool_]</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a list of unstacked blocks of self 
 
        Parameters 
        ---------- 
        unstacker : reshape._Unstacker 
        fill_value : int 
            Only used in ExtensionBlock._unstack 
        new_placement : np.ndarray[np.intp] 
        allow_fill : bool 
        needs_masking : np.ndarray[bool] 
 
        Returns 
        ------- 
        blocks : list of Block 
            New blocks of unstacked values. 
        mask : array-like of bool 
            The mask of columns of `blocks` we should keep. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values</span><span class="s0">, </span><span class="s1">mask = unstacker.get_new_values(</span>
            <span class="s1">self.values.T</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span>
        <span class="s1">)</span>

        <span class="s1">mask = mask.any(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2"># TODO: in all tests we have mask.all(); can we rely on that?</span>

        <span class="s2"># Note: these next two lines ensure that</span>
        <span class="s2">#  mask.sum() == sum(len(nb.mgr_locs) for nb in blocks)</span>
        <span class="s2">#  which the calling function needs in order to pass verify_integrity=False</span>
        <span class="s2">#  to the BlockManager constructor</span>
        <span class="s1">new_values = new_values.T[mask]</span>
        <span class="s1">new_placement = new_placement[mask]</span>

        <span class="s1">bp = BlockPlacement(new_placement)</span>
        <span class="s1">blocks = [new_block_2d(new_values</span><span class="s0">, </span><span class="s1">placement=bp)]</span>
        <span class="s0">return </span><span class="s1">blocks</span><span class="s0">, </span><span class="s1">mask</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">quantile(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">qs: Float64Index</span><span class="s0">, </span><span class="s1">interpolation=</span><span class="s3">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span>
    <span class="s1">) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        compute the quantiles of the 
 
        Parameters 
        ---------- 
        qs : Float64Index 
            List of the quantiles to be computed. 
        interpolation : str, default 'linear' 
            Type of interpolation. 
        axis : int, default 0 
            Axis to compute. 
 
        Returns 
        ------- 
        Block 
        &quot;&quot;&quot;</span>
        <span class="s2"># We should always have ndim == 2 because Series dispatches to DataFrame</span>
        <span class="s0">assert </span><span class="s1">self.ndim == </span><span class="s5">2</span>
        <span class="s0">assert </span><span class="s1">axis == </span><span class="s5">1  </span><span class="s2"># only ever called this way</span>
        <span class="s0">assert </span><span class="s1">is_list_like(qs)  </span><span class="s2"># caller is responsible for this</span>

        <span class="s1">result = quantile_compat(self.values</span><span class="s0">, </span><span class="s1">np.asarray(qs._values)</span><span class="s0">, </span><span class="s1">interpolation)</span>
        <span class="s2"># ensure_block_shape needed for cases where we start with EA and result</span>
        <span class="s2">#  is ndarray, e.g. IntegerArray, SparseArray</span>
        <span class="s1">result = ensure_block_shape(result</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">new_block_2d(result</span><span class="s0">, </span><span class="s1">placement=self._mgr_locs)</span>


<span class="s0">class </span><span class="s1">EABackedBlock(Block):</span>
    <span class="s4">&quot;&quot;&quot; 
    Mixin for Block subclasses backed by ExtensionArray. 
    &quot;&quot;&quot;</span>

    <span class="s1">values: ExtensionArray</span>

    <span class="s0">def </span><span class="s1">where(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">cond) -&gt; list[Block]:</span>
        <span class="s1">arr = self.values.T</span>

        <span class="s1">cond = extract_bool_array(cond)</span>

        <span class="s1">other = self._maybe_squeeze_arg(other)</span>
        <span class="s1">cond = self._maybe_squeeze_arg(cond)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">other = self.fill_value</span>

        <span class="s1">icond</span><span class="s0">, </span><span class="s1">noop = validate_putmask(arr</span><span class="s0">, </span><span class="s1">~cond)</span>
        <span class="s0">if </span><span class="s1">noop:</span>
            <span class="s2"># GH#44181, GH#45135</span>
            <span class="s2"># Avoid a) raising for Interval/PeriodDtype and b) unnecessary object upcast</span>
            <span class="s0">return </span><span class="s1">self.copy()</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">res_values = arr._where(cond</span><span class="s0">, </span><span class="s1">other).T</span>
        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s1">_catch_deprecated_value_error(err)</span>

            <span class="s0">if </span><span class="s1">is_interval_dtype(self.dtype):</span>
                <span class="s2"># TestSetitemFloatIntervalWithIntIntervalValues</span>
                <span class="s1">blk = self.coerce_to_target_dtype(other)</span>
                <span class="s0">if </span><span class="s1">blk.dtype == _dtype_obj:</span>
                    <span class="s2"># For now at least only support casting e.g.</span>
                    <span class="s2">#  Interval[int64]-&gt;Interval[float64]</span>
                    <span class="s0">raise</span>
                <span class="s0">return </span><span class="s1">blk.where(other</span><span class="s0">, </span><span class="s1">cond)</span>

            <span class="s0">elif </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">NDArrayBackedExtensionBlock):</span>
                <span class="s2"># NB: not (yet) the same as</span>
                <span class="s2">#  isinstance(values, NDArrayBackedExtensionArray)</span>
                <span class="s0">if </span><span class="s1">isinstance(self.dtype</span><span class="s0">, </span><span class="s1">PeriodDtype):</span>
                    <span class="s2"># TODO: don't special-case</span>
                    <span class="s2"># Note: this is the main place where the fallback logic</span>
                    <span class="s2">#  is different from EABackedBlock.putmask.</span>
                    <span class="s0">raise</span>
                <span class="s1">blk = self.coerce_to_target_dtype(other)</span>
                <span class="s1">nbs = blk.where(other</span><span class="s0">, </span><span class="s1">cond)</span>
                <span class="s0">return </span><span class="s1">self._maybe_downcast(nbs</span><span class="s0">, </span><span class="s3">&quot;infer&quot;</span><span class="s1">)</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise</span>

        <span class="s1">nb = self.make_block_same_class(res_values)</span>
        <span class="s0">return </span><span class="s1">[nb]</span>

    <span class="s0">def </span><span class="s1">putmask(self</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">new) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        See Block.putmask.__doc__ 
        &quot;&quot;&quot;</span>
        <span class="s1">mask = extract_bool_array(mask)</span>

        <span class="s1">values = self.values</span>

        <span class="s1">mask = self._maybe_squeeze_arg(mask)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Caller is responsible for ensuring matching lengths</span>
            <span class="s1">values._putmask(mask</span><span class="s0">, </span><span class="s1">new)</span>
        <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError) </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s1">_catch_deprecated_value_error(err)</span>

            <span class="s0">if </span><span class="s1">is_interval_dtype(self.dtype):</span>
                <span class="s2"># Discussion about what we want to support in the general</span>
                <span class="s2">#  case GH#39584</span>
                <span class="s1">blk = self.coerce_to_target_dtype(new)</span>
                <span class="s0">if </span><span class="s1">blk.dtype == _dtype_obj:</span>
                    <span class="s2"># For now at least, only support casting e.g.</span>
                    <span class="s2">#  Interval[int64]-&gt;Interval[float64],</span>
                    <span class="s0">raise</span>
                <span class="s0">return </span><span class="s1">blk.putmask(mask</span><span class="s0">, </span><span class="s1">new)</span>

            <span class="s0">elif </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">NDArrayBackedExtensionBlock):</span>
                <span class="s2"># NB: not (yet) the same as</span>
                <span class="s2">#  isinstance(values, NDArrayBackedExtensionArray)</span>
                <span class="s1">blk = self.coerce_to_target_dtype(new)</span>
                <span class="s0">return </span><span class="s1">blk.putmask(mask</span><span class="s0">, </span><span class="s1">new)</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise</span>

        <span class="s0">return </span><span class="s1">[self]</span>

    <span class="s0">def </span><span class="s1">delete(self</span><span class="s0">, </span><span class="s1">loc) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Delete given loc(-s) from block in-place. 
        &quot;&quot;&quot;</span>
        <span class="s2"># This will be unnecessary if/when __array_function__ is implemented</span>
        <span class="s1">self.values = self.values.delete(loc)</span>
        <span class="s1">self.mgr_locs = self._mgr_locs.delete(loc)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._cache.clear()</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># _cache not yet initialized</span>
            <span class="s0">pass</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">array_values(self) -&gt; ExtensionArray:</span>
        <span class="s0">return </span><span class="s1">self.values</span>

    <span class="s0">def </span><span class="s1">get_values(self</span><span class="s0">, </span><span class="s1">dtype: DtypeObj | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; np.ndarray:</span>
        <span class="s4">&quot;&quot;&quot; 
        return object dtype as boxed values, such as Timestamps/Timedelta 
        &quot;&quot;&quot;</span>
        <span class="s1">values: ArrayLike = self.values</span>
        <span class="s0">if </span><span class="s1">dtype == _dtype_obj:</span>
            <span class="s1">values = values.astype(object)</span>
        <span class="s2"># TODO(EA2D): reshape not needed with 2D EAs</span>
        <span class="s0">return </span><span class="s1">np.asarray(values).reshape(self.shape)</span>

    <span class="s0">def </span><span class="s1">values_for_json(self) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">np.asarray(self.values)</span>

    <span class="s0">def </span><span class="s1">interpolate(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">&quot;pad&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">False, </span><span class="s1">limit=</span><span class="s0">None, </span><span class="s1">fill_value=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">values = self.values</span>
        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># NDArrayBackedExtensionArray.fillna assumes axis=1</span>
            <span class="s1">new_values = values.T.fillna(value=fill_value</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">, </span><span class="s1">limit=limit).T</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_values = values.fillna(value=fill_value</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">, </span><span class="s1">limit=limit)</span>
        <span class="s0">return </span><span class="s1">self.make_block_same_class(new_values)</span>


<span class="s0">class </span><span class="s1">ExtensionBlock(libinternals.Block</span><span class="s0">, </span><span class="s1">EABackedBlock):</span>
    <span class="s4">&quot;&quot;&quot; 
    Block for holding extension types. 
 
    Notes 
    ----- 
    This holds all 3rd-party extension array types. It's also the immediate 
    parent class for our internal extension types' blocks, CategoricalBlock. 
 
    ExtensionArrays are limited to 1-D. 
    &quot;&quot;&quot;</span>

    <span class="s1">_can_consolidate = </span><span class="s0">False</span>
    <span class="s1">_validate_ndim = </span><span class="s0">False</span>
    <span class="s1">is_extension = </span><span class="s0">True</span>

    <span class="s1">values: ExtensionArray</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">shape(self) -&gt; Shape:</span>
        <span class="s2"># TODO(EA2D): override unnecessary with 2D EAs</span>
        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(len(self.values)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">len(self._mgr_locs)</span><span class="s0">, </span><span class="s1">len(self.values)</span>

    <span class="s0">def </span><span class="s1">iget(self</span><span class="s0">, </span><span class="s1">i: int | tuple[int</span><span class="s0">, </span><span class="s1">int] | tuple[slice</span><span class="s0">, </span><span class="s1">int]):</span>
        <span class="s2"># In the case where we have a tuple[slice, int], the slice will always</span>
        <span class="s2">#  be slice(None)</span>
        <span class="s2"># We _could_ make the annotation more specific, but mypy would</span>
        <span class="s2">#  complain about override mismatch:</span>
        <span class="s2">#  Literal[0] | tuple[Literal[0], int] | tuple[slice, int]</span>

        <span class="s2"># Note: only reached with self.ndim == 2</span>

        <span class="s0">if </span><span class="s1">isinstance(i</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s2"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s1">col</span><span class="s0">, </span><span class="s1">loc = i</span>
            <span class="s0">if not </span><span class="s1">com.is_null_slice(col) </span><span class="s0">and </span><span class="s1">col != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">only contains one item&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s0">if </span><span class="s1">col != slice(</span><span class="s0">None</span><span class="s1">):</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError(col)</span>
                <span class="s0">return </span><span class="s1">self.values[[loc]]</span>
            <span class="s0">return </span><span class="s1">self.values[loc]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">i != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">only contains one item&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self.values</span>

    <span class="s0">def </span><span class="s1">set_inplace(self</span><span class="s0">, </span><span class="s1">locs</span><span class="s0">, </span><span class="s1">values) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2"># NB: This is a misnomer, is supposed to be inplace but is not,</span>
        <span class="s2">#  see GH#33457</span>
        <span class="s2"># When an ndarray, we should have locs.tolist() == [0]</span>
        <span class="s2"># When a BlockPlacement we should have list(locs) == [0]</span>
        <span class="s1">self.values = values</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># TODO(GH33457) this can be removed</span>
            <span class="s1">self._cache.clear()</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># _cache not yet initialized</span>
            <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_maybe_squeeze_arg(self</span><span class="s0">, </span><span class="s1">arg):</span>
        <span class="s4">&quot;&quot;&quot; 
        If necessary, squeeze a (N, 1) ndarray to (N,) 
        &quot;&quot;&quot;</span>
        <span class="s2"># e.g. if we are passed a 2D mask for putmask</span>
        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">arg.ndim == self.values.ndim + </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s0">assert </span><span class="s1">arg.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span>
            <span class="s1">arg = arg[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">arg</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_view(self) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot;Extension arrays are never treated as views.&quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_numeric(self):</span>
        <span class="s0">return </span><span class="s1">self.values.dtype._is_numeric</span>

    <span class="s0">def </span><span class="s1">setitem(self</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s4">&quot;&quot;&quot; 
        Attempt self.values[indexer] = value, possibly creating a new array. 
 
        This differs from Block.setitem by not allowing setitem to change 
        the dtype of the Block. 
 
        Parameters 
        ---------- 
        indexer : tuple, list-like, array-like, slice, int 
            The subset of self.values to set 
        value : object 
            The value being set 
 
        Returns 
        ------- 
        Block 
 
        Notes 
        ----- 
        `indexer` is a direct slice/positional indexer. `value` must 
        be a compatible shape. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self._can_hold_element(value):</span>
            <span class="s2"># see TestSetitemFloatIntervalWithIntIntervalValues</span>
            <span class="s0">return </span><span class="s1">self.coerce_to_target_dtype(value).setitem(indexer</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s0">if </span><span class="s1">isinstance(indexer</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s2"># TODO(EA2D): not needed with 2D EAs</span>
            <span class="s2"># we are always 1-D</span>
            <span class="s1">indexer = indexer[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">isinstance(indexer</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">indexer.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2"># GH#44703</span>
                <span class="s0">if </span><span class="s1">indexer.shape[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                        <span class="s3">&quot;This should not be reached. Please report a bug at &quot;</span>
                        <span class="s3">&quot;github.com/pandas-dev/pandas/&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">indexer = indexer[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2"># TODO(EA2D): not needed with 2D EAS</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(np.ndarray</span><span class="s0">, </span><span class="s1">ExtensionArray)) </span><span class="s0">and </span><span class="s1">value.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">value.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span>
            <span class="s2"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot;</span>
            <span class="s2"># matches argument type &quot;Tuple[slice, int]&quot;</span>
            <span class="s1">value = value[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s2"># type: ignore[call-overload]</span>
        <span class="s0">elif </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">ABCDataFrame):</span>
            <span class="s2"># TODO: should we avoid getting here with DataFrame?</span>
            <span class="s0">assert </span><span class="s1">value.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span>
            <span class="s1">value = value._ixs(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)._values</span>

        <span class="s1">check_setitem_lengths(indexer</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">self.values)</span>
        <span class="s1">self.values[indexer] = value</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">take_nd(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">indexer</span><span class="s0">,</span>
        <span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">new_mgr_locs: BlockPlacement | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">fill_value=lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; Block:</span>
        <span class="s4">&quot;&quot;&quot; 
        Take values according to indexer and return them as a block. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">fill_value = </span><span class="s0">None</span>

        <span class="s2"># TODO(EA2D): special case not needed with 2D EAs</span>
        <span class="s2"># axis doesn't matter; we are really a single-dim object</span>
        <span class="s2"># but are passed the axis depending on the calling routing</span>
        <span class="s2"># if its REALLY axis 0, then this will be a reindex and not a take</span>
        <span class="s1">new_values = self.values.take(indexer</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">allow_fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s2"># Called from three places in managers, all of which satisfy</span>
        <span class="s2">#  this assertion</span>
        <span class="s0">assert not </span><span class="s1">(self.ndim == </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new_mgr_locs = self._mgr_locs</span>

        <span class="s0">return </span><span class="s1">self.make_block_same_class(new_values</span><span class="s0">, </span><span class="s1">new_mgr_locs)</span>

    <span class="s0">def </span><span class="s1">_slice(self</span><span class="s0">, </span><span class="s1">slicer) -&gt; ExtensionArray:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a slice of my values. 
 
        Parameters 
        ---------- 
        slicer : slice, ndarray[int], or a tuple of these 
            Valid (non-reducing) indexer for self.values. 
 
        Returns 
        ------- 
        ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s2"># return same dims as we currently have</span>
        <span class="s0">if not </span><span class="s1">isinstance(slicer</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2"># reached via getitem_block via _slice_take_blocks_ax0</span>
            <span class="s2"># TODO(EA2D): won't be necessary with 2D EAs</span>
            <span class="s1">slicer = (slicer</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span>

        <span class="s0">if </span><span class="s1">isinstance(slicer</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">len(slicer) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">first = slicer[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">isinstance(first</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s3">&quot;invalid slicing for a 1-ndim ExtensionArray&quot;</span><span class="s0">, </span><span class="s1">first</span>
                <span class="s1">)</span>
            <span class="s2"># GH#32959 only full-slicers along fake-dim0 are valid</span>
            <span class="s2"># TODO(EA2D): won't be necessary with 2D EAs</span>
            <span class="s2"># range(1) instead of self._mgr_locs to avoid exception on [::-1]</span>
            <span class="s2">#  see test_iloc_getitem_slice_negative_step_ea_block</span>
            <span class="s1">new_locs = range(</span><span class="s5">1</span><span class="s1">)[first]</span>
            <span class="s0">if </span><span class="s1">len(new_locs):</span>
                <span class="s2"># effectively slice(None)</span>
                <span class="s1">slicer = slicer[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s3">&quot;invalid slicing for a 1-ndim ExtensionArray&quot;</span><span class="s0">, </span><span class="s1">slicer</span>
                <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self.values[slicer]</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">getitem_block_index(self</span><span class="s0">, </span><span class="s1">slicer: slice) -&gt; ExtensionBlock:</span>
        <span class="s4">&quot;&quot;&quot; 
        Perform __getitem__-like specialized to slicing along index. 
        &quot;&quot;&quot;</span>
        <span class="s2"># GH#42787 in principle this is equivalent to values[..., slicer], but we don't</span>
        <span class="s2"># require subclasses of ExtensionArray to support that form (for now).</span>
        <span class="s1">new_values = self.values[slicer]</span>
        <span class="s0">return </span><span class="s1">type(self)(new_values</span><span class="s0">, </span><span class="s1">self._mgr_locs</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

    <span class="s0">def </span><span class="s1">fillna(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">limit=</span><span class="s0">None, </span><span class="s1">inplace: bool = </span><span class="s0">False, </span><span class="s1">downcast=</span><span class="s0">None</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s1">values = self.values.fillna(value=value</span><span class="s0">, </span><span class="s1">limit=limit)</span>
        <span class="s0">return </span><span class="s1">[self.make_block_same_class(values=values)]</span>

    <span class="s0">def </span><span class="s1">diff(self</span><span class="s0">, </span><span class="s1">n: int</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">1</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s0">if </span><span class="s1">axis == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">n != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># n==0 case will be a no-op so let is fall through</span>
            <span class="s2"># Since we only have one column, the result will be all-NA.</span>
            <span class="s2">#  Create this result by shifting along axis=0 past the length of</span>
            <span class="s2">#  our values.</span>
            <span class="s0">return </span><span class="s1">super().diff(len(self.values)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">axis == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s2"># we are by definition 1D.</span>
            <span class="s1">axis = </span><span class="s5">0</span>
        <span class="s0">return </span><span class="s1">super().diff(n</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s0">def </span><span class="s1">shift(self</span><span class="s0">, </span><span class="s1">periods: int</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">fill_value: Any = </span><span class="s0">None</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Shift the block by `periods`. 
 
        Dispatches to underlying ExtensionArray and re-boxes in an 
        ExtensionBlock. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values = self.values.shift(periods=periods</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s0">return </span><span class="s1">[self.make_block_same_class(new_values)]</span>

    <span class="s0">def </span><span class="s1">_unstack(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">unstacker</span><span class="s0">,</span>
        <span class="s1">fill_value</span><span class="s0">,</span>
        <span class="s1">new_placement: npt.NDArray[np.intp]</span><span class="s0">,</span>
        <span class="s1">needs_masking: npt.NDArray[np.bool_]</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s2"># ExtensionArray-safe unstack.</span>
        <span class="s2"># We override ObjectBlock._unstack, which unstacks directly on the</span>
        <span class="s2"># values of the array. For EA-backed blocks, this would require</span>
        <span class="s2"># converting to a 2-D ndarray of objects.</span>
        <span class="s2"># Instead, we unstack an ndarray of integer positions, followed by</span>
        <span class="s2"># a `take` on the actual values.</span>

        <span class="s2"># Caller is responsible for ensuring self.shape[-1] == len(unstacker.index)</span>
        <span class="s1">new_values</span><span class="s0">, </span><span class="s1">mask = unstacker.arange_result</span>

        <span class="s2"># Note: these next two lines ensure that</span>
        <span class="s2">#  mask.sum() == sum(len(nb.mgr_locs) for nb in blocks)</span>
        <span class="s2">#  which the calling function needs in order to pass verify_integrity=False</span>
        <span class="s2">#  to the BlockManager constructor</span>
        <span class="s1">new_values = new_values.T[mask]</span>
        <span class="s1">new_placement = new_placement[mask]</span>

        <span class="s2"># needs_masking[i] calculated once in BlockManager.unstack tells</span>
        <span class="s2">#  us if there are any -1s in the relevant indices.  When False,</span>
        <span class="s2">#  that allows us to go through a faster path in 'take', among</span>
        <span class="s2">#  other things avoiding e.g. Categorical._validate_scalar.</span>
        <span class="s1">blocks = [</span>
            <span class="s2"># TODO: could cast to object depending on fill_value?</span>
            <span class="s1">type(self)(</span>
                <span class="s1">self.values.take(</span>
                    <span class="s1">indices</span><span class="s0">, </span><span class="s1">allow_fill=needs_masking[i]</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">BlockPlacement(place)</span><span class="s0">,</span>
                <span class="s1">ndim=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(indices</span><span class="s0">, </span><span class="s1">place) </span><span class="s0">in </span><span class="s1">enumerate(zip(new_values</span><span class="s0">, </span><span class="s1">new_placement))</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">blocks</span><span class="s0">, </span><span class="s1">mask</span>


<span class="s0">class </span><span class="s1">NumpyBlock(libinternals.NumpyBlock</span><span class="s0">, </span><span class="s1">Block):</span>
    <span class="s1">values: np.ndarray</span>


<span class="s0">class </span><span class="s1">NumericBlock(NumpyBlock):</span>
    <span class="s1">__slots__ = ()</span>
    <span class="s1">is_numeric = </span><span class="s0">True</span>


<span class="s0">class </span><span class="s1">NDArrayBackedExtensionBlock(libinternals.NDArrayBackedBlock</span><span class="s0">, </span><span class="s1">EABackedBlock):</span>
    <span class="s4">&quot;&quot;&quot; 
    Block backed by an NDArrayBackedExtensionArray 
    &quot;&quot;&quot;</span>

    <span class="s1">values: NDArrayBackedExtensionArray</span>

    <span class="s2"># error: Signature of &quot;is_extension&quot; incompatible with supertype &quot;Block&quot;</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_extension(self) -&gt; bool:  </span><span class="s2"># type: ignore[override]</span>
        <span class="s2"># i.e. datetime64tz, PeriodDtype</span>
        <span class="s0">return not </span><span class="s1">isinstance(self.dtype</span><span class="s0">, </span><span class="s1">np.dtype)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_view(self) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot;return a boolean if I am possibly a view&quot;&quot;&quot;</span>
        <span class="s2"># check the ndarray values of the DatetimeIndex values</span>
        <span class="s0">return </span><span class="s1">self.values._ndarray.base </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">setitem(self</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if not </span><span class="s1">self._can_hold_element(value):</span>
            <span class="s0">return </span><span class="s1">self.coerce_to_target_dtype(value).setitem(indexer</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s1">values = self.values</span>
        <span class="s0">if </span><span class="s1">self.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># Dont transpose with ndim=1 bc we would fail to invalidate</span>
            <span class="s2">#  arr.freq</span>
            <span class="s1">values = values.T</span>
        <span class="s1">values[indexer] = value</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">diff(self</span><span class="s0">, </span><span class="s1">n: int</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        1st discrete difference. 
 
        Parameters 
        ---------- 
        n : int 
            Number of periods to diff. 
        axis : int, default 0 
            Axis to diff upon. 
 
        Returns 
        ------- 
        A list with a new Block. 
 
        Notes 
        ----- 
        The arguments here are mimicking shift so they are called correctly 
        by apply. 
        &quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>

        <span class="s1">new_values = values - values.shift(n</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">[self.make_block(new_values)]</span>

    <span class="s0">def </span><span class="s1">shift(self</span><span class="s0">, </span><span class="s1">periods: int</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">fill_value: Any = </span><span class="s0">None</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s1">values = self.values</span>
        <span class="s1">new_values = values.shift(periods</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">[self.make_block_same_class(new_values)]</span>

    <span class="s0">def </span><span class="s1">fillna(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">limit=</span><span class="s0">None, </span><span class="s1">inplace: bool = </span><span class="s0">False, </span><span class="s1">downcast=</span><span class="s0">None</span>
    <span class="s1">) -&gt; list[Block]:</span>

        <span class="s0">if not </span><span class="s1">self._can_hold_element(value) </span><span class="s0">and </span><span class="s1">self.dtype.kind != </span><span class="s3">&quot;m&quot;</span><span class="s1">:</span>
            <span class="s2"># We support filling a DatetimeTZ with a `value` whose timezone</span>
            <span class="s2">#  is different by coercing to object.</span>
            <span class="s2"># TODO: don't special-case td64</span>
            <span class="s0">return </span><span class="s1">self.coerce_to_target_dtype(value).fillna(</span>
                <span class="s1">value</span><span class="s0">, </span><span class="s1">limit</span><span class="s0">, </span><span class="s1">inplace</span><span class="s0">, </span><span class="s1">downcast</span>
            <span class="s1">)</span>

        <span class="s1">new_values = self.values.fillna(value=value</span><span class="s0">, </span><span class="s1">limit=limit)</span>
        <span class="s0">return </span><span class="s1">[self.make_block_same_class(values=new_values)]</span>


<span class="s0">def </span><span class="s1">_catch_deprecated_value_error(err: Exception) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot; 
    We catch ValueError for now, but only a specific one raised by DatetimeArray 
    which will no longer be raised in version.2.0. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(err</span><span class="s0">, </span><span class="s1">ValueError):</span>
        <span class="s2"># TODO(2.0): once DTA._validate_setitem_value deprecation</span>
        <span class="s2">#  is enforced, stop catching ValueError here altogether</span>
        <span class="s0">if </span><span class="s3">&quot;Timezones don't match&quot; </span><span class="s0">not in </span><span class="s1">str(err):</span>
            <span class="s0">raise</span>


<span class="s0">class </span><span class="s1">DatetimeLikeBlock(NDArrayBackedExtensionBlock):</span>
    <span class="s4">&quot;&quot;&quot;Block for datetime64[ns], timedelta64[ns].&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">is_numeric = </span><span class="s0">False</span>
    <span class="s1">values: DatetimeArray | TimedeltaArray</span>

    <span class="s0">def </span><span class="s1">values_for_json(self) -&gt; np.ndarray:</span>
        <span class="s2"># special casing datetimetz to avoid conversion through</span>
        <span class="s2">#  object dtype</span>
        <span class="s0">return </span><span class="s1">self.values._ndarray</span>


<span class="s0">class </span><span class="s1">DatetimeTZBlock(DatetimeLikeBlock):</span>
    <span class="s4">&quot;&quot;&quot;implement a datetime64 block with a tz attribute&quot;&quot;&quot;</span>

    <span class="s1">values: DatetimeArray</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">is_extension = </span><span class="s0">True</span>
    <span class="s1">_validate_ndim = </span><span class="s0">True</span>
    <span class="s1">_can_consolidate = </span><span class="s0">False</span>


<span class="s0">class </span><span class="s1">ObjectBlock(NumpyBlock):</span>
    <span class="s1">__slots__ = ()</span>
    <span class="s1">is_object = </span><span class="s0">True</span>

    <span class="s1">@maybe_split</span>
    <span class="s0">def </span><span class="s1">reduce(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">ignore_failures: bool = </span><span class="s0">False</span><span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        For object-dtype, we operate column-wise. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self.ndim == </span><span class="s5">2</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">res = func(self.values)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">if not </span><span class="s1">ignore_failures:</span>
                <span class="s0">raise</span>
            <span class="s0">return </span><span class="s1">[]</span>

        <span class="s0">assert </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s0">assert </span><span class="s1">res.ndim == </span><span class="s5">1</span>
        <span class="s1">res = res.reshape(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">[self.make_block_same_class(res)]</span>

    <span class="s1">@maybe_split</span>
    <span class="s0">def </span><span class="s1">convert(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">copy: bool = </span><span class="s0">True,</span>
        <span class="s1">datetime: bool = </span><span class="s0">True,</span>
        <span class="s1">numeric: bool = </span><span class="s0">True,</span>
        <span class="s1">timedelta: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; list[Block]:</span>
        <span class="s4">&quot;&quot;&quot; 
        attempt to cast any object types to better types return a copy of 
        the block (if copy = True) by definition we ARE an ObjectBlock!!!!! 
        &quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>
        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2"># maybe_split ensures we only get here with values.shape[0] == 1,</span>
            <span class="s2"># avoid doing .ravel as that might make a copy</span>
            <span class="s1">values = values[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">res_values = soft_convert_objects(</span>
            <span class="s1">values</span><span class="s0">,</span>
            <span class="s1">datetime=datetime</span><span class="s0">,</span>
            <span class="s1">numeric=numeric</span><span class="s0">,</span>
            <span class="s1">timedelta=timedelta</span><span class="s0">,</span>
            <span class="s1">copy=copy</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">res_values = ensure_block_shape(res_values</span><span class="s0">, </span><span class="s1">self.ndim)</span>
        <span class="s0">return </span><span class="s1">[self.make_block(res_values)]</span>


<span class="s0">class </span><span class="s1">CategoricalBlock(ExtensionBlock):</span>
    <span class="s2"># this Block type is kept for backwards-compatibility</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s2"># GH#43232, GH#43334 self.values.dtype can be changed inplace until 2.0,</span>
    <span class="s2">#  so this cannot be cached</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; DtypeObj:</span>
        <span class="s0">return </span><span class="s1">self.values.dtype</span>


<span class="s2"># -----------------------------------------------------------------</span>
<span class="s2"># Constructor Helpers</span>


<span class="s0">def </span><span class="s1">maybe_coerce_values(values: ArrayLike) -&gt; ArrayLike:</span>
    <span class="s4">&quot;&quot;&quot; 
    Input validation for values passed to __init__. Ensure that 
    any datetime64/timedelta64 dtypes are in nanoseconds.  Ensure 
    that we do not have string dtypes. 
 
    Parameters 
    ---------- 
    values : np.ndarray or ExtensionArray 
 
    Returns 
    ------- 
    values : np.ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s2"># Caller is responsible for ensuring PandasArray is already extracted.</span>

    <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">values = ensure_wrapped_if_datetimelike(values)</span>

        <span class="s0">if </span><span class="s1">issubclass(values.dtype.type</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">values = np.array(values</span><span class="s0">, </span><span class="s1">dtype=object)</span>

    <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(DatetimeArray</span><span class="s0">, </span><span class="s1">TimedeltaArray)) </span><span class="s0">and </span><span class="s1">values.freq </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s2"># freq is only stored in DatetimeIndex/TimedeltaIndex, not in Series/DataFrame</span>
        <span class="s1">values = values._with_freq(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">get_block_type(dtype: DtypeObj):</span>
    <span class="s4">&quot;&quot;&quot; 
    Find the appropriate Block subclass to use for the given values and dtype. 
 
    Parameters 
    ---------- 
    dtype : numpy or pandas dtype 
 
    Returns 
    ------- 
    cls : class, subclass of Block 
    &quot;&quot;&quot;</span>
    <span class="s2"># We use vtype and kind checks because they are much more performant</span>
    <span class="s2">#  than is_foo_dtype</span>
    <span class="s1">vtype = dtype.type</span>
    <span class="s1">kind = dtype.kind</span>

    <span class="s1">cls: type[Block]</span>

    <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">SparseDtype):</span>
        <span class="s2"># Need this first(ish) so that Sparse[datetime] is sparse</span>
        <span class="s1">cls = ExtensionBlock</span>
    <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype):</span>
        <span class="s1">cls = CategoricalBlock</span>
    <span class="s0">elif </span><span class="s1">vtype </span><span class="s0">is </span><span class="s1">Timestamp:</span>
        <span class="s1">cls = DatetimeTZBlock</span>
    <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">PeriodDtype):</span>
        <span class="s1">cls = NDArrayBackedExtensionBlock</span>
    <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s2"># Note: need to be sure PandasArray is unwrapped before we get here</span>
        <span class="s1">cls = ExtensionBlock</span>

    <span class="s0">elif </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;M&quot;</span><span class="s0">, </span><span class="s3">&quot;m&quot;</span><span class="s1">]:</span>
        <span class="s1">cls = DatetimeLikeBlock</span>
    <span class="s0">elif </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;f&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;i&quot;</span><span class="s0">, </span><span class="s3">&quot;u&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]:</span>
        <span class="s1">cls = NumericBlock</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cls = ObjectBlock</span>
    <span class="s0">return </span><span class="s1">cls</span>


<span class="s0">def </span><span class="s1">new_block_2d(values: ArrayLike</span><span class="s0">, </span><span class="s1">placement: BlockPlacement):</span>
    <span class="s2"># new_block specialized to case with</span>
    <span class="s2">#  ndim=2</span>
    <span class="s2">#  isinstance(placement, BlockPlacement)</span>
    <span class="s2">#  check_ndim/ensure_block_shape already checked</span>
    <span class="s1">klass = get_block_type(values.dtype)</span>

    <span class="s1">values = maybe_coerce_values(values)</span>
    <span class="s0">return </span><span class="s1">klass(values</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s0">, </span><span class="s1">placement=placement)</span>


<span class="s0">def </span><span class="s1">new_block(values</span><span class="s0">, </span><span class="s1">placement</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">ndim: int) -&gt; Block:</span>
    <span class="s2"># caller is responsible for ensuring values is NOT a PandasArray</span>

    <span class="s0">if not </span><span class="s1">isinstance(placement</span><span class="s0">, </span><span class="s1">BlockPlacement):</span>
        <span class="s1">placement = BlockPlacement(placement)</span>

    <span class="s1">check_ndim(values</span><span class="s0">, </span><span class="s1">placement</span><span class="s0">, </span><span class="s1">ndim)</span>

    <span class="s1">klass = get_block_type(values.dtype)</span>

    <span class="s1">values = maybe_coerce_values(values)</span>
    <span class="s0">return </span><span class="s1">klass(values</span><span class="s0">, </span><span class="s1">ndim=ndim</span><span class="s0">, </span><span class="s1">placement=placement)</span>


<span class="s0">def </span><span class="s1">check_ndim(values</span><span class="s0">, </span><span class="s1">placement: BlockPlacement</span><span class="s0">, </span><span class="s1">ndim: int):</span>
    <span class="s4">&quot;&quot;&quot; 
    ndim inference and validation. 
 
    Validates that values.ndim and ndim are consistent. 
    Validates that len(values) and len(placement) are consistent. 
 
    Parameters 
    ---------- 
    values : array-like 
    placement : BlockPlacement 
    ndim : int 
 
    Raises 
    ------ 
    ValueError : the number of dimensions do not match 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">values.ndim &gt; ndim:</span>
        <span class="s2"># Check for both np.ndarray and ExtensionArray</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Wrong number of dimensions. &quot;</span>
            <span class="s3">f&quot;values.ndim &gt; ndim [</span><span class="s0">{</span><span class="s1">values.ndim</span><span class="s0">} </span><span class="s3">&gt; </span><span class="s0">{</span><span class="s1">ndim</span><span class="s0">}</span><span class="s3">]&quot;</span>
        <span class="s1">)</span>

    <span class="s0">elif not </span><span class="s1">is_1d_only_ea_dtype(values.dtype):</span>
        <span class="s2"># TODO(EA2D): special case not needed with 2D EAs</span>
        <span class="s0">if </span><span class="s1">values.ndim != ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Wrong number of dimensions. &quot;</span>
                <span class="s3">f&quot;values.ndim != ndim [</span><span class="s0">{</span><span class="s1">values.ndim</span><span class="s0">} </span><span class="s3">!= </span><span class="s0">{</span><span class="s1">ndim</span><span class="s0">}</span><span class="s3">]&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(placement) != len(values):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Wrong number of items passed </span><span class="s0">{</span><span class="s1">len(values)</span><span class="s0">}</span><span class="s3">, &quot;</span>
                <span class="s3">f&quot;placement implies </span><span class="s0">{</span><span class="s1">len(placement)</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">ndim == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">len(placement) != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2"># TODO(EA2D): special case unnecessary with 2D EAs</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;need to split&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">extract_pandas_array(</span>
    <span class="s1">values: np.ndarray | ExtensionArray</span><span class="s0">, </span><span class="s1">dtype: DtypeObj | </span><span class="s0">None, </span><span class="s1">ndim: int</span>
<span class="s1">) -&gt; tuple[np.ndarray | ExtensionArray</span><span class="s0">, </span><span class="s1">DtypeObj | </span><span class="s0">None</span><span class="s1">]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Ensure that we don't allow PandasArray / PandasDtype in internals. 
    &quot;&quot;&quot;</span>
    <span class="s2"># For now, blocks should be backed by ndarrays when possible.</span>
    <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">ABCPandasArray):</span>
        <span class="s1">values = values.to_numpy()</span>
        <span class="s0">if </span><span class="s1">ndim </span><span class="s0">and </span><span class="s1">ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># TODO(EA2D): special case not needed with 2D EAs</span>
            <span class="s1">values = np.atleast_2d(values)</span>

    <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">PandasDtype):</span>
        <span class="s1">dtype = dtype.numpy_dtype</span>

    <span class="s0">return </span><span class="s1">values</span><span class="s0">, </span><span class="s1">dtype</span>


<span class="s2"># -----------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">extend_blocks(result</span><span class="s0">, </span><span class="s1">blocks=</span><span class="s0">None</span><span class="s1">) -&gt; list[Block]:</span>
    <span class="s4">&quot;&quot;&quot;return a new extended blocks, given the result&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">blocks </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">blocks = []</span>
    <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">result:</span>
            <span class="s0">if </span><span class="s1">isinstance(r</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">blocks.extend(r)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">blocks.append(r)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Block)</span><span class="s0">, </span><span class="s1">type(result)</span>
        <span class="s1">blocks.append(result)</span>
    <span class="s0">return </span><span class="s1">blocks</span>


<span class="s0">def </span><span class="s1">ensure_block_shape(values: ArrayLike</span><span class="s0">, </span><span class="s1">ndim: int = </span><span class="s5">1</span><span class="s1">) -&gt; ArrayLike:</span>
    <span class="s4">&quot;&quot;&quot; 
    Reshape if possible to have values.ndim == ndim. 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">values.ndim &lt; ndim:</span>
        <span class="s0">if not </span><span class="s1">is_1d_only_ea_dtype(values.dtype):</span>
            <span class="s2"># TODO(EA2D): https://github.com/pandas-dev/pandas/issues/23023</span>
            <span class="s2"># block.shape is incorrect for &quot;2D&quot; ExtensionArrays</span>
            <span class="s2"># We can't, and don't need to, reshape.</span>
            <span class="s1">values = cast(</span><span class="s3">&quot;np.ndarray | DatetimeArray | TimedeltaArray&quot;</span><span class="s0">, </span><span class="s1">values)</span>
            <span class="s1">values = values.reshape(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">to_native_types(</span>
    <span class="s1">values: ArrayLike</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">na_rep=</span><span class="s3">&quot;nan&quot;</span><span class="s0">,</span>
    <span class="s1">quoting=</span><span class="s0">None,</span>
    <span class="s1">float_format=</span><span class="s0">None,</span>
    <span class="s1">decimal=</span><span class="s3">&quot;.&quot;</span><span class="s0">,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s4">&quot;&quot;&quot;convert to our native types format&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Categorical):</span>
        <span class="s2"># GH#40754 Convert categorical datetimes to datetime array</span>
        <span class="s1">values = take_nd(</span>
            <span class="s1">values.categories._values</span><span class="s0">,</span>
            <span class="s1">ensure_platform_int(values._codes)</span><span class="s0">,</span>
            <span class="s1">fill_value=na_rep</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">values = ensure_wrapped_if_datetimelike(values)</span>

    <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(DatetimeArray</span><span class="s0">, </span><span class="s1">TimedeltaArray)):</span>
        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">result = values._format_native_types(na_rep=na_rep</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">result = result.astype(object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s2"># GH#21734 Process every column separately, they might have different formats</span>
        <span class="s1">results_converted = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(values)):</span>
            <span class="s1">result = values[i</span><span class="s0">, </span><span class="s1">:]._format_native_types(na_rep=na_rep</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">results_converted.append(result.astype(object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">np.vstack(results_converted)</span>

    <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
        <span class="s1">mask = isna(values)</span>

        <span class="s1">new_values = np.asarray(values.astype(object))</span>
        <span class="s1">new_values[mask] = na_rep</span>
        <span class="s0">return </span><span class="s1">new_values</span>

    <span class="s0">elif </span><span class="s1">values.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2"># see GH#13418: no special formatting is desired at the</span>
        <span class="s2"># output (important for appropriate 'quoting' behaviour),</span>
        <span class="s2"># so do not pass it through the FloatArrayFormatter</span>
        <span class="s0">if </span><span class="s1">float_format </span><span class="s0">is None and </span><span class="s1">decimal == </span><span class="s3">&quot;.&quot;</span><span class="s1">:</span>
            <span class="s1">mask = isna(values)</span>

            <span class="s0">if not </span><span class="s1">quoting:</span>
                <span class="s1">values = values.astype(str)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">values = np.array(values</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

            <span class="s1">values[mask] = na_rep</span>
            <span class="s1">values = values.astype(object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">values</span>

        <span class="s0">from </span><span class="s1">pandas.io.formats.format </span><span class="s0">import </span><span class="s1">FloatArrayFormatter</span>

        <span class="s1">formatter = FloatArrayFormatter(</span>
            <span class="s1">values</span><span class="s0">,</span>
            <span class="s1">na_rep=na_rep</span><span class="s0">,</span>
            <span class="s1">float_format=float_format</span><span class="s0">,</span>
            <span class="s1">decimal=decimal</span><span class="s0">,</span>
            <span class="s1">quoting=quoting</span><span class="s0">,</span>
            <span class="s1">fixed_width=</span><span class="s0">False,</span>
        <span class="s1">)</span>
        <span class="s1">res = formatter.get_result_as_array()</span>
        <span class="s1">res = res.astype(object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">else</span><span class="s1">:</span>

        <span class="s1">mask = isna(values)</span>
        <span class="s1">itemsize = writers.word_len(na_rep)</span>

        <span class="s0">if </span><span class="s1">values.dtype != _dtype_obj </span><span class="s0">and not </span><span class="s1">quoting </span><span class="s0">and </span><span class="s1">itemsize:</span>
            <span class="s1">values = values.astype(str)</span>
            <span class="s0">if </span><span class="s1">values.dtype.itemsize / np.dtype(</span><span class="s3">&quot;U1&quot;</span><span class="s1">).itemsize &lt; itemsize:</span>
                <span class="s2"># enlarge for the na_rep</span>
                <span class="s1">values = values.astype(</span><span class="s3">f&quot;&lt;U</span><span class="s0">{</span><span class="s1">itemsize</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">values = np.array(values</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

        <span class="s1">values[mask] = na_rep</span>
        <span class="s1">values = values.astype(object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">external_values(values: ArrayLike) -&gt; ArrayLike:</span>
    <span class="s4">&quot;&quot;&quot; 
    The array that Series.values returns (public attribute). 
 
    This has some historical constraints, and is overridden in block 
    subclasses to return the correct array (e.g. period returns 
    object ndarray and datetimetz a datetime64[ns] ndarray instead of 
    proper extension array). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(PeriodArray</span><span class="s0">, </span><span class="s1">IntervalArray)):</span>
        <span class="s0">return </span><span class="s1">values.astype(object)</span>
    <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(DatetimeArray</span><span class="s0">, </span><span class="s1">TimedeltaArray)):</span>
        <span class="s2"># NB: for datetime64tz this is different from np.asarray(values), since</span>
        <span class="s2">#  that returns an object-dtype ndarray of Timestamps.</span>
        <span class="s2"># Avoid FutureWarning in .astype in casting from dt64tz to dt64</span>
        <span class="s0">return </span><span class="s1">values._data</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">values</span>
</pre>
</body>
</html>