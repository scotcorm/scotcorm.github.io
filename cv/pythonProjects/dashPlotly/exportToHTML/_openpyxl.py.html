<html>
<head>
<title>_openpyxl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_openpyxl.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">mmap</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">FilePath</span><span class="s0">,</span>
    <span class="s1">ReadBuffer</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">StorageOptions</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat._optional </span><span class="s0">import </span><span class="s1">import_optional_dependency</span>

<span class="s0">from </span><span class="s1">pandas.io.excel._base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseExcelReader</span><span class="s0">,</span>
    <span class="s1">ExcelWriter</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.io.excel._util </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">combine_kwargs</span><span class="s0">,</span>
    <span class="s1">validate_freeze_panes</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">openpyxl.descriptors.serialisable </span><span class="s0">import </span><span class="s1">Serialisable</span>


<span class="s0">class </span><span class="s1">OpenpyxlWriter(ExcelWriter):</span>
    <span class="s1">engine = </span><span class="s2">&quot;openpyxl&quot;</span>
    <span class="s1">supported_extensions = (</span><span class="s2">&quot;.xlsx&quot;</span><span class="s0">, </span><span class="s2">&quot;.xlsm&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">path</span><span class="s0">,</span>
        <span class="s1">engine=</span><span class="s0">None,</span>
        <span class="s1">date_format=</span><span class="s0">None,</span>
        <span class="s1">datetime_format=</span><span class="s0">None,</span>
        <span class="s1">mode: str = </span><span class="s2">&quot;w&quot;</span><span class="s0">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
        <span class="s1">if_sheet_exists: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">Any] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s3"># Use the openpyxl module as the Excel writer.</span>
        <span class="s0">from </span><span class="s1">openpyxl.workbook </span><span class="s0">import </span><span class="s1">Workbook</span>

        <span class="s1">engine_kwargs = combine_kwargs(engine_kwargs</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">path</span><span class="s0">,</span>
            <span class="s1">mode=mode</span><span class="s0">,</span>
            <span class="s1">storage_options=storage_options</span><span class="s0">,</span>
            <span class="s1">if_sheet_exists=if_sheet_exists</span><span class="s0">,</span>
            <span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># ExcelWriter replaced &quot;a&quot; by &quot;r+&quot; to allow us to first read the excel file from</span>
        <span class="s3"># the file and later write to it</span>
        <span class="s0">if </span><span class="s2">&quot;r+&quot; </span><span class="s0">in </span><span class="s1">self.mode:  </span><span class="s3"># Load from existing workbook</span>
            <span class="s0">from </span><span class="s1">openpyxl </span><span class="s0">import </span><span class="s1">load_workbook</span>

            <span class="s1">self.book = load_workbook(self.handles.handle</span><span class="s0">, </span><span class="s1">**engine_kwargs)</span>
            <span class="s1">self.handles.handle.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self.sheets = {name: self.book[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.book.sheetnames}</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Create workbook object with default optimized_write=True.</span>
            <span class="s1">self.book = Workbook(**engine_kwargs)</span>

            <span class="s0">if </span><span class="s1">self.book.worksheets:</span>
                <span class="s1">self.book.remove(self.book.worksheets[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">save(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Save workbook to disk. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.book.save(self.handles.handle)</span>
        <span class="s0">if </span><span class="s2">&quot;r+&quot; </span><span class="s0">in </span><span class="s1">self.mode </span><span class="s0">and not </span><span class="s1">isinstance(self.handles.handle</span><span class="s0">, </span><span class="s1">mmap.mmap):</span>
            <span class="s3"># truncate file to the written content</span>
            <span class="s1">self.handles.handle.truncate()</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_style_kwargs(cls</span><span class="s0">, </span><span class="s1">style_dict: dict) -&gt; dict[str</span><span class="s0">, </span><span class="s1">Serialisable]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert a style_dict to a set of kwargs suitable for initializing 
        or updating-on-copy an openpyxl v2 style object. 
 
        Parameters 
        ---------- 
        style_dict : dict 
            A dict with zero or more of the following keys (or their synonyms). 
                'font' 
                'fill' 
                'border' ('borders') 
                'alignment' 
                'number_format' 
                'protection' 
 
        Returns 
        ------- 
        style_kwargs : dict 
            A dict with the same, normalized keys as ``style_dict`` but each 
            value has been replaced with a native openpyxl style object of the 
            appropriate class. 
        &quot;&quot;&quot;</span>
        <span class="s1">_style_key_map = {</span><span class="s2">&quot;borders&quot;</span><span class="s1">: </span><span class="s2">&quot;border&quot;</span><span class="s1">}</span>

        <span class="s1">style_kwargs: dict[str</span><span class="s0">, </span><span class="s1">Serialisable] = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">style_dict.items():</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_style_key_map:</span>
                <span class="s1">k = _style_key_map[k]</span>
            <span class="s1">_conv_to_x = getattr(cls</span><span class="s0">, </span><span class="s2">f&quot;_convert_to_</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, lambda </span><span class="s1">x: </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">new_v = _conv_to_x(v)</span>
            <span class="s0">if </span><span class="s1">new_v:</span>
                <span class="s1">style_kwargs[k] = new_v</span>

        <span class="s0">return </span><span class="s1">style_kwargs</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_color(cls</span><span class="s0">, </span><span class="s1">color_spec):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``color_spec`` to an openpyxl v2 Color object. 
 
        Parameters 
        ---------- 
        color_spec : str, dict 
            A 32-bit ARGB hex string, or a dict with zero or more of the 
            following keys. 
                'rgb' 
                'indexed' 
                'auto' 
                'theme' 
                'tint' 
                'index' 
                'type' 
 
        Returns 
        ------- 
        color : openpyxl.styles.Color 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">Color</span>

        <span class="s0">if </span><span class="s1">isinstance(color_spec</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">Color(color_spec)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Color(**color_spec)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_font(cls</span><span class="s0">, </span><span class="s1">font_dict):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``font_dict`` to an openpyxl v2 Font object. 
 
        Parameters 
        ---------- 
        font_dict : dict 
            A dict with zero or more of the following keys (or their synonyms). 
                'name' 
                'size' ('sz') 
                'bold' ('b') 
                'italic' ('i') 
                'underline' ('u') 
                'strikethrough' ('strike') 
                'color' 
                'vertAlign' ('vertalign') 
                'charset' 
                'scheme' 
                'family' 
                'outline' 
                'shadow' 
                'condense' 
 
        Returns 
        ------- 
        font : openpyxl.styles.Font 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">Font</span>

        <span class="s1">_font_key_map = {</span>
            <span class="s2">&quot;sz&quot;</span><span class="s1">: </span><span class="s2">&quot;size&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;bold&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;i&quot;</span><span class="s1">: </span><span class="s2">&quot;italic&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;u&quot;</span><span class="s1">: </span><span class="s2">&quot;underline&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;strike&quot;</span><span class="s1">: </span><span class="s2">&quot;strikethrough&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;vertalign&quot;</span><span class="s1">: </span><span class="s2">&quot;vertAlign&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">font_kwargs = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">font_dict.items():</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_font_key_map:</span>
                <span class="s1">k = _font_key_map[k]</span>
            <span class="s0">if </span><span class="s1">k == </span><span class="s2">&quot;color&quot;</span><span class="s1">:</span>
                <span class="s1">v = cls._convert_to_color(v)</span>
            <span class="s1">font_kwargs[k] = v</span>

        <span class="s0">return </span><span class="s1">Font(**font_kwargs)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_stop(cls</span><span class="s0">, </span><span class="s1">stop_seq):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``stop_seq`` to a list of openpyxl v2 Color objects, 
        suitable for initializing the ``GradientFill`` ``stop`` parameter. 
 
        Parameters 
        ---------- 
        stop_seq : iterable 
            An iterable that yields objects suitable for consumption by 
            ``_convert_to_color``. 
 
        Returns 
        ------- 
        stop : list of openpyxl.styles.Color 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">map(cls._convert_to_color</span><span class="s0">, </span><span class="s1">stop_seq)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_fill(cls</span><span class="s0">, </span><span class="s1">fill_dict):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``fill_dict`` to an openpyxl v2 Fill object. 
 
        Parameters 
        ---------- 
        fill_dict : dict 
            A dict with one or more of the following keys (or their synonyms), 
                'fill_type' ('patternType', 'patterntype') 
                'start_color' ('fgColor', 'fgcolor') 
                'end_color' ('bgColor', 'bgcolor') 
            or one or more of the following keys (or their synonyms). 
                'type' ('fill_type') 
                'degree' 
                'left' 
                'right' 
                'top' 
                'bottom' 
                'stop' 
 
        Returns 
        ------- 
        fill : openpyxl.styles.Fill 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">GradientFill</span><span class="s0">,</span>
            <span class="s1">PatternFill</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">_pattern_fill_key_map = {</span>
            <span class="s2">&quot;patternType&quot;</span><span class="s1">: </span><span class="s2">&quot;fill_type&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;patterntype&quot;</span><span class="s1">: </span><span class="s2">&quot;fill_type&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;fgColor&quot;</span><span class="s1">: </span><span class="s2">&quot;start_color&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;fgcolor&quot;</span><span class="s1">: </span><span class="s2">&quot;start_color&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;bgColor&quot;</span><span class="s1">: </span><span class="s2">&quot;end_color&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;bgcolor&quot;</span><span class="s1">: </span><span class="s2">&quot;end_color&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">_gradient_fill_key_map = {</span><span class="s2">&quot;fill_type&quot;</span><span class="s1">: </span><span class="s2">&quot;type&quot;</span><span class="s1">}</span>

        <span class="s1">pfill_kwargs = {}</span>
        <span class="s1">gfill_kwargs = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">fill_dict.items():</span>
            <span class="s1">pk = gk = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_pattern_fill_key_map:</span>
                <span class="s1">pk = _pattern_fill_key_map[k]</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_gradient_fill_key_map:</span>
                <span class="s1">gk = _gradient_fill_key_map[k]</span>
            <span class="s0">if </span><span class="s1">pk </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;start_color&quot;</span><span class="s0">, </span><span class="s2">&quot;end_color&quot;</span><span class="s1">]:</span>
                <span class="s1">v = cls._convert_to_color(v)</span>
            <span class="s0">if </span><span class="s1">gk == </span><span class="s2">&quot;stop&quot;</span><span class="s1">:</span>
                <span class="s1">v = cls._convert_to_stop(v)</span>
            <span class="s0">if </span><span class="s1">pk:</span>
                <span class="s1">pfill_kwargs[pk] = v</span>
            <span class="s0">elif </span><span class="s1">gk:</span>
                <span class="s1">gfill_kwargs[gk] = v</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">pfill_kwargs[k] = v</span>
                <span class="s1">gfill_kwargs[k] = v</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">PatternFill(**pfill_kwargs)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">return </span><span class="s1">GradientFill(**gfill_kwargs)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_side(cls</span><span class="s0">, </span><span class="s1">side_spec):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``side_spec`` to an openpyxl v2 Side object. 
 
        Parameters 
        ---------- 
        side_spec : str, dict 
            A string specifying the border style, or a dict with zero or more 
            of the following keys (or their synonyms). 
                'style' ('border_style') 
                'color' 
 
        Returns 
        ------- 
        side : openpyxl.styles.Side 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">Side</span>

        <span class="s1">_side_key_map = {</span><span class="s2">&quot;border_style&quot;</span><span class="s1">: </span><span class="s2">&quot;style&quot;</span><span class="s1">}</span>

        <span class="s0">if </span><span class="s1">isinstance(side_spec</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">Side(style=side_spec)</span>

        <span class="s1">side_kwargs = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">side_spec.items():</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_side_key_map:</span>
                <span class="s1">k = _side_key_map[k]</span>
            <span class="s0">if </span><span class="s1">k == </span><span class="s2">&quot;color&quot;</span><span class="s1">:</span>
                <span class="s1">v = cls._convert_to_color(v)</span>
            <span class="s1">side_kwargs[k] = v</span>

        <span class="s0">return </span><span class="s1">Side(**side_kwargs)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_border(cls</span><span class="s0">, </span><span class="s1">border_dict):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``border_dict`` to an openpyxl v2 Border object. 
 
        Parameters 
        ---------- 
        border_dict : dict 
            A dict with zero or more of the following keys (or their synonyms). 
                'left' 
                'right' 
                'top' 
                'bottom' 
                'diagonal' 
                'diagonal_direction' 
                'vertical' 
                'horizontal' 
                'diagonalUp' ('diagonalup') 
                'diagonalDown' ('diagonaldown') 
                'outline' 
 
        Returns 
        ------- 
        border : openpyxl.styles.Border 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">Border</span>

        <span class="s1">_border_key_map = {</span><span class="s2">&quot;diagonalup&quot;</span><span class="s1">: </span><span class="s2">&quot;diagonalUp&quot;</span><span class="s0">, </span><span class="s2">&quot;diagonaldown&quot;</span><span class="s1">: </span><span class="s2">&quot;diagonalDown&quot;</span><span class="s1">}</span>

        <span class="s1">border_kwargs = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">border_dict.items():</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_border_key_map:</span>
                <span class="s1">k = _border_key_map[k]</span>
            <span class="s0">if </span><span class="s1">k == </span><span class="s2">&quot;color&quot;</span><span class="s1">:</span>
                <span class="s1">v = cls._convert_to_color(v)</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s2">&quot;right&quot;</span><span class="s0">, </span><span class="s2">&quot;top&quot;</span><span class="s0">, </span><span class="s2">&quot;bottom&quot;</span><span class="s0">, </span><span class="s2">&quot;diagonal&quot;</span><span class="s1">]:</span>
                <span class="s1">v = cls._convert_to_side(v)</span>
            <span class="s1">border_kwargs[k] = v</span>

        <span class="s0">return </span><span class="s1">Border(**border_kwargs)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_alignment(cls</span><span class="s0">, </span><span class="s1">alignment_dict):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``alignment_dict`` to an openpyxl v2 Alignment object. 
 
        Parameters 
        ---------- 
        alignment_dict : dict 
            A dict with zero or more of the following keys (or their synonyms). 
                'horizontal' 
                'vertical' 
                'text_rotation' 
                'wrap_text' 
                'shrink_to_fit' 
                'indent' 
        Returns 
        ------- 
        alignment : openpyxl.styles.Alignment 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">Alignment</span>

        <span class="s0">return </span><span class="s1">Alignment(**alignment_dict)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_number_format(cls</span><span class="s0">, </span><span class="s1">number_format_dict):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``number_format_dict`` to an openpyxl v2.1.0 number format 
        initializer. 
 
        Parameters 
        ---------- 
        number_format_dict : dict 
            A dict with zero or more of the following keys. 
                'format_code' : str 
 
        Returns 
        ------- 
        number_format : str 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">number_format_dict[</span><span class="s2">&quot;format_code&quot;</span><span class="s1">]</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_convert_to_protection(cls</span><span class="s0">, </span><span class="s1">protection_dict):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert ``protection_dict`` to an openpyxl v2 Protection object. 
 
        Parameters 
        ---------- 
        protection_dict : dict 
            A dict with zero or more of the following keys. 
                'locked' 
                'hidden' 
 
        Returns 
        ------- 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">openpyxl.styles </span><span class="s0">import </span><span class="s1">Protection</span>

        <span class="s0">return </span><span class="s1">Protection(**protection_dict)</span>

    <span class="s0">def </span><span class="s1">write_cells(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">cells</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s0">None, </span><span class="s1">startrow=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">startcol=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">freeze_panes=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s3"># Write the frame cells using openpyxl.</span>
        <span class="s1">sheet_name = self._get_sheet_name(sheet_name)</span>

        <span class="s1">_style_cache: dict[str</span><span class="s0">, </span><span class="s1">dict[str</span><span class="s0">, </span><span class="s1">Serialisable]] = {}</span>

        <span class="s0">if </span><span class="s1">sheet_name </span><span class="s0">in </span><span class="s1">self.sheets </span><span class="s0">and </span><span class="s1">self.if_sheet_exists != </span><span class="s2">&quot;new&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s2">&quot;r+&quot; </span><span class="s0">in </span><span class="s1">self.mode:</span>
                <span class="s0">if </span><span class="s1">self.if_sheet_exists == </span><span class="s2">&quot;replace&quot;</span><span class="s1">:</span>
                    <span class="s1">old_wks = self.sheets[sheet_name]</span>
                    <span class="s1">target_index = self.book.index(old_wks)</span>
                    <span class="s0">del </span><span class="s1">self.book[sheet_name]</span>
                    <span class="s1">wks = self.book.create_sheet(sheet_name</span><span class="s0">, </span><span class="s1">target_index)</span>
                    <span class="s1">self.sheets[sheet_name] = wks</span>
                <span class="s0">elif </span><span class="s1">self.if_sheet_exists == </span><span class="s2">&quot;error&quot;</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">f&quot;Sheet '</span><span class="s0">{</span><span class="s1">sheet_name</span><span class="s0">}</span><span class="s2">' already exists and &quot;</span>
                        <span class="s2">f&quot;if_sheet_exists is set to 'error'.&quot;</span>
                    <span class="s1">)</span>
                <span class="s0">elif </span><span class="s1">self.if_sheet_exists == </span><span class="s2">&quot;overlay&quot;</span><span class="s1">:</span>
                    <span class="s1">wks = self.sheets[sheet_name]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">f&quot;'</span><span class="s0">{</span><span class="s1">self.if_sheet_exists</span><span class="s0">}</span><span class="s2">' is not valid for if_sheet_exists. &quot;</span>
                        <span class="s2">&quot;Valid options are 'error', 'new', 'replace' and 'overlay'.&quot;</span>
                    <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">wks = self.sheets[sheet_name]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">wks = self.book.create_sheet()</span>
            <span class="s1">wks.title = sheet_name</span>
            <span class="s1">self.sheets[sheet_name] = wks</span>

        <span class="s0">if </span><span class="s1">validate_freeze_panes(freeze_panes):</span>
            <span class="s1">wks.freeze_panes = wks.cell(</span>
                <span class="s1">row=freeze_panes[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">column=freeze_panes[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span>
            <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">cell </span><span class="s0">in </span><span class="s1">cells:</span>
            <span class="s1">xcell = wks.cell(</span>
                <span class="s1">row=startrow + cell.row + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">column=startcol + cell.col + </span><span class="s4">1</span>
            <span class="s1">)</span>
            <span class="s1">xcell.value</span><span class="s0">, </span><span class="s1">fmt = self._value_with_fmt(cell.val)</span>
            <span class="s0">if </span><span class="s1">fmt:</span>
                <span class="s1">xcell.number_format = fmt</span>

            <span class="s1">style_kwargs: dict[str</span><span class="s0">, </span><span class="s1">Serialisable] | </span><span class="s0">None </span><span class="s1">= {}</span>
            <span class="s0">if </span><span class="s1">cell.style:</span>
                <span class="s1">key = str(cell.style)</span>
                <span class="s1">style_kwargs = _style_cache.get(key)</span>
                <span class="s0">if </span><span class="s1">style_kwargs </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">style_kwargs = self._convert_to_style_kwargs(cell.style)</span>
                    <span class="s1">_style_cache[key] = style_kwargs</span>

            <span class="s0">if </span><span class="s1">style_kwargs:</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">style_kwargs.items():</span>
                    <span class="s1">setattr(xcell</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v)</span>

            <span class="s0">if </span><span class="s1">cell.mergestart </span><span class="s0">is not None and </span><span class="s1">cell.mergeend </span><span class="s0">is not None</span><span class="s1">:</span>

                <span class="s1">wks.merge_cells(</span>
                    <span class="s1">start_row=startrow + cell.row + </span><span class="s4">1</span><span class="s0">,</span>
                    <span class="s1">start_column=startcol + cell.col + </span><span class="s4">1</span><span class="s0">,</span>
                    <span class="s1">end_column=startcol + cell.mergeend + </span><span class="s4">1</span><span class="s0">,</span>
                    <span class="s1">end_row=startrow + cell.mergestart + </span><span class="s4">1</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s3"># When cells are merged only the top-left cell is preserved</span>
                <span class="s3"># The behaviour of the other cells in a merged range is</span>
                <span class="s3"># undefined</span>
                <span class="s0">if </span><span class="s1">style_kwargs:</span>
                    <span class="s1">first_row = startrow + cell.row + </span><span class="s4">1</span>
                    <span class="s1">last_row = startrow + cell.mergestart + </span><span class="s4">1</span>
                    <span class="s1">first_col = startcol + cell.col + </span><span class="s4">1</span>
                    <span class="s1">last_col = startcol + cell.mergeend + </span><span class="s4">1</span>

                    <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(first_row</span><span class="s0">, </span><span class="s1">last_row + </span><span class="s4">1</span><span class="s1">):</span>
                        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(first_col</span><span class="s0">, </span><span class="s1">last_col + </span><span class="s4">1</span><span class="s1">):</span>
                            <span class="s0">if </span><span class="s1">row == first_row </span><span class="s0">and </span><span class="s1">col == first_col:</span>
                                <span class="s3"># Ignore first cell. It is already handled.</span>
                                <span class="s0">continue</span>
                            <span class="s1">xcell = wks.cell(column=col</span><span class="s0">, </span><span class="s1">row=row)</span>
                            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">style_kwargs.items():</span>
                                <span class="s1">setattr(xcell</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v)</span>


<span class="s0">class </span><span class="s1">OpenpyxlReader(BaseExcelReader):</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">filepath_or_buffer: FilePath | ReadBuffer[bytes]</span><span class="s0">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Reader using openpyxl engine. 
 
        Parameters 
        ---------- 
        filepath_or_buffer : str, path object or Workbook 
            Object to be parsed. 
        storage_options : dict, optional 
            passed to fsspec for appropriate URLs (see ``_get_filepath_or_buffer``) 
        &quot;&quot;&quot;</span>
        <span class="s1">import_optional_dependency(</span><span class="s2">&quot;openpyxl&quot;</span><span class="s1">)</span>
        <span class="s1">super().__init__(filepath_or_buffer</span><span class="s0">, </span><span class="s1">storage_options=storage_options)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_workbook_class(self):</span>
        <span class="s0">from </span><span class="s1">openpyxl </span><span class="s0">import </span><span class="s1">Workbook</span>

        <span class="s0">return </span><span class="s1">Workbook</span>

    <span class="s0">def </span><span class="s1">load_workbook(self</span><span class="s0">, </span><span class="s1">filepath_or_buffer: FilePath | ReadBuffer[bytes]):</span>
        <span class="s0">from </span><span class="s1">openpyxl </span><span class="s0">import </span><span class="s1">load_workbook</span>

        <span class="s0">return </span><span class="s1">load_workbook(</span>
            <span class="s1">filepath_or_buffer</span><span class="s0">, </span><span class="s1">read_only=</span><span class="s0">True, </span><span class="s1">data_only=</span><span class="s0">True, </span><span class="s1">keep_links=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">sheet_names(self) -&gt; list[str]:</span>
        <span class="s0">return </span><span class="s1">[sheet.title </span><span class="s0">for </span><span class="s1">sheet </span><span class="s0">in </span><span class="s1">self.book.worksheets]</span>

    <span class="s0">def </span><span class="s1">get_sheet_by_name(self</span><span class="s0">, </span><span class="s1">name: str):</span>
        <span class="s1">self.raise_if_bad_sheet_by_name(name)</span>
        <span class="s0">return </span><span class="s1">self.book[name]</span>

    <span class="s0">def </span><span class="s1">get_sheet_by_index(self</span><span class="s0">, </span><span class="s1">index: int):</span>
        <span class="s1">self.raise_if_bad_sheet_by_index(index)</span>
        <span class="s0">return </span><span class="s1">self.book.worksheets[index]</span>

    <span class="s0">def </span><span class="s1">_convert_cell(self</span><span class="s0">, </span><span class="s1">cell</span><span class="s0">, </span><span class="s1">convert_float: bool) -&gt; Scalar:</span>

        <span class="s0">from </span><span class="s1">openpyxl.cell.cell </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">TYPE_ERROR</span><span class="s0">,</span>
            <span class="s1">TYPE_NUMERIC</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">cell.value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">&quot;&quot;  </span><span class="s3"># compat with xlrd</span>
        <span class="s0">elif </span><span class="s1">cell.data_type == TYPE_ERROR:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
        <span class="s0">elif not </span><span class="s1">convert_float </span><span class="s0">and </span><span class="s1">cell.data_type == TYPE_NUMERIC:</span>
            <span class="s0">return </span><span class="s1">float(cell.value)</span>

        <span class="s0">return </span><span class="s1">cell.value</span>

    <span class="s0">def </span><span class="s1">get_sheet_data(self</span><span class="s0">, </span><span class="s1">sheet</span><span class="s0">, </span><span class="s1">convert_float: bool) -&gt; list[list[Scalar]]:</span>

        <span class="s0">if </span><span class="s1">self.book.read_only:</span>
            <span class="s1">sheet.reset_dimensions()</span>

        <span class="s1">data: list[list[Scalar]] = []</span>
        <span class="s1">last_row_with_data = -</span><span class="s4">1</span>
        <span class="s0">for </span><span class="s1">row_number</span><span class="s0">, </span><span class="s1">row </span><span class="s0">in </span><span class="s1">enumerate(sheet.rows):</span>
            <span class="s1">converted_row = [self._convert_cell(cell</span><span class="s0">, </span><span class="s1">convert_float) </span><span class="s0">for </span><span class="s1">cell </span><span class="s0">in </span><span class="s1">row]</span>
            <span class="s0">while </span><span class="s1">converted_row </span><span class="s0">and </span><span class="s1">converted_row[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s2">&quot;&quot;</span><span class="s1">:</span>
                <span class="s3"># trim trailing empty elements</span>
                <span class="s1">converted_row.pop()</span>
            <span class="s0">if </span><span class="s1">converted_row:</span>
                <span class="s1">last_row_with_data = row_number</span>
            <span class="s1">data.append(converted_row)</span>

        <span class="s3"># Trim trailing empty rows</span>
        <span class="s1">data = data[: last_row_with_data + </span><span class="s4">1</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">len(data) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3"># extend rows to max width</span>
            <span class="s1">max_width = max(len(data_row) </span><span class="s0">for </span><span class="s1">data_row </span><span class="s0">in </span><span class="s1">data)</span>
            <span class="s0">if </span><span class="s1">min(len(data_row) </span><span class="s0">for </span><span class="s1">data_row </span><span class="s0">in </span><span class="s1">data) &lt; max_width:</span>
                <span class="s1">empty_cell: list[Scalar] = [</span><span class="s2">&quot;&quot;</span><span class="s1">]</span>
                <span class="s1">data = [</span>
                    <span class="s1">data_row + (max_width - len(data_row)) * empty_cell</span>
                    <span class="s0">for </span><span class="s1">data_row </span><span class="s0">in </span><span class="s1">data</span>
                <span class="s1">]</span>

        <span class="s0">return </span><span class="s1">data</span>
</pre>
</body>
</html>