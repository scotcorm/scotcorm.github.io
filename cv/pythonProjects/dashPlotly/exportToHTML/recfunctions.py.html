<html>
<head>
<title>recfunctions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
recfunctions.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Collection of utilities to manipulate structured arrays. 
 
Most of these functions were initially implemented by John Hunter for 
matplotlib.  They have been rewritten and extended for convenience. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">numpy.ma </span><span class="s2">as </span><span class="s1">ma</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">recarray</span>
<span class="s2">from </span><span class="s1">numpy.ma </span><span class="s2">import </span><span class="s1">MaskedArray</span>
<span class="s2">from </span><span class="s1">numpy.ma.mrecords </span><span class="s2">import </span><span class="s1">MaskedRecords</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">array_function_dispatch</span>
<span class="s2">from </span><span class="s1">numpy.lib._iotools </span><span class="s2">import </span><span class="s1">_is_string_like</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">suppress_warnings</span>

<span class="s1">_check_fill_value = np.ma.core._check_fill_value</span>


<span class="s1">__all__ = [</span>
    <span class="s3">'append_fields'</span><span class="s2">, </span><span class="s3">'apply_along_fields'</span><span class="s2">, </span><span class="s3">'assign_fields_by_name'</span><span class="s2">,</span>
    <span class="s3">'drop_fields'</span><span class="s2">, </span><span class="s3">'find_duplicates'</span><span class="s2">, </span><span class="s3">'flatten_descr'</span><span class="s2">,</span>
    <span class="s3">'get_fieldstructure'</span><span class="s2">, </span><span class="s3">'get_names'</span><span class="s2">, </span><span class="s3">'get_names_flat'</span><span class="s2">,</span>
    <span class="s3">'join_by'</span><span class="s2">, </span><span class="s3">'merge_arrays'</span><span class="s2">, </span><span class="s3">'rec_append_fields'</span><span class="s2">,</span>
    <span class="s3">'rec_drop_fields'</span><span class="s2">, </span><span class="s3">'rec_join'</span><span class="s2">, </span><span class="s3">'recursive_fill_fields'</span><span class="s2">,</span>
    <span class="s3">'rename_fields'</span><span class="s2">, </span><span class="s3">'repack_fields'</span><span class="s2">, </span><span class="s3">'require_fields'</span><span class="s2">,</span>
    <span class="s3">'stack_arrays'</span><span class="s2">, </span><span class="s3">'structured_to_unstructured'</span><span class="s2">, </span><span class="s3">'unstructured_to_structured'</span><span class="s2">,</span>
    <span class="s1">]</span>


<span class="s2">def </span><span class="s1">_recursive_fill_fields_dispatcher(input</span><span class="s2">, </span><span class="s1">output):</span>
    <span class="s2">return </span><span class="s1">(input</span><span class="s2">, </span><span class="s1">output)</span>


<span class="s1">@array_function_dispatch(_recursive_fill_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">recursive_fill_fields(input</span><span class="s2">, </span><span class="s1">output):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fills fields from output with fields from input, 
    with support for nested structures. 
 
    Parameters 
    ---------- 
    input : ndarray 
        Input array. 
    output : ndarray 
        Output array. 
 
    Notes 
    ----- 
    * `output` should be at least the same size as `input` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)]) 
    &gt;&gt;&gt; b = np.zeros((3,), dtype=a.dtype) 
    &gt;&gt;&gt; rfn.recursive_fill_fields(a, b) 
    array([(1, 10.), (2, 20.), (0,  0.)], dtype=[('A', '&lt;i8'), ('B', '&lt;f8')]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">newdtype = output.dtype</span>
    <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">newdtype.names:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">current = input[field]</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">current.dtype.names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">recursive_fill_fields(current</span><span class="s2">, </span><span class="s1">output[field])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">output[field][:len(current)] = current</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_get_fieldspec(dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Produce a list of name/dtype pairs corresponding to the dtype fields 
 
    Similar to dtype.descr, but the second item of each tuple is a dtype, not a 
    string. As a result, this handles subarray dtypes 
 
    Can be passed to the dtype constructor to reconstruct the dtype, noting that 
    this (deliberately) discards field offsets. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; dt = np.dtype([(('a', 'A'), np.int64), ('b', np.double, 3)]) 
    &gt;&gt;&gt; dt.descr 
    [(('a', 'A'), '&lt;i8'), ('b', '&lt;f8', (3,))] 
    &gt;&gt;&gt; _get_fieldspec(dt) 
    [(('a', 'A'), dtype('int64')), ('b', dtype(('&lt;f8', (3,))))] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s4"># .descr returns a nameless field, so we should too</span>
        <span class="s2">return </span><span class="s1">[(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">dtype)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">fields = ((name</span><span class="s2">, </span><span class="s1">dtype.fields[name]) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">dtype.names)</span>
        <span class="s4"># keep any titles, if present</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">(name </span><span class="s2">if </span><span class="s1">len(f) == </span><span class="s5">2 </span><span class="s2">else </span><span class="s1">(f[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">, </span><span class="s1">f[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields</span>
        <span class="s1">]</span>


<span class="s2">def </span><span class="s1">get_names(adtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the field names of the input datatype as a tuple. 
 
    Parameters 
    ---------- 
    adtype : dtype 
        Input datatype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=int)) 
    Traceback (most recent call last): 
        ... 
    AttributeError: 'numpy.ndarray' object has no attribute 'names' 
 
    &gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=[('A',int), ('B', float)])) 
    Traceback (most recent call last): 
        ... 
    AttributeError: 'numpy.ndarray' object has no attribute 'names' 
    &gt;&gt;&gt; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])]) 
    &gt;&gt;&gt; rfn.get_names(adtype) 
    ('a', ('b', ('ba', 'bb'))) 
    &quot;&quot;&quot;</span>
    <span class="s1">listnames = []</span>
    <span class="s1">names = adtype.names</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
        <span class="s1">current = adtype[name]</span>
        <span class="s2">if </span><span class="s1">current.names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">listnames.append((name</span><span class="s2">, </span><span class="s1">tuple(get_names(current))))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">listnames.append(name)</span>
    <span class="s2">return </span><span class="s1">tuple(listnames)</span>


<span class="s2">def </span><span class="s1">get_names_flat(adtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the field names of the input datatype as a tuple. Nested structure 
    are flattened beforehand. 
 
    Parameters 
    ---------- 
    adtype : dtype 
        Input datatype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=int)) is None 
    Traceback (most recent call last): 
        ... 
    AttributeError: 'numpy.ndarray' object has no attribute 'names' 
    &gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=[('A',int), ('B', float)])) 
    Traceback (most recent call last): 
        ... 
    AttributeError: 'numpy.ndarray' object has no attribute 'names' 
    &gt;&gt;&gt; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])]) 
    &gt;&gt;&gt; rfn.get_names_flat(adtype) 
    ('a', 'b', 'ba', 'bb') 
    &quot;&quot;&quot;</span>
    <span class="s1">listnames = []</span>
    <span class="s1">names = adtype.names</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
        <span class="s1">listnames.append(name)</span>
        <span class="s1">current = adtype[name]</span>
        <span class="s2">if </span><span class="s1">current.names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">listnames.extend(get_names_flat(current))</span>
    <span class="s2">return </span><span class="s1">tuple(listnames)</span>


<span class="s2">def </span><span class="s1">flatten_descr(ndtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Flatten a structured data-type description. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; ndtype = np.dtype([('a', '&lt;i4'), ('b', [('ba', '&lt;f8'), ('bb', '&lt;i4')])]) 
    &gt;&gt;&gt; rfn.flatten_descr(ndtype) 
    (('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32'))) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">names = ndtype.names</span>
    <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">((</span><span class="s3">''</span><span class="s2">, </span><span class="s1">ndtype)</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">descr = []</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">(typ</span><span class="s2">, </span><span class="s1">_) = ndtype.fields[field]</span>
            <span class="s2">if </span><span class="s1">typ.names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">descr.extend(flatten_descr(typ))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">descr.append((field</span><span class="s2">, </span><span class="s1">typ))</span>
        <span class="s2">return </span><span class="s1">tuple(descr)</span>


<span class="s2">def </span><span class="s1">_zip_dtype(seqarrays</span><span class="s2">, </span><span class="s1">flatten=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">newdtype = []</span>
    <span class="s2">if </span><span class="s1">flatten:</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">seqarrays:</span>
            <span class="s1">newdtype.extend(flatten_descr(a.dtype))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">seqarrays:</span>
            <span class="s1">current = a.dtype</span>
            <span class="s2">if </span><span class="s1">current.names </span><span class="s2">is not None and </span><span class="s1">len(current.names) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># special case - dtypes of 1 field are flattened</span>
                <span class="s1">newdtype.extend(_get_fieldspec(current))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">newdtype.append((</span><span class="s3">''</span><span class="s2">, </span><span class="s1">current))</span>
    <span class="s2">return </span><span class="s1">np.dtype(newdtype)</span>


<span class="s2">def </span><span class="s1">_zip_descr(seqarrays</span><span class="s2">, </span><span class="s1">flatten=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Combine the dtype description of a series of arrays. 
 
    Parameters 
    ---------- 
    seqarrays : sequence of arrays 
        Sequence of arrays 
    flatten : {boolean}, optional 
        Whether to collapse nested descriptions. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_zip_dtype(seqarrays</span><span class="s2">, </span><span class="s1">flatten=flatten).descr</span>


<span class="s2">def </span><span class="s1">get_fieldstructure(adtype</span><span class="s2">, </span><span class="s1">lastname=</span><span class="s2">None, </span><span class="s1">parents=</span><span class="s2">None,</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a dictionary with fields indexing lists of their parent fields. 
 
    This function is used to simplify access to fields nested in other fields. 
 
    Parameters 
    ---------- 
    adtype : np.dtype 
        Input datatype 
    lastname : optional 
        Last processed field name (used internally during recursion). 
    parents : dictionary 
        Dictionary of parent fields (used interbally during recursion). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; ndtype =  np.dtype([('A', int), 
    ...                     ('B', [('BA', int), 
    ...                            ('BB', [('BBA', int), ('BBB', int)])])]) 
    &gt;&gt;&gt; rfn.get_fieldstructure(ndtype) 
    ... # XXX: possible regression, order of BBA and BBB is swapped 
    {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']} 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">parents </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">parents = {}</span>
    <span class="s1">names = adtype.names</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
        <span class="s1">current = adtype[name]</span>
        <span class="s2">if </span><span class="s1">current.names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">lastname:</span>
                <span class="s1">parents[name] = [lastname</span><span class="s2">, </span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">parents[name] = []</span>
            <span class="s1">parents.update(get_fieldstructure(current</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">parents))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lastparent = [_ </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">(parents.get(lastname</span><span class="s2">, </span><span class="s1">[]) </span><span class="s2">or </span><span class="s1">[])]</span>
            <span class="s2">if </span><span class="s1">lastparent:</span>
                <span class="s1">lastparent.append(lastname)</span>
            <span class="s2">elif </span><span class="s1">lastname:</span>
                <span class="s1">lastparent = [lastname</span><span class="s2">, </span><span class="s1">]</span>
            <span class="s1">parents[name] = lastparent </span><span class="s2">or </span><span class="s1">[]</span>
    <span class="s2">return </span><span class="s1">parents</span>


<span class="s2">def </span><span class="s1">_izip_fields_flat(iterable):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an iterator of concatenated fields from a sequence of arrays, 
    collapsing any nested structure. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">iterable:</span>
        <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">np.void):</span>
            <span class="s2">yield from </span><span class="s1">_izip_fields_flat(tuple(element))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">element</span>


<span class="s2">def </span><span class="s1">_izip_fields(iterable):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an iterator of concatenated fields from a sequence of arrays. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">iterable:</span>
        <span class="s2">if </span><span class="s1">(hasattr(element</span><span class="s2">, </span><span class="s3">'__iter__'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">str)):</span>
            <span class="s2">yield from </span><span class="s1">_izip_fields(element)</span>
        <span class="s2">elif </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">np.void) </span><span class="s2">and </span><span class="s1">len(tuple(element)) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># this statement is the same from the previous expression</span>
            <span class="s2">yield from </span><span class="s1">_izip_fields(element)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">element</span>


<span class="s2">def </span><span class="s1">_izip_records(seqarrays</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s2">None, </span><span class="s1">flatten=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an iterator of concatenated items from a sequence of arrays. 
 
    Parameters 
    ---------- 
    seqarrays : sequence of arrays 
        Sequence of arrays. 
    fill_value : {None, integer} 
        Value used to pad shorter iterables. 
    flatten : {True, False}, 
        Whether to 
    &quot;&quot;&quot;</span>

    <span class="s4"># Should we flatten the items, or just use a nested approach</span>
    <span class="s2">if </span><span class="s1">flatten:</span>
        <span class="s1">zipfunc = _izip_fields_flat</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">zipfunc = _izip_fields</span>

    <span class="s2">for </span><span class="s1">tup </span><span class="s2">in </span><span class="s1">itertools.zip_longest(*seqarrays</span><span class="s2">, </span><span class="s1">fillvalue=fill_value):</span>
        <span class="s2">yield </span><span class="s1">tuple(zipfunc(tup))</span>


<span class="s2">def </span><span class="s1">_fix_output(output</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">True, </span><span class="s1">asrecarray=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private function: return a recarray, a ndarray, a MaskedArray 
    or a MaskedRecords depending on the input parameters 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(output</span><span class="s2">, </span><span class="s1">MaskedArray):</span>
        <span class="s1">usemask = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">usemask:</span>
        <span class="s2">if </span><span class="s1">asrecarray:</span>
            <span class="s1">output = output.view(MaskedRecords)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">output = ma.filled(output)</span>
        <span class="s2">if </span><span class="s1">asrecarray:</span>
            <span class="s1">output = output.view(recarray)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_fix_defaults(output</span><span class="s2">, </span><span class="s1">defaults=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Update the fill_value and masked data of `output` 
    from the default given in a dictionary defaults. 
    &quot;&quot;&quot;</span>
    <span class="s1">names = output.dtype.names</span>
    <span class="s1">(data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">fill_value) = (output.data</span><span class="s2">, </span><span class="s1">output.mask</span><span class="s2">, </span><span class="s1">output.fill_value)</span>
    <span class="s2">for </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">(defaults </span><span class="s2">or </span><span class="s1">{}).items():</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">fill_value[k] = v</span>
            <span class="s1">data[k][mask[k]] = v</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_merge_arrays_dispatcher(seqarrays</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s2">None, </span><span class="s1">flatten=</span><span class="s2">None,</span>
                             <span class="s1">usemask=</span><span class="s2">None, </span><span class="s1">asrecarray=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">seqarrays</span>


<span class="s1">@array_function_dispatch(_merge_arrays_dispatcher)</span>
<span class="s2">def </span><span class="s1">merge_arrays(seqarrays</span><span class="s2">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">flatten=</span><span class="s2">False,</span>
                 <span class="s1">usemask=</span><span class="s2">False, </span><span class="s1">asrecarray=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Merge arrays field by field. 
 
    Parameters 
    ---------- 
    seqarrays : sequence of ndarrays 
        Sequence of arrays 
    fill_value : {float}, optional 
        Filling value used to pad missing data on the shorter arrays. 
    flatten : {False, True}, optional 
        Whether to collapse nested fields. 
    usemask : {False, True}, optional 
        Whether to return a masked array or not. 
    asrecarray : {False, True}, optional 
        Whether to return a recarray (MaskedRecords) or not. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.]))) 
    array([( 1, 10.), ( 2, 20.), (-1, 30.)], 
          dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')]) 
 
    &gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2], dtype=np.int64), 
    ...         np.array([10., 20., 30.])), usemask=False) 
     array([(1, 10.0), (2, 20.0), (-1, 30.0)], 
             dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')]) 
    &gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]).view([('a', np.int64)]), 
    ...               np.array([10., 20., 30.])), 
    ...              usemask=False, asrecarray=True) 
    rec.array([( 1, 10.), ( 2, 20.), (-1, 30.)], 
              dtype=[('a', '&lt;i8'), ('f1', '&lt;f8')]) 
 
    Notes 
    ----- 
    * Without a mask, the missing value will be filled with something, 
      depending on what its corresponding type: 
 
      * ``-1``      for integers 
      * ``-1.0``    for floating point numbers 
      * ``'-'``     for characters 
      * ``'-1'``    for strings 
      * ``True``    for boolean values 
    * XXX: I just obtained these values empirically 
    &quot;&quot;&quot;</span>
    <span class="s4"># Only one item in the input sequence ?</span>
    <span class="s2">if </span><span class="s1">(len(seqarrays) == </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">seqarrays = np.asanyarray(seqarrays[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s4"># Do we have a single ndarray as input ?</span>
    <span class="s2">if </span><span class="s1">isinstance(seqarrays</span><span class="s2">, </span><span class="s1">(ndarray</span><span class="s2">, </span><span class="s1">np.void)):</span>
        <span class="s1">seqdtype = seqarrays.dtype</span>
        <span class="s4"># Make sure we have named fields</span>
        <span class="s2">if </span><span class="s1">seqdtype.names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">seqdtype = np.dtype([(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">seqdtype)])</span>
        <span class="s2">if not </span><span class="s1">flatten </span><span class="s2">or </span><span class="s1">_zip_dtype((seqarrays</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">flatten=</span><span class="s2">True</span><span class="s1">) == seqdtype:</span>
            <span class="s4"># Minimal processing needed: just make sure everything's a-ok</span>
            <span class="s1">seqarrays = seqarrays.ravel()</span>
            <span class="s4"># Find what type of array we must return</span>
            <span class="s2">if </span><span class="s1">usemask:</span>
                <span class="s2">if </span><span class="s1">asrecarray:</span>
                    <span class="s1">seqtype = MaskedRecords</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">seqtype = MaskedArray</span>
            <span class="s2">elif </span><span class="s1">asrecarray:</span>
                <span class="s1">seqtype = recarray</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">seqtype = ndarray</span>
            <span class="s2">return </span><span class="s1">seqarrays.view(dtype=seqdtype</span><span class="s2">, </span><span class="s1">type=seqtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">seqarrays = (seqarrays</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># Make sure we have arrays in the input sequence</span>
        <span class="s1">seqarrays = [np.asanyarray(_m) </span><span class="s2">for </span><span class="s1">_m </span><span class="s2">in </span><span class="s1">seqarrays]</span>
    <span class="s4"># Find the sizes of the inputs and their maximum</span>
    <span class="s1">sizes = tuple(a.size </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">seqarrays)</span>
    <span class="s1">maxlength = max(sizes)</span>
    <span class="s4"># Get the dtype of the output (flattening if needed)</span>
    <span class="s1">newdtype = _zip_dtype(seqarrays</span><span class="s2">, </span><span class="s1">flatten=flatten)</span>
    <span class="s4"># Initialize the sequences for data and mask</span>
    <span class="s1">seqdata = []</span>
    <span class="s1">seqmask = []</span>
    <span class="s4"># If we expect some kind of MaskedArray, make a special loop.</span>
    <span class="s2">if </span><span class="s1">usemask:</span>
        <span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">n) </span><span class="s2">in </span><span class="s1">zip(seqarrays</span><span class="s2">, </span><span class="s1">sizes):</span>
            <span class="s1">nbmissing = (maxlength - n)</span>
            <span class="s4"># Get the data and mask</span>
            <span class="s1">data = a.ravel().__array__()</span>
            <span class="s1">mask = ma.getmaskarray(a).ravel()</span>
            <span class="s4"># Get the filling value (if needed)</span>
            <span class="s2">if </span><span class="s1">nbmissing:</span>
                <span class="s1">fval = _check_fill_value(fill_value</span><span class="s2">, </span><span class="s1">a.dtype)</span>
                <span class="s2">if </span><span class="s1">isinstance(fval</span><span class="s2">, </span><span class="s1">(ndarray</span><span class="s2">, </span><span class="s1">np.void)):</span>
                    <span class="s2">if </span><span class="s1">len(fval.dtype) == </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">fval = fval.item()[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">fmsk = </span><span class="s2">True</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">fval = np.array(fval</span><span class="s2">, </span><span class="s1">dtype=a.dtype</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s1">fmsk = np.ones((</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=mask.dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fval = </span><span class="s2">None</span>
                <span class="s1">fmsk = </span><span class="s2">True</span>
            <span class="s4"># Store an iterator padding the input to the expected length</span>
            <span class="s1">seqdata.append(itertools.chain(data</span><span class="s2">, </span><span class="s1">[fval] * nbmissing))</span>
            <span class="s1">seqmask.append(itertools.chain(mask</span><span class="s2">, </span><span class="s1">[fmsk] * nbmissing))</span>
        <span class="s4"># Create an iterator for the data</span>
        <span class="s1">data = tuple(_izip_records(seqdata</span><span class="s2">, </span><span class="s1">flatten=flatten))</span>
        <span class="s1">output = ma.array(np.fromiter(data</span><span class="s2">, </span><span class="s1">dtype=newdtype</span><span class="s2">, </span><span class="s1">count=maxlength)</span><span class="s2">,</span>
                          <span class="s1">mask=list(_izip_records(seqmask</span><span class="s2">, </span><span class="s1">flatten=flatten)))</span>
        <span class="s2">if </span><span class="s1">asrecarray:</span>
            <span class="s1">output = output.view(MaskedRecords)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># Same as before, without the mask we don't need...</span>
        <span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">n) </span><span class="s2">in </span><span class="s1">zip(seqarrays</span><span class="s2">, </span><span class="s1">sizes):</span>
            <span class="s1">nbmissing = (maxlength - n)</span>
            <span class="s1">data = a.ravel().__array__()</span>
            <span class="s2">if </span><span class="s1">nbmissing:</span>
                <span class="s1">fval = _check_fill_value(fill_value</span><span class="s2">, </span><span class="s1">a.dtype)</span>
                <span class="s2">if </span><span class="s1">isinstance(fval</span><span class="s2">, </span><span class="s1">(ndarray</span><span class="s2">, </span><span class="s1">np.void)):</span>
                    <span class="s2">if </span><span class="s1">len(fval.dtype) == </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">fval = fval.item()[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">fval = np.array(fval</span><span class="s2">, </span><span class="s1">dtype=a.dtype</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fval = </span><span class="s2">None</span>
            <span class="s1">seqdata.append(itertools.chain(data</span><span class="s2">, </span><span class="s1">[fval] * nbmissing))</span>
        <span class="s1">output = np.fromiter(tuple(_izip_records(seqdata</span><span class="s2">, </span><span class="s1">flatten=flatten))</span><span class="s2">,</span>
                             <span class="s1">dtype=newdtype</span><span class="s2">, </span><span class="s1">count=maxlength)</span>
        <span class="s2">if </span><span class="s1">asrecarray:</span>
            <span class="s1">output = output.view(recarray)</span>
    <span class="s4"># And we're done...</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_drop_fields_dispatcher(base</span><span class="s2">, </span><span class="s1">drop_names</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">None, </span><span class="s1">asrecarray=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(base</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_drop_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">drop_fields(base</span><span class="s2">, </span><span class="s1">drop_names</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">True, </span><span class="s1">asrecarray=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a new array with fields in `drop_names` dropped. 
 
    Nested fields are supported. 
 
    .. versionchanged:: 1.18.0 
        `drop_fields` returns an array with 0 fields if all fields are dropped, 
        rather than returning ``None`` as it did previously. 
 
    Parameters 
    ---------- 
    base : array 
        Input array 
    drop_names : string or sequence 
        String or sequence of strings corresponding to the names of the 
        fields to drop. 
    usemask : {False, True}, optional 
        Whether to return a masked array or not. 
    asrecarray : string or sequence, optional 
        Whether to return a recarray or a mrecarray (`asrecarray=True`) or 
        a plain ndarray or masked array with flexible dtype. The default 
        is False. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; a = np.array([(1, (2, 3.0)), (4, (5, 6.0))], 
    ...   dtype=[('a', np.int64), ('b', [('ba', np.double), ('bb', np.int64)])]) 
    &gt;&gt;&gt; rfn.drop_fields(a, 'a') 
    array([((2., 3),), ((5., 6),)], 
          dtype=[('b', [('ba', '&lt;f8'), ('bb', '&lt;i8')])]) 
    &gt;&gt;&gt; rfn.drop_fields(a, 'ba') 
    array([(1, (3,)), (4, (6,))], dtype=[('a', '&lt;i8'), ('b', [('bb', '&lt;i8')])]) 
    &gt;&gt;&gt; rfn.drop_fields(a, ['ba', 'bb']) 
    array([(1,), (4,)], dtype=[('a', '&lt;i8')]) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_is_string_like(drop_names):</span>
        <span class="s1">drop_names = [drop_names]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">drop_names = set(drop_names)</span>

    <span class="s2">def </span><span class="s1">_drop_descr(ndtype</span><span class="s2">, </span><span class="s1">drop_names):</span>
        <span class="s1">names = ndtype.names</span>
        <span class="s1">newdtype = []</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">current = ndtype[name]</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">drop_names:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">current.names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">descr = _drop_descr(current</span><span class="s2">, </span><span class="s1">drop_names)</span>
                <span class="s2">if </span><span class="s1">descr:</span>
                    <span class="s1">newdtype.append((name</span><span class="s2">, </span><span class="s1">descr))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">newdtype.append((name</span><span class="s2">, </span><span class="s1">current))</span>
        <span class="s2">return </span><span class="s1">newdtype</span>

    <span class="s1">newdtype = _drop_descr(base.dtype</span><span class="s2">, </span><span class="s1">drop_names)</span>

    <span class="s1">output = np.empty(base.shape</span><span class="s2">, </span><span class="s1">dtype=newdtype)</span>
    <span class="s1">output = recursive_fill_fields(base</span><span class="s2">, </span><span class="s1">output)</span>
    <span class="s2">return </span><span class="s1">_fix_output(output</span><span class="s2">, </span><span class="s1">usemask=usemask</span><span class="s2">, </span><span class="s1">asrecarray=asrecarray)</span>


<span class="s2">def </span><span class="s1">_keep_fields(base</span><span class="s2">, </span><span class="s1">keep_names</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">True, </span><span class="s1">asrecarray=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a new array keeping only the fields in `keep_names`, 
    and preserving the order of those fields. 
 
    Parameters 
    ---------- 
    base : array 
        Input array 
    keep_names : string or sequence 
        String or sequence of strings corresponding to the names of the 
        fields to keep. Order of the names will be preserved. 
    usemask : {False, True}, optional 
        Whether to return a masked array or not. 
    asrecarray : string or sequence, optional 
        Whether to return a recarray or a mrecarray (`asrecarray=True`) or 
        a plain ndarray or masked array with flexible dtype. The default 
        is False. 
    &quot;&quot;&quot;</span>
    <span class="s1">newdtype = [(n</span><span class="s2">, </span><span class="s1">base.dtype[n]) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">keep_names]</span>
    <span class="s1">output = np.empty(base.shape</span><span class="s2">, </span><span class="s1">dtype=newdtype)</span>
    <span class="s1">output = recursive_fill_fields(base</span><span class="s2">, </span><span class="s1">output)</span>
    <span class="s2">return </span><span class="s1">_fix_output(output</span><span class="s2">, </span><span class="s1">usemask=usemask</span><span class="s2">, </span><span class="s1">asrecarray=asrecarray)</span>


<span class="s2">def </span><span class="s1">_rec_drop_fields_dispatcher(base</span><span class="s2">, </span><span class="s1">drop_names):</span>
    <span class="s2">return </span><span class="s1">(base</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_rec_drop_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">rec_drop_fields(base</span><span class="s2">, </span><span class="s1">drop_names):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a new numpy.recarray with fields in `drop_names` dropped. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">drop_fields(base</span><span class="s2">, </span><span class="s1">drop_names</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">False, </span><span class="s1">asrecarray=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_rename_fields_dispatcher(base</span><span class="s2">, </span><span class="s1">namemapper):</span>
    <span class="s2">return </span><span class="s1">(base</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_rename_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">rename_fields(base</span><span class="s2">, </span><span class="s1">namemapper):</span>
    <span class="s0">&quot;&quot;&quot; 
    Rename the fields from a flexible-datatype ndarray or recarray. 
 
    Nested fields are supported. 
 
    Parameters 
    ---------- 
    base : ndarray 
        Input array whose fields must be modified. 
    namemapper : dictionary 
        Dictionary mapping old field names to their new version. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))], 
    ...   dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])]) 
    &gt;&gt;&gt; rfn.rename_fields(a, {'a':'A', 'bb':'BB'}) 
    array([(1, (2., [ 3., 30.])), (4, (5., [ 6., 60.]))], 
          dtype=[('A', '&lt;i8'), ('b', [('ba', '&lt;f8'), ('BB', '&lt;f8', (2,))])]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_recursive_rename_fields(ndtype</span><span class="s2">, </span><span class="s1">namemapper):</span>
        <span class="s1">newdtype = []</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">ndtype.names:</span>
            <span class="s1">newname = namemapper.get(name</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">current = ndtype[name]</span>
            <span class="s2">if </span><span class="s1">current.names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">newdtype.append(</span>
                    <span class="s1">(newname</span><span class="s2">, </span><span class="s1">_recursive_rename_fields(current</span><span class="s2">, </span><span class="s1">namemapper))</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">newdtype.append((newname</span><span class="s2">, </span><span class="s1">current))</span>
        <span class="s2">return </span><span class="s1">newdtype</span>
    <span class="s1">newdtype = _recursive_rename_fields(base.dtype</span><span class="s2">, </span><span class="s1">namemapper)</span>
    <span class="s2">return </span><span class="s1">base.view(newdtype)</span>


<span class="s2">def </span><span class="s1">_append_fields_dispatcher(base</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtypes=</span><span class="s2">None,</span>
                              <span class="s1">fill_value=</span><span class="s2">None, </span><span class="s1">usemask=</span><span class="s2">None, </span><span class="s1">asrecarray=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">yield </span><span class="s1">base</span>
    <span class="s2">yield from </span><span class="s1">data</span>


<span class="s1">@array_function_dispatch(_append_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">append_fields(base</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtypes=</span><span class="s2">None,</span>
                  <span class="s1">fill_value=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">True, </span><span class="s1">asrecarray=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add new fields to an existing array. 
 
    The names of the fields are given with the `names` arguments, 
    the corresponding values with the `data` arguments. 
    If a single field is appended, `names`, `data` and `dtypes` do not have 
    to be lists but just values. 
 
    Parameters 
    ---------- 
    base : array 
        Input array to extend. 
    names : string, sequence 
        String or sequence of strings corresponding to the names 
        of the new fields. 
    data : array or sequence of arrays 
        Array or sequence of arrays storing the fields to add to the base. 
    dtypes : sequence of datatypes, optional 
        Datatype or sequence of datatypes. 
        If None, the datatypes are estimated from the `data`. 
    fill_value : {float}, optional 
        Filling value used to pad missing data on the shorter arrays. 
    usemask : {False, True}, optional 
        Whether to return a masked array or not. 
    asrecarray : {False, True}, optional 
        Whether to return a recarray (MaskedRecords) or not. 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Check the names</span>
    <span class="s2">if </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
        <span class="s2">if </span><span class="s1">len(names) != len(data):</span>
            <span class="s1">msg = </span><span class="s3">&quot;The number of arrays does not match the number of names&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">elif </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">names = [names</span><span class="s2">, </span><span class="s1">]</span>
        <span class="s1">data = [data</span><span class="s2">, </span><span class="s1">]</span>
    <span class="s4">#</span>
    <span class="s2">if </span><span class="s1">dtypes </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">data = [np.array(a</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">data = [a.view([(name</span><span class="s2">, </span><span class="s1">a.dtype)]) </span><span class="s2">for </span><span class="s1">(name</span><span class="s2">, </span><span class="s1">a) </span><span class="s2">in </span><span class="s1">zip(names</span><span class="s2">, </span><span class="s1">data)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">isinstance(dtypes</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
            <span class="s1">dtypes = [dtypes</span><span class="s2">, </span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">len(data) != len(dtypes):</span>
            <span class="s2">if </span><span class="s1">len(dtypes) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">dtypes = dtypes * len(data)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;The dtypes argument must be None, a dtype, or a list.&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">data = [np.array(a</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">subok=</span><span class="s2">True, </span><span class="s1">dtype=d).view([(n</span><span class="s2">, </span><span class="s1">d)])</span>
                <span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">in </span><span class="s1">zip(data</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">dtypes)]</span>
    <span class="s4">#</span>
    <span class="s1">base = merge_arrays(base</span><span class="s2">, </span><span class="s1">usemask=usemask</span><span class="s2">, </span><span class="s1">fill_value=fill_value)</span>
    <span class="s2">if </span><span class="s1">len(data) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">data = merge_arrays(data</span><span class="s2">, </span><span class="s1">flatten=</span><span class="s2">True, </span><span class="s1">usemask=usemask</span><span class="s2">,</span>
                            <span class="s1">fill_value=fill_value)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">data = data.pop()</span>
    <span class="s4">#</span>
    <span class="s1">output = ma.masked_all(</span>
        <span class="s1">max(len(base)</span><span class="s2">, </span><span class="s1">len(data))</span><span class="s2">,</span>
        <span class="s1">dtype=_get_fieldspec(base.dtype) + _get_fieldspec(data.dtype))</span>
    <span class="s1">output = recursive_fill_fields(base</span><span class="s2">, </span><span class="s1">output)</span>
    <span class="s1">output = recursive_fill_fields(data</span><span class="s2">, </span><span class="s1">output)</span>
    <span class="s4">#</span>
    <span class="s2">return </span><span class="s1">_fix_output(output</span><span class="s2">, </span><span class="s1">usemask=usemask</span><span class="s2">, </span><span class="s1">asrecarray=asrecarray)</span>


<span class="s2">def </span><span class="s1">_rec_append_fields_dispatcher(base</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtypes=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">yield </span><span class="s1">base</span>
    <span class="s2">yield from </span><span class="s1">data</span>


<span class="s1">@array_function_dispatch(_rec_append_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">rec_append_fields(base</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtypes=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add new fields to an existing array. 
 
    The names of the fields are given with the `names` arguments, 
    the corresponding values with the `data` arguments. 
    If a single field is appended, `names`, `data` and `dtypes` do not have 
    to be lists but just values. 
 
    Parameters 
    ---------- 
    base : array 
        Input array to extend. 
    names : string, sequence 
        String or sequence of strings corresponding to the names 
        of the new fields. 
    data : array or sequence of arrays 
        Array or sequence of arrays storing the fields to add to the base. 
    dtypes : sequence of datatypes, optional 
        Datatype or sequence of datatypes. 
        If None, the datatypes are estimated from the `data`. 
 
    See Also 
    -------- 
    append_fields 
 
    Returns 
    ------- 
    appended_array : np.recarray 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">append_fields(base</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">data=data</span><span class="s2">, </span><span class="s1">dtypes=dtypes</span><span class="s2">,</span>
                         <span class="s1">asrecarray=</span><span class="s2">True, </span><span class="s1">usemask=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_repack_fields_dispatcher(a</span><span class="s2">, </span><span class="s1">align=</span><span class="s2">None, </span><span class="s1">recurse=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_repack_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">repack_fields(a</span><span class="s2">, </span><span class="s1">align=</span><span class="s2">False, </span><span class="s1">recurse=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Re-pack the fields of a structured array or dtype in memory. 
 
    The memory layout of structured datatypes allows fields at arbitrary 
    byte offsets. This means the fields can be separated by padding bytes, 
    their offsets can be non-monotonically increasing, and they can overlap. 
 
    This method removes any overlaps and reorders the fields in memory so they 
    have increasing byte offsets, and adds or removes padding bytes depending 
    on the `align` option, which behaves like the `align` option to `np.dtype`. 
 
    If `align=False`, this method produces a &quot;packed&quot; memory layout in which 
    each field starts at the byte the previous field ended, and any padding 
    bytes are removed. 
 
    If `align=True`, this methods produces an &quot;aligned&quot; memory layout in which 
    each field's offset is a multiple of its alignment, and the total itemsize 
    is a multiple of the largest alignment, by adding padding bytes as needed. 
 
    Parameters 
    ---------- 
    a : ndarray or dtype 
       array or dtype for which to repack the fields. 
    align : boolean 
       If true, use an &quot;aligned&quot; memory layout, otherwise use a &quot;packed&quot; layout. 
    recurse : boolean 
       If True, also repack nested structures. 
 
    Returns 
    ------- 
    repacked : ndarray or dtype 
       Copy of `a` with fields repacked, or `a` itself if no repacking was 
       needed. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; def print_offsets(d): 
    ...     print(&quot;offsets:&quot;, [d.fields[name][1] for name in d.names]) 
    ...     print(&quot;itemsize:&quot;, d.itemsize) 
    ... 
    &gt;&gt;&gt; dt = np.dtype('u1, &lt;i8, &lt;f8', align=True) 
    &gt;&gt;&gt; dt 
    dtype({'names': ['f0', 'f1', 'f2'], 'formats': ['u1', '&lt;i8', '&lt;f8'], \ 
'offsets': [0, 8, 16], 'itemsize': 24}, align=True) 
    &gt;&gt;&gt; print_offsets(dt) 
    offsets: [0, 8, 16] 
    itemsize: 24 
    &gt;&gt;&gt; packed_dt = rfn.repack_fields(dt) 
    &gt;&gt;&gt; packed_dt 
    dtype([('f0', 'u1'), ('f1', '&lt;i8'), ('f2', '&lt;f8')]) 
    &gt;&gt;&gt; print_offsets(packed_dt) 
    offsets: [0, 1, 9] 
    itemsize: 17 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(a</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s1">dt = repack_fields(a.dtype</span><span class="s2">, </span><span class="s1">align=align</span><span class="s2">, </span><span class="s1">recurse=recurse)</span>
        <span class="s2">return </span><span class="s1">a.astype(dt</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">a.names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">a</span>

    <span class="s1">fieldinfo = []</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">a.names:</span>
        <span class="s1">tup = a.fields[name]</span>
        <span class="s2">if </span><span class="s1">recurse:</span>
            <span class="s1">fmt = repack_fields(tup[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">align=align</span><span class="s2">, </span><span class="s1">recurse=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fmt = tup[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(tup) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">name = (tup[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s1">fieldinfo.append((name</span><span class="s2">, </span><span class="s1">fmt))</span>

    <span class="s1">dt = np.dtype(fieldinfo</span><span class="s2">, </span><span class="s1">align=align)</span>
    <span class="s2">return </span><span class="s1">np.dtype((a.type</span><span class="s2">, </span><span class="s1">dt))</span>

<span class="s2">def </span><span class="s1">_get_fields_and_offsets(dt</span><span class="s2">, </span><span class="s1">offset=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a flat list of (dtype, count, offset) tuples of all the 
    scalar fields in the dtype &quot;dt&quot;, including nested fields, in left 
    to right order. 
    &quot;&quot;&quot;</span>

    <span class="s4"># counts up elements in subarrays, including nested subarrays, and returns</span>
    <span class="s4"># base dtype and count</span>
    <span class="s2">def </span><span class="s1">count_elem(dt):</span>
        <span class="s1">count = </span><span class="s5">1</span>
        <span class="s2">while </span><span class="s1">dt.shape != ():</span>
            <span class="s2">for </span><span class="s1">size </span><span class="s2">in </span><span class="s1">dt.shape:</span>
                <span class="s1">count *= size</span>
            <span class="s1">dt = dt.base</span>
        <span class="s2">return </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">count</span>

    <span class="s1">fields = []</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">dt.names:</span>
        <span class="s1">field = dt.fields[name]</span>
        <span class="s1">f_dt</span><span class="s2">, </span><span class="s1">f_offset = field[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">field[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">f_dt</span><span class="s2">, </span><span class="s1">n = count_elem(f_dt)</span>

        <span class="s2">if </span><span class="s1">f_dt.names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fields.append((np.dtype((f_dt</span><span class="s2">, </span><span class="s1">(n</span><span class="s2">,</span><span class="s1">)))</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">f_offset + offset))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subfields = _get_fields_and_offsets(f_dt</span><span class="s2">, </span><span class="s1">f_offset + offset)</span>
            <span class="s1">size = f_dt.itemsize</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
                <span class="s2">if </span><span class="s1">i == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s4"># optimization: avoid list comprehension if no subarray</span>
                    <span class="s1">fields.extend(subfields)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fields.extend([(d</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">o + i*size) </span><span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">o </span><span class="s2">in </span><span class="s1">subfields])</span>
    <span class="s2">return </span><span class="s1">fields</span>


<span class="s2">def </span><span class="s1">_structured_to_unstructured_dispatcher(arr</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">copy=</span><span class="s2">None,</span>
                                           <span class="s1">casting=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(arr</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">@array_function_dispatch(_structured_to_unstructured_dispatcher)</span>
<span class="s2">def </span><span class="s1">structured_to_unstructured(arr</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">casting=</span><span class="s3">'unsafe'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Converts an n-D structured array into an (n+1)-D unstructured array. 
 
    The new array will have a new last dimension equal in size to the 
    number of field-elements of the input array. If not supplied, the output 
    datatype is determined from the numpy type promotion rules applied to all 
    the field datatypes. 
 
    Nested fields, as well as each element of any subarray fields, all count 
    as a single field-elements. 
 
    Parameters 
    ---------- 
    arr : ndarray 
       Structured array or dtype to convert. Cannot contain object datatype. 
    dtype : dtype, optional 
       The dtype of the output unstructured array. 
    copy : bool, optional 
        See copy argument to `ndarray.astype`. If true, always return a copy. 
        If false, and `dtype` requirements are satisfied, a view is returned. 
    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional 
        See casting argument of `ndarray.astype`. Controls what kind of data 
        casting may occur. 
 
    Returns 
    ------- 
    unstructured : ndarray 
       Unstructured array with one more dimension. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; a = np.zeros(4, dtype=[('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)]) 
    &gt;&gt;&gt; a 
    array([(0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.]), 
           (0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.])], 
          dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))]) 
    &gt;&gt;&gt; rfn.structured_to_unstructured(a) 
    array([[0., 0., 0., 0., 0.], 
           [0., 0., 0., 0., 0.], 
           [0., 0., 0., 0., 0.], 
           [0., 0., 0., 0., 0.]]) 
 
    &gt;&gt;&gt; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)], 
    ...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')]) 
    &gt;&gt;&gt; np.mean(rfn.structured_to_unstructured(b[['x', 'z']]), axis=-1) 
    array([ 3. ,  5.5,  9. , 11. ]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr.dtype.names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'arr must be a structured array'</span><span class="s1">)</span>

    <span class="s1">fields = _get_fields_and_offsets(arr.dtype)</span>
    <span class="s1">n_fields = len(fields)</span>
    <span class="s2">if </span><span class="s1">n_fields == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;arr has no fields. Unable to guess dtype&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">n_fields == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># too many bugs elsewhere for this to work now</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;arr with no fields is not supported&quot;</span><span class="s1">)</span>

    <span class="s1">dts</span><span class="s2">, </span><span class="s1">counts</span><span class="s2">, </span><span class="s1">offsets = zip(*fields)</span>
    <span class="s1">names = [</span><span class="s3">'f{}'</span><span class="s1">.format(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(n_fields)]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">out_dtype = np.result_type(*[dt.base </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">dts])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">out_dtype = dtype</span>

    <span class="s4"># Use a series of views and casts to convert to an unstructured array:</span>

    <span class="s4"># first view using flattened fields (doesn't work for object arrays)</span>
    <span class="s4"># Note: dts may include a shape for subarrays</span>
    <span class="s1">flattened_fields = np.dtype({</span><span class="s3">'names'</span><span class="s1">: names</span><span class="s2">,</span>
                                 <span class="s3">'formats'</span><span class="s1">: dts</span><span class="s2">,</span>
                                 <span class="s3">'offsets'</span><span class="s1">: offsets</span><span class="s2">,</span>
                                 <span class="s3">'itemsize'</span><span class="s1">: arr.dtype.itemsize})</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:  </span><span class="s4"># until 1.16 (gh-12447)</span>
        <span class="s1">sup.filter(FutureWarning</span><span class="s2">, </span><span class="s3">&quot;Numpy has detected&quot;</span><span class="s1">)</span>
        <span class="s1">arr = arr.view(flattened_fields)</span>

    <span class="s4"># next cast to a packed format with all fields converted to new dtype</span>
    <span class="s1">packed_fields = np.dtype({</span><span class="s3">'names'</span><span class="s1">: names</span><span class="s2">,</span>
                              <span class="s3">'formats'</span><span class="s1">: [(out_dtype</span><span class="s2">, </span><span class="s1">dt.shape) </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">dts]})</span>
    <span class="s1">arr = arr.astype(packed_fields</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">casting=casting)</span>

    <span class="s4"># finally is it safe to view the packed fields as the unstructured type</span>
    <span class="s2">return </span><span class="s1">arr.view((out_dtype</span><span class="s2">, </span><span class="s1">(sum(counts)</span><span class="s2">,</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">_unstructured_to_structured_dispatcher(arr</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">names=</span><span class="s2">None,</span>
                                           <span class="s1">align=</span><span class="s2">None, </span><span class="s1">copy=</span><span class="s2">None, </span><span class="s1">casting=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(arr</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">@array_function_dispatch(_unstructured_to_structured_dispatcher)</span>
<span class="s2">def </span><span class="s1">unstructured_to_structured(arr</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">names=</span><span class="s2">None, </span><span class="s1">align=</span><span class="s2">False,</span>
                               <span class="s1">copy=</span><span class="s2">False, </span><span class="s1">casting=</span><span class="s3">'unsafe'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Converts an n-D unstructured array into an (n-1)-D structured array. 
 
    The last dimension of the input array is converted into a structure, with 
    number of field-elements equal to the size of the last dimension of the 
    input array. By default all output fields have the input array's dtype, but 
    an output structured dtype with an equal number of fields-elements can be 
    supplied instead. 
 
    Nested fields, as well as each element of any subarray fields, all count 
    towards the number of field-elements. 
 
    Parameters 
    ---------- 
    arr : ndarray 
       Unstructured array or dtype to convert. 
    dtype : dtype, optional 
       The structured dtype of the output array 
    names : list of strings, optional 
       If dtype is not supplied, this specifies the field names for the output 
       dtype, in order. The field dtypes will be the same as the input array. 
    align : boolean, optional 
       Whether to create an aligned memory layout. 
    copy : bool, optional 
        See copy argument to `ndarray.astype`. If true, always return a copy. 
        If false, and `dtype` requirements are satisfied, a view is returned. 
    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional 
        See casting argument of `ndarray.astype`. Controls what kind of data 
        casting may occur. 
 
    Returns 
    ------- 
    structured : ndarray 
       Structured array with fewer dimensions. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; dt = np.dtype([('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)]) 
    &gt;&gt;&gt; a = np.arange(20).reshape((4,5)) 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3,  4], 
           [ 5,  6,  7,  8,  9], 
           [10, 11, 12, 13, 14], 
           [15, 16, 17, 18, 19]]) 
    &gt;&gt;&gt; rfn.unstructured_to_structured(a, dt) 
    array([( 0, ( 1.,  2), [ 3.,  4.]), ( 5, ( 6.,  7), [ 8.,  9.]), 
           (10, (11., 12), [13., 14.]), (15, (16., 17), [18., 19.])], 
          dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr.shape == ():</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'arr must have at least one dimension'</span><span class="s1">)</span>
    <span class="s1">n_elem = arr.shape[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">n_elem == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># too many bugs elsewhere for this to work now</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;last axis with size 0 is not supported&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">names = [</span><span class="s3">'f{}'</span><span class="s1">.format(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(n_elem)]</span>
        <span class="s1">out_dtype = np.dtype([(n</span><span class="s2">, </span><span class="s1">arr.dtype) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">names]</span><span class="s2">, </span><span class="s1">align=align)</span>
        <span class="s1">fields = _get_fields_and_offsets(out_dtype)</span>
        <span class="s1">dts</span><span class="s2">, </span><span class="s1">counts</span><span class="s2">, </span><span class="s1">offsets = zip(*fields)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;don't supply both dtype and names&quot;</span><span class="s1">)</span>
        <span class="s4"># sanity check of the input dtype</span>
        <span class="s1">fields = _get_fields_and_offsets(dtype)</span>
        <span class="s2">if </span><span class="s1">len(fields) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">dts</span><span class="s2">, </span><span class="s1">counts</span><span class="s2">, </span><span class="s1">offsets = []</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dts</span><span class="s2">, </span><span class="s1">counts</span><span class="s2">, </span><span class="s1">offsets = zip(*fields)</span>

        <span class="s2">if </span><span class="s1">n_elem != sum(counts):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'The length of the last dimension of arr must '</span>
                             <span class="s3">'be equal to the number of fields in dtype'</span><span class="s1">)</span>
        <span class="s1">out_dtype = dtype</span>
        <span class="s2">if </span><span class="s1">align </span><span class="s2">and not </span><span class="s1">out_dtype.isalignedstruct:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;align was True but dtype is not aligned&quot;</span><span class="s1">)</span>

    <span class="s1">names = [</span><span class="s3">'f{}'</span><span class="s1">.format(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(fields))]</span>

    <span class="s4"># Use a series of views and casts to convert to a structured array:</span>

    <span class="s4"># first view as a packed structured array of one dtype</span>
    <span class="s1">packed_fields = np.dtype({</span><span class="s3">'names'</span><span class="s1">: names</span><span class="s2">,</span>
                              <span class="s3">'formats'</span><span class="s1">: [(arr.dtype</span><span class="s2">, </span><span class="s1">dt.shape) </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">dts]})</span>
    <span class="s1">arr = np.ascontiguousarray(arr).view(packed_fields)</span>

    <span class="s4"># next cast to an unpacked but flattened format with varied dtypes</span>
    <span class="s1">flattened_fields = np.dtype({</span><span class="s3">'names'</span><span class="s1">: names</span><span class="s2">,</span>
                                 <span class="s3">'formats'</span><span class="s1">: dts</span><span class="s2">,</span>
                                 <span class="s3">'offsets'</span><span class="s1">: offsets</span><span class="s2">,</span>
                                 <span class="s3">'itemsize'</span><span class="s1">: out_dtype.itemsize})</span>
    <span class="s1">arr = arr.astype(flattened_fields</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">casting=casting)</span>

    <span class="s4"># finally view as the final nested dtype and remove the last axis</span>
    <span class="s2">return </span><span class="s1">arr.view(out_dtype)[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>

<span class="s2">def </span><span class="s1">_apply_along_fields_dispatcher(func</span><span class="s2">, </span><span class="s1">arr):</span>
    <span class="s2">return </span><span class="s1">(arr</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">@array_function_dispatch(_apply_along_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">apply_along_fields(func</span><span class="s2">, </span><span class="s1">arr):</span>
    <span class="s0">&quot;&quot;&quot; 
    Apply function 'func' as a reduction across fields of a structured array. 
 
    This is similar to `apply_along_axis`, but treats the fields of a 
    structured array as an extra axis. The fields are all first cast to a 
    common type following the type-promotion rules from `numpy.result_type` 
    applied to the field's dtypes. 
 
    Parameters 
    ---------- 
    func : function 
       Function to apply on the &quot;field&quot; dimension. This function must 
       support an `axis` argument, like np.mean, np.sum, etc. 
    arr : ndarray 
       Structured array for which to apply func. 
 
    Returns 
    ------- 
    out : ndarray 
       Result of the recution operation 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)], 
    ...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')]) 
    &gt;&gt;&gt; rfn.apply_along_fields(np.mean, b) 
    array([ 2.66666667,  5.33333333,  8.66666667, 11.        ]) 
    &gt;&gt;&gt; rfn.apply_along_fields(np.mean, b[['x', 'z']]) 
    array([ 3. ,  5.5,  9. , 11. ]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr.dtype.names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'arr must be a structured array'</span><span class="s1">)</span>

    <span class="s1">uarr = structured_to_unstructured(arr)</span>
    <span class="s2">return </span><span class="s1">func(uarr</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s4"># works and avoids axis requirement, but very, very slow:</span>
    <span class="s4">#return np.apply_along_axis(func, -1, uarr)</span>

<span class="s2">def </span><span class="s1">_assign_fields_by_name_dispatcher(dst</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">zero_unassigned=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">dst</span><span class="s2">, </span><span class="s1">src</span>

<span class="s1">@array_function_dispatch(_assign_fields_by_name_dispatcher)</span>
<span class="s2">def </span><span class="s1">assign_fields_by_name(dst</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">zero_unassigned=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Assigns values from one structured array to another by field name. 
 
    Normally in numpy &gt;= 1.14, assignment of one structured array to another 
    copies fields &quot;by position&quot;, meaning that the first field from the src is 
    copied to the first field of the dst, and so on, regardless of field name. 
 
    This function instead copies &quot;by field name&quot;, such that fields in the dst 
    are assigned from the identically named field in the src. This applies 
    recursively for nested structures. This is how structure assignment worked 
    in numpy &gt;= 1.6 to &lt;= 1.13. 
 
    Parameters 
    ---------- 
    dst : ndarray 
    src : ndarray 
        The source and destination arrays during assignment. 
    zero_unassigned : bool, optional 
        If True, fields in the dst for which there was no matching 
        field in the src are filled with the value 0 (zero). This 
        was the behavior of numpy &lt;= 1.13. If False, those fields 
        are not modified. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">dst.dtype.names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dst[...] = src</span>
        <span class="s2">return</span>

    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">dst.dtype.names:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">src.dtype.names:</span>
            <span class="s2">if </span><span class="s1">zero_unassigned:</span>
                <span class="s1">dst[name] = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assign_fields_by_name(dst[name]</span><span class="s2">, </span><span class="s1">src[name]</span><span class="s2">,</span>
                                  <span class="s1">zero_unassigned)</span>

<span class="s2">def </span><span class="s1">_require_fields_dispatcher(array</span><span class="s2">, </span><span class="s1">required_dtype):</span>
    <span class="s2">return </span><span class="s1">(array</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">@array_function_dispatch(_require_fields_dispatcher)</span>
<span class="s2">def </span><span class="s1">require_fields(array</span><span class="s2">, </span><span class="s1">required_dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Casts a structured array to a new dtype using assignment by field-name. 
 
    This function assigns from the old to the new array by name, so the 
    value of a field in the output array is the value of the field with the 
    same name in the source array. This has the effect of creating a new 
    ndarray containing only the fields &quot;required&quot; by the required_dtype. 
 
    If a field name in the required_dtype does not exist in the 
    input array, that field is created and set to 0 in the output array. 
 
    Parameters 
    ---------- 
    a : ndarray 
       array to cast 
    required_dtype : dtype 
       datatype for output array 
 
    Returns 
    ------- 
    out : ndarray 
        array with the new dtype, with field values copied from the fields in 
        the input array with the same name 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; a = np.ones(4, dtype=[('a', 'i4'), ('b', 'f8'), ('c', 'u1')]) 
    &gt;&gt;&gt; rfn.require_fields(a, [('b', 'f4'), ('c', 'u1')]) 
    array([(1., 1), (1., 1), (1., 1), (1., 1)], 
      dtype=[('b', '&lt;f4'), ('c', 'u1')]) 
    &gt;&gt;&gt; rfn.require_fields(a, [('b', 'f4'), ('newf', 'u1')]) 
    array([(1., 0), (1., 0), (1., 0), (1., 0)], 
      dtype=[('b', '&lt;f4'), ('newf', 'u1')]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">out = np.empty(array.shape</span><span class="s2">, </span><span class="s1">dtype=required_dtype)</span>
    <span class="s1">assign_fields_by_name(out</span><span class="s2">, </span><span class="s1">array)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_stack_arrays_dispatcher(arrays</span><span class="s2">, </span><span class="s1">defaults=</span><span class="s2">None, </span><span class="s1">usemask=</span><span class="s2">None,</span>
                             <span class="s1">asrecarray=</span><span class="s2">None, </span><span class="s1">autoconvert=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">arrays</span>


<span class="s1">@array_function_dispatch(_stack_arrays_dispatcher)</span>
<span class="s2">def </span><span class="s1">stack_arrays(arrays</span><span class="s2">, </span><span class="s1">defaults=</span><span class="s2">None, </span><span class="s1">usemask=</span><span class="s2">True, </span><span class="s1">asrecarray=</span><span class="s2">False,</span>
                 <span class="s1">autoconvert=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Superposes arrays fields by fields 
 
    Parameters 
    ---------- 
    arrays : array or sequence 
        Sequence of input arrays. 
    defaults : dictionary, optional 
        Dictionary mapping field names to the corresponding default values. 
    usemask : {True, False}, optional 
        Whether to return a MaskedArray (or MaskedRecords is 
        `asrecarray==True`) or a ndarray. 
    asrecarray : {False, True}, optional 
        Whether to return a recarray (or MaskedRecords if `usemask==True`) 
        or just a flexible-type ndarray. 
    autoconvert : {False, True}, optional 
        Whether automatically cast the type of the field to the maximum. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; x = np.array([1, 2,]) 
    &gt;&gt;&gt; rfn.stack_arrays(x) is x 
    True 
    &gt;&gt;&gt; z = np.array([('A', 1), ('B', 2)], dtype=[('A', '|S3'), ('B', float)]) 
    &gt;&gt;&gt; zz = np.array([('a', 10., 100.), ('b', 20., 200.), ('c', 30., 300.)], 
    ...   dtype=[('A', '|S3'), ('B', np.double), ('C', np.double)]) 
    &gt;&gt;&gt; test = rfn.stack_arrays((z,zz)) 
    &gt;&gt;&gt; test 
    masked_array(data=[(b'A', 1.0, --), (b'B', 2.0, --), (b'a', 10.0, 100.0), 
                       (b'b', 20.0, 200.0), (b'c', 30.0, 300.0)], 
                 mask=[(False, False,  True), (False, False,  True), 
                       (False, False, False), (False, False, False), 
                       (False, False, False)], 
           fill_value=(b'N/A', 1.e+20, 1.e+20), 
                dtype=[('A', 'S3'), ('B', '&lt;f8'), ('C', '&lt;f8')]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(arrays</span><span class="s2">, </span><span class="s1">ndarray):</span>
        <span class="s2">return </span><span class="s1">arrays</span>
    <span class="s2">elif </span><span class="s1">len(arrays) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">arrays[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">seqarrays = [np.asanyarray(a).ravel() </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>
    <span class="s1">nrecords = [len(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">seqarrays]</span>
    <span class="s1">ndtype = [a.dtype </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">seqarrays]</span>
    <span class="s1">fldnames = [d.names </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">ndtype]</span>
    <span class="s4">#</span>
    <span class="s1">dtype_l = ndtype[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">newdescr = _get_fieldspec(dtype_l)</span>
    <span class="s1">names = [n </span><span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">newdescr]</span>
    <span class="s2">for </span><span class="s1">dtype_n </span><span class="s2">in </span><span class="s1">ndtype[</span><span class="s5">1</span><span class="s1">:]:</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">fdtype </span><span class="s2">in </span><span class="s1">_get_fieldspec(dtype_n):</span>
            <span class="s2">if </span><span class="s1">fname </span><span class="s2">not in </span><span class="s1">names:</span>
                <span class="s1">newdescr.append((fname</span><span class="s2">, </span><span class="s1">fdtype))</span>
                <span class="s1">names.append(fname)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nameidx = names.index(fname)</span>
                <span class="s1">_</span><span class="s2">, </span><span class="s1">cdtype = newdescr[nameidx]</span>
                <span class="s2">if </span><span class="s1">autoconvert:</span>
                    <span class="s1">newdescr[nameidx] = (fname</span><span class="s2">, </span><span class="s1">max(fdtype</span><span class="s2">, </span><span class="s1">cdtype))</span>
                <span class="s2">elif </span><span class="s1">fdtype != cdtype:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Incompatible type '%s' &lt;&gt; '%s'&quot; </span><span class="s1">%</span>
                                    <span class="s1">(cdtype</span><span class="s2">, </span><span class="s1">fdtype))</span>
    <span class="s4"># Only one field: use concatenate</span>
    <span class="s2">if </span><span class="s1">len(newdescr) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">output = ma.concatenate(seqarrays)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4">#</span>
        <span class="s1">output = ma.masked_all((np.sum(nrecords)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">newdescr)</span>
        <span class="s1">offset = np.cumsum(np.r_[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nrecords])</span>
        <span class="s1">seen = []</span>
        <span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j) </span><span class="s2">in </span><span class="s1">zip(seqarrays</span><span class="s2">, </span><span class="s1">fldnames</span><span class="s2">, </span><span class="s1">offset[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">offset[</span><span class="s5">1</span><span class="s1">:]):</span>
            <span class="s1">names = a.dtype.names</span>
            <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">output[</span><span class="s3">'f%i' </span><span class="s1">% len(seen)][i:j] = a</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">n:</span>
                    <span class="s1">output[name][i:j] = a[name]</span>
                    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">seen:</span>
                        <span class="s1">seen.append(name)</span>
    <span class="s4">#</span>
    <span class="s2">return </span><span class="s1">_fix_output(_fix_defaults(output</span><span class="s2">, </span><span class="s1">defaults)</span><span class="s2">,</span>
                       <span class="s1">usemask=usemask</span><span class="s2">, </span><span class="s1">asrecarray=asrecarray)</span>


<span class="s2">def </span><span class="s1">_find_duplicates_dispatcher(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">None, </span><span class="s1">ignoremask=</span><span class="s2">None, </span><span class="s1">return_index=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_find_duplicates_dispatcher)</span>
<span class="s2">def </span><span class="s1">find_duplicates(a</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">None, </span><span class="s1">ignoremask=</span><span class="s2">True, </span><span class="s1">return_index=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the duplicates in a structured array along a given key 
 
    Parameters 
    ---------- 
    a : array-like 
        Input array 
    key : {string, None}, optional 
        Name of the fields along which to check the duplicates. 
        If None, the search is performed by records 
    ignoremask : {True, False}, optional 
        Whether masked data should be discarded or considered as duplicates. 
    return_index : {False, True}, optional 
        Whether to return the indices of the duplicated values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.lib import recfunctions as rfn 
    &gt;&gt;&gt; ndtype = [('a', int)] 
    &gt;&gt;&gt; a = np.ma.array([1, 1, 1, 2, 2, 3, 3], 
    ...         mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype) 
    &gt;&gt;&gt; rfn.find_duplicates(a, ignoremask=True, return_index=True) 
    (masked_array(data=[(1,), (1,), (2,), (2,)], 
                 mask=[(False,), (False,), (False,), (False,)], 
           fill_value=(999999,), 
                dtype=[('a', '&lt;i8')]), array([0, 1, 3, 4])) 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asanyarray(a).ravel()</span>
    <span class="s4"># Get a dictionary of fields</span>
    <span class="s1">fields = get_fieldstructure(a.dtype)</span>
    <span class="s4"># Get the sorting data (by selecting the corresponding field)</span>
    <span class="s1">base = a</span>
    <span class="s2">if </span><span class="s1">key:</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields[key]:</span>
            <span class="s1">base = base[f]</span>
        <span class="s1">base = base[key]</span>
    <span class="s4"># Get the sorting indices and the sorted data</span>
    <span class="s1">sortidx = base.argsort()</span>
    <span class="s1">sortedbase = base[sortidx]</span>
    <span class="s1">sorteddata = sortedbase.filled()</span>
    <span class="s4"># Compare the sorting data</span>
    <span class="s1">flag = (sorteddata[:-</span><span class="s5">1</span><span class="s1">] == sorteddata[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s4"># If masked data must be ignored, set the flag to false where needed</span>
    <span class="s2">if </span><span class="s1">ignoremask:</span>
        <span class="s1">sortedmask = sortedbase.recordmask</span>
        <span class="s1">flag[sortedmask[</span><span class="s5">1</span><span class="s1">:]] = </span><span class="s2">False</span>
    <span class="s1">flag = np.concatenate(([</span><span class="s2">False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">flag))</span>
    <span class="s4"># We need to take the point on the left as well (else we're missing it)</span>
    <span class="s1">flag[:-</span><span class="s5">1</span><span class="s1">] = flag[:-</span><span class="s5">1</span><span class="s1">] + flag[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">duplicates = a[sortidx][flag]</span>
    <span class="s2">if </span><span class="s1">return_index:</span>
        <span class="s2">return </span><span class="s1">(duplicates</span><span class="s2">, </span><span class="s1">sortidx[flag])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">duplicates</span>


<span class="s2">def </span><span class="s1">_join_by_dispatcher(</span>
        <span class="s1">key</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">jointype=</span><span class="s2">None, </span><span class="s1">r1postfix=</span><span class="s2">None, </span><span class="s1">r2postfix=</span><span class="s2">None,</span>
        <span class="s1">defaults=</span><span class="s2">None, </span><span class="s1">usemask=</span><span class="s2">None, </span><span class="s1">asrecarray=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(r1</span><span class="s2">, </span><span class="s1">r2)</span>


<span class="s1">@array_function_dispatch(_join_by_dispatcher)</span>
<span class="s2">def </span><span class="s1">join_by(key</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">jointype=</span><span class="s3">'inner'</span><span class="s2">, </span><span class="s1">r1postfix=</span><span class="s3">'1'</span><span class="s2">, </span><span class="s1">r2postfix=</span><span class="s3">'2'</span><span class="s2">,</span>
            <span class="s1">defaults=</span><span class="s2">None, </span><span class="s1">usemask=</span><span class="s2">True, </span><span class="s1">asrecarray=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Join arrays `r1` and `r2` on key `key`. 
 
    The key should be either a string or a sequence of string corresponding 
    to the fields used to join the array.  An exception is raised if the 
    `key` field cannot be found in the two input arrays.  Neither `r1` nor 
    `r2` should have any duplicates along `key`: the presence of duplicates 
    will make the output quite unreliable. Note that duplicates are not 
    looked for by the algorithm. 
 
    Parameters 
    ---------- 
    key : {string, sequence} 
        A string or a sequence of strings corresponding to the fields used 
        for comparison. 
    r1, r2 : arrays 
        Structured arrays. 
    jointype : {'inner', 'outer', 'leftouter'}, optional 
        If 'inner', returns the elements common to both r1 and r2. 
        If 'outer', returns the common elements as well as the elements of 
        r1 not in r2 and the elements of not in r2. 
        If 'leftouter', returns the common elements and the elements of r1 
        not in r2. 
    r1postfix : string, optional 
        String appended to the names of the fields of r1 that are present 
        in r2 but absent of the key. 
    r2postfix : string, optional 
        String appended to the names of the fields of r2 that are present 
        in r1 but absent of the key. 
    defaults : {dictionary}, optional 
        Dictionary mapping field names to the corresponding default values. 
    usemask : {True, False}, optional 
        Whether to return a MaskedArray (or MaskedRecords is 
        `asrecarray==True`) or a ndarray. 
    asrecarray : {False, True}, optional 
        Whether to return a recarray (or MaskedRecords if `usemask==True`) 
        or just a flexible-type ndarray. 
 
    Notes 
    ----- 
    * The output is sorted along the key. 
    * A temporary array is formed by dropping the fields not in the key for 
      the two arrays and concatenating the result. This array is then 
      sorted, and the common entries selected. The output is constructed by 
      filling the fields with the selected entries. Matching is not 
      preserved if there are some duplicates... 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Check jointype</span>
    <span class="s2">if </span><span class="s1">jointype </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'inner'</span><span class="s2">, </span><span class="s3">'outer'</span><span class="s2">, </span><span class="s3">'leftouter'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The 'jointype' argument should be in 'inner', &quot;</span>
                <span class="s3">&quot;'outer' or 'leftouter' (got '%s' instead)&quot; </span><span class="s1">% jointype</span>
                <span class="s1">)</span>
    <span class="s4"># If we have a single key, put it in a tuple</span>
    <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">key = (key</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s4"># Check the keys</span>
    <span class="s2">if </span><span class="s1">len(set(key)) != len(key):</span>
        <span class="s1">dup = next(x </span><span class="s2">for </span><span class="s1">n</span><span class="s2">,</span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(key) </span><span class="s2">if </span><span class="s1">x </span><span class="s2">in </span><span class="s1">key[n+</span><span class="s5">1</span><span class="s1">:])</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;duplicate join key %r&quot; </span><span class="s1">% dup)</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">key:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">r1.dtype.names:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'r1 does not have key field %r' </span><span class="s1">% name)</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">r2.dtype.names:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'r2 does not have key field %r' </span><span class="s1">% name)</span>

    <span class="s4"># Make sure we work with ravelled arrays</span>
    <span class="s1">r1 = r1.ravel()</span>
    <span class="s1">r2 = r2.ravel()</span>
    <span class="s4"># Fixme: nb2 below is never used. Commenting out for pyflakes.</span>
    <span class="s4"># (nb1, nb2) = (len(r1), len(r2))</span>
    <span class="s1">nb1 = len(r1)</span>
    <span class="s1">(r1names</span><span class="s2">, </span><span class="s1">r2names) = (r1.dtype.names</span><span class="s2">, </span><span class="s1">r2.dtype.names)</span>

    <span class="s4"># Check the names for collision</span>
    <span class="s1">collisions = (set(r1names) &amp; set(r2names)) - set(key)</span>
    <span class="s2">if </span><span class="s1">collisions </span><span class="s2">and not </span><span class="s1">(r1postfix </span><span class="s2">or </span><span class="s1">r2postfix):</span>
        <span class="s1">msg = </span><span class="s3">&quot;r1 and r2 contain common names, r1postfix and r2postfix &quot;</span>
        <span class="s1">msg += </span><span class="s3">&quot;can't both be empty&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s4"># Make temporary arrays of just the keys</span>
    <span class="s4">#  (use order of keys in `r1` for back-compatibility)</span>
    <span class="s1">key1 = [ n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">r1names </span><span class="s2">if </span><span class="s1">n </span><span class="s2">in </span><span class="s1">key ]</span>
    <span class="s1">r1k = _keep_fields(r1</span><span class="s2">, </span><span class="s1">key1)</span>
    <span class="s1">r2k = _keep_fields(r2</span><span class="s2">, </span><span class="s1">key1)</span>

    <span class="s4"># Concatenate the two arrays for comparison</span>
    <span class="s1">aux = ma.concatenate((r1k</span><span class="s2">, </span><span class="s1">r2k))</span>
    <span class="s1">idx_sort = aux.argsort(order=key)</span>
    <span class="s1">aux = aux[idx_sort]</span>
    <span class="s4">#</span>
    <span class="s4"># Get the common keys</span>
    <span class="s1">flag_in = ma.concatenate(([</span><span class="s2">False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">aux[</span><span class="s5">1</span><span class="s1">:] == aux[:-</span><span class="s5">1</span><span class="s1">]))</span>
    <span class="s1">flag_in[:-</span><span class="s5">1</span><span class="s1">] = flag_in[</span><span class="s5">1</span><span class="s1">:] + flag_in[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">idx_in = idx_sort[flag_in]</span>
    <span class="s1">idx_1 = idx_in[(idx_in &lt; nb1)]</span>
    <span class="s1">idx_2 = idx_in[(idx_in &gt;= nb1)] - nb1</span>
    <span class="s1">(r1cmn</span><span class="s2">, </span><span class="s1">r2cmn) = (len(idx_1)</span><span class="s2">, </span><span class="s1">len(idx_2))</span>
    <span class="s2">if </span><span class="s1">jointype == </span><span class="s3">'inner'</span><span class="s1">:</span>
        <span class="s1">(r1spc</span><span class="s2">, </span><span class="s1">r2spc) = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">jointype == </span><span class="s3">'outer'</span><span class="s1">:</span>
        <span class="s1">idx_out = idx_sort[~flag_in]</span>
        <span class="s1">idx_1 = np.concatenate((idx_1</span><span class="s2">, </span><span class="s1">idx_out[(idx_out &lt; nb1)]))</span>
        <span class="s1">idx_2 = np.concatenate((idx_2</span><span class="s2">, </span><span class="s1">idx_out[(idx_out &gt;= nb1)] - nb1))</span>
        <span class="s1">(r1spc</span><span class="s2">, </span><span class="s1">r2spc) = (len(idx_1) - r1cmn</span><span class="s2">, </span><span class="s1">len(idx_2) - r2cmn)</span>
    <span class="s2">elif </span><span class="s1">jointype == </span><span class="s3">'leftouter'</span><span class="s1">:</span>
        <span class="s1">idx_out = idx_sort[~flag_in]</span>
        <span class="s1">idx_1 = np.concatenate((idx_1</span><span class="s2">, </span><span class="s1">idx_out[(idx_out &lt; nb1)]))</span>
        <span class="s1">(r1spc</span><span class="s2">, </span><span class="s1">r2spc) = (len(idx_1) - r1cmn</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s4"># Select the entries from each input</span>
    <span class="s1">(s1</span><span class="s2">, </span><span class="s1">s2) = (r1[idx_1]</span><span class="s2">, </span><span class="s1">r2[idx_2])</span>
    <span class="s4">#</span>
    <span class="s4"># Build the new description of the output array .......</span>
    <span class="s4"># Start with the key fields</span>
    <span class="s1">ndtype = _get_fieldspec(r1k.dtype)</span>

    <span class="s4"># Add the fields from r1</span>
    <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">fdtype </span><span class="s2">in </span><span class="s1">_get_fieldspec(r1.dtype):</span>
        <span class="s2">if </span><span class="s1">fname </span><span class="s2">not in </span><span class="s1">key:</span>
            <span class="s1">ndtype.append((fname</span><span class="s2">, </span><span class="s1">fdtype))</span>

    <span class="s4"># Add the fields from r2</span>
    <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">fdtype </span><span class="s2">in </span><span class="s1">_get_fieldspec(r2.dtype):</span>
        <span class="s4"># Have we seen the current name already ?</span>
        <span class="s4"># we need to rebuild this list every time</span>
        <span class="s1">names = list(name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">ndtype)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">nameidx = names.index(fname)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s4">#... we haven't: just add the description to the current list</span>
            <span class="s1">ndtype.append((fname</span><span class="s2">, </span><span class="s1">fdtype))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># collision</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">cdtype = ndtype[nameidx]</span>
            <span class="s2">if </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">key:</span>
                <span class="s4"># The current field is part of the key: take the largest dtype</span>
                <span class="s1">ndtype[nameidx] = (fname</span><span class="s2">, </span><span class="s1">max(fdtype</span><span class="s2">, </span><span class="s1">cdtype))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># The current field is not part of the key: add the suffixes,</span>
                <span class="s4"># and place the new field adjacent to the old one</span>
                <span class="s1">ndtype[nameidx:nameidx + </span><span class="s5">1</span><span class="s1">] = [</span>
                    <span class="s1">(fname + r1postfix</span><span class="s2">, </span><span class="s1">cdtype)</span><span class="s2">,</span>
                    <span class="s1">(fname + r2postfix</span><span class="s2">, </span><span class="s1">fdtype)</span>
                <span class="s1">]</span>
    <span class="s4"># Rebuild a dtype from the new fields</span>
    <span class="s1">ndtype = np.dtype(ndtype)</span>
    <span class="s4"># Find the largest nb of common fields :</span>
    <span class="s4"># r1cmn and r2cmn should be equal, but...</span>
    <span class="s1">cmn = max(r1cmn</span><span class="s2">, </span><span class="s1">r2cmn)</span>
    <span class="s4"># Construct an empty array</span>
    <span class="s1">output = ma.masked_all((cmn + r1spc + r2spc</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=ndtype)</span>
    <span class="s1">names = output.dtype.names</span>
    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">r1names:</span>
        <span class="s1">selected = s1[f]</span>
        <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">names </span><span class="s2">or </span><span class="s1">(f </span><span class="s2">in </span><span class="s1">r2names </span><span class="s2">and not </span><span class="s1">r2postfix </span><span class="s2">and </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">key):</span>
            <span class="s1">f += r1postfix</span>
        <span class="s1">current = output[f]</span>
        <span class="s1">current[:r1cmn] = selected[:r1cmn]</span>
        <span class="s2">if </span><span class="s1">jointype </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'outer'</span><span class="s2">, </span><span class="s3">'leftouter'</span><span class="s1">):</span>
            <span class="s1">current[cmn:cmn + r1spc] = selected[r1cmn:]</span>
    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">r2names:</span>
        <span class="s1">selected = s2[f]</span>
        <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">names </span><span class="s2">or </span><span class="s1">(f </span><span class="s2">in </span><span class="s1">r1names </span><span class="s2">and not </span><span class="s1">r1postfix </span><span class="s2">and </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">key):</span>
            <span class="s1">f += r2postfix</span>
        <span class="s1">current = output[f]</span>
        <span class="s1">current[:r2cmn] = selected[:r2cmn]</span>
        <span class="s2">if </span><span class="s1">(jointype == </span><span class="s3">'outer'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">r2spc:</span>
            <span class="s1">current[-r2spc:] = selected[r2cmn:]</span>
    <span class="s4"># Sort and finalize the output</span>
    <span class="s1">output.sort(order=key)</span>
    <span class="s1">kwargs = dict(usemask=usemask</span><span class="s2">, </span><span class="s1">asrecarray=asrecarray)</span>
    <span class="s2">return </span><span class="s1">_fix_output(_fix_defaults(output</span><span class="s2">, </span><span class="s1">defaults)</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">_rec_join_dispatcher(</span>
        <span class="s1">key</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">jointype=</span><span class="s2">None, </span><span class="s1">r1postfix=</span><span class="s2">None, </span><span class="s1">r2postfix=</span><span class="s2">None,</span>
        <span class="s1">defaults=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(r1</span><span class="s2">, </span><span class="s1">r2)</span>


<span class="s1">@array_function_dispatch(_rec_join_dispatcher)</span>
<span class="s2">def </span><span class="s1">rec_join(key</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">jointype=</span><span class="s3">'inner'</span><span class="s2">, </span><span class="s1">r1postfix=</span><span class="s3">'1'</span><span class="s2">, </span><span class="s1">r2postfix=</span><span class="s3">'2'</span><span class="s2">,</span>
             <span class="s1">defaults=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Join arrays `r1` and `r2` on keys. 
    Alternative to join_by, that always returns a np.recarray. 
 
    See Also 
    -------- 
    join_by : equivalent function 
    &quot;&quot;&quot;</span>
    <span class="s1">kwargs = dict(jointype=jointype</span><span class="s2">, </span><span class="s1">r1postfix=r1postfix</span><span class="s2">, </span><span class="s1">r2postfix=r2postfix</span><span class="s2">,</span>
                  <span class="s1">defaults=defaults</span><span class="s2">, </span><span class="s1">usemask=</span><span class="s2">False, </span><span class="s1">asrecarray=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">join_by(key</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>