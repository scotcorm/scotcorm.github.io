<html>
<head>
<title>test_mem_policy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_mem_policy.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">asyncio</span>
<span class="s0">import </span><span class="s1">gc</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">extbuild</span><span class="s0">, </span><span class="s1">assert_warns</span>
<span class="s0">import </span><span class="s1">sys</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">get_module(tmp_path):</span>
    <span class="s2">&quot;&quot;&quot; Add a memory policy that returns a false pointer 64 bytes into the 
    actual allocation, and fill the prefix with some text. Then check at each 
    memory manipulation that the prefix exists, to make sure all alloc/realloc/ 
    free/calloc go via the functions here. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">'cygwin'</span><span class="s1">):</span>
        <span class="s1">pytest.skip(</span><span class="s3">'link fails on cygwin'</span><span class="s1">)</span>
    <span class="s1">functions = [</span>
        <span class="s1">(</span><span class="s3">&quot;get_default_policy&quot;</span><span class="s0">, </span><span class="s3">&quot;METH_NOARGS&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;&quot; 
             Py_INCREF(PyDataMem_DefaultHandler); 
             return PyDataMem_DefaultHandler; 
         &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;set_secret_data_policy&quot;</span><span class="s0">, </span><span class="s3">&quot;METH_NOARGS&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;&quot; 
             PyObject *secret_data = 
                 PyCapsule_New(&amp;secret_data_handler, &quot;mem_handler&quot;, NULL); 
             if (secret_data == NULL) { 
                 return NULL; 
             } 
             PyObject *old = PyDataMem_SetHandler(secret_data); 
             Py_DECREF(secret_data); 
             return old; 
         &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;set_old_policy&quot;</span><span class="s0">, </span><span class="s3">&quot;METH_O&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;&quot; 
             PyObject *old; 
             if (args != NULL &amp;&amp; PyCapsule_CheckExact(args)) { 
                 old = PyDataMem_SetHandler(args); 
             } 
             else { 
                 old = PyDataMem_SetHandler(NULL); 
             } 
             return old; 
         &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;get_array&quot;</span><span class="s0">, </span><span class="s3">&quot;METH_NOARGS&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;&quot; 
            char *buf = (char *)malloc(20); 
            npy_intp dims[1]; 
            dims[0] = 20; 
            PyArray_Descr *descr =  PyArray_DescrNewFromType(NPY_UINT8); 
            return PyArray_NewFromDescr(&amp;PyArray_Type, descr, 1, dims, NULL, 
                                        buf, NPY_ARRAY_WRITEABLE, NULL); 
         &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;set_own&quot;</span><span class="s0">, </span><span class="s3">&quot;METH_O&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;&quot; 
            if (!PyArray_Check(args)) { 
                PyErr_SetString(PyExc_ValueError, 
                             &quot;need an ndarray&quot;); 
                return NULL; 
            } 
            PyArray_ENABLEFLAGS((PyArrayObject*)args, NPY_ARRAY_OWNDATA); 
            // Maybe try this too? 
            // PyArray_BASE(PyArrayObject *)args) = NULL; 
            Py_RETURN_NONE; 
         &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;get_array_with_base&quot;</span><span class="s0">, </span><span class="s3">&quot;METH_NOARGS&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;&quot; 
            char *buf = (char *)malloc(20); 
            npy_intp dims[1]; 
            dims[0] = 20; 
            PyArray_Descr *descr =  PyArray_DescrNewFromType(NPY_UINT8); 
            PyObject *arr = PyArray_NewFromDescr(&amp;PyArray_Type, descr, 1, dims, 
                                                 NULL, buf, 
                                                 NPY_ARRAY_WRITEABLE, NULL); 
            if (arr == NULL) return NULL; 
            PyObject *obj = PyCapsule_New(buf, &quot;buf capsule&quot;, 
                                          (PyCapsule_Destructor)&amp;warn_on_free); 
            if (obj == NULL) { 
                Py_DECREF(arr); 
                return NULL; 
            } 
            if (PyArray_SetBaseObject((PyArrayObject *)arr, obj) &lt; 0) { 
                Py_DECREF(arr); 
                Py_DECREF(obj); 
                return NULL; 
            } 
            return arr; 
 
         &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">prologue = </span><span class="s3">''' 
        #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION 
        #include &lt;numpy/arrayobject.h&gt; 
        /* 
         * This struct allows the dynamic configuration of the allocator funcs 
         * of the `secret_data_allocator`. It is provided here for 
         * demonstration purposes, as a valid `ctx` use-case scenario. 
         */ 
        typedef struct { 
            void *(*malloc)(size_t); 
            void *(*calloc)(size_t, size_t); 
            void *(*realloc)(void *, size_t); 
            void (*free)(void *); 
        } SecretDataAllocatorFuncs; 
 
        NPY_NO_EXPORT void * 
        shift_alloc(void *ctx, size_t sz) { 
            SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx; 
            char *real = (char *)funcs-&gt;malloc(sz + 64); 
            if (real == NULL) { 
                return NULL; 
            } 
            snprintf(real, 64, &quot;originally allocated %ld&quot;, (unsigned long)sz); 
            return (void *)(real + 64); 
        } 
        NPY_NO_EXPORT void * 
        shift_zero(void *ctx, size_t sz, size_t cnt) { 
            SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx; 
            char *real = (char *)funcs-&gt;calloc(sz + 64, cnt); 
            if (real == NULL) { 
                return NULL; 
            } 
            snprintf(real, 64, &quot;originally allocated %ld via zero&quot;, 
                     (unsigned long)sz); 
            return (void *)(real + 64); 
        } 
        NPY_NO_EXPORT void 
        shift_free(void *ctx, void * p, npy_uintp sz) { 
            SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx; 
            if (p == NULL) { 
                return ; 
            } 
            char *real = (char *)p - 64; 
            if (strncmp(real, &quot;originally allocated&quot;, 20) != 0) { 
                fprintf(stdout, &quot;uh-oh, unmatched shift_free, &quot; 
                        &quot;no appropriate prefix</span><span class="s0">\\</span><span class="s3">n&quot;); 
                /* Make C runtime crash by calling free on the wrong address */ 
                funcs-&gt;free((char *)p + 10); 
                /* funcs-&gt;free(real); */ 
            } 
            else { 
                npy_uintp i = (npy_uintp)atoi(real +20); 
                if (i != sz) { 
                    fprintf(stderr, &quot;uh-oh, unmatched shift_free&quot; 
                            &quot;(ptr, %ld) but allocated %ld</span><span class="s0">\\</span><span class="s3">n&quot;, sz, i); 
                    /* This happens in some places, only print */ 
                    funcs-&gt;free(real); 
                } 
                else { 
                    funcs-&gt;free(real); 
                } 
            } 
        } 
        NPY_NO_EXPORT void * 
        shift_realloc(void *ctx, void * p, npy_uintp sz) { 
            SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx; 
            if (p != NULL) { 
                char *real = (char *)p - 64; 
                if (strncmp(real, &quot;originally allocated&quot;, 20) != 0) { 
                    fprintf(stdout, &quot;uh-oh, unmatched shift_realloc</span><span class="s0">\\</span><span class="s3">n&quot;); 
                    return realloc(p, sz); 
                } 
                return (void *)((char *)funcs-&gt;realloc(real, sz + 64) + 64); 
            } 
            else { 
                char *real = (char *)funcs-&gt;realloc(p, sz + 64); 
                if (real == NULL) { 
                    return NULL; 
                } 
                snprintf(real, 64, &quot;originally allocated &quot; 
                         &quot;%ld  via realloc&quot;, (unsigned long)sz); 
                return (void *)(real + 64); 
            } 
        } 
        /* As an example, we use the standard {m|c|re}alloc/free funcs. */ 
        static SecretDataAllocatorFuncs secret_data_handler_ctx = { 
            malloc, 
            calloc, 
            realloc, 
            free 
        }; 
        static PyDataMem_Handler secret_data_handler = { 
            &quot;secret_data_allocator&quot;, 
            1, 
            { 
                &amp;secret_data_handler_ctx, /* ctx */ 
                shift_alloc,              /* malloc */ 
                shift_zero,               /* calloc */ 
                shift_realloc,            /* realloc */ 
                shift_free                /* free */ 
            } 
        }; 
        void warn_on_free(void *capsule) { 
            PyErr_WarnEx(PyExc_UserWarning, &quot;in warn_on_free&quot;, 1); 
            void * obj = PyCapsule_GetPointer(capsule, 
                                              PyCapsule_GetName(capsule)); 
            free(obj); 
        }; 
        '''</span>
    <span class="s1">more_init = </span><span class="s3">&quot;import_array();&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">import </span><span class="s1">mem_policy</span>
        <span class="s0">return </span><span class="s1">mem_policy</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s0">pass</span>
    <span class="s4"># if it does not exist, build and load it</span>
    <span class="s0">return </span><span class="s1">extbuild.build_and_import_extension(</span><span class="s3">'mem_policy'</span><span class="s0">,</span>
                                               <span class="s1">functions</span><span class="s0">,</span>
                                               <span class="s1">prologue=prologue</span><span class="s0">,</span>
                                               <span class="s1">include_dirs=[np.get_include()]</span><span class="s0">,</span>
                                               <span class="s1">build_dir=tmp_path</span><span class="s0">,</span>
                                               <span class="s1">more_init=more_init)</span>


<span class="s0">def </span><span class="s1">test_set_policy(get_module):</span>

    <span class="s1">get_handler_name = np.core.multiarray.get_handler_name</span>
    <span class="s1">get_handler_version = np.core.multiarray.get_handler_version</span>
    <span class="s1">orig_policy_name = get_handler_name()</span>

    <span class="s1">a = np.arange(</span><span class="s5">10</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))  </span><span class="s4"># a doesn't own its own data</span>
    <span class="s0">assert </span><span class="s1">get_handler_name(a) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">get_handler_version(a) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">get_handler_name(a.base) == orig_policy_name</span>
    <span class="s0">assert </span><span class="s1">get_handler_version(a.base) == </span><span class="s5">1</span>

    <span class="s1">orig_policy = get_module.set_secret_data_policy()</span>

    <span class="s1">b = np.arange(</span><span class="s5">10</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))  </span><span class="s4"># b doesn't own its own data</span>
    <span class="s0">assert </span><span class="s1">get_handler_name(b) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">get_handler_version(b) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">get_handler_name(b.base) == </span><span class="s3">'secret_data_allocator'</span>
    <span class="s0">assert </span><span class="s1">get_handler_version(b.base) == </span><span class="s5">1</span>

    <span class="s0">if </span><span class="s1">orig_policy_name == </span><span class="s3">'default_allocator'</span><span class="s1">:</span>
        <span class="s1">get_module.set_old_policy(</span><span class="s0">None</span><span class="s1">)  </span><span class="s4"># tests PyDataMem_SetHandler(NULL)</span>
        <span class="s0">assert </span><span class="s1">get_handler_name() == </span><span class="s3">'default_allocator'</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">get_module.set_old_policy(orig_policy)</span>
        <span class="s0">assert </span><span class="s1">get_handler_name() == orig_policy_name</span>


<span class="s0">def </span><span class="s1">test_default_policy_singleton(get_module):</span>
    <span class="s1">get_handler_name = np.core.multiarray.get_handler_name</span>

    <span class="s4"># set the policy to default</span>
    <span class="s1">orig_policy = get_module.set_old_policy(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">get_handler_name() == </span><span class="s3">'default_allocator'</span>

    <span class="s4"># re-set the policy to default</span>
    <span class="s1">def_policy_1 = get_module.set_old_policy(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">get_handler_name() == </span><span class="s3">'default_allocator'</span>

    <span class="s4"># set the policy to original</span>
    <span class="s1">def_policy_2 = get_module.set_old_policy(orig_policy)</span>

    <span class="s4"># since default policy is a singleton,</span>
    <span class="s4"># these should be the same object</span>
    <span class="s0">assert </span><span class="s1">def_policy_1 </span><span class="s0">is </span><span class="s1">def_policy_2 </span><span class="s0">is </span><span class="s1">get_module.get_default_policy()</span>


<span class="s0">def </span><span class="s1">test_policy_propagation(get_module):</span>
    <span class="s4"># The memory policy goes hand-in-hand with flags.owndata</span>

    <span class="s0">class </span><span class="s1">MyArr(np.ndarray):</span>
        <span class="s0">pass</span>

    <span class="s1">get_handler_name = np.core.multiarray.get_handler_name</span>
    <span class="s1">orig_policy_name = get_handler_name()</span>
    <span class="s1">a = np.arange(</span><span class="s5">10</span><span class="s1">).view(MyArr).reshape((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">get_handler_name(a) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">a.flags.owndata </span><span class="s0">is False</span>

    <span class="s0">assert </span><span class="s1">get_handler_name(a.base) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">a.base.flags.owndata </span><span class="s0">is False</span>

    <span class="s0">assert </span><span class="s1">get_handler_name(a.base.base) == orig_policy_name</span>
    <span class="s0">assert </span><span class="s1">a.base.base.flags.owndata </span><span class="s0">is True</span>


<span class="s0">async def </span><span class="s1">concurrent_context1(get_module</span><span class="s0">, </span><span class="s1">orig_policy_name</span><span class="s0">, </span><span class="s1">event):</span>
    <span class="s0">if </span><span class="s1">orig_policy_name == </span><span class="s3">'default_allocator'</span><span class="s1">:</span>
        <span class="s1">get_module.set_secret_data_policy()</span>
        <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == </span><span class="s3">'secret_data_allocator'</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">get_module.set_old_policy(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == </span><span class="s3">'default_allocator'</span>
    <span class="s1">event.set()</span>


<span class="s0">async def </span><span class="s1">concurrent_context2(get_module</span><span class="s0">, </span><span class="s1">orig_policy_name</span><span class="s0">, </span><span class="s1">event):</span>
    <span class="s0">await </span><span class="s1">event.wait()</span>
    <span class="s4"># the policy is not affected by changes in parallel contexts</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == orig_policy_name</span>
    <span class="s4"># change policy in the child context</span>
    <span class="s0">if </span><span class="s1">orig_policy_name == </span><span class="s3">'default_allocator'</span><span class="s1">:</span>
        <span class="s1">get_module.set_secret_data_policy()</span>
        <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == </span><span class="s3">'secret_data_allocator'</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">get_module.set_old_policy(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == </span><span class="s3">'default_allocator'</span>


<span class="s0">async def </span><span class="s1">async_test_context_locality(get_module):</span>
    <span class="s1">orig_policy_name = np.core.multiarray.get_handler_name()</span>

    <span class="s1">event = asyncio.Event()</span>
    <span class="s4"># the child contexts inherit the parent policy</span>
    <span class="s1">concurrent_task1 = asyncio.create_task(</span>
        <span class="s1">concurrent_context1(get_module</span><span class="s0">, </span><span class="s1">orig_policy_name</span><span class="s0">, </span><span class="s1">event))</span>
    <span class="s1">concurrent_task2 = asyncio.create_task(</span>
        <span class="s1">concurrent_context2(get_module</span><span class="s0">, </span><span class="s1">orig_policy_name</span><span class="s0">, </span><span class="s1">event))</span>
    <span class="s0">await </span><span class="s1">concurrent_task1</span>
    <span class="s0">await </span><span class="s1">concurrent_task2</span>

    <span class="s4"># the parent context is not affected by child policy changes</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == orig_policy_name</span>


<span class="s0">def </span><span class="s1">test_context_locality(get_module):</span>
    <span class="s0">if </span><span class="s1">(sys.implementation.name == </span><span class="s3">'pypy'</span>
            <span class="s0">and </span><span class="s1">sys.pypy_version_info[:</span><span class="s5">3</span><span class="s1">] &lt; (</span><span class="s5">7</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)):</span>
        <span class="s1">pytest.skip(</span><span class="s3">'no context-locality support in PyPy &lt; 7.3.6'</span><span class="s1">)</span>
    <span class="s1">asyncio.run(async_test_context_locality(get_module))</span>


<span class="s0">def </span><span class="s1">concurrent_thread1(get_module</span><span class="s0">, </span><span class="s1">event):</span>
    <span class="s1">get_module.set_secret_data_policy()</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == </span><span class="s3">'secret_data_allocator'</span>
    <span class="s1">event.set()</span>


<span class="s0">def </span><span class="s1">concurrent_thread2(get_module</span><span class="s0">, </span><span class="s1">event):</span>
    <span class="s1">event.wait()</span>
    <span class="s4"># the policy is not affected by changes in parallel threads</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == </span><span class="s3">'default_allocator'</span>
    <span class="s4"># change policy in the child thread</span>
    <span class="s1">get_module.set_secret_data_policy()</span>


<span class="s0">def </span><span class="s1">test_thread_locality(get_module):</span>
    <span class="s1">orig_policy_name = np.core.multiarray.get_handler_name()</span>

    <span class="s1">event = threading.Event()</span>
    <span class="s4"># the child threads do not inherit the parent policy</span>
    <span class="s1">concurrent_task1 = threading.Thread(target=concurrent_thread1</span><span class="s0">,</span>
                                        <span class="s1">args=(get_module</span><span class="s0">, </span><span class="s1">event))</span>
    <span class="s1">concurrent_task2 = threading.Thread(target=concurrent_thread2</span><span class="s0">,</span>
                                        <span class="s1">args=(get_module</span><span class="s0">, </span><span class="s1">event))</span>
    <span class="s1">concurrent_task1.start()</span>
    <span class="s1">concurrent_task2.start()</span>
    <span class="s1">concurrent_task1.join()</span>
    <span class="s1">concurrent_task2.join()</span>

    <span class="s4"># the parent thread is not affected by child policy changes</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name() == orig_policy_name</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_new_policy(get_module):</span>
    <span class="s1">a = np.arange(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">orig_policy_name = np.core.multiarray.get_handler_name(a)</span>

    <span class="s1">orig_policy = get_module.set_secret_data_policy()</span>

    <span class="s1">b = np.arange(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name(b) == </span><span class="s3">'secret_data_allocator'</span>

    <span class="s4"># test array manipulation. This is slow</span>
    <span class="s0">if </span><span class="s1">orig_policy_name == </span><span class="s3">'default_allocator'</span><span class="s1">:</span>
        <span class="s4"># when the np.core.test tests recurse into this test, the</span>
        <span class="s4"># policy will be set so this &quot;if&quot; will be false, preventing</span>
        <span class="s4"># infinite recursion</span>
        <span class="s4">#</span>
        <span class="s4"># if needed, debug this by</span>
        <span class="s4"># - running tests with -- -s (to not capture stdout/stderr</span>
        <span class="s4"># - setting extra_argv=['-vv'] here</span>
        <span class="s0">assert </span><span class="s1">np.core.test(</span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">2</span><span class="s0">, </span><span class="s1">extra_argv=[</span><span class="s3">'-vv'</span><span class="s1">])</span>
        <span class="s4"># also try the ma tests, the pickling test is quite tricky</span>
        <span class="s0">assert </span><span class="s1">np.ma.test(</span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">2</span><span class="s0">, </span><span class="s1">extra_argv=[</span><span class="s3">'-vv'</span><span class="s1">])</span>

    <span class="s1">get_module.set_old_policy(orig_policy)</span>

    <span class="s1">c = np.arange(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name(c) == orig_policy_name</span>

<span class="s1">@pytest.mark.xfail(sys.implementation.name == </span><span class="s3">&quot;pypy&quot;</span><span class="s0">,</span>
                   <span class="s1">reason=(</span><span class="s3">&quot;bad interaction between getenv and &quot;</span>
                           <span class="s3">&quot;os.environ inside pytest&quot;</span><span class="s1">))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;policy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;0&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s0">, None</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_switch_owner(get_module</span><span class="s0">, </span><span class="s1">policy):</span>
    <span class="s1">a = get_module.get_array()</span>
    <span class="s0">assert </span><span class="s1">np.core.multiarray.get_handler_name(a) </span><span class="s0">is None</span>
    <span class="s1">get_module.set_own(a)</span>
    <span class="s1">oldval = os.environ.get(</span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">policy </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY' </span><span class="s0">in </span><span class="s1">os.environ:</span>
            <span class="s1">os.environ.pop(</span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY'</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">os.environ[</span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY'</span><span class="s1">] = policy</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s4"># The policy should be NULL, so we have to assume we can call</span>
        <span class="s4"># &quot;free&quot;.  A warning is given if the policy == &quot;1&quot;</span>
        <span class="s0">if </span><span class="s1">policy == </span><span class="s3">&quot;1&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">assert_warns(RuntimeWarning) </span><span class="s0">as </span><span class="s1">w:</span>
                <span class="s0">del </span><span class="s1">a</span>
                <span class="s1">gc.collect()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">del </span><span class="s1">a</span>
            <span class="s1">gc.collect()</span>

    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">oldval </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY' </span><span class="s0">in </span><span class="s1">os.environ:</span>
                <span class="s1">os.environ.pop(</span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">os.environ[</span><span class="s3">'NUMPY_WARN_IF_NO_MEM_POLICY'</span><span class="s1">] = oldval</span>

<span class="s0">def </span><span class="s1">test_owner_is_base(get_module):</span>
    <span class="s1">a = get_module.get_array_with_base()</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'warn_on_free'</span><span class="s1">):</span>
        <span class="s0">del </span><span class="s1">a</span>
        <span class="s1">gc.collect()</span>
</pre>
</body>
</html>