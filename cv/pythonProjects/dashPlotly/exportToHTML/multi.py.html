<html>
<head>
<title>multi.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
multi.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>
<span class="s0">from </span><span class="s1">sys </span><span class="s0">import </span><span class="s1">getsizeof</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Collection</span><span class="s0">,</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._config </span><span class="s0">import </span><span class="s1">get_option</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">algos </span><span class="s0">as </span><span class="s1">libalgos</span><span class="s0">,</span>
    <span class="s1">index </span><span class="s0">as </span><span class="s1">libindex</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.hashtable </span><span class="s0">import </span><span class="s1">duplicated</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">AnyArrayLike</span><span class="s0">,</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">F</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">Shape</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat.numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">InvalidIndexError</span><span class="s0">,</span>
    <span class="s1">PerformanceWarning</span><span class="s0">,</span>
    <span class="s1">UnsortedIndexError</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s0">,</span>
    <span class="s1">cache_readonly</span><span class="s0">,</span>
    <span class="s1">deprecate_nonkeyword_arguments</span><span class="s0">,</span>
    <span class="s1">doc</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s0">import </span><span class="s1">coerce_indexer_dtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_int64</span><span class="s0">,</span>
    <span class="s1">ensure_platform_int</span><span class="s0">,</span>
    <span class="s1">is_categorical_dtype</span><span class="s0">,</span>
    <span class="s1">is_hashable</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_iterator</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s0">,</span>
    <span class="s1">ABCDatetimeIndex</span><span class="s0">,</span>
    <span class="s1">ABCTimedeltaIndex</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array_equivalent</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">pandas.core.algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">Categorical</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.categorical </span><span class="s0">import </span><span class="s1">factorize_from_iterables</span>
<span class="s0">import </span><span class="s1">pandas.core.common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">import </span><span class="s1">pandas.core.indexes.base </span><span class="s0">as </span><span class="s1">ibase</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">_index_shared_docs</span><span class="s0">,</span>
    <span class="s1">ensure_index</span><span class="s0">,</span>
    <span class="s1">get_unanimous_names</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.frozen </span><span class="s0">import </span><span class="s1">FrozenList</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.numeric </span><span class="s0">import </span><span class="s1">Int64Index</span>
<span class="s0">from </span><span class="s1">pandas.core.ops.invalid </span><span class="s0">import </span><span class="s1">make_invalid_op</span>
<span class="s0">from </span><span class="s1">pandas.core.sorting </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">get_group_index</span><span class="s0">,</span>
    <span class="s1">indexer_from_factorized</span><span class="s0">,</span>
    <span class="s1">lexsort_indexer</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.io.formats.printing </span><span class="s0">import </span><span class="s1">pprint_thing</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">CategoricalIndex</span><span class="s0">,</span>
        <span class="s1">DataFrame</span><span class="s0">,</span>
        <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">)</span>

<span class="s1">_index_doc_kwargs = dict(ibase._index_doc_kwargs)</span>
<span class="s1">_index_doc_kwargs.update(</span>
    <span class="s1">{</span><span class="s2">&quot;klass&quot;</span><span class="s1">: </span><span class="s2">&quot;MultiIndex&quot;</span><span class="s0">, </span><span class="s2">&quot;target_klass&quot;</span><span class="s1">: </span><span class="s2">&quot;MultiIndex or list of tuples&quot;</span><span class="s1">}</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">MultiIndexUIntEngine(libindex.BaseMultiIndexCodesEngine</span><span class="s0">, </span><span class="s1">libindex.UInt64Engine):</span>
    <span class="s3">&quot;&quot;&quot; 
    This class manages a MultiIndex by mapping label combinations to positive 
    integers. 
    &quot;&quot;&quot;</span>

    <span class="s1">_base = libindex.UInt64Engine</span>

    <span class="s0">def </span><span class="s1">_codes_to_ints(self</span><span class="s0">, </span><span class="s1">codes):</span>
        <span class="s3">&quot;&quot;&quot; 
        Transform combination(s) of uint64 in one uint64 (each), in a strictly 
        monotonic way (i.e. respecting the lexicographic order of integer 
        combinations): see BaseMultiIndexCodesEngine documentation. 
 
        Parameters 
        ---------- 
        codes : 1- or 2-dimensional array of dtype uint64 
            Combinations of integers (one per row) 
 
        Returns 
        ------- 
        scalar or 1-dimensional array, of dtype uint64 
            Integer(s) representing one combination (each). 
        &quot;&quot;&quot;</span>
        <span class="s4"># Shift the representation of each level by the pre-calculated number</span>
        <span class="s4"># of bits:</span>
        <span class="s1">codes &lt;&lt;= self.offsets</span>

        <span class="s4"># Now sum and OR are in fact interchangeable. This is a simple</span>
        <span class="s4"># composition of the (disjunct) significant bits of each level (i.e.</span>
        <span class="s4"># each column in &quot;codes&quot;) in a single positive integer:</span>
        <span class="s0">if </span><span class="s1">codes.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># Single key</span>
            <span class="s0">return </span><span class="s1">np.bitwise_or.reduce(codes)</span>

        <span class="s4"># Multiple keys</span>
        <span class="s0">return </span><span class="s1">np.bitwise_or.reduce(codes</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">MultiIndexPyIntEngine(libindex.BaseMultiIndexCodesEngine</span><span class="s0">, </span><span class="s1">libindex.ObjectEngine):</span>
    <span class="s3">&quot;&quot;&quot; 
    This class manages those (extreme) cases in which the number of possible 
    label combinations overflows the 64 bits integers, and uses an ObjectEngine 
    containing Python integers. 
    &quot;&quot;&quot;</span>

    <span class="s1">_base = libindex.ObjectEngine</span>

    <span class="s0">def </span><span class="s1">_codes_to_ints(self</span><span class="s0">, </span><span class="s1">codes):</span>
        <span class="s3">&quot;&quot;&quot; 
        Transform combination(s) of uint64 in one Python integer (each), in a 
        strictly monotonic way (i.e. respecting the lexicographic order of 
        integer combinations): see BaseMultiIndexCodesEngine documentation. 
 
        Parameters 
        ---------- 
        codes : 1- or 2-dimensional array of dtype uint64 
            Combinations of integers (one per row) 
 
        Returns 
        ------- 
        int, or 1-dimensional array of dtype object 
            Integer(s) representing one combination (each). 
        &quot;&quot;&quot;</span>
        <span class="s4"># Shift the representation of each level by the pre-calculated number</span>
        <span class="s4"># of bits. Since this can overflow uint64, first make sure we are</span>
        <span class="s4"># working with Python integers:</span>
        <span class="s1">codes = codes.astype(</span><span class="s2">&quot;object&quot;</span><span class="s1">) &lt;&lt; self.offsets</span>

        <span class="s4"># Now sum and OR are in fact interchangeable. This is a simple</span>
        <span class="s4"># composition of the (disjunct) significant bits of each level (i.e.</span>
        <span class="s4"># each column in &quot;codes&quot;) in a single positive integer (per row):</span>
        <span class="s0">if </span><span class="s1">codes.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># Single key</span>
            <span class="s0">return </span><span class="s1">np.bitwise_or.reduce(codes)</span>

        <span class="s4"># Multiple keys</span>
        <span class="s0">return </span><span class="s1">np.bitwise_or.reduce(codes</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">names_compat(meth: F) -&gt; F:</span>
    <span class="s3">&quot;&quot;&quot; 
    A decorator to allow either `name` or `names` keyword but not both. 
 
    This makes it easier to share code with base class. 
    &quot;&quot;&quot;</span>

    <span class="s1">@wraps(meth)</span>
    <span class="s0">def </span><span class="s1">new_meth(self_or_cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s2">&quot;name&quot; </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s2">&quot;names&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Can only provide one of `names` and `name`&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s2">&quot;name&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;names&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;name&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">meth(self_or_cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">new_meth)</span>


<span class="s0">class </span><span class="s1">MultiIndex(Index):</span>
    <span class="s3">&quot;&quot;&quot; 
    A multi-level, or hierarchical, index object for pandas objects. 
 
    Parameters 
    ---------- 
    levels : sequence of arrays 
        The unique labels for each level. 
    codes : sequence of arrays 
        Integers for each level designating which label at each location. 
    sortorder : optional int 
        Level of sortedness (must be lexicographically sorted by that 
        level). 
    names : optional sequence of objects 
        Names for each of the index levels. (name is accepted for compat). 
    copy : bool, default False 
        Copy the meta-data. 
    verify_integrity : bool, default True 
        Check that the levels/codes are consistent and valid. 
 
    Attributes 
    ---------- 
    names 
    levels 
    codes 
    nlevels 
    levshape 
 
    Methods 
    ------- 
    from_arrays 
    from_tuples 
    from_product 
    from_frame 
    set_levels 
    set_codes 
    to_frame 
    to_flat_index 
    sortlevel 
    droplevel 
    swaplevel 
    reorder_levels 
    remove_unused_levels 
    get_locs 
 
    See Also 
    -------- 
    MultiIndex.from_arrays  : Convert list of arrays to MultiIndex. 
    MultiIndex.from_product : Create a MultiIndex from the cartesian product 
                              of iterables. 
    MultiIndex.from_tuples  : Convert list of tuples to a MultiIndex. 
    MultiIndex.from_frame   : Make a MultiIndex from a DataFrame. 
    Index : The base pandas Index type. 
 
    Notes 
    ----- 
    See the `user guide 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html&gt;`__ 
    for more. 
 
    Examples 
    -------- 
    A new ``MultiIndex`` is typically constructed using one of the helper 
    methods :meth:`MultiIndex.from_arrays`, :meth:`MultiIndex.from_product` 
    and :meth:`MultiIndex.from_tuples`. For example (using ``.from_arrays``): 
 
    &gt;&gt;&gt; arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']] 
    &gt;&gt;&gt; pd.MultiIndex.from_arrays(arrays, names=('number', 'color')) 
    MultiIndex([(1,  'red'), 
                (1, 'blue'), 
                (2,  'red'), 
                (2, 'blue')], 
               names=['number', 'color']) 
 
    See further examples for how to construct a MultiIndex in the doc strings 
    of the mentioned helper methods. 
    &quot;&quot;&quot;</span>

    <span class="s1">_hidden_attrs = Index._hidden_attrs | frozenset()</span>

    <span class="s4"># initialize to zero-length tuples to make everything work</span>
    <span class="s1">_typ = </span><span class="s2">&quot;multiindex&quot;</span>
    <span class="s1">_names = FrozenList()</span>
    <span class="s1">_levels = FrozenList()</span>
    <span class="s1">_codes = FrozenList()</span>
    <span class="s1">_comparables = [</span><span class="s2">&quot;names&quot;</span><span class="s1">]</span>

    <span class="s1">sortorder: int | </span><span class="s0">None</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Constructors</span>

    <span class="s0">def </span><span class="s1">__new__(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">levels=</span><span class="s0">None,</span>
        <span class="s1">codes=</span><span class="s0">None,</span>
        <span class="s1">sortorder=</span><span class="s0">None,</span>
        <span class="s1">names=</span><span class="s0">None,</span>
        <span class="s1">dtype=</span><span class="s0">None,</span>
        <span class="s1">copy=</span><span class="s0">False,</span>
        <span class="s1">name=</span><span class="s0">None,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s0">True,</span>
    <span class="s1">):</span>

        <span class="s4"># compat with Index</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">names = name</span>
        <span class="s0">if </span><span class="s1">levels </span><span class="s0">is None or </span><span class="s1">codes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Must pass both levels and codes&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(levels) != len(codes):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Length of levels and codes must be the same.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(levels) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Must pass non-zero number of levels/codes&quot;</span><span class="s1">)</span>

        <span class="s1">result = object.__new__(cls)</span>
        <span class="s1">result._cache = {}</span>

        <span class="s4"># we've already validated levels and codes, so shortcut here</span>
        <span class="s1">result._set_levels(levels</span><span class="s0">, </span><span class="s1">copy=copy</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">result._set_codes(codes</span><span class="s0">, </span><span class="s1">copy=copy</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># Incompatible types in assignment (expression has type &quot;List[None]&quot;,</span>
        <span class="s4"># variable has type &quot;FrozenList&quot;)  [assignment]</span>
        <span class="s1">result._names = [</span><span class="s0">None</span><span class="s1">] * len(levels)  </span><span class="s4"># type: ignore[assignment]</span>
        <span class="s0">if </span><span class="s1">names </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># handles name validation</span>
            <span class="s1">result._set_names(names)</span>

        <span class="s0">if </span><span class="s1">sortorder </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">result.sortorder = int(sortorder)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result.sortorder = sortorder</span>

        <span class="s0">if </span><span class="s1">verify_integrity:</span>
            <span class="s1">new_codes = result._verify_integrity()</span>
            <span class="s1">result._codes = new_codes</span>

        <span class="s1">result._reset_identity()</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_validate_codes(self</span><span class="s0">, </span><span class="s1">level: list</span><span class="s0">, </span><span class="s1">code: list):</span>
        <span class="s3">&quot;&quot;&quot; 
        Reassign code values as -1 if their corresponding levels are NaN. 
 
        Parameters 
        ---------- 
        code : list 
            Code to reassign. 
        level : list 
            Level to check for missing values (NaN, NaT, None). 
 
        Returns 
        ------- 
        new code where code value = -1 if it corresponds 
        to a level with missing values (NaN, NaT, None). 
        &quot;&quot;&quot;</span>
        <span class="s1">null_mask = isna(level)</span>
        <span class="s0">if </span><span class="s1">np.any(null_mask):</span>
            <span class="s4"># Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;ndarray[Any, dtype[Any]]&quot;, variable has type &quot;List[Any]&quot;)</span>
            <span class="s1">code = np.where(null_mask[code]</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">code)  </span><span class="s4"># type: ignore[assignment]</span>
        <span class="s0">return </span><span class="s1">code</span>

    <span class="s0">def </span><span class="s1">_verify_integrity(self</span><span class="s0">, </span><span class="s1">codes: list | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">levels: list | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        codes : optional list 
            Codes to check for validity. Defaults to current codes. 
        levels : optional list 
            Levels to check for validity. Defaults to current levels. 
 
        Raises 
        ------ 
        ValueError 
            If length of levels and codes don't match, if the codes for any 
            level would exceed level bounds, or there are any duplicate levels. 
 
        Returns 
        ------- 
        new codes where code value = -1 if it corresponds to a 
        NaN level. 
        &quot;&quot;&quot;</span>
        <span class="s4"># NOTE: Currently does not check, among other things, that cached</span>
        <span class="s4"># nlevels matches nor that sortorder matches actually sortorder.</span>
        <span class="s1">codes = codes </span><span class="s0">or </span><span class="s1">self.codes</span>
        <span class="s1">levels = levels </span><span class="s0">or </span><span class="s1">self.levels</span>

        <span class="s0">if </span><span class="s1">len(levels) != len(codes):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Length of levels and codes must match. NOTE: &quot;</span>
                <span class="s2">&quot;this index is in an inconsistent state.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">codes_length = len(codes[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(level</span><span class="s0">, </span><span class="s1">level_codes) </span><span class="s0">in </span><span class="s1">enumerate(zip(levels</span><span class="s0">, </span><span class="s1">codes)):</span>
            <span class="s0">if </span><span class="s1">len(level_codes) != codes_length:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;Unequal code lengths: </span><span class="s0">{</span><span class="s1">[len(code_) </span><span class="s0">for </span><span class="s1">code_ </span><span class="s0">in </span><span class="s1">codes]</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(level_codes) </span><span class="s0">and </span><span class="s1">level_codes.max() &gt;= len(level):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;On level </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">, code max (</span><span class="s0">{</span><span class="s1">level_codes.max()</span><span class="s0">}</span><span class="s2">) &gt;= length of &quot;</span>
                    <span class="s2">f&quot;level (</span><span class="s0">{</span><span class="s1">len(level)</span><span class="s0">}</span><span class="s2">). NOTE: this index is in an &quot;</span>
                    <span class="s2">&quot;inconsistent state&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(level_codes) </span><span class="s0">and </span><span class="s1">level_codes.min() &lt; -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;On level </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">, code value (</span><span class="s0">{</span><span class="s1">level_codes.min()</span><span class="s0">}</span><span class="s2">) &lt; -1&quot;</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">level.is_unique:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;Level values must be unique: </span><span class="s0">{</span><span class="s1">list(level)</span><span class="s0">} </span><span class="s2">on level </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.sortorder </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.sortorder &gt; _lexsort_depth(self.codes</span><span class="s0">, </span><span class="s1">self.nlevels):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Value for sortorder must be inferior or equal to actual &quot;</span>
                    <span class="s2">f&quot;lexsort_depth: sortorder </span><span class="s0">{</span><span class="s1">self.sortorder</span><span class="s0">} </span><span class="s2">&quot;</span>
                    <span class="s2">f&quot;with lexsort_depth </span><span class="s0">{</span><span class="s1">_lexsort_depth(self.codes</span><span class="s0">, </span><span class="s1">self.nlevels)</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">)</span>

        <span class="s1">codes = [</span>
            <span class="s1">self._validate_codes(level</span><span class="s0">, </span><span class="s1">code) </span><span class="s0">for </span><span class="s1">level</span><span class="s0">, </span><span class="s1">code </span><span class="s0">in </span><span class="s1">zip(levels</span><span class="s0">, </span><span class="s1">codes)</span>
        <span class="s1">]</span>
        <span class="s1">new_codes = FrozenList(codes)</span>
        <span class="s0">return </span><span class="s1">new_codes</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_arrays(cls</span><span class="s0">, </span><span class="s1">arrays</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s0">None, </span><span class="s1">names=lib.no_default) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert arrays to MultiIndex. 
 
        Parameters 
        ---------- 
        arrays : list / sequence of array-likes 
            Each array-like gives one level's value for each data point. 
            len(arrays) is the number of levels. 
        sortorder : int or None 
            Level of sortedness (must be lexicographically sorted by that 
            level). 
        names : list / sequence of str, optional 
            Names for the levels in the index. 
 
        Returns 
        ------- 
        MultiIndex 
 
        See Also 
        -------- 
        MultiIndex.from_tuples : Convert list of tuples to MultiIndex. 
        MultiIndex.from_product : Make a MultiIndex from cartesian product 
                                  of iterables. 
        MultiIndex.from_frame : Make a MultiIndex from a DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']] 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays(arrays, names=('number', 'color')) 
        MultiIndex([(1,  'red'), 
                    (1, 'blue'), 
                    (2,  'red'), 
                    (2, 'blue')], 
                   names=['number', 'color']) 
        &quot;&quot;&quot;</span>
        <span class="s1">error_msg = </span><span class="s2">&quot;Input must be a list / sequence of array-likes.&quot;</span>
        <span class="s0">if not </span><span class="s1">is_list_like(arrays):</span>
            <span class="s0">raise </span><span class="s1">TypeError(error_msg)</span>
        <span class="s0">elif </span><span class="s1">is_iterator(arrays):</span>
            <span class="s1">arrays = list(arrays)</span>

        <span class="s4"># Check if elements of array are list-like</span>
        <span class="s0">for </span><span class="s1">array </span><span class="s0">in </span><span class="s1">arrays:</span>
            <span class="s0">if not </span><span class="s1">is_list_like(array):</span>
                <span class="s0">raise </span><span class="s1">TypeError(error_msg)</span>

        <span class="s4"># Check if lengths of all arrays are equal or not,</span>
        <span class="s4"># raise ValueError, if not</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">len(arrays)):</span>
            <span class="s0">if </span><span class="s1">len(arrays[i]) != len(arrays[i - </span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;all arrays must be same length&quot;</span><span class="s1">)</span>

        <span class="s1">codes</span><span class="s0">, </span><span class="s1">levels = factorize_from_iterables(arrays)</span>
        <span class="s0">if </span><span class="s1">names </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">names = [getattr(arr</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrays]</span>

        <span class="s0">return </span><span class="s1">cls(</span>
            <span class="s1">levels=levels</span><span class="s0">,</span>
            <span class="s1">codes=codes</span><span class="s0">,</span>
            <span class="s1">sortorder=sortorder</span><span class="s0">,</span>
            <span class="s1">names=names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@names_compat</span>
    <span class="s0">def </span><span class="s1">from_tuples(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">tuples: Iterable[tuple[Hashable</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">,</span>
        <span class="s1">sortorder: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">names: Sequence[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert list of tuples to MultiIndex. 
 
        Parameters 
        ---------- 
        tuples : list / sequence of tuple-likes 
            Each tuple is the index of one row/column. 
        sortorder : int or None 
            Level of sortedness (must be lexicographically sorted by that 
            level). 
        names : list / sequence of str, optional 
            Names for the levels in the index. 
 
        Returns 
        ------- 
        MultiIndex 
 
        See Also 
        -------- 
        MultiIndex.from_arrays : Convert list of arrays to MultiIndex. 
        MultiIndex.from_product : Make a MultiIndex from cartesian product 
                                  of iterables. 
        MultiIndex.from_frame : Make a MultiIndex from a DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; tuples = [(1, 'red'), (1, 'blue'), 
        ...           (2, 'red'), (2, 'blue')] 
        &gt;&gt;&gt; pd.MultiIndex.from_tuples(tuples, names=('number', 'color')) 
        MultiIndex([(1,  'red'), 
                    (1, 'blue'), 
                    (2,  'red'), 
                    (2, 'blue')], 
                   names=['number', 'color']) 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">is_list_like(tuples):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Input must be a list / sequence of tuple-likes.&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">is_iterator(tuples):</span>
            <span class="s1">tuples = list(tuples)</span>
        <span class="s1">tuples = cast(Collection[Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">, </span><span class="s1">tuples)</span>

        <span class="s1">arrays: list[Sequence[Hashable]]</span>
        <span class="s0">if </span><span class="s1">len(tuples) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">names </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Cannot infer number of levels from empty list&quot;</span><span class="s1">)</span>
            <span class="s1">arrays = [[]] * len(names)</span>
        <span class="s0">elif </span><span class="s1">isinstance(tuples</span><span class="s0">, </span><span class="s1">(np.ndarray</span><span class="s0">, </span><span class="s1">Index)):</span>
            <span class="s0">if </span><span class="s1">isinstance(tuples</span><span class="s0">, </span><span class="s1">Index):</span>
                <span class="s1">tuples = np.asarray(tuples._values)</span>

            <span class="s1">arrays = list(lib.tuples_to_object_array(tuples).T)</span>
        <span class="s0">elif </span><span class="s1">isinstance(tuples</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">arrays = list(lib.to_object_array_tuples(tuples).T)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">arrs = zip(*tuples)</span>
            <span class="s1">arrays = cast(List[Sequence[Hashable]]</span><span class="s0">, </span><span class="s1">arrs)</span>

        <span class="s0">return </span><span class="s1">cls.from_arrays(arrays</span><span class="s0">, </span><span class="s1">sortorder=sortorder</span><span class="s0">, </span><span class="s1">names=names)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_product(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">iterables</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s0">None, </span><span class="s1">names=lib.no_default</span>
    <span class="s1">) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Make a MultiIndex from the cartesian product of multiple iterables. 
 
        Parameters 
        ---------- 
        iterables : list / sequence of iterables 
            Each iterable has unique labels for each level of the index. 
        sortorder : int or None 
            Level of sortedness (must be lexicographically sorted by that 
            level). 
        names : list / sequence of str, optional 
            Names for the levels in the index. 
 
            .. versionchanged:: 1.0.0 
 
               If not explicitly provided, names will be inferred from the 
               elements of iterables if an element has a name attribute 
 
        Returns 
        ------- 
        MultiIndex 
 
        See Also 
        -------- 
        MultiIndex.from_arrays : Convert list of arrays to MultiIndex. 
        MultiIndex.from_tuples : Convert list of tuples to MultiIndex. 
        MultiIndex.from_frame : Make a MultiIndex from a DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; numbers = [0, 1, 2] 
        &gt;&gt;&gt; colors = ['green', 'purple'] 
        &gt;&gt;&gt; pd.MultiIndex.from_product([numbers, colors], 
        ...                            names=['number', 'color']) 
        MultiIndex([(0,  'green'), 
                    (0, 'purple'), 
                    (1,  'green'), 
                    (1, 'purple'), 
                    (2,  'green'), 
                    (2, 'purple')], 
                   names=['number', 'color']) 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas.core.reshape.util </span><span class="s0">import </span><span class="s1">cartesian_product</span>

        <span class="s0">if not </span><span class="s1">is_list_like(iterables):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Input must be a list / sequence of iterables.&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">is_iterator(iterables):</span>
            <span class="s1">iterables = list(iterables)</span>

        <span class="s1">codes</span><span class="s0">, </span><span class="s1">levels = factorize_from_iterables(iterables)</span>
        <span class="s0">if </span><span class="s1">names </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">names = [getattr(it</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">for </span><span class="s1">it </span><span class="s0">in </span><span class="s1">iterables]</span>

        <span class="s4"># codes are all ndarrays, so cartesian_product is lossless</span>
        <span class="s1">codes = cartesian_product(codes)</span>
        <span class="s0">return </span><span class="s1">cls(levels</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">sortorder=sortorder</span><span class="s0">, </span><span class="s1">names=names)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_frame(cls</span><span class="s0">, </span><span class="s1">df: DataFrame</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s0">None, </span><span class="s1">names=</span><span class="s0">None</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Make a MultiIndex from a DataFrame. 
 
        Parameters 
        ---------- 
        df : DataFrame 
            DataFrame to be converted to MultiIndex. 
        sortorder : int, optional 
            Level of sortedness (must be lexicographically sorted by that 
            level). 
        names : list-like, optional 
            If no names are provided, use the column names, or tuple of column 
            names if the columns is a MultiIndex. If a sequence, overwrite 
            names with the given sequence. 
 
        Returns 
        ------- 
        MultiIndex 
            The MultiIndex representation of the given DataFrame. 
 
        See Also 
        -------- 
        MultiIndex.from_arrays : Convert list of arrays to MultiIndex. 
        MultiIndex.from_tuples : Convert list of tuples to MultiIndex. 
        MultiIndex.from_product : Make a MultiIndex from cartesian product 
                                  of iterables. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; df = pd.DataFrame([['HI', 'Temp'], ['HI', 'Precip'], 
        ...                    ['NJ', 'Temp'], ['NJ', 'Precip']], 
        ...                   columns=['a', 'b']) 
        &gt;&gt;&gt; df 
              a       b 
        0    HI    Temp 
        1    HI  Precip 
        2    NJ    Temp 
        3    NJ  Precip 
 
        &gt;&gt;&gt; pd.MultiIndex.from_frame(df) 
        MultiIndex([('HI',   'Temp'), 
                    ('HI', 'Precip'), 
                    ('NJ',   'Temp'), 
                    ('NJ', 'Precip')], 
                   names=['a', 'b']) 
 
        Using explicit names, instead of the column names 
 
        &gt;&gt;&gt; pd.MultiIndex.from_frame(df, names=['state', 'observation']) 
        MultiIndex([('HI',   'Temp'), 
                    ('HI', 'Precip'), 
                    ('NJ',   'Temp'), 
                    ('NJ', 'Precip')], 
                   names=['state', 'observation']) 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(df</span><span class="s0">, </span><span class="s1">ABCDataFrame):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Input must be a DataFrame&quot;</span><span class="s1">)</span>

        <span class="s1">column_names</span><span class="s0">, </span><span class="s1">columns = zip(*df.items())</span>
        <span class="s1">names = column_names </span><span class="s0">if </span><span class="s1">names </span><span class="s0">is None else </span><span class="s1">names</span>
        <span class="s0">return </span><span class="s1">cls.from_arrays(columns</span><span class="s0">, </span><span class="s1">sortorder=sortorder</span><span class="s0">, </span><span class="s1">names=names)</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_values(self) -&gt; np.ndarray:</span>
        <span class="s4"># We override here, since our parent uses _data, which we don't use.</span>
        <span class="s1">values = []</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.nlevels):</span>
            <span class="s1">vals = self._get_level_values(i)</span>
            <span class="s0">if </span><span class="s1">is_categorical_dtype(vals.dtype):</span>
                <span class="s1">vals = cast(</span><span class="s2">&quot;CategoricalIndex&quot;</span><span class="s0">, </span><span class="s1">vals)</span>
                <span class="s1">vals = vals._data._internal_get_values()</span>
            <span class="s0">if </span><span class="s1">isinstance(vals.dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype) </span><span class="s0">or </span><span class="s1">isinstance(</span>
                <span class="s1">vals</span><span class="s0">, </span><span class="s1">(ABCDatetimeIndex</span><span class="s0">, </span><span class="s1">ABCTimedeltaIndex)</span>
            <span class="s1">):</span>
                <span class="s1">vals = vals.astype(object)</span>
            <span class="s4"># error: Incompatible types in assignment (expression has type &quot;ndarray&quot;,</span>
            <span class="s4"># variable has type &quot;Index&quot;)</span>
            <span class="s1">vals = np.array(vals</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)  </span><span class="s4"># type: ignore[assignment]</span>
            <span class="s1">values.append(vals)</span>

        <span class="s1">arr = lib.fast_zip(values)</span>
        <span class="s0">return </span><span class="s1">arr</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">values(self) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">self._values</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">array(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Raises a ValueError for `MultiIndex` because there's no single 
        array backing a MultiIndex. 
 
        Raises 
        ------ 
        ValueError 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;MultiIndex has no single backing array. Use &quot;</span>
            <span class="s2">&quot;'MultiIndex.to_numpy()' to get a NumPy array of tuples.&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">dtypes(self) -&gt; Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the dtypes as a Series for the underlying MultiIndex. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s1">names = com.fill_missing_names([level.name </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">self.levels])</span>
        <span class="s0">return </span><span class="s1">Series([level.dtype </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">self.levels]</span><span class="s0">, </span><span class="s1">index=names)</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self.codes[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Levels Methods</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">levels(self) -&gt; FrozenList:</span>
        <span class="s4"># Use cache_readonly to ensure that self.get_locs doesn't repeatedly</span>
        <span class="s4"># create new IndexEngine</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/31648</span>
        <span class="s1">result = [x._rename(name=name) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip(self._levels</span><span class="s0">, </span><span class="s1">self._names)]</span>
        <span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">result:</span>
            <span class="s4"># disallow midx.levels[0].name = &quot;foo&quot;</span>
            <span class="s1">level._no_setting_name = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">FrozenList(result)</span>

    <span class="s0">def </span><span class="s1">_set_levels(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">levels</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">level=</span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">validate: bool = </span><span class="s0">True,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4"># This is NOT part of the levels property because it should be</span>
        <span class="s4"># externally not allowed to set levels. User beware if you change</span>
        <span class="s4"># _levels directly</span>
        <span class="s0">if </span><span class="s1">validate:</span>
            <span class="s0">if </span><span class="s1">len(levels) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Must set non-zero number of levels.&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">level </span><span class="s0">is None and </span><span class="s1">len(levels) != self.nlevels:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Length of levels must match number of levels.&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">level </span><span class="s0">is not None and </span><span class="s1">len(levels) != len(level):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Length of levels must match length of level.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">level </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new_levels = FrozenList(</span>
                <span class="s1">ensure_index(lev</span><span class="s0">, </span><span class="s1">copy=copy)._view() </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">levels</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level_numbers = [self._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>
            <span class="s1">new_levels_list = list(self._levels)</span>
            <span class="s0">for </span><span class="s1">lev_num</span><span class="s0">, </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">zip(level_numbers</span><span class="s0">, </span><span class="s1">levels):</span>
                <span class="s1">new_levels_list[lev_num] = ensure_index(lev</span><span class="s0">, </span><span class="s1">copy=copy)._view()</span>
            <span class="s1">new_levels = FrozenList(new_levels_list)</span>

        <span class="s0">if </span><span class="s1">verify_integrity:</span>
            <span class="s1">new_codes = self._verify_integrity(levels=new_levels)</span>
            <span class="s1">self._codes = new_codes</span>

        <span class="s1">names = self.names</span>
        <span class="s1">self._levels = new_levels</span>
        <span class="s0">if </span><span class="s1">any(names):</span>
            <span class="s1">self._set_names(names)</span>

        <span class="s1">self._reset_cache()</span>

    <span class="s1">@deprecate_nonkeyword_arguments(version=</span><span class="s0">None, </span><span class="s1">allowed_args=[</span><span class="s2">&quot;self&quot;</span><span class="s0">, </span><span class="s2">&quot;levels&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">set_levels(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">levels</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None, </span><span class="s1">inplace=</span><span class="s0">None, </span><span class="s1">verify_integrity: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set new levels on MultiIndex. Defaults to returning new index. 
 
        Parameters 
        ---------- 
        levels : sequence or list of sequence 
            New level(s) to apply. 
        level : int, level name, or sequence of int/level names (default None) 
            Level(s) to set (None for all levels). 
        inplace : bool 
            If True, mutates in place. 
 
            .. deprecated:: 1.2.0 
        verify_integrity : bool, default True 
            If True, checks that levels and codes are compatible. 
 
        Returns 
        ------- 
        new index (of same type and class...etc) or None 
            The same type as the caller or None if ``inplace=True``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.MultiIndex.from_tuples( 
        ...     [ 
        ...         (1, &quot;one&quot;), 
        ...         (1, &quot;two&quot;), 
        ...         (2, &quot;one&quot;), 
        ...         (2, &quot;two&quot;), 
        ...         (3, &quot;one&quot;), 
        ...         (3, &quot;two&quot;) 
        ...     ], 
        ...     names=[&quot;foo&quot;, &quot;bar&quot;] 
        ... ) 
        &gt;&gt;&gt; idx 
        MultiIndex([(1, 'one'), 
            (1, 'two'), 
            (2, 'one'), 
            (2, 'two'), 
            (3, 'one'), 
            (3, 'two')], 
           names=['foo', 'bar']) 
 
        &gt;&gt;&gt; idx.set_levels([['a', 'b', 'c'], [1, 2]]) 
        MultiIndex([('a', 1), 
                    ('a', 2), 
                    ('b', 1), 
                    ('b', 2), 
                    ('c', 1), 
                    ('c', 2)], 
                   names=['foo', 'bar']) 
        &gt;&gt;&gt; idx.set_levels(['a', 'b', 'c'], level=0) 
        MultiIndex([('a', 'one'), 
                    ('a', 'two'), 
                    ('b', 'one'), 
                    ('b', 'two'), 
                    ('c', 'one'), 
                    ('c', 'two')], 
                   names=['foo', 'bar']) 
        &gt;&gt;&gt; idx.set_levels(['a', 'b'], level='bar') 
        MultiIndex([(1, 'a'), 
                    (1, 'b'), 
                    (2, 'a'), 
                    (2, 'b'), 
                    (3, 'a'), 
                    (3, 'b')], 
                   names=['foo', 'bar']) 
 
        If any of the levels passed to ``set_levels()`` exceeds the 
        existing length, all of the values from that argument will 
        be stored in the MultiIndex levels, though the values will 
        be truncated in the MultiIndex output. 
 
        &gt;&gt;&gt; idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1]) 
        MultiIndex([('a', 1), 
            ('a', 2), 
            ('b', 1), 
            ('b', 2), 
            ('c', 1), 
            ('c', 2)], 
           names=['foo', 'bar']) 
        &gt;&gt;&gt; idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1]).levels 
        FrozenList([['a', 'b', 'c'], [1, 2, 3, 4]]) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">inplace </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;inplace is deprecated and will be removed in a future version.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">inplace = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">is_list_like(levels) </span><span class="s0">and not </span><span class="s1">isinstance(levels</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s1">levels = list(levels)</span>

        <span class="s1">level</span><span class="s0">, </span><span class="s1">levels = _require_listlike(level</span><span class="s0">, </span><span class="s1">levels</span><span class="s0">, </span><span class="s2">&quot;Levels&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">inplace:</span>
            <span class="s1">idx = self</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx = self._view()</span>
        <span class="s1">idx._reset_identity()</span>
        <span class="s1">idx._set_levels(</span>
            <span class="s1">levels</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">True, </span><span class="s1">verify_integrity=verify_integrity</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">inplace:</span>
            <span class="s0">return </span><span class="s1">idx</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nlevels(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        Integer number of levels in this MultiIndex. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([['a'], ['b'], ['c']]) 
        &gt;&gt;&gt; mi 
        MultiIndex([('a', 'b', 'c')], 
                   ) 
        &gt;&gt;&gt; mi.nlevels 
        3 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len(self._levels)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">levshape(self) -&gt; Shape:</span>
        <span class="s3">&quot;&quot;&quot; 
        A tuple with the length of each level. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([['a'], ['b'], ['c']]) 
        &gt;&gt;&gt; mi 
        MultiIndex([('a', 'b', 'c')], 
                   ) 
        &gt;&gt;&gt; mi.levshape 
        (1, 1, 1) 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.levels)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Codes Methods</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">codes(self):</span>
        <span class="s0">return </span><span class="s1">self._codes</span>

    <span class="s0">def </span><span class="s1">_set_codes(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">codes</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">level=</span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">validate: bool = </span><span class="s0">True,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">validate:</span>
            <span class="s0">if </span><span class="s1">level </span><span class="s0">is None and </span><span class="s1">len(codes) != self.nlevels:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Length of codes must match number of levels&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">level </span><span class="s0">is not None and </span><span class="s1">len(codes) != len(level):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Length of codes must match length of levels.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">level </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new_codes = FrozenList(</span>
                <span class="s1">_coerce_indexer_frozen(level_codes</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">copy=copy).view()</span>
                <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(self._levels</span><span class="s0">, </span><span class="s1">codes)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level_numbers = [self._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>
            <span class="s1">new_codes_list = list(self._codes)</span>
            <span class="s0">for </span><span class="s1">lev_num</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(level_numbers</span><span class="s0">, </span><span class="s1">codes):</span>
                <span class="s1">lev = self.levels[lev_num]</span>
                <span class="s1">new_codes_list[lev_num] = _coerce_indexer_frozen(</span>
                    <span class="s1">level_codes</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">copy=copy</span>
                <span class="s1">)</span>
            <span class="s1">new_codes = FrozenList(new_codes_list)</span>

        <span class="s0">if </span><span class="s1">verify_integrity:</span>
            <span class="s1">new_codes = self._verify_integrity(codes=new_codes)</span>

        <span class="s1">self._codes = new_codes</span>

        <span class="s1">self._reset_cache()</span>

    <span class="s1">@deprecate_nonkeyword_arguments(version=</span><span class="s0">None, </span><span class="s1">allowed_args=[</span><span class="s2">&quot;self&quot;</span><span class="s0">, </span><span class="s2">&quot;codes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">set_codes(self</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None, </span><span class="s1">inplace=</span><span class="s0">None, </span><span class="s1">verify_integrity: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set new codes on MultiIndex. Defaults to returning new index. 
 
        Parameters 
        ---------- 
        codes : sequence or list of sequence 
            New codes to apply. 
        level : int, level name, or sequence of int/level names (default None) 
            Level(s) to set (None for all levels). 
        inplace : bool 
            If True, mutates in place. 
 
            .. deprecated:: 1.2.0 
        verify_integrity : bool, default True 
            If True, checks that levels and codes are compatible. 
 
        Returns 
        ------- 
        new index (of same type and class...etc) or None 
            The same type as the caller or None if ``inplace=True``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.MultiIndex.from_tuples( 
        ...     [(1, &quot;one&quot;), (1, &quot;two&quot;), (2, &quot;one&quot;), (2, &quot;two&quot;)], names=[&quot;foo&quot;, &quot;bar&quot;] 
        ... ) 
        &gt;&gt;&gt; idx 
        MultiIndex([(1, 'one'), 
            (1, 'two'), 
            (2, 'one'), 
            (2, 'two')], 
           names=['foo', 'bar']) 
 
        &gt;&gt;&gt; idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]]) 
        MultiIndex([(2, 'one'), 
                    (1, 'one'), 
                    (2, 'two'), 
                    (1, 'two')], 
                   names=['foo', 'bar']) 
        &gt;&gt;&gt; idx.set_codes([1, 0, 1, 0], level=0) 
        MultiIndex([(2, 'one'), 
                    (1, 'two'), 
                    (2, 'one'), 
                    (1, 'two')], 
                   names=['foo', 'bar']) 
        &gt;&gt;&gt; idx.set_codes([0, 0, 1, 1], level='bar') 
        MultiIndex([(1, 'one'), 
                    (1, 'one'), 
                    (2, 'two'), 
                    (2, 'two')], 
                   names=['foo', 'bar']) 
        &gt;&gt;&gt; idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]], level=[0, 1]) 
        MultiIndex([(2, 'one'), 
                    (1, 'one'), 
                    (2, 'two'), 
                    (1, 'two')], 
                   names=['foo', 'bar']) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">inplace </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;inplace is deprecated and will be removed in a future version.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">inplace = </span><span class="s0">False</span>

        <span class="s1">level</span><span class="s0">, </span><span class="s1">codes = _require_listlike(level</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s2">&quot;Codes&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">inplace:</span>
            <span class="s1">idx = self</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx = self._view()</span>
        <span class="s1">idx._reset_identity()</span>
        <span class="s1">idx._set_codes(codes</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">verify_integrity=verify_integrity)</span>
        <span class="s0">if not </span><span class="s1">inplace:</span>
            <span class="s0">return </span><span class="s1">idx</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Index Internals</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_engine(self):</span>
        <span class="s4"># Calculate the number of bits needed to represent labels in each</span>
        <span class="s4"># level, as log2 of their sizes (including -1 for NaN):</span>
        <span class="s1">sizes = np.ceil(np.log2([len(level) + </span><span class="s5">1 </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">self.levels]))</span>

        <span class="s4"># Sum bit counts, starting from the _right_....</span>
        <span class="s1">lev_bits = np.cumsum(sizes[::-</span><span class="s5">1</span><span class="s1">])[::-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s4"># ... in order to obtain offsets such that sorting the combination of</span>
        <span class="s4"># shifted codes (one for each level, resulting in a unique integer) is</span>
        <span class="s4"># equivalent to sorting lexicographically the codes themselves. Notice</span>
        <span class="s4"># that each level needs to be shifted by the number of bits needed to</span>
        <span class="s4"># represent the _previous_ ones:</span>
        <span class="s1">offsets = np.concatenate([lev_bits[</span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]]).astype(  </span><span class="s4"># type: ignore[arg-type]</span>
            <span class="s2">&quot;uint64&quot;</span>
        <span class="s1">)</span>

        <span class="s4"># Check the total number of bits needed for our representation:</span>
        <span class="s0">if </span><span class="s1">lev_bits[</span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">64</span><span class="s1">:</span>
            <span class="s4"># The levels would overflow a 64 bit uint - use Python integers:</span>
            <span class="s0">return </span><span class="s1">MultiIndexPyIntEngine(self.levels</span><span class="s0">, </span><span class="s1">self.codes</span><span class="s0">, </span><span class="s1">offsets)</span>
        <span class="s0">return </span><span class="s1">MultiIndexUIntEngine(self.levels</span><span class="s0">, </span><span class="s1">self.codes</span><span class="s0">, </span><span class="s1">offsets)</span>

    <span class="s4"># Return type &quot;Callable[..., MultiIndex]&quot; of &quot;_constructor&quot; incompatible with return</span>
    <span class="s4"># type &quot;Type[MultiIndex]&quot; in supertype &quot;Index&quot;</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_constructor(self) -&gt; Callable[...</span><span class="s0">, </span><span class="s1">MultiIndex]:  </span><span class="s4"># type: ignore[override]</span>
        <span class="s0">return </span><span class="s1">type(self).from_tuples</span>

    <span class="s1">@doc(Index._shallow_copy)</span>
    <span class="s0">def </span><span class="s1">_shallow_copy(self</span><span class="s0">, </span><span class="s1">values: np.ndarray</span><span class="s0">, </span><span class="s1">name=lib.no_default) -&gt; MultiIndex:</span>
        <span class="s1">names = name </span><span class="s0">if </span><span class="s1">name </span><span class="s0">is not </span><span class="s1">lib.no_default </span><span class="s0">else </span><span class="s1">self.names</span>

        <span class="s0">return </span><span class="s1">type(self).from_tuples(values</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s0">None, </span><span class="s1">names=names)</span>

    <span class="s0">def </span><span class="s1">_view(self) -&gt; MultiIndex:</span>
        <span class="s1">result = type(self)(</span>
            <span class="s1">levels=self.levels</span><span class="s0">,</span>
            <span class="s1">codes=self.codes</span><span class="s0">,</span>
            <span class="s1">sortorder=self.sortorder</span><span class="s0">,</span>
            <span class="s1">names=self.names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>
        <span class="s1">result._cache = self._cache.copy()</span>
        <span class="s1">result._cache.pop(</span><span class="s2">&quot;levels&quot;</span><span class="s0">, None</span><span class="s1">)  </span><span class="s4"># GH32669</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">copy(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">names=</span><span class="s0">None,</span>
        <span class="s1">dtype=</span><span class="s0">None,</span>
        <span class="s1">levels=</span><span class="s0">None,</span>
        <span class="s1">codes=</span><span class="s0">None,</span>
        <span class="s1">deep=</span><span class="s0">False,</span>
        <span class="s1">name=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Make a copy of this object. Names, dtype, levels and codes can be 
        passed and will be set on new copy. 
 
        Parameters 
        ---------- 
        names : sequence, optional 
        dtype : numpy dtype or pandas type, optional 
 
            .. deprecated:: 1.2.0 
        levels : sequence, optional 
 
            .. deprecated:: 1.2.0 
        codes : sequence, optional 
 
            .. deprecated:: 1.2.0 
        deep : bool, default False 
        name : Label 
            Kept for compatibility with 1-dimensional Index. Should not be used. 
 
        Returns 
        ------- 
        MultiIndex 
 
        Notes 
        ----- 
        In most cases, there should be no functional difference from using 
        ``deep``, but if ``deep`` is passed it will attempt to deepcopy. 
        This could be potentially expensive on large MultiIndex objects. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = self._validate_names(name=name</span><span class="s0">, </span><span class="s1">names=names</span><span class="s0">, </span><span class="s1">deep=deep)</span>
        <span class="s0">if </span><span class="s1">levels </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;parameter levels is deprecated and will be removed in a future &quot;</span>
                <span class="s2">&quot;version. Use the set_levels method instead.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">codes </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;parameter codes is deprecated and will be removed in a future &quot;</span>
                <span class="s2">&quot;version. Use the set_codes method instead.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">deep:</span>
            <span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span>

            <span class="s0">if </span><span class="s1">levels </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">levels = deepcopy(self.levels)</span>
            <span class="s0">if </span><span class="s1">codes </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">codes = deepcopy(self.codes)</span>

        <span class="s1">levels = levels </span><span class="s0">if </span><span class="s1">levels </span><span class="s0">is not None else </span><span class="s1">self.levels</span>
        <span class="s1">codes = codes </span><span class="s0">if </span><span class="s1">codes </span><span class="s0">is not None else </span><span class="s1">self.codes</span>

        <span class="s1">new_index = type(self)(</span>
            <span class="s1">levels=levels</span><span class="s0">,</span>
            <span class="s1">codes=codes</span><span class="s0">,</span>
            <span class="s1">sortorder=self.sortorder</span><span class="s0">,</span>
            <span class="s1">names=names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>
        <span class="s1">new_index._cache = self._cache.copy()</span>
        <span class="s1">new_index._cache.pop(</span><span class="s2">&quot;levels&quot;</span><span class="s0">, None</span><span class="s1">)  </span><span class="s4"># GH32669</span>

        <span class="s0">if </span><span class="s1">dtype:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;parameter dtype is deprecated and will be removed in a future &quot;</span>
                <span class="s2">&quot;version. Use the astype method instead.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">new_index = new_index.astype(dtype)</span>
        <span class="s0">return </span><span class="s1">new_index</span>

    <span class="s0">def </span><span class="s1">__array__(self</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">) -&gt; np.ndarray:</span>
        <span class="s3">&quot;&quot;&quot;the array interface, return my values&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.values</span>

    <span class="s0">def </span><span class="s1">view(self</span><span class="s0">, </span><span class="s1">cls=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;this is defined as a copy with the same identity&quot;&quot;&quot;</span>
        <span class="s1">result = self.copy()</span>
        <span class="s1">result._id = self._id</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@doc(Index.__contains__)</span>
    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">key: Any) -&gt; bool:</span>
        <span class="s1">hash(key)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.get_loc(key)</span>
            <span class="s0">return True</span>
        <span class="s0">except </span><span class="s1">(LookupError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">return False</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; np.dtype:</span>
        <span class="s0">return </span><span class="s1">np.dtype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_is_memory_usage_qualified(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;return a boolean if we need a qualified .info display&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">f(level):</span>
            <span class="s0">return </span><span class="s2">&quot;mixed&quot; </span><span class="s0">in </span><span class="s1">level </span><span class="s0">or </span><span class="s2">&quot;string&quot; </span><span class="s0">in </span><span class="s1">level </span><span class="s0">or </span><span class="s2">&quot;unicode&quot; </span><span class="s0">in </span><span class="s1">level</span>

        <span class="s0">return </span><span class="s1">any(f(level) </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">self._inferred_type_levels)</span>

    <span class="s1">@doc(Index.memory_usage)</span>
    <span class="s0">def </span><span class="s1">memory_usage(self</span><span class="s0">, </span><span class="s1">deep: bool = </span><span class="s0">False</span><span class="s1">) -&gt; int:</span>
        <span class="s4"># we are overwriting our base class to avoid</span>
        <span class="s4"># computing .values here which could materialize</span>
        <span class="s4"># a tuple representation unnecessarily</span>
        <span class="s0">return </span><span class="s1">self._nbytes(deep)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">nbytes(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;return the number of bytes in the underlying data&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._nbytes(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_nbytes(self</span><span class="s0">, </span><span class="s1">deep: bool = </span><span class="s0">False</span><span class="s1">) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        return the number of bytes in the underlying data 
        deeply introspect the level data if deep=True 
 
        include the engine hashtable 
 
        *this is in internal routine* 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># for implementations with no useful getsizeof (PyPy)</span>
        <span class="s1">objsize = </span><span class="s5">24</span>

        <span class="s1">level_nbytes = sum(i.memory_usage(deep=deep) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.levels)</span>
        <span class="s1">label_nbytes = sum(i.nbytes </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.codes)</span>
        <span class="s1">names_nbytes = sum(getsizeof(i</span><span class="s0">, </span><span class="s1">objsize) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.names)</span>
        <span class="s1">result = level_nbytes + label_nbytes + names_nbytes</span>

        <span class="s4"># include our engine hashtable</span>
        <span class="s1">result += self._engine.sizeof(deep=deep)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Rendering Methods</span>

    <span class="s0">def </span><span class="s1">_formatter_func(self</span><span class="s0">, </span><span class="s1">tup):</span>
        <span class="s3">&quot;&quot;&quot; 
        Formats each item in tup according to its level's formatter function. 
        &quot;&quot;&quot;</span>
        <span class="s1">formatter_funcs = [level._formatter_func </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">self.levels]</span>
        <span class="s0">return </span><span class="s1">tuple(func(val) </span><span class="s0">for </span><span class="s1">func</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">zip(formatter_funcs</span><span class="s0">, </span><span class="s1">tup))</span>

    <span class="s0">def </span><span class="s1">_format_native_types(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">na_rep=</span><span class="s2">&quot;nan&quot;</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">new_levels = []</span>
        <span class="s1">new_codes = []</span>

        <span class="s4"># go through the levels and format them</span>
        <span class="s0">for </span><span class="s1">level</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(self.levels</span><span class="s0">, </span><span class="s1">self.codes):</span>
            <span class="s1">level_strs = level._format_native_types(na_rep=na_rep</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s4"># add nan values, if there are any</span>
            <span class="s1">mask = level_codes == -</span><span class="s5">1</span>
            <span class="s0">if </span><span class="s1">mask.any():</span>
                <span class="s1">nan_index = len(level_strs)</span>
                <span class="s4"># numpy 1.21 deprecated implicit string casting</span>
                <span class="s1">level_strs = level_strs.astype(str)</span>
                <span class="s1">level_strs = np.append(level_strs</span><span class="s0">, </span><span class="s1">na_rep)</span>
                <span class="s0">assert not </span><span class="s1">level_codes.flags.writeable  </span><span class="s4"># i.e. copy is needed</span>
                <span class="s1">level_codes = level_codes.copy()  </span><span class="s4"># make writeable</span>
                <span class="s1">level_codes[mask] = nan_index</span>
            <span class="s1">new_levels.append(level_strs)</span>
            <span class="s1">new_codes.append(level_codes)</span>

        <span class="s0">if </span><span class="s1">len(new_levels) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># a single-level multi-index</span>
            <span class="s0">return </span><span class="s1">Index(new_levels[</span><span class="s5">0</span><span class="s1">].take(new_codes[</span><span class="s5">0</span><span class="s1">]))._format_native_types()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># reconstruct the multi-index</span>
            <span class="s1">mi = MultiIndex(</span>
                <span class="s1">levels=new_levels</span><span class="s0">,</span>
                <span class="s1">codes=new_codes</span><span class="s0">,</span>
                <span class="s1">names=self.names</span><span class="s0">,</span>
                <span class="s1">sortorder=self.sortorder</span><span class="s0">,</span>
                <span class="s1">verify_integrity=</span><span class="s0">False,</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">mi._values</span>

    <span class="s0">def </span><span class="s1">format(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">formatter: Callable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">na_rep: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">names: bool = </span><span class="s0">False,</span>
        <span class="s1">space: int = </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">sparsify=</span><span class="s0">None,</span>
        <span class="s1">adjoin: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; list:</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">names = name</span>

        <span class="s0">if </span><span class="s1">len(self) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[]</span>

        <span class="s1">stringified_levels = []</span>
        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(self.levels</span><span class="s0">, </span><span class="s1">self.codes):</span>
            <span class="s1">na = na_rep </span><span class="s0">if </span><span class="s1">na_rep </span><span class="s0">is not None else </span><span class="s1">_get_na_rep(lev.dtype.type)</span>

            <span class="s0">if </span><span class="s1">len(lev) &gt; </span><span class="s5">0</span><span class="s1">:</span>

                <span class="s1">formatted = lev.take(level_codes).format(formatter=formatter)</span>

                <span class="s4"># we have some NA</span>
                <span class="s1">mask = level_codes == -</span><span class="s5">1</span>
                <span class="s0">if </span><span class="s1">mask.any():</span>
                    <span class="s1">formatted = np.array(formatted</span><span class="s0">, </span><span class="s1">dtype=object)</span>
                    <span class="s1">formatted[mask] = na</span>
                    <span class="s1">formatted = formatted.tolist()</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># weird all NA case</span>
                <span class="s1">formatted = [</span>
                    <span class="s1">pprint_thing(na </span><span class="s0">if </span><span class="s1">isna(x) </span><span class="s0">else </span><span class="s1">x</span><span class="s0">, </span><span class="s1">escape_chars=(</span><span class="s2">&quot;</span><span class="s0">\t</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\r</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">))</span>
                    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">algos.take_nd(lev._values</span><span class="s0">, </span><span class="s1">level_codes)</span>
                <span class="s1">]</span>
            <span class="s1">stringified_levels.append(formatted)</span>

        <span class="s1">result_levels = []</span>
        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">lev_name </span><span class="s0">in </span><span class="s1">zip(stringified_levels</span><span class="s0">, </span><span class="s1">self.names):</span>
            <span class="s1">level = []</span>

            <span class="s0">if </span><span class="s1">names:</span>
                <span class="s1">level.append(</span>
                    <span class="s1">pprint_thing(lev_name</span><span class="s0">, </span><span class="s1">escape_chars=(</span><span class="s2">&quot;</span><span class="s0">\t</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\r</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">))</span>
                    <span class="s0">if </span><span class="s1">lev_name </span><span class="s0">is not None</span>
                    <span class="s0">else </span><span class="s2">&quot;&quot;</span>
                <span class="s1">)</span>

            <span class="s1">level.extend(np.array(lev</span><span class="s0">, </span><span class="s1">dtype=object))</span>
            <span class="s1">result_levels.append(level)</span>

        <span class="s0">if </span><span class="s1">sparsify </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sparsify = get_option(</span><span class="s2">&quot;display.multi_sparse&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">sparsify:</span>
            <span class="s1">sentinel = </span><span class="s2">&quot;&quot;</span>
            <span class="s4"># GH3547 use value of sparsify as sentinel if it's &quot;Falsey&quot;</span>
            <span class="s0">assert </span><span class="s1">isinstance(sparsify</span><span class="s0">, </span><span class="s1">bool) </span><span class="s0">or </span><span class="s1">sparsify </span><span class="s0">is </span><span class="s1">lib.no_default</span>
            <span class="s0">if </span><span class="s1">sparsify </span><span class="s0">in </span><span class="s1">[</span><span class="s0">False, </span><span class="s1">lib.no_default]:</span>
                <span class="s1">sentinel = sparsify</span>
            <span class="s4"># little bit of a kludge job for #1217</span>
            <span class="s1">result_levels = sparsify_labels(</span>
                <span class="s1">result_levels</span><span class="s0">, </span><span class="s1">start=int(names)</span><span class="s0">, </span><span class="s1">sentinel=sentinel</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">adjoin:</span>
            <span class="s0">from </span><span class="s1">pandas.io.formats.format </span><span class="s0">import </span><span class="s1">get_adjustment</span>

            <span class="s1">adj = get_adjustment()</span>
            <span class="s0">return </span><span class="s1">adj.adjoin(space</span><span class="s0">, </span><span class="s1">*result_levels).split(</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result_levels</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Names Methods</span>

    <span class="s0">def </span><span class="s1">_get_names(self) -&gt; FrozenList:</span>
        <span class="s0">return </span><span class="s1">FrozenList(self._names)</span>

    <span class="s0">def </span><span class="s1">_set_names(self</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None, </span><span class="s1">validate: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set new names on index. Each name has to be a hashable type. 
 
        Parameters 
        ---------- 
        values : str or sequence 
            name(s) to set 
        level : int, level name, or sequence of int/level names (default None) 
            If the index is a MultiIndex (hierarchical), level(s) to set (None 
            for all levels).  Otherwise level must be None 
        validate : bool, default True 
            validate that the names match level lengths 
 
        Raises 
        ------ 
        TypeError if each name is not hashable. 
 
        Notes 
        ----- 
        sets names on levels. WARNING: mutates! 
 
        Note that you generally want to set this *after* changing levels, so 
        that it only acts on copies 
        &quot;&quot;&quot;</span>
        <span class="s4"># GH 15110</span>
        <span class="s4"># Don't allow a single string for names in a MultiIndex</span>
        <span class="s0">if </span><span class="s1">names </span><span class="s0">is not None and not </span><span class="s1">is_list_like(names):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Names should be list-like for a MultiIndex&quot;</span><span class="s1">)</span>
        <span class="s1">names = list(names)</span>

        <span class="s0">if </span><span class="s1">validate:</span>
            <span class="s0">if </span><span class="s1">level </span><span class="s0">is not None and </span><span class="s1">len(names) != len(level):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Length of names must match length of level.&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">level </span><span class="s0">is None and </span><span class="s1">len(names) != self.nlevels:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Length of names must match number of levels in MultiIndex.&quot;</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">level </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">level = range(self.nlevels)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level = [self._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>

        <span class="s4"># set the name</span>
        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip(level</span><span class="s0">, </span><span class="s1">names):</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># GH 20527</span>
                <span class="s4"># All items in 'names' need to be hashable:</span>
                <span class="s0">if not </span><span class="s1">is_hashable(name):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">.name must be a hashable type&quot;</span>
                    <span class="s1">)</span>
            <span class="s4"># error: Cannot determine type of '__setitem__'</span>
            <span class="s1">self._names[lev] = name  </span><span class="s4"># type: ignore[has-type]</span>

        <span class="s4"># If .levels has been accessed, the names in our cache will be stale.</span>
        <span class="s1">self._reset_cache()</span>

    <span class="s1">names = property(</span>
        <span class="s1">fset=_set_names</span><span class="s0">,</span>
        <span class="s1">fget=_get_names</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s2">&quot;&quot;&quot; 
        Names of levels in MultiIndex. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays( 
        ... [[1, 2], [3, 4], [5, 6]], names=['x', 'y', 'z']) 
        &gt;&gt;&gt; mi 
        MultiIndex([(1, 3, 5), 
                    (2, 4, 6)], 
                   names=['x', 'y', 'z']) 
        &gt;&gt;&gt; mi.names 
        FrozenList(['x', 'y', 'z']) 
        &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s1">@doc(Index._get_grouper_for_level)</span>
    <span class="s0">def </span><span class="s1">_get_grouper_for_level(self</span><span class="s0">, </span><span class="s1">mapper</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">level):</span>
        <span class="s1">indexer = self.codes[level]</span>
        <span class="s1">level_index = self.levels[level]</span>

        <span class="s0">if </span><span class="s1">mapper </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># Handle group mapping function and return</span>
            <span class="s1">level_values = self.levels[level].take(indexer)</span>
            <span class="s1">grouper = level_values.map(mapper)</span>
            <span class="s0">return </span><span class="s1">grouper</span><span class="s0">, None, None</span>

        <span class="s1">codes</span><span class="s0">, </span><span class="s1">uniques = algos.factorize(indexer</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">len(uniques) &gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">uniques[</span><span class="s5">0</span><span class="s1">] == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># Handle NAs</span>
            <span class="s1">mask = indexer != -</span><span class="s5">1</span>
            <span class="s1">ok_codes</span><span class="s0">, </span><span class="s1">uniques = algos.factorize(indexer[mask]</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">codes = np.empty(len(indexer)</span><span class="s0">, </span><span class="s1">dtype=indexer.dtype)</span>
            <span class="s1">codes[mask] = ok_codes</span>
            <span class="s1">codes[~mask] = -</span><span class="s5">1</span>

        <span class="s0">if </span><span class="s1">len(uniques) &lt; len(level_index):</span>
            <span class="s4"># Remove unobserved levels from level_index</span>
            <span class="s1">level_index = level_index.take(uniques)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># break references back to us so that setting the name</span>
            <span class="s4"># on the output of a groupby doesn't reflect back here.</span>
            <span class="s1">level_index = level_index.copy()</span>

        <span class="s0">if </span><span class="s1">level_index._can_hold_na:</span>
            <span class="s1">grouper = level_index.take(codes</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">grouper = level_index.take(codes)</span>

        <span class="s0">return </span><span class="s1">grouper</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">level_index</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">inferred_type(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;mixed&quot;</span>

    <span class="s0">def </span><span class="s1">_get_level_number(self</span><span class="s0">, </span><span class="s1">level) -&gt; int:</span>
        <span class="s1">count = self.names.count(level)</span>
        <span class="s0">if </span><span class="s1">(count &gt; </span><span class="s5">1</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">is_integer(level):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;The name </span><span class="s0">{</span><span class="s1">level</span><span class="s0">} </span><span class="s2">occurs multiple times, use a level number&quot;</span>
            <span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">level = self.names.index(level)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s0">if not </span><span class="s1">is_integer(level):</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">f&quot;Level </span><span class="s0">{</span><span class="s1">level</span><span class="s0">} </span><span class="s2">not found&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">elif </span><span class="s1">level &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">level += self.nlevels</span>
                <span class="s0">if </span><span class="s1">level &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">orig_level = level - self.nlevels</span>
                    <span class="s0">raise </span><span class="s1">IndexError(</span>
                        <span class="s2">f&quot;Too many levels: Index has only </span><span class="s0">{</span><span class="s1">self.nlevels</span><span class="s0">} </span><span class="s2">levels, &quot;</span>
                        <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">orig_level</span><span class="s0">} </span><span class="s2">is not a valid level number&quot;</span>
                    <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s4"># Note: levels are zero-based</span>
            <span class="s0">elif </span><span class="s1">level &gt;= self.nlevels:</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s2">f&quot;Too many levels: Index has only </span><span class="s0">{</span><span class="s1">self.nlevels</span><span class="s0">} </span><span class="s2">levels, &quot;</span>
                    <span class="s2">f&quot;not </span><span class="s0">{</span><span class="s1">level + </span><span class="s5">1</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">return </span><span class="s1">level</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_monotonic_increasing(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        return if the index is monotonic increasing (only equal or 
        increasing) values. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">any(-</span><span class="s5">1 </span><span class="s0">in </span><span class="s1">code </span><span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">self.codes):</span>
            <span class="s0">return False</span>

        <span class="s0">if </span><span class="s1">all(level.is_monotonic </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">self.levels):</span>
            <span class="s4"># If each level is sorted, we can operate on the codes directly. GH27495</span>
            <span class="s0">return </span><span class="s1">libalgos.is_lexsorted(</span>
                <span class="s1">[x.astype(</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.codes]</span>
            <span class="s1">)</span>

        <span class="s4"># reversed() because lexsort() wants the most significant key last.</span>
        <span class="s1">values = [</span>
            <span class="s1">self._get_level_values(i)._values </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">reversed(range(len(self.levels)))</span>
        <span class="s1">]</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s4"># Argument 1 to &quot;lexsort&quot; has incompatible type &quot;List[Union[ExtensionArray,</span>
            <span class="s4"># ndarray[Any, Any]]]&quot;; expected &quot;Union[_SupportsArray[dtype[Any]],</span>
            <span class="s4"># _NestedSequence[_SupportsArray[dtype[Any]]], bool,</span>
            <span class="s4">#  int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float,</span>
            <span class="s4">#  complex, str, bytes]]]&quot;  [arg-type]</span>
            <span class="s1">sort_order = np.lexsort(values)  </span><span class="s4"># type: ignore[arg-type]</span>
            <span class="s0">return </span><span class="s1">Index(sort_order).is_monotonic</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>

            <span class="s4"># we have mixed types and np.lexsort is not happy</span>
            <span class="s0">return </span><span class="s1">Index(self._values).is_monotonic</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_monotonic_decreasing(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        return if the index is monotonic decreasing (only equal or 
        decreasing) values. 
        &quot;&quot;&quot;</span>
        <span class="s4"># monotonic decreasing if and only if reverse is monotonic increasing</span>
        <span class="s0">return </span><span class="s1">self[::-</span><span class="s5">1</span><span class="s1">].is_monotonic_increasing</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_inferred_type_levels(self) -&gt; list[str]:</span>
        <span class="s3">&quot;&quot;&quot;return a list of the inferred types, one for each level&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">[i.inferred_type </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.levels]</span>

    <span class="s1">@doc(Index.duplicated)</span>
    <span class="s0">def </span><span class="s1">duplicated(self</span><span class="s0">, </span><span class="s1">keep=</span><span class="s2">&quot;first&quot;</span><span class="s1">) -&gt; npt.NDArray[np.bool_]:</span>
        <span class="s1">shape = tuple(len(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">self.levels)</span>
        <span class="s1">ids = get_group_index(self.codes</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False, </span><span class="s1">xnull=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">duplicated(ids</span><span class="s0">, </span><span class="s1">keep)</span>

    <span class="s4"># error: Cannot override final attribute &quot;_duplicated&quot;</span>
    <span class="s4"># (previously declared in base class &quot;IndexOpsMixin&quot;)</span>
    <span class="s1">_duplicated = duplicated  </span><span class="s4"># type: ignore[misc]</span>

    <span class="s0">def </span><span class="s1">fillna(self</span><span class="s0">, </span><span class="s1">value=</span><span class="s0">None, </span><span class="s1">downcast=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        fillna is not implemented for MultiIndex 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;isna is not defined for MultiIndex&quot;</span><span class="s1">)</span>

    <span class="s1">@doc(Index.dropna)</span>
    <span class="s0">def </span><span class="s1">dropna(self</span><span class="s0">, </span><span class="s1">how: str = </span><span class="s2">&quot;any&quot;</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s1">nans = [level_codes == -</span><span class="s5">1 </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>
        <span class="s0">if </span><span class="s1">how == </span><span class="s2">&quot;any&quot;</span><span class="s1">:</span>
            <span class="s1">indexer = np.any(nans</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">how == </span><span class="s2">&quot;all&quot;</span><span class="s1">:</span>
            <span class="s1">indexer = np.all(nans</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;invalid how option: </span><span class="s0">{</span><span class="s1">how</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s1">new_codes = [level_codes[~indexer] </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>
        <span class="s0">return </span><span class="s1">self.set_codes(codes=new_codes)</span>

    <span class="s0">def </span><span class="s1">_get_level_values(self</span><span class="s0">, </span><span class="s1">level: int</span><span class="s0">, </span><span class="s1">unique: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Index:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return vector of label values for requested level, 
        equal to the length of the index 
 
        **this is an internal method** 
 
        Parameters 
        ---------- 
        level : int 
        unique : bool, default False 
            if True, drop duplicated values 
 
        Returns 
        ------- 
        Index 
        &quot;&quot;&quot;</span>
        <span class="s1">lev = self.levels[level]</span>
        <span class="s1">level_codes = self.codes[level]</span>
        <span class="s1">name = self._names[level]</span>
        <span class="s0">if </span><span class="s1">unique:</span>
            <span class="s1">level_codes = algos.unique(level_codes)</span>
        <span class="s1">filled = algos.take_nd(lev._values</span><span class="s0">, </span><span class="s1">level_codes</span><span class="s0">, </span><span class="s1">fill_value=lev._na_value)</span>
        <span class="s0">return </span><span class="s1">lev._shallow_copy(filled</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s0">def </span><span class="s1">get_level_values(self</span><span class="s0">, </span><span class="s1">level):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return vector of label values for requested level. 
 
        Length of returned vector is equal to the length of the index. 
 
        Parameters 
        ---------- 
        level : int or str 
            ``level`` is either the integer position of the level in the 
            MultiIndex, or the name of the level. 
 
        Returns 
        ------- 
        values : Index 
            Values is a level of this MultiIndex converted to 
            a single :class:`Index` (or subclass thereof). 
 
        Notes 
        ----- 
        If the level contains missing values, the result may be casted to 
        ``float`` with missing values specified as ``NaN``. This is because 
        the level is converted to a regular ``Index``. 
 
        Examples 
        -------- 
        Create a MultiIndex: 
 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays((list('abc'), list('def'))) 
        &gt;&gt;&gt; mi.names = ['level_1', 'level_2'] 
 
        Get level values by supplying level as either integer or name: 
 
        &gt;&gt;&gt; mi.get_level_values(0) 
        Index(['a', 'b', 'c'], dtype='object', name='level_1') 
        &gt;&gt;&gt; mi.get_level_values('level_2') 
        Index(['d', 'e', 'f'], dtype='object', name='level_2') 
 
        If a level contains missing values, the return type of the level 
        maybe casted to ``float``. 
 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([[1, None, 2], [3, 4, 5]]).dtypes 
        level_0    int64 
        level_1    int64 
        dtype: object 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([[1, None, 2], [3, 4, 5]]).get_level_values(0) 
        Float64Index([1.0, nan, 2.0], dtype='float64') 
        &quot;&quot;&quot;</span>
        <span class="s1">level = self._get_level_number(level)</span>
        <span class="s1">values = self._get_level_values(level)</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s1">@doc(Index.unique)</span>
    <span class="s0">def </span><span class="s1">unique(self</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">level </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super().unique()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level = self._get_level_number(level)</span>
            <span class="s0">return </span><span class="s1">self._get_level_values(level=level</span><span class="s0">, </span><span class="s1">unique=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_frame(self</span><span class="s0">, </span><span class="s1">index: bool = </span><span class="s0">True, </span><span class="s1">name=lib.no_default) -&gt; DataFrame:</span>
        <span class="s3">&quot;&quot;&quot; 
        Create a DataFrame with the levels of the MultiIndex as columns. 
 
        Column ordering is determined by the DataFrame constructor with data as 
        a dict. 
 
        Parameters 
        ---------- 
        index : bool, default True 
            Set the index of the returned DataFrame as the original MultiIndex. 
 
        name : list / sequence of str, optional 
            The passed names should substitute index level names. 
 
        Returns 
        ------- 
        DataFrame : a DataFrame containing the original MultiIndex data. 
 
        See Also 
        -------- 
        DataFrame : Two-dimensional, size-mutable, potentially heterogeneous 
            tabular data. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([['a', 'b'], ['c', 'd']]) 
        &gt;&gt;&gt; mi 
        MultiIndex([('a', 'c'), 
                    ('b', 'd')], 
                   ) 
 
        &gt;&gt;&gt; df = mi.to_frame() 
        &gt;&gt;&gt; df 
             0  1 
        a c  a  c 
        b d  b  d 
 
        &gt;&gt;&gt; df = mi.to_frame(index=False) 
        &gt;&gt;&gt; df 
           0  1 
        0  a  c 
        1  b  d 
 
        &gt;&gt;&gt; df = mi.to_frame(name=['x', 'y']) 
        &gt;&gt;&gt; df 
             x  y 
        a c  a  c 
        b d  b  d 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;Explicitly passing `name=None` currently preserves the Index's name &quot;</span>
                <span class="s2">&quot;or uses a default name of 0. This behaviour is deprecated, and in &quot;</span>
                <span class="s2">&quot;the future `None` will be used as the name of the resulting &quot;</span>
                <span class="s2">&quot;DataFrame column.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">name = lib.no_default</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">is not </span><span class="s1">lib.no_default:</span>
            <span class="s0">if not </span><span class="s1">is_list_like(name):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;'name' must be a list / sequence of column names.&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">len(name) != len(self.levels):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;'name' should have same length as number of levels on index.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">idx_names = name</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx_names = self.names</span>

        <span class="s4"># Guarantee resulting column order - PY36+ dict maintains insertion order</span>
        <span class="s1">result = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s1">(level </span><span class="s0">if </span><span class="s1">lvlname </span><span class="s0">is None else </span><span class="s1">lvlname): self._get_level_values(level)</span>
                <span class="s0">for </span><span class="s1">lvlname</span><span class="s0">, </span><span class="s1">level </span><span class="s0">in </span><span class="s1">zip(idx_names</span><span class="s0">, </span><span class="s1">range(len(self.levels)))</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">copy=</span><span class="s0">False,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">index:</span>
            <span class="s1">result.index = self</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">to_flat_index(self) -&gt; Index:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a MultiIndex to an Index of Tuples containing the level values. 
 
        Returns 
        ------- 
        pd.Index 
            Index with the MultiIndex data represented in Tuples. 
 
        See Also 
        -------- 
        MultiIndex.from_tuples : Convert flat index back to MultiIndex. 
 
        Notes 
        ----- 
        This method will simply return the caller if called by anything other 
        than a MultiIndex. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; index = pd.MultiIndex.from_product( 
        ...     [['foo', 'bar'], ['baz', 'qux']], 
        ...     names=['a', 'b']) 
        &gt;&gt;&gt; index.to_flat_index() 
        Index([('foo', 'baz'), ('foo', 'qux'), 
               ('bar', 'baz'), ('bar', 'qux')], 
              dtype='object') 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Index(self._values</span><span class="s0">, </span><span class="s1">tupleize_cols=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_is_all_dates(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">is_lexsorted(self) -&gt; bool:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;MultiIndex.is_lexsorted is deprecated as a public function, &quot;</span>
            <span class="s2">&quot;users should use MultiIndex.is_monotonic_increasing instead.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._is_lexsorted()</span>

    <span class="s0">def </span><span class="s1">_is_lexsorted(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return True if the codes are lexicographically sorted. 
 
        Returns 
        ------- 
        bool 
 
        Examples 
        -------- 
        In the below examples, the first level of the MultiIndex is sorted because 
        a&lt;b&lt;c, so there is no need to look at the next level. 
 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([['a', 'b', 'c'], ['d', 'e', 'f']]).is_lexsorted() 
        True 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([['a', 'b', 'c'], ['d', 'f', 'e']]).is_lexsorted() 
        True 
 
        In case there is a tie, the lexicographical sorting looks 
        at the next level of the MultiIndex. 
 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([[0, 1, 1], ['a', 'b', 'c']]).is_lexsorted() 
        True 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([[0, 1, 1], ['a', 'c', 'b']]).is_lexsorted() 
        False 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], 
        ...                            ['aa', 'bb', 'aa', 'bb']]).is_lexsorted() 
        True 
        &gt;&gt;&gt; pd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], 
        ...                            ['bb', 'aa', 'aa', 'bb']]).is_lexsorted() 
        False 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._lexsort_depth == self.nlevels</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">lexsort_depth(self) -&gt; int:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;MultiIndex.is_lexsorted is deprecated as a public function, &quot;</span>
            <span class="s2">&quot;users should use MultiIndex.is_monotonic_increasing instead.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._lexsort_depth</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_lexsort_depth(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute and return the lexsort_depth, the number of levels of the 
        MultiIndex that are sorted lexically 
 
        Returns 
        ------- 
        int 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.sortorder </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.sortorder</span>
        <span class="s0">return </span><span class="s1">_lexsort_depth(self.codes</span><span class="s0">, </span><span class="s1">self.nlevels)</span>

    <span class="s0">def </span><span class="s1">_sort_levels_monotonic(self) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        This is an *internal* function. 
 
        Create a new MultiIndex from the current to monotonically sorted 
        items IN the levels. This does not actually make the entire MultiIndex 
        monotonic, JUST the levels. 
 
        The resulting MultiIndex will have the same outward 
        appearance, meaning the same .values and ordering. It will also 
        be .equals() to the original. 
 
        Returns 
        ------- 
        MultiIndex 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']], 
        ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]]) 
        &gt;&gt;&gt; mi 
        MultiIndex([('a', 'bb'), 
                    ('a', 'aa'), 
                    ('b', 'bb'), 
                    ('b', 'aa')], 
                   ) 
 
        &gt;&gt;&gt; mi.sort_values() 
        MultiIndex([('a', 'aa'), 
                    ('a', 'bb'), 
                    ('b', 'aa'), 
                    ('b', 'bb')], 
                   ) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._is_lexsorted() </span><span class="s0">and </span><span class="s1">self.is_monotonic:</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">new_levels = []</span>
        <span class="s1">new_codes = []</span>

        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(self.levels</span><span class="s0">, </span><span class="s1">self.codes):</span>

            <span class="s0">if not </span><span class="s1">lev.is_monotonic:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s4"># indexer to reorder the levels</span>
                    <span class="s1">indexer = lev.argsort()</span>
                <span class="s0">except </span><span class="s1">TypeError:</span>
                    <span class="s0">pass</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">lev = lev.take(indexer)</span>

                    <span class="s4"># indexer to reorder the level codes</span>
                    <span class="s1">indexer = ensure_platform_int(indexer)</span>
                    <span class="s1">ri = lib.get_reverse_indexer(indexer</span><span class="s0">, </span><span class="s1">len(indexer))</span>
                    <span class="s1">level_codes = algos.take_nd(ri</span><span class="s0">, </span><span class="s1">level_codes)</span>

            <span class="s1">new_levels.append(lev)</span>
            <span class="s1">new_codes.append(level_codes)</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">new_levels</span><span class="s0">,</span>
            <span class="s1">new_codes</span><span class="s0">,</span>
            <span class="s1">names=self.names</span><span class="s0">,</span>
            <span class="s1">sortorder=self.sortorder</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">remove_unused_levels(self) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Create new MultiIndex from current that removes unused levels. 
 
        Unused level(s) means levels that are not expressed in the 
        labels. The resulting MultiIndex will have the same outward 
        appearance, meaning the same .values and ordering. It will 
        also be .equals() to the original. 
 
        Returns 
        ------- 
        MultiIndex 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_product([range(2), list('ab')]) 
        &gt;&gt;&gt; mi 
        MultiIndex([(0, 'a'), 
                    (0, 'b'), 
                    (1, 'a'), 
                    (1, 'b')], 
                   ) 
 
        &gt;&gt;&gt; mi[2:] 
        MultiIndex([(1, 'a'), 
                    (1, 'b')], 
                   ) 
 
        The 0 from the first level is not represented 
        and can be removed 
 
        &gt;&gt;&gt; mi2 = mi[2:].remove_unused_levels() 
        &gt;&gt;&gt; mi2.levels 
        FrozenList([[1], ['a', 'b']]) 
        &quot;&quot;&quot;</span>
        <span class="s1">new_levels = []</span>
        <span class="s1">new_codes = []</span>

        <span class="s1">changed = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(self.levels</span><span class="s0">, </span><span class="s1">self.codes):</span>

            <span class="s4"># Since few levels are typically unused, bincount() is more</span>
            <span class="s4"># efficient than unique() - however it only accepts positive values</span>
            <span class="s4"># (and drops order):</span>
            <span class="s1">uniques = np.where(np.bincount(level_codes + </span><span class="s5">1</span><span class="s1">) &gt; </span><span class="s5">0</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span>
            <span class="s1">has_na = int(len(uniques) </span><span class="s0">and </span><span class="s1">(uniques[</span><span class="s5">0</span><span class="s1">] == -</span><span class="s5">1</span><span class="s1">))</span>

            <span class="s0">if </span><span class="s1">len(uniques) != len(lev) + has_na:</span>

                <span class="s0">if </span><span class="s1">lev.isna().any() </span><span class="s0">and </span><span class="s1">len(uniques) == len(lev):</span>
                    <span class="s0">break</span>
                <span class="s4"># We have unused levels</span>
                <span class="s1">changed = </span><span class="s0">True</span>

                <span class="s4"># Recalculate uniques, now preserving order.</span>
                <span class="s4"># Can easily be cythonized by exploiting the already existing</span>
                <span class="s4"># &quot;uniques&quot; and stop parsing &quot;level_codes&quot; when all items</span>
                <span class="s4"># are found:</span>
                <span class="s1">uniques = algos.unique(level_codes)</span>
                <span class="s0">if </span><span class="s1">has_na:</span>
                    <span class="s1">na_idx = np.where(uniques == -</span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s4"># Just ensure that -1 is in first position:</span>
                    <span class="s1">uniques[[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">na_idx[</span><span class="s5">0</span><span class="s1">]]] = uniques[[na_idx[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]]</span>

                <span class="s4"># codes get mapped from uniques to 0:len(uniques)</span>
                <span class="s4"># -1 (if present) is mapped to last position</span>
                <span class="s1">code_mapping = np.zeros(len(lev) + has_na)</span>
                <span class="s4"># ... and reassigned value -1:</span>
                <span class="s1">code_mapping[uniques] = np.arange(len(uniques)) - has_na</span>

                <span class="s1">level_codes = code_mapping[level_codes]</span>

                <span class="s4"># new levels are simple</span>
                <span class="s1">lev = lev.take(uniques[has_na:])</span>

            <span class="s1">new_levels.append(lev)</span>
            <span class="s1">new_codes.append(level_codes)</span>

        <span class="s1">result = self.view()</span>

        <span class="s0">if </span><span class="s1">changed:</span>
            <span class="s1">result._reset_identity()</span>
            <span class="s1">result._set_levels(new_levels</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">result._set_codes(new_codes</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Pickling Methods</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s3">&quot;&quot;&quot;Necessary for making this object picklable&quot;&quot;&quot;</span>
        <span class="s1">d = {</span>
            <span class="s2">&quot;levels&quot;</span><span class="s1">: list(self.levels)</span><span class="s0">,</span>
            <span class="s2">&quot;codes&quot;</span><span class="s1">: list(self.codes)</span><span class="s0">,</span>
            <span class="s2">&quot;sortorder&quot;</span><span class="s1">: self.sortorder</span><span class="s0">,</span>
            <span class="s2">&quot;names&quot;</span><span class="s1">: list(self.names)</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">ibase._new_Index</span><span class="s0">, </span><span class="s1">(type(self)</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, None</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">is_scalar(key):</span>
            <span class="s1">key = com.cast_scalar_indexer(key</span><span class="s0">, </span><span class="s1">warn_float=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">retval = []</span>
            <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(self.levels</span><span class="s0">, </span><span class="s1">self.codes):</span>
                <span class="s0">if </span><span class="s1">level_codes[key] == -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">retval.append(np.nan)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">retval.append(lev[level_codes[key]])</span>

            <span class="s0">return </span><span class="s1">tuple(retval)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># in general cannot be sure whether the result will be sorted</span>
            <span class="s1">sortorder = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">com.is_bool_indexer(key):</span>
                <span class="s1">key = np.asarray(key</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
                <span class="s1">sortorder = self.sortorder</span>
            <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s0">if </span><span class="s1">key.step </span><span class="s0">is None or </span><span class="s1">key.step &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">sortorder = self.sortorder</span>
            <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">Index):</span>
                <span class="s1">key = np.asarray(key)</span>

            <span class="s1">new_codes = [level_codes[key] </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>

            <span class="s0">return </span><span class="s1">MultiIndex(</span>
                <span class="s1">levels=self.levels</span><span class="s0">,</span>
                <span class="s1">codes=new_codes</span><span class="s0">,</span>
                <span class="s1">names=self.names</span><span class="s0">,</span>
                <span class="s1">sortorder=sortorder</span><span class="s0">,</span>
                <span class="s1">verify_integrity=</span><span class="s0">False,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_getitem_slice(self: MultiIndex</span><span class="s0">, </span><span class="s1">slobj: slice) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Fastpath for __getitem__ when we know we have a slice. 
        &quot;&quot;&quot;</span>
        <span class="s1">sortorder = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">slobj.step </span><span class="s0">is None or </span><span class="s1">slobj.step &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">sortorder = self.sortorder</span>

        <span class="s1">new_codes = [level_codes[slobj] </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>

        <span class="s0">return </span><span class="s1">type(self)(</span>
            <span class="s1">levels=self.levels</span><span class="s0">,</span>
            <span class="s1">codes=new_codes</span><span class="s0">,</span>
            <span class="s1">names=self._names</span><span class="s0">,</span>
            <span class="s1">sortorder=sortorder</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s1">@Appender(_index_shared_docs[</span><span class="s2">&quot;take&quot;</span><span class="s1">] % _index_doc_kwargs)</span>
    <span class="s0">def </span><span class="s1">take(</span>
        <span class="s1">self: MultiIndex</span><span class="s0">,</span>
        <span class="s1">indices</span><span class="s0">,</span>
        <span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">allow_fill: bool = </span><span class="s0">True,</span>
        <span class="s1">fill_value=</span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">) -&gt; MultiIndex:</span>
        <span class="s1">nv.validate_take(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">indices = ensure_platform_int(indices)</span>

        <span class="s4"># only fill if we are passing a non-None fill_value</span>
        <span class="s1">allow_fill = self._maybe_disallow_fill(allow_fill</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">indices)</span>

        <span class="s1">na_value = -</span><span class="s5">1</span>

        <span class="s1">taken = [lab.take(indices) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">self.codes]</span>
        <span class="s0">if </span><span class="s1">allow_fill:</span>
            <span class="s1">mask = indices == -</span><span class="s5">1</span>
            <span class="s0">if </span><span class="s1">mask.any():</span>
                <span class="s1">masked = []</span>
                <span class="s0">for </span><span class="s1">new_label </span><span class="s0">in </span><span class="s1">taken:</span>
                    <span class="s1">label_values = new_label</span>
                    <span class="s1">label_values[mask] = na_value</span>
                    <span class="s1">masked.append(np.asarray(label_values))</span>
                <span class="s1">taken = masked</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=self.levels</span><span class="s0">, </span><span class="s1">codes=taken</span><span class="s0">, </span><span class="s1">names=self.names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">append(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s3">&quot;&quot;&quot; 
        Append a collection of Index options together 
 
        Parameters 
        ---------- 
        other : Index or list/tuple of indices 
 
        Returns 
        ------- 
        appended : Index 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">other = [other]</span>

        <span class="s0">if </span><span class="s1">all(</span>
            <span class="s1">(isinstance(o</span><span class="s0">, </span><span class="s1">MultiIndex) </span><span class="s0">and </span><span class="s1">o.nlevels &gt;= self.nlevels) </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">other</span>
        <span class="s1">):</span>
            <span class="s1">arrays = []</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.nlevels):</span>
                <span class="s1">label = self._get_level_values(i)</span>
                <span class="s1">appended = [o._get_level_values(i) </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">other]</span>
                <span class="s1">arrays.append(label.append(appended))</span>
            <span class="s0">return </span><span class="s1">MultiIndex.from_arrays(arrays</span><span class="s0">, </span><span class="s1">names=self.names)</span>

        <span class="s1">to_concat = (self._values</span><span class="s0">,</span><span class="s1">) + tuple(k._values </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">other)</span>
        <span class="s1">new_tuples = np.concatenate(to_concat)</span>

        <span class="s4"># if all(isinstance(x, MultiIndex) for x in other):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">MultiIndex.from_tuples(new_tuples</span><span class="s0">, </span><span class="s1">names=self.names)</span>
        <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">IndexError):</span>
            <span class="s0">return </span><span class="s1">Index._with_infer(new_tuples)</span>

    <span class="s0">def </span><span class="s1">argsort(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s0">return </span><span class="s1">self._values.argsort(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@Appender(_index_shared_docs[</span><span class="s2">&quot;repeat&quot;</span><span class="s1">] % _index_doc_kwargs)</span>
    <span class="s0">def </span><span class="s1">repeat(self</span><span class="s0">, </span><span class="s1">repeats: int</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s1">nv.validate_repeat(()</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;axis&quot;</span><span class="s1">: axis})</span>
        <span class="s4"># error: Incompatible types in assignment (expression has type &quot;ndarray&quot;,</span>
        <span class="s4"># variable has type &quot;int&quot;)</span>
        <span class="s1">repeats = ensure_platform_int(repeats)  </span><span class="s4"># type: ignore[assignment]</span>
        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=self.levels</span><span class="s0">,</span>
            <span class="s1">codes=[</span>
                <span class="s1">level_codes.view(np.ndarray).astype(np.intp</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">).repeat(repeats)</span>
                <span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">names=self.names</span><span class="s0">,</span>
            <span class="s1">sortorder=self.sortorder</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">drop(self</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None, </span><span class="s1">errors=</span><span class="s2">&quot;raise&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Make new MultiIndex with passed list of codes deleted 
 
        Parameters 
        ---------- 
        codes : array-like 
            Must be a list of tuples when level is not specified 
        level : int or level name, default None 
        errors : str, default 'raise' 
 
        Returns 
        ------- 
        dropped : MultiIndex 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">level </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._drop_from_level(codes</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">errors)</span>

        <span class="s0">if not </span><span class="s1">isinstance(codes</span><span class="s0">, </span><span class="s1">(np.ndarray</span><span class="s0">, </span><span class="s1">Index)):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">codes = com.index_labels_to_array(codes</span><span class="s0">, </span><span class="s1">dtype=np.dtype(</span><span class="s2">&quot;object&quot;</span><span class="s1">))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">pass</span>

        <span class="s1">inds = []</span>
        <span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">codes:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">loc = self.get_loc(level_codes)</span>
                <span class="s4"># get_loc returns either an integer, a slice, or a boolean</span>
                <span class="s4"># mask</span>
                <span class="s0">if </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">int):</span>
                    <span class="s1">inds.append(loc)</span>
                <span class="s0">elif </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
                    <span class="s1">step = loc.step </span><span class="s0">if </span><span class="s1">loc.step </span><span class="s0">is not None else </span><span class="s5">1</span>
                    <span class="s1">inds.extend(range(loc.start</span><span class="s0">, </span><span class="s1">loc.stop</span><span class="s0">, </span><span class="s1">step))</span>
                <span class="s0">elif </span><span class="s1">com.is_bool_indexer(loc):</span>
                    <span class="s0">if </span><span class="s1">self._lexsort_depth == </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">warnings.warn(</span>
                            <span class="s2">&quot;dropping on a non-lexsorted multi-index &quot;</span>
                            <span class="s2">&quot;without a level parameter may impact performance.&quot;</span><span class="s0">,</span>
                            <span class="s1">PerformanceWarning</span><span class="s0">,</span>
                            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">loc = loc.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">inds.extend(loc)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;unsupported indexer of type </span><span class="s0">{</span><span class="s1">type(loc)</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(msg)</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">if </span><span class="s1">errors != </span><span class="s2">&quot;ignore&quot;</span><span class="s1">:</span>
                    <span class="s0">raise</span>

        <span class="s0">return </span><span class="s1">self.delete(inds)</span>

    <span class="s0">def </span><span class="s1">_drop_from_level(self</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;raise&quot;</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s1">codes = com.index_labels_to_array(codes)</span>
        <span class="s1">i = self._get_level_number(level)</span>
        <span class="s1">index = self.levels[i]</span>
        <span class="s1">values = index.get_indexer(codes)</span>
        <span class="s4"># If nan should be dropped it will equal -1 here. We have to check which values</span>
        <span class="s4"># are not nan and equal -1, this means they are missing in the index</span>
        <span class="s1">nan_codes = isna(codes)</span>
        <span class="s1">values[(np.equal(nan_codes</span><span class="s0">, False</span><span class="s1">)) &amp; (values == -</span><span class="s5">1</span><span class="s1">)] = -</span><span class="s5">2</span>
        <span class="s0">if </span><span class="s1">index.shape[</span><span class="s5">0</span><span class="s1">] == self.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">values[np.equal(nan_codes</span><span class="s0">, True</span><span class="s1">)] = -</span><span class="s5">2</span>

        <span class="s1">not_found = codes[values == -</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">len(not_found) != </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">errors != </span><span class="s2">&quot;ignore&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">f&quot;labels </span><span class="s0">{</span><span class="s1">not_found</span><span class="s0">} </span><span class="s2">not found in level&quot;</span><span class="s1">)</span>
        <span class="s1">mask = ~algos.isin(self.codes[i]</span><span class="s0">, </span><span class="s1">values)</span>

        <span class="s0">return </span><span class="s1">self[mask]</span>

    <span class="s0">def </span><span class="s1">swaplevel(self</span><span class="s0">, </span><span class="s1">i=-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">j=-</span><span class="s5">1</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Swap level i with level j. 
 
        Calling this method does not change the ordering of the values. 
 
        Parameters 
        ---------- 
        i : int, str, default -2 
            First level of index to be swapped. Can pass level name as string. 
            Type of parameters can be mixed. 
        j : int, str, default -1 
            Second level of index to be swapped. Can pass level name as string. 
            Type of parameters can be mixed. 
 
        Returns 
        ------- 
        MultiIndex 
            A new MultiIndex. 
 
        See Also 
        -------- 
        Series.swaplevel : Swap levels i and j in a MultiIndex. 
        Dataframe.swaplevel : Swap levels i and j in a MultiIndex on a 
            particular axis. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']], 
        ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]]) 
        &gt;&gt;&gt; mi 
        MultiIndex([('a', 'bb'), 
                    ('a', 'aa'), 
                    ('b', 'bb'), 
                    ('b', 'aa')], 
                   ) 
        &gt;&gt;&gt; mi.swaplevel(0, 1) 
        MultiIndex([('bb', 'a'), 
                    ('aa', 'a'), 
                    ('bb', 'b'), 
                    ('aa', 'b')], 
                   ) 
        &quot;&quot;&quot;</span>
        <span class="s1">new_levels = list(self.levels)</span>
        <span class="s1">new_codes = list(self.codes)</span>
        <span class="s1">new_names = list(self.names)</span>

        <span class="s1">i = self._get_level_number(i)</span>
        <span class="s1">j = self._get_level_number(j)</span>

        <span class="s1">new_levels[i]</span><span class="s0">, </span><span class="s1">new_levels[j] = new_levels[j]</span><span class="s0">, </span><span class="s1">new_levels[i]</span>
        <span class="s1">new_codes[i]</span><span class="s0">, </span><span class="s1">new_codes[j] = new_codes[j]</span><span class="s0">, </span><span class="s1">new_codes[i]</span>
        <span class="s1">new_names[i]</span><span class="s0">, </span><span class="s1">new_names[j] = new_names[j]</span><span class="s0">, </span><span class="s1">new_names[i]</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">reorder_levels(self</span><span class="s0">, </span><span class="s1">order) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Rearrange levels using input order. May not drop or duplicate levels. 
 
        Parameters 
        ---------- 
        order : list of int or list of str 
            List representing new level order. Reference level by number 
            (position) or by key (label). 
 
        Returns 
        ------- 
        MultiIndex 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([[1, 2], [3, 4]], names=['x', 'y']) 
        &gt;&gt;&gt; mi 
        MultiIndex([(1, 3), 
                    (2, 4)], 
                   names=['x', 'y']) 
 
        &gt;&gt;&gt; mi.reorder_levels(order=[1, 0]) 
        MultiIndex([(3, 1), 
                    (4, 2)], 
                   names=['y', 'x']) 
 
        &gt;&gt;&gt; mi.reorder_levels(order=['y', 'x']) 
        MultiIndex([(3, 1), 
                    (4, 2)], 
                   names=['y', 'x']) 
        &quot;&quot;&quot;</span>
        <span class="s1">order = [self._get_level_number(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">order]</span>
        <span class="s0">if </span><span class="s1">len(order) != self.nlevels:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span>
                <span class="s2">f&quot;Length of order must be same as number of levels (</span><span class="s0">{</span><span class="s1">self.nlevels</span><span class="s0">}</span><span class="s2">), &quot;</span>
                <span class="s2">f&quot;got </span><span class="s0">{</span><span class="s1">len(order)</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
        <span class="s1">new_levels = [self.levels[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">order]</span>
        <span class="s1">new_codes = [self.codes[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">order]</span>
        <span class="s1">new_names = [self.names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">order]</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_codes_for_sorting(self) -&gt; list[Categorical]:</span>
        <span class="s3">&quot;&quot;&quot; 
        we are categorizing our codes by using the 
        available categories (all, not just observed) 
        excluding any missing ones (-1); this is in preparation 
        for sorting, where we need to disambiguate that -1 is not 
        a valid valid 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">cats(level_codes):</span>
            <span class="s0">return </span><span class="s1">np.arange(</span>
                <span class="s1">np.array(level_codes).max() + </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">len(level_codes) </span><span class="s0">else </span><span class="s5">0</span><span class="s0">,</span>
                <span class="s1">dtype=level_codes.dtype</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">[</span>
            <span class="s1">Categorical.from_codes(level_codes</span><span class="s0">, </span><span class="s1">cats(level_codes)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">sortlevel(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">ascending: bool = </span><span class="s0">True, </span><span class="s1">sort_remaining: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; tuple[MultiIndex</span><span class="s0">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Sort MultiIndex at the requested level. 
 
        The result will respect the original ordering of the associated 
        factor at that level. 
 
        Parameters 
        ---------- 
        level : list-like, int or str, default 0 
            If a string is given, must be a name of the level. 
            If list-like must be names or ints of levels. 
        ascending : bool, default True 
            False to sort in descending order. 
            Can also be a list to specify a directed ordering. 
        sort_remaining : sort by the remaining levels after level 
 
        Returns 
        ------- 
        sorted_index : pd.MultiIndex 
            Resulting index. 
        indexer : np.ndarray[np.intp] 
            Indices of output values in original index. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([[0, 0], [2, 1]]) 
        &gt;&gt;&gt; mi 
        MultiIndex([(0, 2), 
                    (0, 1)], 
                   ) 
 
        &gt;&gt;&gt; mi.sortlevel() 
        (MultiIndex([(0, 1), 
                    (0, 2)], 
                   ), array([1, 0])) 
 
        &gt;&gt;&gt; mi.sortlevel(sort_remaining=False) 
        (MultiIndex([(0, 2), 
                    (0, 1)], 
                   ), array([0, 1])) 
 
        &gt;&gt;&gt; mi.sortlevel(1) 
        (MultiIndex([(0, 1), 
                    (0, 2)], 
                   ), array([1, 0])) 
 
        &gt;&gt;&gt; mi.sortlevel(1, ascending=False) 
        (MultiIndex([(0, 2), 
                    (0, 1)], 
                   ), array([0, 1])) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(level</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">int)):</span>
            <span class="s1">level = [level]</span>
        <span class="s1">level = [self._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>
        <span class="s1">sortorder = </span><span class="s0">None</span>

        <span class="s4"># we have a directed ordering via ascending</span>
        <span class="s0">if </span><span class="s1">isinstance(ascending</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s0">if not </span><span class="s1">len(level) == len(ascending):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;level must have same length as ascending&quot;</span><span class="s1">)</span>

            <span class="s1">indexer = lexsort_indexer(</span>
                <span class="s1">[self.codes[lev] </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span><span class="s0">, </span><span class="s1">orders=ascending</span>
            <span class="s1">)</span>

        <span class="s4"># level ordering</span>
        <span class="s0">else</span><span class="s1">:</span>

            <span class="s1">codes = list(self.codes)</span>
            <span class="s1">shape = list(self.levshape)</span>

            <span class="s4"># partition codes and shape</span>
            <span class="s1">primary = tuple(codes[lev] </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level)</span>
            <span class="s1">primshp = tuple(shape[lev] </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level)</span>

            <span class="s4"># Reverse sorted to retain the order of</span>
            <span class="s4"># smaller indices that needs to be removed</span>
            <span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">sorted(level</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s1">codes.pop(lev)</span>
                <span class="s1">shape.pop(lev)</span>

            <span class="s0">if </span><span class="s1">sort_remaining:</span>
                <span class="s1">primary += primary + tuple(codes)</span>
                <span class="s1">primshp += primshp + tuple(shape)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">sortorder = level[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">indexer = indexer_from_factorized(primary</span><span class="s0">, </span><span class="s1">primshp</span><span class="s0">, </span><span class="s1">compress=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">ascending:</span>
                <span class="s1">indexer = indexer[::-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">indexer = ensure_platform_int(indexer)</span>
        <span class="s1">new_codes = [level_codes.take(indexer) </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>

        <span class="s1">new_index = MultiIndex(</span>
            <span class="s1">codes=new_codes</span><span class="s0">,</span>
            <span class="s1">levels=self.levels</span><span class="s0">,</span>
            <span class="s1">names=self.names</span><span class="s0">,</span>
            <span class="s1">sortorder=sortorder</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">new_index</span><span class="s0">, </span><span class="s1">indexer</span>

    <span class="s0">def </span><span class="s1">_wrap_reindex_result(self</span><span class="s0">, </span><span class="s1">target</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">preserve_names: bool):</span>
        <span class="s0">if not </span><span class="s1">isinstance(target</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">target = self</span>
            <span class="s0">elif </span><span class="s1">(indexer &gt;= </span><span class="s5">0</span><span class="s1">).all():</span>
                <span class="s1">target = self.take(indexer)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">target = MultiIndex.from_tuples(target)</span>
                <span class="s0">except </span><span class="s1">TypeError:</span>
                    <span class="s4"># not all tuples, see test_constructor_dict_multiindex_reindex_flat</span>
                    <span class="s0">return </span><span class="s1">target</span>

        <span class="s1">target = self._maybe_preserve_names(target</span><span class="s0">, </span><span class="s1">preserve_names)</span>
        <span class="s0">return </span><span class="s1">target</span>

    <span class="s0">def </span><span class="s1">_maybe_preserve_names(self</span><span class="s0">, </span><span class="s1">target: Index</span><span class="s0">, </span><span class="s1">preserve_names: bool) -&gt; Index:</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">preserve_names</span>
            <span class="s0">and </span><span class="s1">target.nlevels == self.nlevels</span>
            <span class="s0">and </span><span class="s1">target.names != self.names</span>
        <span class="s1">):</span>
            <span class="s1">target = target.copy(deep=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">target.names = self.names</span>
        <span class="s0">return </span><span class="s1">target</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Indexing Methods</span>

    <span class="s0">def </span><span class="s1">_check_indexing_error(self</span><span class="s0">, </span><span class="s1">key) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">is_hashable(key) </span><span class="s0">or </span><span class="s1">is_iterator(key):</span>
            <span class="s4"># We allow tuples if they are hashable, whereas other Index</span>
            <span class="s4">#  subclasses require scalar.</span>
            <span class="s4"># We have to explicitly exclude generators, as these are hashable.</span>
            <span class="s0">raise </span><span class="s1">InvalidIndexError(key)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_should_fallback_to_positional(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Should integer key(s) be treated as positional? 
        &quot;&quot;&quot;</span>
        <span class="s4"># GH#33355</span>
        <span class="s0">return </span><span class="s1">self.levels[</span><span class="s5">0</span><span class="s1">]._should_fallback_to_positional</span>

    <span class="s0">def </span><span class="s1">_get_values_for_loc(self</span><span class="s0">, </span><span class="s1">series: Series</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot; 
        Do a positional lookup on the given Series, returning either a scalar 
        or a Series. 
 
        Assumes that `series.index is self` 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values = series._values[loc]</span>
        <span class="s0">if </span><span class="s1">is_scalar(loc):</span>
            <span class="s0">return </span><span class="s1">new_values</span>

        <span class="s0">if </span><span class="s1">len(new_values) == </span><span class="s5">1 </span><span class="s0">and not </span><span class="s1">self.nlevels &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># If more than one level left, we can not return a scalar</span>
            <span class="s0">return </span><span class="s1">new_values[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">new_index = self[loc]</span>
        <span class="s1">new_index = maybe_droplevels(new_index</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s1">new_ser = series._constructor(new_values</span><span class="s0">, </span><span class="s1">index=new_index</span><span class="s0">, </span><span class="s1">name=series.name)</span>
        <span class="s0">return </span><span class="s1">new_ser.__finalize__(series)</span>

    <span class="s0">def </span><span class="s1">_get_indexer_strict(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">axis_name: str</span>
    <span class="s1">) -&gt; tuple[Index</span><span class="s0">, </span><span class="s1">npt.NDArray[np.intp]]:</span>

        <span class="s1">keyarr = key</span>
        <span class="s0">if not </span><span class="s1">isinstance(keyarr</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s1">keyarr = com.asarray_tuplesafe(keyarr)</span>

        <span class="s0">if </span><span class="s1">len(keyarr) </span><span class="s0">and not </span><span class="s1">isinstance(keyarr[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">indexer = self._get_indexer_level_0(keyarr)</span>

            <span class="s1">self._raise_if_missing(key</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis_name)</span>
            <span class="s0">return </span><span class="s1">self[indexer]</span><span class="s0">, </span><span class="s1">indexer</span>

        <span class="s0">return </span><span class="s1">super()._get_indexer_strict(key</span><span class="s0">, </span><span class="s1">axis_name)</span>

    <span class="s0">def </span><span class="s1">_raise_if_missing(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis_name: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">keyarr = key</span>
        <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s1">keyarr = com.asarray_tuplesafe(key)</span>

        <span class="s0">if </span><span class="s1">len(keyarr) </span><span class="s0">and not </span><span class="s1">isinstance(keyarr[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s4"># i.e. same condition for special case in MultiIndex._get_indexer_strict</span>

            <span class="s1">mask = indexer == -</span><span class="s5">1</span>
            <span class="s0">if </span><span class="s1">mask.any():</span>
                <span class="s1">check = self.levels[</span><span class="s5">0</span><span class="s1">].get_indexer(keyarr)</span>
                <span class="s1">cmask = check == -</span><span class="s5">1</span>
                <span class="s0">if </span><span class="s1">cmask.any():</span>
                    <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">keyarr[cmask]</span><span class="s0">} </span><span class="s2">not in index&quot;</span><span class="s1">)</span>
                <span class="s4"># We get here when levels still contain values which are not</span>
                <span class="s4"># actually in Index anymore</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">keyarr</span><span class="s0">} </span><span class="s2">not in index&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super()._raise_if_missing(key</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis_name)</span>

    <span class="s0">def </span><span class="s1">_get_indexer_level_0(self</span><span class="s0">, </span><span class="s1">target) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Optimized equivalent to `self.get_level_values(0).get_indexer_for(target)`. 
        &quot;&quot;&quot;</span>
        <span class="s1">lev = self.levels[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">codes = self._codes[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">cat = Categorical.from_codes(codes=codes</span><span class="s0">, </span><span class="s1">categories=lev)</span>
        <span class="s1">ci = Index(cat)</span>
        <span class="s0">return </span><span class="s1">ci.get_indexer_for(target)</span>

    <span class="s0">def </span><span class="s1">get_slice_bound(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">label: Hashable | Sequence[Hashable]</span><span class="s0">, </span><span class="s1">side: str</span><span class="s0">, </span><span class="s1">kind=lib.no_default</span>
    <span class="s1">) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        For an ordered MultiIndex, compute slice bound 
        that corresponds to given label. 
 
        Returns leftmost (one-past-the-rightmost if `side=='right') position 
        of given label. 
 
        Parameters 
        ---------- 
        label : object or tuple of objects 
        side : {'left', 'right'} 
        kind : {'loc', 'getitem', None} 
 
            .. deprecated:: 1.4.0 
 
        Returns 
        ------- 
        int 
            Index of label. 
 
        Notes 
        ----- 
        This method only works if level 0 index of the MultiIndex is lexsorted. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')]) 
 
        Get the locations from the leftmost 'b' in the first level 
        until the end of the multiindex: 
 
        &gt;&gt;&gt; mi.get_slice_bound('b', side=&quot;left&quot;) 
        1 
 
        Like above, but if you get the locations from the rightmost 
        'b' in the first level and 'f' in the second level: 
 
        &gt;&gt;&gt; mi.get_slice_bound(('b','f'), side=&quot;right&quot;) 
        3 
 
        See Also 
        -------- 
        MultiIndex.get_loc : Get location for a label or a tuple of labels. 
        MultiIndex.get_locs : Get location for a label/slice/list/mask or a 
                              sequence of such. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._deprecated_arg(kind</span><span class="s0">, </span><span class="s2">&quot;kind&quot;</span><span class="s0">, </span><span class="s2">&quot;get_slice_bound&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">isinstance(label</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">label = (label</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._partial_tup_index(label</span><span class="s0">, </span><span class="s1">side=side)</span>

    <span class="s0">def </span><span class="s1">slice_locs(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None, </span><span class="s1">step=</span><span class="s0">None, </span><span class="s1">kind=lib.no_default</span>
    <span class="s1">) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s3">&quot;&quot;&quot; 
        For an ordered MultiIndex, compute the slice locations for input 
        labels. 
 
        The input labels can be tuples representing partial levels, e.g. for a 
        MultiIndex with 3 levels, you can pass a single value (corresponding to 
        the first level), or a 1-, 2-, or 3-tuple. 
 
        Parameters 
        ---------- 
        start : label or tuple, default None 
            If None, defaults to the beginning 
        end : label or tuple 
            If None, defaults to the end 
        step : int or None 
            Slice step 
        kind : string, optional, defaults None 
 
            .. deprecated:: 1.4.0 
 
        Returns 
        ------- 
        (start, end) : (int, int) 
 
        Notes 
        ----- 
        This method only works if the MultiIndex is properly lexsorted. So, 
        if only the first 2 levels of a 3-level MultiIndex are lexsorted, 
        you can only pass two levels to ``.slice_locs``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')], 
        ...                                names=['A', 'B']) 
 
        Get the slice locations from the beginning of 'b' in the first level 
        until the end of the multiindex: 
 
        &gt;&gt;&gt; mi.slice_locs(start='b') 
        (1, 4) 
 
        Like above, but stop at the end of 'b' in the first level and 'f' in 
        the second level: 
 
        &gt;&gt;&gt; mi.slice_locs(start='b', end=('b', 'f')) 
        (1, 3) 
 
        See Also 
        -------- 
        MultiIndex.get_loc : Get location for a label or a tuple of labels. 
        MultiIndex.get_locs : Get location for a label/slice/list/mask or a 
                              sequence of such. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._deprecated_arg(kind</span><span class="s0">, </span><span class="s2">&quot;kind&quot;</span><span class="s0">, </span><span class="s2">&quot;slice_locs&quot;</span><span class="s1">)</span>
        <span class="s4"># This function adds nothing to its parent implementation (the magic</span>
        <span class="s4"># happens in get_slice_bound method), but it adds meaningful doc.</span>
        <span class="s0">return </span><span class="s1">super().slice_locs(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">step)</span>

    <span class="s0">def </span><span class="s1">_partial_tup_index(self</span><span class="s0">, </span><span class="s1">tup: tuple</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">len(tup) &gt; self._lexsort_depth:</span>
            <span class="s0">raise </span><span class="s1">UnsortedIndexError(</span>
                <span class="s2">f&quot;Key length (</span><span class="s0">{</span><span class="s1">len(tup)</span><span class="s0">}</span><span class="s2">) was greater than MultiIndex lexsort depth &quot;</span>
                <span class="s2">f&quot;(</span><span class="s0">{</span><span class="s1">self._lexsort_depth</span><span class="s0">}</span><span class="s2">)&quot;</span>
            <span class="s1">)</span>

        <span class="s1">n = len(tup)</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">len(self)</span>
        <span class="s1">zipped = zip(tup</span><span class="s0">, </span><span class="s1">self.levels</span><span class="s0">, </span><span class="s1">self.codes)</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">(lab</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">level_codes) </span><span class="s0">in </span><span class="s1">enumerate(zipped):</span>
            <span class="s1">section = level_codes[start:end]</span>

            <span class="s0">if </span><span class="s1">lab </span><span class="s0">not in </span><span class="s1">lev </span><span class="s0">and not </span><span class="s1">isna(lab):</span>
                <span class="s4"># short circuit</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">loc = lev.searchsorted(lab</span><span class="s0">, </span><span class="s1">side=side)</span>
                <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s4"># non-comparable e.g. test_slice_locs_with_type_mismatch</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Level type mismatch: </span><span class="s0">{</span><span class="s1">lab</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
                <span class="s0">if not </span><span class="s1">is_integer(loc):</span>
                    <span class="s4"># non-comparable level, e.g. test_groupby_example</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Level type mismatch: </span><span class="s0">{</span><span class="s1">lab</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">side == </span><span class="s2">&quot;right&quot; </span><span class="s0">and </span><span class="s1">loc &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">loc -= </span><span class="s5">1</span>
                <span class="s0">return </span><span class="s1">start + section.searchsorted(loc</span><span class="s0">, </span><span class="s1">side=side)</span>

            <span class="s1">idx = self._get_loc_single_level_index(lev</span><span class="s0">, </span><span class="s1">lab)</span>
            <span class="s0">if </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">slice) </span><span class="s0">and </span><span class="s1">k &lt; n - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># Get start and end value from slice, necessary when a non-integer</span>
                <span class="s4"># interval is given as input GH#37707</span>
                <span class="s1">start = idx.start</span>
                <span class="s1">end = idx.stop</span>
            <span class="s0">elif </span><span class="s1">k &lt; n - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">end = start + section.searchsorted(idx</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;right&quot;</span><span class="s1">)</span>
                <span class="s1">start = start + section.searchsorted(idx</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">idx = idx.start</span>
                <span class="s0">return </span><span class="s1">start + section.searchsorted(idx</span><span class="s0">, </span><span class="s1">side=side)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">start + section.searchsorted(idx</span><span class="s0">, </span><span class="s1">side=side)</span>

    <span class="s0">def </span><span class="s1">_get_loc_single_level_index(self</span><span class="s0">, </span><span class="s1">level_index: Index</span><span class="s0">, </span><span class="s1">key: Hashable) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        If key is NA value, location of index unify as -1. 
 
        Parameters 
        ---------- 
        level_index: Index 
        key : label 
 
        Returns 
        ------- 
        loc : int 
            If key is NA value, loc is -1 
            Else, location of key in index. 
 
        See Also 
        -------- 
        Index.get_loc : The get_loc method for (single-level) index. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">is_scalar(key) </span><span class="s0">and </span><span class="s1">isna(key):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s5">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">level_index.get_loc(key)</span>

    <span class="s0">def </span><span class="s1">get_loc(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">method=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get location for a label or a tuple of labels. 
 
        The location is returned as an integer/slice or boolean 
        mask. 
 
        Parameters 
        ---------- 
        key : label or tuple of labels (one for each level) 
        method : None 
 
        Returns 
        ------- 
        loc : int, slice object or boolean mask 
            If the key is past the lexsort depth, the return may be a 
            boolean mask array, otherwise it is always a slice or int. 
 
        See Also 
        -------- 
        Index.get_loc : The get_loc method for (single-level) index. 
        MultiIndex.slice_locs : Get slice location given start label(s) and 
                                end label(s). 
        MultiIndex.get_locs : Get location for a label/slice/list/mask or a 
                              sequence of such. 
 
        Notes 
        ----- 
        The key cannot be a slice, list of same-level labels, a boolean mask, 
        or a sequence of such. If you want to use those, use 
        :meth:`MultiIndex.get_locs` instead. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([list('abb'), list('def')]) 
 
        &gt;&gt;&gt; mi.get_loc('b') 
        slice(1, 3, None) 
 
        &gt;&gt;&gt; mi.get_loc(('b', 'e')) 
        1 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s2">&quot;only the default get_loc method is &quot;</span>
                <span class="s2">&quot;currently supported for MultiIndex&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._check_indexing_error(key)</span>

        <span class="s0">def </span><span class="s1">_maybe_to_slice(loc):</span>
            <span class="s3">&quot;&quot;&quot;convert integer indexer to boolean mask or slice if possible&quot;&quot;&quot;</span>
            <span class="s0">if not </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">or </span><span class="s1">loc.dtype != np.intp:</span>
                <span class="s0">return </span><span class="s1">loc</span>

            <span class="s1">loc = lib.maybe_indices_to_slice(loc</span><span class="s0">, </span><span class="s1">len(self))</span>
            <span class="s0">if </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s0">return </span><span class="s1">loc</span>

            <span class="s1">mask = np.empty(len(self)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
            <span class="s1">mask.fill(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">mask[loc] = </span><span class="s0">True</span>
            <span class="s0">return </span><span class="s1">mask</span>

        <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">loc = self._get_level_indexer(key</span><span class="s0">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">_maybe_to_slice(loc)</span>

        <span class="s1">keylen = len(key)</span>
        <span class="s0">if </span><span class="s1">self.nlevels &lt; keylen:</span>
            <span class="s0">raise </span><span class="s1">KeyError(</span>
                <span class="s2">f&quot;Key length (</span><span class="s0">{</span><span class="s1">keylen</span><span class="s0">}</span><span class="s2">) exceeds index depth (</span><span class="s0">{</span><span class="s1">self.nlevels</span><span class="s0">}</span><span class="s2">)&quot;</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">keylen == self.nlevels </span><span class="s0">and </span><span class="s1">self.is_unique:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._engine.get_loc(key)</span>
            <span class="s0">except </span><span class="s1">TypeError:</span>
                <span class="s4"># e.g. test_partial_slicing_with_multiindex partial string slicing</span>
                <span class="s1">loc</span><span class="s0">, </span><span class="s1">_ = self.get_loc_level(key</span><span class="s0">, </span><span class="s1">list(range(self.nlevels)))</span>
                <span class="s0">return </span><span class="s1">loc</span>

        <span class="s4"># -- partial selection or non-unique index</span>
        <span class="s4"># break the key into 2 parts based on the lexsort_depth of the index;</span>
        <span class="s4"># the first part returns a continuous slice of the index; the 2nd part</span>
        <span class="s4"># needs linear search within the slice</span>
        <span class="s1">i = self._lexsort_depth</span>
        <span class="s1">lead_key</span><span class="s0">, </span><span class="s1">follow_key = key[:i]</span><span class="s0">, </span><span class="s1">key[i:]</span>

        <span class="s0">if not </span><span class="s1">lead_key:</span>
            <span class="s1">start = </span><span class="s5">0</span>
            <span class="s1">stop = len(self)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">start</span><span class="s0">, </span><span class="s1">stop = self.slice_locs(lead_key</span><span class="s0">, </span><span class="s1">lead_key)</span>
            <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s4"># e.g. test_groupby_example key = ((0, 0, 1, 2), &quot;new_col&quot;)</span>
                <span class="s4">#  when self has 5 integer levels</span>
                <span class="s0">raise </span><span class="s1">KeyError(key) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s0">if </span><span class="s1">start == stop:</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>

        <span class="s0">if not </span><span class="s1">follow_key:</span>
            <span class="s0">return </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop)</span>

        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;indexing past lexsort depth may impact performance.&quot;</span><span class="s0">,</span>
            <span class="s1">PerformanceWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">loc = np.arange(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">enumerate(follow_key</span><span class="s0">, </span><span class="s1">len(lead_key)):</span>
            <span class="s1">mask = self.codes[i][loc] == self._get_loc_single_level_index(</span>
                <span class="s1">self.levels[i]</span><span class="s0">, </span><span class="s1">k</span>
            <span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">mask.all():</span>
                <span class="s1">loc = loc[mask]</span>
            <span class="s0">if not </span><span class="s1">len(loc):</span>
                <span class="s0">raise </span><span class="s1">KeyError(key)</span>

        <span class="s0">return </span><span class="s1">_maybe_to_slice(loc) </span><span class="s0">if </span><span class="s1">len(loc) != stop - start </span><span class="s0">else </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop)</span>

    <span class="s0">def </span><span class="s1">get_loc_level(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">drop_level: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get location and sliced index for requested label(s)/level(s). 
 
        Parameters 
        ---------- 
        key : label or sequence of labels 
        level : int/level name or list thereof, optional 
        drop_level : bool, default True 
            If ``False``, the resulting index will not drop any level. 
 
        Returns 
        ------- 
        loc : A 2-tuple where the elements are: 
              Element 0: int, slice object or boolean array 
              Element 1: The resulting sliced multiindex/index. If the key 
              contains all levels, this will be ``None``. 
 
        See Also 
        -------- 
        MultiIndex.get_loc  : Get location for a label or a tuple of labels. 
        MultiIndex.get_locs : Get location for a label/slice/list/mask or a 
                              sequence of such. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([list('abb'), list('def')], 
        ...                                names=['A', 'B']) 
 
        &gt;&gt;&gt; mi.get_loc_level('b') 
        (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B')) 
 
        &gt;&gt;&gt; mi.get_loc_level('e', level='B') 
        (array([False,  True, False]), Index(['b'], dtype='object', name='A')) 
 
        &gt;&gt;&gt; mi.get_loc_level(['b', 'e']) 
        (1, None) 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(level</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">level = self._get_level_number(level)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level = [self._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>

        <span class="s1">loc</span><span class="s0">, </span><span class="s1">mi = self._get_loc_level(key</span><span class="s0">, </span><span class="s1">level=level)</span>
        <span class="s0">if not </span><span class="s1">drop_level:</span>
            <span class="s0">if </span><span class="s1">lib.is_integer(loc):</span>
                <span class="s1">mi = self[loc : loc + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">mi = self[loc]</span>
        <span class="s0">return </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">mi</span>

    <span class="s0">def </span><span class="s1">_get_loc_level(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">level: int | list[int] = </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        get_loc_level but with `level` known to be positional, not name-based. 
        &quot;&quot;&quot;</span>

        <span class="s4"># different name to distinguish from maybe_droplevels</span>
        <span class="s0">def </span><span class="s1">maybe_mi_droplevels(indexer</span><span class="s0">, </span><span class="s1">levels):</span>
            <span class="s1">new_index = self[indexer]</span>

            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">sorted(levels</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s1">new_index = new_index._drop_level_numbers([i])</span>

            <span class="s0">return </span><span class="s1">new_index</span>

        <span class="s0">if </span><span class="s1">isinstance(level</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
            <span class="s0">if </span><span class="s1">len(key) != len(level):</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s2">&quot;Key for location must have same length as number of levels&quot;</span>
                <span class="s1">)</span>
            <span class="s1">result = </span><span class="s0">None</span>
            <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">zip(level</span><span class="s0">, </span><span class="s1">key):</span>
                <span class="s1">loc</span><span class="s0">, </span><span class="s1">new_index = self._get_loc_level(k</span><span class="s0">, </span><span class="s1">level=lev)</span>
                <span class="s0">if </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
                    <span class="s1">mask = np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
                    <span class="s1">mask[loc] = </span><span class="s0">True</span>
                    <span class="s1">loc = mask</span>
                <span class="s1">result = loc </span><span class="s0">if </span><span class="s1">result </span><span class="s0">is None else </span><span class="s1">result &amp; loc</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s4"># FIXME: we should be only dropping levels on which we are</span>
                <span class="s4">#  scalar-indexing</span>
                <span class="s1">mi = maybe_mi_droplevels(result</span><span class="s0">, </span><span class="s1">level)</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s4"># droplevel failed because we tried to drop all levels,</span>
                <span class="s4">#  i.e. len(level) == self.nlevels</span>
                <span class="s1">mi = self[result]</span>

            <span class="s0">return </span><span class="s1">result</span><span class="s0">, </span><span class="s1">mi</span>

        <span class="s4"># kludge for #1796</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">key = tuple(key)</span>

        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">level == </span><span class="s5">0</span><span class="s1">:</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s4"># Check if this tuple is a single key in our first level</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.levels[</span><span class="s5">0</span><span class="s1">]:</span>
                    <span class="s1">indexer = self._get_level_indexer(key</span><span class="s0">, </span><span class="s1">level=level)</span>
                    <span class="s1">new_index = maybe_mi_droplevels(indexer</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">new_index</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">InvalidIndexError):</span>
                <span class="s0">pass</span>

            <span class="s0">if not </span><span class="s1">any(isinstance(k</span><span class="s0">, </span><span class="s1">slice) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key):</span>

                <span class="s0">if </span><span class="s1">len(key) == self.nlevels </span><span class="s0">and </span><span class="s1">self.is_unique:</span>
                    <span class="s4"># Complete key in unique index -&gt; standard get_loc</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">(self._engine.get_loc(key)</span><span class="s0">, None</span><span class="s1">)</span>
                    <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">err:</span>
                        <span class="s0">raise </span><span class="s1">KeyError(key) </span><span class="s0">from </span><span class="s1">err</span>
                    <span class="s0">except </span><span class="s1">TypeError:</span>
                        <span class="s4"># e.g. partial string indexing</span>
                        <span class="s4">#  test_partial_string_timestamp_multiindex</span>
                        <span class="s0">pass</span>

                <span class="s4"># partial selection</span>
                <span class="s1">indexer = self.get_loc(key)</span>
                <span class="s1">ilevels = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(key)) </span><span class="s0">if </span><span class="s1">key[i] != slice(</span><span class="s0">None, None</span><span class="s1">)]</span>
                <span class="s0">if </span><span class="s1">len(ilevels) == self.nlevels:</span>
                    <span class="s0">if </span><span class="s1">is_integer(indexer):</span>
                        <span class="s4"># we are dropping all levels</span>
                        <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, None</span>

                    <span class="s4"># TODO: in some cases we still need to drop some levels,</span>
                    <span class="s4">#  e.g. test_multiindex_perf_warn</span>
                    <span class="s4"># test_partial_string_timestamp_multiindex</span>
                    <span class="s1">ilevels = [</span>
                        <span class="s1">i</span>
                        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(key))</span>
                        <span class="s0">if </span><span class="s1">(</span>
                            <span class="s0">not </span><span class="s1">isinstance(key[i]</span><span class="s0">, </span><span class="s1">str)</span>
                            <span class="s0">or not </span><span class="s1">self.levels[i]._supports_partial_string_indexing</span>
                        <span class="s1">)</span>
                        <span class="s0">and </span><span class="s1">key[i] != slice(</span><span class="s0">None, None</span><span class="s1">)</span>
                    <span class="s1">]</span>
                    <span class="s0">if </span><span class="s1">len(ilevels) == self.nlevels:</span>
                        <span class="s4"># TODO: why?</span>
                        <span class="s1">ilevels = []</span>
                <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">maybe_mi_droplevels(indexer</span><span class="s0">, </span><span class="s1">ilevels)</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">indexer = </span><span class="s0">None</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">enumerate(key):</span>
                    <span class="s0">if not </span><span class="s1">isinstance(k</span><span class="s0">, </span><span class="s1">slice):</span>
                        <span class="s1">loc_level = self._get_level_indexer(k</span><span class="s0">, </span><span class="s1">level=i)</span>
                        <span class="s0">if </span><span class="s1">isinstance(loc_level</span><span class="s0">, </span><span class="s1">slice):</span>
                            <span class="s0">if </span><span class="s1">com.is_null_slice(loc_level) </span><span class="s0">or </span><span class="s1">com.is_full_slice(</span>
                                <span class="s1">loc_level</span><span class="s0">, </span><span class="s1">len(self)</span>
                            <span class="s1">):</span>
                                <span class="s4"># everything</span>
                                <span class="s0">continue</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s4"># e.g. test_xs_IndexSlice_argument_not_implemented</span>
                                <span class="s1">k_index = np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
                                <span class="s1">k_index[loc_level] = </span><span class="s0">True</span>

                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">k_index = loc_level</span>

                    <span class="s0">elif </span><span class="s1">com.is_null_slice(k):</span>
                        <span class="s4"># taking everything, does not affect `indexer` below</span>
                        <span class="s0">continue</span>

                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s4"># FIXME: this message can be inaccurate, e.g.</span>
                        <span class="s4">#  test_series_varied_multiindex_alignment</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Expected label or tuple of labels, got </span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

                    <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is None</span><span class="s1">:</span>
                        <span class="s1">indexer = k_index</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">indexer &amp;= k_index</span>
                <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">indexer = slice(</span><span class="s0">None, None</span><span class="s1">)</span>
                <span class="s1">ilevels = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(key)) </span><span class="s0">if </span><span class="s1">key[i] != slice(</span><span class="s0">None, None</span><span class="s1">)]</span>
                <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">maybe_mi_droplevels(indexer</span><span class="s0">, </span><span class="s1">ilevels)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">indexer = self._get_level_indexer(key</span><span class="s0">, </span><span class="s1">level=level)</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str)</span>
                <span class="s0">and </span><span class="s1">self.levels[level]._supports_partial_string_indexing</span>
            <span class="s1">):</span>
                <span class="s4"># check to see if we did an exact lookup vs sliced</span>
                <span class="s1">check = self.levels[level].get_loc(key)</span>
                <span class="s0">if not </span><span class="s1">is_integer(check):</span>
                    <span class="s4"># e.g. test_partial_string_timestamp_multiindex</span>
                    <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">self[indexer]</span>

            <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">maybe_mi_droplevels(indexer</span><span class="s0">, </span><span class="s1">[level])</span>

    <span class="s0">def </span><span class="s1">_get_level_indexer(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">level: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">indexer: Int64Index | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s4"># `level` kwarg is _always_ positional, never name</span>
        <span class="s4"># return an indexer, boolean array or a slice showing where the key is</span>
        <span class="s4"># in the totality of values</span>
        <span class="s4"># if the indexer is provided, then use this</span>

        <span class="s1">level_index = self.levels[level]</span>
        <span class="s1">level_codes = self.codes[level]</span>

        <span class="s0">def </span><span class="s1">convert_indexer(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step</span><span class="s0">, </span><span class="s1">indexer=indexer</span><span class="s0">, </span><span class="s1">codes=level_codes):</span>
            <span class="s4"># given the inputs and the codes/indexer, compute an indexer set</span>
            <span class="s4"># if we have a provided indexer, then this need not consider</span>
            <span class="s4"># the entire labels set</span>
            <span class="s0">if </span><span class="s1">step </span><span class="s0">is not None and </span><span class="s1">step &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># Switch elements for negative step size</span>
                <span class="s1">start</span><span class="s0">, </span><span class="s1">stop = stop - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">start - </span><span class="s5">1</span>
            <span class="s1">r = np.arange(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>

            <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is not None and </span><span class="s1">len(indexer) != len(codes):</span>

                <span class="s4"># we have an indexer which maps the locations in the labels</span>
                <span class="s4"># that we have already selected (and is not an indexer for the</span>
                <span class="s4"># entire set) otherwise this is wasteful so we only need to</span>
                <span class="s4"># examine locations that are in this set the only magic here is</span>
                <span class="s4"># that the result are the mappings to the set that we have</span>
                <span class="s4"># selected</span>
                <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

                <span class="s1">mapper = Series(indexer)</span>
                <span class="s1">indexer = codes.take(ensure_platform_int(indexer))</span>
                <span class="s1">result = Series(Index(indexer).isin(r).nonzero()[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">m = result.map(mapper)</span>
                <span class="s4"># error: Incompatible types in assignment (expression has type</span>
                <span class="s4"># &quot;ndarray&quot;, variable has type &quot;Series&quot;)</span>
                <span class="s1">m = np.asarray(m)  </span><span class="s4"># type: ignore[assignment]</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># error: Incompatible types in assignment (expression has type</span>
                <span class="s4"># &quot;ndarray&quot;, variable has type &quot;Series&quot;)</span>
                <span class="s1">m = np.zeros(len(codes)</span><span class="s0">, </span><span class="s1">dtype=bool)  </span><span class="s4"># type: ignore[assignment]</span>
                <span class="s1">m[np.in1d(codes</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">assume_unique=Index(codes).is_unique)] = </span><span class="s0">True</span>

            <span class="s0">return </span><span class="s1">m</span>

        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s4"># handle a slice, returning a slice if we can</span>
            <span class="s4"># otherwise a boolean indexer</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">key.start </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">start = level_index.get_loc(key.start)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">start = </span><span class="s5">0</span>
                <span class="s0">if </span><span class="s1">key.stop </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">stop = level_index.get_loc(key.stop)</span>
                <span class="s0">elif </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">slice):</span>
                    <span class="s1">stop = len(level_index)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">stop = len(level_index) - </span><span class="s5">1</span>
                <span class="s1">step = key.step</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>

                <span class="s4"># we have a partial slice (like looking up a partial date</span>
                <span class="s4"># string)</span>
                <span class="s1">start = stop = level_index.slice_indexer(key.start</span><span class="s0">, </span><span class="s1">key.stop</span><span class="s0">, </span><span class="s1">key.step)</span>
                <span class="s1">step = start.step</span>

            <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">slice) </span><span class="s0">or </span><span class="s1">isinstance(stop</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s4"># we have a slice for start and/or stop</span>
                <span class="s4"># a partial date slicer on a DatetimeIndex generates a slice</span>
                <span class="s4"># note that the stop ALREADY includes the stopped point (if</span>
                <span class="s4"># it was a string sliced)</span>
                <span class="s1">start = getattr(start</span><span class="s0">, </span><span class="s2">&quot;start&quot;</span><span class="s0">, </span><span class="s1">start)</span>
                <span class="s1">stop = getattr(stop</span><span class="s0">, </span><span class="s2">&quot;stop&quot;</span><span class="s0">, </span><span class="s1">stop)</span>
                <span class="s0">return </span><span class="s1">convert_indexer(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>

            <span class="s0">elif </span><span class="s1">level &gt; </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">self._lexsort_depth == </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">step </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># need to have like semantics here to right</span>
                <span class="s4"># searching as when we are using a slice</span>
                <span class="s4"># so include the stop+1 (so we include stop)</span>
                <span class="s0">return </span><span class="s1">convert_indexer(start</span><span class="s0">, </span><span class="s1">stop + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">step)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># sorted, so can return slice object -&gt; view</span>
                <span class="s1">i = level_codes.searchsorted(start</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s1">)</span>
                <span class="s1">j = level_codes.searchsorted(stop</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;right&quot;</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">slice(i</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">step)</span>

        <span class="s0">else</span><span class="s1">:</span>

            <span class="s1">idx = self._get_loc_single_level_index(level_index</span><span class="s0">, </span><span class="s1">key)</span>

            <span class="s0">if </span><span class="s1">level &gt; </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">self._lexsort_depth == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># Desired level is not sorted</span>
                <span class="s0">if </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">slice):</span>
                    <span class="s4"># test_get_loc_partial_timestamp_multiindex</span>
                    <span class="s1">locs = (level_codes &gt;= idx.start) &amp; (level_codes &lt; idx.stop)</span>
                    <span class="s0">return </span><span class="s1">locs</span>

                <span class="s1">locs = np.array(level_codes == idx</span><span class="s0">, </span><span class="s1">dtype=bool</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

                <span class="s0">if not </span><span class="s1">locs.any():</span>
                    <span class="s4"># The label is present in self.levels[level] but unused:</span>
                    <span class="s0">raise </span><span class="s1">KeyError(key)</span>
                <span class="s0">return </span><span class="s1">locs</span>

            <span class="s0">if </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s4"># e.g. test_partial_string_timestamp_multiindex</span>
                <span class="s1">start = level_codes.searchsorted(idx.start</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s1">)</span>
                <span class="s4"># NB: &quot;left&quot; here bc of slice semantics</span>
                <span class="s1">end = level_codes.searchsorted(idx.stop</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">start = level_codes.searchsorted(idx</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s1">)</span>
                <span class="s1">end = level_codes.searchsorted(idx</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;right&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">start == end:</span>
                <span class="s4"># The label is present in self.levels[level] but unused:</span>
                <span class="s0">raise </span><span class="s1">KeyError(key)</span>
            <span class="s0">return </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">end)</span>

    <span class="s0">def </span><span class="s1">get_locs(self</span><span class="s0">, </span><span class="s1">seq):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get location for a sequence of labels. 
 
        Parameters 
        ---------- 
        seq : label, slice, list, mask or a sequence of such 
           You should use one of the above for each level. 
           If a level should not be used, set it to ``slice(None)``. 
 
        Returns 
        ------- 
        numpy.ndarray 
            NumPy array of integers suitable for passing to iloc. 
 
        See Also 
        -------- 
        MultiIndex.get_loc : Get location for a label or a tuple of labels. 
        MultiIndex.slice_locs : Get slice location given start label(s) and 
                                end label(s). 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays([list('abb'), list('def')]) 
 
        &gt;&gt;&gt; mi.get_locs('b')  # doctest: +SKIP 
        array([1, 2], dtype=int64) 
 
        &gt;&gt;&gt; mi.get_locs([slice(None), ['e', 'f']])  # doctest: +SKIP 
        array([1, 2], dtype=int64) 
 
        &gt;&gt;&gt; mi.get_locs([[True, False, True], slice('e', 'f')])  # doctest: +SKIP 
        array([2], dtype=int64) 
        &quot;&quot;&quot;</span>

        <span class="s4"># must be lexsorted to at least as many levels</span>
        <span class="s1">true_slices = [i </span><span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">in </span><span class="s1">enumerate(com.is_true_slices(seq)) </span><span class="s0">if </span><span class="s1">s]</span>
        <span class="s0">if </span><span class="s1">true_slices </span><span class="s0">and </span><span class="s1">true_slices[-</span><span class="s5">1</span><span class="s1">] &gt;= self._lexsort_depth:</span>
            <span class="s0">raise </span><span class="s1">UnsortedIndexError(</span>
                <span class="s2">&quot;MultiIndex slicing requires the index to be lexsorted: slicing &quot;</span>
                <span class="s2">f&quot;on levels </span><span class="s0">{</span><span class="s1">true_slices</span><span class="s0">}</span><span class="s2">, lexsort depth </span><span class="s0">{</span><span class="s1">self._lexsort_depth</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">n = len(self)</span>
        <span class="s4"># indexer is the list of all positions that we want to take; we</span>
        <span class="s4">#  start with it being everything and narrow it down as we look at each</span>
        <span class="s4">#  entry in `seq`</span>
        <span class="s1">indexer = Index(np.arange(n))</span>

        <span class="s0">if </span><span class="s1">any(x </span><span class="s0">is </span><span class="s1">Ellipsis </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">seq):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s2">&quot;MultiIndex does not support indexing with Ellipsis&quot;</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">_convert_to_indexer(r) -&gt; Int64Index:</span>
            <span class="s4"># return an indexer</span>
            <span class="s0">if </span><span class="s1">isinstance(r</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">m = np.zeros(n</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
                <span class="s1">m[r] = </span><span class="s0">True</span>
                <span class="s1">r = m.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">elif </span><span class="s1">com.is_bool_indexer(r):</span>
                <span class="s0">if </span><span class="s1">len(r) != n:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;cannot index with a boolean indexer &quot;</span>
                        <span class="s2">&quot;that is not the same length as the &quot;</span>
                        <span class="s2">&quot;index&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">r = r.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">Int64Index(r)</span>

        <span class="s0">def </span><span class="s1">_update_indexer(idxr: Index</span><span class="s0">, </span><span class="s1">indexer: Index) -&gt; Index:</span>
            <span class="s1">indexer_intersection = indexer.intersection(idxr)</span>
            <span class="s0">if </span><span class="s1">indexer_intersection.empty </span><span class="s0">and not </span><span class="s1">idxr.empty </span><span class="s0">and not </span><span class="s1">indexer.empty:</span>
                <span class="s0">raise </span><span class="s1">KeyError(seq)</span>
            <span class="s0">return </span><span class="s1">indexer_intersection</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">enumerate(seq):</span>

            <span class="s0">if </span><span class="s1">com.is_bool_indexer(k):</span>
                <span class="s4"># a boolean indexer, must be the same length!</span>
                <span class="s1">k = np.asarray(k)</span>
                <span class="s1">lvl_indexer = _convert_to_indexer(k)</span>
                <span class="s1">indexer = _update_indexer(lvl_indexer</span><span class="s0">, </span><span class="s1">indexer=indexer)</span>

            <span class="s0">elif </span><span class="s1">is_list_like(k):</span>
                <span class="s4"># a collection of labels to include from this level (these</span>
                <span class="s4"># are or'd)</span>

                <span class="s1">indexers: Int64Index | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

                <span class="s4"># GH#27591 check if this is a single tuple key in the level</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s4"># Argument &quot;indexer&quot; to &quot;_get_level_indexer&quot; of &quot;MultiIndex&quot;</span>
                    <span class="s4"># has incompatible type &quot;Index&quot;; expected &quot;Optional[Int64Index]&quot;</span>
                    <span class="s1">lev_loc = self._get_level_indexer(</span>
                        <span class="s1">k</span><span class="s0">, </span><span class="s1">level=i</span><span class="s0">, </span><span class="s1">indexer=indexer  </span><span class="s4"># type: ignore[arg-type]</span>
                    <span class="s1">)</span>
                <span class="s0">except </span><span class="s1">(InvalidIndexError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">KeyError) </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s4"># InvalidIndexError e.g. non-hashable, fall back to treating</span>
                    <span class="s4">#  this as a sequence of labels</span>
                    <span class="s4"># KeyError it can be ambiguous if this is a label or sequence</span>
                    <span class="s4">#  of labels</span>
                    <span class="s4">#  github.com/pandas-dev/pandas/issues/39424#issuecomment-871626708</span>
                    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">k:</span>
                        <span class="s0">if not </span><span class="s1">is_hashable(x):</span>
                            <span class="s4"># e.g. slice</span>
                            <span class="s0">raise </span><span class="s1">err</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s4"># Argument &quot;indexer&quot; to &quot;_get_level_indexer&quot; of &quot;MultiIndex&quot;</span>
                            <span class="s4"># has incompatible type &quot;Index&quot;; expected</span>
                            <span class="s4"># &quot;Optional[Int64Index]&quot;</span>
                            <span class="s1">item_lvl_indexer = self._get_level_indexer(</span>
                                <span class="s1">x</span><span class="s0">, </span><span class="s1">level=i</span><span class="s0">, </span><span class="s1">indexer=indexer  </span><span class="s4"># type: ignore[arg-type]</span>
                            <span class="s1">)</span>
                        <span class="s0">except </span><span class="s1">KeyError:</span>
                            <span class="s4"># ignore not founds; see discussion in GH#39424</span>
                            <span class="s1">warnings.warn(</span>
                                <span class="s2">&quot;The behavior of indexing on a MultiIndex with a &quot;</span>
                                <span class="s2">&quot;nested sequence of labels is deprecated and will &quot;</span>
                                <span class="s2">&quot;change in a future version. &quot;</span>
                                <span class="s2">&quot;`series.loc[label, sequence]` will raise if any &quot;</span>
                                <span class="s2">&quot;members of 'sequence' or not present in &quot;</span>
                                <span class="s2">&quot;the index's second level. To retain the old &quot;</span>
                                <span class="s2">&quot;behavior, use `series.index.isin(sequence, level=1)`&quot;</span><span class="s0">,</span>
                                <span class="s4"># TODO: how to opt in to the future behavior?</span>
                                <span class="s4"># TODO: how to handle IntervalIndex level?</span>
                                <span class="s4">#  (no test cases)</span>
                                <span class="s1">FutureWarning</span><span class="s0">,</span>
                                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                            <span class="s1">)</span>
                            <span class="s0">continue</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">idxrs = _convert_to_indexer(item_lvl_indexer)</span>

                            <span class="s0">if </span><span class="s1">indexers </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s1">indexers = idxrs</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">indexers = indexers.union(idxrs</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>

                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">idxrs = _convert_to_indexer(lev_loc)</span>
                    <span class="s0">if </span><span class="s1">indexers </span><span class="s0">is None</span><span class="s1">:</span>
                        <span class="s1">indexers = idxrs</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">indexers = indexers.union(idxrs</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>

                <span class="s0">if </span><span class="s1">indexers </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">indexer = _update_indexer(indexers</span><span class="s0">, </span><span class="s1">indexer=indexer)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s4"># no matches we are done</span>
                    <span class="s4"># test_loc_getitem_duplicates_multiindex_empty_indexer</span>
                    <span class="s0">return </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

            <span class="s0">elif </span><span class="s1">com.is_null_slice(k):</span>
                <span class="s4"># empty slice</span>
                <span class="s0">pass</span>

            <span class="s0">elif </span><span class="s1">isinstance(k</span><span class="s0">, </span><span class="s1">slice):</span>

                <span class="s4"># a slice, include BOTH of the labels</span>
                <span class="s4"># Argument &quot;indexer&quot; to &quot;_get_level_indexer&quot; of &quot;MultiIndex&quot; has</span>
                <span class="s4"># incompatible type &quot;Index&quot;; expected &quot;Optional[Int64Index]&quot;</span>
                <span class="s1">lvl_indexer = self._get_level_indexer(</span>
                    <span class="s1">k</span><span class="s0">,</span>
                    <span class="s1">level=i</span><span class="s0">,</span>
                    <span class="s1">indexer=indexer</span><span class="s0">,  </span><span class="s4"># type: ignore[arg-type]</span>
                <span class="s1">)</span>
                <span class="s1">indexer = _update_indexer(</span>
                    <span class="s1">_convert_to_indexer(lvl_indexer)</span><span class="s0">,</span>
                    <span class="s1">indexer=indexer</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># a single label</span>
                <span class="s1">lvl_indexer = self._get_loc_level(k</span><span class="s0">, </span><span class="s1">level=i)[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">indexer = _update_indexer(</span>
                    <span class="s1">_convert_to_indexer(lvl_indexer)</span><span class="s0">,</span>
                    <span class="s1">indexer=indexer</span><span class="s0">,</span>
                <span class="s1">)</span>

        <span class="s4"># empty indexer</span>
        <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s0">assert </span><span class="s1">isinstance(indexer</span><span class="s0">, </span><span class="s1">Int64Index)</span><span class="s0">, </span><span class="s1">type(indexer)</span>
        <span class="s1">indexer = self._reorder_indexer(seq</span><span class="s0">, </span><span class="s1">indexer)</span>

        <span class="s0">return </span><span class="s1">indexer._values.astype(np.intp</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">_reorder_indexer(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">seq: tuple[Scalar | Iterable | AnyArrayLike</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">,</span>
        <span class="s1">indexer: Int64Index</span><span class="s0">,</span>
    <span class="s1">) -&gt; Int64Index:</span>
        <span class="s3">&quot;&quot;&quot; 
        Reorder an indexer of a MultiIndex (self) so that the label are in the 
        same order as given in seq 
 
        Parameters 
        ---------- 
        seq : label/slice/list/mask or a sequence of such 
        indexer: an Int64Index indexer of self 
 
        Returns 
        ------- 
        indexer : a sorted Int64Index indexer of self ordered as seq 
        &quot;&quot;&quot;</span>
        <span class="s4"># If the index is lexsorted and the list_like label in seq are sorted</span>
        <span class="s4"># then we do not need to sort</span>
        <span class="s0">if </span><span class="s1">self._is_lexsorted():</span>
            <span class="s1">need_sort = </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">enumerate(seq):</span>
                <span class="s0">if </span><span class="s1">is_list_like(k):</span>
                    <span class="s0">if not </span><span class="s1">need_sort:</span>
                        <span class="s1">k_codes = self.levels[i].get_indexer(k)</span>
                        <span class="s1">k_codes = k_codes[k_codes &gt;= </span><span class="s5">0</span><span class="s1">]  </span><span class="s4"># Filter absent keys</span>
                        <span class="s4"># True if the given codes are not ordered</span>
                        <span class="s1">need_sort = (k_codes[:-</span><span class="s5">1</span><span class="s1">] &gt; k_codes[</span><span class="s5">1</span><span class="s1">:]).any()</span>
                <span class="s0">elif </span><span class="s1">isinstance(k</span><span class="s0">, </span><span class="s1">slice) </span><span class="s0">and </span><span class="s1">k.step </span><span class="s0">is not None and </span><span class="s1">k.step &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">need_sort = </span><span class="s0">True</span>
            <span class="s4"># Bail out if both index and seq are sorted</span>
            <span class="s0">if not </span><span class="s1">need_sort:</span>
                <span class="s0">return </span><span class="s1">indexer</span>

        <span class="s1">n = len(self)</span>
        <span class="s1">keys: tuple[np.ndarray</span><span class="s0">, </span><span class="s1">...] = ()</span>
        <span class="s4"># For each level of the sequence in seq, map the level codes with the</span>
        <span class="s4"># order they appears in a list-like sequence</span>
        <span class="s4"># This mapping is then use to reorder the indexer</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">enumerate(seq):</span>
            <span class="s0">if </span><span class="s1">is_scalar(k):</span>
                <span class="s4"># GH#34603 we want to treat a scalar the same as an all equal list</span>
                <span class="s1">k = [k]</span>
            <span class="s0">if </span><span class="s1">com.is_bool_indexer(k):</span>
                <span class="s1">new_order = np.arange(n)[indexer]</span>
            <span class="s0">elif </span><span class="s1">is_list_like(k):</span>
                <span class="s4"># Generate a map with all level codes as sorted initially</span>
                <span class="s1">k = algos.unique(k)</span>
                <span class="s1">key_order_map = np.ones(len(self.levels[i])</span><span class="s0">, </span><span class="s1">dtype=np.uint64) * len(</span>
                    <span class="s1">self.levels[i]</span>
                <span class="s1">)</span>
                <span class="s4"># Set order as given in the indexer list</span>
                <span class="s1">level_indexer = self.levels[i].get_indexer(k)</span>
                <span class="s1">level_indexer = level_indexer[level_indexer &gt;= </span><span class="s5">0</span><span class="s1">]  </span><span class="s4"># Filter absent keys</span>
                <span class="s1">key_order_map[level_indexer] = np.arange(len(level_indexer))</span>

                <span class="s1">new_order = key_order_map[self.codes[i][indexer]]</span>
            <span class="s0">elif </span><span class="s1">isinstance(k</span><span class="s0">, </span><span class="s1">slice) </span><span class="s0">and </span><span class="s1">k.step </span><span class="s0">is not None and </span><span class="s1">k.step &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">new_order = np.arange(n)[k][indexer]</span>
            <span class="s0">elif </span><span class="s1">isinstance(k</span><span class="s0">, </span><span class="s1">slice) </span><span class="s0">and </span><span class="s1">k.start </span><span class="s0">is None and </span><span class="s1">k.stop </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s4"># slice(None) should not determine order GH#31330</span>
                <span class="s1">new_order = np.ones((n</span><span class="s0">,</span><span class="s1">))[indexer]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># For all other case, use the same order as the level</span>
                <span class="s1">new_order = np.arange(n)[indexer]</span>
            <span class="s1">keys = (new_order</span><span class="s0">,</span><span class="s1">) + keys</span>

        <span class="s4"># Find the reordering using lexsort on the keys mapping</span>
        <span class="s1">ind = np.lexsort(keys)</span>
        <span class="s0">return </span><span class="s1">indexer[ind]</span>

    <span class="s0">def </span><span class="s1">truncate(self</span><span class="s0">, </span><span class="s1">before=</span><span class="s0">None, </span><span class="s1">after=</span><span class="s0">None</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Slice index between two labels / tuples, return new MultiIndex 
 
        Parameters 
        ---------- 
        before : label or tuple, can be partial. Default None 
            None defaults to start 
        after : label or tuple, can be partial. Default None 
            None defaults to end 
 
        Returns 
        ------- 
        truncated : MultiIndex 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">after </span><span class="s0">and </span><span class="s1">before </span><span class="s0">and </span><span class="s1">after &lt; before:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;after &lt; before&quot;</span><span class="s1">)</span>

        <span class="s1">i</span><span class="s0">, </span><span class="s1">j = self.levels[</span><span class="s5">0</span><span class="s1">].slice_locs(before</span><span class="s0">, </span><span class="s1">after)</span>
        <span class="s1">left</span><span class="s0">, </span><span class="s1">right = self.slice_locs(before</span><span class="s0">, </span><span class="s1">after)</span>

        <span class="s1">new_levels = list(self.levels)</span>
        <span class="s1">new_levels[</span><span class="s5">0</span><span class="s1">] = new_levels[</span><span class="s5">0</span><span class="s1">][i:j]</span>

        <span class="s1">new_codes = [level_codes[left:right] </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>
        <span class="s1">new_codes[</span><span class="s5">0</span><span class="s1">] = new_codes[</span><span class="s5">0</span><span class="s1">] - i</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">,</span>
            <span class="s1">codes=new_codes</span><span class="s0">,</span>
            <span class="s1">names=self._names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">equals(self</span><span class="s0">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Determines if two MultiIndex objects have the same labeling information 
        (the levels themselves do not necessarily have to be the same) 
 
        See Also 
        -------- 
        equal_levels 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_(other):</span>
            <span class="s0">return True</span>

        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s0">return False</span>

        <span class="s0">if </span><span class="s1">len(self) != len(other):</span>
            <span class="s0">return False</span>

        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s4"># d-level MultiIndex can equal d-tuple Index</span>
            <span class="s0">if not </span><span class="s1">self._should_compare(other):</span>
                <span class="s4"># object Index or Categorical[object] may contain tuples</span>
                <span class="s0">return False</span>
            <span class="s0">return </span><span class="s1">array_equivalent(self._values</span><span class="s0">, </span><span class="s1">other._values)</span>

        <span class="s0">if </span><span class="s1">self.nlevels != other.nlevels:</span>
            <span class="s0">return False</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.nlevels):</span>
            <span class="s1">self_codes = self.codes[i]</span>
            <span class="s1">other_codes = other.codes[i]</span>
            <span class="s1">self_mask = self_codes == -</span><span class="s5">1</span>
            <span class="s1">other_mask = other_codes == -</span><span class="s5">1</span>
            <span class="s0">if not </span><span class="s1">np.array_equal(self_mask</span><span class="s0">, </span><span class="s1">other_mask):</span>
                <span class="s0">return False</span>
            <span class="s1">self_codes = self_codes[~self_mask]</span>
            <span class="s1">self_values = self.levels[i]._values.take(self_codes)</span>

            <span class="s1">other_codes = other_codes[~other_mask]</span>
            <span class="s1">other_values = other.levels[i]._values.take(other_codes)</span>

            <span class="s4"># since we use NaT both datetime64 and timedelta64 we can have a</span>
            <span class="s4"># situation where a level is typed say timedelta64 in self (IOW it</span>
            <span class="s4"># has other values than NaT) but types datetime64 in other (where</span>
            <span class="s4"># its all NaT) but these are equivalent</span>
            <span class="s0">if </span><span class="s1">len(self_values) == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">len(other_values) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">continue</span>

            <span class="s0">if not </span><span class="s1">isinstance(self_values</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s4"># i.e. ExtensionArray</span>
                <span class="s0">if not </span><span class="s1">self_values.equals(other_values):</span>
                    <span class="s0">return False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">array_equivalent(self_values</span><span class="s0">, </span><span class="s1">other_values):</span>
                    <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">equal_levels(self</span><span class="s0">, </span><span class="s1">other: MultiIndex) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return True if the levels of both MultiIndex objects are the same 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.nlevels != other.nlevels:</span>
            <span class="s0">return False</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.nlevels):</span>
            <span class="s0">if not </span><span class="s1">self.levels[i].equals(other.levels[i]):</span>
                <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Set Methods</span>

    <span class="s0">def </span><span class="s1">_union(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">sort) -&gt; MultiIndex:</span>
        <span class="s1">other</span><span class="s0">, </span><span class="s1">result_names = self._convert_can_do_setop(other)</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">any(-</span><span class="s5">1 </span><span class="s0">in </span><span class="s1">code </span><span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">self.codes)</span>
            <span class="s0">and </span><span class="s1">any(-</span><span class="s5">1 </span><span class="s0">in </span><span class="s1">code </span><span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">other.codes)</span>
            <span class="s0">or </span><span class="s1">self.has_duplicates</span>
            <span class="s0">or </span><span class="s1">other.has_duplicates</span>
        <span class="s1">):</span>
            <span class="s4"># This is only necessary if both sides have nans or one has dups,</span>
            <span class="s4"># fast_unique_multiple is faster</span>
            <span class="s1">result = super()._union(other</span><span class="s0">, </span><span class="s1">sort)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">rvals = other._values.astype(object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">result = lib.fast_unique_multiple([self._values</span><span class="s0">, </span><span class="s1">rvals]</span><span class="s0">, </span><span class="s1">sort=sort)</span>

        <span class="s0">return </span><span class="s1">MultiIndex.from_arrays(zip(*result)</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s0">None, </span><span class="s1">names=result_names)</span>

    <span class="s0">def </span><span class="s1">_is_comparable_dtype(self</span><span class="s0">, </span><span class="s1">dtype: DtypeObj) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">is_object_dtype(dtype)</span>

    <span class="s0">def </span><span class="s1">_get_reconciled_name_object(self</span><span class="s0">, </span><span class="s1">other) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        If the result of a set operation will be self, 
        return self, unless the names change, in which 
        case make a shallow copy of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = self._maybe_match_names(other)</span>
        <span class="s0">if </span><span class="s1">self.names != names:</span>
            <span class="s4"># Incompatible return value type (got &quot;Optional[MultiIndex]&quot;, expected</span>
            <span class="s4"># &quot;MultiIndex&quot;)</span>
            <span class="s0">return </span><span class="s1">self.rename(names)  </span><span class="s4"># type: ignore[return-value]</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_maybe_match_names(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s3">&quot;&quot;&quot; 
        Try to find common names to attach to the result of an operation between 
        a and b. Return a consensus list of names if they match at least partly 
        or list of None if they have completely different names. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(self.names) != len(other.names):</span>
            <span class="s0">return </span><span class="s1">[</span><span class="s0">None</span><span class="s1">] * len(self.names)</span>
        <span class="s1">names = []</span>
        <span class="s0">for </span><span class="s1">a_name</span><span class="s0">, </span><span class="s1">b_name </span><span class="s0">in </span><span class="s1">zip(self.names</span><span class="s0">, </span><span class="s1">other.names):</span>
            <span class="s0">if </span><span class="s1">a_name == b_name:</span>
                <span class="s1">names.append(a_name)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># TODO: what if they both have np.nan for their names?</span>
                <span class="s1">names.append(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">names</span>

    <span class="s0">def </span><span class="s1">_wrap_intersection_result(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">result) -&gt; MultiIndex:</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">result_names = self._convert_can_do_setop(other)</span>

        <span class="s0">if </span><span class="s1">len(result) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">MultiIndex(</span>
                <span class="s1">levels=self.levels</span><span class="s0">,</span>
                <span class="s1">codes=[[]] * self.nlevels</span><span class="s0">,</span>
                <span class="s1">names=result_names</span><span class="s0">,</span>
                <span class="s1">verify_integrity=</span><span class="s0">False,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">MultiIndex.from_arrays(zip(*result)</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">names=result_names)</span>

    <span class="s0">def </span><span class="s1">_wrap_difference_result(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">result) -&gt; MultiIndex:</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">result_names = self._convert_can_do_setop(other)</span>

        <span class="s0">if </span><span class="s1">len(result) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">MultiIndex(</span>
                <span class="s1">levels=[[]] * self.nlevels</span><span class="s0">,</span>
                <span class="s1">codes=[[]] * self.nlevels</span><span class="s0">,</span>
                <span class="s1">names=result_names</span><span class="s0">,</span>
                <span class="s1">verify_integrity=</span><span class="s0">False,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">MultiIndex.from_tuples(result</span><span class="s0">, </span><span class="s1">sortorder=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">names=result_names)</span>

    <span class="s0">def </span><span class="s1">_convert_can_do_setop(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s1">result_names = self.names</span>

        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">Index):</span>

            <span class="s0">if </span><span class="s1">len(other) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self[:</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.names</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s2">&quot;other must be a MultiIndex or a list of tuples&quot;</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">other = MultiIndex.from_tuples(other</span><span class="s0">, </span><span class="s1">names=self.names)</span>
                <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s4"># ValueError raised by tuples_to_object_array if we</span>
                    <span class="s4">#  have non-object dtype</span>
                    <span class="s0">raise </span><span class="s1">TypeError(msg) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result_names = get_unanimous_names(self</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s0">return </span><span class="s1">other</span><span class="s0">, </span><span class="s1">result_names</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s1">@doc(Index.astype)</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">dtype = pandas_dtype(dtype)</span>
        <span class="s0">if </span><span class="s1">is_categorical_dtype(dtype):</span>
            <span class="s1">msg = </span><span class="s2">&quot;&gt; 1 ndim Categorical are not supported at this time&quot;</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(msg)</span>
        <span class="s0">elif not </span><span class="s1">is_object_dtype(dtype):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;Setting a MultiIndex dtype to anything other than object &quot;</span>
                <span class="s2">&quot;is not supported&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">copy </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._view()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_validate_fill_value(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">if </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s4"># GH#43212</span>
            <span class="s0">if </span><span class="s1">item.nlevels != self.nlevels:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Item must have length equal to number of levels.&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">item._values</span>
        <span class="s0">elif not </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s4"># Pad the key with empty strings if lower levels of the key</span>
            <span class="s4"># aren't specified:</span>
            <span class="s1">item = (item</span><span class="s0">,</span><span class="s1">) + (</span><span class="s2">&quot;&quot;</span><span class="s0">,</span><span class="s1">) * (self.nlevels - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">len(item) != self.nlevels:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Item must have length equal to number of levels.&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">item</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">item) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Make new MultiIndex inserting new item at location 
 
        Parameters 
        ---------- 
        loc : int 
        item : tuple 
            Must be same length as number of levels in the MultiIndex 
 
        Returns 
        ------- 
        new_index : Index 
        &quot;&quot;&quot;</span>
        <span class="s1">item = self._validate_fill_value(item)</span>

        <span class="s1">new_levels = []</span>
        <span class="s1">new_codes = []</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">zip(item</span><span class="s0">, </span><span class="s1">self.levels</span><span class="s0">, </span><span class="s1">self.codes):</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">level:</span>
                <span class="s4"># have to insert into level</span>
                <span class="s4"># must insert at end otherwise you have to recompute all the</span>
                <span class="s4"># other codes</span>
                <span class="s1">lev_loc = len(level)</span>
                <span class="s1">level = level.insert(lev_loc</span><span class="s0">, </span><span class="s1">k)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">lev_loc = level.get_loc(k)</span>

            <span class="s1">new_levels.append(level)</span>
            <span class="s1">new_codes.append(np.insert(ensure_int64(level_codes)</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">lev_loc))</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=self.names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">delete(self</span><span class="s0">, </span><span class="s1">loc) -&gt; MultiIndex:</span>
        <span class="s3">&quot;&quot;&quot; 
        Make new index with passed location deleted 
 
        Returns 
        ------- 
        new_index : MultiIndex 
        &quot;&quot;&quot;</span>
        <span class="s1">new_codes = [np.delete(level_codes</span><span class="s0">, </span><span class="s1">loc) </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">self.codes]</span>
        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=self.levels</span><span class="s0">,</span>
            <span class="s1">codes=new_codes</span><span class="s0">,</span>
            <span class="s1">names=self.names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(Index.isin)</span>
    <span class="s0">def </span><span class="s1">isin(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None</span><span class="s1">) -&gt; npt.NDArray[np.bool_]:</span>
        <span class="s0">if </span><span class="s1">level </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">values = MultiIndex.from_tuples(values</span><span class="s0">, </span><span class="s1">names=self.names)._values</span>
            <span class="s0">return </span><span class="s1">algos.isin(self._values</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">num = self._get_level_number(level)</span>
            <span class="s1">levs = self.get_level_values(num)</span>

            <span class="s0">if </span><span class="s1">levs.size == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">np.zeros(len(levs)</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
            <span class="s0">return </span><span class="s1">levs.isin(values)</span>

    <span class="s1">@deprecate_nonkeyword_arguments(version=</span><span class="s0">None, </span><span class="s1">allowed_args=[</span><span class="s2">&quot;self&quot;</span><span class="s0">, </span><span class="s2">&quot;names&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">set_names(self</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">level=</span><span class="s0">None, </span><span class="s1">inplace: bool = </span><span class="s0">False</span><span class="s1">) -&gt; MultiIndex | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">super().set_names(names=names</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">inplace=inplace)</span>

    <span class="s1">rename = set_names</span>

    <span class="s1">@deprecate_nonkeyword_arguments(version=</span><span class="s0">None, </span><span class="s1">allowed_args=[</span><span class="s2">&quot;self&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">drop_duplicates(self</span><span class="s0">, </span><span class="s1">keep: str | bool = </span><span class="s2">&quot;first&quot;</span><span class="s1">) -&gt; MultiIndex:</span>
        <span class="s0">return </span><span class="s1">super().drop_duplicates(keep=keep)</span>

    <span class="s4"># ---------------------------------------------------------------</span>
    <span class="s4"># Arithmetic/Numeric Methods - Disabled</span>

    <span class="s1">__add__ = make_invalid_op(</span><span class="s2">&quot;__add__&quot;</span><span class="s1">)</span>
    <span class="s1">__radd__ = make_invalid_op(</span><span class="s2">&quot;__radd__&quot;</span><span class="s1">)</span>
    <span class="s1">__iadd__ = make_invalid_op(</span><span class="s2">&quot;__iadd__&quot;</span><span class="s1">)</span>
    <span class="s1">__sub__ = make_invalid_op(</span><span class="s2">&quot;__sub__&quot;</span><span class="s1">)</span>
    <span class="s1">__rsub__ = make_invalid_op(</span><span class="s2">&quot;__rsub__&quot;</span><span class="s1">)</span>
    <span class="s1">__isub__ = make_invalid_op(</span><span class="s2">&quot;__isub__&quot;</span><span class="s1">)</span>
    <span class="s1">__pow__ = make_invalid_op(</span><span class="s2">&quot;__pow__&quot;</span><span class="s1">)</span>
    <span class="s1">__rpow__ = make_invalid_op(</span><span class="s2">&quot;__rpow__&quot;</span><span class="s1">)</span>
    <span class="s1">__mul__ = make_invalid_op(</span><span class="s2">&quot;__mul__&quot;</span><span class="s1">)</span>
    <span class="s1">__rmul__ = make_invalid_op(</span><span class="s2">&quot;__rmul__&quot;</span><span class="s1">)</span>
    <span class="s1">__floordiv__ = make_invalid_op(</span><span class="s2">&quot;__floordiv__&quot;</span><span class="s1">)</span>
    <span class="s1">__rfloordiv__ = make_invalid_op(</span><span class="s2">&quot;__rfloordiv__&quot;</span><span class="s1">)</span>
    <span class="s1">__truediv__ = make_invalid_op(</span><span class="s2">&quot;__truediv__&quot;</span><span class="s1">)</span>
    <span class="s1">__rtruediv__ = make_invalid_op(</span><span class="s2">&quot;__rtruediv__&quot;</span><span class="s1">)</span>
    <span class="s1">__mod__ = make_invalid_op(</span><span class="s2">&quot;__mod__&quot;</span><span class="s1">)</span>
    <span class="s1">__rmod__ = make_invalid_op(</span><span class="s2">&quot;__rmod__&quot;</span><span class="s1">)</span>
    <span class="s1">__divmod__ = make_invalid_op(</span><span class="s2">&quot;__divmod__&quot;</span><span class="s1">)</span>
    <span class="s1">__rdivmod__ = make_invalid_op(</span><span class="s2">&quot;__rdivmod__&quot;</span><span class="s1">)</span>
    <span class="s4"># Unary methods disabled</span>
    <span class="s1">__neg__ = make_invalid_op(</span><span class="s2">&quot;__neg__&quot;</span><span class="s1">)</span>
    <span class="s1">__pos__ = make_invalid_op(</span><span class="s2">&quot;__pos__&quot;</span><span class="s1">)</span>
    <span class="s1">__abs__ = make_invalid_op(</span><span class="s2">&quot;__abs__&quot;</span><span class="s1">)</span>
    <span class="s1">__invert__ = make_invalid_op(</span><span class="s2">&quot;__invert__&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_lexsort_depth(codes: list[np.ndarray]</span><span class="s0">, </span><span class="s1">nlevels: int) -&gt; int:</span>
    <span class="s3">&quot;&quot;&quot;Count depth (up to a maximum of `nlevels`) with which codes are lexsorted.&quot;&quot;&quot;</span>
    <span class="s1">int64_codes = [ensure_int64(level_codes) </span><span class="s0">for </span><span class="s1">level_codes </span><span class="s0">in </span><span class="s1">codes]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(nlevels</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">libalgos.is_lexsorted(int64_codes[:k]):</span>
            <span class="s0">return </span><span class="s1">k</span>
    <span class="s0">return </span><span class="s5">0</span>


<span class="s0">def </span><span class="s1">sparsify_labels(label_list</span><span class="s0">, </span><span class="s1">start: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">sentinel=</span><span class="s2">&quot;&quot;</span><span class="s1">):</span>
    <span class="s1">pivoted = list(zip(*label_list))</span>
    <span class="s1">k = len(label_list)</span>

    <span class="s1">result = pivoted[: start + </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">prev = pivoted[start]</span>

    <span class="s0">for </span><span class="s1">cur </span><span class="s0">in </span><span class="s1">pivoted[start + </span><span class="s5">1 </span><span class="s1">:]:</span>
        <span class="s1">sparse_cur = []</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(p</span><span class="s0">, </span><span class="s1">t) </span><span class="s0">in </span><span class="s1">enumerate(zip(prev</span><span class="s0">, </span><span class="s1">cur)):</span>
            <span class="s0">if </span><span class="s1">i == k - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">sparse_cur.append(t)</span>
                <span class="s1">result.append(sparse_cur)</span>
                <span class="s0">break</span>

            <span class="s0">if </span><span class="s1">p == t:</span>
                <span class="s1">sparse_cur.append(sentinel)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">sparse_cur.extend(cur[i:])</span>
                <span class="s1">result.append(sparse_cur)</span>
                <span class="s0">break</span>

        <span class="s1">prev = cur</span>

    <span class="s0">return </span><span class="s1">list(zip(*result))</span>


<span class="s0">def </span><span class="s1">_get_na_rep(dtype) -&gt; str:</span>
    <span class="s0">return </span><span class="s1">{np.datetime64: </span><span class="s2">&quot;NaT&quot;</span><span class="s0">, </span><span class="s1">np.timedelta64: </span><span class="s2">&quot;NaT&quot;</span><span class="s1">}.get(dtype</span><span class="s0">, </span><span class="s2">&quot;NaN&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">maybe_droplevels(index: Index</span><span class="s0">, </span><span class="s1">key) -&gt; Index:</span>
    <span class="s3">&quot;&quot;&quot; 
    Attempt to drop level or levels from the given index. 
 
    Parameters 
    ---------- 
    index: Index 
    key : scalar or tuple 
 
    Returns 
    ------- 
    Index 
    &quot;&quot;&quot;</span>
    <span class="s4"># drop levels</span>
    <span class="s1">original_index = index</span>
    <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">key:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">index = index._drop_level_numbers([</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s4"># we have dropped too much, so back out</span>
                <span class="s0">return </span><span class="s1">original_index</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">index = index._drop_level_numbers([</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">pass</span>

    <span class="s0">return </span><span class="s1">index</span>


<span class="s0">def </span><span class="s1">_coerce_indexer_frozen(array_like</span><span class="s0">, </span><span class="s1">categories</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">) -&gt; np.ndarray:</span>
    <span class="s3">&quot;&quot;&quot; 
    Coerce the array-like indexer to the smallest integer dtype that can encode all 
    of the given categories. 
 
    Parameters 
    ---------- 
    array_like : array-like 
    categories : array-like 
    copy : bool 
 
    Returns 
    ------- 
    np.ndarray 
        Non-writeable. 
    &quot;&quot;&quot;</span>
    <span class="s1">array_like = coerce_indexer_dtype(array_like</span><span class="s0">, </span><span class="s1">categories)</span>
    <span class="s0">if </span><span class="s1">copy:</span>
        <span class="s1">array_like = array_like.copy()</span>
    <span class="s1">array_like.flags.writeable = </span><span class="s0">False</span>
    <span class="s0">return </span><span class="s1">array_like</span>


<span class="s0">def </span><span class="s1">_require_listlike(level</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">arrname: str):</span>
    <span class="s3">&quot;&quot;&quot; 
    Ensure that level is either None or listlike, and arr is list-of-listlike. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">level </span><span class="s0">is not None and not </span><span class="s1">is_list_like(level):</span>
        <span class="s0">if not </span><span class="s1">is_list_like(arr):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">arrname</span><span class="s0">} </span><span class="s2">must be list-like&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_list_like(arr[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">arrname</span><span class="s0">} </span><span class="s2">must be list-like&quot;</span><span class="s1">)</span>
        <span class="s1">level = [level]</span>
        <span class="s1">arr = [arr]</span>
    <span class="s0">elif </span><span class="s1">level </span><span class="s0">is None or </span><span class="s1">is_list_like(level):</span>
        <span class="s0">if not </span><span class="s1">is_list_like(arr) </span><span class="s0">or not </span><span class="s1">is_list_like(arr[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">arrname</span><span class="s0">} </span><span class="s2">must be list of lists-like&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">level</span><span class="s0">, </span><span class="s1">arr</span>
</pre>
</body>
</html>