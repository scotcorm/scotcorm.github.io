<html>
<head>
<title>basedatatypes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
basedatatypes.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">OrderedDict</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">six</span>
<span class="s0">from </span><span class="s1">six </span><span class="s0">import </span><span class="s1">string_types</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span><span class="s0">, </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>

<span class="s0">from </span><span class="s1">_plotly_utils.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_natural_sort_strings</span><span class="s0">,</span>
    <span class="s1">_get_int_type</span><span class="s0">,</span>
    <span class="s1">split_multichar</span><span class="s0">,</span>
    <span class="s1">split_string_positions</span><span class="s0">,</span>
    <span class="s1">display_string_positions</span><span class="s0">,</span>
    <span class="s1">chomp_empty_strings</span><span class="s0">,</span>
    <span class="s1">find_closest_string</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">_plotly_utils.exceptions </span><span class="s0">import </span><span class="s1">PlotlyKeyError</span>
<span class="s0">from </span><span class="s1">.optional_imports </span><span class="s0">import </span><span class="s1">get_module</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">shapeannotation</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">subplots</span>

<span class="s2"># Create Undefined sentinel value</span>
<span class="s2">#   - Setting a property to None removes any existing value</span>
<span class="s2">#   - Setting a property to Undefined leaves existing value unmodified</span>
<span class="s1">Undefined = object()</span>


<span class="s0">def </span><span class="s1">_len_dict_item(item):</span>
    <span class="s3">&quot;&quot;&quot; 
    Because a parsed dict path is a tuple containings strings or integers, to 
    know the length of the resulting string when printing we might need to 
    convert to a string before calling len on it. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">l = len(item)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">l = len(</span><span class="s4">&quot;%d&quot; </span><span class="s1">% (item</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Cannot find string length of an item that is not string-like nor an integer.&quot;</span>
            <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">l</span>


<span class="s0">def </span><span class="s1">_str_to_dict_path_full(key_path_str):</span>
    <span class="s3">&quot;&quot;&quot; 
    Convert a key path string into a tuple of key path elements and also 
    return a tuple of indices marking the beginning of each element in the 
    string. 
 
    Parameters 
    ---------- 
    key_path_str : str 
        Key path string, where nested keys are joined on '.' characters 
        and array indexes are specified using brackets 
        (e.g. 'foo.bar[1]') 
    Returns 
    ------- 
    tuple[str | int] 
    tuple [int] 
    &quot;&quot;&quot;</span>
    <span class="s2"># skip all the parsing if the string is empty</span>
    <span class="s0">if </span><span class="s1">len(key_path_str):</span>
        <span class="s2"># split string on &quot;.[]&quot; and filter out empty strings</span>
        <span class="s1">key_path2 = split_multichar([key_path_str]</span><span class="s0">, </span><span class="s1">list(</span><span class="s4">&quot;.[]&quot;</span><span class="s1">))</span>
        <span class="s2"># Split out underscore</span>
        <span class="s2"># e.g. ['foo', 'bar_baz', '1'] -&gt; ['foo', 'bar', 'baz', '1']</span>
        <span class="s1">key_path3 = []</span>
        <span class="s1">underscore_props = BaseFigure._valid_underscore_properties</span>

        <span class="s0">def </span><span class="s1">_make_hyphen_key(key):</span>
            <span class="s0">if </span><span class="s4">&quot;_&quot; </span><span class="s0">in </span><span class="s1">key[</span><span class="s5">1</span><span class="s1">:]:</span>
                <span class="s2"># For valid properties that contain underscores (error_x)</span>
                <span class="s2"># replace the underscores with hyphens to protect them</span>
                <span class="s2"># from being split up</span>
                <span class="s0">for </span><span class="s1">under_prop</span><span class="s0">, </span><span class="s1">hyphen_prop </span><span class="s0">in </span><span class="s1">underscore_props.items():</span>
                    <span class="s1">key = key.replace(under_prop</span><span class="s0">, </span><span class="s1">hyphen_prop)</span>
            <span class="s0">return </span><span class="s1">key</span>

        <span class="s0">def </span><span class="s1">_make_underscore_key(key):</span>
            <span class="s0">return </span><span class="s1">key.replace(</span><span class="s4">&quot;-&quot;</span><span class="s0">, </span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>

        <span class="s1">key_path2b = list(map(_make_hyphen_key</span><span class="s0">, </span><span class="s1">key_path2))</span>
        <span class="s2"># Here we want to split up each non-empty string in the list at</span>
        <span class="s2"># underscores and recombine the strings using chomp_empty_strings so</span>
        <span class="s2"># that leading, trailing and multiple _ will be preserved</span>
        <span class="s0">def </span><span class="s1">_split_and_chomp(s):</span>
            <span class="s0">if not </span><span class="s1">len(s):</span>
                <span class="s0">return </span><span class="s1">s</span>
            <span class="s1">s_split = split_multichar([s]</span><span class="s0">, </span><span class="s1">list(</span><span class="s4">&quot;_&quot;</span><span class="s1">))</span>
            <span class="s2"># handle key paths like &quot;a_path_&quot;, &quot;_another_path&quot;, or</span>
            <span class="s2"># &quot;yet__another_path&quot; by joining extra &quot;_&quot; to the string to the right or</span>
            <span class="s2"># the empty string if at the end</span>
            <span class="s1">s_chomped = chomp_empty_strings(s_split</span><span class="s0">, </span><span class="s4">&quot;_&quot;</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">s_chomped</span>

        <span class="s2"># after running _split_and_chomp on key_path2b, it will be a list</span>
        <span class="s2"># containing strings and lists of strings; concatenate the sublists with</span>
        <span class="s2"># the list (&quot;lift&quot; the items out of the sublists)</span>
        <span class="s1">key_path2c = list(</span>
            <span class="s1">reduce(</span>
                <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x + y </span><span class="s0">if </span><span class="s1">type(y) == type(list()) </span><span class="s0">else </span><span class="s1">x + [y]</span><span class="s0">,</span>
                <span class="s1">map(_split_and_chomp</span><span class="s0">, </span><span class="s1">key_path2b)</span><span class="s0">,</span>
                <span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">key_path2d = list(map(_make_underscore_key</span><span class="s0">, </span><span class="s1">key_path2c))</span>
        <span class="s1">all_elem_idcs = tuple(split_string_positions(list(key_path2d)))</span>
        <span class="s2"># remove empty strings, and indices pointing to them</span>
        <span class="s1">key_elem_pairs = list(filter(</span><span class="s0">lambda </span><span class="s1">t: len(t[</span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">enumerate(key_path2d)))</span>
        <span class="s1">key_path3 = [x </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">key_elem_pairs]</span>
        <span class="s1">elem_idcs = [all_elem_idcs[i] </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">key_elem_pairs]</span>

        <span class="s2"># Convert elements to ints if possible.</span>
        <span class="s2"># e.g. ['foo', 'bar', '0'] -&gt; ['foo', 'bar', 0]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(key_path3)):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">key_path3[i] = int(key_path3[i])</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">_:</span>
                <span class="s0">pass</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">key_path3 = []</span>
        <span class="s1">elem_idcs = []</span>

    <span class="s0">return </span><span class="s1">(tuple(key_path3)</span><span class="s0">, </span><span class="s1">elem_idcs)</span>


<span class="s0">def </span><span class="s1">_remake_path_from_tuple(props):</span>
    <span class="s3">&quot;&quot;&quot; 
    try to remake a path using the properties in props 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(props) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_add_square_brackets_to_number(n):</span>
        <span class="s0">if </span><span class="s1">type(n) == type(int()):</span>
            <span class="s0">return </span><span class="s4">&quot;[%d]&quot; </span><span class="s1">% (n</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">n</span>

    <span class="s0">def </span><span class="s1">_prepend_dot_if_not_number(s):</span>
        <span class="s0">if not </span><span class="s1">s.startswith(</span><span class="s4">&quot;[&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s4">&quot;.&quot; </span><span class="s1">+ s</span>
        <span class="s0">return </span><span class="s1">s</span>

    <span class="s1">props_all_str = list(map(_add_square_brackets_to_number</span><span class="s0">, </span><span class="s1">props))</span>
    <span class="s1">props_w_underscore = props_all_str[:</span><span class="s5">1</span><span class="s1">] + list(</span>
        <span class="s1">map(_prepend_dot_if_not_number</span><span class="s0">, </span><span class="s1">props_all_str[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s4">&quot;&quot;</span><span class="s1">.join(props_w_underscore)</span>


<span class="s0">def </span><span class="s1">_check_path_in_prop_tree(obj</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">error_cast=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    obj:        the object in which the first property is looked up 
    path:       the path that will be split into properties to be looked up 
                path can also be a tuple. In this case, it is combined using . 
                and [] because it is impossible to reconstruct the string fully 
                in order to give a decent error message. 
    error_cast: this function walks down the property tree by looking up values 
                in objects. So this will throw exceptions that are thrown by 
                __getitem__, but in some cases we are checking the path for a 
                different reason and would prefer throwing a more relevant 
                exception (e.g., __getitem__ throws KeyError but __setitem__ 
                throws ValueError for subclasses of BasePlotlyType and 
                BaseFigure). So the resulting error can be &quot;casted&quot; to the 
                passed in type, if not None. 
    returns 
          an Exception object or None. The caller can raise this 
          exception to see where the lookup error occurred. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">path = _remake_path_from_tuple(path)</span>
    <span class="s1">prop</span><span class="s0">, </span><span class="s1">prop_idcs = _str_to_dict_path_full(path)</span>
    <span class="s1">prev_objs = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">enumerate(prop):</span>
        <span class="s1">arg = </span><span class="s4">&quot;&quot;</span>
        <span class="s1">prev_objs.append(obj)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">obj = obj[p]</span>
        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">KeyError</span><span class="s0">, </span><span class="s1">IndexError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">arg = e.args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">issubclass(e.__class__</span><span class="s0">, </span><span class="s1">TypeError):</span>
                <span class="s2"># If obj doesn't support subscripting, state that and show the</span>
                <span class="s2"># (valid) property that gives the object that doesn't support</span>
                <span class="s2"># subscripting.</span>
                <span class="s0">if </span><span class="s1">i &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">validator = prev_objs[i - </span><span class="s5">1</span><span class="s1">]._get_validator(prop[i - </span><span class="s5">1</span><span class="s1">])</span>
                    <span class="s1">arg += </span><span class="s4">&quot;&quot;&quot; 
 
Invalid value received for the '{plotly_name}' property of {parent_name} 
 
{description}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">parent_name=validator.parent_name</span><span class="s0">,</span>
                        <span class="s1">plotly_name=validator.plotly_name</span><span class="s0">,</span>
                        <span class="s1">description=validator.description()</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s2"># In case i is 0, the best we can do is indicate the first</span>
                <span class="s2"># property in the string as having caused the error</span>
                <span class="s1">disp_i = max(i - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">dict_item_len = _len_dict_item(prop[disp_i])</span>
                <span class="s2"># if the path has trailing underscores, the prop string will start with &quot;_&quot;</span>
                <span class="s1">trailing_underscores = </span><span class="s4">&quot;&quot;</span>
                <span class="s0">if </span><span class="s1">prop[i][</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">&quot;_&quot;</span><span class="s1">:</span>
                    <span class="s1">trailing_underscores = </span><span class="s4">&quot; and path has trailing underscores&quot;</span>
                <span class="s2"># if the path has trailing underscores and the display index is</span>
                <span class="s2"># one less than the prop index (see above), then we can also</span>
                <span class="s2"># indicate the offending underscores</span>
                <span class="s0">if </span><span class="s1">(trailing_underscores != </span><span class="s4">&quot;&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(disp_i != i):</span>
                    <span class="s1">dict_item_len += _len_dict_item(prop[i])</span>
                <span class="s1">arg += </span><span class="s4">&quot;&quot;&quot; 
 
Property does not support subscripting%s: 
%s 
%s&quot;&quot;&quot; </span><span class="s1">% (</span>
                    <span class="s1">trailing_underscores</span><span class="s0">,</span>
                    <span class="s1">path</span><span class="s0">,</span>
                    <span class="s1">display_string_positions(</span>
                        <span class="s1">prop_idcs</span><span class="s0">, </span><span class="s1">disp_i</span><span class="s0">, </span><span class="s1">length=dict_item_len</span><span class="s0">, </span><span class="s1">char=</span><span class="s4">&quot;^&quot;</span>
                    <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># State that the property for which subscripting was attempted</span>
                <span class="s2"># is bad and indicate the start of the bad property.</span>
                <span class="s1">arg += </span><span class="s4">&quot;&quot;&quot; 
Bad property path: 
%s 
%s&quot;&quot;&quot; </span><span class="s1">% (</span>
                    <span class="s1">path</span><span class="s0">,</span>
                    <span class="s1">display_string_positions(</span>
                        <span class="s1">prop_idcs</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">length=_len_dict_item(prop[i])</span><span class="s0">, </span><span class="s1">char=</span><span class="s4">&quot;^&quot;</span>
                    <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s2"># Make KeyError more pretty by changing it to a PlotlyKeyError,</span>
            <span class="s2"># because the Python interpreter has a special way of printing</span>
            <span class="s2"># KeyError</span>
            <span class="s0">if </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">KeyError):</span>
                <span class="s1">e = PlotlyKeyError()</span>
            <span class="s0">if </span><span class="s1">error_cast </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">e = error_cast()</span>
            <span class="s1">e.args = (arg</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">e</span>
    <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">_combine_dicts(dicts):</span>
    <span class="s1">all_args = dict()</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dicts:</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">d:</span>
            <span class="s1">all_args[k] = d[k]</span>
    <span class="s0">return </span><span class="s1">all_args</span>


<span class="s0">def </span><span class="s1">_indexing_combinations(dims</span><span class="s0">, </span><span class="s1">alls</span><span class="s0">, </span><span class="s1">product=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Gives indexing tuples specified by the coordinates in dims. 
    If a member of dims is 'all' then it is replaced by the corresponding member 
    in alls. 
    If product is True, then the cartesian product of all the indices is 
    returned, otherwise the zip (that means index lists of mis-matched length 
    will yield a list of tuples whose length is the length of the shortest 
    list). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(dims) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2"># this is because list(itertools.product(*[])) returns [()] which has non-zero</span>
        <span class="s2"># length!</span>
        <span class="s0">return </span><span class="s1">[]</span>
    <span class="s0">if </span><span class="s1">len(dims) != len(alls):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;Must have corresponding values in alls for each value of dims. Got dims=%s and alls=%s.&quot;</span>
            <span class="s1">% (str(dims)</span><span class="s0">, </span><span class="s1">str(alls))</span>
        <span class="s1">)</span>
    <span class="s1">r = []</span>
    <span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">a </span><span class="s0">in </span><span class="s1">zip(dims</span><span class="s0">, </span><span class="s1">alls):</span>
        <span class="s0">if </span><span class="s1">d == </span><span class="s4">&quot;all&quot;</span><span class="s1">:</span>
            <span class="s1">d = a</span>
        <span class="s0">elif not </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">d = [d]</span>
        <span class="s1">r.append(d)</span>
    <span class="s0">if </span><span class="s1">product:</span>
        <span class="s0">return </span><span class="s1">itertools.product(*r)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">zip(*r)</span>


<span class="s0">def </span><span class="s1">_is_select_subplot_coordinates_arg(*args):</span>
    <span class="s3">&quot;&quot;&quot; Returns true if any args are lists or the string 'all' &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">any((a == </span><span class="s4">&quot;all&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args)</span>


<span class="s0">def </span><span class="s1">_axis_spanning_shapes_docstr(shape_type):</span>
    <span class="s1">docstr = </span><span class="s4">&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">shape_type == </span><span class="s4">&quot;hline&quot;</span><span class="s1">:</span>
        <span class="s1">docstr = </span><span class="s4">&quot;&quot;&quot; 
Add a horizontal line to a plot or subplot that extends infinitely in the 
x-dimension. 
 
Parameters 
---------- 
y: float or int 
    A number representing the y coordinate of the horizontal line.&quot;&quot;&quot;</span>
    <span class="s0">elif </span><span class="s1">shape_type == </span><span class="s4">&quot;vline&quot;</span><span class="s1">:</span>
        <span class="s1">docstr = </span><span class="s4">&quot;&quot;&quot; 
Add a vertical line to a plot or subplot that extends infinitely in the 
y-dimension. 
 
Parameters 
---------- 
x: float or int 
    A number representing the x coordinate of the vertical line.&quot;&quot;&quot;</span>
    <span class="s0">elif </span><span class="s1">shape_type == </span><span class="s4">&quot;hrect&quot;</span><span class="s1">:</span>
        <span class="s1">docstr = </span><span class="s4">&quot;&quot;&quot; 
Add a rectangle to a plot or subplot that extends infinitely in the 
x-dimension. 
 
Parameters 
---------- 
y0: float or int 
    A number representing the y coordinate of one side of the rectangle. 
y1: float or int 
    A number representing the y coordinate of the other side of the rectangle.&quot;&quot;&quot;</span>
    <span class="s0">elif </span><span class="s1">shape_type == </span><span class="s4">&quot;vrect&quot;</span><span class="s1">:</span>
        <span class="s1">docstr = </span><span class="s4">&quot;&quot;&quot; 
Add a rectangle to a plot or subplot that extends infinitely in the 
y-dimension. 
 
Parameters 
---------- 
x0: float or int 
    A number representing the x coordinate of one side of the rectangle. 
x1: float or int 
    A number representing the x coordinate of the other side of the rectangle.&quot;&quot;&quot;</span>
    <span class="s1">docstr += </span><span class="s4">&quot;&quot;&quot; 
exclude_empty_subplots: Boolean 
    If True (default) do not place the shape on subplots that have no data 
    plotted on them. 
row: None, int or 'all' 
    Subplot row for shape indexed starting at 1. If 'all', addresses all rows in 
    the specified column(s). If both row and col are None, addresses the 
    first subplot if subplots exist, or the only plot. By default is &quot;all&quot;. 
col: None, int or 'all' 
    Subplot column for shape indexed starting at 1. If 'all', addresses all rows in 
    the specified column(s). If both row and col are None, addresses the 
    first subplot if subplots exist, or the only plot. By default is &quot;all&quot;. 
annotation: dict or plotly.graph_objects.layout.Annotation. If dict(), 
    it is interpreted as describing an annotation. The annotation is 
    placed relative to the shape based on annotation_position (see 
    below) unless its x or y value has been specified for the annotation 
    passed here. xref and yref are always the same as for the added 
    shape and cannot be overridden.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">shape_type </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;hline&quot;</span><span class="s0">, </span><span class="s4">&quot;vline&quot;</span><span class="s1">]:</span>
        <span class="s1">docstr += </span><span class="s4">&quot;&quot;&quot; 
annotation_position: a string containing optionally [&quot;top&quot;, &quot;bottom&quot;] 
    and [&quot;left&quot;, &quot;right&quot;] specifying where the text should be anchored 
    to on the line. Example positions are &quot;bottom left&quot;, &quot;right top&quot;, 
    &quot;right&quot;, &quot;bottom&quot;. If an annotation is added but annotation_position is 
    not specified, this defaults to &quot;top right&quot;.&quot;&quot;&quot;</span>
    <span class="s0">elif </span><span class="s1">shape_type </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;hrect&quot;</span><span class="s0">, </span><span class="s4">&quot;vrect&quot;</span><span class="s1">]:</span>
        <span class="s1">docstr += </span><span class="s4">&quot;&quot;&quot; 
annotation_position: a string containing optionally [&quot;inside&quot;, &quot;outside&quot;], [&quot;top&quot;, &quot;bottom&quot;] 
    and [&quot;left&quot;, &quot;right&quot;] specifying where the text should be anchored 
    to on the rectangle. Example positions are &quot;outside top left&quot;, &quot;inside 
    bottom&quot;, &quot;right&quot;, &quot;inside left&quot;, &quot;inside&quot; (&quot;outside&quot; is not supported). If 
    an annotation is added but annotation_position is not specified this 
    defaults to &quot;inside top right&quot;.&quot;&quot;&quot;</span>
    <span class="s1">docstr += </span><span class="s4">&quot;&quot;&quot; 
annotation_*: any parameters to go.layout.Annotation can be passed as 
    keywords by prefixing them with &quot;annotation_&quot;. For example, to specify the 
    annotation text &quot;example&quot; you can pass annotation_text=&quot;example&quot; as a 
    keyword argument. 
**kwargs: 
    Any named function parameters that can be passed to 'add_shape', 
    except for x0, x1, y0, y1 or type.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">docstr</span>


<span class="s0">def </span><span class="s1">_generator(i):</span>
    <span class="s3">&quot;&quot;&quot; &quot;cast&quot; an iterator to a generator &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">i:</span>
        <span class="s0">yield </span><span class="s1">x</span>


<span class="s0">class </span><span class="s1">BaseFigure(object):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for all figure types (both widget and non-widget) 
    &quot;&quot;&quot;</span>

    <span class="s1">_bracket_re = re.compile(</span><span class="s4">r&quot;^(.*)\[(\d+)\]$&quot;</span><span class="s1">)</span>

    <span class="s1">_valid_underscore_properties = {</span>
        <span class="s4">&quot;error_x&quot;</span><span class="s1">: </span><span class="s4">&quot;error-x&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;error_y&quot;</span><span class="s1">: </span><span class="s4">&quot;error-y&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;error_z&quot;</span><span class="s1">: </span><span class="s4">&quot;error-z&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;copy_xstyle&quot;</span><span class="s1">: </span><span class="s4">&quot;copy-xstyle&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;copy_ystyle&quot;</span><span class="s1">: </span><span class="s4">&quot;copy-ystyle&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;copy_zstyle&quot;</span><span class="s1">: </span><span class="s4">&quot;copy-zstyle&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;paper_bgcolor&quot;</span><span class="s1">: </span><span class="s4">&quot;paper-bgcolor&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;plot_bgcolor&quot;</span><span class="s1">: </span><span class="s4">&quot;plot-bgcolor&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">_set_trace_uid = </span><span class="s0">False</span>
    <span class="s1">_allow_disable_validation = </span><span class="s0">True</span>

    <span class="s2"># Constructor</span>
    <span class="s2"># -----------</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data=</span><span class="s0">None, </span><span class="s1">layout_plotly=</span><span class="s0">None, </span><span class="s1">frames=</span><span class="s0">None, </span><span class="s1">skip_invalid=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a BaseFigure object 
 
        Parameters 
        ---------- 
        data 
            One of: 
            - A list or tuple of trace objects (or dicts that can be coerced 
            into trace objects) 
 
            - If `data` is a dict that contains a 'data', 
            'layout', or 'frames' key then these values are used to 
            construct the figure. 
 
            - If `data` is a `BaseFigure` instance then the `data`, `layout`, 
            and `frames` properties are extracted from the input figure 
        layout_plotly 
            The plotly layout dict. 
 
            Note: this property is named `layout_plotly` rather than `layout` 
            to deconflict it with the `layout` constructor parameter of the 
            `widgets.DOMWidget` ipywidgets class, as the `BaseFigureWidget` 
            class is a subclass of both BaseFigure and widgets.DOMWidget. 
 
            If the `data` property is a BaseFigure instance, or a dict that 
            contains a 'layout' key, then this property is ignored. 
        frames 
            A list or tuple of `plotly.graph_objs.Frame` objects (or dicts 
            that can be coerced into Frame objects) 
 
            If the `data` property is a BaseFigure instance, or a dict that 
            contains a 'frames' key, then this property is ignored. 
 
        skip_invalid: bool 
            If True, invalid properties in the figure specification will be 
            skipped silently. If False (default) invalid properties in the 
            figure specification will result in a ValueError 
 
        Raises 
        ------ 
        ValueError 
            if a property in the specification of data, layout, or frames 
            is invalid AND skip_invalid is False 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.validators </span><span class="s0">import </span><span class="s1">DataValidator</span><span class="s0">, </span><span class="s1">LayoutValidator</span><span class="s0">, </span><span class="s1">FramesValidator</span>

        <span class="s1">super(BaseFigure</span><span class="s0">, </span><span class="s1">self).__init__()</span>

        <span class="s2"># Initialize validation</span>
        <span class="s1">self._validate = kwargs.pop(</span><span class="s4">&quot;_validate&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s2"># Assign layout_plotly to layout</span>
        <span class="s2"># ------------------------------</span>
        <span class="s2"># See docstring note for explanation</span>
        <span class="s1">layout = layout_plotly</span>

        <span class="s2"># Subplot properties</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># These properties are used by the tools.make_subplots logic.</span>
        <span class="s2"># We initialize them to None here, before checking if the input data</span>
        <span class="s2"># object is a BaseFigure, or a dict with _grid_str and _grid_ref</span>
        <span class="s2"># properties, in which case we bring over the _grid* properties of</span>
        <span class="s2"># the input</span>
        <span class="s1">self._grid_str = </span><span class="s0">None</span>
        <span class="s1">self._grid_ref = </span><span class="s0">None</span>

        <span class="s2"># Handle case where data is a Figure or Figure-like dict</span>
        <span class="s2"># ------------------------------------------------------</span>
        <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">BaseFigure):</span>
            <span class="s2"># Bring over subplot fields</span>
            <span class="s1">self._grid_str = data._grid_str</span>
            <span class="s1">self._grid_ref = data._grid_ref</span>

            <span class="s2"># Extract data, layout, and frames</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">layout</span><span class="s0">, </span><span class="s1">frames = data.data</span><span class="s0">, </span><span class="s1">data.layout</span><span class="s0">, </span><span class="s1">data.frames</span>

        <span class="s0">elif </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">and </span><span class="s1">(</span>
            <span class="s4">&quot;data&quot; </span><span class="s0">in </span><span class="s1">data </span><span class="s0">or </span><span class="s4">&quot;layout&quot; </span><span class="s0">in </span><span class="s1">data </span><span class="s0">or </span><span class="s4">&quot;frames&quot; </span><span class="s0">in </span><span class="s1">data</span>
        <span class="s1">):</span>

            <span class="s2"># Bring over subplot fields</span>
            <span class="s1">self._grid_str = data.get(</span><span class="s4">&quot;_grid_str&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">self._grid_ref = data.get(</span><span class="s4">&quot;_grid_ref&quot;</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s2"># Extract data, layout, and frames</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">layout</span><span class="s0">, </span><span class="s1">frames = (</span>
                <span class="s1">data.get(</span><span class="s4">&quot;data&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">data.get(</span><span class="s4">&quot;layout&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">data.get(</span><span class="s4">&quot;frames&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s2"># Handle data (traces)</span>
        <span class="s2"># --------------------</span>
        <span class="s2"># ### Construct data validator ###</span>
        <span class="s2"># This is the validator that handles importing sequences of trace</span>
        <span class="s2"># objects</span>
        <span class="s1">self._data_validator = DataValidator(set_uid=self._set_trace_uid)</span>

        <span class="s2"># ### Import traces ###</span>
        <span class="s1">data = self._data_validator.validate_coerce(</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid</span><span class="s0">, </span><span class="s1">_validate=self._validate</span>
        <span class="s1">)</span>

        <span class="s2"># ### Save tuple of trace objects ###</span>
        <span class="s1">self._data_objs = data</span>

        <span class="s2"># ### Import clone of trace properties ###</span>
        <span class="s2"># The _data property is a list of dicts containing the properties</span>
        <span class="s2"># explicitly set by the user for each trace.</span>
        <span class="s1">self._data = [deepcopy(trace._props) </span><span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">data]</span>

        <span class="s2"># ### Create data defaults ###</span>
        <span class="s2"># _data_defaults is a tuple of dicts, one for each trace. When</span>
        <span class="s2"># running in a widget context, these defaults are populated with</span>
        <span class="s2"># all property values chosen by the Plotly.js library that</span>
        <span class="s2"># aren't explicitly specified by the user.</span>
        <span class="s2">#</span>
        <span class="s2"># Note: No property should exist in both the _data and</span>
        <span class="s2"># _data_defaults for the same trace.</span>
        <span class="s1">self._data_defaults = [{} </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">data]</span>

        <span class="s2"># ### Reparent trace objects ###</span>
        <span class="s0">for </span><span class="s1">trace_ind</span><span class="s0">, </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">enumerate(data):</span>
            <span class="s2"># By setting the trace's parent to be this figure, we tell the</span>
            <span class="s2"># trace object to use the figure's _data and _data_defaults</span>
            <span class="s2"># dicts to get/set it's properties, rather than using the trace</span>
            <span class="s2"># object's internal _orphan_props dict.</span>
            <span class="s1">trace._parent = self</span>

            <span class="s2"># We clear the orphan props since the trace no longer needs then</span>
            <span class="s1">trace._orphan_props.clear()</span>

            <span class="s2"># Set trace index</span>
            <span class="s1">trace._trace_ind = trace_ind</span>

        <span class="s2"># Layout</span>
        <span class="s2"># ------</span>
        <span class="s2"># ### Construct layout validator ###</span>
        <span class="s2"># This is the validator that handles importing Layout objects</span>
        <span class="s1">self._layout_validator = LayoutValidator()</span>

        <span class="s2"># ### Import Layout ###</span>
        <span class="s1">self._layout_obj = self._layout_validator.validate_coerce(</span>
            <span class="s1">layout</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid</span><span class="s0">, </span><span class="s1">_validate=self._validate</span>
        <span class="s1">)</span>

        <span class="s2"># ### Import clone of layout properties ###</span>
        <span class="s1">self._layout = deepcopy(self._layout_obj._props)</span>

        <span class="s2"># ### Initialize layout defaults dict ###</span>
        <span class="s1">self._layout_defaults = {}</span>

        <span class="s2"># ### Reparent layout object ###</span>
        <span class="s1">self._layout_obj._orphan_props.clear()</span>
        <span class="s1">self._layout_obj._parent = self</span>

        <span class="s2"># Config</span>
        <span class="s2"># ------</span>
        <span class="s2"># Pass along default config to the front end. For now this just</span>
        <span class="s2"># ensures that the plotly domain url gets passed to the front end.</span>
        <span class="s2"># In the future we can extend this to allow the user to supply</span>
        <span class="s2"># arbitrary config options like in plotly.offline.plot/iplot.  But</span>
        <span class="s2"># this will require a fair amount of testing to determine which</span>
        <span class="s2"># options are compatible with FigureWidget.</span>
        <span class="s0">from </span><span class="s1">plotly.offline.offline </span><span class="s0">import </span><span class="s1">_get_jconfig</span>

        <span class="s1">self._config = _get_jconfig(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># Frames</span>
        <span class="s2"># ------</span>

        <span class="s2"># ### Construct frames validator ###</span>
        <span class="s2"># This is the validator that handles importing sequences of frame</span>
        <span class="s2"># objects</span>
        <span class="s1">self._frames_validator = FramesValidator()</span>

        <span class="s2"># ### Import frames ###</span>
        <span class="s1">self._frame_objs = self._frames_validator.validate_coerce(</span>
            <span class="s1">frames</span><span class="s0">, </span><span class="s1">skip_invalid=skip_invalid</span>
        <span class="s1">)</span>

        <span class="s2"># Note: Because frames are not currently supported in the widget</span>
        <span class="s2"># context, we don't need to follow the pattern above and create</span>
        <span class="s2"># _frames and _frame_defaults properties and then reparent the</span>
        <span class="s2"># frames. The figure doesn't need to be notified of</span>
        <span class="s2"># changes to the properties in the frames object hierarchy.</span>

        <span class="s2"># Context manager</span>
        <span class="s2"># ---------------</span>

        <span class="s2"># ### batch mode indicator ###</span>
        <span class="s2"># Flag that indicates whether we're currently inside a batch_*()</span>
        <span class="s2"># context</span>
        <span class="s1">self._in_batch_mode = </span><span class="s0">False</span>

        <span class="s2"># ### Batch trace edits ###</span>
        <span class="s2"># Dict from trace indexes to trace edit dicts. These trace edit dicts</span>
        <span class="s2"># are suitable as `data` elements of Plotly.animate, but not</span>
        <span class="s2"># the Plotly.update (See `_build_update_params_from_batch`)</span>
        <span class="s1">self._batch_trace_edits = OrderedDict()</span>

        <span class="s2"># ### Batch layout edits ###</span>
        <span class="s2"># Dict from layout properties to new layout values. This dict is</span>
        <span class="s2"># directly suitable for use in Plotly.animate and Plotly.update</span>
        <span class="s1">self._batch_layout_edits = OrderedDict()</span>

        <span class="s2"># Animation property validators</span>
        <span class="s2"># -----------------------------</span>
        <span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">animation</span>

        <span class="s1">self._animation_duration_validator = animation.DurationValidator()</span>
        <span class="s1">self._animation_easing_validator = animation.EasingValidator()</span>

        <span class="s2"># Template</span>
        <span class="s2"># --------</span>
        <span class="s2"># ### Check for default template ###</span>
        <span class="s1">self._initialize_layout_template()</span>

        <span class="s2"># Process kwargs</span>
        <span class="s2"># --------------</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items():</span>
            <span class="s1">err = _check_path_in_prop_tree(self</span><span class="s0">, </span><span class="s1">k)</span>
            <span class="s0">if </span><span class="s1">err </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self[k] = v</span>
            <span class="s0">elif not </span><span class="s1">skip_invalid:</span>
                <span class="s1">type_err = TypeError(</span><span class="s4">&quot;invalid Figure property: {}&quot;</span><span class="s1">.format(k))</span>
                <span class="s1">type_err.args = (</span>
                    <span class="s1">type_err.args[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">+ </span><span class="s4">&quot;&quot;&quot; 
%s&quot;&quot;&quot;</span>
                    <span class="s1">% (err.args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">type_err</span>

    <span class="s2"># Magic Methods</span>
    <span class="s2"># -------------</span>
    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom implementation of reduce is used to support deep copying 
        and pickling 
        &quot;&quot;&quot;</span>
        <span class="s1">props = self.to_dict()</span>
        <span class="s1">props[</span><span class="s4">&quot;_grid_str&quot;</span><span class="s1">] = self._grid_str</span>
        <span class="s1">props[</span><span class="s4">&quot;_grid_ref&quot;</span><span class="s1">] = self._grid_ref</span>
        <span class="s0">return </span><span class="s1">(self.__class__</span><span class="s0">, </span><span class="s1">(props</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>

        <span class="s2"># Normalize prop</span>
        <span class="s2"># --------------</span>
        <span class="s2"># Convert into a property tuple</span>
        <span class="s1">orig_prop = prop</span>
        <span class="s1">prop = BaseFigure._str_to_dict_path(prop)</span>

        <span class="s2"># Handle empty case</span>
        <span class="s2"># -----------------</span>
        <span class="s0">if </span><span class="s1">len(prop) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError(orig_prop)</span>

        <span class="s2"># Handle scalar case</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># e.g. ('foo',)</span>
        <span class="s0">elif </span><span class="s1">len(prop) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># ### Unwrap scalar tuple ###</span>
            <span class="s1">prop = prop[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">prop == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                <span class="s1">self.data = value</span>
            <span class="s0">elif </span><span class="s1">prop == </span><span class="s4">&quot;layout&quot;</span><span class="s1">:</span>
                <span class="s1">self.layout = value</span>
            <span class="s0">elif </span><span class="s1">prop == </span><span class="s4">&quot;frames&quot;</span><span class="s1">:</span>
                <span class="s1">self.frames = value</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">KeyError(prop)</span>

        <span class="s2"># Handle non-scalar case</span>
        <span class="s2"># ----------------------</span>
        <span class="s2"># e.g. ('foo', 1)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">err = _check_path_in_prop_tree(self</span><span class="s0">, </span><span class="s1">orig_prop</span><span class="s0">, </span><span class="s1">error_cast=ValueError)</span>
            <span class="s0">if </span><span class="s1">err </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">err</span>
            <span class="s1">res = self</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">prop[:-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">res = res[p]</span>

            <span class="s1">res._validate = self._validate</span>

            <span class="s1">res[prop[-</span><span class="s5">1</span><span class="s1">]] = value</span>

    <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        prop : str 
            The name of a direct child of this object 
        value 
            New property value 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">prop.startswith(</span><span class="s4">&quot;_&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s1">prop):</span>
            <span class="s2"># Let known properties and private properties through</span>
            <span class="s1">super(BaseFigure</span><span class="s0">, </span><span class="s1">self).__setattr__(prop</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Raise error on unknown public properties</span>
            <span class="s0">raise </span><span class="s1">AttributeError(prop)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">prop):</span>

        <span class="s2"># Normalize prop</span>
        <span class="s2"># --------------</span>
        <span class="s2"># Convert into a property tuple</span>
        <span class="s1">orig_prop = prop</span>
        <span class="s1">prop = BaseFigure._str_to_dict_path(prop)</span>

        <span class="s2"># Handle scalar case</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># e.g. ('foo',)</span>
        <span class="s0">if </span><span class="s1">len(prop) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># Unwrap scalar tuple</span>
            <span class="s1">prop = prop[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">prop == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._data_validator.present(self._data_objs)</span>
            <span class="s0">elif </span><span class="s1">prop == </span><span class="s4">&quot;layout&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._layout_validator.present(self._layout_obj)</span>
            <span class="s0">elif </span><span class="s1">prop == </span><span class="s4">&quot;frames&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._frames_validator.present(self._frame_objs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">KeyError(orig_prop)</span>

        <span class="s2"># Handle non-scalar case</span>
        <span class="s2"># ----------------------</span>
        <span class="s2"># e.g. ('foo', 1)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">err = _check_path_in_prop_tree(self</span><span class="s0">, </span><span class="s1">orig_prop</span><span class="s0">, </span><span class="s1">error_cast=PlotlyKeyError)</span>
            <span class="s0">if </span><span class="s1">err </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">err</span>
            <span class="s1">res = self</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">prop:</span>
                <span class="s1">res = res[p]</span>

            <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter((</span><span class="s4">&quot;data&quot;</span><span class="s0">, </span><span class="s4">&quot;layout&quot;</span><span class="s0">, </span><span class="s4">&quot;frames&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s1">prop = BaseFigure._str_to_dict_path(prop)</span>
        <span class="s0">if </span><span class="s1">prop[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">(</span><span class="s4">&quot;data&quot;</span><span class="s0">, </span><span class="s4">&quot;layout&quot;</span><span class="s0">, </span><span class="s4">&quot;frames&quot;</span><span class="s1">):</span>
            <span class="s0">return False</span>
        <span class="s0">elif </span><span class="s1">len(prop) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">prop[</span><span class="s5">1</span><span class="s1">:] </span><span class="s0">in </span><span class="s1">self[prop[</span><span class="s5">0</span><span class="s1">]]</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">BaseFigure):</span>
            <span class="s2"># Require objects to both be BaseFigure instances</span>
            <span class="s0">return False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Compare plotly_json representations</span>

            <span class="s2"># Use _vals_equal instead of `==` to handle cases where</span>
            <span class="s2"># underlying dicts contain numpy arrays</span>
            <span class="s0">return </span><span class="s1">BasePlotlyType._vals_equal(</span>
                <span class="s1">self.to_plotly_json()</span><span class="s0">, </span><span class="s1">other.to_plotly_json()</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Customize Figure representation when displayed in the 
        terminal/notebook 
        &quot;&quot;&quot;</span>
        <span class="s1">props = self.to_plotly_json()</span>

        <span class="s2"># Elide template</span>
        <span class="s1">template_props = props.get(</span><span class="s4">&quot;layout&quot;</span><span class="s0">, </span><span class="s1">{}).get(</span><span class="s4">&quot;template&quot;</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s0">if </span><span class="s1">template_props:</span>
            <span class="s1">props[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;template&quot;</span><span class="s1">] = </span><span class="s4">&quot;...&quot;</span>

        <span class="s1">repr_str = BasePlotlyType._build_repr_for_class(</span>
            <span class="s1">props=props</span><span class="s0">, </span><span class="s1">class_name=self.__class__.__name__</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">repr_str</span>

    <span class="s0">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Customize html representation 
        &quot;&quot;&quot;</span>
        <span class="s1">bundle = self._repr_mimebundle_()</span>
        <span class="s0">if </span><span class="s4">&quot;text/html&quot; </span><span class="s0">in </span><span class="s1">bundle:</span>
            <span class="s0">return </span><span class="s1">bundle[</span><span class="s4">&quot;text/html&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.to_html(full_html=</span><span class="s0">False, </span><span class="s1">include_plotlyjs=</span><span class="s4">&quot;cdn&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_repr_mimebundle_(self</span><span class="s0">, </span><span class="s1">include=</span><span class="s0">None, </span><span class="s1">exclude=</span><span class="s0">None, </span><span class="s1">validate=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return mimebundle corresponding to default renderer. 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s1">renderer_str = pio.renderers.default</span>
        <span class="s1">renderers = pio._renderers.renderers</span>
        <span class="s1">renderer_names = renderers._validate_coerce_renderers(renderer_str)</span>
        <span class="s1">renderers_list = [renderers[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">renderer_names]</span>
        <span class="s0">from </span><span class="s1">plotly.io._utils </span><span class="s0">import </span><span class="s1">validate_coerce_fig_to_dict</span>
        <span class="s0">from </span><span class="s1">plotly.io._renderers </span><span class="s0">import </span><span class="s1">MimetypeRenderer</span>

        <span class="s1">fig_dict = validate_coerce_fig_to_dict(self</span><span class="s0">, </span><span class="s1">validate)</span>
        <span class="s2"># Mimetype renderers</span>
        <span class="s1">bundle = {}</span>
        <span class="s0">for </span><span class="s1">renderer </span><span class="s0">in </span><span class="s1">renderers_list:</span>
            <span class="s0">if </span><span class="s1">isinstance(renderer</span><span class="s0">, </span><span class="s1">MimetypeRenderer):</span>
                <span class="s1">bundle.update(renderer.to_mimebundle(fig_dict))</span>
        <span class="s0">return </span><span class="s1">bundle</span>

    <span class="s0">def </span><span class="s1">_ipython_display_(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Handle rich display of figures in ipython contexts 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">if </span><span class="s1">pio.renderers.render_on_display </span><span class="s0">and </span><span class="s1">pio.renderers.default:</span>
            <span class="s1">pio.show(self)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(repr(self))</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">dict1=</span><span class="s0">None, </span><span class="s1">overwrite=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Update the properties of the figure with a dict and/or with 
        keyword arguments. 
 
        This recursively updates the structure of the figure 
        object with the values in the input dict / keyword arguments. 
 
        Parameters 
        ---------- 
        dict1 : dict 
            Dictionary of properties to be updated 
        overwrite: bool 
            If True, overwrite existing properties. If False, apply updates 
            to existing properties recursively, preserving existing 
            properties that are not specified in the update operation. 
        kwargs : 
            Keyword/value pair of properties to be updated 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import plotly.graph_objs as go 
        &gt;&gt;&gt; fig = go.Figure(data=[{'y': [1, 2, 3]}]) 
        &gt;&gt;&gt; fig.update(data=[{'y': [4, 5, 6]}]) # doctest: +ELLIPSIS 
        Figure(...) 
        &gt;&gt;&gt; fig.to_plotly_json() # doctest: +SKIP 
            {'data': [{'type': 'scatter', 
               'uid': 'e86a7c7a-346a-11e8-8aa8-a0999b0c017b', 
               'y': array([4, 5, 6], dtype=int32)}], 
             'layout': {}} 
 
        &gt;&gt;&gt; fig = go.Figure(layout={'xaxis': 
        ...                         {'color': 'green', 
        ...                          'range': [0, 1]}}) 
        &gt;&gt;&gt; fig.update({'layout': {'xaxis': {'color': 'pink'}}}) # doctest: +ELLIPSIS 
        Figure(...) 
        &gt;&gt;&gt; fig.to_plotly_json() # doctest: +SKIP 
            {'data': [], 
             'layout': {'xaxis': 
                        {'color': 'pink', 
                         'range': [0, 1]}}} 
 
        Returns 
        ------- 
        BaseFigure 
            Updated figure 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self.batch_update():</span>
            <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">[dict1</span><span class="s0">, </span><span class="s1">kwargs]:</span>
                <span class="s0">if </span><span class="s1">d:</span>
                    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">d.items():</span>
                        <span class="s1">update_target = self[k]</span>
                        <span class="s0">if </span><span class="s1">update_target == () </span><span class="s0">or </span><span class="s1">overwrite:</span>
                            <span class="s0">if </span><span class="s1">k == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                                <span class="s2"># Overwrite all traces as special due to</span>
                                <span class="s2"># restrictions on trace assignment</span>
                                <span class="s1">self.data = ()</span>
                                <span class="s1">self.add_traces(v)</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s2"># Accept v</span>
                                <span class="s1">self[k] = v</span>
                        <span class="s0">elif </span><span class="s1">(</span>
                            <span class="s1">isinstance(update_target</span><span class="s0">, </span><span class="s1">BasePlotlyType)</span>
                            <span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">BasePlotlyType))</span>
                        <span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
                            <span class="s1">isinstance(update_target</span><span class="s0">, </span><span class="s1">tuple)</span>
                            <span class="s0">and </span><span class="s1">isinstance(update_target[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">BasePlotlyType)</span>
                        <span class="s1">):</span>
                            <span class="s1">BaseFigure._perform_update(self[k]</span><span class="s0">, </span><span class="s1">v)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">self[k] = v</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s3">&quot;&quot;&quot; 
        Remove the value associated with the specified key and return it 
 
        Parameters 
        ---------- 
        key: str 
            Property name 
        dflt 
            The default value to return if key was not found in figure 
 
        Returns 
        ------- 
        value 
            The removed value that was previously associated with key 
 
        Raises 
        ------ 
        KeyError 
            If key is not in object and no dflt argument specified 
        &quot;&quot;&quot;</span>
        <span class="s2"># Handle default</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self </span><span class="s0">and </span><span class="s1">args:</span>
            <span class="s0">return </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s1">val = self[key]</span>
            <span class="s1">self[key] = </span><span class="s0">None</span>
            <span class="s0">return </span><span class="s1">val</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>

    <span class="s2"># Data</span>
    <span class="s2"># ----</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">data(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        The `data` property is a tuple of the figure's trace objects 
 
        Returns 
        ------- 
        tuple[BaseTraceType] 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self[</span><span class="s4">&quot;data&quot;</span><span class="s1">]</span>

    <span class="s1">@data.setter</span>
    <span class="s0">def </span><span class="s1">data(self</span><span class="s0">, </span><span class="s1">new_data):</span>

        <span class="s2"># Validate new_data</span>
        <span class="s2"># -----------------</span>
        <span class="s1">err_header = (</span>
            <span class="s4">&quot;The data property of a figure may only be assigned </span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;a list or tuple that contains a permutation of a &quot;</span>
            <span class="s4">&quot;subset of itself.</span><span class="s0">\n</span><span class="s4">&quot;</span>
        <span class="s1">)</span>

        <span class="s2"># ### Treat None as empty ###</span>
        <span class="s0">if </span><span class="s1">new_data </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new_data = ()</span>

        <span class="s2"># ### Check valid input type ###</span>
        <span class="s0">if not </span><span class="s1">isinstance(new_data</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">err_msg = err_header + </span><span class="s4">&quot;    Received value with type {typ}&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(new_data)</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">ValueError(err_msg)</span>

        <span class="s2"># ### Check valid element types ###</span>
        <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">new_data:</span>
            <span class="s0">if not </span><span class="s1">isinstance(trace</span><span class="s0">, </span><span class="s1">BaseTraceType):</span>
                <span class="s1">err_msg = (</span>
                    <span class="s1">err_header</span>
                    <span class="s1">+ </span><span class="s4">&quot;    Received element value of type {typ}&quot;</span><span class="s1">.format(typ=type(trace))</span>
                <span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">ValueError(err_msg)</span>

        <span class="s2"># ### Check trace objects ###</span>
        <span class="s2"># Require that no new traces are introduced</span>
        <span class="s1">orig_uids = [id(trace) </span><span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">self.data]</span>
        <span class="s1">new_uids = [id(trace) </span><span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">new_data]</span>

        <span class="s1">invalid_uids = set(new_uids).difference(set(orig_uids))</span>
        <span class="s0">if </span><span class="s1">invalid_uids:</span>
            <span class="s1">err_msg = err_header</span>

            <span class="s0">raise </span><span class="s1">ValueError(err_msg)</span>

        <span class="s2"># ### Check for duplicates in assignment ###</span>
        <span class="s1">uid_counter = collections.Counter(new_uids)</span>
        <span class="s1">duplicate_uids = [uid </span><span class="s0">for </span><span class="s1">uid</span><span class="s0">, </span><span class="s1">count </span><span class="s0">in </span><span class="s1">uid_counter.items() </span><span class="s0">if </span><span class="s1">count &gt; </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">duplicate_uids:</span>
            <span class="s1">err_msg = err_header + </span><span class="s4">&quot;    Received duplicated traces&quot;</span>

            <span class="s0">raise </span><span class="s1">ValueError(err_msg)</span>

        <span class="s2"># Remove traces</span>
        <span class="s2"># -------------</span>
        <span class="s1">remove_uids = set(orig_uids).difference(set(new_uids))</span>
        <span class="s1">delete_inds = []</span>

        <span class="s2"># ### Unparent removed traces ###</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">enumerate(self.data):</span>
            <span class="s0">if </span><span class="s1">id(trace) </span><span class="s0">in </span><span class="s1">remove_uids:</span>
                <span class="s1">delete_inds.append(i)</span>

                <span class="s2"># Unparent trace object to be removed</span>
                <span class="s1">old_trace = self.data[i]</span>
                <span class="s1">old_trace._orphan_props.update(deepcopy(old_trace._props))</span>
                <span class="s1">old_trace._parent = </span><span class="s0">None</span>
                <span class="s1">old_trace._trace_ind = </span><span class="s0">None</span>

        <span class="s2"># ### Compute trace props / defaults after removal ###</span>
        <span class="s1">traces_props_post_removal = [t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self._data]</span>
        <span class="s1">traces_prop_defaults_post_removal = [t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self._data_defaults]</span>
        <span class="s1">uids_post_removal = [id(trace_data) </span><span class="s0">for </span><span class="s1">trace_data </span><span class="s0">in </span><span class="s1">self.data]</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">reversed(delete_inds):</span>
            <span class="s0">del </span><span class="s1">traces_props_post_removal[i]</span>
            <span class="s0">del </span><span class="s1">traces_prop_defaults_post_removal[i]</span>
            <span class="s0">del </span><span class="s1">uids_post_removal[i]</span>

            <span class="s2"># Modify in-place so we don't trigger serialization</span>
            <span class="s0">del </span><span class="s1">self._data[i]</span>

        <span class="s0">if </span><span class="s1">delete_inds:</span>
            <span class="s2"># Update widget, if any</span>
            <span class="s1">self._send_deleteTraces_msg(delete_inds)</span>

        <span class="s2"># Move traces</span>
        <span class="s2"># -----------</span>

        <span class="s2"># ### Compute new index for each remaining trace ###</span>
        <span class="s1">new_inds = []</span>
        <span class="s0">for </span><span class="s1">uid </span><span class="s0">in </span><span class="s1">uids_post_removal:</span>
            <span class="s1">new_inds.append(new_uids.index(uid))</span>

        <span class="s2"># ### Compute current index for each remaining trace ###</span>
        <span class="s1">current_inds = list(range(len(traces_props_post_removal)))</span>

        <span class="s2"># ### Check whether a move is needed ###</span>
        <span class="s0">if not </span><span class="s1">all([i1 == i2 </span><span class="s0">for </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2 </span><span class="s0">in </span><span class="s1">zip(new_inds</span><span class="s0">, </span><span class="s1">current_inds)]):</span>

            <span class="s2"># #### Save off index lists for moveTraces message ####</span>
            <span class="s1">msg_current_inds = current_inds</span>
            <span class="s1">msg_new_inds = new_inds</span>

            <span class="s2"># #### Reorder trace elements ####</span>
            <span class="s2"># We do so in-place so we don't trigger traitlet property</span>
            <span class="s2"># serialization for the FigureWidget case</span>
            <span class="s2"># ##### Remove by curr_inds in reverse order #####</span>
            <span class="s1">moving_traces_data = []</span>
            <span class="s0">for </span><span class="s1">ci </span><span class="s0">in </span><span class="s1">reversed(current_inds):</span>
                <span class="s2"># Push moving traces data to front of list</span>
                <span class="s1">moving_traces_data.insert(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">self._data[ci])</span>
                <span class="s0">del </span><span class="s1">self._data[ci]</span>

            <span class="s2"># #### Sort new_inds and moving_traces_data by new_inds ####</span>
            <span class="s1">new_inds</span><span class="s0">, </span><span class="s1">moving_traces_data = zip(</span>
                <span class="s1">*sorted(zip(new_inds</span><span class="s0">, </span><span class="s1">moving_traces_data))</span>
            <span class="s1">)</span>

            <span class="s2"># #### Insert by new_inds in forward order ####</span>
            <span class="s0">for </span><span class="s1">ni</span><span class="s0">, </span><span class="s1">trace_data </span><span class="s0">in </span><span class="s1">zip(new_inds</span><span class="s0">, </span><span class="s1">moving_traces_data):</span>
                <span class="s1">self._data.insert(ni</span><span class="s0">, </span><span class="s1">trace_data)</span>

            <span class="s2"># #### Update widget, if any ####</span>
            <span class="s1">self._send_moveTraces_msg(msg_current_inds</span><span class="s0">, </span><span class="s1">msg_new_inds)</span>

        <span class="s2"># ### Update data defaults ###</span>
        <span class="s2"># There is to front-end syncronization to worry about so this</span>
        <span class="s2"># operations doesn't need to be in-place</span>
        <span class="s1">self._data_defaults = [</span>
            <span class="s1">_trace</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">_trace </span><span class="s0">in </span><span class="s1">sorted(zip(new_inds</span><span class="s0">, </span><span class="s1">traces_prop_defaults_post_removal))</span>
        <span class="s1">]</span>

        <span class="s2"># Update trace objects tuple</span>
        <span class="s1">self._data_objs = list(new_data)</span>

        <span class="s2"># Update trace indexes</span>
        <span class="s0">for </span><span class="s1">trace_ind</span><span class="s0">, </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">enumerate(self._data_objs):</span>
            <span class="s1">trace._trace_ind = trace_ind</span>

    <span class="s0">def </span><span class="s1">select_traces(self</span><span class="s0">, </span><span class="s1">selector=</span><span class="s0">None, </span><span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">secondary_y=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Select traces from a particular subplot cell and/or traces 
        that satisfy custom selection criteria. 
 
        Parameters 
        ---------- 
        selector: dict, function, int, str or None (default None) 
            Dict to use as selection criteria. 
            Traces will be selected if they contain properties corresponding 
            to all of the dictionary's keys, with values that exactly match 
            the supplied values. If None (the default), all traces are 
            selected. If a function, it must be a function accepting a single 
            argument and returning a boolean. The function will be called on 
            each trace and those for which the function returned True 
            will be in the selection. If an int N, the Nth trace matching row 
            and col will be selected (N can be negative). If a string S, the selector 
            is equivalent to dict(type=S). 
        row, col: int or None (default None) 
            Subplot row and column index of traces to select. 
            To select traces by row and column, the Figure must have been 
            created using plotly.subplots.make_subplots.  If None 
            (the default), all traces are selected. 
        secondary_y: boolean or None (default None) 
            * If True, only select traces associated with the secondary 
              y-axis of the subplot. 
            * If False, only select traces associated with the primary 
              y-axis of the subplot. 
            * If None (the default), do not filter traces based on secondary 
              y-axis. 
 
            To select traces by secondary y-axis, the Figure must have been 
            created using plotly.subplots.make_subplots. See the docstring 
            for the specs argument to make_subplots for more info on 
            creating subplots with secondary y-axes. 
        Returns 
        ------- 
        generator 
            Generator that iterates through all of the traces that satisfy 
            all of the specified selection criteria 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">selector:</span>
            <span class="s1">selector = {}</span>

        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None or </span><span class="s1">col </span><span class="s0">is not None or </span><span class="s1">secondary_y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
            <span class="s1">filter_by_subplot = </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">row </span><span class="s0">is None and </span><span class="s1">col </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s2"># All rows for column</span>
                <span class="s1">grid_subplot_ref_tuples = [ref_row[col - </span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">ref_row </span><span class="s0">in </span><span class="s1">grid_ref]</span>
            <span class="s0">elif </span><span class="s1">col </span><span class="s0">is None and </span><span class="s1">row </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s2"># All columns for row</span>
                <span class="s1">grid_subplot_ref_tuples = grid_ref[row - </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">elif </span><span class="s1">col </span><span class="s0">is not None and </span><span class="s1">row </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s2"># Single grid cell</span>
                <span class="s1">grid_subplot_ref_tuples = [grid_ref[row - </span><span class="s5">1</span><span class="s1">][col - </span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># row and col are None, secondary_y not None</span>
                <span class="s1">grid_subplot_ref_tuples = [</span>
                    <span class="s1">refs </span><span class="s0">for </span><span class="s1">refs_row </span><span class="s0">in </span><span class="s1">grid_ref </span><span class="s0">for </span><span class="s1">refs </span><span class="s0">in </span><span class="s1">refs_row</span>
                <span class="s1">]</span>

            <span class="s2"># Collect list of subplot refs, taking secondary_y into account</span>
            <span class="s1">grid_subplot_refs = []</span>
            <span class="s0">for </span><span class="s1">refs </span><span class="s0">in </span><span class="s1">grid_subplot_ref_tuples:</span>
                <span class="s0">if not </span><span class="s1">refs:</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">secondary_y </span><span class="s0">is not True</span><span class="s1">:</span>
                    <span class="s1">grid_subplot_refs.append(refs[</span><span class="s5">0</span><span class="s1">])</span>

                <span class="s0">if </span><span class="s1">secondary_y </span><span class="s0">is not False and </span><span class="s1">len(refs) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">grid_subplot_refs.append(refs[</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">filter_by_subplot = </span><span class="s0">False</span>
            <span class="s1">grid_subplot_refs = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">self._perform_select_traces(</span>
            <span class="s1">filter_by_subplot</span><span class="s0">, </span><span class="s1">grid_subplot_refs</span><span class="s0">, </span><span class="s1">selector</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_perform_select_traces(self</span><span class="s0">, </span><span class="s1">filter_by_subplot</span><span class="s0">, </span><span class="s1">grid_subplot_refs</span><span class="s0">, </span><span class="s1">selector):</span>
        <span class="s0">from </span><span class="s1">plotly.subplots </span><span class="s0">import </span><span class="s1">_get_subplot_ref_for_trace</span>

        <span class="s2"># functions for filtering</span>
        <span class="s0">def </span><span class="s1">_filter_by_subplot_ref(trace):</span>
            <span class="s1">trace_subplot_ref = _get_subplot_ref_for_trace(trace)</span>
            <span class="s0">return </span><span class="s1">trace_subplot_ref </span><span class="s0">in </span><span class="s1">grid_subplot_refs</span>

        <span class="s1">funcs = []</span>
        <span class="s0">if </span><span class="s1">filter_by_subplot:</span>
            <span class="s1">funcs.append(_filter_by_subplot_ref)</span>

        <span class="s0">return </span><span class="s1">_generator(self._filter_by_selector(self.data</span><span class="s0">, </span><span class="s1">funcs</span><span class="s0">, </span><span class="s1">selector))</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_selector_matches(obj</span><span class="s0">, </span><span class="s1">selector):</span>
        <span class="s0">if </span><span class="s1">selector </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return True</span>
        <span class="s2"># If selector is a string then put it at the 'type' key of a dictionary</span>
        <span class="s2"># to select objects where &quot;type&quot;:selector</span>
        <span class="s0">if </span><span class="s1">isinstance(selector</span><span class="s0">, </span><span class="s1">six.string_types):</span>
            <span class="s1">selector = dict(type=selector)</span>
        <span class="s2"># If selector is a dict, compare the fields</span>
        <span class="s0">if </span><span class="s1">isinstance(selector</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">or </span><span class="s1">isinstance(selector</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
            <span class="s2"># This returns True if selector is an empty dict</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">selector:</span>
                <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">obj:</span>
                    <span class="s0">return False</span>

                <span class="s1">obj_val = obj[k]</span>
                <span class="s1">selector_val = selector[k]</span>

                <span class="s0">if </span><span class="s1">isinstance(obj_val</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                    <span class="s1">obj_val = obj_val.to_plotly_json()</span>

                <span class="s0">if </span><span class="s1">isinstance(selector_val</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                    <span class="s1">selector_val = selector_val.to_plotly_json()</span>

                <span class="s0">if </span><span class="s1">obj_val != selector_val:</span>
                    <span class="s0">return False</span>
            <span class="s0">return True</span>
        <span class="s2"># If selector is a function, call it with the obj as the argument</span>
        <span class="s0">elif </span><span class="s1">six.callable(selector):</span>
            <span class="s0">return </span><span class="s1">selector(obj)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;selector must be dict or a function &quot;</span>
                <span class="s4">&quot;accepting a graph object returning a boolean.&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_filter_by_selector(self</span><span class="s0">, </span><span class="s1">objects</span><span class="s0">, </span><span class="s1">funcs</span><span class="s0">, </span><span class="s1">selector):</span>
        <span class="s3">&quot;&quot;&quot; 
        objects is a sequence of objects, funcs a list of functions that 
        return True if the object should be included in the selection and False 
        otherwise and selector is an argument to the self._selector_matches 
        function. 
        If selector is an integer, the resulting sequence obtained after 
        sucessively filtering by each function in funcs is indexed by this 
        integer. 
        Otherwise selector is used as the selector argument to 
        self._selector_matches which is used to filter down the sequence. 
        The function returns the sequence (an iterator). 
        &quot;&quot;&quot;</span>

        <span class="s2"># if selector is not an int, we call it on each trace to test it for selection</span>
        <span class="s0">if not </span><span class="s1">isinstance(selector</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s1">funcs.append(</span><span class="s0">lambda </span><span class="s1">obj: self._selector_matches(obj</span><span class="s0">, </span><span class="s1">selector))</span>

        <span class="s0">def </span><span class="s1">_filt(last</span><span class="s0">, </span><span class="s1">f):</span>
            <span class="s0">return </span><span class="s1">filter(f</span><span class="s0">, </span><span class="s1">last)</span>

        <span class="s1">filtered_objects = reduce(_filt</span><span class="s0">, </span><span class="s1">funcs</span><span class="s0">, </span><span class="s1">objects)</span>

        <span class="s0">if </span><span class="s1">isinstance(selector</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">return </span><span class="s1">iter([list(filtered_objects)[selector]])</span>

        <span class="s0">return </span><span class="s1">filtered_objects</span>

    <span class="s0">def </span><span class="s1">for_each_trace(self</span><span class="s0">, </span><span class="s1">fn</span><span class="s0">, </span><span class="s1">selector=</span><span class="s0">None, </span><span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">secondary_y=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply a function to all traces that satisfy the specified selection 
        criteria 
 
        Parameters 
        ---------- 
        fn: 
            Function that inputs a single trace object. 
        selector: dict, function, int, str or None (default None) 
            Dict to use as selection criteria. 
            Traces will be selected if they contain properties corresponding 
            to all of the dictionary's keys, with values that exactly match 
            the supplied values. If None (the default), all traces are 
            selected. If a function, it must be a function accepting a single 
            argument and returning a boolean. The function will be called on 
            each trace and those for which the function returned True 
            will be in the selection. If an int N, the Nth trace matching row 
            and col will be selected (N can be negative). If a string S, the selector 
            is equivalent to dict(type=S). 
        row, col: int or None (default None) 
            Subplot row and column index of traces to select. 
            To select traces by row and column, the Figure must have been 
            created using plotly.subplots.make_subplots.  If None 
            (the default), all traces are selected. 
        secondary_y: boolean or None (default None) 
            * If True, only select traces associated with the secondary 
              y-axis of the subplot. 
            * If False, only select traces associated with the primary 
              y-axis of the subplot. 
            * If None (the default), do not filter traces based on secondary 
              y-axis. 
 
            To select traces by secondary y-axis, the Figure must have been 
            created using plotly.subplots.make_subplots. See the docstring 
            for the specs argument to make_subplots for more info on 
            creating subplots with secondary y-axes. 
        Returns 
        ------- 
        self 
            Returns the Figure object that the method was called on 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">self.select_traces(</span>
            <span class="s1">selector=selector</span><span class="s0">, </span><span class="s1">row=row</span><span class="s0">, </span><span class="s1">col=col</span><span class="s0">, </span><span class="s1">secondary_y=secondary_y</span>
        <span class="s1">):</span>
            <span class="s1">fn(trace)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">update_traces(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">patch=</span><span class="s0">None,</span>
        <span class="s1">selector=</span><span class="s0">None,</span>
        <span class="s1">row=</span><span class="s0">None,</span>
        <span class="s1">col=</span><span class="s0">None,</span>
        <span class="s1">secondary_y=</span><span class="s0">None,</span>
        <span class="s1">overwrite=</span><span class="s0">False,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a property update operation on all traces that satisfy the 
        specified selection criteria 
 
        Parameters 
        ---------- 
        patch: dict or None (default None) 
            Dictionary of property updates to be applied to all traces that 
            satisfy the selection criteria. 
        selector: dict, function, int, str or None (default None) 
            Dict to use as selection criteria. 
            Traces will be selected if they contain properties corresponding 
            to all of the dictionary's keys, with values that exactly match 
            the supplied values. If None (the default), all traces are 
            selected. If a function, it must be a function accepting a single 
            argument and returning a boolean. The function will be called on 
            each trace and those for which the function returned True 
            will be in the selection. If an int N, the Nth trace matching row 
            and col will be selected (N can be negative). If a string S, the selector 
            is equivalent to dict(type=S). 
        row, col: int or None (default None) 
            Subplot row and column index of traces to select. 
            To select traces by row and column, the Figure must have been 
            created using plotly.subplots.make_subplots.  If None 
            (the default), all traces are selected. 
        secondary_y: boolean or None (default None) 
            * If True, only select traces associated with the secondary 
              y-axis of the subplot. 
            * If False, only select traces associated with the primary 
              y-axis of the subplot. 
            * If None (the default), do not filter traces based on secondary 
              y-axis. 
 
            To select traces by secondary y-axis, the Figure must have been 
            created using plotly.subplots.make_subplots. See the docstring 
            for the specs argument to make_subplots for more info on 
            creating subplots with secondary y-axes. 
        overwrite: bool 
            If True, overwrite existing properties. If False, apply updates 
            to existing properties recursively, preserving existing 
            properties that are not specified in the update operation. 
        **kwargs 
            Additional property updates to apply to each selected trace. If 
            a property is specified in both patch and in **kwargs then the 
            one in **kwargs takes precedence. 
 
        Returns 
        ------- 
        self 
            Returns the Figure object that the method was called on 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">self.select_traces(</span>
            <span class="s1">selector=selector</span><span class="s0">, </span><span class="s1">row=row</span><span class="s0">, </span><span class="s1">col=col</span><span class="s0">, </span><span class="s1">secondary_y=secondary_y</span>
        <span class="s1">):</span>
            <span class="s1">trace.update(patch</span><span class="s0">, </span><span class="s1">overwrite=overwrite</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">update_layout(self</span><span class="s0">, </span><span class="s1">dict1=</span><span class="s0">None, </span><span class="s1">overwrite=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Update the properties of the figure's layout with a dict and/or with 
        keyword arguments. 
 
        This recursively updates the structure of the original 
        layout with the values in the input dict / keyword arguments. 
 
        Parameters 
        ---------- 
        dict1 : dict 
            Dictionary of properties to be updated 
        overwrite: bool 
            If True, overwrite existing properties. If False, apply updates 
            to existing properties recursively, preserving existing 
            properties that are not specified in the update operation. 
        kwargs : 
            Keyword/value pair of properties to be updated 
 
        Returns 
        ------- 
        BaseFigure 
            The Figure object that the update_layout method was called on 
        &quot;&quot;&quot;</span>
        <span class="s1">self.layout.update(dict1</span><span class="s0">, </span><span class="s1">overwrite=overwrite</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_select_layout_subplots_by_prefix(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">prefix</span><span class="s0">, </span><span class="s1">selector=</span><span class="s0">None, </span><span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">secondary_y=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Helper called by code generated select_* methods 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None or </span><span class="s1">col </span><span class="s0">is not None or </span><span class="s1">secondary_y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Build mapping from container keys ('xaxis2', 'scene4', etc.)</span>
            <span class="s2"># to (row, col, secondary_y) triplets</span>
            <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
            <span class="s1">container_to_row_col = {}</span>
            <span class="s0">for </span><span class="s1">r</span><span class="s0">, </span><span class="s1">subplot_row </span><span class="s0">in </span><span class="s1">enumerate(grid_ref):</span>
                <span class="s0">for </span><span class="s1">c</span><span class="s0">, </span><span class="s1">subplot_refs </span><span class="s0">in </span><span class="s1">enumerate(subplot_row):</span>
                    <span class="s0">if not </span><span class="s1">subplot_refs:</span>
                        <span class="s0">continue</span>

                    <span class="s2"># collect primary keys</span>
                    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">subplot_ref </span><span class="s0">in </span><span class="s1">enumerate(subplot_refs):</span>
                        <span class="s0">for </span><span class="s1">layout_key </span><span class="s0">in </span><span class="s1">subplot_ref.layout_keys:</span>
                            <span class="s0">if </span><span class="s1">layout_key.startswith(prefix):</span>
                                <span class="s1">is_secondary_y = i == </span><span class="s5">1</span>
                                <span class="s1">container_to_row_col[layout_key] = (</span>
                                    <span class="s1">r + </span><span class="s5">1</span><span class="s0">,</span>
                                    <span class="s1">c + </span><span class="s5">1</span><span class="s0">,</span>
                                    <span class="s1">is_secondary_y</span><span class="s0">,</span>
                                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">container_to_row_col = </span><span class="s0">None</span>

        <span class="s1">layout_keys_filters = [</span>
            <span class="s0">lambda </span><span class="s1">k: k.startswith(prefix) </span><span class="s0">and </span><span class="s1">self.layout[k] </span><span class="s0">is not None,</span>
            <span class="s0">lambda </span><span class="s1">k: row </span><span class="s0">is None</span>
            <span class="s0">or </span><span class="s1">container_to_row_col.get(k</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None, None</span><span class="s1">))[</span><span class="s5">0</span><span class="s1">] == row</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">k: col </span><span class="s0">is None</span>
            <span class="s0">or </span><span class="s1">container_to_row_col.get(k</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None, None</span><span class="s1">))[</span><span class="s5">1</span><span class="s1">] == col</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">k: (</span>
                <span class="s1">secondary_y </span><span class="s0">is None</span>
                <span class="s0">or </span><span class="s1">container_to_row_col.get(k</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None, None</span><span class="s1">))[</span><span class="s5">2</span><span class="s1">] == secondary_y</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">layout_keys = reduce(</span>
            <span class="s0">lambda </span><span class="s1">last</span><span class="s0">, </span><span class="s1">f: filter(f</span><span class="s0">, </span><span class="s1">last)</span><span class="s0">,</span>
            <span class="s1">layout_keys_filters</span><span class="s0">,</span>
            <span class="s2"># Natural sort keys so that xaxis20 is after xaxis3</span>
            <span class="s1">_natural_sort_strings(list(self.layout))</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">layout_objs = [self.layout[k] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">layout_keys]</span>
        <span class="s0">return </span><span class="s1">_generator(self._filter_by_selector(layout_objs</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">selector))</span>

    <span class="s0">def </span><span class="s1">_select_annotations_like(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">selector=</span><span class="s0">None, </span><span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">secondary_y=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Helper to select annotation-like elements from a layout object array. 
        Compatible with layout.annotations, layout.shapes, and layout.images 
        &quot;&quot;&quot;</span>
        <span class="s1">xref_to_col = {}</span>
        <span class="s1">yref_to_row = {}</span>
        <span class="s1">yref_to_secondary_y = {}</span>
        <span class="s0">if </span><span class="s1">isinstance(row</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">or </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">or </span><span class="s1">secondary_y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
            <span class="s0">for </span><span class="s1">r</span><span class="s0">, </span><span class="s1">subplot_row </span><span class="s0">in </span><span class="s1">enumerate(grid_ref):</span>
                <span class="s0">for </span><span class="s1">c</span><span class="s0">, </span><span class="s1">subplot_refs </span><span class="s0">in </span><span class="s1">enumerate(subplot_row):</span>
                    <span class="s0">if not </span><span class="s1">subplot_refs:</span>
                        <span class="s0">continue</span>

                    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">subplot_ref </span><span class="s0">in </span><span class="s1">enumerate(subplot_refs):</span>
                        <span class="s0">if </span><span class="s1">subplot_ref.subplot_type == </span><span class="s4">&quot;xy&quot;</span><span class="s1">:</span>
                            <span class="s1">is_secondary_y = i == </span><span class="s5">1</span>
                            <span class="s1">xaxis</span><span class="s0">, </span><span class="s1">yaxis = subplot_ref.layout_keys</span>
                            <span class="s1">xref = xaxis.replace(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                            <span class="s1">yref = yaxis.replace(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                            <span class="s1">xref_to_col[xref] = c + </span><span class="s5">1</span>
                            <span class="s1">yref_to_row[yref] = r + </span><span class="s5">1</span>
                            <span class="s1">yref_to_secondary_y[yref] = is_secondary_y</span>

        <span class="s2"># filter down (select) which graph objects, by applying the filters</span>
        <span class="s2"># successively</span>
        <span class="s0">def </span><span class="s1">_filter_row(obj):</span>
            <span class="s3">&quot;&quot;&quot; Filter objects in rows by column &quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">(col </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(xref_to_col.get(obj.xref</span><span class="s0">, None</span><span class="s1">) == col)</span>

        <span class="s0">def </span><span class="s1">_filter_col(obj):</span>
            <span class="s3">&quot;&quot;&quot; Filter objects in columns by row &quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">(row </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(yref_to_row.get(obj.yref</span><span class="s0">, None</span><span class="s1">) == row)</span>

        <span class="s0">def </span><span class="s1">_filter_sec_y(obj):</span>
            <span class="s3">&quot;&quot;&quot; Filter objects on secondary y axes &quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">(secondary_y </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
                <span class="s1">yref_to_secondary_y.get(obj.yref</span><span class="s0">, None</span><span class="s1">) == secondary_y</span>
            <span class="s1">)</span>

        <span class="s1">funcs = [_filter_row</span><span class="s0">, </span><span class="s1">_filter_col</span><span class="s0">, </span><span class="s1">_filter_sec_y]</span>

        <span class="s0">return </span><span class="s1">_generator(self._filter_by_selector(self.layout[prop]</span><span class="s0">, </span><span class="s1">funcs</span><span class="s0">, </span><span class="s1">selector))</span>

    <span class="s0">def </span><span class="s1">_add_annotation_like(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">prop_singular</span><span class="s0">,</span>
        <span class="s1">prop_plural</span><span class="s0">,</span>
        <span class="s1">new_obj</span><span class="s0">,</span>
        <span class="s1">row=</span><span class="s0">None,</span>
        <span class="s1">col=</span><span class="s0">None,</span>
        <span class="s1">secondary_y=</span><span class="s0">None,</span>
        <span class="s1">exclude_empty_subplots=</span><span class="s0">False,</span>
    <span class="s1">):</span>
        <span class="s2"># Make sure we have both row and col or neither</span>
        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None and </span><span class="s1">col </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Received row parameter but not col.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;row and col must be specified together&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">col </span><span class="s0">is not None and </span><span class="s1">row </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Received col parameter but not row.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;row and col must be specified together&quot;</span>
            <span class="s1">)</span>

        <span class="s2"># Address multiple subplots</span>
        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None and </span><span class="s1">_is_select_subplot_coordinates_arg(row</span><span class="s0">, </span><span class="s1">col):</span>
            <span class="s2"># TODO product argument could be added</span>
            <span class="s1">rows_cols = self._select_subplot_coordinates(row</span><span class="s0">, </span><span class="s1">col)</span>
            <span class="s0">for </span><span class="s1">r</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">rows_cols:</span>
                <span class="s1">self._add_annotation_like(</span>
                    <span class="s1">prop_singular</span><span class="s0">,</span>
                    <span class="s1">prop_plural</span><span class="s0">,</span>
                    <span class="s1">new_obj</span><span class="s0">,</span>
                    <span class="s1">row=r</span><span class="s0">,</span>
                    <span class="s1">col=c</span><span class="s0">,</span>
                    <span class="s1">secondary_y=secondary_y</span><span class="s0">,</span>
                    <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s2"># Get grid_ref if specific row or column requested</span>
        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
            <span class="s0">if </span><span class="s1">row &gt; len(grid_ref):</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">&quot;row index %d out-of-bounds, row index must be between 1 and %d, inclusive.&quot;</span>
                    <span class="s1">% (row</span><span class="s0">, </span><span class="s1">len(grid_ref))</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">col &gt; len(grid_ref[row - </span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">&quot;column index %d out-of-bounds, &quot;</span>
                    <span class="s4">&quot;column index must be between 1 and %d, inclusive.&quot;</span>
                    <span class="s1">% (row</span><span class="s0">, </span><span class="s1">len(grid_ref[row - </span><span class="s5">1</span><span class="s1">]))</span>
                <span class="s1">)</span>
            <span class="s1">refs = grid_ref[row - </span><span class="s5">1</span><span class="s1">][col - </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">refs:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;No subplot found at position ({r}, {c})&quot;</span><span class="s1">.format(r=row</span><span class="s0">, </span><span class="s1">c=col)</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">refs[</span><span class="s5">0</span><span class="s1">].subplot_type != </span><span class="s4">&quot;xy&quot;</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;&quot;&quot; 
Cannot add {prop_singular} to subplot at position ({r}, {c}) because subplot 
is of type {subplot_type}.&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">prop_singular=prop_singular</span><span class="s0">,</span>
                        <span class="s1">r=row</span><span class="s0">,</span>
                        <span class="s1">c=col</span><span class="s0">,</span>
                        <span class="s1">subplot_type=refs[</span><span class="s5">0</span><span class="s1">].subplot_type</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(refs) == </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">secondary_y:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;&quot;&quot; 
Cannot add {prop_singular} to secondary y-axis of subplot at position ({r}, {c}) 
because subplot does not have a secondary y-axis&quot;&quot;&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">secondary_y:</span>
                <span class="s1">xaxis</span><span class="s0">, </span><span class="s1">yaxis = refs[</span><span class="s5">1</span><span class="s1">].layout_keys</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">xaxis</span><span class="s0">, </span><span class="s1">yaxis = refs[</span><span class="s5">0</span><span class="s1">].layout_keys</span>
            <span class="s1">xref</span><span class="s0">, </span><span class="s1">yref = xaxis.replace(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">yaxis.replace(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s2"># if exclude_empty_subplots is True, check to see if subplot is</span>
            <span class="s2"># empty and return if it is</span>
            <span class="s0">if </span><span class="s1">exclude_empty_subplots </span><span class="s0">and </span><span class="s1">(</span>
                <span class="s0">not </span><span class="s1">self._subplot_not_empty(</span>
                    <span class="s1">xref</span><span class="s0">, </span><span class="s1">yref</span><span class="s0">, </span><span class="s1">selector=bool(exclude_empty_subplots)</span>
                <span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s0">return </span><span class="s1">self</span>
            <span class="s2"># in case the user specified they wanted an axis to refer to the</span>
            <span class="s2"># domain of that axis and not the data, append ' domain' to the</span>
            <span class="s2"># computed axis accordingly</span>
            <span class="s0">def </span><span class="s1">_add_domain(ax_letter</span><span class="s0">, </span><span class="s1">new_axref):</span>
                <span class="s1">axref = ax_letter + </span><span class="s4">&quot;ref&quot;</span>
                <span class="s0">if </span><span class="s1">axref </span><span class="s0">in </span><span class="s1">new_obj._props.keys() </span><span class="s0">and </span><span class="s4">&quot;domain&quot; </span><span class="s0">in </span><span class="s1">new_obj[axref]:</span>
                    <span class="s1">new_axref += </span><span class="s4">&quot; domain&quot;</span>
                <span class="s0">return </span><span class="s1">new_axref</span>

            <span class="s1">xref</span><span class="s0">, </span><span class="s1">yref = map(</span><span class="s0">lambda </span><span class="s1">t: _add_domain(*t)</span><span class="s0">, </span><span class="s1">zip([</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s4">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[xref</span><span class="s0">, </span><span class="s1">yref]))</span>
            <span class="s1">new_obj.update(xref=xref</span><span class="s0">, </span><span class="s1">yref=yref)</span>

        <span class="s1">self.layout[prop_plural] += (new_obj</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s2"># Restyle</span>
    <span class="s2"># -------</span>
    <span class="s0">def </span><span class="s1">plotly_restyle(self</span><span class="s0">, </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">trace_indexes=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a Plotly restyle operation on the figure's traces 
 
        Parameters 
        ---------- 
        restyle_data : dict 
            Dict of trace style updates. 
 
            Keys are strings that specify the properties to be updated. 
            Nested properties are expressed by joining successive keys on 
            '.' characters (e.g. 'marker.color'). 
 
            Values may be scalars or lists. When values are scalars, 
            that scalar value is applied to all traces specified by the 
            `trace_indexes` parameter.  When values are lists, 
            the restyle operation will cycle through the elements 
            of the list as it cycles through the traces specified by the 
            `trace_indexes` parameter. 
 
            Caution: To use plotly_restyle to update a list property (e.g. 
            the `x` property of the scatter trace), the property value 
            should be a scalar list containing the list to update with. For 
            example, the following command would be used to update the 'x' 
            property of the first trace to the list [1, 2, 3] 
 
            &gt;&gt;&gt; import plotly.graph_objects as go 
            &gt;&gt;&gt; fig = go.Figure(go.Scatter(x=[2, 4, 6])) 
            &gt;&gt;&gt; fig.plotly_restyle({'x': [[1, 2, 3]]}, 0) 
 
        trace_indexes : int or list of int 
            Trace index, or list of trace indexes, that the restyle operation 
            applies to. Defaults to all trace indexes. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Normalize trace indexes</span>
        <span class="s2"># -----------------------</span>
        <span class="s1">trace_indexes = self._normalize_trace_indexes(trace_indexes)</span>

        <span class="s2"># Handle source_view_id</span>
        <span class="s2"># ---------------------</span>
        <span class="s2"># If not None, the source_view_id is the UID of the frontend</span>
        <span class="s2"># Plotly.js view that initially triggered this restyle operation</span>
        <span class="s2"># (e.g. the user clicked on the legend to hide a trace). We pass</span>
        <span class="s2"># this UID along so that the frontend views can determine whether</span>
        <span class="s2"># they need to apply the restyle operation on themselves.</span>
        <span class="s1">source_view_id = kwargs.get(</span><span class="s4">&quot;source_view_id&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s2"># Perform restyle on trace dicts</span>
        <span class="s2"># ------------------------------</span>
        <span class="s1">restyle_changes = self._perform_plotly_restyle(restyle_data</span><span class="s0">, </span><span class="s1">trace_indexes)</span>
        <span class="s0">if </span><span class="s1">restyle_changes:</span>
            <span class="s2"># The restyle operation resulted in a change to some trace</span>
            <span class="s2"># properties, so we dispatch change callbacks and send the</span>
            <span class="s2"># restyle message to the frontend (if any)</span>
            <span class="s1">msg_kwargs = (</span>
                <span class="s1">{</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">: source_view_id} </span><span class="s0">if </span><span class="s1">source_view_id </span><span class="s0">is not None else </span><span class="s1">{}</span>
            <span class="s1">)</span>

            <span class="s1">self._send_restyle_msg(</span>
                <span class="s1">restyle_changes</span><span class="s0">, </span><span class="s1">trace_indexes=trace_indexes</span><span class="s0">, </span><span class="s1">**msg_kwargs</span>
            <span class="s1">)</span>

            <span class="s1">self._dispatch_trace_change_callbacks(restyle_changes</span><span class="s0">, </span><span class="s1">trace_indexes)</span>

    <span class="s0">def </span><span class="s1">_perform_plotly_restyle(self</span><span class="s0">, </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">trace_indexes):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a restyle operation on the figure's traces data and return 
        the changes that were applied 
 
        Parameters 
        ---------- 
        restyle_data : dict[str, any] 
            See docstring for plotly_restyle 
        trace_indexes : list[int] 
            List of trace indexes that restyle operation applies to 
        Returns 
        ------- 
        restyle_changes: dict[str, any] 
            Subset of restyle_data including only the keys / values that 
            resulted in a change to the figure's traces data 
        &quot;&quot;&quot;</span>
        <span class="s2"># Initialize restyle changes</span>
        <span class="s2"># --------------------------</span>
        <span class="s2"># This will be a subset of the restyle_data including only the</span>
        <span class="s2"># keys / values that are changed in the figure's trace data</span>
        <span class="s1">restyle_changes = {}</span>

        <span class="s2"># Process each key</span>
        <span class="s2"># ----------------</span>
        <span class="s0">for </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">restyle_data.items():</span>

            <span class="s2"># Track whether any of the new values are cause a change in</span>
            <span class="s2"># self._data</span>
            <span class="s1">any_vals_changed = </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">trace_ind </span><span class="s0">in </span><span class="s1">enumerate(trace_indexes):</span>
                <span class="s0">if </span><span class="s1">trace_ind &gt;= len(self._data):</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;Trace index {trace_ind} out of range&quot;</span><span class="s1">.format(</span>
                            <span class="s1">trace_ind=trace_ind</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s2"># Get new value for this particular trace</span>
                <span class="s1">trace_v = v[i % len(v)] </span><span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">else </span><span class="s1">v</span>

                <span class="s0">if </span><span class="s1">trace_v </span><span class="s0">is not </span><span class="s1">Undefined:</span>

                    <span class="s2"># Get trace being updated</span>
                    <span class="s1">trace_obj = self.data[trace_ind]</span>

                    <span class="s2"># Validate key_path_str</span>
                    <span class="s0">if not </span><span class="s1">BaseFigure._is_key_path_compatible(key_path_str</span><span class="s0">, </span><span class="s1">trace_obj):</span>

                        <span class="s1">trace_class = trace_obj.__class__.__name__</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s4">&quot;&quot;&quot; 
Invalid property path '{key_path_str}' for trace class {trace_class} 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
                                <span class="s1">key_path_str=key_path_str</span><span class="s0">, </span><span class="s1">trace_class=trace_class</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>

                    <span class="s2"># Apply set operation for this trace and thist value</span>
                    <span class="s1">val_changed = BaseFigure._set_in(</span>
                        <span class="s1">self._data[trace_ind]</span><span class="s0">, </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">trace_v</span>
                    <span class="s1">)</span>

                    <span class="s2"># Update any_vals_changed status</span>
                    <span class="s1">any_vals_changed = any_vals_changed </span><span class="s0">or </span><span class="s1">val_changed</span>

            <span class="s0">if </span><span class="s1">any_vals_changed:</span>
                <span class="s1">restyle_changes[key_path_str] = v</span>

        <span class="s0">return </span><span class="s1">restyle_changes</span>

    <span class="s0">def </span><span class="s1">_restyle_child(self</span><span class="s0">, </span><span class="s1">child</span><span class="s0">, </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process restyle operation on a child trace object 
 
        Note: This method name/signature must match the one in 
        BasePlotlyType. BasePlotlyType objects call their parent's 
        _restyle_child method without knowing whether their parent is a 
        BasePlotlyType or a BaseFigure. 
 
        Parameters 
        ---------- 
        child : BaseTraceType 
            Child being restyled 
        key_path_str : str 
            A key path string (e.g. 'foo.bar[0]') 
        val 
            Restyle value 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Compute trace index</span>
        <span class="s2"># -------------------</span>
        <span class="s1">trace_index = child._trace_ind</span>

        <span class="s2"># Not in batch mode</span>
        <span class="s2"># -----------------</span>
        <span class="s2"># Dispatch change callbacks and send restyle message</span>
        <span class="s0">if not </span><span class="s1">self._in_batch_mode:</span>
            <span class="s1">send_val = [val]</span>
            <span class="s1">restyle = {key_path_str: send_val}</span>
            <span class="s1">self._send_restyle_msg(restyle</span><span class="s0">, </span><span class="s1">trace_indexes=trace_index)</span>
            <span class="s1">self._dispatch_trace_change_callbacks(restyle</span><span class="s0">, </span><span class="s1">[trace_index])</span>

        <span class="s2"># In batch mode</span>
        <span class="s2"># -------------</span>
        <span class="s2"># Add key_path_str/val to saved batch edits</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">trace_index </span><span class="s0">not in </span><span class="s1">self._batch_trace_edits:</span>
                <span class="s1">self._batch_trace_edits[trace_index] = OrderedDict()</span>
            <span class="s1">self._batch_trace_edits[trace_index][key_path_str] = val</span>

    <span class="s0">def </span><span class="s1">_normalize_trace_indexes(self</span><span class="s0">, </span><span class="s1">trace_indexes):</span>
        <span class="s3">&quot;&quot;&quot; 
        Input trace index specification and return list of the specified trace 
        indexes 
 
        Parameters 
        ---------- 
        trace_indexes : None or int or list[int] 
 
        Returns 
        ------- 
        list[int] 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">trace_indexes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">trace_indexes = list(range(len(self.data)))</span>
        <span class="s0">if not </span><span class="s1">isinstance(trace_indexes</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">trace_indexes = [trace_indexes]</span>
        <span class="s0">return </span><span class="s1">list(trace_indexes)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_str_to_dict_path(key_path_str):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a key path string into a tuple of key path elements. 
 
        Parameters 
        ---------- 
        key_path_str : str 
            Key path string, where nested keys are joined on '.' characters 
            and array indexes are specified using brackets 
            (e.g. 'foo.bar[1]') 
        Returns 
        ------- 
        tuple[str | int] 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(key_path_str</span><span class="s0">, </span><span class="s1">string_types)</span>
            <span class="s0">and </span><span class="s4">&quot;.&quot; </span><span class="s0">not in </span><span class="s1">key_path_str</span>
            <span class="s0">and </span><span class="s4">&quot;[&quot; </span><span class="s0">not in </span><span class="s1">key_path_str</span>
            <span class="s0">and </span><span class="s4">&quot;_&quot; </span><span class="s0">not in </span><span class="s1">key_path_str</span>
        <span class="s1">):</span>
            <span class="s2"># Fast path for common case that avoids regular expressions</span>
            <span class="s0">return </span><span class="s1">(key_path_str</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(key_path_str</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s2"># Nothing to do</span>
            <span class="s0">return </span><span class="s1">key_path_str</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ret = _str_to_dict_path_full(key_path_str)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">ret</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_set_in(d</span><span class="s0">, </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">v):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set a value in a nested dict using a key path string 
        (e.g. 'foo.bar[0]') 
 
        Parameters 
        ---------- 
        d : dict 
            Input dict to set property in 
        key_path_str : str 
            Key path string, where nested keys are joined on '.' characters 
            and array indexes are specified using brackets 
            (e.g. 'foo.bar[1]') 
        v 
            New value 
        Returns 
        ------- 
        bool 
            True if set resulted in modification of dict (i.e. v was not 
            already present at the specified location), False otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Validate inputs</span>
        <span class="s2"># ---------------</span>
        <span class="s0">assert </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">dict)</span>

        <span class="s2"># Compute key path</span>
        <span class="s2"># ----------------</span>
        <span class="s2"># Convert the key_path_str into a tuple of key paths</span>
        <span class="s2"># e.g. 'foo.bar[0]' -&gt; ('foo', 'bar', 0)</span>
        <span class="s1">key_path = BaseFigure._str_to_dict_path(key_path_str)</span>

        <span class="s2"># Initialize val_parent</span>
        <span class="s2"># ---------------------</span>
        <span class="s2"># This variable will be assigned to the parent of the next key path</span>
        <span class="s2"># element currently being processed</span>
        <span class="s1">val_parent = d</span>

        <span class="s2"># Initialize parent dict or list of value to be assigned</span>
        <span class="s2"># -----------------------------------------------------</span>
        <span class="s0">for </span><span class="s1">kp</span><span class="s0">, </span><span class="s1">key_path_el </span><span class="s0">in </span><span class="s1">enumerate(key_path[:-</span><span class="s5">1</span><span class="s1">]):</span>

            <span class="s2"># Extend val_parent list if needed</span>
            <span class="s0">if </span><span class="s1">isinstance(val_parent</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">isinstance(key_path_el</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s0">while </span><span class="s1">len(val_parent) &lt;= key_path_el:</span>
                    <span class="s1">val_parent.append(</span><span class="s0">None</span><span class="s1">)</span>

            <span class="s0">elif </span><span class="s1">isinstance(val_parent</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">and </span><span class="s1">key_path_el </span><span class="s0">not in </span><span class="s1">val_parent:</span>
                <span class="s0">if </span><span class="s1">isinstance(key_path[kp + </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int):</span>
                    <span class="s1">val_parent[key_path_el] = []</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">val_parent[key_path_el] = {}</span>

            <span class="s1">val_parent = val_parent[key_path_el]</span>

        <span class="s2"># Assign value to to final parent dict or list</span>
        <span class="s2"># --------------------------------------------</span>
        <span class="s2"># ### Get reference to final key path element ###</span>
        <span class="s1">last_key = key_path[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2"># ### Track whether assignment alters parent ###</span>
        <span class="s1">val_changed = </span><span class="s0">False</span>

        <span class="s2"># v is Undefined</span>
        <span class="s2"># --------------</span>
        <span class="s2"># Don't alter val_parent</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is </span><span class="s1">Undefined:</span>
            <span class="s0">pass</span>

        <span class="s2"># v is None</span>
        <span class="s2"># ---------</span>
        <span class="s2"># Check whether we can remove key from parent</span>
        <span class="s0">elif </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(val_parent</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">if </span><span class="s1">last_key </span><span class="s0">in </span><span class="s1">val_parent:</span>
                    <span class="s2"># Parent is a dict and has last_key as a current key so</span>
                    <span class="s2"># we can pop the key, which alters parent</span>
                    <span class="s1">val_parent.pop(last_key)</span>
                    <span class="s1">val_changed = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">isinstance(val_parent</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s0">if </span><span class="s1">isinstance(last_key</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">and </span><span class="s5">0 </span><span class="s1">&lt;= last_key &lt; len(val_parent):</span>
                    <span class="s2"># Parent is a list and last_key is a valid index so we</span>
                    <span class="s2"># can set the element value to None</span>
                    <span class="s1">val_parent[last_key] = </span><span class="s0">None</span>
                    <span class="s1">val_changed = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Unsupported parent type (numpy array for example)</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;&quot;&quot; 
    Cannot remove element of type {typ} at location {raw_key}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">typ=type(val_parent)</span><span class="s0">, </span><span class="s1">raw_key=key_path_str</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2"># v is a valid value</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># Check whether parent should be updated</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(val_parent</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">if </span><span class="s1">last_key </span><span class="s0">not in </span><span class="s1">val_parent </span><span class="s0">or not </span><span class="s1">BasePlotlyType._vals_equal(</span>
                    <span class="s1">val_parent[last_key]</span><span class="s0">, </span><span class="s1">v</span>
                <span class="s1">):</span>
                    <span class="s2"># Parent is a dict and does not already contain the</span>
                    <span class="s2"># value v at key last_key</span>
                    <span class="s1">val_parent[last_key] = v</span>
                    <span class="s1">val_changed = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">isinstance(val_parent</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s0">if </span><span class="s1">isinstance(last_key</span><span class="s0">, </span><span class="s1">int):</span>
                    <span class="s2"># Extend list with Nones if needed so that last_key is</span>
                    <span class="s2"># in bounds</span>
                    <span class="s0">while </span><span class="s1">len(val_parent) &lt;= last_key:</span>
                        <span class="s1">val_parent.append(</span><span class="s0">None</span><span class="s1">)</span>

                    <span class="s0">if not </span><span class="s1">BasePlotlyType._vals_equal(val_parent[last_key]</span><span class="s0">, </span><span class="s1">v):</span>
                        <span class="s2"># Parent is a list and does not already contain the</span>
                        <span class="s2"># value v at index last_key</span>
                        <span class="s1">val_parent[last_key] = v</span>
                        <span class="s1">val_changed = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Unsupported parent type (numpy array for example)</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;&quot;&quot; 
    Cannot set element of type {typ} at location {raw_key}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">typ=type(val_parent)</span><span class="s0">, </span><span class="s1">raw_key=key_path_str</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">val_changed</span>

    <span class="s2"># Add traces</span>
    <span class="s2"># ----------</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_raise_invalid_rows_cols(name</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">invalid):</span>
        <span class="s1">rows_err_msg = </span><span class="s4">&quot;&quot;&quot; 
        If specified, the {name} parameter must be a list or tuple of integers 
        of length {n} (The number of traces being added) 
 
        Received: {invalid} 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">name=name</span><span class="s0">, </span><span class="s1">n=n</span><span class="s0">, </span><span class="s1">invalid=invalid</span>
        <span class="s1">)</span>

        <span class="s0">raise </span><span class="s1">ValueError(rows_err_msg)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_validate_rows_cols(name</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">vals):</span>
        <span class="s0">if </span><span class="s1">vals </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">isinstance(vals</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s0">if </span><span class="s1">len(vals) != n:</span>
                <span class="s1">BaseFigure._raise_invalid_rows_cols(name=name</span><span class="s0">, </span><span class="s1">n=n</span><span class="s0">, </span><span class="s1">invalid=vals)</span>

            <span class="s1">int_type = _get_int_type()</span>

            <span class="s0">if </span><span class="s1">[r </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">vals </span><span class="s0">if not </span><span class="s1">isinstance(r</span><span class="s0">, </span><span class="s1">int_type)]:</span>
                <span class="s1">BaseFigure._raise_invalid_rows_cols(name=name</span><span class="s0">, </span><span class="s1">n=n</span><span class="s0">, </span><span class="s1">invalid=vals)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">BaseFigure._raise_invalid_rows_cols(name=name</span><span class="s0">, </span><span class="s1">n=n</span><span class="s0">, </span><span class="s1">invalid=vals)</span>

    <span class="s0">def </span><span class="s1">add_trace(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">secondary_y=</span><span class="s0">None, </span><span class="s1">exclude_empty_subplots=</span><span class="s0">False</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add a trace to the figure 
 
        Parameters 
        ---------- 
        trace : BaseTraceType or dict 
            Either: 
              - An instances of a trace classe from the plotly.graph_objs 
                package (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar) 
              - or a dicts where: 
 
                  - The 'type' property specifies the trace type (e.g. 
                    'scatter', 'bar', 'area', etc.). If the dict has no 'type' 
                    property then 'scatter' is assumed. 
                  - All remaining properties are passed to the constructor 
                    of the specified trace type. 
 
        row : 'all', int or None (default) 
            Subplot row index (starting from 1) for the trace to be 
            added. Only valid if figure was created using 
            `plotly.tools.make_subplots`. 
            If 'all', addresses all rows in the specified column(s). 
        col : 'all', int or None (default) 
            Subplot col index (starting from 1) for the trace to be 
            added. Only valid if figure was created using 
            `plotly.tools.make_subplots`. 
            If 'all', addresses all columns in the specified row(s). 
        secondary_y: boolean or None (default None) 
            If True, associate this trace with the secondary y-axis of the 
            subplot at the specified row and col. Only valid if all of the 
            following conditions are satisfied: 
              * The figure was created using `plotly.subplots.make_subplots`. 
              * The row and col arguments are not None 
              * The subplot at the specified row and col has type xy 
                (which is the default) and secondary_y True.  These 
                properties are specified in the specs argument to 
                make_subplots. See the make_subplots docstring for more info. 
              * The trace argument is a 2D cartesian trace 
                (scatter, bar, etc.) 
        exclude_empty_subplots: boolean 
            If True, the trace will not be added to subplots that don't already 
            have traces. 
        Returns 
        ------- 
        BaseFigure 
            The Figure that add_trace was called on 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; from plotly import subplots 
        &gt;&gt;&gt; import plotly.graph_objs as go 
 
        Add two Scatter traces to a figure 
 
        &gt;&gt;&gt; fig = go.Figure() 
        &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS 
        Figure(...) 
        &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS 
        Figure(...) 
 
 
        Add two Scatter traces to vertically stacked subplots 
 
        &gt;&gt;&gt; fig = subplots.make_subplots(rows=2) 
        &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) # doctest: +ELLIPSIS 
        Figure(...) 
        &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) # doctest: +ELLIPSIS 
        Figure(...) 
        &quot;&quot;&quot;</span>
        <span class="s2"># Make sure we have both row and col or neither</span>
        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None and </span><span class="s1">col </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Received row parameter but not col.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;row and col must be specified together&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">col </span><span class="s0">is not None and </span><span class="s1">row </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Received col parameter but not row.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;row and col must be specified together&quot;</span>
            <span class="s1">)</span>

        <span class="s2"># Address multiple subplots</span>
        <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None and </span><span class="s1">_is_select_subplot_coordinates_arg(row</span><span class="s0">, </span><span class="s1">col):</span>
            <span class="s2"># TODO add product argument</span>
            <span class="s1">rows_cols = self._select_subplot_coordinates(row</span><span class="s0">, </span><span class="s1">col)</span>
            <span class="s0">for </span><span class="s1">r</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">rows_cols:</span>
                <span class="s1">self.add_trace(</span>
                    <span class="s1">trace</span><span class="s0">,</span>
                    <span class="s1">row=r</span><span class="s0">,</span>
                    <span class="s1">col=c</span><span class="s0">,</span>
                    <span class="s1">secondary_y=secondary_y</span><span class="s0">,</span>
                    <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">return </span><span class="s1">self.add_traces(</span>
            <span class="s1">data=[trace]</span><span class="s0">,</span>
            <span class="s1">rows=[row] </span><span class="s0">if </span><span class="s1">row </span><span class="s0">is not None else None,</span>
            <span class="s1">cols=[col] </span><span class="s0">if </span><span class="s1">col </span><span class="s0">is not None else None,</span>
            <span class="s1">secondary_ys=[secondary_y] </span><span class="s0">if </span><span class="s1">secondary_y </span><span class="s0">is not None else None,</span>
            <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_traces(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">data</span><span class="s0">,</span>
        <span class="s1">rows=</span><span class="s0">None,</span>
        <span class="s1">cols=</span><span class="s0">None,</span>
        <span class="s1">secondary_ys=</span><span class="s0">None,</span>
        <span class="s1">exclude_empty_subplots=</span><span class="s0">False,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add traces to the figure 
 
        Parameters 
        ---------- 
        data : list[BaseTraceType or dict] 
            A list of trace specifications to be added. 
            Trace specifications may be either: 
 
              - Instances of trace classes from the plotly.graph_objs 
                package (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar) 
              - Dicts where: 
 
                  - The 'type' property specifies the trace type (e.g. 
                    'scatter', 'bar', 'area', etc.). If the dict has no 'type' 
                    property then 'scatter' is assumed. 
                  - All remaining properties are passed to the constructor 
                    of the specified trace type. 
 
        rows : None, list[int], or int (default None) 
            List of subplot row indexes (starting from 1) for the traces to be 
            added. Only valid if figure was created using 
            `plotly.tools.make_subplots` 
            If a single integer is passed, all traces will be added to row number 
 
        cols : None or list[int] (default None) 
            List of subplot column indexes (starting from 1) for the traces 
            to be added. Only valid if figure was created using 
            `plotly.tools.make_subplots` 
            If a single integer is passed, all traces will be added to column number 
 
 
        secondary_ys: None or list[boolean] (default None) 
            List of secondary_y booleans for traces to be added. See the 
            docstring for `add_trace` for more info. 
 
        exclude_empty_subplots: boolean 
            If True, the trace will not be added to subplots that don't already 
            have traces. 
 
        Returns 
        ------- 
        BaseFigure 
            The Figure that add_traces was called on 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; from plotly import subplots 
        &gt;&gt;&gt; import plotly.graph_objs as go 
 
        Add two Scatter traces to a figure 
 
        &gt;&gt;&gt; fig = go.Figure() 
        &gt;&gt;&gt; fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]), 
        ...                 go.Scatter(x=[1,2,3], y=[2,1,2])]) # doctest: +ELLIPSIS 
        Figure(...) 
 
        Add two Scatter traces to vertically stacked subplots 
 
        &gt;&gt;&gt; fig = subplots.make_subplots(rows=2) 
        &gt;&gt;&gt; fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]), 
        ...                 go.Scatter(x=[1,2,3], y=[2,1,2])], 
        ...                 rows=[1, 2], cols=[1, 1]) # doctest: +ELLIPSIS 
        Figure(...) 
        &quot;&quot;&quot;</span>

        <span class="s2"># Validate traces</span>
        <span class="s1">data = self._data_validator.validate_coerce(data)</span>

        <span class="s2"># Set trace indexes</span>
        <span class="s0">for </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">new_trace </span><span class="s0">in </span><span class="s1">enumerate(data):</span>
            <span class="s1">new_trace._trace_ind = ind + len(self.data)</span>

        <span class="s2"># Allow integers as inputs to subplots</span>
        <span class="s1">int_type = _get_int_type()</span>

        <span class="s0">if </span><span class="s1">isinstance(rows</span><span class="s0">, </span><span class="s1">int_type):</span>
            <span class="s1">rows = [rows] * len(data)</span>

        <span class="s0">if </span><span class="s1">isinstance(cols</span><span class="s0">, </span><span class="s1">int_type):</span>
            <span class="s1">cols = [cols] * len(data)</span>

        <span class="s2"># Validate rows / cols</span>
        <span class="s1">n = len(data)</span>
        <span class="s1">BaseFigure._validate_rows_cols(</span><span class="s4">&quot;rows&quot;</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">rows)</span>
        <span class="s1">BaseFigure._validate_rows_cols(</span><span class="s4">&quot;cols&quot;</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">cols)</span>

        <span class="s2"># Make sure we have both rows and cols or neither</span>
        <span class="s0">if </span><span class="s1">rows </span><span class="s0">is not None and </span><span class="s1">cols </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Received rows parameter but not cols.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;rows and cols must be specified together&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">cols </span><span class="s0">is not None and </span><span class="s1">rows </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Received cols parameter but not rows.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;rows and cols must be specified together&quot;</span>
            <span class="s1">)</span>

        <span class="s2"># Process secondary_ys defaults</span>
        <span class="s0">if </span><span class="s1">secondary_ys </span><span class="s0">is not None and </span><span class="s1">rows </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Default rows/cols to 1s if secondary_ys specified but not rows</span>
            <span class="s2"># or cols</span>
            <span class="s1">rows = [</span><span class="s5">1</span><span class="s1">] * len(secondary_ys)</span>
            <span class="s1">cols = rows</span>
        <span class="s0">elif </span><span class="s1">secondary_ys </span><span class="s0">is None and </span><span class="s1">rows </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Default secondary_ys to Nones if secondary_ys is not specified</span>
            <span class="s2"># but not rows and cols are specified</span>
            <span class="s1">secondary_ys = [</span><span class="s0">None</span><span class="s1">] * len(rows)</span>

        <span class="s2"># Apply rows / cols</span>
        <span class="s0">if </span><span class="s1">rows </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">secondary_y </span><span class="s0">in </span><span class="s1">zip(data</span><span class="s0">, </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols</span><span class="s0">, </span><span class="s1">secondary_ys):</span>
                <span class="s1">self._set_trace_grid_position(trace</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">secondary_y)</span>

        <span class="s0">if </span><span class="s1">exclude_empty_subplots:</span>
            <span class="s1">data = list(</span>
                <span class="s1">filter(</span>
                    <span class="s0">lambda </span><span class="s1">trace: self._subplot_not_empty(</span>
                        <span class="s1">trace[</span><span class="s4">&quot;xaxis&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">trace[</span><span class="s4">&quot;yaxis&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bool(exclude_empty_subplots)</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">data</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s2"># Make deep copy of trace data (Optimize later if needed)</span>
        <span class="s1">new_traces_data = [deepcopy(trace._props) </span><span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">data]</span>

        <span class="s2"># Update trace parent</span>
        <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">data:</span>
            <span class="s1">trace._parent = self</span>
            <span class="s1">trace._orphan_props.clear()</span>

        <span class="s2"># Update python side</span>
        <span class="s2">#  Use extend instead of assignment so we don't trigger serialization</span>
        <span class="s1">self._data.extend(new_traces_data)</span>
        <span class="s1">self._data_defaults = self._data_defaults + [{} </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">data]</span>
        <span class="s1">self._data_objs = self._data_objs + data</span>

        <span class="s2"># Update messages</span>
        <span class="s1">self._send_addTraces_msg(new_traces_data)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s2"># Subplots</span>
    <span class="s2"># --------</span>
    <span class="s0">def </span><span class="s1">print_grid(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Print a visual layout of the figure's axes arrangement. 
        This is only valid for figures that are created 
        with plotly.tools.make_subplots. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._grid_str </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span>
                <span class="s4">&quot;Use plotly.tools.make_subplots &quot; &quot;to create a subplot grid.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">print(self._grid_str)</span>

    <span class="s0">def </span><span class="s1">append_trace(self</span><span class="s0">, </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add a trace to the figure bound to axes at the specified row, 
        col index. 
 
        A row, col index grid is generated for figures created with 
        plotly.tools.make_subplots, and can be viewed with the `print_grid` 
        method 
 
        Parameters 
        ---------- 
        trace 
            The data trace to be bound 
        row: int 
            Subplot row index (see Figure.print_grid) 
        col: int 
            Subplot column index (see Figure.print_grid) 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; from plotly import tools 
        &gt;&gt;&gt; import plotly.graph_objs as go 
        &gt;&gt;&gt; # stack two subplots vertically 
        &gt;&gt;&gt; fig = tools.make_subplots(rows=2) 
 
        This is the format of your plot grid: 
        [ (1,1) x1,y1 ] 
        [ (2,1) x2,y2 ] 
 
        &gt;&gt;&gt; fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) 
        &gt;&gt;&gt; fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s4">The append_trace method is deprecated and will be removed in a future version. 
Please use the add_trace method with the row and col parameters. 
&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.add_trace(trace=trace</span><span class="s0">, </span><span class="s1">row=row</span><span class="s0">, </span><span class="s1">col=col)</span>

    <span class="s0">def </span><span class="s1">_set_trace_grid_position(self</span><span class="s0">, </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">secondary_y=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">plotly.subplots </span><span class="s0">import </span><span class="s1">_set_trace_grid_reference</span>

        <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
        <span class="s0">return </span><span class="s1">_set_trace_grid_reference(</span>
            <span class="s1">trace</span><span class="s0">, </span><span class="s1">self.layout</span><span class="s0">, </span><span class="s1">grid_ref</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">secondary_y</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_validate_get_grid_ref(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">grid_ref = self._grid_ref</span>
            <span class="s0">if </span><span class="s1">grid_ref </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;_grid_ref&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span>
                <span class="s4">&quot;In order to reference traces by row and column, &quot;</span>
                <span class="s4">&quot;you must first use &quot;</span>
                <span class="s4">&quot;plotly.tools.make_subplots &quot;</span>
                <span class="s4">&quot;to create the figure with a subplot grid.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">grid_ref</span>

    <span class="s0">def </span><span class="s1">_get_subplot_rows_columns(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a pair of lists, the first containing all the row indices and 
        the second all the column indices. 
        &quot;&quot;&quot;</span>
        <span class="s2"># currently, this just iterates over all the rows and columns (because</span>
        <span class="s2"># self._grid_ref is currently always rectangular)</span>
        <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
        <span class="s1">nrows = len(grid_ref)</span>
        <span class="s1">ncols = len(grid_ref[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">(range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nrows + </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">ncols + </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_get_subplot_coordinates(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns an iterator over (row,col) pairs representing all the possible 
        subplot coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">itertools.product(*self._get_subplot_rows_columns())</span>

    <span class="s0">def </span><span class="s1">_select_subplot_coordinates(self</span><span class="s0">, </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols</span><span class="s0">, </span><span class="s1">product=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Allows selecting all or a subset of the subplots. 
        If any of rows or columns is 'all', product is set to True. This is 
        probably the expected behaviour, so that rows=1,cols='all' selects all 
        the columns in row 1 (otherwise it would just select the subplot in the 
        first row and first column). 
        &quot;&quot;&quot;</span>
        <span class="s1">product |= any([s == </span><span class="s4">&quot;all&quot; </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">[rows</span><span class="s0">, </span><span class="s1">cols]])</span>
        <span class="s2"># TODO: If grid_ref ever becomes non-rectangular, then t should be the</span>
        <span class="s2"># set-intersection of the result of _indexing_combinations and</span>
        <span class="s2"># _get_subplot_coordinates, because some coordinates given by</span>
        <span class="s2"># the _indexing_combinations function might be invalid.</span>
        <span class="s1">t = _indexing_combinations(</span>
            <span class="s1">[rows</span><span class="s0">, </span><span class="s1">cols]</span><span class="s0">, </span><span class="s1">list(self._get_subplot_rows_columns())</span><span class="s0">, </span><span class="s1">product=product</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">t = list(t)</span>
        <span class="s2"># remove rows and cols where the subplot is &quot;None&quot;</span>
        <span class="s1">grid_ref = self._validate_get_grid_ref()</span>
        <span class="s1">t = list(filter(</span><span class="s0">lambda </span><span class="s1">u: grid_ref[u[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">][u[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">] </span><span class="s0">is not None, </span><span class="s1">t))</span>
        <span class="s0">return </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">get_subplot(self</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">secondary_y=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return an object representing the subplot at the specified row 
        and column.  May only be used on Figures created using 
        plotly.tools.make_subplots 
 
        Parameters 
        ---------- 
        row: int 
            1-based index of subplot row 
        col: int 
            1-based index of subplot column 
        secondary_y: bool 
            If True, select the subplot that consists of the x-axis and the 
            secondary y-axis at the specified row/col. Only valid if the 
            subplot at row/col is an 2D cartesian subplot that was created 
            with a secondary y-axis.  See the docstring for the specs argument 
            to make_subplots for more info on creating a subplot with a 
            secondary y-axis. 
        Returns 
        ------- 
        subplot 
            * None: if subplot is empty 
            * plotly.graph_objs.layout.Scene: if subplot type is 'scene' 
            * plotly.graph_objs.layout.Polar: if subplot type is 'polar' 
            * plotly.graph_objs.layout.Ternary: if subplot type is 'ternary' 
            * plotly.graph_objs.layout.Mapbox: if subplot type is 'ternary' 
            * SubplotDomain namedtuple with `x` and `y` fields: 
              if subplot type is 'domain'. 
                - x: length 2 list of the subplot start and stop width 
                - y: length 2 list of the subplot start and stop height 
            * SubplotXY namedtuple with `xaxis` and `yaxis` fields: 
              if subplot type is 'xy'. 
                - xaxis: plotly.graph_objs.layout.XAxis instance for subplot 
                - yaxis: plotly.graph_objs.layout.YAxis instance for subplot 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">plotly.subplots </span><span class="s0">import </span><span class="s1">_get_grid_subplot</span>

        <span class="s0">return </span><span class="s1">_get_grid_subplot(self</span><span class="s0">, </span><span class="s1">row</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">secondary_y)</span>

    <span class="s2"># Child property operations</span>
    <span class="s2"># -------------------------</span>
    <span class="s0">def </span><span class="s1">_get_child_props(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the properties dict for a child trace or child layout 
 
        Note: this method must match the name/signature of one on 
        BasePlotlyType 
 
        Parameters 
        ---------- 
        child : BaseTraceType | BaseLayoutType 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s2"># Try to find index of child as a trace</span>
        <span class="s2"># -------------------------------------</span>
        <span class="s0">if </span><span class="s1">isinstance(child</span><span class="s0">, </span><span class="s1">BaseTraceType):</span>
            <span class="s2"># ### Child is a trace ###</span>
            <span class="s1">trace_index = child._trace_ind</span>
            <span class="s0">return </span><span class="s1">self._data[trace_index]</span>

        <span class="s2"># Child is the layout</span>
        <span class="s2"># -------------------</span>
        <span class="s0">elif </span><span class="s1">child </span><span class="s0">is </span><span class="s1">self.layout:</span>
            <span class="s0">return </span><span class="s1">self._layout</span>

        <span class="s2"># Unknown child</span>
        <span class="s2"># -------------</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized child: %s&quot; </span><span class="s1">% child)</span>

    <span class="s0">def </span><span class="s1">_get_child_prop_defaults(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the default properties dict for a child trace or child layout 
 
        Note: this method must match the name/signature of one on 
        BasePlotlyType 
 
        Parameters 
        ---------- 
        child : BaseTraceType | BaseLayoutType 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s2"># Child is a trace</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">isinstance(child</span><span class="s0">, </span><span class="s1">BaseTraceType):</span>
            <span class="s1">trace_index = child._trace_ind</span>
            <span class="s0">return </span><span class="s1">self._data_defaults[trace_index]</span>

        <span class="s2"># Child is the layout</span>
        <span class="s2"># -------------------</span>
        <span class="s0">elif </span><span class="s1">child </span><span class="s0">is </span><span class="s1">self.layout:</span>
            <span class="s0">return </span><span class="s1">self._layout_defaults</span>

        <span class="s2"># Unknown child</span>
        <span class="s2"># -------------</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized child: %s&quot; </span><span class="s1">% child)</span>

    <span class="s0">def </span><span class="s1">_init_child_props(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Initialize the properites dict for a child trace or layout 
 
        Note: this method must match the name/signature of one on 
        BasePlotlyType 
 
        Parameters 
        ---------- 
        child : BaseTraceType | BaseLayoutType 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s2"># layout and traces dict are initialize when figure is constructed</span>
        <span class="s2"># and when new traces are added to the figure</span>
        <span class="s0">pass</span>

    <span class="s2"># Layout</span>
    <span class="s2"># ------</span>
    <span class="s0">def </span><span class="s1">_initialize_layout_template(self):</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">if </span><span class="s1">self._layout_obj._props.get(</span><span class="s4">&quot;template&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">pio.templates.default </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s2"># Assume default template is already validated</span>
                <span class="s0">if </span><span class="s1">self._allow_disable_validation:</span>
                    <span class="s1">self._layout_obj._validate = </span><span class="s0">False</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">isinstance(pio.templates.default</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                        <span class="s2"># Template object. Don't want to actually import `Template`</span>
                        <span class="s2"># here for performance so we check against `BasePlotlyType`</span>
                        <span class="s1">template_object = pio.templates.default</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s2"># Name of registered template object</span>
                        <span class="s1">template_object = pio.templates[pio.templates.default]</span>
                    <span class="s1">self._layout_obj.template = template_object</span>
                <span class="s0">finally</span><span class="s1">:</span>
                    <span class="s1">self._layout_obj._validate = self._validate</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">layout(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        The `layout` property of the figure 
 
        Returns 
        ------- 
        plotly.graph_objs.Layout 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self[</span><span class="s4">&quot;layout&quot;</span><span class="s1">]</span>

    <span class="s1">@layout.setter</span>
    <span class="s0">def </span><span class="s1">layout(self</span><span class="s0">, </span><span class="s1">new_layout):</span>

        <span class="s2"># Validate new layout</span>
        <span class="s2"># -------------------</span>
        <span class="s1">new_layout = self._layout_validator.validate_coerce(new_layout)</span>
        <span class="s1">new_layout_data = deepcopy(new_layout._props)</span>

        <span class="s2"># Unparent current layout</span>
        <span class="s2"># -----------------------</span>
        <span class="s0">if </span><span class="s1">self._layout_obj:</span>
            <span class="s1">old_layout_data = deepcopy(self._layout_obj._props)</span>
            <span class="s1">self._layout_obj._orphan_props.update(old_layout_data)</span>
            <span class="s1">self._layout_obj._parent = </span><span class="s0">None</span>

        <span class="s2"># Parent new layout</span>
        <span class="s2"># -----------------</span>
        <span class="s1">self._layout = new_layout_data</span>
        <span class="s1">new_layout._parent = self</span>
        <span class="s1">new_layout._orphan_props.clear()</span>
        <span class="s1">self._layout_obj = new_layout</span>

        <span class="s2"># Initialize template object</span>
        <span class="s2"># --------------------------</span>
        <span class="s1">self._initialize_layout_template()</span>

        <span class="s2"># Notify JS side</span>
        <span class="s1">self._send_relayout_msg(new_layout_data)</span>

    <span class="s0">def </span><span class="s1">plotly_relayout(self</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a Plotly relayout operation on the figure's layout 
 
        Parameters 
        ---------- 
        relayout_data : dict 
            Dict of layout updates 
 
            dict keys are strings that specify the properties to be updated. 
            Nested properties are expressed by joining successive keys on 
            '.' characters (e.g. 'xaxis.range') 
 
            dict values are the values to use to update the layout. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Handle source_view_id</span>
        <span class="s2"># ---------------------</span>
        <span class="s2"># If not None, the source_view_id is the UID of the frontend</span>
        <span class="s2"># Plotly.js view that initially triggered this relayout operation</span>
        <span class="s2"># (e.g. the user clicked on the toolbar to change the drag mode</span>
        <span class="s2"># from zoom to pan). We pass this UID along so that the frontend</span>
        <span class="s2"># views can determine whether they need to apply the relayout</span>
        <span class="s2"># operation on themselves.</span>
        <span class="s0">if </span><span class="s4">&quot;source_view_id&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">msg_kwargs = {</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">: kwargs[</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">]}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg_kwargs = {}</span>

        <span class="s2"># Perform relayout operation on layout dict</span>
        <span class="s2"># -----------------------------------------</span>
        <span class="s1">relayout_changes = self._perform_plotly_relayout(relayout_data)</span>
        <span class="s0">if </span><span class="s1">relayout_changes:</span>
            <span class="s2"># The relayout operation resulted in a change to some layout</span>
            <span class="s2"># properties, so we dispatch change callbacks and send the</span>
            <span class="s2"># relayout message to the frontend (if any)</span>
            <span class="s1">self._send_relayout_msg(relayout_changes</span><span class="s0">, </span><span class="s1">**msg_kwargs)</span>

            <span class="s1">self._dispatch_layout_change_callbacks(relayout_changes)</span>

    <span class="s0">def </span><span class="s1">_perform_plotly_relayout(self</span><span class="s0">, </span><span class="s1">relayout_data):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a relayout operation on the figure's layout data and return 
        the changes that were applied 
 
        Parameters 
        ---------- 
        relayout_data : dict[str, any] 
            See the docstring for plotly_relayout 
        Returns 
        ------- 
        relayout_changes: dict[str, any] 
            Subset of relayout_data including only the keys / values that 
            resulted in a change to the figure's layout data 
        &quot;&quot;&quot;</span>
        <span class="s2"># Initialize relayout changes</span>
        <span class="s2"># ---------------------------</span>
        <span class="s2"># This will be a subset of the relayout_data including only the</span>
        <span class="s2"># keys / values that are changed in the figure's layout data</span>
        <span class="s1">relayout_changes = {}</span>

        <span class="s2"># Process each key</span>
        <span class="s2"># ----------------</span>
        <span class="s0">for </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">relayout_data.items():</span>

            <span class="s0">if not </span><span class="s1">BaseFigure._is_key_path_compatible(key_path_str</span><span class="s0">, </span><span class="s1">self.layout):</span>

                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;&quot;&quot; 
Invalid property path '{key_path_str}' for layout 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">key_path_str=key_path_str</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s2"># Apply set operation on the layout dict</span>
            <span class="s1">val_changed = BaseFigure._set_in(self._layout</span><span class="s0">, </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">v)</span>

            <span class="s0">if </span><span class="s1">val_changed:</span>
                <span class="s1">relayout_changes[key_path_str] = v</span>

        <span class="s0">return </span><span class="s1">relayout_changes</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_is_key_path_compatible(key_path_str</span><span class="s0">, </span><span class="s1">plotly_obj):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether the specifieid key path string is compatible with 
        the specified plotly object for the purpose of relayout/restyle 
        operation 
        &quot;&quot;&quot;</span>

        <span class="s2"># Convert string to tuple of path components</span>
        <span class="s2"># e.g. 'foo[0].bar[1]' -&gt; ('foo', 0, 'bar', 1)</span>
        <span class="s1">key_path_tuple = BaseFigure._str_to_dict_path(key_path_str)</span>

        <span class="s2"># Remove trailing integer component</span>
        <span class="s2"># e.g. ('foo', 0, 'bar', 1) -&gt; ('foo', 0, 'bar')</span>
        <span class="s2"># We do this because it's fine for relayout/restyle to create new</span>
        <span class="s2"># elements in the final array in the path.</span>
        <span class="s0">if </span><span class="s1">isinstance(key_path_tuple[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s1">key_path_tuple = key_path_tuple[:-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2"># Test whether modified key path tuple is in plotly_obj</span>
        <span class="s0">return </span><span class="s1">key_path_tuple </span><span class="s0">in </span><span class="s1">plotly_obj</span>

    <span class="s0">def </span><span class="s1">_relayout_child(self</span><span class="s0">, </span><span class="s1">child</span><span class="s0">, </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process relayout operation on child layout object 
 
        Parameters 
        ---------- 
        child : BaseLayoutType 
            The figure's layout 
        key_path_str : 
            A key path string (e.g. 'foo.bar[0]') 
        val 
            Relayout value 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Validate input</span>
        <span class="s2"># --------------</span>
        <span class="s0">assert </span><span class="s1">child </span><span class="s0">is </span><span class="s1">self.layout</span>

        <span class="s2"># Not in batch mode</span>
        <span class="s2"># -------------</span>
        <span class="s2"># Dispatch change callbacks and send relayout message</span>
        <span class="s0">if not </span><span class="s1">self._in_batch_mode:</span>
            <span class="s1">relayout_msg = {key_path_str: val}</span>
            <span class="s1">self._send_relayout_msg(relayout_msg)</span>
            <span class="s1">self._dispatch_layout_change_callbacks(relayout_msg)</span>

        <span class="s2"># In batch mode</span>
        <span class="s2"># -------------</span>
        <span class="s2"># Add key_path_str/val to saved batch edits</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._batch_layout_edits[key_path_str] = val</span>

    <span class="s2"># Dispatch change callbacks</span>
    <span class="s2"># -------------------------</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_build_dispatch_plan(key_path_strs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Build a dispatch plan for a list of key path strings 
 
        A dispatch plan is a dict: 
           - *from* path tuples that reference an object that has descendants 
             that are referenced in `key_path_strs`. 
           - *to* sets of tuples that correspond to descendants of the object 
             above. 
 
        Parameters 
        ---------- 
        key_path_strs : list[str] 
            List of key path strings. For example: 
 
            ['xaxis.rangeselector.font.color', 'xaxis.rangeselector.bgcolor'] 
 
        Returns 
        ------- 
        dispatch_plan: dict[tuple[str|int], set[tuple[str|int]]] 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; key_path_strs = ['xaxis.rangeselector.font.color', 
        ...                  'xaxis.rangeselector.bgcolor'] 
 
        &gt;&gt;&gt; BaseFigure._build_dispatch_plan(key_path_strs) # doctest: +SKIP 
            {(): {'xaxis', 
                  ('xaxis', 'rangeselector'), 
                  ('xaxis', 'rangeselector', 'bgcolor'), 
                  ('xaxis', 'rangeselector', 'font'), 
                  ('xaxis', 'rangeselector', 'font', 'color')}, 
             ('xaxis',): {('rangeselector',), 
                          ('rangeselector', 'bgcolor'), 
                          ('rangeselector', 'font'), 
                          ('rangeselector', 'font', 'color')}, 
             ('xaxis', 'rangeselector'): {('bgcolor',), 
                                          ('font',), 
                                          ('font', 'color')}, 
             ('xaxis', 'rangeselector', 'font'): {('color',)}} 
        &quot;&quot;&quot;</span>
        <span class="s1">dispatch_plan = {}</span>

        <span class="s0">for </span><span class="s1">key_path_str </span><span class="s0">in </span><span class="s1">key_path_strs:</span>

            <span class="s1">key_path = BaseFigure._str_to_dict_path(key_path_str)</span>
            <span class="s1">key_path_so_far = ()</span>
            <span class="s1">keys_left = key_path</span>

            <span class="s2"># Iterate down the key path</span>
            <span class="s0">for </span><span class="s1">next_key </span><span class="s0">in </span><span class="s1">key_path:</span>
                <span class="s0">if </span><span class="s1">key_path_so_far </span><span class="s0">not in </span><span class="s1">dispatch_plan:</span>
                    <span class="s1">dispatch_plan[key_path_so_far] = set()</span>

                <span class="s1">to_add = [keys_left[: i + </span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(keys_left))]</span>
                <span class="s1">dispatch_plan[key_path_so_far].update(to_add)</span>

                <span class="s1">key_path_so_far = key_path_so_far + (next_key</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s1">keys_left = keys_left[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s0">return </span><span class="s1">dispatch_plan</span>

    <span class="s0">def </span><span class="s1">_dispatch_layout_change_callbacks(self</span><span class="s0">, </span><span class="s1">relayout_data):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch property change callbacks given relayout_data 
 
        Parameters 
        ---------- 
        relayout_data : dict[str, any] 
            See docstring for plotly_relayout. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s2"># Build dispatch plan</span>
        <span class="s2"># -------------------</span>
        <span class="s1">key_path_strs = list(relayout_data.keys())</span>
        <span class="s1">dispatch_plan = BaseFigure._build_dispatch_plan(key_path_strs)</span>

        <span class="s2"># Dispatch changes to each layout objects</span>
        <span class="s2"># ---------------------------------------</span>
        <span class="s0">for </span><span class="s1">path_tuple</span><span class="s0">, </span><span class="s1">changed_paths </span><span class="s0">in </span><span class="s1">dispatch_plan.items():</span>
            <span class="s0">if </span><span class="s1">path_tuple </span><span class="s0">in </span><span class="s1">self.layout:</span>
                <span class="s1">dispatch_obj = self.layout[path_tuple]</span>
                <span class="s0">if </span><span class="s1">isinstance(dispatch_obj</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                    <span class="s1">dispatch_obj._dispatch_change_callbacks(changed_paths)</span>

    <span class="s0">def </span><span class="s1">_dispatch_trace_change_callbacks(self</span><span class="s0">, </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">trace_indexes):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch property change callbacks given restyle_data 
 
        Parameters 
        ---------- 
        restyle_data : dict[str, any] 
            See docstring for plotly_restyle. 
 
        trace_indexes : list[int] 
            List of trace indexes that restyle operation applied to 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Build dispatch plan</span>
        <span class="s2"># -------------------</span>
        <span class="s1">key_path_strs = list(restyle_data.keys())</span>
        <span class="s1">dispatch_plan = BaseFigure._build_dispatch_plan(key_path_strs)</span>

        <span class="s2"># Dispatch changes to each object in each trace</span>
        <span class="s2"># ---------------------------------------------</span>
        <span class="s0">for </span><span class="s1">path_tuple</span><span class="s0">, </span><span class="s1">changed_paths </span><span class="s0">in </span><span class="s1">dispatch_plan.items():</span>
            <span class="s0">for </span><span class="s1">trace_ind </span><span class="s0">in </span><span class="s1">trace_indexes:</span>
                <span class="s1">trace = self.data[trace_ind]</span>
                <span class="s0">if </span><span class="s1">path_tuple </span><span class="s0">in </span><span class="s1">trace:</span>
                    <span class="s1">dispatch_obj = trace[path_tuple]</span>
                    <span class="s0">if </span><span class="s1">isinstance(dispatch_obj</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                        <span class="s1">dispatch_obj._dispatch_change_callbacks(changed_paths)</span>

    <span class="s2"># Frames</span>
    <span class="s2"># ------</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">frames(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        The `frames` property is a tuple of the figure's frame objects 
 
        Returns 
        ------- 
        tuple[plotly.graph_objs.Frame] 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self[</span><span class="s4">&quot;frames&quot;</span><span class="s1">]</span>

    <span class="s1">@frames.setter</span>
    <span class="s0">def </span><span class="s1">frames(self</span><span class="s0">, </span><span class="s1">new_frames):</span>
        <span class="s2"># Note: Frames are not supported by the FigureWidget subclass so we</span>
        <span class="s2"># only validate coerce the frames. We don't emit any events on frame</span>
        <span class="s2"># changes, and we don't reparent the frames.</span>

        <span class="s2"># Validate frames</span>
        <span class="s1">self._frame_objs = self._frames_validator.validate_coerce(new_frames)</span>

    <span class="s2"># Update</span>
    <span class="s2"># ------</span>
    <span class="s0">def </span><span class="s1">plotly_update(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">restyle_data=</span><span class="s0">None, </span><span class="s1">relayout_data=</span><span class="s0">None, </span><span class="s1">trace_indexes=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a Plotly update operation on the figure. 
 
        Note: This operation both mutates and returns the figure 
 
        Parameters 
        ---------- 
        restyle_data : dict 
            Traces update specification. See the docstring for the 
            `plotly_restyle` method for details 
        relayout_data : dict 
            Layout update specification. See the docstring for the 
            `plotly_relayout` method for details 
        trace_indexes : 
            Trace index, or list of trace indexes, that the update operation 
            applies to. Defaults to all trace indexes. 
 
        Returns 
        ------- 
        BaseFigure 
            None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Handle source_view_id</span>
        <span class="s2"># ---------------------</span>
        <span class="s2"># If not None, the source_view_id is the UID of the frontend</span>
        <span class="s2"># Plotly.js view that initially triggered this update operation</span>
        <span class="s2"># (e.g. the user clicked a button that triggered an update</span>
        <span class="s2"># operation). We pass this UID along so that the frontend views can</span>
        <span class="s2"># determine whether they need to apply the update operation on</span>
        <span class="s2"># themselves.</span>
        <span class="s0">if </span><span class="s4">&quot;source_view_id&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">msg_kwargs = {</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">: kwargs[</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">]}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg_kwargs = {}</span>

        <span class="s2"># Perform update operation</span>
        <span class="s2"># ------------------------</span>
        <span class="s2"># This updates the _data and _layout dicts, and returns the changes</span>
        <span class="s2"># to the traces (restyle_changes) and layout (relayout_changes)</span>
        <span class="s1">(</span>
            <span class="s1">restyle_changes</span><span class="s0">,</span>
            <span class="s1">relayout_changes</span><span class="s0">,</span>
            <span class="s1">trace_indexes</span><span class="s0">,</span>
        <span class="s1">) = self._perform_plotly_update(</span>
            <span class="s1">restyle_data=restyle_data</span><span class="s0">,</span>
            <span class="s1">relayout_data=relayout_data</span><span class="s0">,</span>
            <span class="s1">trace_indexes=trace_indexes</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s2"># Send update message</span>
        <span class="s2"># -------------------</span>
        <span class="s2"># Send a plotly_update message to the frontend (if any)</span>
        <span class="s0">if </span><span class="s1">restyle_changes </span><span class="s0">or </span><span class="s1">relayout_changes:</span>
            <span class="s1">self._send_update_msg(</span>
                <span class="s1">restyle_data=restyle_changes</span><span class="s0">,</span>
                <span class="s1">relayout_data=relayout_changes</span><span class="s0">,</span>
                <span class="s1">trace_indexes=trace_indexes</span><span class="s0">,</span>
                <span class="s1">**msg_kwargs</span>
            <span class="s1">)</span>

        <span class="s2"># Dispatch changes</span>
        <span class="s2"># ----------------</span>
        <span class="s2"># ### Dispatch restyle changes ###</span>
        <span class="s0">if </span><span class="s1">restyle_changes:</span>
            <span class="s1">self._dispatch_trace_change_callbacks(restyle_changes</span><span class="s0">, </span><span class="s1">trace_indexes)</span>

        <span class="s2"># ### Dispatch relayout changes ###</span>
        <span class="s0">if </span><span class="s1">relayout_changes:</span>
            <span class="s1">self._dispatch_layout_change_callbacks(relayout_changes)</span>

    <span class="s0">def </span><span class="s1">_perform_plotly_update(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">restyle_data=</span><span class="s0">None, </span><span class="s1">relayout_data=</span><span class="s0">None, </span><span class="s1">trace_indexes=</span><span class="s0">None</span>
    <span class="s1">):</span>

        <span class="s2"># Check for early exist</span>
        <span class="s2"># ---------------------</span>
        <span class="s0">if not </span><span class="s1">restyle_data </span><span class="s0">and not </span><span class="s1">relayout_data:</span>
            <span class="s2"># Nothing to do</span>
            <span class="s0">return None, None, None</span>

        <span class="s2"># Normalize input</span>
        <span class="s2"># ---------------</span>
        <span class="s0">if </span><span class="s1">restyle_data </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">restyle_data = {}</span>
        <span class="s0">if </span><span class="s1">relayout_data </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">relayout_data = {}</span>

        <span class="s1">trace_indexes = self._normalize_trace_indexes(trace_indexes)</span>

        <span class="s2"># Perform relayout</span>
        <span class="s2"># ----------------</span>
        <span class="s1">relayout_changes = self._perform_plotly_relayout(relayout_data)</span>

        <span class="s2"># Perform restyle</span>
        <span class="s2"># ---------------</span>
        <span class="s1">restyle_changes = self._perform_plotly_restyle(restyle_data</span><span class="s0">, </span><span class="s1">trace_indexes)</span>

        <span class="s2"># Return changes</span>
        <span class="s2"># --------------</span>
        <span class="s0">return </span><span class="s1">restyle_changes</span><span class="s0">, </span><span class="s1">relayout_changes</span><span class="s0">, </span><span class="s1">trace_indexes</span>

    <span class="s2"># Plotly message stubs</span>
    <span class="s2"># --------------------</span>
    <span class="s2"># send-message stubs that may be overridden by the widget subclass</span>
    <span class="s0">def </span><span class="s1">_send_addTraces_msg(self</span><span class="s0">, </span><span class="s1">new_traces_data):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_send_moveTraces_msg(self</span><span class="s0">, </span><span class="s1">current_inds</span><span class="s0">, </span><span class="s1">new_inds):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_send_deleteTraces_msg(self</span><span class="s0">, </span><span class="s1">delete_inds):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_send_restyle_msg(self</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">trace_indexes=</span><span class="s0">None, </span><span class="s1">source_view_id=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_send_relayout_msg(self</span><span class="s0">, </span><span class="s1">layout</span><span class="s0">, </span><span class="s1">source_view_id=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_send_update_msg(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">trace_indexes=</span><span class="s0">None, </span><span class="s1">source_view_id=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_send_animate_msg(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">styles_data</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">trace_indexes</span><span class="s0">, </span><span class="s1">animation_opts</span>
    <span class="s1">):</span>
        <span class="s0">pass</span>

    <span class="s2"># Context managers</span>
    <span class="s2"># ----------------</span>
    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">batch_update(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        A context manager that batches up trace and layout assignment 
        operations into a singe plotly_update message that is executed when 
        the context exits. 
 
        Examples 
        -------- 
        For example, suppose we have a figure widget, `fig`, with a single 
        trace. 
 
        &gt;&gt;&gt; import plotly.graph_objs as go 
        &gt;&gt;&gt; fig = go.FigureWidget(data=[{'y': [3, 4, 2]}]) 
 
        If we want to update the xaxis range, the yaxis range, and the 
        marker color, we could do so using a series of three property 
        assignments as follows: 
 
        &gt;&gt;&gt; fig.layout.xaxis.range = [0, 5] 
        &gt;&gt;&gt; fig.layout.yaxis.range = [0, 10] 
        &gt;&gt;&gt; fig.data[0].marker.color = 'green' 
 
        This will work, however it will result in three messages being 
        sent to the front end (two relayout messages for the axis range 
        updates followed by one restyle message for the marker color 
        update). This can cause the plot to appear to stutter as the 
        three updates are applied incrementally. 
 
        We can avoid this problem by performing these three assignments in a 
        `batch_update` context as follows: 
 
        &gt;&gt;&gt; with fig.batch_update(): 
        ...     fig.layout.xaxis.range = [0, 5] 
        ...     fig.layout.yaxis.range = [0, 10] 
        ...     fig.data[0].marker.color = 'green' 
 
        Now, these three property updates will be sent to the frontend in a 
        single update message, and they will be applied by the front end 
        simultaneously. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._in_batch_mode </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s0">yield</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self._in_batch_mode = </span><span class="s0">True</span>
                <span class="s0">yield</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s2"># ### Disable batch mode ###</span>
                <span class="s1">self._in_batch_mode = </span><span class="s0">False</span>

                <span class="s2"># ### Build plotly_update params ###</span>
                <span class="s1">(</span>
                    <span class="s1">restyle_data</span><span class="s0">,</span>
                    <span class="s1">relayout_data</span><span class="s0">,</span>
                    <span class="s1">trace_indexes</span><span class="s0">,</span>
                <span class="s1">) = self._build_update_params_from_batch()</span>

                <span class="s2"># ### Call plotly_update ###</span>
                <span class="s1">self.plotly_update(</span>
                    <span class="s1">restyle_data=restyle_data</span><span class="s0">,</span>
                    <span class="s1">relayout_data=relayout_data</span><span class="s0">,</span>
                    <span class="s1">trace_indexes=trace_indexes</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s2"># ### Clear out saved batch edits ###</span>
                <span class="s1">self._batch_layout_edits.clear()</span>
                <span class="s1">self._batch_trace_edits.clear()</span>

    <span class="s0">def </span><span class="s1">_build_update_params_from_batch(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert `_batch_trace_edits` and `_batch_layout_edits` into the 
        `restyle_data`, `relayout_data`, and `trace_indexes` params accepted 
        by the `plotly_update` method. 
 
        Returns 
        ------- 
        (dict, dict, list[int]) 
        &quot;&quot;&quot;</span>

        <span class="s2"># Handle Style / Trace Indexes</span>
        <span class="s2"># ----------------------------</span>
        <span class="s1">batch_style_commands = self._batch_trace_edits</span>
        <span class="s1">trace_indexes = sorted(set([trace_ind </span><span class="s0">for </span><span class="s1">trace_ind </span><span class="s0">in </span><span class="s1">batch_style_commands]))</span>

        <span class="s1">all_props = sorted(</span>
            <span class="s1">set(</span>
                <span class="s1">[</span>
                    <span class="s1">prop</span>
                    <span class="s0">for </span><span class="s1">trace_style </span><span class="s0">in </span><span class="s1">self._batch_trace_edits.values()</span>
                    <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">trace_style</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2"># Initialize restyle_data dict with all values undefined</span>
        <span class="s1">restyle_data = {</span>
            <span class="s1">prop: [Undefined </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(len(trace_indexes))] </span><span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">all_props</span>
        <span class="s1">}</span>

        <span class="s2"># Fill in values</span>
        <span class="s0">for </span><span class="s1">trace_ind</span><span class="s0">, </span><span class="s1">trace_style </span><span class="s0">in </span><span class="s1">batch_style_commands.items():</span>
            <span class="s0">for </span><span class="s1">trace_prop</span><span class="s0">, </span><span class="s1">trace_val </span><span class="s0">in </span><span class="s1">trace_style.items():</span>
                <span class="s1">restyle_trace_index = trace_indexes.index(trace_ind)</span>
                <span class="s1">restyle_data[trace_prop][restyle_trace_index] = trace_val</span>

        <span class="s2"># Handle Layout</span>
        <span class="s2"># -------------</span>
        <span class="s1">relayout_data = self._batch_layout_edits</span>

        <span class="s2"># Return plotly_update params</span>
        <span class="s2"># ---------------------------</span>
        <span class="s0">return </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">trace_indexes</span>

    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">batch_animate(self</span><span class="s0">, </span><span class="s1">duration=</span><span class="s5">500</span><span class="s0">, </span><span class="s1">easing=</span><span class="s4">&quot;cubic-in-out&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Context manager to animate trace / layout updates 
 
        Parameters 
        ---------- 
        duration : number 
            The duration of the transition, in milliseconds. 
            If equal to zero, updates are synchronous. 
        easing : string 
            The easing function used for the transition. 
            One of: 
                - linear 
                - quad 
                - cubic 
                - sin 
                - exp 
                - circle 
                - elastic 
                - back 
                - bounce 
                - linear-in 
                - quad-in 
                - cubic-in 
                - sin-in 
                - exp-in 
                - circle-in 
                - elastic-in 
                - back-in 
                - bounce-in 
                - linear-out 
                - quad-out 
                - cubic-out 
                - sin-out 
                - exp-out 
                - circle-out 
                - elastic-out 
                - back-out 
                - bounce-out 
                - linear-in-out 
                - quad-in-out 
                - cubic-in-out 
                - sin-in-out 
                - exp-in-out 
                - circle-in-out 
                - elastic-in-out 
                - back-in-out 
                - bounce-in-out 
 
        Examples 
        -------- 
        Suppose we have a figure widget, `fig`, with a single trace. 
 
        &gt;&gt;&gt; import plotly.graph_objs as go 
        &gt;&gt;&gt; fig = go.FigureWidget(data=[{'y': [3, 4, 2]}]) 
 
        1) Animate a change in the xaxis and yaxis ranges using default 
        duration and easing parameters. 
 
        &gt;&gt;&gt; with fig.batch_animate(): 
        ...     fig.layout.xaxis.range = [0, 5] 
        ...     fig.layout.yaxis.range = [0, 10] 
 
        2) Animate a change in the size and color of the trace's markers 
        over 2 seconds using the elastic-in-out easing method 
 
        &gt;&gt;&gt; with fig.batch_animate(duration=2000, easing='elastic-in-out'): 
        ...     fig.data[0].marker.color = 'green' 
        ...     fig.data[0].marker.size = 20 
        &quot;&quot;&quot;</span>

        <span class="s2"># Validate inputs</span>
        <span class="s2"># ---------------</span>
        <span class="s1">duration = self._animation_duration_validator.validate_coerce(duration)</span>
        <span class="s1">easing = self._animation_easing_validator.validate_coerce(easing)</span>

        <span class="s0">if </span><span class="s1">self._in_batch_mode </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s0">yield</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self._in_batch_mode = </span><span class="s0">True</span>
                <span class="s0">yield</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s2"># Exit batch mode</span>
                <span class="s2"># ---------------</span>
                <span class="s1">self._in_batch_mode = </span><span class="s0">False</span>

                <span class="s2"># Apply batch animate</span>
                <span class="s2"># -------------------</span>
                <span class="s1">self._perform_batch_animate(</span>
                    <span class="s1">{</span>
                        <span class="s4">&quot;transition&quot;</span><span class="s1">: {</span><span class="s4">&quot;duration&quot;</span><span class="s1">: duration</span><span class="s0">, </span><span class="s4">&quot;easing&quot;</span><span class="s1">: easing}</span><span class="s0">,</span>
                        <span class="s4">&quot;frame&quot;</span><span class="s1">: {</span><span class="s4">&quot;duration&quot;</span><span class="s1">: duration}</span><span class="s0">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_perform_batch_animate(self</span><span class="s0">, </span><span class="s1">animation_opts):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform the batch animate operation 
 
        This method should be called with the batch_animate() context 
        manager exits. 
 
        Parameters 
        ---------- 
        animation_opts : dict 
            Animation options as accepted by frontend Plotly.animation command 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s2"># Apply commands to internal dictionaries as an update</span>
        <span class="s2"># ----------------------------------------------------</span>
        <span class="s1">(</span>
            <span class="s1">restyle_data</span><span class="s0">,</span>
            <span class="s1">relayout_data</span><span class="s0">,</span>
            <span class="s1">trace_indexes</span><span class="s0">,</span>
        <span class="s1">) = self._build_update_params_from_batch()</span>

        <span class="s1">(</span>
            <span class="s1">restyle_changes</span><span class="s0">,</span>
            <span class="s1">relayout_changes</span><span class="s0">,</span>
            <span class="s1">trace_indexes</span><span class="s0">,</span>
        <span class="s1">) = self._perform_plotly_update(restyle_data</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">trace_indexes)</span>

        <span class="s2"># Convert style / trace_indexes into animate form</span>
        <span class="s2"># -----------------------------------------------</span>
        <span class="s0">if </span><span class="s1">self._batch_trace_edits:</span>
            <span class="s1">animate_styles</span><span class="s0">, </span><span class="s1">animate_trace_indexes = zip(</span>
                <span class="s1">*[</span>
                    <span class="s1">(trace_style</span><span class="s0">, </span><span class="s1">trace_index)</span>
                    <span class="s0">for </span><span class="s1">trace_index</span><span class="s0">, </span><span class="s1">trace_style </span><span class="s0">in </span><span class="s1">self._batch_trace_edits.items()</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">animate_styles</span><span class="s0">, </span><span class="s1">animate_trace_indexes = {}</span><span class="s0">, </span><span class="s1">[]</span>

        <span class="s1">animate_layout = copy(self._batch_layout_edits)</span>

        <span class="s2"># Send animate message</span>
        <span class="s2"># --------------------</span>
        <span class="s2"># Sends animate message to the front end (if any)</span>
        <span class="s1">self._send_animate_msg(</span>
            <span class="s1">styles_data=list(animate_styles)</span><span class="s0">,</span>
            <span class="s1">relayout_data=animate_layout</span><span class="s0">,</span>
            <span class="s1">trace_indexes=list(animate_trace_indexes)</span><span class="s0">,</span>
            <span class="s1">animation_opts=animation_opts</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s2"># Clear batched commands</span>
        <span class="s2"># ----------------------</span>
        <span class="s1">self._batch_layout_edits.clear()</span>
        <span class="s1">self._batch_trace_edits.clear()</span>

        <span class="s2"># Dispatch callbacks</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># ### Dispatch restyle changes ###</span>
        <span class="s0">if </span><span class="s1">restyle_changes:</span>
            <span class="s1">self._dispatch_trace_change_callbacks(restyle_changes</span><span class="s0">, </span><span class="s1">trace_indexes)</span>

        <span class="s2"># ### Dispatch relayout changes ###</span>
        <span class="s0">if </span><span class="s1">relayout_changes:</span>
            <span class="s1">self._dispatch_layout_change_callbacks(relayout_changes)</span>

    <span class="s2"># Exports</span>
    <span class="s2"># -------</span>
    <span class="s0">def </span><span class="s1">to_dict(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert figure to a dictionary 
 
        Note: the dictionary includes the properties explicitly set by the 
        user, it does not include default values of unspecified properties 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s2"># Handle data</span>
        <span class="s2"># -----------</span>
        <span class="s1">data = deepcopy(self._data)</span>

        <span class="s2"># Handle layout</span>
        <span class="s2"># -------------</span>
        <span class="s1">layout = deepcopy(self._layout)</span>

        <span class="s2"># Handle frames</span>
        <span class="s2"># -------------</span>
        <span class="s2"># Frame key is only added if there are any frames</span>
        <span class="s1">res = {</span><span class="s4">&quot;data&quot;</span><span class="s1">: data</span><span class="s0">, </span><span class="s4">&quot;layout&quot;</span><span class="s1">: layout}</span>
        <span class="s1">frames = deepcopy([frame._props </span><span class="s0">for </span><span class="s1">frame </span><span class="s0">in </span><span class="s1">self._frame_objs])</span>

        <span class="s0">if </span><span class="s1">frames:</span>
            <span class="s1">res[</span><span class="s4">&quot;frames&quot;</span><span class="s1">] = frames</span>

        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">to_plotly_json(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert figure to a JSON representation as a Python dict 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.to_dict()</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_to_ordered_dict(d</span><span class="s0">, </span><span class="s1">skip_uid=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Static helper for converting dict or list to structure of ordered 
        dictionaries 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s2"># d is a dict</span>
            <span class="s1">result = collections.OrderedDict()</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">sorted(d.keys()):</span>
                <span class="s0">if </span><span class="s1">skip_uid </span><span class="s0">and </span><span class="s1">key == </span><span class="s4">&quot;uid&quot;</span><span class="s1">:</span>
                    <span class="s0">continue</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">result[key] = BaseFigure._to_ordered_dict(d[key]</span><span class="s0">, </span><span class="s1">skip_uid=skip_uid)</span>

        <span class="s0">elif </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">d </span><span class="s0">and </span><span class="s1">isinstance(d[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s2"># d is a list of dicts</span>
            <span class="s1">result = [BaseFigure._to_ordered_dict(el</span><span class="s0">, </span><span class="s1">skip_uid=skip_uid) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">d]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = d</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">to_ordered_dict(self</span><span class="s0">, </span><span class="s1">skip_uid=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s2"># Initialize resulting OrderedDict</span>
        <span class="s2"># --------------------------------</span>
        <span class="s1">result = collections.OrderedDict()</span>

        <span class="s2"># Handle data</span>
        <span class="s2"># -----------</span>
        <span class="s1">result[</span><span class="s4">&quot;data&quot;</span><span class="s1">] = BaseFigure._to_ordered_dict(self._data</span><span class="s0">, </span><span class="s1">skip_uid=skip_uid)</span>

        <span class="s2"># Handle layout</span>
        <span class="s2"># -------------</span>
        <span class="s1">result[</span><span class="s4">&quot;layout&quot;</span><span class="s1">] = BaseFigure._to_ordered_dict(self._layout)</span>

        <span class="s2"># Handle frames</span>
        <span class="s2"># -------------</span>
        <span class="s0">if </span><span class="s1">self._frame_objs:</span>
            <span class="s1">frames_props = [frame._props </span><span class="s0">for </span><span class="s1">frame </span><span class="s0">in </span><span class="s1">self._frame_objs]</span>
            <span class="s1">result[</span><span class="s4">&quot;frames&quot;</span><span class="s1">] = BaseFigure._to_ordered_dict(frames_props)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s2"># plotly.io methods</span>
    <span class="s2"># -----------------</span>
    <span class="s2"># Note that docstrings are auto-generated in plotly/_docstring_gen.py</span>
    <span class="s0">def </span><span class="s1">show(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Show a figure using either the default renderer(s) or the renderer(s) 
        specified by the renderer argument 
 
        Parameters 
        ---------- 
        renderer: str or None (default None) 
            A string containing the names of one or more registered renderers 
            (separated by '+' characters) or None.  If None, then the default 
            renderers specified in plotly.io.renderers.default are used. 
 
        validate: bool (default True) 
            True if the figure should be validated before being shown, 
            False otherwise. 
 
        width: int or float 
            An integer or float that determines the number of pixels wide the 
            plot is. The default is set in plotly.js. 
 
        height: int or float 
            An integer or float that determines the number of pixels wide the 
            plot is. The default is set in plotly.js. 
 
        config: dict 
            A dict of parameters to configure the figure. The defaults are set 
            in plotly.js. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.show(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">to_json(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a figure to a JSON string representation 
 
        Parameters 
        ---------- 
        validate: bool (default True) 
            True if the figure should be validated before being converted to 
            JSON, False otherwise. 
 
        pretty: bool (default False) 
            True if JSON representation should be pretty-printed, False if 
            representation should be as compact as possible. 
 
        remove_uids: bool (default True) 
            True if trace UIDs should be omitted from the JSON representation 
 
        engine: str (default None) 
            The JSON encoding engine to use. One of: 
              - &quot;json&quot; for an encoder based on the built-in Python json module 
              - &quot;orjson&quot; for a fast encoder the requires the orjson package 
            If not specified, the default encoder is set to the current value of 
            plotly.io.json.config.default_encoder. 
 
        Returns 
        ------- 
        str 
            Representation of figure as a JSON string 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.to_json(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">full_figure_for_development(self</span><span class="s0">, </span><span class="s1">warn=</span><span class="s0">True, </span><span class="s1">as_dict=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute default values for all attributes not specified in the input figure and 
        returns the output as a &quot;full&quot; figure. This function calls Plotly.js via Kaleido 
        to populate unspecified attributes. This function is intended for interactive use 
        during development to learn more about how Plotly.js computes default values and is 
        not generally necessary or recommended for production use. 
 
        Parameters 
        ---------- 
        fig: 
            Figure object or dict representing a figure 
 
        warn: bool 
            If False, suppress warnings about not using this in production. 
 
        as_dict: bool 
            If True, output is a dict with some keys that go.Figure can't parse. 
            If False, output is a go.Figure with unparseable keys skipped. 
 
        Returns 
        ------- 
        plotly.graph_objects.Figure or dict 
            The full figure 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.full_figure_for_development(self</span><span class="s0">, </span><span class="s1">warn</span><span class="s0">, </span><span class="s1">as_dict)</span>

    <span class="s0">def </span><span class="s1">write_json(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a figure to JSON and write it to a file or writeable 
        object 
 
        Parameters 
        ---------- 
        file: str or writeable 
            A string representing a local file path or a writeable object 
            (e.g. an open file descriptor) 
 
        pretty: bool (default False) 
            True if JSON representation should be pretty-printed, False if 
            representation should be as compact as possible. 
 
        remove_uids: bool (default True) 
            True if trace UIDs should be omitted from the JSON representation 
 
        engine: str (default None) 
            The JSON encoding engine to use. One of: 
              - &quot;json&quot; for an encoder based on the built-in Python json module 
              - &quot;orjson&quot; for a fast encoder the requires the orjson package 
            If not specified, the default encoder is set to the current value of 
            plotly.io.json.config.default_encoder. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.write_json(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">to_html(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a figure to an HTML string representation. 
 
        Parameters 
        ---------- 
        config: dict or None (default None) 
            Plotly.js figure config options 
        auto_play: bool (default=True) 
            Whether to automatically start the animation sequence on page load 
            if the figure contains frames. Has no effect if the figure does not 
            contain frames. 
        include_plotlyjs: bool or string (default True) 
            Specifies how the plotly.js library is included/loaded in the output 
            div string. 
 
            If True, a script tag containing the plotly.js source code (~3MB) 
            is included in the output.  HTML files generated with this option are 
            fully self-contained and can be used offline. 
 
            If 'cdn', a script tag that references the plotly.js CDN is included 
            in the output. HTML files generated with this option are about 3MB 
            smaller than those generated with include_plotlyjs=True, but they 
            require an active internet connection in order to load the plotly.js 
            library. 
 
            If 'directory', a script tag is included that references an external 
            plotly.min.js bundle that is assumed to reside in the same 
            directory as the HTML file. 
 
            If 'require', Plotly.js is loaded using require.js.  This option 
            assumes that require.js is globally available and that it has been 
            globally configured to know how to find Plotly.js as 'plotly'. 
            This option is not advised when full_html=True as it will result 
            in a non-functional html file. 
 
            If a string that ends in '.js', a script tag is included that 
            references the specified path. This approach can be used to point 
            the resulting HTML file to an alternative CDN or local bundle. 
 
            If False, no script tag referencing plotly.js is included. This is 
            useful when the resulting div string will be placed inside an HTML 
            document that already loads plotly.js. This option is not advised 
            when full_html=True as it will result in a non-functional html file. 
        include_mathjax: bool or string (default False) 
            Specifies how the MathJax.js library is included in the output html 
            div string.  MathJax is required in order to display labels 
            with LaTeX typesetting. 
 
            If False, no script tag referencing MathJax.js will be included in the 
            output. 
 
            If 'cdn', a script tag that references a MathJax CDN location will be 
            included in the output.  HTML div strings generated with this option 
            will be able to display LaTeX typesetting as long as internet access 
            is available. 
 
            If a string that ends in '.js', a script tag is included that 
            references the specified path. This approach can be used to point the 
            resulting HTML div string to an alternative CDN. 
        post_script: str or list or None (default None) 
            JavaScript snippet(s) to be included in the resulting div just after 
            plot creation.  The string(s) may include '{plot_id}' placeholders 
            that will then be replaced by the `id` of the div element that the 
            plotly.js figure is associated with.  One application for this script 
            is to install custom plotly.js event handlers. 
        full_html: bool (default True) 
            If True, produce a string containing a complete HTML document 
            starting with an &lt;html&gt; tag.  If False, produce a string containing 
            a single &lt;div&gt; element. 
        animation_opts: dict or None (default None) 
            dict of custom animation parameters to be passed to the function 
            Plotly.animate in Plotly.js. See 
            https://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js 
            for available options. Has no effect if the figure does not contain 
            frames, or auto_play is False. 
        default_width, default_height: number or str (default '100%') 
            The default figure width/height to use if the provided figure does not 
            specify its own layout.width/layout.height property.  May be 
            specified in pixels as an integer (e.g. 500), or as a css width style 
            string (e.g. '500px', '100%'). 
        validate: bool (default True) 
            True if the figure should be validated before being converted to 
            JSON, False otherwise. 
        div_id: str (default None) 
            If provided, this is the value of the id attribute of the div tag. If None, the 
            id attribute is a UUID. 
 
        Returns 
        ------- 
        str 
            Representation of figure as an HTML div string 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.to_html(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">write_html(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Write a figure to an HTML file representation 
 
        Parameters 
        ---------- 
        file: str or writeable 
            A string representing a local file path or a writeable object 
            (e.g. a pathlib.Path object or an open file descriptor) 
        config: dict or None (default None) 
            Plotly.js figure config options 
        auto_play: bool (default=True) 
            Whether to automatically start the animation sequence on page load 
            if the figure contains frames. Has no effect if the figure does not 
            contain frames. 
        include_plotlyjs: bool or string (default True) 
            Specifies how the plotly.js library is included/loaded in the output 
            div string. 
 
            If True, a script tag containing the plotly.js source code (~3MB) 
            is included in the output.  HTML files generated with this option are 
            fully self-contained and can be used offline. 
 
            If 'cdn', a script tag that references the plotly.js CDN is included 
            in the output. HTML files generated with this option are about 3MB 
            smaller than those generated with include_plotlyjs=True, but they 
            require an active internet connection in order to load the plotly.js 
            library. 
 
            If 'directory', a script tag is included that references an external 
            plotly.min.js bundle that is assumed to reside in the same 
            directory as the HTML file. If `file` is a string to a local file path 
            and `full_html` is True then 
 
            If 'directory', a script tag is included that references an external 
            plotly.min.js bundle that is assumed to reside in the same 
            directory as the HTML file.  If `file` is a string to a local file 
            path and `full_html` is True, then the plotly.min.js bundle is copied 
            into the directory of the resulting HTML file. If a file named 
            plotly.min.js already exists in the output directory then this file 
            is left unmodified and no copy is performed. HTML files generated 
            with this option can be used offline, but they require a copy of 
            the plotly.min.js bundle in the same directory. This option is 
            useful when many figures will be saved as HTML files in the same 
            directory because the plotly.js source code will be included only 
            once per output directory, rather than once per output file. 
 
            If 'require', Plotly.js is loaded using require.js.  This option 
            assumes that require.js is globally available and that it has been 
            globally configured to know how to find Plotly.js as 'plotly'. 
            This option is not advised when full_html=True as it will result 
            in a non-functional html file. 
 
            If a string that ends in '.js', a script tag is included that 
            references the specified path. This approach can be used to point 
            the resulting HTML file to an alternative CDN or local bundle. 
 
            If False, no script tag referencing plotly.js is included. This is 
            useful when the resulting div string will be placed inside an HTML 
            document that already loads plotly.js.  This option is not advised 
            when full_html=True as it will result in a non-functional html file. 
 
        include_mathjax: bool or string (default False) 
            Specifies how the MathJax.js library is included in the output html 
            div string.  MathJax is required in order to display labels 
            with LaTeX typesetting. 
 
            If False, no script tag referencing MathJax.js will be included in the 
            output. 
 
            If 'cdn', a script tag that references a MathJax CDN location will be 
            included in the output.  HTML div strings generated with this option 
            will be able to display LaTeX typesetting as long as internet access 
            is available. 
 
            If a string that ends in '.js', a script tag is included that 
            references the specified path. This approach can be used to point the 
            resulting HTML div string to an alternative CDN. 
        post_script: str or list or None (default None) 
            JavaScript snippet(s) to be included in the resulting div just after 
            plot creation.  The string(s) may include '{plot_id}' placeholders 
            that will then be replaced by the `id` of the div element that the 
            plotly.js figure is associated with.  One application for this script 
            is to install custom plotly.js event handlers. 
        full_html: bool (default True) 
            If True, produce a string containing a complete HTML document 
            starting with an &lt;html&gt; tag.  If False, produce a string containing 
            a single &lt;div&gt; element. 
        animation_opts: dict or None (default None) 
            dict of custom animation parameters to be passed to the function 
            Plotly.animate in Plotly.js. See 
            https://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js 
            for available options. Has no effect if the figure does not contain 
            frames, or auto_play is False. 
        default_width, default_height: number or str (default '100%') 
            The default figure width/height to use if the provided figure does not 
            specify its own layout.width/layout.height property.  May be 
            specified in pixels as an integer (e.g. 500), or as a css width style 
            string (e.g. '500px', '100%'). 
        validate: bool (default True) 
            True if the figure should be validated before being converted to 
            JSON, False otherwise. 
        auto_open: bool (default True) 
            If True, open the saved file in a web browser after saving. 
            This argument only applies if `full_html` is True. 
        div_id: str (default None) 
            If provided, this is the value of the id attribute of the div tag. If None, the 
            id attribute is a UUID. 
 
        Returns 
        ------- 
        str 
            Representation of figure as an HTML div string 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.write_html(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">to_image(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a figure to a static image bytes string 
 
        Parameters 
        ---------- 
        format: str or None 
            The desired image format. One of 
              - 'png' 
              - 'jpg' or 'jpeg' 
              - 'webp' 
              - 'svg' 
              - 'pdf' 
              - 'eps' (Requires the poppler library to be installed) 
 
            If not specified, will default to `plotly.io.config.default_format` 
 
        width: int or None 
            The width of the exported image in layout pixels. If the `scale` 
            property is 1.0, this will also be the width of the exported image 
            in physical pixels. 
 
            If not specified, will default to `plotly.io.config.default_width` 
 
        height: int or None 
            The height of the exported image in layout pixels. If the `scale` 
            property is 1.0, this will also be the height of the exported image 
            in physical pixels. 
 
            If not specified, will default to `plotly.io.config.default_height` 
 
        scale: int or float or None 
            The scale factor to use when exporting the figure. A scale factor 
            larger than 1.0 will increase the image resolution with respect 
            to the figure's layout pixel dimensions. Whereas as scale factor of 
            less than 1.0 will decrease the image resolution. 
 
            If not specified, will default to `plotly.io.config.default_scale` 
 
        validate: bool 
            True if the figure should be validated before being converted to 
            an image, False otherwise. 
 
        engine: str 
            Image export engine to use: 
             - &quot;kaleido&quot;: Use Kaleido for image export 
             - &quot;orca&quot;: Use Orca for image export 
             - &quot;auto&quot; (default): Use Kaleido if installed, otherwise use orca 
 
        Returns 
        ------- 
        bytes 
            The image data 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.to_image(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">write_image(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a figure to a static image and write it to a file or writeable 
        object 
 
        Parameters 
        ---------- 
        file: str or writeable 
            A string representing a local file path or a writeable object 
            (e.g. a pathlib.Path object or an open file descriptor) 
 
        format: str or None 
            The desired image format. One of 
              - 'png' 
              - 'jpg' or 'jpeg' 
              - 'webp' 
              - 'svg' 
              - 'pdf' 
              - 'eps' (Requires the poppler library to be installed) 
 
            If not specified and `file` is a string then this will default to the 
            file extension. If not specified and `file` is not a string then this 
            will default to `plotly.io.config.default_format` 
 
        width: int or None 
            The width of the exported image in layout pixels. If the `scale` 
            property is 1.0, this will also be the width of the exported image 
            in physical pixels. 
 
            If not specified, will default to `plotly.io.config.default_width` 
 
        height: int or None 
            The height of the exported image in layout pixels. If the `scale` 
            property is 1.0, this will also be the height of the exported image 
            in physical pixels. 
 
            If not specified, will default to `plotly.io.config.default_height` 
 
        scale: int or float or None 
            The scale factor to use when exporting the figure. A scale factor 
            larger than 1.0 will increase the image resolution with respect 
            to the figure's layout pixel dimensions. Whereas as scale factor of 
            less than 1.0 will decrease the image resolution. 
 
            If not specified, will default to `plotly.io.config.default_scale` 
 
        validate: bool 
            True if the figure should be validated before being converted to 
            an image, False otherwise. 
 
        engine: str 
            Image export engine to use: 
             - &quot;kaleido&quot;: Use Kaleido for image export 
             - &quot;orca&quot;: Use Orca for image export 
             - &quot;auto&quot; (default): Use Kaleido if installed, otherwise use orca 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>

        <span class="s0">return </span><span class="s1">pio.write_image(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s2"># Static helpers</span>
    <span class="s2"># --------------</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_is_dict_list(v):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return true of the input object is a list of dicts 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">len(v) &gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">isinstance(v[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dict)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_perform_update(plotly_obj</span><span class="s0">, </span><span class="s1">update_obj</span><span class="s0">, </span><span class="s1">overwrite=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Helper to support the update() methods on :class:`BaseFigure` and 
        :class:`BasePlotlyType` 
 
        Parameters 
        ---------- 
        plotly_obj : BasePlotlyType|tuple[BasePlotlyType] 
            Object to up updated 
        update_obj : dict|list[dict]|tuple[dict] 
            When ``plotly_obj`` is an instance of :class:`BaseFigure`, 
            ``update_obj`` should be a dict 
 
            When ``plotly_obj`` is a tuple of instances of 
            :class:`BasePlotlyType`, ``update_obj`` should be a tuple or list 
            of dicts 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">CompoundValidator</span><span class="s0">,</span>
            <span class="s1">CompoundArrayValidator</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">update_obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Nothing to do</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">isinstance(plotly_obj</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>

            <span class="s2"># Handle initializing subplot ids</span>
            <span class="s2"># -------------------------------</span>
            <span class="s2"># This should be valid even if xaxis2 hasn't been initialized:</span>
            <span class="s2"># &gt;&gt;&gt; layout.update(xaxis2={'title': 'xaxis 2'})</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">update_obj:</span>
                <span class="s1">err = _check_path_in_prop_tree(plotly_obj</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">error_cast=ValueError)</span>
                <span class="s0">if </span><span class="s1">err </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">isinstance(plotly_obj</span><span class="s0">, </span><span class="s1">BaseLayoutType):</span>
                        <span class="s2"># try _subplot_re_match</span>
                        <span class="s1">match = plotly_obj._subplot_re_match(key)</span>
                        <span class="s0">if </span><span class="s1">match:</span>
                            <span class="s2"># We need to create a subplotid object</span>
                            <span class="s1">plotly_obj[key] = {}</span>
                            <span class="s0">continue</span>
                    <span class="s2"># If no match, raise the error, which should already</span>
                    <span class="s2"># contain the _raise_on_invalid_property_error</span>
                    <span class="s2"># generated message</span>
                    <span class="s0">raise </span><span class="s1">err</span>

            <span class="s2"># Convert update_obj to dict</span>
            <span class="s2"># --------------------------</span>
            <span class="s0">if </span><span class="s1">isinstance(update_obj</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                <span class="s1">update_obj = update_obj.to_plotly_json()</span>

            <span class="s2"># Process valid properties</span>
            <span class="s2"># ------------------------</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">update_obj:</span>
                <span class="s1">val = update_obj[key]</span>

                <span class="s0">if </span><span class="s1">overwrite:</span>
                    <span class="s2"># Don't recurse and assign property as-is</span>
                    <span class="s1">plotly_obj[key] = val</span>
                    <span class="s0">continue</span>

                <span class="s1">validator = plotly_obj._get_prop_validator(key)</span>

                <span class="s0">if </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundValidator) </span><span class="s0">and </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">dict):</span>

                    <span class="s2"># Update compound objects recursively</span>
                    <span class="s2"># plotly_obj[key].update(val)</span>
                    <span class="s1">BaseFigure._perform_update(plotly_obj[key]</span><span class="s0">, </span><span class="s1">val)</span>
                <span class="s0">elif </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundArrayValidator):</span>
                    <span class="s0">if </span><span class="s1">plotly_obj[key]:</span>
                        <span class="s2"># plotly_obj has an existing non-empty array for key</span>
                        <span class="s2"># In this case we merge val into the existing elements</span>
                        <span class="s1">BaseFigure._perform_update(plotly_obj[key]</span><span class="s0">, </span><span class="s1">val)</span>

                        <span class="s2"># If update tuple is longer that current tuple, append the</span>
                        <span class="s2"># extra elements to the end</span>
                        <span class="s0">if </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)) </span><span class="s0">and </span><span class="s1">len(val) &gt; len(</span>
                            <span class="s1">plotly_obj[key]</span>
                        <span class="s1">):</span>
                            <span class="s1">plotly_obj[key] = plotly_obj[key] + tuple(</span>
                                <span class="s1">val[len(plotly_obj[key]) :]</span>
                            <span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s2"># plotly_obj is an empty or uninitialized list for key</span>
                        <span class="s2"># In this case we accept val as is</span>
                        <span class="s1">plotly_obj[key] = val</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s2"># Assign non-compound value</span>
                    <span class="s1">plotly_obj[key] = val</span>

        <span class="s0">elif </span><span class="s1">isinstance(plotly_obj</span><span class="s0">, </span><span class="s1">tuple):</span>

            <span class="s0">if </span><span class="s1">len(update_obj) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2"># Nothing to do</span>
                <span class="s0">return</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">plotly_element </span><span class="s0">in </span><span class="s1">enumerate(plotly_obj):</span>
                    <span class="s0">if </span><span class="s1">isinstance(update_obj</span><span class="s0">, </span><span class="s1">dict):</span>
                        <span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">update_obj:</span>
                            <span class="s1">update_element = update_obj[i]</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s0">continue</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">update_element = update_obj[i % len(update_obj)]</span>
                    <span class="s1">BaseFigure._perform_update(plotly_element</span><span class="s0">, </span><span class="s1">update_element)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Unexpected plotly object with type {typ}&quot;</span><span class="s1">.format(typ=type(plotly_obj))</span>
            <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_index_is(iterable</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the index of a value in an iterable using object identity 
        (not object equality as is the case for list.index) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">index_list = [i </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">curr_val </span><span class="s0">in </span><span class="s1">enumerate(iterable) </span><span class="s0">if </span><span class="s1">curr_val </span><span class="s0">is </span><span class="s1">val]</span>
        <span class="s0">if not </span><span class="s1">index_list:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid value&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">index_list[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_make_axis_spanning_layout_object(self</span><span class="s0">, </span><span class="s1">direction</span><span class="s0">, </span><span class="s1">shape):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert a shape drawn on a plot or a subplot into one whose yref or xref 
        ends with &quot; domain&quot; and has coordinates so that the shape will seem to 
        extend infinitely in that dimension. This is useful for drawing lines or 
        boxes on a plot where one dimension of the shape will not move out of 
        bounds when moving the plot's view. 
        Note that the shape already added to the (sub)plot must have the 
        corresponding axis reference referring to an actual axis (e.g., 'x', 
        'y2' etc. are accepted, but not 'paper'). This will be the case if the 
        shape was added with &quot;add_shape&quot;. 
        Shape must have the x0, x1, y0, y1 fields already initialized. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">direction == </span><span class="s4">&quot;vertical&quot;</span><span class="s1">:</span>
            <span class="s2"># fix y points to top and bottom of subplot</span>
            <span class="s1">ref = </span><span class="s4">&quot;yref&quot;</span>
        <span class="s0">elif </span><span class="s1">direction == </span><span class="s4">&quot;horizontal&quot;</span><span class="s1">:</span>
            <span class="s2"># fix x points to left and right of subplot</span>
            <span class="s1">ref = </span><span class="s4">&quot;xref&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Bad direction: %s. Permissible values are 'vertical' and 'horizontal'.&quot;</span>
                <span class="s1">% (direction</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2"># set the ref to &quot;&lt;axis_id&gt; domain&quot; so that its size is based on the</span>
        <span class="s2"># axis's size</span>
        <span class="s1">shape[ref] += </span><span class="s4">&quot; domain&quot;</span>
        <span class="s0">return </span><span class="s1">shape</span>

    <span class="s0">def </span><span class="s1">_process_multiple_axis_spanning_shapes(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">shape_args</span><span class="s0">,</span>
        <span class="s1">row</span><span class="s0">,</span>
        <span class="s1">col</span><span class="s0">,</span>
        <span class="s1">shape_type</span><span class="s0">,</span>
        <span class="s1">exclude_empty_subplots=</span><span class="s0">True,</span>
        <span class="s1">annotation=</span><span class="s0">None,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add a shape or multiple shapes and call _make_axis_spanning_layout_object on 
        all the new shapes. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">shape_type </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;vline&quot;</span><span class="s0">, </span><span class="s4">&quot;vrect&quot;</span><span class="s1">]:</span>
            <span class="s1">direction = </span><span class="s4">&quot;vertical&quot;</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;hline&quot;</span><span class="s0">, </span><span class="s4">&quot;hrect&quot;</span><span class="s1">]:</span>
            <span class="s1">direction = </span><span class="s4">&quot;horizontal&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Bad shape_type %s, needs to be one of 'vline', 'hline', 'vrect', 'hrect'&quot;</span>
                <span class="s1">% (shape_type</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">(row </span><span class="s0">is not None or </span><span class="s1">col </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(</span><span class="s0">not </span><span class="s1">self._has_subplots()):</span>
            <span class="s2"># this has no subplots to address, so we force row and col to be None</span>
            <span class="s1">row = </span><span class="s0">None</span>
            <span class="s1">col = </span><span class="s0">None</span>
        <span class="s1">n_shapes_before = len(self.layout[</span><span class="s4">&quot;shapes&quot;</span><span class="s1">])</span>
        <span class="s1">n_annotations_before = len(self.layout[</span><span class="s4">&quot;annotations&quot;</span><span class="s1">])</span>
        <span class="s2"># shapes are always added at the end of the tuple of shapes, so we see</span>
        <span class="s2"># how long the tuple is before the call and after the call, and adjust</span>
        <span class="s2"># the new shapes that were added at the end</span>
        <span class="s2"># extract annotation prefixed kwargs</span>
        <span class="s2"># annotation with extra parameters based on the annotation_position</span>
        <span class="s2"># argument and other annotation_ prefixed kwargs</span>
        <span class="s1">shape_kwargs</span><span class="s0">, </span><span class="s1">annotation_kwargs = shapeannotation.split_dict_by_key_prefix(</span>
            <span class="s1">kwargs</span><span class="s0">, </span><span class="s4">&quot;annotation_&quot;</span>
        <span class="s1">)</span>
        <span class="s1">augmented_annotation = shapeannotation.axis_spanning_shape_annotation(</span>
            <span class="s1">annotation</span><span class="s0">, </span><span class="s1">shape_type</span><span class="s0">, </span><span class="s1">shape_args</span><span class="s0">, </span><span class="s1">annotation_kwargs</span>
        <span class="s1">)</span>
        <span class="s1">self.add_shape(</span>
            <span class="s1">row=row</span><span class="s0">,</span>
            <span class="s1">col=col</span><span class="s0">,</span>
            <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
            <span class="s1">**_combine_dicts([shape_args</span><span class="s0">, </span><span class="s1">shape_kwargs])</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">augmented_annotation </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.add_annotation(</span>
                <span class="s1">augmented_annotation</span><span class="s0">,</span>
                <span class="s1">row=row</span><span class="s0">,</span>
                <span class="s1">col=col</span><span class="s0">,</span>
                <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s2"># update xref and yref for the new shapes and annotations</span>
        <span class="s0">for </span><span class="s1">layout_obj</span><span class="s0">, </span><span class="s1">n_layout_objs_before </span><span class="s0">in </span><span class="s1">zip(</span>
            <span class="s1">[</span><span class="s4">&quot;shapes&quot;</span><span class="s0">, </span><span class="s4">&quot;annotations&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[n_shapes_before</span><span class="s0">, </span><span class="s1">n_annotations_before]</span>
        <span class="s1">):</span>
            <span class="s1">n_layout_objs_after = len(self.layout[layout_obj])</span>
            <span class="s0">if </span><span class="s1">(n_layout_objs_after &gt; n_layout_objs_before) </span><span class="s0">and </span><span class="s1">(</span>
                <span class="s1">row </span><span class="s0">is None and </span><span class="s1">col </span><span class="s0">is None</span>
            <span class="s1">):</span>
                <span class="s2"># this was called intending to add to a single plot (and</span>
                <span class="s2"># self.add_{layout_obj} succeeded)</span>
                <span class="s2"># however, in the case of a single plot, xref and yref are not</span>
                <span class="s2"># specified, so we specify them here so the following routines can work</span>
                <span class="s2"># (they need to append &quot; domain&quot; to xref or yref)</span>
                <span class="s1">self.layout[layout_obj][-</span><span class="s5">1</span><span class="s1">].update(xref=</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s1">yref=</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
            <span class="s1">new_layout_objs = tuple(</span>
                <span class="s1">filter(</span>
                    <span class="s0">lambda </span><span class="s1">x: x </span><span class="s0">is not None,</span>
                    <span class="s1">[</span>
                        <span class="s1">self._make_axis_spanning_layout_object(</span>
                            <span class="s1">direction</span><span class="s0">, </span><span class="s1">self.layout[layout_obj][n]</span><span class="s0">,</span>
                        <span class="s1">)</span>
                        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(n_layout_objs_before</span><span class="s0">, </span><span class="s1">n_layout_objs_after)</span>
                    <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">self.layout[layout_obj] = (</span>
                <span class="s1">self.layout[layout_obj][:n_layout_objs_before] + new_layout_objs</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_vline(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">x</span><span class="s0">,</span>
        <span class="s1">row=</span><span class="s4">&quot;all&quot;</span><span class="s0">,</span>
        <span class="s1">col=</span><span class="s4">&quot;all&quot;</span><span class="s0">,</span>
        <span class="s1">exclude_empty_subplots=</span><span class="s0">True,</span>
        <span class="s1">annotation=</span><span class="s0">None,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">self._process_multiple_axis_spanning_shapes(</span>
            <span class="s1">dict(type=</span><span class="s4">&quot;line&quot;</span><span class="s0">, </span><span class="s1">x0=x</span><span class="s0">, </span><span class="s1">x1=x</span><span class="s0">, </span><span class="s1">y0=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">y1=</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">row</span><span class="s0">,</span>
            <span class="s1">col</span><span class="s0">,</span>
            <span class="s4">&quot;vline&quot;</span><span class="s0">,</span>
            <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
            <span class="s1">annotation=annotation</span><span class="s0">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">add_vline.__doc__ = _axis_spanning_shapes_docstr(</span><span class="s4">&quot;vline&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_hline(self</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">exclude_empty_subplots=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._process_multiple_axis_spanning_shapes(</span>
            <span class="s1">dict(type=</span><span class="s4">&quot;line&quot;</span><span class="s0">, </span><span class="s1">x0=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">x1=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">y0=y</span><span class="s0">, </span><span class="s1">y1=y</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">row</span><span class="s0">,</span>
            <span class="s1">col</span><span class="s0">,</span>
            <span class="s4">&quot;hline&quot;</span><span class="s0">,</span>
            <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">add_hline.__doc__ = _axis_spanning_shapes_docstr(</span><span class="s4">&quot;hline&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_vrect(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">exclude_empty_subplots=</span><span class="s0">True, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">self._process_multiple_axis_spanning_shapes(</span>
            <span class="s1">dict(type=</span><span class="s4">&quot;rect&quot;</span><span class="s0">, </span><span class="s1">x0=x0</span><span class="s0">, </span><span class="s1">x1=x1</span><span class="s0">, </span><span class="s1">y0=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">y1=</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">row</span><span class="s0">,</span>
            <span class="s1">col</span><span class="s0">,</span>
            <span class="s4">&quot;vrect&quot;</span><span class="s0">,</span>
            <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">add_vrect.__doc__ = _axis_spanning_shapes_docstr(</span><span class="s4">&quot;vrect&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_hrect(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">exclude_empty_subplots=</span><span class="s0">True, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">self._process_multiple_axis_spanning_shapes(</span>
            <span class="s1">dict(type=</span><span class="s4">&quot;rect&quot;</span><span class="s0">, </span><span class="s1">x0=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">x1=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">y0=y0</span><span class="s0">, </span><span class="s1">y1=y1)</span><span class="s0">,</span>
            <span class="s1">row</span><span class="s0">,</span>
            <span class="s1">col</span><span class="s0">,</span>
            <span class="s4">&quot;hrect&quot;</span><span class="s0">,</span>
            <span class="s1">exclude_empty_subplots=exclude_empty_subplots</span><span class="s0">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">add_hrect.__doc__ = _axis_spanning_shapes_docstr(</span><span class="s4">&quot;hrect&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_has_subplots(self):</span>
        <span class="s3">&quot;&quot;&quot; Returns True if figure contains subplots, otherwise it contains a 
        single plot and so this returns False. &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._grid_ref </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">_subplot_not_empty(self</span><span class="s0">, </span><span class="s1">xref</span><span class="s0">, </span><span class="s1">yref</span><span class="s0">, </span><span class="s1">selector=</span><span class="s4">&quot;all&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        xref: string representing the axis. Objects in the plot will be checked 
              for this xref (for layout objects) or xaxis (for traces) to 
              determine if they lie in a certain subplot. 
        yref: string representing the axis. Objects in the plot will be checked 
              for this yref (for layout objects) or yaxis (for traces) to 
              determine if they lie in a certain subplot. 
        selector: can be &quot;all&quot; or an iterable containing some combination of 
                  &quot;traces&quot;, &quot;shapes&quot;, &quot;annotations&quot;, &quot;images&quot;. Only the presence 
                  of objects specified in selector will be checked. So if 
                  [&quot;traces&quot;,&quot;shapes&quot;] is passed then a plot we be considered 
                  non-empty if it contains traces or shapes. If 
                  bool(selector) returns False, no checking is performed and 
                  this function returns True. If selector is True, it is 
                  converted to &quot;all&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">selector:</span>
            <span class="s2"># If nothing to select was specified then a subplot is always deemed non-empty</span>
            <span class="s0">return True</span>
        <span class="s0">if </span><span class="s1">selector </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">selector = </span><span class="s4">&quot;all&quot;</span>
        <span class="s0">if </span><span class="s1">selector == </span><span class="s4">&quot;all&quot;</span><span class="s1">:</span>
            <span class="s1">selector = [</span><span class="s4">&quot;traces&quot;</span><span class="s0">, </span><span class="s4">&quot;shapes&quot;</span><span class="s0">, </span><span class="s4">&quot;annotations&quot;</span><span class="s0">, </span><span class="s4">&quot;images&quot;</span><span class="s1">]</span>
        <span class="s1">ret = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">selector:</span>
            <span class="s0">if </span><span class="s1">s == </span><span class="s4">&quot;traces&quot;</span><span class="s1">:</span>
                <span class="s1">obj = self.data</span>
                <span class="s1">xaxiskw = </span><span class="s4">&quot;xaxis&quot;</span>
                <span class="s1">yaxiskw = </span><span class="s4">&quot;yaxis&quot;</span>
            <span class="s0">elif </span><span class="s1">s </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;shapes&quot;</span><span class="s0">, </span><span class="s4">&quot;annotations&quot;</span><span class="s0">, </span><span class="s4">&quot;images&quot;</span><span class="s1">]:</span>
                <span class="s1">obj = self.layout[s]</span>
                <span class="s1">xaxiskw = </span><span class="s4">&quot;xref&quot;</span>
                <span class="s1">yaxiskw = </span><span class="s4">&quot;yref&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">obj = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">obj:</span>
                <span class="s1">ret |= any(</span>
                    <span class="s1">t == (xref</span><span class="s0">, </span><span class="s1">yref)</span>
                    <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[</span>
                        <span class="s2"># if a object exists but has no xaxis or yaxis keys, then it</span>
                        <span class="s2"># is plotted with xaxis/xref 'x' and yaxis/yref 'y'</span>
                        <span class="s1">(</span>
                            <span class="s4">&quot;x&quot; </span><span class="s0">if </span><span class="s1">d[xaxiskw] </span><span class="s0">is None else </span><span class="s1">d[xaxiskw]</span><span class="s0">,</span>
                            <span class="s4">&quot;y&quot; </span><span class="s0">if </span><span class="s1">d[yaxiskw] </span><span class="s0">is None else </span><span class="s1">d[yaxiskw]</span><span class="s0">,</span>
                        <span class="s1">)</span>
                        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">obj</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">ret</span>

    <span class="s0">def </span><span class="s1">set_subplots(self</span><span class="s0">, </span><span class="s1">rows=</span><span class="s0">None, </span><span class="s1">cols=</span><span class="s0">None, </span><span class="s1">**make_subplots_args):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add subplots to this figure. If the figure already contains subplots, 
        then this throws an error. Accepts any keyword arguments that 
        plotly.subplots.make_subplots accepts. 
        &quot;&quot;&quot;</span>
        <span class="s2"># rows, cols provided so that this can be called like</span>
        <span class="s2"># fig.set_subplots(2,3), say</span>
        <span class="s0">if </span><span class="s1">rows </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">make_subplots_args[</span><span class="s4">&quot;rows&quot;</span><span class="s1">] = rows</span>
        <span class="s0">if </span><span class="s1">cols </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">make_subplots_args[</span><span class="s4">&quot;cols&quot;</span><span class="s1">] = cols</span>
        <span class="s0">if </span><span class="s1">self._has_subplots():</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;This figure already has subplots.&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">subplots.make_subplots(figure=self</span><span class="s0">, </span><span class="s1">**make_subplots_args)</span>


<span class="s0">class </span><span class="s1">BasePlotlyType(object):</span>
    <span class="s3">&quot;&quot;&quot; 
    BasePlotlyType is the base class for all objects in the trace, layout, 
    and frame object hierarchies 
    &quot;&quot;&quot;</span>

    <span class="s2"># ### Mapped (deprecated) properties ###</span>
    <span class="s2"># dict for deprecated property name (e.g. 'titlefont') to tuple</span>
    <span class="s2"># of relative path to new property (e.g. ('title', 'font')</span>
    <span class="s1">_mapped_properties = {}</span>

    <span class="s1">_parent_path_str = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">_path_str = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">_valid_props = set()</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new BasePlotlyType 
 
        Parameters 
        ---------- 
        plotly_name : str 
            The lowercase name of the plotly object 
        kwargs : dict 
            Invalid props/values to raise on 
        &quot;&quot;&quot;</span>
        <span class="s2"># ### _skip_invalid ##</span>
        <span class="s2"># If True, then invalid properties should be skipped, if False then</span>
        <span class="s2"># invalid properties will result in an exception</span>
        <span class="s1">self._skip_invalid = </span><span class="s0">False</span>

        <span class="s1">self._validate = </span><span class="s0">True</span>

        <span class="s2"># Validate inputs</span>
        <span class="s2"># ---------------</span>
        <span class="s1">self._process_kwargs(**kwargs)</span>

        <span class="s2"># Store params</span>
        <span class="s2"># ------------</span>
        <span class="s1">self._plotly_name = plotly_name</span>

        <span class="s2"># Initialize properties</span>
        <span class="s2"># ---------------------</span>
        <span class="s2"># ### _compound_props ###</span>
        <span class="s2"># A dict from compound property names to compound objects</span>
        <span class="s1">self._compound_props = {}</span>

        <span class="s2"># ### _compound_array_props ###</span>
        <span class="s2"># A dict from compound array property names to tuples of compound</span>
        <span class="s2"># objects</span>
        <span class="s1">self._compound_array_props = {}</span>

        <span class="s2"># ### _orphan_props ###</span>
        <span class="s2"># A dict of properties for use while object has no parent. When</span>
        <span class="s2"># object has a parent, it requests its properties dict from its</span>
        <span class="s2"># parent and doesn't use this.</span>
        <span class="s1">self._orphan_props = {}</span>

        <span class="s2"># ### _parent ###</span>
        <span class="s2"># The parent of the object. May be another BasePlotlyType or it may</span>
        <span class="s2"># be a BaseFigure (as is the case for the Layout and Trace objects)</span>
        <span class="s1">self._parent = </span><span class="s0">None</span>

        <span class="s2"># ### _change_callbacks ###</span>
        <span class="s2"># A dict from tuples of child property path tuples to lists</span>
        <span class="s2"># of callbacks that should be executed whenever any of these</span>
        <span class="s2"># properties is modified</span>
        <span class="s1">self._change_callbacks = {}</span>

        <span class="s2"># ### Backing property for backward compatible _validator property ##</span>
        <span class="s1">self.__validators = </span><span class="s0">None</span>

    <span class="s2"># @property</span>
    <span class="s2"># def _validate(self):</span>
    <span class="s2">#     fig = self.figure</span>
    <span class="s2">#     if fig is None:</span>
    <span class="s2">#         return True</span>
    <span class="s2">#     else:</span>
    <span class="s2">#         return fig._validate</span>

    <span class="s0">def </span><span class="s1">_get_validator(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s0">from </span><span class="s1">.validator_cache </span><span class="s0">import </span><span class="s1">ValidatorCache</span>

        <span class="s0">return </span><span class="s1">ValidatorCache.get_validator(self._path_str</span><span class="s0">, </span><span class="s1">prop)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_validators(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Validators used to be stored in a private _validators property. This was 
        eliminated when we switched to building validators on demand using the 
        _get_validator method. 
 
        This property returns a simple object that 
 
        Returns 
        ------- 
        dict-like interface for accessing the object's validators 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self</span>
        <span class="s0">if </span><span class="s1">self.__validators </span><span class="s0">is None</span><span class="s1">:</span>

            <span class="s0">class </span><span class="s1">ValidatorCompat(object):</span>
                <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
                    <span class="s0">return </span><span class="s1">obj._get_validator(item)</span>

                <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">item):</span>
                    <span class="s0">return </span><span class="s1">obj.__contains__(item)</span>

                <span class="s0">def </span><span class="s1">__iter__(self):</span>
                    <span class="s0">return </span><span class="s1">iter(obj)</span>

                <span class="s0">def </span><span class="s1">items(self):</span>
                    <span class="s0">return </span><span class="s1">[(k</span><span class="s0">, </span><span class="s1">self[k]) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self]</span>

            <span class="s1">self.__validators = ValidatorCompat()</span>

        <span class="s0">return </span><span class="s1">self.__validators</span>

    <span class="s0">def </span><span class="s1">_process_kwargs(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process any extra kwargs that are not predefined as constructor params 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items():</span>
            <span class="s1">err = _check_path_in_prop_tree(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">error_cast=ValueError)</span>
            <span class="s0">if </span><span class="s1">err </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s2"># e.g. underscore kwargs like marker_line_color</span>
                <span class="s1">self[k] = v</span>
            <span class="s0">elif not </span><span class="s1">self._validate:</span>
                <span class="s2"># Set extra property as-is</span>
                <span class="s1">self[k] = v</span>
            <span class="s0">elif not </span><span class="s1">self._skip_invalid:</span>
                <span class="s0">raise </span><span class="s1">err</span>
        <span class="s2"># No need to call _raise_on_invalid_property_error here,</span>
        <span class="s2"># because we have it set up so that the singular case of calling</span>
        <span class="s2"># __setitem__ will raise this. If _check_path_in_prop_tree</span>
        <span class="s2"># raised that in its travels, it will already be in the error</span>
        <span class="s2"># message.</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">plotly_name(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        The plotly name of the object 
 
        Returns 
        ------- 
        str 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._plotly_name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_prop_descriptions(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Formatted string containing all of this obejcts child properties 
        and their descriptions 
 
        Returns 
        ------- 
        str 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_props(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dictionary used to store this object properties.  When the object 
        has a parent, this dict is retreived from the parent. When the 
        object does not have a parent, this dict is the object's 
        `_orphan_props` property 
 
        Note: Property will return None if the object has a parent and the 
        object's properties have not been initialized using the 
        `_init_props` method. 
 
        Returns 
        ------- 
        dict|None 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.parent </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Use orphan data</span>
            <span class="s0">return </span><span class="s1">self._orphan_props</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Get data from parent's dict</span>
            <span class="s0">return </span><span class="s1">self.parent._get_child_props(self)</span>

    <span class="s0">def </span><span class="s1">_get_child_props(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return properties dict for child 
 
        Parameters 
        ---------- 
        child : BasePlotlyType 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._props </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># If this node's properties are uninitialized then so are its</span>
            <span class="s2"># child's</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># ### Child a compound property ###</span>
            <span class="s0">if </span><span class="s1">child.plotly_name </span><span class="s0">in </span><span class="s1">self:</span>
                <span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">(</span>
                    <span class="s1">CompoundValidator</span><span class="s0">,</span>
                    <span class="s1">CompoundArrayValidator</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s1">validator = self._get_validator(child.plotly_name)</span>

                <span class="s0">if </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundValidator):</span>
                    <span class="s0">return </span><span class="s1">self._props.get(child.plotly_name</span><span class="s0">, None</span><span class="s1">)</span>

                <span class="s2"># ### Child an element of a compound array property ###</span>
                <span class="s0">elif </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundArrayValidator):</span>
                    <span class="s1">children = self[child.plotly_name]</span>
                    <span class="s1">child_ind = BaseFigure._index_is(children</span><span class="s0">, </span><span class="s1">child)</span>
                    <span class="s0">assert </span><span class="s1">child_ind </span><span class="s0">is not None</span>

                    <span class="s1">children_props = self._props.get(child.plotly_name</span><span class="s0">, None</span><span class="s1">)</span>
                    <span class="s0">return </span><span class="s1">(</span>
                        <span class="s1">children_props[child_ind]</span>
                        <span class="s0">if </span><span class="s1">children_props </span><span class="s0">is not None</span>
                        <span class="s0">and </span><span class="s1">len(children_props) &gt; child_ind</span>
                        <span class="s0">else None</span>
                    <span class="s1">)</span>

            <span class="s2"># ### Invalid child ###</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid child with name: %s&quot; </span><span class="s1">% child.plotly_name)</span>

    <span class="s0">def </span><span class="s1">_init_props(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Ensure that this object's properties dict has been initialized. When 
        the object has a parent, this ensures that the parent has an 
        initialized properties dict with this object's plotly_name as a key. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s2"># Ensure that _data is initialized.</span>
        <span class="s0">if </span><span class="s1">self._props </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._parent._init_child_props(self)</span>

    <span class="s0">def </span><span class="s1">_init_child_props(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Ensure that a properties dict has been initialized for a child object 
 
        Parameters 
        ---------- 
        child : BasePlotlyType 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s2"># Init our own properties</span>
        <span class="s2"># -----------------------</span>
        <span class="s1">self._init_props()</span>

        <span class="s2"># Child a compound property</span>
        <span class="s2"># -------------------------</span>
        <span class="s0">if </span><span class="s1">child.plotly_name </span><span class="s0">in </span><span class="s1">self._compound_props:</span>
            <span class="s0">if </span><span class="s1">child.plotly_name </span><span class="s0">not in </span><span class="s1">self._props:</span>
                <span class="s1">self._props[child.plotly_name] = {}</span>

        <span class="s2"># Child an element of a compound array property</span>
        <span class="s2"># ---------------------------------------------</span>
        <span class="s0">elif </span><span class="s1">child.plotly_name </span><span class="s0">in </span><span class="s1">self._compound_array_props:</span>
            <span class="s1">children = self._compound_array_props[child.plotly_name]</span>
            <span class="s1">child_ind = BaseFigure._index_is(children</span><span class="s0">, </span><span class="s1">child)</span>
            <span class="s0">assert </span><span class="s1">child_ind </span><span class="s0">is not None</span>

            <span class="s0">if </span><span class="s1">child.plotly_name </span><span class="s0">not in </span><span class="s1">self._props:</span>
                <span class="s2"># Initialize list</span>
                <span class="s1">self._props[child.plotly_name] = []</span>

            <span class="s2"># Make sure list is long enough for child</span>
            <span class="s1">children_list = self._props[child.plotly_name]</span>
            <span class="s0">while </span><span class="s1">len(children_list) &lt;= child_ind:</span>
                <span class="s1">children_list.append({})</span>

        <span class="s2"># Invalid child</span>
        <span class="s2"># -------------</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid child with name: %s&quot; </span><span class="s1">% child.plotly_name)</span>

    <span class="s0">def </span><span class="s1">_get_child_prop_defaults(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return default properties dict for child 
 
        Parameters 
        ---------- 
        child : BasePlotlyType 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._prop_defaults </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># If this node's default properties are uninitialized then so are</span>
            <span class="s2"># its child's</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># ### Child a compound property ###</span>
            <span class="s0">if </span><span class="s1">child.plotly_name </span><span class="s0">in </span><span class="s1">self._compound_props:</span>
                <span class="s0">return </span><span class="s1">self._prop_defaults.get(child.plotly_name</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s2"># ### Child an element of a compound array property ###</span>
            <span class="s0">elif </span><span class="s1">child.plotly_name </span><span class="s0">in </span><span class="s1">self._compound_array_props:</span>
                <span class="s1">children = self._compound_array_props[child.plotly_name]</span>
                <span class="s1">child_ind = BaseFigure._index_is(children</span><span class="s0">, </span><span class="s1">child)</span>

                <span class="s0">assert </span><span class="s1">child_ind </span><span class="s0">is not None</span>

                <span class="s1">children_props = self._prop_defaults.get(child.plotly_name</span><span class="s0">, None</span><span class="s1">)</span>

                <span class="s0">return </span><span class="s1">(</span>
                    <span class="s1">children_props[child_ind]</span>
                    <span class="s0">if </span><span class="s1">children_props </span><span class="s0">is not None and </span><span class="s1">len(children_props) &gt; child_ind</span>
                    <span class="s0">else None</span>
                <span class="s1">)</span>

            <span class="s2"># ### Invalid child ###</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid child with name: %s&quot; </span><span class="s1">% child.plotly_name)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_prop_defaults(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return default properties dict 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.parent </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.parent._get_child_prop_defaults(self)</span>

    <span class="s0">def </span><span class="s1">_get_prop_validator(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the validator associated with the specified property 
 
        Parameters 
        ---------- 
        prop: str 
            A property that exists in this object 
 
        Returns 
        ------- 
        BaseValidator 
        &quot;&quot;&quot;</span>

        <span class="s2"># Handle remapping</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._mapped_properties:</span>
            <span class="s1">prop_path = self._mapped_properties[prop]</span>
            <span class="s1">plotly_obj = self[prop_path[:-</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s1">prop = prop_path[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">prop_path = BaseFigure._str_to_dict_path(prop)</span>
            <span class="s1">plotly_obj = self[prop_path[:-</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s1">prop = prop_path[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2"># Return validator</span>
        <span class="s2"># ----------------</span>
        <span class="s0">return </span><span class="s1">plotly_obj._get_validator(prop)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">parent(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the object's parent, or None if the object has no parent 
        Returns 
        ------- 
        BasePlotlyType|BaseFigure 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._parent</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">figure(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Reference to the top-level Figure or FigureWidget that this object 
        belongs to. None if the object does not belong to a Figure 
 
        Returns 
        ------- 
        Union[BaseFigure, None] 
        &quot;&quot;&quot;</span>
        <span class="s1">top_parent = self</span>
        <span class="s0">while </span><span class="s1">top_parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(top_parent</span><span class="s0">, </span><span class="s1">BaseFigure):</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">top_parent = top_parent.parent</span>

        <span class="s0">return </span><span class="s1">top_parent</span>

    <span class="s2"># Magic Methods</span>
    <span class="s2"># -------------</span>
    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom implementation of reduce is used to support deep copying 
        and pickling 
        &quot;&quot;&quot;</span>
        <span class="s1">props = self.to_plotly_json()</span>
        <span class="s0">return </span><span class="s1">(self.__class__</span><span class="s0">, </span><span class="s1">(props</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get item or nested item from object 
 
        Parameters 
        ---------- 
        prop : str|tuple 
 
            If prop is the name of a property of this object, then the 
            property is returned. 
 
            If prop is a nested property path string (e.g. 'foo[1].bar'), 
            then a nested property is returned (e.g. obj['foo'][1]['bar']) 
 
            If prop is a path tuple (e.g. ('foo', 1, 'bar')), then a nested 
            property is returned (e.g. obj['foo'][1]['bar']). 
 
        Returns 
        ------- 
        Any 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">CompoundValidator</span><span class="s0">,</span>
            <span class="s1">CompoundArrayValidator</span><span class="s0">,</span>
            <span class="s1">BaseDataValidator</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s2"># Normalize prop</span>
        <span class="s2"># --------------</span>
        <span class="s2"># Convert into a property tuple</span>
        <span class="s1">orig_prop = prop</span>
        <span class="s1">prop = BaseFigure._str_to_dict_path(prop)</span>

        <span class="s2"># Handle remapping</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">prop </span><span class="s0">and </span><span class="s1">prop[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">in </span><span class="s1">self._mapped_properties:</span>
            <span class="s1">prop = self._mapped_properties[prop[</span><span class="s5">0</span><span class="s1">]] + prop[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">orig_prop = _remake_path_from_tuple(prop)</span>

        <span class="s2"># Handle scalar case</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># e.g. ('foo',)</span>
        <span class="s0">if </span><span class="s1">len(prop) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># Unwrap scalar tuple</span>
            <span class="s1">prop = prop[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">prop </span><span class="s0">not in </span><span class="s1">self._valid_props:</span>
                <span class="s1">self._raise_on_invalid_property_error(_error_to_raise=PlotlyKeyError)(</span>
                    <span class="s1">prop</span>
                <span class="s1">)</span>

            <span class="s1">validator = self._get_validator(prop)</span>

            <span class="s0">if </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundValidator):</span>
                <span class="s0">if </span><span class="s1">self._compound_props.get(prop</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s2"># Init compound objects</span>
                    <span class="s1">self._compound_props[prop] = validator.data_class(</span>
                        <span class="s1">_parent=self</span><span class="s0">, </span><span class="s1">plotly_name=prop</span>
                    <span class="s1">)</span>
                    <span class="s2"># Update plotly_name value in case the validator applies</span>
                    <span class="s2"># non-standard name (e.g. imagedefaults instead of image)</span>
                    <span class="s1">self._compound_props[prop]._plotly_name = prop</span>

                <span class="s0">return </span><span class="s1">validator.present(self._compound_props[prop])</span>
            <span class="s0">elif </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">(CompoundArrayValidator</span><span class="s0">, </span><span class="s1">BaseDataValidator)):</span>
                <span class="s0">if </span><span class="s1">self._compound_array_props.get(prop</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s2"># Init list of compound objects</span>
                    <span class="s0">if </span><span class="s1">self._props </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">self._compound_array_props[prop] = [</span>
                            <span class="s1">validator.data_class(_parent=self)</span>
                            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self._props.get(prop</span><span class="s0">, </span><span class="s1">[])</span>
                        <span class="s1">]</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self._compound_array_props[prop] = []</span>

                <span class="s0">return </span><span class="s1">validator.present(self._compound_array_props[prop])</span>
            <span class="s0">elif </span><span class="s1">self._props </span><span class="s0">is not None and </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._props:</span>
                <span class="s0">return </span><span class="s1">validator.present(self._props[prop])</span>
            <span class="s0">elif </span><span class="s1">self._prop_defaults </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">validator.present(self._prop_defaults.get(prop</span><span class="s0">, None</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return None</span>

        <span class="s2"># Handle non-scalar case</span>
        <span class="s2"># ----------------------</span>
        <span class="s2"># e.g. ('foo', 1), ()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">err = _check_path_in_prop_tree(self</span><span class="s0">, </span><span class="s1">orig_prop</span><span class="s0">, </span><span class="s1">error_cast=PlotlyKeyError)</span>
            <span class="s0">if </span><span class="s1">err </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">err</span>
            <span class="s1">res = self</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">prop:</span>
                <span class="s1">res = res[p]</span>

            <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Determine whether object contains a property or nested property 
 
        Parameters 
        ---------- 
        prop : str|tuple 
            If prop is a simple string (e.g. 'foo'), then return true of the 
            object contains an element named 'foo' 
 
            If prop is a property path string (e.g. 'foo[0].bar'), 
            then return true if the obejct contains the nested elements for 
            each entry in the path string (e.g. 'bar' in obj['foo'][0]) 
 
            If prop is a property path tuple (e.g. ('foo', 0, 'bar')), 
            then return true if the object contains the nested elements for 
            each entry in the path string (e.g. 'bar' in obj['foo'][0]) 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s1">prop = BaseFigure._str_to_dict_path(prop)</span>

        <span class="s2"># Handle remapping</span>
        <span class="s0">if </span><span class="s1">prop </span><span class="s0">and </span><span class="s1">prop[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">in </span><span class="s1">self._mapped_properties:</span>
            <span class="s1">prop = self._mapped_properties[prop[</span><span class="s5">0</span><span class="s1">]] + prop[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s1">obj = self</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">prop:</span>
            <span class="s0">if </span><span class="s1">isinstance(p</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s5">0 </span><span class="s1">&lt;= p &lt; len(obj):</span>
                    <span class="s1">obj = obj[p]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">obj </span><span class="s0">is not None and </span><span class="s1">p </span><span class="s0">in </span><span class="s1">obj._valid_props:</span>
                    <span class="s1">obj = obj[p]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        prop : str 
            The name of a direct child of this object 
 
            Note: Setting nested properties using property path string or 
            property path tuples is not supported. 
        value 
            New property value 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">CompoundValidator</span><span class="s0">,</span>
            <span class="s1">CompoundArrayValidator</span><span class="s0">,</span>
            <span class="s1">BaseDataValidator</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s2"># Normalize prop</span>
        <span class="s2"># --------------</span>
        <span class="s2"># Convert into a property tuple</span>
        <span class="s1">orig_prop = prop</span>
        <span class="s1">prop = BaseFigure._str_to_dict_path(prop)</span>

        <span class="s2"># Handle empty case</span>
        <span class="s2"># -----------------</span>
        <span class="s0">if </span><span class="s1">len(prop) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError(orig_prop)</span>

        <span class="s2"># Handle remapping</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">prop[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">in </span><span class="s1">self._mapped_properties:</span>
            <span class="s1">prop = self._mapped_properties[prop[</span><span class="s5">0</span><span class="s1">]] + prop[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s2"># Handle scalar case</span>
        <span class="s2"># ------------------</span>
        <span class="s2"># e.g. ('foo',)</span>
        <span class="s0">if </span><span class="s1">len(prop) == </span><span class="s5">1</span><span class="s1">:</span>

            <span class="s2"># ### Unwrap scalar tuple ###</span>
            <span class="s1">prop = prop[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">self._validate:</span>
                <span class="s0">if </span><span class="s1">prop </span><span class="s0">not in </span><span class="s1">self._valid_props:</span>
                    <span class="s1">self._raise_on_invalid_property_error()(prop)</span>

                <span class="s2"># ### Get validator for this property ###</span>
                <span class="s1">validator = self._get_validator(prop)</span>

                <span class="s2"># ### Handle compound property ###</span>
                <span class="s0">if </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundValidator):</span>
                    <span class="s1">self._set_compound_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>

                <span class="s2"># ### Handle compound array property ###</span>
                <span class="s0">elif </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">(CompoundArrayValidator</span><span class="s0">, </span><span class="s1">BaseDataValidator)):</span>
                    <span class="s1">self._set_array_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>

                <span class="s2"># ### Handle simple property ###</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self._set_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Make sure properties dict is initialized</span>
                <span class="s1">self._init_props()</span>

                <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
                    <span class="s2"># Extract json from graph objects</span>
                    <span class="s1">value = value.to_plotly_json()</span>

                <span class="s2"># Check for list/tuple of graph objects</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple))</span>
                    <span class="s0">and </span><span class="s1">value</span>
                    <span class="s0">and </span><span class="s1">isinstance(value[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">BasePlotlyType)</span>
                <span class="s1">):</span>
                    <span class="s1">value = [</span>
                        <span class="s1">v.to_plotly_json() </span><span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">BasePlotlyType) </span><span class="s0">else </span><span class="s1">v</span>
                        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value</span>
                    <span class="s1">]</span>

                <span class="s1">self._props[prop] = value</span>

                <span class="s2"># Remove any already constructed graph object so that it will be</span>
                <span class="s2"># reconstructed on property access</span>
                <span class="s1">self._compound_props.pop(prop</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">self._compound_array_props.pop(prop</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s2"># Handle non-scalar case</span>
        <span class="s2"># ----------------------</span>
        <span class="s2"># e.g. ('foo', 1), ()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">err = _check_path_in_prop_tree(self</span><span class="s0">, </span><span class="s1">orig_prop</span><span class="s0">, </span><span class="s1">error_cast=ValueError)</span>
            <span class="s0">if </span><span class="s1">err </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">err</span>
            <span class="s1">res = self</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">prop[:-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">res = res[p]</span>

            <span class="s1">res._validate = self._validate</span>

            <span class="s1">res[prop[-</span><span class="s5">1</span><span class="s1">]] = value</span>

    <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        prop : str 
            The name of a direct child of this object 
        value 
            New property value 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">prop.startswith(</span><span class="s4">&quot;_&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s1">prop) </span><span class="s0">or </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._valid_props:</span>
            <span class="s2"># Let known properties and private properties through</span>
            <span class="s1">super(BasePlotlyType</span><span class="s0">, </span><span class="s1">self).__setattr__(prop</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Raise error on unknown public properties</span>
            <span class="s1">self._raise_on_invalid_property_error()(prop)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return an iterator over the object's properties 
        &quot;&quot;&quot;</span>
        <span class="s1">res = list(self._valid_props)</span>
        <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._mapped_properties:</span>
            <span class="s1">res.append(prop)</span>
        <span class="s0">return </span><span class="s1">iter(res)</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test for equality 
 
        To be considered equal, `other` must have the same type as this object 
        and their `to_plotly_json` representaitons must be identical. 
 
        Parameters 
        ---------- 
        other 
            The object to compare against 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">self.__class__):</span>
            <span class="s2"># Require objects to be of the same plotly type</span>
            <span class="s0">return False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Compare plotly_json representations</span>

            <span class="s2"># Use _vals_equal instead of `==` to handle cases where</span>
            <span class="s2"># underlying dicts contain numpy arrays</span>
            <span class="s0">return </span><span class="s1">BasePlotlyType._vals_equal(</span>
                <span class="s1">self._props </span><span class="s0">if </span><span class="s1">self._props </span><span class="s0">is not None else </span><span class="s1">{}</span><span class="s0">,</span>
                <span class="s1">other._props </span><span class="s0">if </span><span class="s1">other._props </span><span class="s0">is not None else </span><span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_build_repr_for_class(props</span><span class="s0">, </span><span class="s1">class_name</span><span class="s0">, </span><span class="s1">parent_path_str=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Helper to build representation string for a class 
 
        Parameters 
        ---------- 
        class_name : str 
            Name of the class being represented 
        parent_path_str : str of None (default) 
            Name of the class's parent package to display 
        props : dict 
            Properties to unpack into the constructor 
 
        Returns 
        ------- 
        str 
            The representation string 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">plotly.utils </span><span class="s0">import </span><span class="s1">ElidedPrettyPrinter</span>

        <span class="s0">if </span><span class="s1">parent_path_str:</span>
            <span class="s1">class_name = parent_path_str + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ class_name</span>

        <span class="s0">if </span><span class="s1">len(props) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">repr_str = class_name + </span><span class="s4">&quot;()&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pprinter = ElidedPrettyPrinter(threshold=</span><span class="s5">200</span><span class="s0">, </span><span class="s1">width=</span><span class="s5">120</span><span class="s1">)</span>
            <span class="s1">pprint_res = pprinter.pformat(props)</span>

            <span class="s2"># pprint_res is indented by 1 space. Add extra 3 spaces for PEP8</span>
            <span class="s2"># complaint indent</span>
            <span class="s1">body = </span><span class="s4">&quot;   &quot; </span><span class="s1">+ pprint_res[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">].replace(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s4">&quot;</span><span class="s0">\n   </span><span class="s4">&quot;</span><span class="s1">)</span>

            <span class="s1">repr_str = class_name + </span><span class="s4">&quot;({</span><span class="s0">\n </span><span class="s4">&quot; </span><span class="s1">+ body + </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">})&quot;</span>

        <span class="s0">return </span><span class="s1">repr_str</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Customize object representation when displayed in the 
        terminal/notebook 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">LiteralValidator</span>

        <span class="s2"># Get all properties</span>
        <span class="s1">props = self._props </span><span class="s0">if </span><span class="s1">self._props </span><span class="s0">is not None else </span><span class="s1">{}</span>

        <span class="s2"># Remove literals (These can't be specified in the constructor)</span>
        <span class="s1">props = {</span>
            <span class="s1">p: v</span>
            <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">props.items()</span>
            <span class="s0">if </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self._valid_props</span>
            <span class="s0">and not </span><span class="s1">isinstance(self._get_validator(p)</span><span class="s0">, </span><span class="s1">LiteralValidator)</span>
        <span class="s1">}</span>

        <span class="s2"># Elide template</span>
        <span class="s0">if </span><span class="s4">&quot;template&quot; </span><span class="s0">in </span><span class="s1">props:</span>
            <span class="s1">props[</span><span class="s4">&quot;template&quot;</span><span class="s1">] = </span><span class="s4">&quot;...&quot;</span>

        <span class="s2"># Build repr string</span>
        <span class="s1">repr_str = BasePlotlyType._build_repr_for_class(</span>
            <span class="s1">props=props</span><span class="s0">,</span>
            <span class="s1">class_name=self.__class__.__name__</span><span class="s0">,</span>
            <span class="s1">parent_path_str=self._parent_path_str</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">repr_str</span>

    <span class="s0">def </span><span class="s1">_raise_on_invalid_property_error(self</span><span class="s0">, </span><span class="s1">_error_to_raise=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a function that raises informative exception when invalid 
        property names are encountered. The _error_to_raise argument allows 
        specifying the exception to raise, which is ValueError if None. 
 
        Parameters 
        ---------- 
        args : list[str] 
            List of property names that have already been determined to be 
            invalid 
 
        Raises 
        ------ 
        ValueError by default, or _error_to_raise if not None 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">_error_to_raise </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">_error_to_raise = ValueError</span>

        <span class="s0">def </span><span class="s1">_ret(*args):</span>
            <span class="s1">invalid_props = args</span>
            <span class="s0">if </span><span class="s1">invalid_props:</span>
                <span class="s0">if </span><span class="s1">len(invalid_props) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">prop_str = </span><span class="s4">&quot;property&quot;</span>
                    <span class="s1">invalid_str = repr(invalid_props[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">prop_str = </span><span class="s4">&quot;properties&quot;</span>
                    <span class="s1">invalid_str = repr(invalid_props)</span>

                <span class="s1">module_root = </span><span class="s4">&quot;plotly.graph_objs.&quot;</span>
                <span class="s0">if </span><span class="s1">self._parent_path_str:</span>
                    <span class="s1">full_obj_name = (</span>
                        <span class="s1">module_root</span>
                        <span class="s1">+ self._parent_path_str</span>
                        <span class="s1">+ </span><span class="s4">&quot;.&quot;</span>
                        <span class="s1">+ self.__class__.__name__</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">full_obj_name = module_root + self.__class__.__name__</span>

                <span class="s1">guessed_prop = </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s1">len(invalid_props) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">guessed_prop = find_closest_string(</span>
                            <span class="s1">invalid_props[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self._valid_props</span>
                        <span class="s1">)</span>
                    <span class="s0">except </span><span class="s1">Exception:</span>
                        <span class="s0">pass</span>
                <span class="s1">guessed_prop_suggestion = </span><span class="s4">&quot;&quot;</span>
                <span class="s0">if </span><span class="s1">guessed_prop </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">guessed_prop_suggestion = </span><span class="s4">'Did you mean &quot;%s&quot;?' </span><span class="s1">% (guessed_prop</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">_error_to_raise(</span>
                    <span class="s4">&quot;Invalid {prop_str} specified for object of type &quot;</span>
                    <span class="s4">&quot;{full_obj_name}: {invalid_str}</span><span class="s0">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">{guessed_prop_suggestion}</span><span class="s0">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;</span><span class="s0">\n    </span><span class="s4">Valid properties:</span><span class="s0">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;{prop_descriptions}&quot;</span>
                    <span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">{guessed_prop_suggestion}</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.format(</span>
                        <span class="s1">prop_str=prop_str</span><span class="s0">,</span>
                        <span class="s1">full_obj_name=full_obj_name</span><span class="s0">,</span>
                        <span class="s1">invalid_str=invalid_str</span><span class="s0">,</span>
                        <span class="s1">prop_descriptions=self._prop_descriptions</span><span class="s0">,</span>
                        <span class="s1">guessed_prop_suggestion=guessed_prop_suggestion</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">_ret</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">dict1=</span><span class="s0">None, </span><span class="s1">overwrite=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Update the properties of an object with a dict and/or with 
        keyword arguments. 
 
        This recursively updates the structure of the original 
        object with the values in the input dict / keyword arguments. 
 
        Parameters 
        ---------- 
        dict1 : dict 
            Dictionary of properties to be updated 
        overwrite: bool 
            If True, overwrite existing properties. If False, apply updates 
            to existing properties recursively, preserving existing 
            properties that are not specified in the update operation. 
        kwargs : 
            Keyword/value pair of properties to be updated 
 
        Returns 
        ------- 
        BasePlotlyType 
            Updated plotly object 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.figure:</span>
            <span class="s0">with </span><span class="s1">self.figure.batch_update():</span>
                <span class="s1">BaseFigure._perform_update(self</span><span class="s0">, </span><span class="s1">dict1</span><span class="s0">, </span><span class="s1">overwrite=overwrite)</span>
                <span class="s1">BaseFigure._perform_update(self</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">overwrite=overwrite)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">BaseFigure._perform_update(self</span><span class="s0">, </span><span class="s1">dict1</span><span class="s0">, </span><span class="s1">overwrite=overwrite)</span>
            <span class="s1">BaseFigure._perform_update(self</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">overwrite=overwrite)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">pop(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s3">&quot;&quot;&quot; 
        Remove the value associated with the specified key and return it 
 
        Parameters 
        ---------- 
        key: str 
            Property name 
        dflt 
            The default value to return if key was not found in object 
 
        Returns 
        ------- 
        value 
            The removed value that was previously associated with key 
 
        Raises 
        ------ 
        KeyError 
            If key is not in object and no dflt argument specified 
        &quot;&quot;&quot;</span>
        <span class="s2"># Handle default</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self </span><span class="s0">and </span><span class="s1">args:</span>
            <span class="s0">return </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s1">val = self[key]</span>
            <span class="s1">self[key] = </span><span class="s0">None</span>
            <span class="s0">return </span><span class="s1">val</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_in_batch_mode(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        True if the object belongs to a figure that is currently in batch mode 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.parent </span><span class="s0">and </span><span class="s1">self.parent._in_batch_mode</span>

    <span class="s0">def </span><span class="s1">_set_prop(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the value of a simple property 
 
        Parameters 
        ---------- 
        prop : str 
            Name of a simple (non-compound, non-array) property 
        val 
            The new property value 
 
        Returns 
        ------- 
        Any 
            The coerced assigned value 
        &quot;&quot;&quot;</span>

        <span class="s2"># val is Undefined</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">val </span><span class="s0">is </span><span class="s1">Undefined:</span>
            <span class="s2"># Do nothing</span>
            <span class="s0">return</span>

        <span class="s2"># Import value</span>
        <span class="s2"># ------------</span>
        <span class="s1">validator = self._get_validator(prop)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">val = validator.validate_coerce(val)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s0">if </span><span class="s1">self._skip_invalid:</span>
                <span class="s0">return</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">err</span>

        <span class="s2"># val is None</span>
        <span class="s2"># -----------</span>
        <span class="s0">if </span><span class="s1">val </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Check if we should send null update</span>
            <span class="s0">if </span><span class="s1">self._props </span><span class="s0">and </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._props:</span>
                <span class="s2"># Remove property if not in batch mode</span>
                <span class="s0">if not </span><span class="s1">self._in_batch_mode:</span>
                    <span class="s1">self._props.pop(prop)</span>

                <span class="s2"># Send property update message</span>
                <span class="s1">self._send_prop_set(prop</span><span class="s0">, </span><span class="s1">val)</span>

        <span class="s2"># val is valid value</span>
        <span class="s2"># ------------------</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Make sure properties dict is initialized</span>
            <span class="s1">self._init_props()</span>

            <span class="s2"># Check whether the value is a change</span>
            <span class="s0">if </span><span class="s1">prop </span><span class="s0">not in </span><span class="s1">self._props </span><span class="s0">or not </span><span class="s1">BasePlotlyType._vals_equal(</span>
                <span class="s1">self._props[prop]</span><span class="s0">, </span><span class="s1">val</span>
            <span class="s1">):</span>
                <span class="s2"># Set property value if not in batch mode</span>
                <span class="s0">if not </span><span class="s1">self._in_batch_mode:</span>
                    <span class="s1">self._props[prop] = val</span>

                <span class="s2"># Send property update message</span>
                <span class="s1">self._send_prop_set(prop</span><span class="s0">, </span><span class="s1">val)</span>

        <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">_set_compound_prop(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the value of a compound property 
 
        Parameters 
        ---------- 
        prop : str 
            Name of a compound property 
        val 
            The new property value 
 
        Returns 
        ------- 
        BasePlotlyType 
            The coerced assigned object 
        &quot;&quot;&quot;</span>

        <span class="s2"># val is Undefined</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">val </span><span class="s0">is </span><span class="s1">Undefined:</span>
            <span class="s2"># Do nothing</span>
            <span class="s0">return</span>

        <span class="s2"># Import value</span>
        <span class="s2"># ------------</span>
        <span class="s1">validator = self._get_validator(prop)</span>
        <span class="s1">val = validator.validate_coerce(val</span><span class="s0">, </span><span class="s1">skip_invalid=self._skip_invalid)</span>

        <span class="s2"># Save deep copies of current and new states</span>
        <span class="s2"># ------------------------------------------</span>
        <span class="s1">curr_val = self._compound_props.get(prop</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">curr_val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">curr_dict_val = deepcopy(curr_val._props)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">curr_dict_val = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">new_dict_val = deepcopy(val._props)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_dict_val = </span><span class="s0">None</span>

        <span class="s2"># Update _props dict</span>
        <span class="s2"># ------------------</span>
        <span class="s0">if not </span><span class="s1">self._in_batch_mode:</span>
            <span class="s0">if not </span><span class="s1">new_dict_val:</span>
                <span class="s0">if </span><span class="s1">self._props </span><span class="s0">and </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._props:</span>
                    <span class="s1">self._props.pop(prop)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._init_props()</span>
                <span class="s1">self._props[prop] = new_dict_val</span>

        <span class="s2"># Send update if there was a change in value</span>
        <span class="s2"># ------------------------------------------</span>
        <span class="s0">if not </span><span class="s1">BasePlotlyType._vals_equal(curr_dict_val</span><span class="s0">, </span><span class="s1">new_dict_val):</span>
            <span class="s1">self._send_prop_set(prop</span><span class="s0">, </span><span class="s1">new_dict_val)</span>

        <span class="s2"># Reparent</span>
        <span class="s2"># --------</span>
        <span class="s2"># ### Reparent new value and clear orphan data ###</span>
        <span class="s0">if </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">BasePlotlyType):</span>
            <span class="s1">val._parent = self</span>
            <span class="s1">val._orphan_props.clear()</span>

        <span class="s2"># ### Unparent old value and update orphan data ###</span>
        <span class="s0">if </span><span class="s1">curr_val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">curr_dict_val </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">curr_val._orphan_props.update(curr_dict_val)</span>
            <span class="s1">curr_val._parent = </span><span class="s0">None</span>

        <span class="s2"># Update _compound_props</span>
        <span class="s2"># ----------------------</span>
        <span class="s1">self._compound_props[prop] = val</span>
        <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">_set_array_prop(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the value of a compound property 
 
        Parameters 
        ---------- 
        prop : str 
            Name of a compound property 
        val 
            The new property value 
 
        Returns 
        ------- 
        tuple[BasePlotlyType] 
            The coerced assigned object 
        &quot;&quot;&quot;</span>

        <span class="s2"># val is Undefined</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">val </span><span class="s0">is </span><span class="s1">Undefined:</span>
            <span class="s2"># Do nothing</span>
            <span class="s0">return</span>

        <span class="s2"># Import value</span>
        <span class="s2"># ------------</span>
        <span class="s1">validator = self._get_validator(prop)</span>
        <span class="s1">val = validator.validate_coerce(val</span><span class="s0">, </span><span class="s1">skip_invalid=self._skip_invalid)</span>

        <span class="s2"># Save deep copies of current and new states</span>
        <span class="s2"># ------------------------------------------</span>
        <span class="s1">curr_val = self._compound_array_props.get(prop</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">curr_val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">curr_dict_vals = [deepcopy(cv._props) </span><span class="s0">for </span><span class="s1">cv </span><span class="s0">in </span><span class="s1">curr_val]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">curr_dict_vals = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">new_dict_vals = [deepcopy(nv._props) </span><span class="s0">for </span><span class="s1">nv </span><span class="s0">in </span><span class="s1">val]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_dict_vals = </span><span class="s0">None</span>

        <span class="s2"># Update _props dict</span>
        <span class="s2"># ------------------</span>
        <span class="s0">if not </span><span class="s1">self._in_batch_mode:</span>
            <span class="s0">if not </span><span class="s1">new_dict_vals:</span>
                <span class="s0">if </span><span class="s1">self._props </span><span class="s0">and </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._props:</span>
                    <span class="s1">self._props.pop(prop)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._init_props()</span>
                <span class="s1">self._props[prop] = new_dict_vals</span>

        <span class="s2"># Send update if there was a change in value</span>
        <span class="s2"># ------------------------------------------</span>
        <span class="s0">if not </span><span class="s1">BasePlotlyType._vals_equal(curr_dict_vals</span><span class="s0">, </span><span class="s1">new_dict_vals):</span>
            <span class="s1">self._send_prop_set(prop</span><span class="s0">, </span><span class="s1">new_dict_vals)</span>

        <span class="s2"># Reparent</span>
        <span class="s2"># --------</span>
        <span class="s2"># ### Reparent new values and clear orphan data ###</span>
        <span class="s0">if </span><span class="s1">val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">val:</span>
                <span class="s1">v._orphan_props.clear()</span>
                <span class="s1">v._parent = self</span>

        <span class="s2"># ### Unparent old value and update orphan data ###</span>
        <span class="s0">if </span><span class="s1">curr_val </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">cv</span><span class="s0">, </span><span class="s1">cv_dict </span><span class="s0">in </span><span class="s1">zip(curr_val</span><span class="s0">, </span><span class="s1">curr_dict_vals):</span>
                <span class="s0">if </span><span class="s1">cv_dict </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">cv._orphan_props.update(cv_dict)</span>
                <span class="s1">cv._parent = </span><span class="s0">None</span>

        <span class="s2"># Update _compound_array_props</span>
        <span class="s2"># ----------------------------</span>
        <span class="s1">self._compound_array_props[prop] = val</span>
        <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">_send_prop_set(self</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Notify parent that a property has been set to a new value 
 
        Parameters 
        ---------- 
        prop_path_str : str 
            Property path string (e.g. 'foo[0].bar') of property that 
            was set, relative to this object 
        val 
            New value for property. Either a simple value, a dict, 
            or a tuple of dicts. This should *not* be a BasePlotlyType object. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_prop_set_child(self</span><span class="s0">, </span><span class="s1">child</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Propagate property setting notification from child to parent 
 
        Parameters 
        ---------- 
        child : BasePlotlyType 
            Child object 
        prop_path_str : str 
            Property path string (e.g. 'foo[0].bar') of property that 
            was set, relative to `child` 
        val 
            New value for property. Either a simple value, a dict, 
            or a tuple of dicts. This should *not* be a BasePlotlyType object. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Child is compound array property</span>
        <span class="s2"># --------------------------------</span>
        <span class="s1">child_prop_val = getattr(self</span><span class="s0">, </span><span class="s1">child.plotly_name)</span>
        <span class="s0">if </span><span class="s1">isinstance(child_prop_val</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">child_ind = BaseFigure._index_is(child_prop_val</span><span class="s0">, </span><span class="s1">child)</span>
            <span class="s1">obj_path = </span><span class="s4">&quot;{child_name}.{child_ind}.{prop}&quot;</span><span class="s1">.format(</span>
                <span class="s1">child_name=child.plotly_name</span><span class="s0">, </span><span class="s1">child_ind=child_ind</span><span class="s0">, </span><span class="s1">prop=prop_path_str</span>
            <span class="s1">)</span>

        <span class="s2"># Child is compound property</span>
        <span class="s2"># --------------------------</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">obj_path = </span><span class="s4">&quot;{child_name}.{prop}&quot;</span><span class="s1">.format(</span>
                <span class="s1">child_name=child.plotly_name</span><span class="s0">, </span><span class="s1">prop=prop_path_str</span>
            <span class="s1">)</span>

        <span class="s2"># Propagate to parent</span>
        <span class="s2"># -------------------</span>
        <span class="s1">self._send_prop_set(obj_path</span><span class="s0">, </span><span class="s1">val)</span>

    <span class="s0">def </span><span class="s1">_restyle_child(self</span><span class="s0">, </span><span class="s1">child</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Propagate _restyle_child to parent 
 
        Note: This method must match the name and signature of the 
        corresponding method on BaseFigure 
        &quot;&quot;&quot;</span>
        <span class="s1">self._prop_set_child(child</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val)</span>

    <span class="s0">def </span><span class="s1">_relayout_child(self</span><span class="s0">, </span><span class="s1">child</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s3">&quot;&quot;&quot; 
        Propagate _relayout_child to parent 
 
        Note: This method must match the name and signature of the 
        corresponding method on BaseFigure 
        &quot;&quot;&quot;</span>
        <span class="s1">self._prop_set_child(child</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">val)</span>

    <span class="s2"># Callbacks</span>
    <span class="s2"># ---------</span>
    <span class="s0">def </span><span class="s1">_dispatch_change_callbacks(self</span><span class="s0">, </span><span class="s1">changed_paths):</span>
        <span class="s3">&quot;&quot;&quot; 
        Execute the appropriate change callback functions given a set of 
        changed property path tuples 
 
        Parameters 
        ---------- 
        changed_paths : set[tuple[int|str]] 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s2"># Loop over registered callbacks</span>
        <span class="s2"># ------------------------------</span>
        <span class="s0">for </span><span class="s1">prop_path_tuples</span><span class="s0">, </span><span class="s1">callbacks </span><span class="s0">in </span><span class="s1">self._change_callbacks.items():</span>
            <span class="s2"># ### Compute callback paths that changed ###</span>
            <span class="s1">common_paths = changed_paths.intersection(set(prop_path_tuples))</span>
            <span class="s0">if </span><span class="s1">common_paths:</span>

                <span class="s2"># #### Invoke callback ####</span>
                <span class="s1">callback_args = [self[cb_path] </span><span class="s0">for </span><span class="s1">cb_path </span><span class="s0">in </span><span class="s1">prop_path_tuples]</span>

                <span class="s0">for </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">callbacks:</span>
                    <span class="s1">callback(self</span><span class="s0">, </span><span class="s1">*callback_args)</span>

    <span class="s0">def </span><span class="s1">on_change(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Register callback function to be called when certain properties or 
        subproperties of this object are modified. 
 
        Callback will be invoked whenever ANY of these properties is 
        modified. Furthermore, the callback will only be invoked once even 
        if multiple properties are modified during the same restyle / 
        relayout / update operation. 
 
        Parameters 
        ---------- 
        callback : function 
            Function that accepts 1 + len(`args`) parameters. First parameter 
            is this object. Second through last parameters are the 
            property / subpropery values referenced by args. 
        args : list[str|tuple[int|str]] 
            List of property references where each reference may be one of: 
 
              1) A property name string (e.g. 'foo') for direct properties 
              2) A property path string (e.g. 'foo[0].bar') for 
                 subproperties 
              3) A property path tuple (e.g. ('foo', 0, 'bar')) for 
                 subproperties 
 
        append : bool 
            True if callback should be appended to previously registered 
            callback on the same properties, False if callback should replace 
            previously registered callbacks on the same properties. Defaults 
            to False. 
 
        Examples 
        -------- 
 
        Register callback that prints out the range extents of the xaxis and 
        yaxis whenever either either of them changes. 
 
        &gt;&gt;&gt; import plotly.graph_objects as go 
        &gt;&gt;&gt; fig = go.Figure(go.Scatter(x=[1, 2], y=[1, 0])) 
        &gt;&gt;&gt; fig.layout.on_change( 
        ...   lambda obj, xrange, yrange: print(&quot;%s-%s&quot; % (xrange, yrange)), 
        ...   ('xaxis', 'range'), ('yaxis', 'range')) 
 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>

        <span class="s2"># Warn if object not descendent of a figure</span>
        <span class="s2"># -----------------------------------------</span>
        <span class="s0">if not </span><span class="s1">self.figure:</span>
            <span class="s1">class_name = self.__class__.__name__</span>
            <span class="s1">msg = </span><span class="s4">&quot;&quot;&quot; 
{class_name} object is not a descendant of a Figure. 
on_change callbacks are not supported in this case. 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">class_name=class_name</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2"># Validate args not empty</span>
        <span class="s2"># -----------------------</span>
        <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;At least one change property must be specified&quot;</span><span class="s1">)</span>

        <span class="s2"># Validate args</span>
        <span class="s2"># -------------</span>
        <span class="s1">invalid_args = [arg </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args </span><span class="s0">if </span><span class="s1">arg </span><span class="s0">not in </span><span class="s1">self]</span>
        <span class="s0">if </span><span class="s1">invalid_args:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid property specification(s): %s&quot; </span><span class="s1">% invalid_args)</span>

        <span class="s2"># Process append option</span>
        <span class="s2"># ---------------------</span>
        <span class="s1">append = kwargs.get(</span><span class="s4">&quot;append&quot;</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># Normalize args to path tuples</span>
        <span class="s2"># -----------------------------</span>
        <span class="s1">arg_tuples = tuple([BaseFigure._str_to_dict_path(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args])</span>

        <span class="s2"># Initialize callbacks list</span>
        <span class="s2"># -------------------------</span>
        <span class="s2"># Initialize an empty callbacks list if there are no previously</span>
        <span class="s2"># defined callbacks for this collection of args, or if append is False</span>
        <span class="s0">if </span><span class="s1">arg_tuples </span><span class="s0">not in </span><span class="s1">self._change_callbacks </span><span class="s0">or not </span><span class="s1">append:</span>
            <span class="s1">self._change_callbacks[arg_tuples] = []</span>

        <span class="s2"># Register callback</span>
        <span class="s2"># -----------------</span>
        <span class="s1">self._change_callbacks[arg_tuples].append(callback)</span>

    <span class="s0">def </span><span class="s1">to_plotly_json(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return plotly JSON representation of object as a Python dict 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">deepcopy(self._props </span><span class="s0">if </span><span class="s1">self._props </span><span class="s0">is not None else </span><span class="s1">{})</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_vals_equal(v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s3">&quot;&quot;&quot; 
        Recursive equality function that handles nested dicts / tuples / lists 
        that contain numpy arrays. 
 
        v1 
            First value to compare 
        v2 
            Second value to compare 
 
        Returns 
        ------- 
        bool 
            True if v1 and v2 are equal, False otherwise 
        &quot;&quot;&quot;</span>
        <span class="s1">np = get_module(</span><span class="s4">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">should_load=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">np </span><span class="s0">is not None and </span><span class="s1">(</span>
            <span class="s1">isinstance(v1</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">or </span><span class="s1">isinstance(v2</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s1">):</span>
            <span class="s0">return </span><span class="s1">np.array_equal(v1</span><span class="s0">, </span><span class="s1">v2)</span>
        <span class="s0">elif </span><span class="s1">isinstance(v1</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s2"># Handle recursive equality on lists and tuples</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s1">isinstance(v2</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple))</span>
                <span class="s0">and </span><span class="s1">len(v1) == len(v2)</span>
                <span class="s0">and </span><span class="s1">all(BasePlotlyType._vals_equal(e1</span><span class="s0">, </span><span class="s1">e2) </span><span class="s0">for </span><span class="s1">e1</span><span class="s0">, </span><span class="s1">e2 </span><span class="s0">in </span><span class="s1">zip(v1</span><span class="s0">, </span><span class="s1">v2))</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(v1</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s2"># Handle recursive equality on dicts</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s1">isinstance(v2</span><span class="s0">, </span><span class="s1">dict)</span>
                <span class="s0">and </span><span class="s1">set(v1.keys()) == set(v2.keys())</span>
                <span class="s0">and </span><span class="s1">all(BasePlotlyType._vals_equal(v1[k]</span><span class="s0">, </span><span class="s1">v2[k]) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">v1)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">v1 == v2</span>


<span class="s0">class </span><span class="s1">BaseLayoutHierarchyType(BasePlotlyType):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for all types in the layout hierarchy 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_parent_path_str(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__init__(plotly_name</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">_send_prop_set(self</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s0">if </span><span class="s1">self.parent:</span>
            <span class="s2"># ### Inform parent of relayout operation ###</span>
            <span class="s1">self.parent._relayout_child(self</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val)</span>


<span class="s0">class </span><span class="s1">BaseLayoutType(BaseLayoutHierarchyType):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for the layout type. The Layout class itself is a 
    code-generated subclass. 
    &quot;&quot;&quot;</span>

    <span class="s2"># Dynamic properties</span>
    <span class="s2"># ------------------</span>
    <span class="s2"># Unlike all other plotly types, BaseLayoutType has dynamic properties.</span>
    <span class="s2"># These are used when a layout has multiple instances of subplot types</span>
    <span class="s2"># (xaxis2, yaxis3, geo4, etc.)</span>
    <span class="s2">#</span>
    <span class="s2"># The base version of each suplot type is defined in the schema and code</span>
    <span class="s2"># generated. So the Layout subclass has statically defined properties</span>
    <span class="s2"># for xaxis, yaxis, geo, ternary, and scene. But, we need to dynamically</span>
    <span class="s2"># generated properties/validators as needed for xaxis2, yaxis3, etc.</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_subplotid_validators(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        dict of validator classes for each subplot type 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_subplot_re_match(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new BaseLayoutType object 
 
        Parameters 
        ---------- 
        plotly_name : str 
            Name of the object (should always be 'layout') 
        kwargs : dict[str, any] 
            Properties that were not recognized by the Layout subclass. 
            These are subplot identifiers (xaxis2, geo4, etc.) or they are 
            invalid properties. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Validate inputs</span>
        <span class="s2"># ---------------</span>
        <span class="s0">assert </span><span class="s1">plotly_name == </span><span class="s4">&quot;layout&quot;</span>

        <span class="s2"># Call superclass constructor</span>
        <span class="s2"># ---------------------------</span>
        <span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__init__(plotly_name)</span>

        <span class="s2"># Initialize _subplotid_props</span>
        <span class="s2"># ---------------------------</span>
        <span class="s2"># This is a set storing the names of the layout's dynamic subplot</span>
        <span class="s2"># properties</span>
        <span class="s1">self._subplotid_props = set()</span>

        <span class="s2"># Process kwargs</span>
        <span class="s2"># --------------</span>
        <span class="s1">self._process_kwargs(**kwargs)</span>

    <span class="s0">def </span><span class="s1">_process_kwargs(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process any extra kwargs that are not predefined as constructor params 
        &quot;&quot;&quot;</span>
        <span class="s1">unknown_kwargs = {</span>
            <span class="s1">k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items() </span><span class="s0">if not </span><span class="s1">self._subplot_re_match(k)</span>
        <span class="s1">}</span>
        <span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self)._process_kwargs(**unknown_kwargs)</span>

        <span class="s1">subplot_kwargs = {k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items() </span><span class="s0">if </span><span class="s1">self._subplot_re_match(k)}</span>

        <span class="s0">for </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">subplot_kwargs.items():</span>
            <span class="s1">self._set_subplotid_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">_set_subplotid_prop(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set a subplot property on the layout 
 
        Parameters 
        ---------- 
        prop : str 
            A valid subplot property 
        value 
            Subplot value 
        &quot;&quot;&quot;</span>
        <span class="s2"># Get regular expression match</span>
        <span class="s2"># ----------------------------</span>
        <span class="s2"># Note: we already tested that match exists in the constructor</span>
        <span class="s1">match = self._subplot_re_match(prop)</span>
        <span class="s1">subplot_prop = match.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">suffix_digit = int(match.group(</span><span class="s5">2</span><span class="s1">))</span>

        <span class="s2"># Validate suffix digit</span>
        <span class="s2"># ---------------------</span>
        <span class="s0">if </span><span class="s1">suffix_digit == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Subplot properties may only be suffixed by an &quot;</span>
                <span class="s4">&quot;integer &gt;= 1</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Received {k}&quot;</span><span class="s1">.format(k=prop)</span>
            <span class="s1">)</span>

        <span class="s2"># Handle suffix_digit == 1</span>
        <span class="s2"># ------------------------</span>
        <span class="s2"># In this case we remove suffix digit (e.g. xaxis1 -&gt; xaxis)</span>
        <span class="s0">if </span><span class="s1">suffix_digit == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">prop = subplot_prop</span>

        <span class="s2"># Construct and add validator</span>
        <span class="s2"># ---------------------------</span>
        <span class="s0">if </span><span class="s1">prop </span><span class="s0">not in </span><span class="s1">self._valid_props:</span>
            <span class="s1">self._valid_props.add(prop)</span>

        <span class="s2"># Import value</span>
        <span class="s2"># ------------</span>
        <span class="s2"># Use the standard _set_compound_prop method to</span>
        <span class="s2"># validate/coerce/import subplot value. This must be called AFTER</span>
        <span class="s2"># the validator instance is added to self._validators above.</span>
        <span class="s1">self._set_compound_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s1">self._subplotid_props.add(prop)</span>

    <span class="s0">def </span><span class="s1">_strip_subplot_suffix_of_1(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Strip the suffix for subplot property names that have a suffix of 1. 
        All other properties are returned unchanged 
 
        e.g. 'xaxis1' -&gt; 'xaxis' 
 
        Parameters 
        ---------- 
        prop : str|tuple 
 
        Returns 
        ------- 
        str|tuple 
        &quot;&quot;&quot;</span>
        <span class="s2"># Let parent handle non-scalar cases</span>
        <span class="s2"># ----------------------------------</span>
        <span class="s2"># e.g. ('xaxis', 'range') or 'xaxis.range'</span>
        <span class="s1">prop_tuple = BaseFigure._str_to_dict_path(prop)</span>
        <span class="s0">if </span><span class="s1">len(prop_tuple) != </span><span class="s5">1 </span><span class="s0">or not </span><span class="s1">isinstance(prop_tuple[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s0">return </span><span class="s1">prop</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Unwrap to scalar string</span>
            <span class="s1">prop = prop_tuple[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2"># Handle subplot suffix digit of 1</span>
        <span class="s2"># --------------------------------</span>
        <span class="s2"># Remove digit of 1 from subplot id (e.g.. xaxis1 -&gt; xaxis)</span>
        <span class="s1">match = self._subplot_re_match(prop)</span>

        <span class="s0">if </span><span class="s1">match:</span>
            <span class="s1">subplot_prop = match.group(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">suffix_digit = int(match.group(</span><span class="s5">2</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">subplot_prop </span><span class="s0">and </span><span class="s1">suffix_digit == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">prop = subplot_prop</span>

        <span class="s0">return </span><span class="s1">prop</span>

    <span class="s0">def </span><span class="s1">_get_prop_validator(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom _get_prop_validator that handles subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s1">prop = self._strip_subplot_suffix_of_1(prop)</span>
        <span class="s0">return </span><span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self)._get_prop_validator(prop)</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom __getattr__ that handles dynamic subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s1">prop = self._strip_subplot_suffix_of_1(prop)</span>
        <span class="s0">if </span><span class="s1">prop != </span><span class="s4">&quot;_subplotid_props&quot; </span><span class="s0">and </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">self._subplotid_props:</span>
            <span class="s1">validator = self._get_validator(prop)</span>
            <span class="s0">return </span><span class="s1">validator.present(self._compound_props[prop])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__getattribute__(prop)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom __getitem__ that handles dynamic subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s1">prop = self._strip_subplot_suffix_of_1(prop)</span>
        <span class="s0">return </span><span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__getitem__(prop)</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">prop):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom __contains__ that handles dynamic subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s1">prop = self._strip_subplot_suffix_of_1(prop)</span>
        <span class="s0">return </span><span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__contains__(prop)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom __setitem__ that handles dynamic subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s2"># Convert prop to prop tuple</span>
        <span class="s2"># --------------------------</span>
        <span class="s1">prop_tuple = BaseFigure._str_to_dict_path(prop)</span>
        <span class="s0">if </span><span class="s1">len(prop_tuple) != </span><span class="s5">1 </span><span class="s0">or not </span><span class="s1">isinstance(prop_tuple[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s2"># Let parent handle non-scalar non-string cases</span>
            <span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__setitem__(prop</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Unwrap prop tuple</span>
            <span class="s1">prop = prop_tuple[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2"># Check for subplot assignment</span>
        <span class="s2"># ----------------------------</span>
        <span class="s1">match = self._subplot_re_match(prop)</span>
        <span class="s0">if </span><span class="s1">match </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Set as ordinary property</span>
            <span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__setitem__(prop</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Set as subplotid property</span>
            <span class="s1">self._set_subplotid_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom __setattr__ that handles dynamic subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s2"># Check for subplot assignment</span>
        <span class="s2"># ----------------------------</span>
        <span class="s1">match = self._subplot_re_match(prop)</span>
        <span class="s0">if </span><span class="s1">match </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># Set as ordinary property</span>
            <span class="s1">super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__setattr__(prop</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Set as subplotid property</span>
            <span class="s1">self._set_subplotid_prop(prop</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__dir__(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Custom __dir__ that handles dynamic subplot properties 
        &quot;&quot;&quot;</span>
        <span class="s2"># Include any active subplot values</span>
        <span class="s0">if </span><span class="s1">six.PY2:</span>

            <span class="s0">def </span><span class="s1">get_attrs(obj):</span>
                <span class="s0">import </span><span class="s1">types</span>

                <span class="s0">if not </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s4">&quot;__dict__&quot;</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">[]</span>
                <span class="s0">if not </span><span class="s1">isinstance(obj.__dict__</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">types.DictProxyType)):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s.__dict__ is not a dictionary&quot; &quot;&quot; </span><span class="s1">% obj.__name__)</span>
                <span class="s0">return </span><span class="s1">obj.__dict__.keys()</span>

            <span class="s0">def </span><span class="s1">dir2(obj):</span>
                <span class="s1">attrs = set()</span>
                <span class="s0">if not </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s4">&quot;__bases__&quot;</span><span class="s1">):</span>
                    <span class="s2"># obj is an instance</span>
                    <span class="s0">if not </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s4">&quot;__class__&quot;</span><span class="s1">):</span>
                        <span class="s2"># slots</span>
                        <span class="s0">return </span><span class="s1">sorted(get_attrs(obj))</span>
                    <span class="s1">klass = obj.__class__</span>
                    <span class="s1">attrs.update(get_attrs(klass))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s2"># obj is a class</span>
                    <span class="s1">klass = obj</span>

                <span class="s0">for </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">klass.__bases__:</span>
                    <span class="s1">attrs.update(get_attrs(cls))</span>
                    <span class="s1">attrs.update(dir2(cls))</span>
                <span class="s1">attrs.update(get_attrs(obj))</span>
                <span class="s0">return </span><span class="s1">list(attrs)</span>

            <span class="s0">return </span><span class="s1">dir2(self) + sorted(self._subplotid_props)</span>
        <span class="s0">else</span><span class="s1">:</span>

            <span class="s0">return </span><span class="s1">list(super(BaseLayoutHierarchyType</span><span class="s0">, </span><span class="s1">self).__dir__()) + sorted(</span>
                <span class="s1">self._subplotid_props</span>
            <span class="s1">)</span>


<span class="s0">class </span><span class="s1">BaseTraceHierarchyType(BasePlotlyType):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for all types in the trace hierarchy 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(BaseTraceHierarchyType</span><span class="s0">, </span><span class="s1">self).__init__(plotly_name</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">_send_prop_set(self</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s0">if </span><span class="s1">self.parent:</span>
            <span class="s2"># ### Inform parent of restyle operation ###</span>
            <span class="s1">self.parent._restyle_child(self</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val)</span>


<span class="s0">class </span><span class="s1">BaseTraceType(BaseTraceHierarchyType):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for the all trace types. 
 
    Specific trace type classes (Scatter, Bar, etc.) are code generated as 
    subclasses of this class. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(BaseTraceHierarchyType</span><span class="s0">, </span><span class="s1">self).__init__(plotly_name</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s2"># Initialize callback function lists</span>
        <span class="s2"># ----------------------------------</span>
        <span class="s2"># ### Callbacks to be called on hover ###</span>
        <span class="s1">self._hover_callbacks = []</span>

        <span class="s2"># ### Callbacks to be called on unhover ###</span>
        <span class="s1">self._unhover_callbacks = []</span>

        <span class="s2"># ### Callbacks to be called on click ###</span>
        <span class="s1">self._click_callbacks = []</span>

        <span class="s2"># ### Callbacks to be called on selection ###</span>
        <span class="s1">self._select_callbacks = []</span>

        <span class="s2"># ### Callbacks to be called on deselect ###</span>
        <span class="s1">self._deselect_callbacks = []</span>

        <span class="s2"># ### Trace index in figure ###</span>
        <span class="s1">self._trace_ind = </span><span class="s0">None</span>

    <span class="s2"># uid</span>
    <span class="s2"># ---</span>
    <span class="s2"># All trace types must have a top-level UID</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">uid(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@uid.setter</span>
    <span class="s0">def </span><span class="s1">uid(self</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2"># Hover</span>
    <span class="s2"># -----</span>
    <span class="s0">def </span><span class="s1">on_hover(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">append=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Register function to be called when the user hovers over one or more 
        points in this trace 
 
        Note: Callbacks will only be triggered when the trace belongs to a 
        instance of plotly.graph_objs.FigureWidget and it is displayed in an 
        ipywidget context. Callbacks will not be triggered on figures 
        that are displayed using plot/iplot. 
 
        Parameters 
        ---------- 
        callback 
            Callable function that accepts 3 arguments 
 
            - this trace 
            - plotly.callbacks.Points object 
            - plotly.callbacks.InputDeviceState object 
 
        append : bool 
            If False (the default), this callback replaces any previously 
            defined on_hover callbacks for this trace. If True, 
            this callback is appended to the list of any previously defined 
            callbacks. 
 
        Returns 
        ------- 
        None 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; import plotly.graph_objects as go 
        &gt;&gt;&gt; from plotly.callbacks import Points, InputDeviceState 
        &gt;&gt;&gt; points, state = Points(), InputDeviceState() 
 
        &gt;&gt;&gt; def hover_fn(trace, points, state): 
        ...     inds = points.point_inds 
        ...     # Do something 
 
        &gt;&gt;&gt; trace = go.Scatter(x=[1, 2], y=[3, 0]) 
        &gt;&gt;&gt; trace.on_hover(hover_fn) 
 
        Note: The creation of the `points` and `state` objects is optional, 
        it's simply a convenience to help the text editor perform completion 
        on the arguments inside `hover_fn` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">append:</span>
            <span class="s0">del </span><span class="s1">self._hover_callbacks[:]</span>

        <span class="s0">if </span><span class="s1">callback:</span>
            <span class="s1">self._hover_callbacks.append(callback)</span>

    <span class="s0">def </span><span class="s1">_dispatch_on_hover(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch points and device state all all hover callbacks 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">self._hover_callbacks:</span>
            <span class="s1">callback(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">state)</span>

    <span class="s2"># Unhover</span>
    <span class="s2"># -------</span>
    <span class="s0">def </span><span class="s1">on_unhover(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">append=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Register function to be called when the user unhovers away from one 
        or more points in this trace. 
 
        Note: Callbacks will only be triggered when the trace belongs to a 
        instance of plotly.graph_objs.FigureWidget and it is displayed in an 
        ipywidget context. Callbacks will not be triggered on figures 
        that are displayed using plot/iplot. 
 
        Parameters 
        ---------- 
        callback 
            Callable function that accepts 3 arguments 
 
            - this trace 
            - plotly.callbacks.Points object 
            - plotly.callbacks.InputDeviceState object 
 
        append : bool 
            If False (the default), this callback replaces any previously 
            defined on_unhover callbacks for this trace. If True, 
            this callback is appended to the list of any previously defined 
            callbacks. 
 
        Returns 
        ------- 
        None 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; import plotly.graph_objects as go 
        &gt;&gt;&gt; from plotly.callbacks import Points, InputDeviceState 
        &gt;&gt;&gt; points, state = Points(), InputDeviceState() 
 
        &gt;&gt;&gt; def unhover_fn(trace, points, state): 
        ...     inds = points.point_inds 
        ...     # Do something 
 
        &gt;&gt;&gt; trace = go.Scatter(x=[1, 2], y=[3, 0]) 
        &gt;&gt;&gt; trace.on_unhover(unhover_fn) 
 
        Note: The creation of the `points` and `state` objects is optional, 
        it's simply a convenience to help the text editor perform completion 
        on the arguments inside `unhover_fn` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">append:</span>
            <span class="s0">del </span><span class="s1">self._unhover_callbacks[:]</span>

        <span class="s0">if </span><span class="s1">callback:</span>
            <span class="s1">self._unhover_callbacks.append(callback)</span>

    <span class="s0">def </span><span class="s1">_dispatch_on_unhover(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch points and device state all all hover callbacks 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">self._unhover_callbacks:</span>
            <span class="s1">callback(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">state)</span>

    <span class="s2"># Click</span>
    <span class="s2"># -----</span>
    <span class="s0">def </span><span class="s1">on_click(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">append=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Register function to be called when the user clicks on one or more 
        points in this trace. 
 
        Note: Callbacks will only be triggered when the trace belongs to a 
        instance of plotly.graph_objs.FigureWidget and it is displayed in an 
        ipywidget context. Callbacks will not be triggered on figures 
        that are displayed using plot/iplot. 
 
        Parameters 
        ---------- 
        callback 
            Callable function that accepts 3 arguments 
 
            - this trace 
            - plotly.callbacks.Points object 
            - plotly.callbacks.InputDeviceState object 
 
        append : bool 
            If False (the default), this callback replaces any previously 
            defined on_click callbacks for this trace. If True, 
            this callback is appended to the list of any previously defined 
            callbacks. 
 
        Returns 
        ------- 
        None 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; import plotly.graph_objects as go 
        &gt;&gt;&gt; from plotly.callbacks import Points, InputDeviceState 
        &gt;&gt;&gt; points, state = Points(), InputDeviceState() 
 
        &gt;&gt;&gt; def click_fn(trace, points, state): 
        ...     inds = points.point_inds 
        ...     # Do something 
 
        &gt;&gt;&gt; trace = go.Scatter(x=[1, 2], y=[3, 0]) 
        &gt;&gt;&gt; trace.on_click(click_fn) 
 
        Note: The creation of the `points` and `state` objects is optional, 
        it's simply a convenience to help the text editor perform completion 
        on the arguments inside `click_fn` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">append:</span>
            <span class="s0">del </span><span class="s1">self._click_callbacks[:]</span>
        <span class="s0">if </span><span class="s1">callback:</span>
            <span class="s1">self._click_callbacks.append(callback)</span>

    <span class="s0">def </span><span class="s1">_dispatch_on_click(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch points and device state all all hover callbacks 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">self._click_callbacks:</span>
            <span class="s1">callback(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">state)</span>

    <span class="s2"># Select</span>
    <span class="s2"># ------</span>
    <span class="s0">def </span><span class="s1">on_selection(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">append=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Register function to be called when the user selects one or more 
        points in this trace. 
 
        Note: Callbacks will only be triggered when the trace belongs to a 
        instance of plotly.graph_objs.FigureWidget and it is displayed in an 
        ipywidget context. Callbacks will not be triggered on figures 
        that are displayed using plot/iplot. 
 
        Parameters 
        ---------- 
        callback 
            Callable function that accepts 4 arguments 
 
            - this trace 
            - plotly.callbacks.Points object 
            - plotly.callbacks.BoxSelector or plotly.callbacks.LassoSelector 
 
        append : bool 
            If False (the default), this callback replaces any previously 
            defined on_selection callbacks for this trace. If True, 
            this callback is appended to the list of any previously defined 
            callbacks. 
 
        Returns 
        ------- 
        None 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; import plotly.graph_objects as go 
        &gt;&gt;&gt; from plotly.callbacks import Points 
        &gt;&gt;&gt; points = Points() 
 
        &gt;&gt;&gt; def selection_fn(trace, points, selector): 
        ...     inds = points.point_inds 
        ...     # Do something 
 
        &gt;&gt;&gt; trace = go.Scatter(x=[1, 2], y=[3, 0]) 
        &gt;&gt;&gt; trace.on_selection(selection_fn) 
 
        Note: The creation of the `points` object is optional, 
        it's simply a convenience to help the text editor perform completion 
        on the `points` arguments inside `selection_fn` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">append:</span>
            <span class="s0">del </span><span class="s1">self._select_callbacks[:]</span>

        <span class="s0">if </span><span class="s1">callback:</span>
            <span class="s1">self._select_callbacks.append(callback)</span>

    <span class="s0">def </span><span class="s1">_dispatch_on_selection(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">selector):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch points and selector info to selection callbacks 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">&quot;selectedpoints&quot; </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s2"># Update the selectedpoints property, which will notify all views</span>
            <span class="s2"># of the selection change.  This is a special case because no</span>
            <span class="s2"># restyle event is emitted by plotly.js on selection events</span>
            <span class="s2"># even though these events update the selectedpoints property.</span>
            <span class="s1">self.selectedpoints = points.point_inds</span>

        <span class="s0">for </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">self._select_callbacks:</span>
            <span class="s1">callback(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">selector)</span>

    <span class="s2"># deselect</span>
    <span class="s2"># --------</span>
    <span class="s0">def </span><span class="s1">on_deselect(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">append=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Register function to be called when the user deselects points 
        in this trace using doubleclick. 
 
        Note: Callbacks will only be triggered when the trace belongs to a 
        instance of plotly.graph_objs.FigureWidget and it is displayed in an 
        ipywidget context. Callbacks will not be triggered on figures 
        that are displayed using plot/iplot. 
 
        Parameters 
        ---------- 
        callback 
            Callable function that accepts 3 arguments 
 
            - this trace 
            - plotly.callbacks.Points object 
 
        append : bool 
            If False (the default), this callback replaces any previously 
            defined on_deselect callbacks for this trace. If True, 
            this callback is appended to the list of any previously defined 
            callbacks. 
 
        Returns 
        ------- 
        None 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; import plotly.graph_objects as go 
        &gt;&gt;&gt; from plotly.callbacks import Points 
        &gt;&gt;&gt; points = Points() 
 
        &gt;&gt;&gt; def deselect_fn(trace, points): 
        ...     inds = points.point_inds 
        ...     # Do something 
 
        &gt;&gt;&gt; trace = go.Scatter(x=[1, 2], y=[3, 0]) 
        &gt;&gt;&gt; trace.on_deselect(deselect_fn) 
 
        Note: The creation of the `points` object is optional, 
        it's simply a convenience to help the text editor perform completion 
        on the `points` arguments inside `selection_fn` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">append:</span>
            <span class="s0">del </span><span class="s1">self._deselect_callbacks[:]</span>

        <span class="s0">if </span><span class="s1">callback:</span>
            <span class="s1">self._deselect_callbacks.append(callback)</span>

    <span class="s0">def </span><span class="s1">_dispatch_on_deselect(self</span><span class="s0">, </span><span class="s1">points):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch points info to deselection callbacks 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">&quot;selectedpoints&quot; </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s2"># Update the selectedpoints property, which will notify all views</span>
            <span class="s2"># of the selection change.  This is a special case because no</span>
            <span class="s2"># restyle event is emitted by plotly.js on selection events</span>
            <span class="s2"># even though these events update the selectedpoints property.</span>
            <span class="s1">self.selectedpoints = </span><span class="s0">None</span>

        <span class="s0">for </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">self._deselect_callbacks:</span>
            <span class="s1">callback(self</span><span class="s0">, </span><span class="s1">points)</span>


<span class="s0">class </span><span class="s1">BaseFrameHierarchyType(BasePlotlyType):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for all types in the trace hierarchy 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">plotly_name</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(BaseFrameHierarchyType</span><span class="s0">, </span><span class="s1">self).__init__(plotly_name</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">_send_prop_set(self</span><span class="s0">, </span><span class="s1">prop_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s2"># Note: Frames are not supported by FigureWidget, and updates are not</span>
        <span class="s2"># propagated to parents</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_restyle_child(self</span><span class="s0">, </span><span class="s1">child</span><span class="s0">, </span><span class="s1">key_path_str</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s2"># Note: Frames are not supported by FigureWidget, and updates are not</span>
        <span class="s2"># propagated to parents</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">on_change(self</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Change callbacks are not supported on Frames&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_child_props(self</span><span class="s0">, </span><span class="s1">child):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the properties dict for a child trace or child layout 
 
        Note: this method must match the name/signature of one on 
        BasePlotlyType 
 
        Parameters 
        ---------- 
        child : BaseTraceType | BaseLayoutType 
 
        Returns 
        ------- 
        dict 
        &quot;&quot;&quot;</span>
        <span class="s2"># Try to find index of child as a trace</span>
        <span class="s2"># -------------------------------------</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">trace_index = BaseFigure._index_is(self.data</span><span class="s0">, </span><span class="s1">child)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s1">trace_index = </span><span class="s0">None</span>

        <span class="s2"># Child is a trace</span>
        <span class="s2"># ----------------</span>
        <span class="s0">if </span><span class="s1">trace_index </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s4">&quot;data&quot; </span><span class="s0">in </span><span class="s1">self._props:</span>
                <span class="s0">return </span><span class="s1">self._props[</span><span class="s4">&quot;data&quot;</span><span class="s1">][trace_index]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return None</span>

        <span class="s2"># Child is the layout</span>
        <span class="s2"># -------------------</span>
        <span class="s0">elif </span><span class="s1">child </span><span class="s0">is </span><span class="s1">self.layout:</span>
            <span class="s0">return </span><span class="s1">self._props.get(</span><span class="s4">&quot;layout&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s2"># Unknown child</span>
        <span class="s2"># -------------</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized child: %s&quot; </span><span class="s1">% child)</span>
</pre>
</body>
</html>