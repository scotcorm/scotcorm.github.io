<html>
<head>
<title>easy_install.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
easy_install.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Easy Install 
------------ 
 
A tool for doing automatic download/extract/build of distutils-based Python 
packages.  For detailed documentation, see the accompanying EasyInstall.txt 
file, or visit the `EasyInstall home page`__. 
 
__ https://setuptools.readthedocs.io/en/latest/easy_install.html 
 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">glob</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">get_platform</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">convert_path</span><span class="s2">, </span><span class="s1">subst_vars</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DistutilsArgError</span><span class="s2">, </span><span class="s1">DistutilsOptionError</span><span class="s2">,</span>
    <span class="s1">DistutilsError</span><span class="s2">, </span><span class="s1">DistutilsPlatformError</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">distutils.command.install </span><span class="s2">import </span><span class="s1">INSTALL_SCHEMES</span><span class="s2">, </span><span class="s1">SCHEME_KEYS</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span><span class="s2">, </span><span class="s1">dir_util</span>
<span class="s2">from </span><span class="s1">distutils.command.build_scripts </span><span class="s2">import </span><span class="s1">first_line_re</span>
<span class="s2">from </span><span class="s1">distutils.spawn </span><span class="s2">import </span><span class="s1">find_executable</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">zipimport</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">import </span><span class="s1">zipfile</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">stat</span>
<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">site</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">shlex</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">configparser</span>


<span class="s2">from </span><span class="s1">sysconfig </span><span class="s2">import </span><span class="s1">get_config_vars</span><span class="s2">, </span><span class="s1">get_path</span>

<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">SetuptoolsDeprecationWarning</span>

<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Command</span>
<span class="s2">from </span><span class="s1">setuptools.sandbox </span><span class="s2">import </span><span class="s1">run_setup</span>
<span class="s2">from </span><span class="s1">setuptools.command </span><span class="s2">import </span><span class="s1">setopt</span>
<span class="s2">from </span><span class="s1">setuptools.archive_util </span><span class="s2">import </span><span class="s1">unpack_archive</span>
<span class="s2">from </span><span class="s1">setuptools.package_index </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">PackageIndex</span><span class="s2">, </span><span class="s1">parse_requirement_arg</span><span class="s2">, </span><span class="s1">URL_SCHEME</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">setuptools.command </span><span class="s2">import </span><span class="s1">bdist_egg</span><span class="s2">, </span><span class="s1">egg_info</span>
<span class="s2">from </span><span class="s1">setuptools.wheel </span><span class="s2">import </span><span class="s1">Wheel</span>
<span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">yield_lines</span><span class="s2">, </span><span class="s1">normalize_path</span><span class="s2">, </span><span class="s1">resource_string</span><span class="s2">, </span><span class="s1">ensure_directory</span><span class="s2">,</span>
    <span class="s1">get_distribution</span><span class="s2">, </span><span class="s1">find_distributions</span><span class="s2">, </span><span class="s1">Environment</span><span class="s2">, </span><span class="s1">Requirement</span><span class="s2">,</span>
    <span class="s1">Distribution</span><span class="s2">, </span><span class="s1">PathMetadata</span><span class="s2">, </span><span class="s1">EggMetadata</span><span class="s2">, </span><span class="s1">WorkingSet</span><span class="s2">, </span><span class="s1">DistributionNotFound</span><span class="s2">,</span>
    <span class="s1">VersionConflict</span><span class="s2">, </span><span class="s1">DEVELOP_DIST</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pkg_resources</span>

<span class="s3"># Turn on PEP440Warnings</span>
<span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;default&quot;</span><span class="s2">, </span><span class="s1">category=pkg_resources.PEP440Warning)</span>

<span class="s1">__all__ = [</span>
    <span class="s4">'samefile'</span><span class="s2">, </span><span class="s4">'easy_install'</span><span class="s2">, </span><span class="s4">'PthDistributions'</span><span class="s2">, </span><span class="s4">'extract_wininst_cfg'</span><span class="s2">,</span>
    <span class="s4">'get_exe_prefixes'</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">is_64bit():</span>
    <span class="s2">return </span><span class="s1">struct.calcsize(</span><span class="s4">&quot;P&quot;</span><span class="s1">) == </span><span class="s5">8</span>


<span class="s2">def </span><span class="s1">samefile(p1</span><span class="s2">, </span><span class="s1">p2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine if two paths reference the same file. 
 
    Augments os.path.samefile to work on Windows and 
    suppresses errors if the path doesn't exist. 
    &quot;&quot;&quot;</span>
    <span class="s1">both_exist = os.path.exists(p1) </span><span class="s2">and </span><span class="s1">os.path.exists(p2)</span>
    <span class="s1">use_samefile = hasattr(os.path</span><span class="s2">, </span><span class="s4">'samefile'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">both_exist</span>
    <span class="s2">if </span><span class="s1">use_samefile:</span>
        <span class="s2">return </span><span class="s1">os.path.samefile(p1</span><span class="s2">, </span><span class="s1">p2)</span>
    <span class="s1">norm_p1 = os.path.normpath(os.path.normcase(p1))</span>
    <span class="s1">norm_p2 = os.path.normpath(os.path.normcase(p2))</span>
    <span class="s2">return </span><span class="s1">norm_p1 == norm_p2</span>


<span class="s2">def </span><span class="s1">_to_bytes(s):</span>
    <span class="s2">return </span><span class="s1">s.encode(</span><span class="s4">'utf8'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">isascii(s):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">s.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
        <span class="s2">return True</span>
    <span class="s2">except </span><span class="s1">UnicodeError:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_one_liner(text):</span>
    <span class="s2">return </span><span class="s1">textwrap.dedent(text).strip().replace(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'; '</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">easy_install(Command):</span>
    <span class="s0">&quot;&quot;&quot;Manage a download/build/install process&quot;&quot;&quot;</span>
    <span class="s1">description = </span><span class="s4">&quot;Find/get/install Python packages&quot;</span>
    <span class="s1">command_consumes_arguments = </span><span class="s2">True</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s4">'prefix='</span><span class="s2">, None, </span><span class="s4">&quot;installation prefix&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;zip-ok&quot;</span><span class="s2">, </span><span class="s4">&quot;z&quot;</span><span class="s2">, </span><span class="s4">&quot;install package as a zipfile&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;multi-version&quot;</span><span class="s2">, </span><span class="s4">&quot;m&quot;</span><span class="s2">, </span><span class="s4">&quot;make apps have to require() a version&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;upgrade&quot;</span><span class="s2">, </span><span class="s4">&quot;U&quot;</span><span class="s2">, </span><span class="s4">&quot;force upgrade (searches PyPI for latest versions)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;install-dir=&quot;</span><span class="s2">, </span><span class="s4">&quot;d&quot;</span><span class="s2">, </span><span class="s4">&quot;install package to DIR&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;script-dir=&quot;</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s2">, </span><span class="s4">&quot;install scripts to DIR&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;exclude-scripts&quot;</span><span class="s2">, </span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;Don't install scripts&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;always-copy&quot;</span><span class="s2">, </span><span class="s4">&quot;a&quot;</span><span class="s2">, </span><span class="s4">&quot;Copy all needed packages to install dir&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;index-url=&quot;</span><span class="s2">, </span><span class="s4">&quot;i&quot;</span><span class="s2">, </span><span class="s4">&quot;base URL of Python Package Index&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;find-links=&quot;</span><span class="s2">, </span><span class="s4">&quot;f&quot;</span><span class="s2">, </span><span class="s4">&quot;additional URL(s) to search for packages&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;build-directory=&quot;</span><span class="s2">, </span><span class="s4">&quot;b&quot;</span><span class="s2">,</span>
         <span class="s4">&quot;download/extract/build in DIR; keep the results&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'optimize='</span><span class="s2">, </span><span class="s4">'O'</span><span class="s2">,</span>
         <span class="s4">&quot;also compile with optimization: -O1 for </span><span class="s2">\&quot;</span><span class="s4">python -O</span><span class="s2">\&quot;</span><span class="s4">, &quot;</span>
         <span class="s4">&quot;-O2 for </span><span class="s2">\&quot;</span><span class="s4">python -OO</span><span class="s2">\&quot;</span><span class="s4">, and -O0 to disable [default: -O0]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'record='</span><span class="s2">, None,</span>
         <span class="s4">&quot;filename in which to record list of installed files&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'always-unzip'</span><span class="s2">, </span><span class="s4">'Z'</span><span class="s2">, </span><span class="s4">&quot;don't install as a zipfile, no matter what&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'site-dirs='</span><span class="s2">, </span><span class="s4">'S'</span><span class="s2">, </span><span class="s4">&quot;list of directories where .pth files work&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'editable'</span><span class="s2">, </span><span class="s4">'e'</span><span class="s2">, </span><span class="s4">&quot;Install specified packages in editable form&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'no-deps'</span><span class="s2">, </span><span class="s4">'N'</span><span class="s2">, </span><span class="s4">&quot;don't install dependencies&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'allow-hosts='</span><span class="s2">, </span><span class="s4">'H'</span><span class="s2">, </span><span class="s4">&quot;pattern(s) that hostnames must match&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'local-snapshots-ok'</span><span class="s2">, </span><span class="s4">'l'</span><span class="s2">,</span>
         <span class="s4">&quot;allow building eggs from local checkouts&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'version'</span><span class="s2">, None, </span><span class="s4">&quot;print version information and exit&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'no-find-links'</span><span class="s2">, None,</span>
         <span class="s4">&quot;Don't load find-links defined in packages being installed&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'user'</span><span class="s2">, None, </span><span class="s4">&quot;install in user site-package '%s'&quot; </span><span class="s1">% site.USER_SITE)</span>
    <span class="s1">]</span>
    <span class="s1">boolean_options = [</span>
        <span class="s4">'zip-ok'</span><span class="s2">, </span><span class="s4">'multi-version'</span><span class="s2">, </span><span class="s4">'exclude-scripts'</span><span class="s2">, </span><span class="s4">'upgrade'</span><span class="s2">, </span><span class="s4">'always-copy'</span><span class="s2">,</span>
        <span class="s4">'editable'</span><span class="s2">,</span>
        <span class="s4">'no-deps'</span><span class="s2">, </span><span class="s4">'local-snapshots-ok'</span><span class="s2">, </span><span class="s4">'version'</span><span class="s2">,</span>
        <span class="s4">'user'</span>
    <span class="s1">]</span>

    <span class="s1">negative_opt = {</span><span class="s4">'always-unzip'</span><span class="s1">: </span><span class="s4">'zip-ok'</span><span class="s1">}</span>
    <span class="s1">create_index = PackageIndex</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s3"># the --user option seems to be an opt-in one,</span>
        <span class="s3"># so the default should be False.</span>
        <span class="s1">self.user = </span><span class="s5">0</span>
        <span class="s1">self.zip_ok = self.local_snapshots_ok = </span><span class="s2">None</span>
        <span class="s1">self.install_dir = self.script_dir = self.exclude_scripts = </span><span class="s2">None</span>
        <span class="s1">self.index_url = </span><span class="s2">None</span>
        <span class="s1">self.find_links = </span><span class="s2">None</span>
        <span class="s1">self.build_directory = </span><span class="s2">None</span>
        <span class="s1">self.args = </span><span class="s2">None</span>
        <span class="s1">self.optimize = self.record = </span><span class="s2">None</span>
        <span class="s1">self.upgrade = self.always_copy = self.multi_version = </span><span class="s2">None</span>
        <span class="s1">self.editable = self.no_deps = self.allow_hosts = </span><span class="s2">None</span>
        <span class="s1">self.root = self.prefix = self.no_report = </span><span class="s2">None</span>
        <span class="s1">self.version = </span><span class="s2">None</span>
        <span class="s1">self.install_purelib = </span><span class="s2">None  </span><span class="s3"># for pure module distributions</span>
        <span class="s1">self.install_platlib = </span><span class="s2">None  </span><span class="s3"># non-pure (dists w/ extensions)</span>
        <span class="s1">self.install_headers = </span><span class="s2">None  </span><span class="s3"># for C/C++ headers</span>
        <span class="s1">self.install_lib = </span><span class="s2">None  </span><span class="s3"># set to either purelib or platlib</span>
        <span class="s1">self.install_scripts = </span><span class="s2">None</span>
        <span class="s1">self.install_data = </span><span class="s2">None</span>
        <span class="s1">self.install_base = </span><span class="s2">None</span>
        <span class="s1">self.install_platbase = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">site.ENABLE_USER_SITE:</span>
            <span class="s1">self.install_userbase = site.USER_BASE</span>
            <span class="s1">self.install_usersite = site.USER_SITE</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.install_userbase = </span><span class="s2">None</span>
            <span class="s1">self.install_usersite = </span><span class="s2">None</span>
        <span class="s1">self.no_find_links = </span><span class="s2">None</span>

        <span class="s3"># Options not specifiable via command line</span>
        <span class="s1">self.package_index = </span><span class="s2">None</span>
        <span class="s1">self.pth_file = self.always_copy_from = </span><span class="s2">None</span>
        <span class="s1">self.site_dirs = </span><span class="s2">None</span>
        <span class="s1">self.installed_projects = {}</span>
        <span class="s3"># Always read easy_install options, even if we are subclassed, or have</span>
        <span class="s3"># an independent instance created.  This ensures that defaults will</span>
        <span class="s3"># always come from the standard configuration file(s)' &quot;easy_install&quot;</span>
        <span class="s3"># section, even if this is a &quot;develop&quot; or &quot;install&quot; command, or some</span>
        <span class="s3"># other embedding.</span>
        <span class="s1">self._dry_run = </span><span class="s2">None</span>
        <span class="s1">self.verbose = self.distribution.verbose</span>
        <span class="s1">self.distribution._set_command_options(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">self.distribution.get_option_dict(</span><span class="s4">'easy_install'</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">delete_blockers(self</span><span class="s2">, </span><span class="s1">blockers):</span>
        <span class="s1">extant_blockers = (</span>
            <span class="s1">filename </span><span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">blockers</span>
            <span class="s2">if </span><span class="s1">os.path.exists(filename) </span><span class="s2">or </span><span class="s1">os.path.islink(filename)</span>
        <span class="s1">)</span>
        <span class="s1">list(map(self._delete_path</span><span class="s2">, </span><span class="s1">extant_blockers))</span>

    <span class="s2">def </span><span class="s1">_delete_path(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">log.info(</span><span class="s4">&quot;Deleting %s&quot;</span><span class="s2">, </span><span class="s1">path)</span>
        <span class="s2">if </span><span class="s1">self.dry_run:</span>
            <span class="s2">return</span>

        <span class="s1">is_tree = os.path.isdir(path) </span><span class="s2">and not </span><span class="s1">os.path.islink(path)</span>
        <span class="s1">remover = rmtree </span><span class="s2">if </span><span class="s1">is_tree </span><span class="s2">else </span><span class="s1">os.unlink</span>
        <span class="s1">remover(path)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_render_version():</span>
        <span class="s0">&quot;&quot;&quot; 
        Render the Setuptools version and installation details, then exit. 
        &quot;&quot;&quot;</span>
        <span class="s1">ver = </span><span class="s4">'{}.{}'</span><span class="s1">.format(*sys.version_info)</span>
        <span class="s1">dist = get_distribution(</span><span class="s4">'setuptools'</span><span class="s1">)</span>
        <span class="s1">tmpl = </span><span class="s4">'setuptools {dist.version} from {dist.location} (Python {ver})'</span>
        <span class="s1">print(tmpl.format(**locals()))</span>
        <span class="s2">raise </span><span class="s1">SystemExit()</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):  </span><span class="s3"># noqa: C901  # is too complex (25)  # FIXME</span>
        <span class="s1">self.version </span><span class="s2">and </span><span class="s1">self._render_version()</span>

        <span class="s1">py_version = sys.version.split()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">exec_prefix = get_config_vars(</span><span class="s4">'prefix'</span><span class="s2">, </span><span class="s4">'exec_prefix'</span><span class="s1">)</span>

        <span class="s1">self.config_vars = {</span>
            <span class="s4">'dist_name'</span><span class="s1">: self.distribution.get_name()</span><span class="s2">,</span>
            <span class="s4">'dist_version'</span><span class="s1">: self.distribution.get_version()</span><span class="s2">,</span>
            <span class="s4">'dist_fullname'</span><span class="s1">: self.distribution.get_fullname()</span><span class="s2">,</span>
            <span class="s4">'py_version'</span><span class="s1">: py_version</span><span class="s2">,</span>
            <span class="s4">'py_version_short'</span><span class="s1">: py_version[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">'py_version_nodot'</span><span class="s1">: py_version[</span><span class="s5">0</span><span class="s1">] + py_version[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">'sys_prefix'</span><span class="s1">: prefix</span><span class="s2">,</span>
            <span class="s4">'prefix'</span><span class="s1">: prefix</span><span class="s2">,</span>
            <span class="s4">'sys_exec_prefix'</span><span class="s1">: exec_prefix</span><span class="s2">,</span>
            <span class="s4">'exec_prefix'</span><span class="s1">: exec_prefix</span><span class="s2">,</span>
            <span class="s3"># Only python 3.2+ has abiflags</span>
            <span class="s4">'abiflags'</span><span class="s1">: getattr(sys</span><span class="s2">, </span><span class="s4">'abiflags'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">site.ENABLE_USER_SITE:</span>
            <span class="s1">self.config_vars[</span><span class="s4">'userbase'</span><span class="s1">] = self.install_userbase</span>
            <span class="s1">self.config_vars[</span><span class="s4">'usersite'</span><span class="s1">] = self.install_usersite</span>

        <span class="s2">elif </span><span class="s1">self.user:</span>
            <span class="s1">log.warn(</span><span class="s4">&quot;WARNING: The user site-packages directory is disabled.&quot;</span><span class="s1">)</span>

        <span class="s1">self._fix_install_dir_for_user_site()</span>

        <span class="s1">self.expand_basedirs()</span>
        <span class="s1">self.expand_dirs()</span>

        <span class="s1">self._expand(</span>
            <span class="s4">'install_dir'</span><span class="s2">, </span><span class="s4">'script_dir'</span><span class="s2">, </span><span class="s4">'build_directory'</span><span class="s2">,</span>
            <span class="s4">'site_dirs'</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s3"># If a non-default installation directory was specified, default the</span>
        <span class="s3"># script directory to match it.</span>
        <span class="s2">if </span><span class="s1">self.script_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.script_dir = self.install_dir</span>

        <span class="s2">if </span><span class="s1">self.no_find_links </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.no_find_links = </span><span class="s2">False</span>

        <span class="s3"># Let install_dir get set by install_lib command, which in turn</span>
        <span class="s3"># gets its info from the install command, and takes into account</span>
        <span class="s3"># --prefix and --home and all that other crud.</span>
        <span class="s1">self.set_undefined_options(</span>
            <span class="s4">'install_lib'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'install_dir'</span><span class="s2">, </span><span class="s4">'install_dir'</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s3"># Likewise, set default script_dir from 'install_scripts.install_dir'</span>
        <span class="s1">self.set_undefined_options(</span>
            <span class="s4">'install_scripts'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'install_dir'</span><span class="s2">, </span><span class="s4">'script_dir'</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.user </span><span class="s2">and </span><span class="s1">self.install_purelib:</span>
            <span class="s1">self.install_dir = self.install_purelib</span>
            <span class="s1">self.script_dir = self.install_scripts</span>
        <span class="s3"># default --record from the install command</span>
        <span class="s1">self.set_undefined_options(</span><span class="s4">'install'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'record'</span><span class="s2">, </span><span class="s4">'record'</span><span class="s1">))</span>
        <span class="s3"># Should this be moved to the if statement below? It's not used</span>
        <span class="s3"># elsewhere</span>
        <span class="s1">normpath = map(normalize_path</span><span class="s2">, </span><span class="s1">sys.path)</span>
        <span class="s1">self.all_site_dirs = get_site_dirs()</span>
        <span class="s2">if </span><span class="s1">self.site_dirs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">site_dirs = [</span>
                <span class="s1">os.path.expanduser(s.strip()) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in</span>
                <span class="s1">self.site_dirs.split(</span><span class="s4">','</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">site_dirs:</span>
                <span class="s2">if not </span><span class="s1">os.path.isdir(d):</span>
                    <span class="s1">log.warn(</span><span class="s4">&quot;%s (in --site-dirs) does not exist&quot;</span><span class="s2">, </span><span class="s1">d)</span>
                <span class="s2">elif </span><span class="s1">normalize_path(d) </span><span class="s2">not in </span><span class="s1">normpath:</span>
                    <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                        <span class="s1">d + </span><span class="s4">&quot; (in --site-dirs) is not on sys.path&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.all_site_dirs.append(normalize_path(d))</span>
        <span class="s2">if not </span><span class="s1">self.editable:</span>
            <span class="s1">self.check_site_dir()</span>
        <span class="s1">self.index_url = self.index_url </span><span class="s2">or </span><span class="s4">&quot;https://pypi.org/simple/&quot;</span>
        <span class="s1">self.shadow_path = self.all_site_dirs[:]</span>
        <span class="s2">for </span><span class="s1">path_item </span><span class="s2">in </span><span class="s1">self.install_dir</span><span class="s2">, </span><span class="s1">normalize_path(self.script_dir):</span>
            <span class="s2">if </span><span class="s1">path_item </span><span class="s2">not in </span><span class="s1">self.shadow_path:</span>
                <span class="s1">self.shadow_path.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">path_item)</span>

        <span class="s2">if </span><span class="s1">self.allow_hosts </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">hosts = [s.strip() </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.allow_hosts.split(</span><span class="s4">','</span><span class="s1">)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">hosts = [</span><span class="s4">'*'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.package_index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.package_index = self.create_index(</span>
                <span class="s1">self.index_url</span><span class="s2">, </span><span class="s1">search_path=self.shadow_path</span><span class="s2">, </span><span class="s1">hosts=hosts</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">self.local_index = Environment(self.shadow_path + sys.path)</span>

        <span class="s2">if </span><span class="s1">self.find_links </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.find_links</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">self.find_links = self.find_links.split()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.find_links = []</span>
        <span class="s2">if </span><span class="s1">self.local_snapshots_ok:</span>
            <span class="s1">self.package_index.scan_egg_links(self.shadow_path + sys.path)</span>
        <span class="s2">if not </span><span class="s1">self.no_find_links:</span>
            <span class="s1">self.package_index.add_find_links(self.find_links)</span>
        <span class="s1">self.set_undefined_options(</span><span class="s4">'install_lib'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'optimize'</span><span class="s2">, </span><span class="s4">'optimize'</span><span class="s1">))</span>
        <span class="s2">if not </span><span class="s1">isinstance(self.optimize</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.optimize = int(self.optimize)</span>
                <span class="s2">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= self.optimize &lt;= </span><span class="s5">2</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                    <span class="s4">&quot;--optimize must be 0, 1, or 2&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">if </span><span class="s1">self.editable </span><span class="s2">and not </span><span class="s1">self.build_directory:</span>
            <span class="s2">raise </span><span class="s1">DistutilsArgError(</span>
                <span class="s4">&quot;Must specify a build directory (-b) when using --editable&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self.args:</span>
            <span class="s2">raise </span><span class="s1">DistutilsArgError(</span>
                <span class="s4">&quot;No urls, filenames, or requirements specified (see --help)&quot;</span><span class="s1">)</span>

        <span class="s1">self.outputs = []</span>

    <span class="s2">def </span><span class="s1">_fix_install_dir_for_user_site(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fix the install_dir if &quot;--user&quot; was used. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.user </span><span class="s2">or not </span><span class="s1">site.ENABLE_USER_SITE:</span>
            <span class="s2">return</span>

        <span class="s1">self.create_home_path()</span>
        <span class="s2">if </span><span class="s1">self.install_userbase </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;User base directory is not specified&quot;</span>
            <span class="s2">raise </span><span class="s1">DistutilsPlatformError(msg)</span>
        <span class="s1">self.install_base = self.install_platbase = self.install_userbase</span>
        <span class="s1">scheme_name = os.name.replace(</span><span class="s4">'posix'</span><span class="s2">, </span><span class="s4">'unix'</span><span class="s1">) + </span><span class="s4">'_user'</span>
        <span class="s1">self.select_scheme(scheme_name)</span>

    <span class="s2">def </span><span class="s1">_expand_attrs(self</span><span class="s2">, </span><span class="s1">attrs):</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
            <span class="s1">val = getattr(self</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">os.name == </span><span class="s4">'posix' </span><span class="s2">or </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
                    <span class="s1">val = os.path.expanduser(val)</span>
                <span class="s1">val = subst_vars(val</span><span class="s2">, </span><span class="s1">self.config_vars)</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>

    <span class="s2">def </span><span class="s1">expand_basedirs(self):</span>
        <span class="s0">&quot;&quot;&quot;Calls `os.path.expanduser` on install_base, install_platbase and 
        root.&quot;&quot;&quot;</span>
        <span class="s1">self._expand_attrs([</span><span class="s4">'install_base'</span><span class="s2">, </span><span class="s4">'install_platbase'</span><span class="s2">, </span><span class="s4">'root'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">expand_dirs(self):</span>
        <span class="s0">&quot;&quot;&quot;Calls `os.path.expanduser` on install dirs.&quot;&quot;&quot;</span>
        <span class="s1">dirs = [</span>
            <span class="s4">'install_purelib'</span><span class="s2">,</span>
            <span class="s4">'install_platlib'</span><span class="s2">,</span>
            <span class="s4">'install_lib'</span><span class="s2">,</span>
            <span class="s4">'install_headers'</span><span class="s2">,</span>
            <span class="s4">'install_scripts'</span><span class="s2">,</span>
            <span class="s4">'install_data'</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">self._expand_attrs(dirs)</span>

    <span class="s2">def </span><span class="s1">run(self</span><span class="s2">, </span><span class="s1">show_deprecation=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">show_deprecation:</span>
            <span class="s1">self.announce(</span>
                <span class="s4">&quot;WARNING: The easy_install command is deprecated &quot;</span>
                <span class="s4">&quot;and will be removed in a future version.&quot;</span><span class="s2">,</span>
                <span class="s1">log.WARN</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.verbose != self.distribution.verbose:</span>
            <span class="s1">log.set_verbosity(self.verbose)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">self.args:</span>
                <span class="s1">self.easy_install(spec</span><span class="s2">, not </span><span class="s1">self.no_deps)</span>
            <span class="s2">if </span><span class="s1">self.record:</span>
                <span class="s1">outputs = self.outputs</span>
                <span class="s2">if </span><span class="s1">self.root:  </span><span class="s3"># strip any package prefix</span>
                    <span class="s1">root_len = len(self.root)</span>
                    <span class="s2">for </span><span class="s1">counter </span><span class="s2">in </span><span class="s1">range(len(outputs)):</span>
                        <span class="s1">outputs[counter] = outputs[counter][root_len:]</span>
                <span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">file_util</span>

                <span class="s1">self.execute(</span>
                    <span class="s1">file_util.write_file</span><span class="s2">, </span><span class="s1">(self.record</span><span class="s2">, </span><span class="s1">outputs)</span><span class="s2">,</span>
                    <span class="s4">&quot;writing list of installed files to '%s'&quot; </span><span class="s1">%</span>
                    <span class="s1">self.record</span>
                <span class="s1">)</span>
            <span class="s1">self.warn_deprecated_options()</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">log.set_verbosity(self.distribution.verbose)</span>

    <span class="s2">def </span><span class="s1">pseudo_tempname(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a pseudo-tempname base in the install directory. 
        This code is intentionally naive; if a malicious party can write to 
        the target directory you're already in deep doodoo. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">pid = os.getpid()</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">pid = random.randint(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">sys.maxsize)</span>
        <span class="s2">return </span><span class="s1">os.path.join(self.install_dir</span><span class="s2">, </span><span class="s4">&quot;test-easy-install-%s&quot; </span><span class="s1">% pid)</span>

    <span class="s2">def </span><span class="s1">warn_deprecated_options(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">check_site_dir(self):  </span><span class="s3"># noqa: C901  # is too complex (12)  # FIXME</span>
        <span class="s0">&quot;&quot;&quot;Verify that self.install_dir is .pth-capable dir, if needed&quot;&quot;&quot;</span>

        <span class="s1">instdir = normalize_path(self.install_dir)</span>
        <span class="s1">pth_file = os.path.join(instdir</span><span class="s2">, </span><span class="s4">'easy-install.pth'</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">os.path.exists(instdir):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">os.makedirs(instdir)</span>
            <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">IOError):</span>
                <span class="s1">self.cant_write_to_target()</span>

        <span class="s3"># Is it a configured, PYTHONPATH, implicit, or explicit site dir?</span>
        <span class="s1">is_site_dir = instdir </span><span class="s2">in </span><span class="s1">self.all_site_dirs</span>

        <span class="s2">if not </span><span class="s1">is_site_dir </span><span class="s2">and not </span><span class="s1">self.multi_version:</span>
            <span class="s3"># No?  Then directly test whether it does .pth file processing</span>
            <span class="s1">is_site_dir = self.check_pth_processing()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># make sure we can write to target dir</span>
            <span class="s1">testfile = self.pseudo_tempname() + </span><span class="s4">'.write-test'</span>
            <span class="s1">test_exists = os.path.exists(testfile)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">test_exists:</span>
                    <span class="s1">os.unlink(testfile)</span>
                <span class="s1">open(testfile</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">).close()</span>
                <span class="s1">os.unlink(testfile)</span>
            <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">IOError):</span>
                <span class="s1">self.cant_write_to_target()</span>

        <span class="s2">if not </span><span class="s1">is_site_dir </span><span class="s2">and not </span><span class="s1">self.multi_version:</span>
            <span class="s3"># Can't install non-multi to non-site dir with easy_install</span>
            <span class="s1">pythonpath = os.environ.get(</span><span class="s4">'PYTHONPATH'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s1">log.warn(self.__no_default_msg</span><span class="s2">, </span><span class="s1">self.install_dir</span><span class="s2">, </span><span class="s1">pythonpath)</span>

        <span class="s2">if </span><span class="s1">is_site_dir:</span>
            <span class="s2">if </span><span class="s1">self.pth_file </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.pth_file = PthDistributions(pth_file</span><span class="s2">, </span><span class="s1">self.all_site_dirs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.pth_file = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.multi_version </span><span class="s2">and not </span><span class="s1">os.path.exists(pth_file):</span>
            <span class="s1">self.pth_file = </span><span class="s2">None  </span><span class="s3"># don't create a .pth file</span>
        <span class="s1">self.install_dir = instdir</span>

    <span class="s1">__cant_write_msg = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        can't create or remove files in install directory 
 
        The following error occurred while trying to add or remove files in the 
        installation directory: 
 
            %s 
 
        The installation directory you specified (via --install-dir, --prefix, or 
        the distutils default setting) was: 
 
            %s 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()  </span><span class="s3"># noqa</span>

    <span class="s1">__not_exists_id = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        This directory does not currently exist.  Please create it and try again, or 
        choose a different installation directory (using the -d or --install-dir 
        option). 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()  </span><span class="s3"># noqa</span>

    <span class="s1">__access_msg = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        Perhaps your account does not have write access to this directory?  If the 
        installation directory is a system-owned directory, you may need to sign in 
        as the administrator or &quot;root&quot; account.  If you do not have administrative 
        access to this machine, you may wish to choose a different installation 
        directory, preferably one that is listed in your PYTHONPATH environment 
        variable. 
 
        For information on other options, you may wish to consult the 
        documentation at: 
 
          https://setuptools.readthedocs.io/en/latest/easy_install.html 
 
        Please make the appropriate changes for your system and try again. 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()  </span><span class="s3"># noqa</span>

    <span class="s2">def </span><span class="s1">cant_write_to_target(self):</span>
        <span class="s1">msg = self.__cant_write_msg % (sys.exc_info()[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.install_dir</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">os.path.exists(self.install_dir):</span>
            <span class="s1">msg += </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ self.__not_exists_id</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg += </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ self.__access_msg</span>
        <span class="s2">raise </span><span class="s1">DistutilsError(msg)</span>

    <span class="s2">def </span><span class="s1">check_pth_processing(self):</span>
        <span class="s0">&quot;&quot;&quot;Empirically verify whether .pth files are supported in inst. dir&quot;&quot;&quot;</span>
        <span class="s1">instdir = self.install_dir</span>
        <span class="s1">log.info(</span><span class="s4">&quot;Checking .pth file support in %s&quot;</span><span class="s2">, </span><span class="s1">instdir)</span>
        <span class="s1">pth_file = self.pseudo_tempname() + </span><span class="s4">&quot;.pth&quot;</span>
        <span class="s1">ok_file = pth_file + </span><span class="s4">'.ok'</span>
        <span class="s1">ok_exists = os.path.exists(ok_file)</span>
        <span class="s1">tmpl = _one_liner(</span><span class="s4">&quot;&quot;&quot; 
            import os 
            f = open({ok_file!r}, 'w') 
            f.write('OK') 
            f.close() 
            &quot;&quot;&quot;</span><span class="s1">) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ok_exists:</span>
                <span class="s1">os.unlink(ok_file)</span>
            <span class="s1">dirname = os.path.dirname(ok_file)</span>
            <span class="s1">os.makedirs(dirname</span><span class="s2">, </span><span class="s1">exist_ok=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">f = open(pth_file</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">IOError):</span>
            <span class="s1">self.cant_write_to_target()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">f.write(tmpl.format(**locals()))</span>
                <span class="s1">f.close()</span>
                <span class="s1">f = </span><span class="s2">None</span>
                <span class="s1">executable = sys.executable</span>
                <span class="s2">if </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
                    <span class="s1">dirname</span><span class="s2">, </span><span class="s1">basename = os.path.split(executable)</span>
                    <span class="s1">alt = os.path.join(dirname</span><span class="s2">, </span><span class="s4">'pythonw.exe'</span><span class="s1">)</span>
                    <span class="s1">use_alt = (</span>
                        <span class="s1">basename.lower() == </span><span class="s4">'python.exe' </span><span class="s2">and</span>
                        <span class="s1">os.path.exists(alt)</span>
                    <span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">use_alt:</span>
                        <span class="s3"># use pythonw.exe to avoid opening a console window</span>
                        <span class="s1">executable = alt</span>

                <span class="s2">from </span><span class="s1">distutils.spawn </span><span class="s2">import </span><span class="s1">spawn</span>

                <span class="s1">spawn([executable</span><span class="s2">, </span><span class="s4">'-E'</span><span class="s2">, </span><span class="s4">'-c'</span><span class="s2">, </span><span class="s4">'pass'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">os.path.exists(ok_file):</span>
                    <span class="s1">log.info(</span>
                        <span class="s4">&quot;TEST PASSED: %s appears to support .pth files&quot;</span><span class="s2">,</span>
                        <span class="s1">instdir</span>
                    <span class="s1">)</span>
                    <span class="s2">return True</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">f:</span>
                    <span class="s1">f.close()</span>
                <span class="s2">if </span><span class="s1">os.path.exists(ok_file):</span>
                    <span class="s1">os.unlink(ok_file)</span>
                <span class="s2">if </span><span class="s1">os.path.exists(pth_file):</span>
                    <span class="s1">os.unlink(pth_file)</span>
        <span class="s2">if not </span><span class="s1">self.multi_version:</span>
            <span class="s1">log.warn(</span><span class="s4">&quot;TEST FAILED: %s does NOT support .pth files&quot;</span><span class="s2">, </span><span class="s1">instdir)</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">install_egg_scripts(self</span><span class="s2">, </span><span class="s1">dist):</span>
        <span class="s0">&quot;&quot;&quot;Write all the scripts for `dist`, unless scripts are excluded&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.exclude_scripts </span><span class="s2">and </span><span class="s1">dist.metadata_isdir(</span><span class="s4">'scripts'</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">script_name </span><span class="s2">in </span><span class="s1">dist.metadata_listdir(</span><span class="s4">'scripts'</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">dist.metadata_isdir(</span><span class="s4">'scripts/' </span><span class="s1">+ script_name):</span>
                    <span class="s3"># The &quot;script&quot; is a directory, likely a Python 3</span>
                    <span class="s3"># __pycache__ directory, so skip it.</span>
                    <span class="s2">continue</span>
                <span class="s1">self.install_script(</span>
                    <span class="s1">dist</span><span class="s2">, </span><span class="s1">script_name</span><span class="s2">,</span>
                    <span class="s1">dist.get_metadata(</span><span class="s4">'scripts/' </span><span class="s1">+ script_name)</span>
                <span class="s1">)</span>
        <span class="s1">self.install_wrapper_scripts(dist)</span>

    <span class="s2">def </span><span class="s1">add_output(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s2">if </span><span class="s1">os.path.isdir(path):</span>
            <span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(path):</span>
                <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">files:</span>
                    <span class="s1">self.outputs.append(os.path.join(base</span><span class="s2">, </span><span class="s1">filename))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.outputs.append(path)</span>

    <span class="s2">def </span><span class="s1">not_editable(self</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s2">if </span><span class="s1">self.editable:</span>
            <span class="s2">raise </span><span class="s1">DistutilsArgError(</span>
                <span class="s4">&quot;Invalid argument %r: you can't use filenames or URLs &quot;</span>
                <span class="s4">&quot;with --editable (except via the --find-links option).&quot;</span>
                <span class="s1">% (spec</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">check_editable(self</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s2">if not </span><span class="s1">self.editable:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.build_directory</span><span class="s2">, </span><span class="s1">spec.key)):</span>
            <span class="s2">raise </span><span class="s1">DistutilsArgError(</span>
                <span class="s4">&quot;%r already exists in %s; can't do a checkout there&quot; </span><span class="s1">%</span>
                <span class="s1">(spec.key</span><span class="s2">, </span><span class="s1">self.build_directory)</span>
            <span class="s1">)</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">_tmpdir(self):</span>
        <span class="s1">tmpdir = tempfile.mkdtemp(prefix=</span><span class="s4">u&quot;easy_install-&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># cast to str as workaround for #709 and #710 and #712</span>
            <span class="s2">yield </span><span class="s1">str(tmpdir)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">os.path.exists(tmpdir) </span><span class="s2">and </span><span class="s1">rmtree(tmpdir)</span>

    <span class="s2">def </span><span class="s1">easy_install(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">deps=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">with </span><span class="s1">self._tmpdir() </span><span class="s2">as </span><span class="s1">tmpdir:</span>
            <span class="s2">if not </span><span class="s1">isinstance(spec</span><span class="s2">, </span><span class="s1">Requirement):</span>
                <span class="s2">if </span><span class="s1">URL_SCHEME(spec):</span>
                    <span class="s3"># It's a url, download it to tmpdir and process</span>
                    <span class="s1">self.not_editable(spec)</span>
                    <span class="s1">dl = self.package_index.download(spec</span><span class="s2">, </span><span class="s1">tmpdir)</span>
                    <span class="s2">return </span><span class="s1">self.install_item(</span><span class="s2">None, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">deps</span><span class="s2">, True</span><span class="s1">)</span>

                <span class="s2">elif </span><span class="s1">os.path.exists(spec):</span>
                    <span class="s3"># Existing file or directory, just process it directly</span>
                    <span class="s1">self.not_editable(spec)</span>
                    <span class="s2">return </span><span class="s1">self.install_item(</span><span class="s2">None, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">deps</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">spec = parse_requirement_arg(spec)</span>

            <span class="s1">self.check_editable(spec)</span>
            <span class="s1">dist = self.package_index.fetch_distribution(</span>
                <span class="s1">spec</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">self.upgrade</span><span class="s2">, </span><span class="s1">self.editable</span><span class="s2">,</span>
                <span class="s2">not </span><span class="s1">self.always_copy</span><span class="s2">, </span><span class="s1">self.local_index</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">dist </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s4">&quot;Could not find suitable distribution for %r&quot; </span><span class="s1">% spec</span>
                <span class="s2">if </span><span class="s1">self.always_copy:</span>
                    <span class="s1">msg += </span><span class="s4">&quot; (--always-copy skips system and development eggs)&quot;</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(msg)</span>
            <span class="s2">elif </span><span class="s1">dist.precedence == DEVELOP_DIST:</span>
                <span class="s3"># .egg-info dists don't need installing, just process deps</span>
                <span class="s1">self.process_distribution(spec</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">deps</span><span class="s2">, </span><span class="s4">&quot;Using&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">dist</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.install_item(spec</span><span class="s2">, </span><span class="s1">dist.location</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">deps)</span>

    <span class="s2">def </span><span class="s1">install_item(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">download</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">deps</span><span class="s2">, </span><span class="s1">install_needed=</span><span class="s2">False</span><span class="s1">):</span>

        <span class="s3"># Installation is also needed if file in tmpdir or is not an egg</span>
        <span class="s1">install_needed = install_needed </span><span class="s2">or </span><span class="s1">self.always_copy</span>
        <span class="s1">install_needed = install_needed </span><span class="s2">or </span><span class="s1">os.path.dirname(download) == tmpdir</span>
        <span class="s1">install_needed = install_needed </span><span class="s2">or not </span><span class="s1">download.endswith(</span><span class="s4">'.egg'</span><span class="s1">)</span>
        <span class="s1">install_needed = install_needed </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">self.always_copy_from </span><span class="s2">is not None and</span>
            <span class="s1">os.path.dirname(normalize_path(download)) ==</span>
            <span class="s1">normalize_path(self.always_copy_from)</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">spec </span><span class="s2">and not </span><span class="s1">install_needed:</span>
            <span class="s3"># at this point, we know it's a local .egg, we just don't know if</span>
            <span class="s3"># it's already installed.</span>
            <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">self.local_index[spec.project_name]:</span>
                <span class="s2">if </span><span class="s1">dist.location == download:</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">install_needed = </span><span class="s2">True  </span><span class="s3"># it's not in the local index</span>

        <span class="s1">log.info(</span><span class="s4">&quot;Processing %s&quot;</span><span class="s2">, </span><span class="s1">os.path.basename(download))</span>

        <span class="s2">if </span><span class="s1">install_needed:</span>
            <span class="s1">dists = self.install_eggs(spec</span><span class="s2">, </span><span class="s1">download</span><span class="s2">, </span><span class="s1">tmpdir)</span>
            <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">dists:</span>
                <span class="s1">self.process_distribution(spec</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">deps)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dists = [self.egg_distribution(download)]</span>
            <span class="s1">self.process_distribution(spec</span><span class="s2">, </span><span class="s1">dists[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">deps</span><span class="s2">, </span><span class="s4">&quot;Using&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">spec </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">dists:</span>
                <span class="s2">if </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">spec:</span>
                    <span class="s2">return </span><span class="s1">dist</span>

    <span class="s2">def </span><span class="s1">select_scheme(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot;Sets the install directories by applying the install schemes.&quot;&quot;&quot;</span>
        <span class="s3"># it's the caller's problem if they supply a bad name!</span>
        <span class="s1">scheme = INSTALL_SCHEMES[name]</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">SCHEME_KEYS:</span>
            <span class="s1">attrname = </span><span class="s4">'install_' </span><span class="s1">+ key</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">attrname) </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attrname</span><span class="s2">, </span><span class="s1">scheme[key])</span>

    <span class="s3"># FIXME: 'easy_install.process_distribution' is too complex (12)</span>
    <span class="s2">def </span><span class="s1">process_distribution(  </span><span class="s3"># noqa: C901</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">deps=</span><span class="s2">True, </span><span class="s1">*info</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self.update_pth(dist)</span>
        <span class="s1">self.package_index.add(dist)</span>
        <span class="s2">if </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">self.local_index[dist.key]:</span>
            <span class="s1">self.local_index.remove(dist)</span>
        <span class="s1">self.local_index.add(dist)</span>
        <span class="s1">self.install_egg_scripts(dist)</span>
        <span class="s1">self.installed_projects[dist.key] = dist</span>
        <span class="s1">log.info(self.installation_report(requirement</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">*info))</span>
        <span class="s2">if </span><span class="s1">(dist.has_metadata(</span><span class="s4">'dependency_links.txt'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">self.no_find_links):</span>
            <span class="s1">self.package_index.add_find_links(</span>
                <span class="s1">dist.get_metadata_lines(</span><span class="s4">'dependency_links.txt'</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">deps </span><span class="s2">and not </span><span class="s1">self.always_copy:</span>
            <span class="s2">return</span>
        <span class="s2">elif </span><span class="s1">requirement </span><span class="s2">is not None and </span><span class="s1">dist.key != requirement.key:</span>
            <span class="s1">log.warn(</span><span class="s4">&quot;Skipping dependencies for %s&quot;</span><span class="s2">, </span><span class="s1">dist)</span>
            <span class="s2">return  </span><span class="s3"># XXX this is not the distribution we were looking for</span>
        <span class="s2">elif </span><span class="s1">requirement </span><span class="s2">is None or </span><span class="s1">dist </span><span class="s2">not in </span><span class="s1">requirement:</span>
            <span class="s3"># if we wound up with a different version, resolve what we've got</span>
            <span class="s1">distreq = dist.as_requirement()</span>
            <span class="s1">requirement = Requirement(str(distreq))</span>
        <span class="s1">log.info(</span><span class="s4">&quot;Processing dependencies for %s&quot;</span><span class="s2">, </span><span class="s1">requirement)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">distros = WorkingSet([]).resolve(</span>
                <span class="s1">[requirement]</span><span class="s2">, </span><span class="s1">self.local_index</span><span class="s2">, </span><span class="s1">self.easy_install</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">DistributionNotFound </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(str(e)) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">except </span><span class="s1">VersionConflict </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(e.report()) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">if </span><span class="s1">self.always_copy </span><span class="s2">or </span><span class="s1">self.always_copy_from:</span>
            <span class="s3"># Force all the relevant distros to be copied or activated</span>
            <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">distros:</span>
                <span class="s2">if </span><span class="s1">dist.key </span><span class="s2">not in </span><span class="s1">self.installed_projects:</span>
                    <span class="s1">self.easy_install(dist.as_requirement())</span>
        <span class="s1">log.info(</span><span class="s4">&quot;Finished processing dependencies for %s&quot;</span><span class="s2">, </span><span class="s1">requirement)</span>

    <span class="s2">def </span><span class="s1">should_unzip(self</span><span class="s2">, </span><span class="s1">dist):</span>
        <span class="s2">if </span><span class="s1">self.zip_ok </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return not </span><span class="s1">self.zip_ok</span>
        <span class="s2">if </span><span class="s1">dist.has_metadata(</span><span class="s4">'not-zip-safe'</span><span class="s1">):</span>
            <span class="s2">return True</span>
        <span class="s2">if not </span><span class="s1">dist.has_metadata(</span><span class="s4">'zip-safe'</span><span class="s1">):</span>
            <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">maybe_move(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">dist_filename</span><span class="s2">, </span><span class="s1">setup_base):</span>
        <span class="s1">dst = os.path.join(self.build_directory</span><span class="s2">, </span><span class="s1">spec.key)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(dst):</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;%r already exists in %s; build directory %s will not be kept&quot;</span>
            <span class="s1">)</span>
            <span class="s1">log.warn(msg</span><span class="s2">, </span><span class="s1">spec.key</span><span class="s2">, </span><span class="s1">self.build_directory</span><span class="s2">, </span><span class="s1">setup_base)</span>
            <span class="s2">return </span><span class="s1">setup_base</span>
        <span class="s2">if </span><span class="s1">os.path.isdir(dist_filename):</span>
            <span class="s1">setup_base = dist_filename</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">os.path.dirname(dist_filename) == setup_base:</span>
                <span class="s1">os.unlink(dist_filename)  </span><span class="s3"># get it out of the tmp dir</span>
            <span class="s1">contents = os.listdir(setup_base)</span>
            <span class="s2">if </span><span class="s1">len(contents) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">dist_filename = os.path.join(setup_base</span><span class="s2">, </span><span class="s1">contents[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s2">if </span><span class="s1">os.path.isdir(dist_filename):</span>
                    <span class="s3"># if the only thing there is a directory, move it instead</span>
                    <span class="s1">setup_base = dist_filename</span>
        <span class="s1">ensure_directory(dst)</span>
        <span class="s1">shutil.move(setup_base</span><span class="s2">, </span><span class="s1">dst)</span>
        <span class="s2">return </span><span class="s1">dst</span>

    <span class="s2">def </span><span class="s1">install_wrapper_scripts(self</span><span class="s2">, </span><span class="s1">dist):</span>
        <span class="s2">if </span><span class="s1">self.exclude_scripts:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">ScriptWriter.best().get_args(dist):</span>
            <span class="s1">self.write_script(*args)</span>

    <span class="s2">def </span><span class="s1">install_script(self</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">script_name</span><span class="s2">, </span><span class="s1">script_text</span><span class="s2">, </span><span class="s1">dev_path=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate a legacy script wrapper and install it&quot;&quot;&quot;</span>
        <span class="s1">spec = str(dist.as_requirement())</span>
        <span class="s1">is_script = is_python_script(script_text</span><span class="s2">, </span><span class="s1">script_name)</span>

        <span class="s2">if </span><span class="s1">is_script:</span>
            <span class="s1">body = self._load_template(dev_path) % locals()</span>
            <span class="s1">script_text = ScriptWriter.get_header(script_text) + body</span>
        <span class="s1">self.write_script(script_name</span><span class="s2">, </span><span class="s1">_to_bytes(script_text)</span><span class="s2">, </span><span class="s4">'b'</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_load_template(dev_path):</span>
        <span class="s0">&quot;&quot;&quot; 
        There are a couple of template scripts in the package. This 
        function loads one of them and prepares it for use. 
        &quot;&quot;&quot;</span>
        <span class="s3"># See https://github.com/pypa/setuptools/issues/134 for info</span>
        <span class="s3"># on script file naming and downstream issues with SVR4</span>
        <span class="s1">name = </span><span class="s4">'script.tmpl'</span>
        <span class="s2">if </span><span class="s1">dev_path:</span>
            <span class="s1">name = name.replace(</span><span class="s4">'.tmpl'</span><span class="s2">, </span><span class="s4">' (dev).tmpl'</span><span class="s1">)</span>

        <span class="s1">raw_bytes = resource_string(</span><span class="s4">'setuptools'</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">return </span><span class="s1">raw_bytes.decode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">write_script(self</span><span class="s2">, </span><span class="s1">script_name</span><span class="s2">, </span><span class="s1">contents</span><span class="s2">, </span><span class="s1">mode=</span><span class="s4">&quot;t&quot;</span><span class="s2">, </span><span class="s1">blockers=()):</span>
        <span class="s0">&quot;&quot;&quot;Write an executable file to the scripts directory&quot;&quot;&quot;</span>
        <span class="s1">self.delete_blockers(  </span><span class="s3"># clean up old .py/.pyw w/o a script</span>
            <span class="s1">[os.path.join(self.script_dir</span><span class="s2">, </span><span class="s1">x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">blockers]</span>
        <span class="s1">)</span>
        <span class="s1">log.info(</span><span class="s4">&quot;Installing %s script to %s&quot;</span><span class="s2">, </span><span class="s1">script_name</span><span class="s2">, </span><span class="s1">self.script_dir)</span>
        <span class="s1">target = os.path.join(self.script_dir</span><span class="s2">, </span><span class="s1">script_name)</span>
        <span class="s1">self.add_output(target)</span>

        <span class="s2">if </span><span class="s1">self.dry_run:</span>
            <span class="s2">return</span>

        <span class="s1">mask = current_umask()</span>
        <span class="s1">ensure_directory(target)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(target):</span>
            <span class="s1">os.unlink(target)</span>
        <span class="s2">with </span><span class="s1">open(target</span><span class="s2">, </span><span class="s4">&quot;w&quot; </span><span class="s1">+ mode) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.write(contents)</span>
        <span class="s1">chmod(target</span><span class="s2">, </span><span class="s5">0o777 </span><span class="s1">- mask)</span>

    <span class="s2">def </span><span class="s1">install_eggs(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">dist_filename</span><span class="s2">, </span><span class="s1">tmpdir):</span>
        <span class="s3"># .egg dirs or files are already built, so just return them</span>
        <span class="s1">installer_map = {</span>
            <span class="s4">'.egg'</span><span class="s1">: self.install_egg</span><span class="s2">,</span>
            <span class="s4">'.exe'</span><span class="s1">: self.install_exe</span><span class="s2">,</span>
            <span class="s4">'.whl'</span><span class="s1">: self.install_wheel</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">install_dist = installer_map[</span>
                <span class="s1">dist_filename.lower()[-</span><span class="s5">4</span><span class="s1">:]</span>
            <span class="s1">]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[install_dist(dist_filename</span><span class="s2">, </span><span class="s1">tmpdir)]</span>

        <span class="s3"># Anything else, try to extract and build</span>
        <span class="s1">setup_base = tmpdir</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(dist_filename) </span><span class="s2">and not </span><span class="s1">dist_filename.endswith(</span><span class="s4">'.py'</span><span class="s1">):</span>
            <span class="s1">unpack_archive(dist_filename</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">self.unpack_progress)</span>
        <span class="s2">elif </span><span class="s1">os.path.isdir(dist_filename):</span>
            <span class="s1">setup_base = os.path.abspath(dist_filename)</span>

        <span class="s2">if </span><span class="s1">(setup_base.startswith(tmpdir)  </span><span class="s3"># something we downloaded</span>
                <span class="s2">and </span><span class="s1">self.build_directory </span><span class="s2">and </span><span class="s1">spec </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">setup_base = self.maybe_move(spec</span><span class="s2">, </span><span class="s1">dist_filename</span><span class="s2">, </span><span class="s1">setup_base)</span>

        <span class="s3"># Find the setup.py file</span>
        <span class="s1">setup_script = os.path.join(setup_base</span><span class="s2">, </span><span class="s4">'setup.py'</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">os.path.exists(setup_script):</span>
            <span class="s1">setups = glob(os.path.join(setup_base</span><span class="s2">, </span><span class="s4">'*'</span><span class="s2">, </span><span class="s4">'setup.py'</span><span class="s1">))</span>
            <span class="s2">if not </span><span class="s1">setups:</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                    <span class="s4">&quot;Couldn't find a setup script in %s&quot; </span><span class="s1">%</span>
                    <span class="s1">os.path.abspath(dist_filename)</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(setups) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                    <span class="s4">&quot;Multiple setup scripts in %s&quot; </span><span class="s1">%</span>
                    <span class="s1">os.path.abspath(dist_filename)</span>
                <span class="s1">)</span>
            <span class="s1">setup_script = setups[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3"># Now run it, and return the result</span>
        <span class="s2">if </span><span class="s1">self.editable:</span>
            <span class="s1">log.info(self.report_editable(spec</span><span class="s2">, </span><span class="s1">setup_script))</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.build_and_install(setup_script</span><span class="s2">, </span><span class="s1">setup_base)</span>

    <span class="s2">def </span><span class="s1">egg_distribution(self</span><span class="s2">, </span><span class="s1">egg_path):</span>
        <span class="s2">if </span><span class="s1">os.path.isdir(egg_path):</span>
            <span class="s1">metadata = PathMetadata(egg_path</span><span class="s2">, </span><span class="s1">os.path.join(egg_path</span><span class="s2">,</span>
                                                           <span class="s4">'EGG-INFO'</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">metadata = EggMetadata(zipimport.zipimporter(egg_path))</span>
        <span class="s2">return </span><span class="s1">Distribution.from_filename(egg_path</span><span class="s2">, </span><span class="s1">metadata=metadata)</span>

    <span class="s3"># FIXME: 'easy_install.install_egg' is too complex (11)</span>
    <span class="s2">def </span><span class="s1">install_egg(self</span><span class="s2">, </span><span class="s1">egg_path</span><span class="s2">, </span><span class="s1">tmpdir):  </span><span class="s3"># noqa: C901</span>
        <span class="s1">destination = os.path.join(</span>
            <span class="s1">self.install_dir</span><span class="s2">,</span>
            <span class="s1">os.path.basename(egg_path)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">destination = os.path.abspath(destination)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s1">ensure_directory(destination)</span>

        <span class="s1">dist = self.egg_distribution(egg_path)</span>
        <span class="s2">if not </span><span class="s1">samefile(egg_path</span><span class="s2">, </span><span class="s1">destination):</span>
            <span class="s2">if </span><span class="s1">os.path.isdir(destination) </span><span class="s2">and not </span><span class="s1">os.path.islink(destination):</span>
                <span class="s1">dir_util.remove_tree(destination</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run)</span>
            <span class="s2">elif </span><span class="s1">os.path.exists(destination):</span>
                <span class="s1">self.execute(</span>
                    <span class="s1">os.unlink</span><span class="s2">,</span>
                    <span class="s1">(destination</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">&quot;Removing &quot; </span><span class="s1">+ destination</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">new_dist_is_zipped = </span><span class="s2">False</span>
                <span class="s2">if </span><span class="s1">os.path.isdir(egg_path):</span>
                    <span class="s2">if </span><span class="s1">egg_path.startswith(tmpdir):</span>
                        <span class="s1">f</span><span class="s2">, </span><span class="s1">m = shutil.move</span><span class="s2">, </span><span class="s4">&quot;Moving&quot;</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">f</span><span class="s2">, </span><span class="s1">m = shutil.copytree</span><span class="s2">, </span><span class="s4">&quot;Copying&quot;</span>
                <span class="s2">elif </span><span class="s1">self.should_unzip(dist):</span>
                    <span class="s1">self.mkpath(destination)</span>
                    <span class="s1">f</span><span class="s2">, </span><span class="s1">m = self.unpack_and_compile</span><span class="s2">, </span><span class="s4">&quot;Extracting&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">new_dist_is_zipped = </span><span class="s2">True</span>
                    <span class="s2">if </span><span class="s1">egg_path.startswith(tmpdir):</span>
                        <span class="s1">f</span><span class="s2">, </span><span class="s1">m = shutil.move</span><span class="s2">, </span><span class="s4">&quot;Moving&quot;</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">f</span><span class="s2">, </span><span class="s1">m = shutil.copy2</span><span class="s2">, </span><span class="s4">&quot;Copying&quot;</span>
                <span class="s1">self.execute(</span>
                    <span class="s1">f</span><span class="s2">,</span>
                    <span class="s1">(egg_path</span><span class="s2">, </span><span class="s1">destination)</span><span class="s2">,</span>
                    <span class="s1">(m + </span><span class="s4">&quot; %s to %s&quot;</span><span class="s1">) % (</span>
                        <span class="s1">os.path.basename(egg_path)</span><span class="s2">,</span>
                        <span class="s1">os.path.dirname(destination)</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">update_dist_caches(</span>
                    <span class="s1">destination</span><span class="s2">,</span>
                    <span class="s1">fix_zipimporter_caches=new_dist_is_zipped</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s1">update_dist_caches(destination</span><span class="s2">, </span><span class="s1">fix_zipimporter_caches=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s2">raise</span>

        <span class="s1">self.add_output(destination)</span>
        <span class="s2">return </span><span class="s1">self.egg_distribution(destination)</span>

    <span class="s2">def </span><span class="s1">install_exe(self</span><span class="s2">, </span><span class="s1">dist_filename</span><span class="s2">, </span><span class="s1">tmpdir):</span>
        <span class="s3"># See if it's valid, get data</span>
        <span class="s1">cfg = extract_wininst_cfg(dist_filename)</span>
        <span class="s2">if </span><span class="s1">cfg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                <span class="s4">&quot;%s is not a valid distutils Windows .exe&quot; </span><span class="s1">% dist_filename</span>
            <span class="s1">)</span>
        <span class="s3"># Create a dummy distribution object until we build the real distro</span>
        <span class="s1">dist = Distribution(</span>
            <span class="s2">None,</span>
            <span class="s1">project_name=cfg.get(</span><span class="s4">'metadata'</span><span class="s2">, </span><span class="s4">'name'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">version=cfg.get(</span><span class="s4">'metadata'</span><span class="s2">, </span><span class="s4">'version'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">platform=get_platform()</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s3"># Convert the .exe to an unpacked egg</span>
        <span class="s1">egg_path = os.path.join(tmpdir</span><span class="s2">, </span><span class="s1">dist.egg_name() + </span><span class="s4">'.egg'</span><span class="s1">)</span>
        <span class="s1">dist.location = egg_path</span>
        <span class="s1">egg_tmp = egg_path + </span><span class="s4">'.tmp'</span>
        <span class="s1">_egg_info = os.path.join(egg_tmp</span><span class="s2">, </span><span class="s4">'EGG-INFO'</span><span class="s1">)</span>
        <span class="s1">pkg_inf = os.path.join(_egg_info</span><span class="s2">, </span><span class="s4">'PKG-INFO'</span><span class="s1">)</span>
        <span class="s1">ensure_directory(pkg_inf)  </span><span class="s3"># make sure EGG-INFO dir exists</span>
        <span class="s1">dist._provider = PathMetadata(egg_tmp</span><span class="s2">, </span><span class="s1">_egg_info)  </span><span class="s3"># XXX</span>
        <span class="s1">self.exe_to_egg(dist_filename</span><span class="s2">, </span><span class="s1">egg_tmp)</span>

        <span class="s3"># Write EGG-INFO/PKG-INFO</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(pkg_inf):</span>
            <span class="s1">f = open(pkg_inf</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">)</span>
            <span class="s1">f.write(</span><span class="s4">'Metadata-Version: 1.0</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">cfg.items(</span><span class="s4">'metadata'</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">k != </span><span class="s4">'target_version'</span><span class="s1">:</span>
                    <span class="s1">f.write(</span><span class="s4">'%s: %s</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">% (k.replace(</span><span class="s4">'_'</span><span class="s2">, </span><span class="s4">'-'</span><span class="s1">).title()</span><span class="s2">, </span><span class="s1">v))</span>
            <span class="s1">f.close()</span>
        <span class="s1">script_dir = os.path.join(_egg_info</span><span class="s2">, </span><span class="s4">'scripts'</span><span class="s1">)</span>
        <span class="s3"># delete entry-point scripts to avoid duping</span>
        <span class="s1">self.delete_blockers([</span>
            <span class="s1">os.path.join(script_dir</span><span class="s2">, </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">ScriptWriter.get_args(dist)</span>
        <span class="s1">])</span>
        <span class="s3"># Build .egg file from tmpdir</span>
        <span class="s1">bdist_egg.make_zipfile(</span>
            <span class="s1">egg_path</span><span class="s2">, </span><span class="s1">egg_tmp</span><span class="s2">, </span><span class="s1">verbose=self.verbose</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s3"># install the .egg</span>
        <span class="s2">return </span><span class="s1">self.install_egg(egg_path</span><span class="s2">, </span><span class="s1">tmpdir)</span>

    <span class="s3"># FIXME: 'easy_install.exe_to_egg' is too complex (12)</span>
    <span class="s2">def </span><span class="s1">exe_to_egg(self</span><span class="s2">, </span><span class="s1">dist_filename</span><span class="s2">, </span><span class="s1">egg_tmp):  </span><span class="s3"># noqa: C901</span>
        <span class="s0">&quot;&quot;&quot;Extract a bdist_wininst to the directories an egg would use&quot;&quot;&quot;</span>
        <span class="s3"># Check for .pth file and set up prefix translations</span>
        <span class="s1">prefixes = get_exe_prefixes(dist_filename)</span>
        <span class="s1">to_compile = []</span>
        <span class="s1">native_libs = []</span>
        <span class="s1">top_level = {}</span>

        <span class="s2">def </span><span class="s1">process(src</span><span class="s2">, </span><span class="s1">dst):</span>
            <span class="s1">s = src.lower()</span>
            <span class="s2">for </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new </span><span class="s2">in </span><span class="s1">prefixes:</span>
                <span class="s2">if </span><span class="s1">s.startswith(old):</span>
                    <span class="s1">src = new + src[len(old):]</span>
                    <span class="s1">parts = src.split(</span><span class="s4">'/'</span><span class="s1">)</span>
                    <span class="s1">dst = os.path.join(egg_tmp</span><span class="s2">, </span><span class="s1">*parts)</span>
                    <span class="s1">dl = dst.lower()</span>
                    <span class="s2">if </span><span class="s1">dl.endswith(</span><span class="s4">'.pyd'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">dl.endswith(</span><span class="s4">'.dll'</span><span class="s1">):</span>
                        <span class="s1">parts[-</span><span class="s5">1</span><span class="s1">] = bdist_egg.strip_module(parts[-</span><span class="s5">1</span><span class="s1">])</span>
                        <span class="s1">top_level[os.path.splitext(parts[</span><span class="s5">0</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]] = </span><span class="s5">1</span>
                        <span class="s1">native_libs.append(src)</span>
                    <span class="s2">elif </span><span class="s1">dl.endswith(</span><span class="s4">'.py'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">old != </span><span class="s4">'SCRIPTS/'</span><span class="s1">:</span>
                        <span class="s1">top_level[os.path.splitext(parts[</span><span class="s5">0</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]] = </span><span class="s5">1</span>
                        <span class="s1">to_compile.append(dst)</span>
                    <span class="s2">return </span><span class="s1">dst</span>
            <span class="s2">if not </span><span class="s1">src.endswith(</span><span class="s4">'.pth'</span><span class="s1">):</span>
                <span class="s1">log.warn(</span><span class="s4">&quot;WARNING: can't process %s&quot;</span><span class="s2">, </span><span class="s1">src)</span>
            <span class="s2">return None</span>

        <span class="s3"># extract, tracking .pyd/.dll-&gt;native_libs and .py -&gt; to_compile</span>
        <span class="s1">unpack_archive(dist_filename</span><span class="s2">, </span><span class="s1">egg_tmp</span><span class="s2">, </span><span class="s1">process)</span>
        <span class="s1">stubs = []</span>
        <span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">native_libs:</span>
            <span class="s2">if </span><span class="s1">res.lower().endswith(</span><span class="s4">'.pyd'</span><span class="s1">):  </span><span class="s3"># create stubs for .pyd's</span>
                <span class="s1">parts = res.split(</span><span class="s4">'/'</span><span class="s1">)</span>
                <span class="s1">resource = parts[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">parts[-</span><span class="s5">1</span><span class="s1">] = bdist_egg.strip_module(parts[-</span><span class="s5">1</span><span class="s1">]) + </span><span class="s4">'.py'</span>
                <span class="s1">pyfile = os.path.join(egg_tmp</span><span class="s2">, </span><span class="s1">*parts)</span>
                <span class="s1">to_compile.append(pyfile)</span>
                <span class="s1">stubs.append(pyfile)</span>
                <span class="s1">bdist_egg.write_stub(resource</span><span class="s2">, </span><span class="s1">pyfile)</span>
        <span class="s1">self.byte_compile(to_compile)  </span><span class="s3"># compile .py's</span>
        <span class="s1">bdist_egg.write_safety_flag(</span>
            <span class="s1">os.path.join(egg_tmp</span><span class="s2">, </span><span class="s4">'EGG-INFO'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">bdist_egg.analyze_egg(egg_tmp</span><span class="s2">, </span><span class="s1">stubs))  </span><span class="s3"># write zip-safety flag</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s4">'top_level'</span><span class="s2">, </span><span class="s4">'native_libs'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">locals()[name]:</span>
                <span class="s1">txt = os.path.join(egg_tmp</span><span class="s2">, </span><span class="s4">'EGG-INFO'</span><span class="s2">, </span><span class="s1">name + </span><span class="s4">'.txt'</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">os.path.exists(txt):</span>
                    <span class="s1">f = open(txt</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">)</span>
                    <span class="s1">f.write(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(locals()[name]) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>
                    <span class="s1">f.close()</span>

    <span class="s2">def </span><span class="s1">install_wheel(self</span><span class="s2">, </span><span class="s1">wheel_path</span><span class="s2">, </span><span class="s1">tmpdir):</span>
        <span class="s1">wheel = Wheel(wheel_path)</span>
        <span class="s2">assert </span><span class="s1">wheel.is_compatible()</span>
        <span class="s1">destination = os.path.join(self.install_dir</span><span class="s2">, </span><span class="s1">wheel.egg_name())</span>
        <span class="s1">destination = os.path.abspath(destination)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s1">ensure_directory(destination)</span>
        <span class="s2">if </span><span class="s1">os.path.isdir(destination) </span><span class="s2">and not </span><span class="s1">os.path.islink(destination):</span>
            <span class="s1">dir_util.remove_tree(destination</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run)</span>
        <span class="s2">elif </span><span class="s1">os.path.exists(destination):</span>
            <span class="s1">self.execute(</span>
                <span class="s1">os.unlink</span><span class="s2">,</span>
                <span class="s1">(destination</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">&quot;Removing &quot; </span><span class="s1">+ destination</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.execute(</span>
                <span class="s1">wheel.install_as_egg</span><span class="s2">,</span>
                <span class="s1">(destination</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">&quot;Installing %s to %s&quot;</span><span class="s1">) % (</span>
                    <span class="s1">os.path.basename(wheel_path)</span><span class="s2">,</span>
                    <span class="s1">os.path.dirname(destination)</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">update_dist_caches(destination</span><span class="s2">, </span><span class="s1">fix_zipimporter_caches=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.add_output(destination)</span>
        <span class="s2">return </span><span class="s1">self.egg_distribution(destination)</span>

    <span class="s1">__mv_warning = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        Because this distribution was installed --multi-version, before you can 
        import modules from this package in an application, you will need to 
        'import pkg_resources' and then use a 'require()' call similar to one of 
        these examples, in order to select the desired version: 
 
            pkg_resources.require(&quot;%(name)s&quot;)  # latest installed version 
            pkg_resources.require(&quot;%(name)s==%(version)s&quot;)  # this exact version 
            pkg_resources.require(&quot;%(name)s&gt;=%(version)s&quot;)  # this version or higher 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()  </span><span class="s3"># noqa</span>

    <span class="s1">__id_warning = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        Note also that the installation directory must be on sys.path at runtime for 
        this to work.  (e.g. by being the application's script directory, by being on 
        PYTHONPATH, or by being added to sys.path by your code.) 
        &quot;&quot;&quot;</span><span class="s1">)  </span><span class="s3"># noqa</span>

    <span class="s2">def </span><span class="s1">installation_report(self</span><span class="s2">, </span><span class="s1">req</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">what=</span><span class="s4">&quot;Installed&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Helpful installation message for display to package users&quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">%(what)s %(eggloc)s%(extras)s&quot;</span>
        <span class="s2">if </span><span class="s1">self.multi_version </span><span class="s2">and not </span><span class="s1">self.no_report:</span>
            <span class="s1">msg += </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ self.__mv_warning</span>
            <span class="s2">if </span><span class="s1">self.install_dir </span><span class="s2">not in </span><span class="s1">map(normalize_path</span><span class="s2">, </span><span class="s1">sys.path):</span>
                <span class="s1">msg += </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ self.__id_warning</span>

        <span class="s1">eggloc = dist.location</span>
        <span class="s1">name = dist.project_name</span>
        <span class="s1">version = dist.version</span>
        <span class="s1">extras = </span><span class="s4">''  </span><span class="s3"># TODO: self.report_extras(req, dist)</span>
        <span class="s2">return </span><span class="s1">msg % locals()</span>

    <span class="s1">__editable_msg = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        Extracted editable version of %(spec)s to %(dirname)s 
 
        If it uses setuptools in its setup script, you can activate it in 
        &quot;development&quot; mode by going to that directory and running:: 
 
            %(python)s setup.py develop 
 
        See the setuptools documentation for the &quot;develop&quot; command for more info. 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()  </span><span class="s3"># noqa</span>

    <span class="s2">def </span><span class="s1">report_editable(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">setup_script):</span>
        <span class="s1">dirname = os.path.dirname(setup_script)</span>
        <span class="s1">python = sys.executable</span>
        <span class="s2">return </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ self.__editable_msg % locals()</span>

    <span class="s2">def </span><span class="s1">run_setup(self</span><span class="s2">, </span><span class="s1">setup_script</span><span class="s2">, </span><span class="s1">setup_base</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s1">sys.modules.setdefault(</span><span class="s4">'distutils.command.bdist_egg'</span><span class="s2">, </span><span class="s1">bdist_egg)</span>
        <span class="s1">sys.modules.setdefault(</span><span class="s4">'distutils.command.egg_info'</span><span class="s2">, </span><span class="s1">egg_info)</span>

        <span class="s1">args = list(args)</span>
        <span class="s2">if </span><span class="s1">self.verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">v = </span><span class="s4">'v' </span><span class="s1">* (self.verbose - </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s4">'-' </span><span class="s1">+ v)</span>
        <span class="s2">elif </span><span class="s1">self.verbose &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s4">'-q'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.dry_run:</span>
            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s4">'-n'</span><span class="s1">)</span>
        <span class="s1">log.info(</span>
            <span class="s4">&quot;Running %s %s&quot;</span><span class="s2">, </span><span class="s1">setup_script[len(setup_base) + </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s4">' '</span><span class="s1">.join(args)</span>
        <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">run_setup(setup_script</span><span class="s2">, </span><span class="s1">args)</span>
        <span class="s2">except </span><span class="s1">SystemExit </span><span class="s2">as </span><span class="s1">v:</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(</span>
                <span class="s4">&quot;Setup script exited with %s&quot; </span><span class="s1">% (v.args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">build_and_install(self</span><span class="s2">, </span><span class="s1">setup_script</span><span class="s2">, </span><span class="s1">setup_base):</span>
        <span class="s1">args = [</span><span class="s4">'bdist_egg'</span><span class="s2">, </span><span class="s4">'--dist-dir'</span><span class="s1">]</span>

        <span class="s1">dist_dir = tempfile.mkdtemp(</span>
            <span class="s1">prefix=</span><span class="s4">'egg-dist-tmp-'</span><span class="s2">, </span><span class="s1">dir=os.path.dirname(setup_script)</span>
        <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._set_fetcher_options(os.path.dirname(setup_script))</span>
            <span class="s1">args.append(dist_dir)</span>

            <span class="s1">self.run_setup(setup_script</span><span class="s2">, </span><span class="s1">setup_base</span><span class="s2">, </span><span class="s1">args)</span>
            <span class="s1">all_eggs = Environment([dist_dir])</span>
            <span class="s1">eggs = []</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">all_eggs:</span>
                <span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">all_eggs[key]:</span>
                    <span class="s1">eggs.append(self.install_egg(dist.location</span><span class="s2">, </span><span class="s1">setup_base))</span>
            <span class="s2">if not </span><span class="s1">eggs </span><span class="s2">and not </span><span class="s1">self.dry_run:</span>
                <span class="s1">log.warn(</span><span class="s4">&quot;No eggs found in %s (setup script problem?)&quot;</span><span class="s2">,</span>
                         <span class="s1">dist_dir)</span>
            <span class="s2">return </span><span class="s1">eggs</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">rmtree(dist_dir)</span>
            <span class="s1">log.set_verbosity(self.verbose)  </span><span class="s3"># restore our log verbosity</span>

    <span class="s2">def </span><span class="s1">_set_fetcher_options(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s0">&quot;&quot;&quot; 
        When easy_install is about to run bdist_egg on a source dist, that 
        source dist might have 'setup_requires' directives, requiring 
        additional fetching. Ensure the fetcher options given to easy_install 
        are available to that command as well. 
        &quot;&quot;&quot;</span>
        <span class="s3"># find the fetch options from easy_install and write them out</span>
        <span class="s3"># to the setup.cfg file.</span>
        <span class="s1">ei_opts = self.distribution.get_option_dict(</span><span class="s4">'easy_install'</span><span class="s1">).copy()</span>
        <span class="s1">fetch_directives = (</span>
            <span class="s4">'find_links'</span><span class="s2">, </span><span class="s4">'site_dirs'</span><span class="s2">, </span><span class="s4">'index_url'</span><span class="s2">, </span><span class="s4">'optimize'</span><span class="s2">, </span><span class="s4">'allow_hosts'</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">fetch_options = {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">ei_opts.items():</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">fetch_directives:</span>
                <span class="s2">continue</span>
            <span class="s1">fetch_options[key] = val[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3"># create a settings dictionary suitable for `edit_config`</span>
        <span class="s1">settings = dict(easy_install=fetch_options)</span>
        <span class="s1">cfg_filename = os.path.join(base</span><span class="s2">, </span><span class="s4">'setup.cfg'</span><span class="s1">)</span>
        <span class="s1">setopt.edit_config(cfg_filename</span><span class="s2">, </span><span class="s1">settings)</span>

    <span class="s2">def </span><span class="s1">update_pth(self</span><span class="s2">, </span><span class="s1">dist):  </span><span class="s3"># noqa: C901  # is too complex (11)  # FIXME</span>
        <span class="s2">if </span><span class="s1">self.pth_file </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.pth_file[dist.key]:  </span><span class="s3"># drop old entries</span>
            <span class="s2">if not </span><span class="s1">self.multi_version </span><span class="s2">and </span><span class="s1">d.location == dist.location:</span>
                <span class="s2">continue</span>

            <span class="s1">log.info(</span><span class="s4">&quot;Removing %s from easy-install.pth file&quot;</span><span class="s2">, </span><span class="s1">d)</span>
            <span class="s1">self.pth_file.remove(d)</span>
            <span class="s2">if </span><span class="s1">d.location </span><span class="s2">in </span><span class="s1">self.shadow_path:</span>
                <span class="s1">self.shadow_path.remove(d.location)</span>

        <span class="s2">if not </span><span class="s1">self.multi_version:</span>
            <span class="s2">if </span><span class="s1">dist.location </span><span class="s2">in </span><span class="s1">self.pth_file.paths:</span>
                <span class="s1">log.info(</span>
                    <span class="s4">&quot;%s is already the active version in easy-install.pth&quot;</span><span class="s2">,</span>
                    <span class="s1">dist</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">log.info(</span><span class="s4">&quot;Adding %s to easy-install.pth file&quot;</span><span class="s2">, </span><span class="s1">dist)</span>
                <span class="s1">self.pth_file.add(dist)  </span><span class="s3"># add new entry</span>
                <span class="s2">if </span><span class="s1">dist.location </span><span class="s2">not in </span><span class="s1">self.shadow_path:</span>
                    <span class="s1">self.shadow_path.append(dist.location)</span>

        <span class="s2">if </span><span class="s1">self.dry_run:</span>
            <span class="s2">return</span>

        <span class="s1">self.pth_file.save()</span>

        <span class="s2">if </span><span class="s1">dist.key != </span><span class="s4">'setuptools'</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s3"># Ensure that setuptools itself never becomes unavailable!</span>
        <span class="s3"># XXX should this check for latest version?</span>
        <span class="s1">filename = os.path.join(self.install_dir</span><span class="s2">, </span><span class="s4">'setuptools.pth'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">os.path.islink(filename):</span>
            <span class="s1">os.unlink(filename)</span>
        <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s4">'wt'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.write(self.pth_file.make_relative(dist.location) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">unpack_progress(self</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">dst):</span>
        <span class="s3"># Progress filter for unpacking</span>
        <span class="s1">log.debug(</span><span class="s4">&quot;Unpacking %s to %s&quot;</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">dst)</span>
        <span class="s2">return </span><span class="s1">dst  </span><span class="s3"># only unpack-and-compile skips files for dry run</span>

    <span class="s2">def </span><span class="s1">unpack_and_compile(self</span><span class="s2">, </span><span class="s1">egg_path</span><span class="s2">, </span><span class="s1">destination):</span>
        <span class="s1">to_compile = []</span>
        <span class="s1">to_chmod = []</span>

        <span class="s2">def </span><span class="s1">pf(src</span><span class="s2">, </span><span class="s1">dst):</span>
            <span class="s2">if </span><span class="s1">dst.endswith(</span><span class="s4">'.py'</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">src.startswith(</span><span class="s4">'EGG-INFO/'</span><span class="s1">):</span>
                <span class="s1">to_compile.append(dst)</span>
            <span class="s2">elif </span><span class="s1">dst.endswith(</span><span class="s4">'.dll'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">dst.endswith(</span><span class="s4">'.so'</span><span class="s1">):</span>
                <span class="s1">to_chmod.append(dst)</span>
            <span class="s1">self.unpack_progress(src</span><span class="s2">, </span><span class="s1">dst)</span>
            <span class="s2">return not </span><span class="s1">self.dry_run </span><span class="s2">and </span><span class="s1">dst </span><span class="s2">or None</span>

        <span class="s1">unpack_archive(egg_path</span><span class="s2">, </span><span class="s1">destination</span><span class="s2">, </span><span class="s1">pf)</span>
        <span class="s1">self.byte_compile(to_compile)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">to_chmod:</span>
                <span class="s1">mode = ((os.stat(f)[stat.ST_MODE]) | </span><span class="s5">0o555</span><span class="s1">) &amp; </span><span class="s5">0o7755</span>
                <span class="s1">chmod(f</span><span class="s2">, </span><span class="s1">mode)</span>

    <span class="s2">def </span><span class="s1">byte_compile(self</span><span class="s2">, </span><span class="s1">to_compile):</span>
        <span class="s2">if </span><span class="s1">sys.dont_write_bytecode:</span>
            <span class="s2">return</span>

        <span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">byte_compile</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># try to make the byte compile messages quieter</span>
            <span class="s1">log.set_verbosity(self.verbose - </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s1">byte_compile(to_compile</span><span class="s2">, </span><span class="s1">optimize=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">force=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run)</span>
            <span class="s2">if </span><span class="s1">self.optimize:</span>
                <span class="s1">byte_compile(</span>
                    <span class="s1">to_compile</span><span class="s2">, </span><span class="s1">optimize=self.optimize</span><span class="s2">, </span><span class="s1">force=</span><span class="s5">1</span><span class="s2">,</span>
                    <span class="s1">dry_run=self.dry_run</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">log.set_verbosity(self.verbose)  </span><span class="s3"># restore original verbosity</span>

    <span class="s1">__no_default_msg = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        bad install directory or PYTHONPATH 
 
        You are attempting to install a package to a directory that is not 
        on PYTHONPATH and which Python does not read &quot;.pth&quot; files from.  The 
        installation directory you specified (via --install-dir, --prefix, or 
        the distutils default setting) was: 
 
            %s 
 
        and your PYTHONPATH environment variable currently contains: 
 
            %r 
 
        Here are some of your options for correcting the problem: 
 
        * You can choose a different installation directory, i.e., one that is 
          on PYTHONPATH or supports .pth files 
 
        * You can add the installation directory to the PYTHONPATH environment 
          variable.  (It must then also be on PYTHONPATH whenever you run 
          Python and want to use the package(s) you are installing.) 
 
        * You can set up the installation directory to support &quot;.pth&quot; files by 
          using one of the approaches described here: 
 
          https://setuptools.readthedocs.io/en/latest/easy_install.html#custom-installation-locations 
 
 
        Please make the appropriate changes for your system and try again. 
        &quot;&quot;&quot;</span><span class="s1">).strip()</span>

    <span class="s2">def </span><span class="s1">create_home_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Create directories under ~.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.user:</span>
            <span class="s2">return</span>
        <span class="s1">home = convert_path(os.path.expanduser(</span><span class="s4">&quot;~&quot;</span><span class="s1">))</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.config_vars.items():</span>
            <span class="s2">if </span><span class="s1">path.startswith(home) </span><span class="s2">and not </span><span class="s1">os.path.isdir(path):</span>
                <span class="s1">self.debug_print(</span><span class="s4">&quot;os.makedirs('%s', 0o700)&quot; </span><span class="s1">% path)</span>
                <span class="s1">os.makedirs(path</span><span class="s2">, </span><span class="s5">0o700</span><span class="s1">)</span>

    <span class="s1">INSTALL_SCHEMES = dict(</span>
        <span class="s1">posix=dict(</span>
            <span class="s1">install_dir=</span><span class="s4">'$base/lib/python$py_version_short/site-packages'</span><span class="s2">,</span>
            <span class="s1">script_dir=</span><span class="s4">'$base/bin'</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">DEFAULT_SCHEME = dict(</span>
        <span class="s1">install_dir=</span><span class="s4">'$base/Lib/site-packages'</span><span class="s2">,</span>
        <span class="s1">script_dir=</span><span class="s4">'$base/Scripts'</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_expand(self</span><span class="s2">, </span><span class="s1">*attrs):</span>
        <span class="s1">config_vars = self.get_finalized_command(</span><span class="s4">'install'</span><span class="s1">).config_vars</span>

        <span class="s2">if </span><span class="s1">self.prefix:</span>
            <span class="s3"># Set default install_dir/scripts from --prefix</span>
            <span class="s1">config_vars = config_vars.copy()</span>
            <span class="s1">config_vars[</span><span class="s4">'base'</span><span class="s1">] = self.prefix</span>
            <span class="s1">scheme = self.INSTALL_SCHEMES.get(os.name</span><span class="s2">, </span><span class="s1">self.DEFAULT_SCHEME)</span>
            <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">scheme.items():</span>
                <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>

        <span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">subst_vars</span>

        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
            <span class="s1">val = getattr(self</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">val = subst_vars(val</span><span class="s2">, </span><span class="s1">config_vars)</span>
                <span class="s2">if </span><span class="s1">os.name == </span><span class="s4">'posix'</span><span class="s1">:</span>
                    <span class="s1">val = os.path.expanduser(val)</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>


<span class="s2">def </span><span class="s1">_pythonpath():</span>
    <span class="s1">items = os.environ.get(</span><span class="s4">'PYTHONPATH'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">).split(os.pathsep)</span>
    <span class="s2">return </span><span class="s1">filter(</span><span class="s2">None, </span><span class="s1">items)</span>


<span class="s2">def </span><span class="s1">get_site_dirs():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a list of 'site' dirs 
    &quot;&quot;&quot;</span>

    <span class="s1">sitedirs = []</span>

    <span class="s3"># start with PYTHONPATH</span>
    <span class="s1">sitedirs.extend(_pythonpath())</span>

    <span class="s1">prefixes = [sys.prefix]</span>
    <span class="s2">if </span><span class="s1">sys.exec_prefix != sys.prefix:</span>
        <span class="s1">prefixes.append(sys.exec_prefix)</span>
    <span class="s2">for </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">prefixes:</span>
        <span class="s2">if not </span><span class="s1">prefix:</span>
            <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">sys.platform </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'os2emx'</span><span class="s2">, </span><span class="s4">'riscos'</span><span class="s1">):</span>
            <span class="s1">sitedirs.append(os.path.join(prefix</span><span class="s2">, </span><span class="s4">&quot;Lib&quot;</span><span class="s2">, </span><span class="s4">&quot;site-packages&quot;</span><span class="s1">))</span>
        <span class="s2">elif </span><span class="s1">os.sep == </span><span class="s4">'/'</span><span class="s1">:</span>
            <span class="s1">sitedirs.extend([</span>
                <span class="s1">os.path.join(</span>
                    <span class="s1">prefix</span><span class="s2">,</span>
                    <span class="s4">&quot;lib&quot;</span><span class="s2">,</span>
                    <span class="s4">&quot;python{}.{}&quot;</span><span class="s1">.format(*sys.version_info)</span><span class="s2">,</span>
                    <span class="s4">&quot;site-packages&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s4">&quot;lib&quot;</span><span class="s2">, </span><span class="s4">&quot;site-python&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sitedirs.extend([</span>
                <span class="s1">prefix</span><span class="s2">,</span>
                <span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s4">&quot;lib&quot;</span><span class="s2">, </span><span class="s4">&quot;site-packages&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">])</span>
        <span class="s2">if </span><span class="s1">sys.platform != </span><span class="s4">'darwin'</span><span class="s1">:</span>
            <span class="s2">continue</span>

        <span class="s3"># for framework builds *only* we add the standard Apple</span>
        <span class="s3"># locations. Currently only per-user, but /Library and</span>
        <span class="s3"># /Network/Library could be added too</span>
        <span class="s2">if </span><span class="s4">'Python.framework' </span><span class="s2">not in </span><span class="s1">prefix:</span>
            <span class="s2">continue</span>

        <span class="s1">home = os.environ.get(</span><span class="s4">'HOME'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">home:</span>
            <span class="s2">continue</span>

        <span class="s1">home_sp = os.path.join(</span>
            <span class="s1">home</span><span class="s2">,</span>
            <span class="s4">'Library'</span><span class="s2">,</span>
            <span class="s4">'Python'</span><span class="s2">,</span>
            <span class="s4">'{}.{}'</span><span class="s1">.format(*sys.version_info)</span><span class="s2">,</span>
            <span class="s4">'site-packages'</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">sitedirs.append(home_sp)</span>
    <span class="s1">lib_paths = get_path(</span><span class="s4">'purelib'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">get_path(</span><span class="s4">'platlib'</span><span class="s1">)</span>

    <span class="s1">sitedirs.extend(s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">lib_paths </span><span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">sitedirs)</span>

    <span class="s2">if </span><span class="s1">site.ENABLE_USER_SITE:</span>
        <span class="s1">sitedirs.append(site.USER_SITE)</span>

    <span class="s2">with </span><span class="s1">contextlib.suppress(AttributeError):</span>
        <span class="s1">sitedirs.extend(site.getsitepackages())</span>

    <span class="s1">sitedirs = list(map(normalize_path</span><span class="s2">, </span><span class="s1">sitedirs))</span>

    <span class="s2">return </span><span class="s1">sitedirs</span>


<span class="s2">def </span><span class="s1">expand_paths(inputs):  </span><span class="s3"># noqa: C901  # is too complex (11)  # FIXME</span>
    <span class="s0">&quot;&quot;&quot;Yield sys.path directories that might contain &quot;old-style&quot; packages&quot;&quot;&quot;</span>

    <span class="s1">seen = {}</span>

    <span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">inputs:</span>
        <span class="s1">dirname = normalize_path(dirname)</span>
        <span class="s2">if </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">seen:</span>
            <span class="s2">continue</span>

        <span class="s1">seen[dirname] = </span><span class="s5">1</span>
        <span class="s2">if not </span><span class="s1">os.path.isdir(dirname):</span>
            <span class="s2">continue</span>

        <span class="s1">files = os.listdir(dirname)</span>
        <span class="s2">yield </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">files</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s2">if not </span><span class="s1">name.endswith(</span><span class="s4">'.pth'</span><span class="s1">):</span>
                <span class="s3"># We only care about the .pth files</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'easy-install.pth'</span><span class="s2">, </span><span class="s4">'setuptools.pth'</span><span class="s1">):</span>
                <span class="s3"># Ignore .pth files that we control</span>
                <span class="s2">continue</span>

            <span class="s3"># Read the .pth file</span>
            <span class="s1">f = open(os.path.join(dirname</span><span class="s2">, </span><span class="s1">name))</span>
            <span class="s1">lines = list(yield_lines(f))</span>
            <span class="s1">f.close()</span>

            <span class="s3"># Yield existing non-dupe, non-import directory lines from it</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
                <span class="s2">if </span><span class="s1">line.startswith(</span><span class="s4">&quot;import&quot;</span><span class="s1">):</span>
                    <span class="s2">continue</span>

                <span class="s1">line = normalize_path(line.rstrip())</span>
                <span class="s2">if </span><span class="s1">line </span><span class="s2">in </span><span class="s1">seen:</span>
                    <span class="s2">continue</span>

                <span class="s1">seen[line] = </span><span class="s5">1</span>
                <span class="s2">if not </span><span class="s1">os.path.isdir(line):</span>
                    <span class="s2">continue</span>

                <span class="s2">yield </span><span class="s1">line</span><span class="s2">, </span><span class="s1">os.listdir(line)</span>


<span class="s2">def </span><span class="s1">extract_wininst_cfg(dist_filename):</span>
    <span class="s0">&quot;&quot;&quot;Extract configuration data from a bdist_wininst .exe 
 
    Returns a configparser.RawConfigParser, or None 
    &quot;&quot;&quot;</span>
    <span class="s1">f = open(dist_filename</span><span class="s2">, </span><span class="s4">'rb'</span><span class="s1">)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">endrec = zipfile._EndRecData(f)</span>
        <span class="s2">if </span><span class="s1">endrec </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s1">prepended = (endrec[</span><span class="s5">9</span><span class="s1">] - endrec[</span><span class="s5">5</span><span class="s1">]) - endrec[</span><span class="s5">6</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">prepended &lt; </span><span class="s5">12</span><span class="s1">:  </span><span class="s3"># no wininst data here</span>
            <span class="s2">return None</span>
        <span class="s1">f.seek(prepended - </span><span class="s5">12</span><span class="s1">)</span>

        <span class="s1">tag</span><span class="s2">, </span><span class="s1">cfglen</span><span class="s2">, </span><span class="s1">bmlen = struct.unpack(</span><span class="s4">&quot;&lt;iii&quot;</span><span class="s2">, </span><span class="s1">f.read(</span><span class="s5">12</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">tag </span><span class="s2">not in </span><span class="s1">(</span><span class="s5">0x1234567A</span><span class="s2">, </span><span class="s5">0x1234567B</span><span class="s1">):</span>
            <span class="s2">return None  </span><span class="s3"># not a valid tag</span>

        <span class="s1">f.seek(prepended - (</span><span class="s5">12 </span><span class="s1">+ cfglen))</span>
        <span class="s1">init = {</span><span class="s4">'version'</span><span class="s1">: </span><span class="s4">''</span><span class="s2">, </span><span class="s4">'target_version'</span><span class="s1">: </span><span class="s4">''</span><span class="s1">}</span>
        <span class="s1">cfg = configparser.RawConfigParser(init)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">part = f.read(cfglen)</span>
            <span class="s3"># Read up to the first null byte.</span>
            <span class="s1">config = part.split(</span><span class="s6">b'</span><span class="s2">\0</span><span class="s6">'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3"># Now the config is in bytes, but for RawConfigParser, it should</span>
            <span class="s3">#  be text, so decode it.</span>
            <span class="s1">config = config.decode(sys.getfilesystemencoding())</span>
            <span class="s1">cfg.readfp(io.StringIO(config))</span>
        <span class="s2">except </span><span class="s1">configparser.Error:</span>
            <span class="s2">return None</span>
        <span class="s2">if not </span><span class="s1">cfg.has_section(</span><span class="s4">'metadata'</span><span class="s1">) </span><span class="s2">or not </span><span class="s1">cfg.has_section(</span><span class="s4">'Setup'</span><span class="s1">):</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">cfg</span>

    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">f.close()</span>


<span class="s2">def </span><span class="s1">get_exe_prefixes(exe_filename):</span>
    <span class="s0">&quot;&quot;&quot;Get exe-&gt;egg path translations for a given .exe file&quot;&quot;&quot;</span>

    <span class="s1">prefixes = [</span>
        <span class="s1">(</span><span class="s4">'PURELIB/'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'PLATLIB/pywin32_system32'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'PLATLIB/'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'SCRIPTS/'</span><span class="s2">, </span><span class="s4">'EGG-INFO/scripts/'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'DATA/lib/site-packages'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">z = zipfile.ZipFile(exe_filename)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">info </span><span class="s2">in </span><span class="s1">z.infolist():</span>
            <span class="s1">name = info.filename</span>
            <span class="s1">parts = name.split(</span><span class="s4">'/'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(parts) == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">parts[</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'PKG-INFO'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">].endswith(</span><span class="s4">'.egg-info'</span><span class="s1">):</span>
                    <span class="s1">prefixes.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'/'</span><span class="s1">.join(parts[:</span><span class="s5">2</span><span class="s1">])</span><span class="s2">, </span><span class="s4">'EGG-INFO/'</span><span class="s1">))</span>
                    <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">len(parts) != </span><span class="s5">2 </span><span class="s2">or not </span><span class="s1">name.endswith(</span><span class="s4">'.pth'</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s4">'-nspkg.pth'</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">].upper() </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'PURELIB'</span><span class="s2">, </span><span class="s4">'PLATLIB'</span><span class="s1">):</span>
                <span class="s1">contents = z.read(name).decode()</span>
                <span class="s2">for </span><span class="s1">pth </span><span class="s2">in </span><span class="s1">yield_lines(contents):</span>
                    <span class="s1">pth = pth.strip().replace(</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'/'</span><span class="s1">)</span>
                    <span class="s2">if not </span><span class="s1">pth.startswith(</span><span class="s4">'import'</span><span class="s1">):</span>
                        <span class="s1">prefixes.append(((</span><span class="s4">'%s/%s/' </span><span class="s1">% (parts[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pth))</span><span class="s2">, </span><span class="s4">''</span><span class="s1">))</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">z.close()</span>
    <span class="s1">prefixes = [(x.lower()</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">prefixes]</span>
    <span class="s1">prefixes.sort()</span>
    <span class="s1">prefixes.reverse()</span>
    <span class="s2">return </span><span class="s1">prefixes</span>


<span class="s2">class </span><span class="s1">PthDistributions(Environment):</span>
    <span class="s0">&quot;&quot;&quot;A .pth file with Distribution paths in it&quot;&quot;&quot;</span>

    <span class="s1">dirty = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">sitedirs=()):</span>
        <span class="s1">self.filename = filename</span>
        <span class="s1">self.sitedirs = list(map(normalize_path</span><span class="s2">, </span><span class="s1">sitedirs))</span>
        <span class="s1">self.basedir = normalize_path(os.path.dirname(self.filename))</span>
        <span class="s1">self._load()</span>
        <span class="s1">Environment.__init__(self</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, None, None</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">yield_lines(self.paths):</span>
            <span class="s1">list(map(self.add</span><span class="s2">, </span><span class="s1">find_distributions(path</span><span class="s2">, True</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">_load(self):</span>
        <span class="s1">self.paths = []</span>
        <span class="s1">saw_import = </span><span class="s2">False</span>
        <span class="s1">seen = dict.fromkeys(self.sitedirs)</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(self.filename):</span>
            <span class="s1">f = open(self.filename</span><span class="s2">, </span><span class="s4">'rt'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">f:</span>
                <span class="s2">if </span><span class="s1">line.startswith(</span><span class="s4">'import'</span><span class="s1">):</span>
                    <span class="s1">saw_import = </span><span class="s2">True</span>
                    <span class="s2">continue</span>
                <span class="s1">path = line.rstrip()</span>
                <span class="s1">self.paths.append(path)</span>
                <span class="s2">if not </span><span class="s1">path.strip() </span><span class="s2">or </span><span class="s1">path.strip().startswith(</span><span class="s4">'#'</span><span class="s1">):</span>
                    <span class="s2">continue</span>
                <span class="s3"># skip non-existent paths, in case somebody deleted a package</span>
                <span class="s3"># manually, and duplicate paths as well</span>
                <span class="s1">path = self.paths[-</span><span class="s5">1</span><span class="s1">] = normalize_path(</span>
                    <span class="s1">os.path.join(self.basedir</span><span class="s2">, </span><span class="s1">path)</span>
                <span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">os.path.exists(path) </span><span class="s2">or </span><span class="s1">path </span><span class="s2">in </span><span class="s1">seen:</span>
                    <span class="s1">self.paths.pop()  </span><span class="s3"># skip it</span>
                    <span class="s1">self.dirty = </span><span class="s2">True  </span><span class="s3"># we cleaned up, so we're dirty now :)</span>
                    <span class="s2">continue</span>
                <span class="s1">seen[path] = </span><span class="s5">1</span>
            <span class="s1">f.close()</span>

        <span class="s2">if </span><span class="s1">self.paths </span><span class="s2">and not </span><span class="s1">saw_import:</span>
            <span class="s1">self.dirty = </span><span class="s2">True  </span><span class="s3"># ensure anything we touch has import wrappers</span>
        <span class="s2">while </span><span class="s1">self.paths </span><span class="s2">and not </span><span class="s1">self.paths[-</span><span class="s5">1</span><span class="s1">].strip():</span>
            <span class="s1">self.paths.pop()</span>

    <span class="s2">def </span><span class="s1">save(self):</span>
        <span class="s0">&quot;&quot;&quot;Write changed .pth file back to disk&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.dirty:</span>
            <span class="s2">return</span>

        <span class="s1">rel_paths = list(map(self.make_relative</span><span class="s2">, </span><span class="s1">self.paths))</span>
        <span class="s2">if </span><span class="s1">rel_paths:</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;Saving %s&quot;</span><span class="s2">, </span><span class="s1">self.filename)</span>
            <span class="s1">lines = self._wrap_lines(rel_paths)</span>
            <span class="s1">data = </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(lines) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>

            <span class="s2">if </span><span class="s1">os.path.islink(self.filename):</span>
                <span class="s1">os.unlink(self.filename)</span>
            <span class="s2">with </span><span class="s1">open(self.filename</span><span class="s2">, </span><span class="s4">'wt'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">f.write(data)</span>

        <span class="s2">elif </span><span class="s1">os.path.exists(self.filename):</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;Deleting empty %s&quot;</span><span class="s2">, </span><span class="s1">self.filename)</span>
            <span class="s1">os.unlink(self.filename)</span>

        <span class="s1">self.dirty = </span><span class="s2">False</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_wrap_lines(lines):</span>
        <span class="s2">return </span><span class="s1">lines</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">dist):</span>
        <span class="s0">&quot;&quot;&quot;Add `dist` to the distribution map&quot;&quot;&quot;</span>
        <span class="s1">new_path = (</span>
            <span class="s1">dist.location </span><span class="s2">not in </span><span class="s1">self.paths </span><span class="s2">and </span><span class="s1">(</span>
                <span class="s1">dist.location </span><span class="s2">not in </span><span class="s1">self.sitedirs </span><span class="s2">or</span>
                <span class="s3"># account for '.' being in PYTHONPATH</span>
                <span class="s1">dist.location == os.getcwd()</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">new_path:</span>
            <span class="s1">self.paths.append(dist.location)</span>
            <span class="s1">self.dirty = </span><span class="s2">True</span>
        <span class="s1">Environment.add(self</span><span class="s2">, </span><span class="s1">dist)</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">dist):</span>
        <span class="s0">&quot;&quot;&quot;Remove `dist` from the distribution map&quot;&quot;&quot;</span>
        <span class="s2">while </span><span class="s1">dist.location </span><span class="s2">in </span><span class="s1">self.paths:</span>
            <span class="s1">self.paths.remove(dist.location)</span>
            <span class="s1">self.dirty = </span><span class="s2">True</span>
        <span class="s1">Environment.remove(self</span><span class="s2">, </span><span class="s1">dist)</span>

    <span class="s2">def </span><span class="s1">make_relative(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">npath</span><span class="s2">, </span><span class="s1">last = os.path.split(normalize_path(path))</span>
        <span class="s1">baselen = len(self.basedir)</span>
        <span class="s1">parts = [last]</span>
        <span class="s1">sep = os.altsep == </span><span class="s4">'/' </span><span class="s2">and </span><span class="s4">'/' </span><span class="s2">or </span><span class="s1">os.sep</span>
        <span class="s2">while </span><span class="s1">len(npath) &gt;= baselen:</span>
            <span class="s2">if </span><span class="s1">npath == self.basedir:</span>
                <span class="s1">parts.append(os.curdir)</span>
                <span class="s1">parts.reverse()</span>
                <span class="s2">return </span><span class="s1">sep.join(parts)</span>
            <span class="s1">npath</span><span class="s2">, </span><span class="s1">last = os.path.split(npath)</span>
            <span class="s1">parts.append(last)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path</span>


<span class="s2">class </span><span class="s1">RewritePthDistributions(PthDistributions):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_wrap_lines(cls</span><span class="s2">, </span><span class="s1">lines):</span>
        <span class="s2">yield </span><span class="s1">cls.prelude</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
            <span class="s2">yield </span><span class="s1">line</span>
        <span class="s2">yield </span><span class="s1">cls.postlude</span>

    <span class="s1">prelude = _one_liner(</span><span class="s4">&quot;&quot;&quot; 
        import sys 
        sys.__plen = len(sys.path) 
        &quot;&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">postlude = _one_liner(</span><span class="s4">&quot;&quot;&quot; 
        import sys 
        new = sys.path[sys.__plen:] 
        del sys.path[sys.__plen:] 
        p = getattr(sys, '__egginsert', 0) 
        sys.path[p:p] = new 
        sys.__egginsert = p + len(new) 
        &quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">os.environ.get(</span><span class="s4">'SETUPTOOLS_SYS_PATH_TECHNIQUE'</span><span class="s2">, </span><span class="s4">'raw'</span><span class="s1">) == </span><span class="s4">'rewrite'</span><span class="s1">:</span>
    <span class="s1">PthDistributions = RewritePthDistributions</span>


<span class="s2">def </span><span class="s1">_first_line_re():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a regular expression based on first_line_re suitable for matching 
    strings. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(first_line_re.pattern</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">first_line_re</span>

    <span class="s3"># first_line_re in Python &gt;=3.1.4 and &gt;=3.2.1 is a bytes pattern.</span>
    <span class="s2">return </span><span class="s1">re.compile(first_line_re.pattern.decode())</span>


<span class="s2">def </span><span class="s1">auto_chmod(func</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">exc):</span>
    <span class="s2">if </span><span class="s1">func </span><span class="s2">in </span><span class="s1">[os.unlink</span><span class="s2">, </span><span class="s1">os.remove] </span><span class="s2">and </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
        <span class="s1">chmod(arg</span><span class="s2">, </span><span class="s1">stat.S_IWRITE)</span>
        <span class="s2">return </span><span class="s1">func(arg)</span>
    <span class="s1">et</span><span class="s2">, </span><span class="s1">ev</span><span class="s2">, </span><span class="s1">_ = sys.exc_info()</span>
    <span class="s3"># TODO: This code doesn't make sense. What is it trying to do?</span>
    <span class="s2">raise </span><span class="s1">(ev[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ev[</span><span class="s5">1</span><span class="s1">] + (</span><span class="s4">&quot; %s %s&quot; </span><span class="s1">% (func</span><span class="s2">, </span><span class="s1">arg)))</span>


<span class="s2">def </span><span class="s1">update_dist_caches(dist_path</span><span class="s2">, </span><span class="s1">fix_zipimporter_caches):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fix any globally cached `dist_path` related data 
 
    `dist_path` should be a path of a newly installed egg distribution (zipped 
    or unzipped). 
 
    sys.path_importer_cache contains finder objects that have been cached when 
    importing data from the original distribution. Any such finders need to be 
    cleared since the replacement distribution might be packaged differently, 
    e.g. a zipped egg distribution might get replaced with an unzipped egg 
    folder or vice versa. Having the old finders cached may then cause Python 
    to attempt loading modules from the replacement distribution using an 
    incorrect loader. 
 
    zipimport.zipimporter objects are Python loaders charged with importing 
    data packaged inside zip archives. If stale loaders referencing the 
    original distribution, are left behind, they can fail to load modules from 
    the replacement distribution. E.g. if an old zipimport.zipimporter instance 
    is used to load data from a new zipped egg archive, it may cause the 
    operation to attempt to locate the requested data in the wrong location - 
    one indicated by the original distribution's zip archive directory 
    information. Such an operation may then fail outright, e.g. report having 
    read a 'bad local file header', or even worse, it may fail silently &amp; 
    return invalid data. 
 
    zipimport._zip_directory_cache contains cached zip archive directory 
    information for all existing zipimport.zipimporter instances and all such 
    instances connected to the same archive share the same cached directory 
    information. 
 
    If asked, and the underlying Python implementation allows it, we can fix 
    all existing zipimport.zipimporter instances instead of having to track 
    them down and remove them one by one, by updating their shared cached zip 
    archive directory information. This, of course, assumes that the 
    replacement distribution is packaged as a zipped egg. 
 
    If not asked to fix existing zipimport.zipimporter instances, we still do 
    our best to clear any remaining zipimport.zipimporter related cached data 
    that might somehow later get used when attempting to load data from the new 
    distribution and thus cause such load operations to fail. Note that when 
    tracking down such remaining stale data, we can not catch every conceivable 
    usage from here, and we clear only those that we know of and have found to 
    cause problems if left alive. Any remaining caches should be updated by 
    whomever is in charge of maintaining them, i.e. they should be ready to 
    handle us replacing their zip archives with new distributions at runtime. 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># There are several other known sources of stale zipimport.zipimporter</span>
    <span class="s3"># instances that we do not clear here, but might if ever given a reason to</span>
    <span class="s3"># do so:</span>
    <span class="s3"># * Global setuptools pkg_resources.working_set (a.k.a. 'master working</span>
    <span class="s3"># set') may contain distributions which may in turn contain their</span>
    <span class="s3">#   zipimport.zipimporter loaders.</span>
    <span class="s3"># * Several zipimport.zipimporter loaders held by local variables further</span>
    <span class="s3">#   up the function call stack when running the setuptools installation.</span>
    <span class="s3"># * Already loaded modules may have their __loader__ attribute set to the</span>
    <span class="s3">#   exact loader instance used when importing them. Python 3.4 docs state</span>
    <span class="s3">#   that this information is intended mostly for introspection and so is</span>
    <span class="s3">#   not expected to cause us problems.</span>
    <span class="s1">normalized_path = normalize_path(dist_path)</span>
    <span class="s1">_uncache(normalized_path</span><span class="s2">, </span><span class="s1">sys.path_importer_cache)</span>
    <span class="s2">if </span><span class="s1">fix_zipimporter_caches:</span>
        <span class="s1">_replace_zip_directory_cache_data(normalized_path)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Here, even though we do not want to fix existing and now stale</span>
        <span class="s3"># zipimporter cache information, we still want to remove it. Related to</span>
        <span class="s3"># Python's zip archive directory information cache, we clear each of</span>
        <span class="s3"># its stale entries in two phases:</span>
        <span class="s3">#   1. Clear the entry so attempting to access zip archive information</span>
        <span class="s3">#      via any existing stale zipimport.zipimporter instances fails.</span>
        <span class="s3">#   2. Remove the entry from the cache so any newly constructed</span>
        <span class="s3">#      zipimport.zipimporter instances do not end up using old stale</span>
        <span class="s3">#      zip archive directory information.</span>
        <span class="s3"># This whole stale data removal step does not seem strictly necessary,</span>
        <span class="s3"># but has been left in because it was done before we started replacing</span>
        <span class="s3"># the zip archive directory information cache content if possible, and</span>
        <span class="s3"># there are no relevant unit tests that we can depend on to tell us if</span>
        <span class="s3"># this is really needed.</span>
        <span class="s1">_remove_and_clear_zip_directory_cache_data(normalized_path)</span>


<span class="s2">def </span><span class="s1">_collect_zipimporter_cache_entries(normalized_path</span><span class="s2">, </span><span class="s1">cache):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return zipimporter cache entry keys related to a given normalized path. 
 
    Alternative path spellings (e.g. those using different character case or 
    those using alternative path separators) related to the same path are 
    included. Any sub-path entries are included as well, i.e. those 
    corresponding to zip archives embedded in other zip archives. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">result = []</span>
    <span class="s1">prefix_len = len(normalized_path)</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">cache:</span>
        <span class="s1">np = normalize_path(p)</span>
        <span class="s2">if </span><span class="s1">(np.startswith(normalized_path) </span><span class="s2">and</span>
                <span class="s1">np[prefix_len:prefix_len + </span><span class="s5">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(os.sep</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)):</span>
            <span class="s1">result.append(p)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_update_zipimporter_cache(normalized_path</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">updater=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Update zipimporter cache data for a given normalized path. 
 
    Any sub-path entries are processed as well, i.e. those corresponding to zip 
    archives embedded in other zip archives. 
 
    Given updater is a callable taking a cache entry key and the original entry 
    (after already removing the entry from the cache), and expected to update 
    the entry and possibly return a new one to be inserted in its place. 
    Returning None indicates that the entry should not be replaced with a new 
    one. If no updater is given, the cache entries are simply removed without 
    any additional processing, the same as if the updater simply returned None. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">_collect_zipimporter_cache_entries(normalized_path</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s3"># N.B. pypy's custom zipimport._zip_directory_cache implementation does</span>
        <span class="s3"># not support the complete dict interface:</span>
        <span class="s3"># * Does not support item assignment, thus not allowing this function</span>
        <span class="s3">#    to be used only for removing existing cache entries.</span>
        <span class="s3">#  * Does not support the dict.pop() method, forcing us to use the</span>
        <span class="s3">#    get/del patterns instead. For more detailed information see the</span>
        <span class="s3">#    following links:</span>
        <span class="s3">#      https://github.com/pypa/setuptools/issues/202#issuecomment-202913420</span>
        <span class="s3">#      http://bit.ly/2h9itJX</span>
        <span class="s1">old_entry = cache[p]</span>
        <span class="s2">del </span><span class="s1">cache[p]</span>
        <span class="s1">new_entry = updater </span><span class="s2">and </span><span class="s1">updater(p</span><span class="s2">, </span><span class="s1">old_entry)</span>
        <span class="s2">if </span><span class="s1">new_entry </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">cache[p] = new_entry</span>


<span class="s2">def </span><span class="s1">_uncache(normalized_path</span><span class="s2">, </span><span class="s1">cache):</span>
    <span class="s1">_update_zipimporter_cache(normalized_path</span><span class="s2">, </span><span class="s1">cache)</span>


<span class="s2">def </span><span class="s1">_remove_and_clear_zip_directory_cache_data(normalized_path):</span>
    <span class="s2">def </span><span class="s1">clear_and_remove_cached_zip_archive_directory_data(path</span><span class="s2">, </span><span class="s1">old_entry):</span>
        <span class="s1">old_entry.clear()</span>

    <span class="s1">_update_zipimporter_cache(</span>
        <span class="s1">normalized_path</span><span class="s2">, </span><span class="s1">zipimport._zip_directory_cache</span><span class="s2">,</span>
        <span class="s1">updater=clear_and_remove_cached_zip_archive_directory_data)</span>


<span class="s3"># PyPy Python implementation does not allow directly writing to the</span>
<span class="s3"># zipimport._zip_directory_cache and so prevents us from attempting to correct</span>
<span class="s3"># its content. The best we can do there is clear the problematic cache content</span>
<span class="s3"># and have PyPy repopulate it as needed. The downside is that if there are any</span>
<span class="s3"># stale zipimport.zipimporter instances laying around, attempting to use them</span>
<span class="s3"># will fail due to not having its zip archive directory information available</span>
<span class="s3"># instead of being automatically corrected to use the new correct zip archive</span>
<span class="s3"># directory information.</span>
<span class="s2">if </span><span class="s4">'__pypy__' </span><span class="s2">in </span><span class="s1">sys.builtin_module_names:</span>
    <span class="s1">_replace_zip_directory_cache_data = \</span>
        <span class="s1">_remove_and_clear_zip_directory_cache_data</span>
<span class="s2">else</span><span class="s1">:</span>

    <span class="s2">def </span><span class="s1">_replace_zip_directory_cache_data(normalized_path):</span>
        <span class="s2">def </span><span class="s1">replace_cached_zip_archive_directory_data(path</span><span class="s2">, </span><span class="s1">old_entry):</span>
            <span class="s3"># N.B. In theory, we could load the zip directory information just</span>
            <span class="s3"># once for all updated path spellings, and then copy it locally and</span>
            <span class="s3"># update its contained path strings to contain the correct</span>
            <span class="s3"># spelling, but that seems like a way too invasive move (this cache</span>
            <span class="s3"># structure is not officially documented anywhere and could in</span>
            <span class="s3"># theory change with new Python releases) for no significant</span>
            <span class="s3"># benefit.</span>
            <span class="s1">old_entry.clear()</span>
            <span class="s1">zipimport.zipimporter(path)</span>
            <span class="s1">old_entry.update(zipimport._zip_directory_cache[path])</span>
            <span class="s2">return </span><span class="s1">old_entry</span>

        <span class="s1">_update_zipimporter_cache(</span>
            <span class="s1">normalized_path</span><span class="s2">, </span><span class="s1">zipimport._zip_directory_cache</span><span class="s2">,</span>
            <span class="s1">updater=replace_cached_zip_archive_directory_data)</span>


<span class="s2">def </span><span class="s1">is_python(text</span><span class="s2">, </span><span class="s1">filename=</span><span class="s4">'&lt;string&gt;'</span><span class="s1">):</span>
    <span class="s0">&quot;Is this string a valid Python script?&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">compile(text</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s4">'exec'</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">(SyntaxError</span><span class="s2">, </span><span class="s1">TypeError):</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">is_sh(executable):</span>
    <span class="s0">&quot;&quot;&quot;Determine if the specified executable is a .sh (contains a #! line)&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">with </span><span class="s1">io.open(executable</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">'latin-1'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp:</span>
            <span class="s1">magic = fp.read(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">IOError):</span>
        <span class="s2">return </span><span class="s1">executable</span>
    <span class="s2">return </span><span class="s1">magic == </span><span class="s4">'#!'</span>


<span class="s2">def </span><span class="s1">nt_quote_arg(arg):</span>
    <span class="s0">&quot;&quot;&quot;Quote a command line argument according to Windows parsing rules&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">subprocess.list2cmdline([arg])</span>


<span class="s2">def </span><span class="s1">is_python_script(script_text</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s0">&quot;&quot;&quot;Is this text, as a whole, a Python script? (as opposed to shell/bat/etc. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">filename.endswith(</span><span class="s4">'.py'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">filename.endswith(</span><span class="s4">'.pyw'</span><span class="s1">):</span>
        <span class="s2">return True  </span><span class="s3"># extension says it's Python</span>
    <span class="s2">if </span><span class="s1">is_python(script_text</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s2">return True  </span><span class="s3"># it's syntactically valid Python</span>
    <span class="s2">if </span><span class="s1">script_text.startswith(</span><span class="s4">'#!'</span><span class="s1">):</span>
        <span class="s3"># It begins with a '#!' line, so check if 'python' is in it somewhere</span>
        <span class="s2">return </span><span class="s4">'python' </span><span class="s2">in </span><span class="s1">script_text.splitlines()[</span><span class="s5">0</span><span class="s1">].lower()</span>

    <span class="s2">return False  </span><span class="s3"># Not any Python I can recognize</span>


<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">os </span><span class="s2">import </span><span class="s1">chmod </span><span class="s2">as </span><span class="s1">_chmod</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s3"># Jython compatibility</span>
    <span class="s2">def </span><span class="s1">_chmod(*args):</span>
        <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">chmod(path</span><span class="s2">, </span><span class="s1">mode):</span>
    <span class="s1">log.debug(</span><span class="s4">&quot;changing mode of %s to %o&quot;</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mode)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">_chmod(path</span><span class="s2">, </span><span class="s1">mode)</span>
    <span class="s2">except </span><span class="s1">os.error </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">log.debug(</span><span class="s4">&quot;chmod failed: %s&quot;</span><span class="s2">, </span><span class="s1">e)</span>


<span class="s2">class </span><span class="s1">CommandSpec(list):</span>
    <span class="s0">&quot;&quot;&quot; 
    A command spec for a #! header, specified as a list of arguments akin to 
    those passed to Popen. 
    &quot;&quot;&quot;</span>

    <span class="s1">options = []</span>
    <span class="s1">split_args = dict()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">best(cls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Choose the best CommandSpec class based on environmental conditions. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_sys_executable(cls):</span>
        <span class="s1">_default = os.path.normpath(sys.executable)</span>
        <span class="s2">return </span><span class="s1">os.environ.get(</span><span class="s4">'__PYVENV_LAUNCHER__'</span><span class="s2">, </span><span class="s1">_default)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_param(cls</span><span class="s2">, </span><span class="s1">param):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a CommandSpec from a parameter to build_scripts, which may 
        be None. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(param</span><span class="s2">, </span><span class="s1">cls):</span>
            <span class="s2">return </span><span class="s1">param</span>
        <span class="s2">if </span><span class="s1">isinstance(param</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s2">return </span><span class="s1">cls(param)</span>
        <span class="s2">if </span><span class="s1">param </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls.from_environment()</span>
        <span class="s3"># otherwise, assume it's a string.</span>
        <span class="s2">return </span><span class="s1">cls.from_string(param)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_environment(cls):</span>
        <span class="s2">return </span><span class="s1">cls([cls._sys_executable()])</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_string(cls</span><span class="s2">, </span><span class="s1">string):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a command spec from a simple string representing a command 
        line parseable by shlex.split. 
        &quot;&quot;&quot;</span>
        <span class="s1">items = shlex.split(string</span><span class="s2">, </span><span class="s1">**cls.split_args)</span>
        <span class="s2">return </span><span class="s1">cls(items)</span>

    <span class="s2">def </span><span class="s1">install_options(self</span><span class="s2">, </span><span class="s1">script_text):</span>
        <span class="s1">self.options = shlex.split(self._extract_options(script_text))</span>
        <span class="s1">cmdline = subprocess.list2cmdline(self)</span>
        <span class="s2">if not </span><span class="s1">isascii(cmdline):</span>
            <span class="s1">self.options[:</span><span class="s5">0</span><span class="s1">] = [</span><span class="s4">'-x'</span><span class="s1">]</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_extract_options(orig_script):</span>
        <span class="s0">&quot;&quot;&quot; 
        Extract any options from the first line of the script. 
        &quot;&quot;&quot;</span>
        <span class="s1">first = (orig_script + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">).splitlines()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">match = _first_line_re().match(first)</span>
        <span class="s1">options = match.group(</span><span class="s5">1</span><span class="s1">) </span><span class="s2">or </span><span class="s4">'' </span><span class="s2">if </span><span class="s1">match </span><span class="s2">else </span><span class="s4">''</span>
        <span class="s2">return </span><span class="s1">options.strip()</span>

    <span class="s2">def </span><span class="s1">as_header(self):</span>
        <span class="s2">return </span><span class="s1">self._render(self + list(self.options))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_strip_quotes(item):</span>
        <span class="s1">_QUOTES = </span><span class="s4">'&quot;</span><span class="s2">\'</span><span class="s4">'</span>
        <span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">_QUOTES:</span>
            <span class="s2">if </span><span class="s1">item.startswith(q) </span><span class="s2">and </span><span class="s1">item.endswith(q):</span>
                <span class="s2">return </span><span class="s1">item[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">item</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_render(items):</span>
        <span class="s1">cmdline = subprocess.list2cmdline(</span>
            <span class="s1">CommandSpec._strip_quotes(item.strip()) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">items)</span>
        <span class="s2">return </span><span class="s4">'#!' </span><span class="s1">+ cmdline + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>


<span class="s3"># For pbr compat; will be removed in a future version.</span>
<span class="s1">sys_executable = CommandSpec._sys_executable()</span>


<span class="s2">class </span><span class="s1">WindowsCommandSpec(CommandSpec):</span>
    <span class="s1">split_args = dict(posix=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ScriptWriter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Encapsulates behavior around writing entry point scripts for console and 
    gui apps. 
    &quot;&quot;&quot;</span>

    <span class="s1">template = textwrap.dedent(</span><span class="s4">r&quot;&quot;&quot; 
        # EASY-INSTALL-ENTRY-SCRIPT: %(spec)r,%(group)r,%(name)r 
        import re 
        import sys 
 
        # for compatibility with easy_install; see #2198 
        __requires__ = %(spec)r 
 
        try: 
            from importlib.metadata import distribution 
        except ImportError: 
            try: 
                from importlib_metadata import distribution 
            except ImportError: 
                from pkg_resources import load_entry_point 
 
 
        def importlib_load_entry_point(spec, group, name): 
            dist_name, _, _ = spec.partition('==') 
            matches = ( 
                entry_point 
                for entry_point in distribution(dist_name).entry_points 
                if entry_point.group == group and entry_point.name == name 
            ) 
            return next(matches).load() 
 
 
        globals().setdefault('load_entry_point', importlib_load_entry_point) 
 
 
        if __name__ == '__main__': 
            sys.argv[0] = re.sub(r'(-script\.pyw?|\.exe)?$', '', sys.argv[0]) 
            sys.exit(load_entry_point(%(spec)r, %(group)r, %(name)r)()) 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()</span>

    <span class="s1">command_spec_class = CommandSpec</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_script_args(cls</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">executable=</span><span class="s2">None, </span><span class="s1">wininst=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># for backward compatibility</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;Use get_args&quot;</span><span class="s2">, </span><span class="s1">EasyInstallDeprecationWarning)</span>
        <span class="s1">writer = (WindowsScriptWriter </span><span class="s2">if </span><span class="s1">wininst </span><span class="s2">else </span><span class="s1">ScriptWriter).best()</span>
        <span class="s1">header = cls.get_script_header(</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">executable</span><span class="s2">, </span><span class="s1">wininst)</span>
        <span class="s2">return </span><span class="s1">writer.get_args(dist</span><span class="s2">, </span><span class="s1">header)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_script_header(cls</span><span class="s2">, </span><span class="s1">script_text</span><span class="s2">, </span><span class="s1">executable=</span><span class="s2">None, </span><span class="s1">wininst=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># for backward compatibility</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;Use get_header&quot;</span><span class="s2">, </span><span class="s1">EasyInstallDeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">wininst:</span>
            <span class="s1">executable = </span><span class="s4">&quot;python.exe&quot;</span>
        <span class="s2">return </span><span class="s1">cls.get_header(script_text</span><span class="s2">, </span><span class="s1">executable)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_args(cls</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Yield write_script() argument tuples for a distribution's 
        console_scripts and gui_scripts entry points. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">header </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">header = cls.get_header()</span>
        <span class="s1">spec = str(dist.as_requirement())</span>
        <span class="s2">for </span><span class="s1">type_ </span><span class="s2">in </span><span class="s4">'console'</span><span class="s2">, </span><span class="s4">'gui'</span><span class="s1">:</span>
            <span class="s1">group = type_ + </span><span class="s4">'_scripts'</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ep </span><span class="s2">in </span><span class="s1">dist.get_entry_map(group).items():</span>
                <span class="s1">cls._ensure_safe_name(name)</span>
                <span class="s1">script_text = cls.template % locals()</span>
                <span class="s1">args = cls._get_script_args(type_</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">script_text)</span>
                <span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">args:</span>
                    <span class="s2">yield </span><span class="s1">res</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_ensure_safe_name(name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Prevent paths in *_scripts entry point names. 
        &quot;&quot;&quot;</span>
        <span class="s1">has_path_sep = re.search(</span><span class="s4">r'[\\/]'</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">if </span><span class="s1">has_path_sep:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Path separators not allowed in script names&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_writer(cls</span><span class="s2">, </span><span class="s1">force_windows):</span>
        <span class="s3"># for backward compatibility</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;Use best&quot;</span><span class="s2">, </span><span class="s1">EasyInstallDeprecationWarning)</span>
        <span class="s2">return </span><span class="s1">WindowsScriptWriter.best() </span><span class="s2">if </span><span class="s1">force_windows </span><span class="s2">else </span><span class="s1">cls.best()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">best(cls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Select the best ScriptWriter for this environment. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s4">'win32' </span><span class="s2">or </span><span class="s1">(os.name == </span><span class="s4">'java' </span><span class="s2">and </span><span class="s1">os._name == </span><span class="s4">'nt'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">WindowsScriptWriter.best()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_get_script_args(cls</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">script_text):</span>
        <span class="s3"># Simply write the stub with no extension.</span>
        <span class="s2">yield </span><span class="s1">(name</span><span class="s2">, </span><span class="s1">header + script_text)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_header(cls</span><span class="s2">, </span><span class="s1">script_text=</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">executable=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a #! line, getting options (if any) from script_text&quot;&quot;&quot;</span>
        <span class="s1">cmd = cls.command_spec_class.best().from_param(executable)</span>
        <span class="s1">cmd.install_options(script_text)</span>
        <span class="s2">return </span><span class="s1">cmd.as_header()</span>


<span class="s2">class </span><span class="s1">WindowsScriptWriter(ScriptWriter):</span>
    <span class="s1">command_spec_class = WindowsCommandSpec</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_writer(cls):</span>
        <span class="s3"># for backward compatibility</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;Use best&quot;</span><span class="s2">, </span><span class="s1">EasyInstallDeprecationWarning)</span>
        <span class="s2">return </span><span class="s1">cls.best()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">best(cls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Select the best ScriptWriter suitable for Windows 
        &quot;&quot;&quot;</span>
        <span class="s1">writer_lookup = dict(</span>
            <span class="s1">executable=WindowsExecutableLauncherWriter</span><span class="s2">,</span>
            <span class="s1">natural=cls</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s3"># for compatibility, use the executable launcher by default</span>
        <span class="s1">launcher = os.environ.get(</span><span class="s4">'SETUPTOOLS_LAUNCHER'</span><span class="s2">, </span><span class="s4">'executable'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">writer_lookup[launcher]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_get_script_args(cls</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">script_text):</span>
        <span class="s0">&quot;For Windows, add a .py extension&quot;</span>
        <span class="s1">ext = dict(console=</span><span class="s4">'.pya'</span><span class="s2">, </span><span class="s1">gui=</span><span class="s4">'.pyw'</span><span class="s1">)[type_]</span>
        <span class="s2">if </span><span class="s1">ext </span><span class="s2">not in </span><span class="s1">os.environ[</span><span class="s4">'PATHEXT'</span><span class="s1">].lower().split(</span><span class="s4">';'</span><span class="s1">):</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;{ext} not listed in PATHEXT; scripts will not be &quot;</span>
                <span class="s4">&quot;recognized as executables.&quot;</span>
            <span class="s1">).format(**locals())</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning)</span>
        <span class="s1">old = [</span><span class="s4">'.pya'</span><span class="s2">, </span><span class="s4">'.py'</span><span class="s2">, </span><span class="s4">'-script.py'</span><span class="s2">, </span><span class="s4">'.pyc'</span><span class="s2">, </span><span class="s4">'.pyo'</span><span class="s2">, </span><span class="s4">'.pyw'</span><span class="s2">, </span><span class="s4">'.exe'</span><span class="s1">]</span>
        <span class="s1">old.remove(ext)</span>
        <span class="s1">header = cls._adjust_header(type_</span><span class="s2">, </span><span class="s1">header)</span>
        <span class="s1">blockers = [name + x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">old]</span>
        <span class="s2">yield </span><span class="s1">name + ext</span><span class="s2">, </span><span class="s1">header + script_text</span><span class="s2">, </span><span class="s4">'t'</span><span class="s2">, </span><span class="s1">blockers</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_adjust_header(cls</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">orig_header):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make sure 'pythonw' is used for gui and 'python' is used for 
        console (regardless of what sys.executable is). 
        &quot;&quot;&quot;</span>
        <span class="s1">pattern = </span><span class="s4">'pythonw.exe'</span>
        <span class="s1">repl = </span><span class="s4">'python.exe'</span>
        <span class="s2">if </span><span class="s1">type_ == </span><span class="s4">'gui'</span><span class="s1">:</span>
            <span class="s1">pattern</span><span class="s2">, </span><span class="s1">repl = repl</span><span class="s2">, </span><span class="s1">pattern</span>
        <span class="s1">pattern_ob = re.compile(re.escape(pattern)</span><span class="s2">, </span><span class="s1">re.IGNORECASE)</span>
        <span class="s1">new_header = pattern_ob.sub(string=orig_header</span><span class="s2">, </span><span class="s1">repl=repl)</span>
        <span class="s2">return </span><span class="s1">new_header </span><span class="s2">if </span><span class="s1">cls._use_header(new_header) </span><span class="s2">else </span><span class="s1">orig_header</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_use_header(new_header):</span>
        <span class="s0">&quot;&quot;&quot; 
        Should _adjust_header use the replaced header? 
 
        On non-windows systems, always use. On 
        Windows systems, only use the replaced header if it resolves 
        to an executable on the system. 
        &quot;&quot;&quot;</span>
        <span class="s1">clean_header = new_header[</span><span class="s5">2</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">].strip(</span><span class="s4">'&quot;'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">sys.platform != </span><span class="s4">'win32' </span><span class="s2">or </span><span class="s1">find_executable(clean_header)</span>


<span class="s2">class </span><span class="s1">WindowsExecutableLauncherWriter(WindowsScriptWriter):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_get_script_args(cls</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">script_text):</span>
        <span class="s0">&quot;&quot;&quot; 
        For Windows, add a .py extension and an .exe launcher 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">type_ == </span><span class="s4">'gui'</span><span class="s1">:</span>
            <span class="s1">launcher_type = </span><span class="s4">'gui'</span>
            <span class="s1">ext = </span><span class="s4">'-script.pyw'</span>
            <span class="s1">old = [</span><span class="s4">'.pyw'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">launcher_type = </span><span class="s4">'cli'</span>
            <span class="s1">ext = </span><span class="s4">'-script.py'</span>
            <span class="s1">old = [</span><span class="s4">'.py'</span><span class="s2">, </span><span class="s4">'.pyc'</span><span class="s2">, </span><span class="s4">'.pyo'</span><span class="s1">]</span>
        <span class="s1">hdr = cls._adjust_header(type_</span><span class="s2">, </span><span class="s1">header)</span>
        <span class="s1">blockers = [name + x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">old]</span>
        <span class="s2">yield </span><span class="s1">(name + ext</span><span class="s2">, </span><span class="s1">hdr + script_text</span><span class="s2">, </span><span class="s4">'t'</span><span class="s2">, </span><span class="s1">blockers)</span>
        <span class="s2">yield </span><span class="s1">(</span>
            <span class="s1">name + </span><span class="s4">'.exe'</span><span class="s2">, </span><span class="s1">get_win_launcher(launcher_type)</span><span class="s2">,</span>
            <span class="s4">'b'  </span><span class="s3"># write in binary mode</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">is_64bit():</span>
            <span class="s3"># install a manifest for the launcher to prevent Windows</span>
            <span class="s3"># from detecting it as an installer (which it will for</span>
            <span class="s3">#  launchers like easy_install.exe). Consider only</span>
            <span class="s3">#  adding a manifest for launchers detected as installers.</span>
            <span class="s3">#  See Distribute #143 for details.</span>
            <span class="s1">m_name = name + </span><span class="s4">'.exe.manifest'</span>
            <span class="s2">yield </span><span class="s1">(m_name</span><span class="s2">, </span><span class="s1">load_launcher_manifest(name)</span><span class="s2">, </span><span class="s4">'t'</span><span class="s1">)</span>


<span class="s3"># for backward-compatibility</span>
<span class="s1">get_script_args = ScriptWriter.get_script_args</span>
<span class="s1">get_script_header = ScriptWriter.get_script_header</span>


<span class="s2">def </span><span class="s1">get_win_launcher(type):</span>
    <span class="s0">&quot;&quot;&quot; 
    Load the Windows launcher (executable) suitable for launching a script. 
 
    `type` should be either 'cli' or 'gui' 
 
    Returns the executable as a byte string. 
    &quot;&quot;&quot;</span>
    <span class="s1">launcher_fn = </span><span class="s4">'%s.exe' </span><span class="s1">% type</span>
    <span class="s2">if </span><span class="s1">is_64bit():</span>
        <span class="s1">launcher_fn = launcher_fn.replace(</span><span class="s4">&quot;.&quot;</span><span class="s2">, </span><span class="s4">&quot;-64.&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">launcher_fn = launcher_fn.replace(</span><span class="s4">&quot;.&quot;</span><span class="s2">, </span><span class="s4">&quot;-32.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">resource_string(</span><span class="s4">'setuptools'</span><span class="s2">, </span><span class="s1">launcher_fn)</span>


<span class="s2">def </span><span class="s1">load_launcher_manifest(name):</span>
    <span class="s1">manifest = pkg_resources.resource_string(__name__</span><span class="s2">, </span><span class="s4">'launcher manifest.xml'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">manifest.decode(</span><span class="s4">'utf-8'</span><span class="s1">) % vars()</span>


<span class="s2">def </span><span class="s1">rmtree(path</span><span class="s2">, </span><span class="s1">ignore_errors=</span><span class="s2">False, </span><span class="s1">onerror=auto_chmod):</span>
    <span class="s2">return </span><span class="s1">shutil.rmtree(path</span><span class="s2">, </span><span class="s1">ignore_errors</span><span class="s2">, </span><span class="s1">onerror)</span>


<span class="s2">def </span><span class="s1">current_umask():</span>
    <span class="s1">tmp = os.umask(</span><span class="s5">0o022</span><span class="s1">)</span>
    <span class="s1">os.umask(tmp)</span>
    <span class="s2">return </span><span class="s1">tmp</span>


<span class="s2">class </span><span class="s1">EasyInstallDeprecationWarning(SetuptoolsDeprecationWarning):</span>
    <span class="s0">&quot;&quot;&quot; 
    Warning for EasyInstall deprecations, bypassing suppression. 
    &quot;&quot;&quot;</span>
</pre>
</body>
</html>