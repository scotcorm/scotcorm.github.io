<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.util 
 
Miscellaneous utility functions -- anything that doesn't fit into 
one of the other *util.py modules. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">importlib.util</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsPlatformError</span>
<span class="s2">from </span><span class="s1">distutils.dep_util </span><span class="s2">import </span><span class="s1">newer</span>
<span class="s2">from </span><span class="s1">distutils.spawn </span><span class="s2">import </span><span class="s1">spawn</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsByteCompileError</span>
<span class="s2">from </span><span class="s1">.py35compat </span><span class="s2">import </span><span class="s1">_optim_args_from_interpreter_flags</span>


<span class="s2">def </span><span class="s1">get_host_platform():</span>
    <span class="s0">&quot;&quot;&quot;Return a string that identifies the current platform.  This is used mainly to 
    distinguish platform-specific build directories and platform-specific built 
    distributions.  Typically includes the OS name and version and the 
    architecture (as supplied by 'os.uname()'), although the exact information 
    included depends on the OS; eg. on Linux, the kernel version isn't 
    particularly important. 
 
    Examples of returned values: 
       linux-i586 
       linux-alpha (?) 
       solaris-2.6-sun4u 
 
    Windows will return one of: 
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc) 
       win32 (all others - specifically, sys.platform is returned) 
 
    For other non-POSIX platforms, currently just returns 'sys.platform'. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s3">'amd64' </span><span class="s2">in </span><span class="s1">sys.version.lower():</span>
            <span class="s2">return </span><span class="s3">'win-amd64'</span>
        <span class="s2">if </span><span class="s3">'(arm)' </span><span class="s2">in </span><span class="s1">sys.version.lower():</span>
            <span class="s2">return </span><span class="s3">'win-arm32'</span>
        <span class="s2">if </span><span class="s3">'(arm64)' </span><span class="s2">in </span><span class="s1">sys.version.lower():</span>
            <span class="s2">return </span><span class="s3">'win-arm64'</span>
        <span class="s2">return </span><span class="s1">sys.platform</span>

    <span class="s4"># Set for cross builds explicitly</span>
    <span class="s2">if </span><span class="s3">&quot;_PYTHON_HOST_PLATFORM&quot; </span><span class="s2">in </span><span class="s1">os.environ:</span>
        <span class="s2">return </span><span class="s1">os.environ[</span><span class="s3">&quot;_PYTHON_HOST_PLATFORM&quot;</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">os.name != </span><span class="s3">&quot;posix&quot; </span><span class="s2">or not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'uname'</span><span class="s1">):</span>
        <span class="s4"># XXX what about the architecture? NT is Intel or Alpha,</span>
        <span class="s4"># Mac OS is M68k or PPC, etc.</span>
        <span class="s2">return </span><span class="s1">sys.platform</span>

    <span class="s4"># Try to distinguish various flavours of Unix</span>

    <span class="s1">(osname</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">machine) = os.uname()</span>

    <span class="s4"># Convert the OS name to lowercase, remove '/' characters, and translate</span>
    <span class="s4"># spaces (for &quot;Power Macintosh&quot;)</span>
    <span class="s1">osname = osname.lower().replace(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
    <span class="s1">machine = machine.replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span>
    <span class="s1">machine = machine.replace(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">osname[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">&quot;linux&quot;</span><span class="s1">:</span>
        <span class="s4"># At least on Linux/Intel, 'machine' is the processor --</span>
        <span class="s4"># i386, etc.</span>
        <span class="s4"># XXX what about Alpha, SPARC, etc?</span>
        <span class="s2">return  </span><span class="s3">&quot;%s-%s&quot; </span><span class="s1">% (osname</span><span class="s2">, </span><span class="s1">machine)</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">&quot;sunos&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">release[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s3">&quot;5&quot;</span><span class="s1">:           </span><span class="s4"># SunOS 5 == Solaris 2</span>
            <span class="s1">osname = </span><span class="s3">&quot;solaris&quot;</span>
            <span class="s1">release = </span><span class="s3">&quot;%d.%s&quot; </span><span class="s1">% (int(release[</span><span class="s5">0</span><span class="s1">]) - </span><span class="s5">3</span><span class="s2">, </span><span class="s1">release[</span><span class="s5">2</span><span class="s1">:])</span>
            <span class="s4"># We can't use &quot;platform.architecture()[0]&quot; because a</span>
            <span class="s4"># bootstrap problem. We use a dict to get an error</span>
            <span class="s4"># if some suspicious happens.</span>
            <span class="s1">bitness = {</span><span class="s5">2147483647</span><span class="s1">:</span><span class="s3">&quot;32bit&quot;</span><span class="s2">, </span><span class="s5">9223372036854775807</span><span class="s1">:</span><span class="s3">&quot;64bit&quot;</span><span class="s1">}</span>
            <span class="s1">machine += </span><span class="s3">&quot;.%s&quot; </span><span class="s1">% bitness[sys.maxsize]</span>
        <span class="s4"># fall through to standard osname-release-machine representation</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">3</span><span class="s1">] == </span><span class="s3">&quot;aix&quot;</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">.py38compat </span><span class="s2">import </span><span class="s1">aix_platform</span>
        <span class="s2">return </span><span class="s1">aix_platform(osname</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">release)</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">6</span><span class="s1">] == </span><span class="s3">&quot;cygwin&quot;</span><span class="s1">:</span>
        <span class="s1">osname = </span><span class="s3">&quot;cygwin&quot;</span>
        <span class="s1">rel_re = re.compile (</span><span class="s3">r'[\d.]+'</span><span class="s2">, </span><span class="s1">re.ASCII)</span>
        <span class="s1">m = rel_re.match(release)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">release = m.group()</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">6</span><span class="s1">] == </span><span class="s3">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">_osx_support</span><span class="s2">, </span><span class="s1">distutils.sysconfig</span>
        <span class="s1">osname</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">machine = _osx_support.get_platform_osx(</span>
                                        <span class="s1">distutils.sysconfig.get_config_vars()</span><span class="s2">,</span>
                                        <span class="s1">osname</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">machine)</span>

    <span class="s2">return </span><span class="s3">&quot;%s-%s-%s&quot; </span><span class="s1">% (osname</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">machine)</span>

<span class="s2">def </span><span class="s1">get_platform():</span>
    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
        <span class="s1">TARGET_TO_PLAT = {</span>
            <span class="s3">'x86' </span><span class="s1">: </span><span class="s3">'win32'</span><span class="s2">,</span>
            <span class="s3">'x64' </span><span class="s1">: </span><span class="s3">'win-amd64'</span><span class="s2">,</span>
            <span class="s3">'arm' </span><span class="s1">: </span><span class="s3">'win-arm32'</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">TARGET_TO_PLAT.get(os.environ.get(</span><span class="s3">'VSCMD_ARG_TGT_ARCH'</span><span class="s1">)) </span><span class="s2">or </span><span class="s1">get_host_platform()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">get_host_platform()</span>

<span class="s2">def </span><span class="s1">convert_path (pathname):</span>
    <span class="s0">&quot;&quot;&quot;Return 'pathname' as a name that will work on the native filesystem, 
    i.e. split it on '/' and put it back together again using the current 
    directory separator.  Needed because filenames in the setup script are 
    always supplied in Unix style, and have to be converted to the local 
    convention before we can actually use them in the filesystem.  Raises 
    ValueError on non-Unix-ish systems if 'pathname' either starts or 
    ends with a slash. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os.sep == </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pathname</span>
    <span class="s2">if not </span><span class="s1">pathname:</span>
        <span class="s2">return </span><span class="s1">pathname</span>
    <span class="s2">if </span><span class="s1">pathname[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;path '%s' cannot be absolute&quot; </span><span class="s1">% pathname)</span>
    <span class="s2">if </span><span class="s1">pathname[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;path '%s' cannot end with '/'&quot; </span><span class="s1">% pathname)</span>

    <span class="s1">paths = pathname.split(</span><span class="s3">'/'</span><span class="s1">)</span>
    <span class="s2">while </span><span class="s3">'.' </span><span class="s2">in </span><span class="s1">paths:</span>
        <span class="s1">paths.remove(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">paths:</span>
        <span class="s2">return </span><span class="s1">os.curdir</span>
    <span class="s2">return </span><span class="s1">os.path.join(*paths)</span>

<span class="s4"># convert_path ()</span>


<span class="s2">def </span><span class="s1">change_root (new_root</span><span class="s2">, </span><span class="s1">pathname):</span>
    <span class="s0">&quot;&quot;&quot;Return 'pathname' with 'new_root' prepended.  If 'pathname' is 
    relative, this is equivalent to &quot;os.path.join(new_root,pathname)&quot;. 
    Otherwise, it requires making 'pathname' relative and then joining the 
    two, which is tricky on DOS/Windows and Mac OS. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix'</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">os.path.isabs(pathname):</span>
            <span class="s2">return </span><span class="s1">os.path.join(new_root</span><span class="s2">, </span><span class="s1">pathname)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">os.path.join(new_root</span><span class="s2">, </span><span class="s1">pathname[</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s2">elif </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
        <span class="s1">(drive</span><span class="s2">, </span><span class="s1">path) = os.path.splitdrive(pathname)</span>
        <span class="s2">if </span><span class="s1">path[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">:</span>
            <span class="s1">path = path[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">os.path.join(new_root</span><span class="s2">, </span><span class="s1">path)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s3">&quot;nothing known about platform '%s'&quot; </span><span class="s1">% os.name)</span>


<span class="s1">_environ_checked = </span><span class="s5">0</span>
<span class="s2">def </span><span class="s1">check_environ ():</span>
    <span class="s0">&quot;&quot;&quot;Ensure that 'os.environ' has all the environment variables we 
    guarantee that users can use in config files, command-line options, 
    etc.  Currently this includes: 
      HOME - user's home directory (Unix only) 
      PLAT - description of the current platform, including hardware 
             and OS (see 'get_platform()') 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_environ_checked</span>
    <span class="s2">if </span><span class="s1">_environ_checked:</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix' </span><span class="s2">and </span><span class="s3">'HOME' </span><span class="s2">not in </span><span class="s1">os.environ:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">pwd</span>
            <span class="s1">os.environ[</span><span class="s3">'HOME'</span><span class="s1">] = pwd.getpwuid(os.getuid())[</span><span class="s5">5</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">KeyError):</span>
            <span class="s4"># bpo-10496: if the current user identifier doesn't exist in the</span>
            <span class="s4"># password database, do nothing</span>
            <span class="s2">pass</span>

    <span class="s2">if </span><span class="s3">'PLAT' </span><span class="s2">not in </span><span class="s1">os.environ:</span>
        <span class="s1">os.environ[</span><span class="s3">'PLAT'</span><span class="s1">] = get_platform()</span>

    <span class="s1">_environ_checked = </span><span class="s5">1</span>


<span class="s2">def </span><span class="s1">subst_vars (s</span><span class="s2">, </span><span class="s1">local_vars):</span>
    <span class="s0">&quot;&quot;&quot;Perform shell/Perl-style variable substitution on 'string'.  Every 
    occurrence of '$' followed by a name is considered a variable, and 
    variable is substituted by the value found in the 'local_vars' 
    dictionary, or in 'os.environ' if it's not in 'local_vars'. 
    'os.environ' is first checked/augmented to guarantee that it contains 
    certain values: see 'check_environ()'.  Raise ValueError for any 
    variables not found in either 'local_vars' or 'os.environ'. 
    &quot;&quot;&quot;</span>
    <span class="s1">check_environ()</span>
    <span class="s2">def </span><span class="s1">_subst (match</span><span class="s2">, </span><span class="s1">local_vars=local_vars):</span>
        <span class="s1">var_name = match.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">var_name </span><span class="s2">in </span><span class="s1">local_vars:</span>
            <span class="s2">return </span><span class="s1">str(local_vars[var_name])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">os.environ[var_name]</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">re.sub(</span><span class="s3">r'\$([a-zA-Z_][a-zA-Z_0-9]*)'</span><span class="s2">, </span><span class="s1">_subst</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">var:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;invalid variable '$%s'&quot; </span><span class="s1">% var)</span>

<span class="s4"># subst_vars ()</span>


<span class="s2">def </span><span class="s1">grok_environment_error (exc</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s3">&quot;error: &quot;</span><span class="s1">):</span>
    <span class="s4"># Function kept for backward compatibility.</span>
    <span class="s4"># Used to try clever things with EnvironmentErrors,</span>
    <span class="s4"># but nowadays str(exception) produces good messages.</span>
    <span class="s2">return </span><span class="s1">prefix + str(exc)</span>


<span class="s4"># Needed by 'split_quoted()'</span>
<span class="s1">_wordchars_re = _squote_re = _dquote_re = </span><span class="s2">None</span>
<span class="s2">def </span><span class="s1">_init_regex():</span>
    <span class="s2">global </span><span class="s1">_wordchars_re</span><span class="s2">, </span><span class="s1">_squote_re</span><span class="s2">, </span><span class="s1">_dquote_re</span>
    <span class="s1">_wordchars_re = re.compile(</span><span class="s3">r'[^\\\'\&quot;%s ]*' </span><span class="s1">% string.whitespace)</span>
    <span class="s1">_squote_re = re.compile(</span><span class="s3">r&quot;'(?:[^'\\]|\\.)*'&quot;</span><span class="s1">)</span>
    <span class="s1">_dquote_re = re.compile(</span><span class="s3">r'&quot;(?:[^&quot;\\]|\\.)*&quot;'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">split_quoted (s):</span>
    <span class="s0">&quot;&quot;&quot;Split a string up according to Unix shell-like rules for quotes and 
    backslashes.  In short: words are delimited by spaces, as long as those 
    spaces are not escaped by a backslash, or inside a quoted string. 
    Single and double quotes are equivalent, and the quote characters can 
    be backslash-escaped.  The backslash is stripped from any two-character 
    escape sequence, leaving only the escaped character.  The quote 
    characters are stripped from any quoted string.  Returns a list of 
    words. 
    &quot;&quot;&quot;</span>

    <span class="s4"># This is a nice algorithm for splitting up a single string, since it</span>
    <span class="s4"># doesn't require character-by-character examination.  It was a little</span>
    <span class="s4"># bit of a brain-bender to get it working right, though...</span>
    <span class="s2">if </span><span class="s1">_wordchars_re </span><span class="s2">is None</span><span class="s1">: _init_regex()</span>

    <span class="s1">s = s.strip()</span>
    <span class="s1">words = []</span>
    <span class="s1">pos = </span><span class="s5">0</span>

    <span class="s2">while </span><span class="s1">s:</span>
        <span class="s1">m = _wordchars_re.match(s</span><span class="s2">, </span><span class="s1">pos)</span>
        <span class="s1">end = m.end()</span>
        <span class="s2">if </span><span class="s1">end == len(s):</span>
            <span class="s1">words.append(s[:end])</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">s[end] </span><span class="s2">in </span><span class="s1">string.whitespace: </span><span class="s4"># unescaped, unquoted whitespace: now</span>
            <span class="s1">words.append(s[:end])       </span><span class="s4"># we definitely have a word delimiter</span>
            <span class="s1">s = s[end:].lstrip()</span>
            <span class="s1">pos = </span><span class="s5">0</span>

        <span class="s2">elif </span><span class="s1">s[end] == </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">:            </span><span class="s4"># preserve whatever is being escaped;</span>
                                        <span class="s4"># will become part of the current word</span>
            <span class="s1">s = s[:end] + s[end+</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">pos = end+</span><span class="s5">1</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">s[end] == </span><span class="s3">&quot;'&quot;</span><span class="s1">:           </span><span class="s4"># slurp singly-quoted string</span>
                <span class="s1">m = _squote_re.match(s</span><span class="s2">, </span><span class="s1">end)</span>
            <span class="s2">elif </span><span class="s1">s[end] == </span><span class="s3">'&quot;'</span><span class="s1">:         </span><span class="s4"># slurp doubly-quoted string</span>
                <span class="s1">m = _dquote_re.match(s</span><span class="s2">, </span><span class="s1">end)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;this can't happen (bad char '%c')&quot; </span><span class="s1">% s[end])</span>

            <span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;bad string (mismatched %s quotes?)&quot; </span><span class="s1">% s[end])</span>

            <span class="s1">(beg</span><span class="s2">, </span><span class="s1">end) = m.span()</span>
            <span class="s1">s = s[:beg] + s[beg+</span><span class="s5">1</span><span class="s1">:end-</span><span class="s5">1</span><span class="s1">] + s[end:]</span>
            <span class="s1">pos = m.end() - </span><span class="s5">2</span>

        <span class="s2">if </span><span class="s1">pos &gt;= len(s):</span>
            <span class="s1">words.append(s)</span>
            <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">words</span>

<span class="s4"># split_quoted ()</span>


<span class="s2">def </span><span class="s1">execute (func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg=</span><span class="s2">None, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Perform some action that affects the outside world (eg.  by 
    writing to the filesystem).  Such actions are special because they 
    are disabled by the 'dry_run' flag.  This method takes care of all 
    that bureaucracy for you; all you have to do is supply the 
    function to call and an argument tuple for it (to embody the 
    &quot;external action&quot; being performed), and an optional message to 
    print. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">msg </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s3">&quot;%s%r&quot; </span><span class="s1">% (func.__name__</span><span class="s2">, </span><span class="s1">args)</span>
        <span class="s2">if </span><span class="s1">msg[-</span><span class="s5">2</span><span class="s1">:] == </span><span class="s3">',)'</span><span class="s1">:        </span><span class="s4"># correct for singleton tuple</span>
            <span class="s1">msg = msg[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">2</span><span class="s1">] + </span><span class="s3">')'</span>

    <span class="s1">log.info(msg)</span>
    <span class="s2">if not </span><span class="s1">dry_run:</span>
        <span class="s1">func(*args)</span>


<span class="s2">def </span><span class="s1">strtobool (val):</span>
    <span class="s0">&quot;&quot;&quot;Convert a string representation of truth to true (1) or false (0). 
 
    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values 
    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if 
    'val' is anything else. 
    &quot;&quot;&quot;</span>
    <span class="s1">val = val.lower()</span>
    <span class="s2">if </span><span class="s1">val </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'yes'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s2">, </span><span class="s3">'true'</span><span class="s2">, </span><span class="s3">'on'</span><span class="s2">, </span><span class="s3">'1'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s5">1</span>
    <span class="s2">elif </span><span class="s1">val </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'no'</span><span class="s2">, </span><span class="s3">'f'</span><span class="s2">, </span><span class="s3">'false'</span><span class="s2">, </span><span class="s3">'off'</span><span class="s2">, </span><span class="s3">'0'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s5">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;invalid truth value %r&quot; </span><span class="s1">% (val</span><span class="s2">,</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">byte_compile (py_files</span><span class="s2">,</span>
                  <span class="s1">optimize=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">force=</span><span class="s5">0</span><span class="s2">,</span>
                  <span class="s1">prefix=</span><span class="s2">None, </span><span class="s1">base_dir=</span><span class="s2">None,</span>
                  <span class="s1">verbose=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s2">,</span>
                  <span class="s1">direct=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Byte-compile a collection of Python source files to .pyc 
    files in a __pycache__ subdirectory.  'py_files' is a list 
    of files to compile; any files that don't end in &quot;.py&quot; are silently 
    skipped.  'optimize' must be one of the following: 
      0 - don't optimize 
      1 - normal optimization (like &quot;python -O&quot;) 
      2 - extra optimization (like &quot;python -OO&quot;) 
    If 'force' is true, all files are recompiled regardless of 
    timestamps. 
 
    The source filename encoded in each bytecode file defaults to the 
    filenames listed in 'py_files'; you can modify these with 'prefix' and 
    'basedir'.  'prefix' is a string that will be stripped off of each 
    source filename, and 'base_dir' is a directory name that will be 
    prepended (after 'prefix' is stripped).  You can supply either or both 
    (or neither) of 'prefix' and 'base_dir', as you wish. 
 
    If 'dry_run' is true, doesn't actually do anything that would 
    affect the filesystem. 
 
    Byte-compilation is either done directly in this interpreter process 
    with the standard py_compile module, or indirectly by writing a 
    temporary script and executing it.  Normally, you should let 
    'byte_compile()' figure out to use direct compilation or not (see 
    the source for details).  The 'direct' flag is used by the script 
    generated in indirect mode; unless you know what you're doing, leave 
    it set to None. 
    &quot;&quot;&quot;</span>

    <span class="s4"># Late import to fix a bootstrap issue: _posixsubprocess is built by</span>
    <span class="s4"># setup.py, but setup.py uses distutils.</span>
    <span class="s2">import </span><span class="s1">subprocess</span>

    <span class="s4"># nothing is done if sys.dont_write_bytecode is True</span>
    <span class="s2">if </span><span class="s1">sys.dont_write_bytecode:</span>
        <span class="s2">raise </span><span class="s1">DistutilsByteCompileError(</span><span class="s3">'byte-compiling is disabled.'</span><span class="s1">)</span>

    <span class="s4"># First, if the caller didn't force us into direct or indirect mode,</span>
    <span class="s4"># figure out which mode we should be in.  We take a conservative</span>
    <span class="s4"># approach: choose direct mode *only* if the current interpreter is</span>
    <span class="s4"># in debug mode and optimize is 0.  If we're not in debug mode (-O</span>
    <span class="s4"># or -OO), we don't know which level of optimization this</span>
    <span class="s4"># interpreter is running with, so we can't do direct</span>
    <span class="s4"># byte-compilation and be certain that it's the right thing.  Thus,</span>
    <span class="s4"># always compile indirectly if the current interpreter is in either</span>
    <span class="s4"># optimize mode, or if either optimization level was requested by</span>
    <span class="s4"># the caller.</span>
    <span class="s2">if </span><span class="s1">direct </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">direct = (</span><span class="s2">__debug__ and </span><span class="s1">optimize == </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4"># &quot;Indirect&quot; byte-compilation: write a temporary script and then</span>
    <span class="s4"># run it with the appropriate flags.</span>
    <span class="s2">if not </span><span class="s1">direct:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">mkstemp</span>
            <span class="s1">(script_fd</span><span class="s2">, </span><span class="s1">script_name) = mkstemp(</span><span class="s3">&quot;.py&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">mktemp</span>
            <span class="s1">(script_fd</span><span class="s2">, </span><span class="s1">script_name) = </span><span class="s2">None, </span><span class="s1">mktemp(</span><span class="s3">&quot;.py&quot;</span><span class="s1">)</span>
        <span class="s1">log.info(</span><span class="s3">&quot;writing byte-compilation script '%s'&quot;</span><span class="s2">, </span><span class="s1">script_name)</span>
        <span class="s2">if not </span><span class="s1">dry_run:</span>
            <span class="s2">if </span><span class="s1">script_fd </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">script = os.fdopen(script_fd</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">script = open(script_name</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">)</span>

            <span class="s2">with </span><span class="s1">script:</span>
                <span class="s1">script.write(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">from distutils.util import byte_compile 
files = [ 
&quot;&quot;&quot;</span><span class="s1">)</span>

                <span class="s4"># XXX would be nice to write absolute filenames, just for</span>
                <span class="s4"># safety's sake (script should be more robust in the face of</span>
                <span class="s4"># chdir'ing before running it).  But this requires abspath'ing</span>
                <span class="s4"># 'prefix' as well, and that breaks the hack in build_lib's</span>
                <span class="s4"># 'byte_compile()' method that carefully tacks on a trailing</span>
                <span class="s4"># slash (os.sep really) to make sure the prefix here is &quot;just</span>
                <span class="s4"># right&quot;.  This whole prefix business is rather delicate -- the</span>
                <span class="s4"># problem is that it's really a directory, but I'm treating it</span>
                <span class="s4"># as a dumb string, so trailing slashes and so forth matter.</span>

                <span class="s4">#py_files = map(os.path.abspath, py_files)</span>
                <span class="s4">#if prefix:</span>
                <span class="s4">#    prefix = os.path.abspath(prefix)</span>

                <span class="s1">script.write(</span><span class="s3">&quot;,</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">py_files)) + </span><span class="s3">&quot;]</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">script.write(</span><span class="s3">&quot;&quot;&quot; 
byte_compile(files, optimize=%r, force=%r, 
             prefix=%r, base_dir=%r, 
             verbose=%r, dry_run=0, 
             direct=1) 
&quot;&quot;&quot; </span><span class="s1">% (optimize</span><span class="s2">, </span><span class="s1">force</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">base_dir</span><span class="s2">, </span><span class="s1">verbose))</span>

        <span class="s1">cmd = [sys.executable]</span>
        <span class="s1">cmd.extend(_optim_args_from_interpreter_flags())</span>
        <span class="s1">cmd.append(script_name)</span>
        <span class="s1">spawn(cmd</span><span class="s2">, </span><span class="s1">dry_run=dry_run)</span>
        <span class="s1">execute(os.remove</span><span class="s2">, </span><span class="s1">(script_name</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;removing %s&quot; </span><span class="s1">% script_name</span><span class="s2">,</span>
                <span class="s1">dry_run=dry_run)</span>

    <span class="s4"># &quot;Direct&quot; byte-compilation: use the py_compile module to compile</span>
    <span class="s4"># right here, right now.  Note that the script generated in indirect</span>
    <span class="s4"># mode simply calls 'byte_compile()' in direct mode, a weird sort of</span>
    <span class="s4"># cross-process recursion.  Hey, it works!</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">py_compile </span><span class="s2">import </span><span class="s1">compile</span>

        <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">py_files:</span>
            <span class="s2">if </span><span class="s1">file[-</span><span class="s5">3</span><span class="s1">:] != </span><span class="s3">&quot;.py&quot;</span><span class="s1">:</span>
                <span class="s4"># This lets us be lazy and not filter filenames in</span>
                <span class="s4"># the &quot;install_lib&quot; command.</span>
                <span class="s2">continue</span>

            <span class="s4"># Terminology from the py_compile module:</span>
            <span class="s4">#   cfile - byte-compiled file</span>
            <span class="s4">#   dfile - purported source filename (same as 'file' by default)</span>
            <span class="s2">if </span><span class="s1">optimize &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">opt = </span><span class="s3">'' </span><span class="s2">if </span><span class="s1">optimize == </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">optimize</span>
                <span class="s1">cfile = importlib.util.cache_from_source(</span>
                    <span class="s1">file</span><span class="s2">, </span><span class="s1">optimization=opt)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cfile = importlib.util.cache_from_source(file)</span>
            <span class="s1">dfile = file</span>
            <span class="s2">if </span><span class="s1">prefix:</span>
                <span class="s2">if </span><span class="s1">file[:len(prefix)] != prefix:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;invalid prefix: filename %r doesn't start with %r&quot;</span>
                           <span class="s1">% (file</span><span class="s2">, </span><span class="s1">prefix))</span>
                <span class="s1">dfile = dfile[len(prefix):]</span>
            <span class="s2">if </span><span class="s1">base_dir:</span>
                <span class="s1">dfile = os.path.join(base_dir</span><span class="s2">, </span><span class="s1">dfile)</span>

            <span class="s1">cfile_base = os.path.basename(cfile)</span>
            <span class="s2">if </span><span class="s1">direct:</span>
                <span class="s2">if </span><span class="s1">force </span><span class="s2">or </span><span class="s1">newer(file</span><span class="s2">, </span><span class="s1">cfile):</span>
                    <span class="s1">log.info(</span><span class="s3">&quot;byte-compiling %s to %s&quot;</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">cfile_base)</span>
                    <span class="s2">if not </span><span class="s1">dry_run:</span>
                        <span class="s1">compile(file</span><span class="s2">, </span><span class="s1">cfile</span><span class="s2">, </span><span class="s1">dfile)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">log.debug(</span><span class="s3">&quot;skipping byte-compilation of %s to %s&quot;</span><span class="s2">,</span>
                              <span class="s1">file</span><span class="s2">, </span><span class="s1">cfile_base)</span>

<span class="s4"># byte_compile ()</span>

<span class="s2">def </span><span class="s1">rfc822_escape (header):</span>
    <span class="s0">&quot;&quot;&quot;Return a version of the string escaped for inclusion in an 
    RFC-822 header, by ensuring there are 8 spaces space after each newline. 
    &quot;&quot;&quot;</span>
    <span class="s1">lines = header.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s1">sep = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s5">8 </span><span class="s1">* </span><span class="s3">' '</span>
    <span class="s2">return </span><span class="s1">sep.join(lines)</span>

<span class="s4"># 2to3 support</span>

<span class="s2">def </span><span class="s1">run_2to3(files</span><span class="s2">, </span><span class="s1">fixer_names=</span><span class="s2">None, </span><span class="s1">options=</span><span class="s2">None, </span><span class="s1">explicit=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Invoke 2to3 on a list of Python files. 
    The files should all come from the build area, as the 
    modification is done in-place. To reduce the build time, 
    only files modified since the last invocation of this 
    function should be passed in the files argument.&quot;&quot;&quot;</span>

    <span class="s2">if not </span><span class="s1">files:</span>
        <span class="s2">return</span>

    <span class="s4"># Make this class local, to delay import of 2to3</span>
    <span class="s2">from </span><span class="s1">lib2to3.refactor </span><span class="s2">import </span><span class="s1">RefactoringTool</span><span class="s2">, </span><span class="s1">get_fixers_from_package</span>
    <span class="s2">class </span><span class="s1">DistutilsRefactoringTool(RefactoringTool):</span>
        <span class="s2">def </span><span class="s1">log_error(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
            <span class="s1">log.error(msg</span><span class="s2">, </span><span class="s1">*args)</span>

        <span class="s2">def </span><span class="s1">log_message(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s1">log.info(msg</span><span class="s2">, </span><span class="s1">*args)</span>

        <span class="s2">def </span><span class="s1">log_debug(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s1">log.debug(msg</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">if </span><span class="s1">fixer_names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">fixer_names = get_fixers_from_package(</span><span class="s3">'lib2to3.fixes'</span><span class="s1">)</span>
    <span class="s1">r = DistutilsRefactoringTool(fixer_names</span><span class="s2">, </span><span class="s1">options=options)</span>
    <span class="s1">r.refactor(files</span><span class="s2">, </span><span class="s1">write=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">copydir_run_2to3(src</span><span class="s2">, </span><span class="s1">dest</span><span class="s2">, </span><span class="s1">template=</span><span class="s2">None, </span><span class="s1">fixer_names=</span><span class="s2">None,</span>
                     <span class="s1">options=</span><span class="s2">None, </span><span class="s1">explicit=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Recursively copy a directory, only copying new and changed files, 
    running run_2to3 over all newly copied Python modules afterward. 
 
    If you give a template string, it's parsed like a MANIFEST.in. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">distutils.dir_util </span><span class="s2">import </span><span class="s1">mkpath</span>
    <span class="s2">from </span><span class="s1">distutils.file_util </span><span class="s2">import </span><span class="s1">copy_file</span>
    <span class="s2">from </span><span class="s1">distutils.filelist </span><span class="s2">import </span><span class="s1">FileList</span>
    <span class="s1">filelist = FileList()</span>
    <span class="s1">curdir = os.getcwd()</span>
    <span class="s1">os.chdir(src)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">filelist.findall()</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">os.chdir(curdir)</span>
    <span class="s1">filelist.files[:] = filelist.allfiles</span>
    <span class="s2">if </span><span class="s1">template:</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">template.splitlines():</span>
            <span class="s1">line = line.strip()</span>
            <span class="s2">if not </span><span class="s1">line: </span><span class="s2">continue</span>
            <span class="s1">filelist.process_template_line(line)</span>
    <span class="s1">copied = []</span>
    <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filelist.files:</span>
        <span class="s1">outname = os.path.join(dest</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">mkpath(os.path.dirname(outname))</span>
        <span class="s1">res = copy_file(os.path.join(src</span><span class="s2">, </span><span class="s1">filename)</span><span class="s2">, </span><span class="s1">outname</span><span class="s2">, </span><span class="s1">update=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">res[</span><span class="s5">1</span><span class="s1">]: copied.append(outname)</span>
    <span class="s1">run_2to3([fn </span><span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">copied </span><span class="s2">if </span><span class="s1">fn.lower().endswith(</span><span class="s3">'.py'</span><span class="s1">)]</span><span class="s2">,</span>
             <span class="s1">fixer_names=fixer_names</span><span class="s2">, </span><span class="s1">options=options</span><span class="s2">, </span><span class="s1">explicit=explicit)</span>
    <span class="s2">return </span><span class="s1">copied</span>

<span class="s2">class </span><span class="s1">Mixin2to3:</span>
    <span class="s0">'''Mixin class for commands that run 2to3. 
    To configure 2to3, setup scripts may either change 
    the class variables, or inherit from individual commands 
    to override how 2to3 is invoked.'''</span>

    <span class="s4"># provide list of fixers to run;</span>
    <span class="s4"># defaults to all from lib2to3.fixers</span>
    <span class="s1">fixer_names = </span><span class="s2">None</span>

    <span class="s4"># options dictionary</span>
    <span class="s1">options = </span><span class="s2">None</span>

    <span class="s4"># list of fixers to invoke even though they are marked as explicit</span>
    <span class="s1">explicit = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">run_2to3(self</span><span class="s2">, </span><span class="s1">files):</span>
        <span class="s2">return </span><span class="s1">run_2to3(files</span><span class="s2">, </span><span class="s1">self.fixer_names</span><span class="s2">, </span><span class="s1">self.options</span><span class="s2">, </span><span class="s1">self.explicit)</span>
</pre>
</body>
</html>