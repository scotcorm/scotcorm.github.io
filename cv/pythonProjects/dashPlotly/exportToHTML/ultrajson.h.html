<html>
<head>
<title>ultrajson.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #ab51ba;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ultrajson.h</font>
</center></td></tr></table>
<pre><span class="s0">/* 
Copyright (c) 2011-2013, ESN Social Software AB and Jonas Tarnstrom 
All rights reserved. 
 
Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met: 
    * Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
    * Neither the name of the ESN Social Software AB nor the 
      names of its contributors may be used to endorse or promote products 
      derived from this software without specific prior written permission. 
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL ESN SOCIAL SOFTWARE AB OR JONAS TARNSTROM BE LIABLE 
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 
 
Portions of code from MODP_ASCII - Ascii transformations (upper/lower, etc) 
https://github.com/client9/stringencoders 
Copyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved. 
 
Numeric decoder derived from from TCL library 
https://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms 
 * Copyright (c) 1988-1993 The Regents of the University of California. 
 * Copyright (c) 1994 Sun Microsystems, Inc. 
*/</span>

<span class="s0">/* 
Ultra fast JSON encoder and decoder 
Developed by Jonas Tarnstrom (jonas@esn.me). 
 
Encoder notes: 
------------------ 
 
:: Cyclic references :: 
Cyclic referenced objects are not detected. 
Set JSONObjectEncoder.recursionMax to suitable value or make sure input object 
tree doesn't have cyclic references. 
 
*/</span>

<span class="s2">#ifndef </span><span class="s1">PANDAS__LIBS_SRC_UJSON_LIB_ULTRAJSON_H_</span>
<span class="s2">#define </span><span class="s1">PANDAS__LIBS_SRC_UJSON_LIB_ULTRAJSON_H_</span>

<span class="s2">#include </span><span class="s1">&lt;stdio.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;wchar.h&gt;</span>

<span class="s0">// Don't output any extra whitespaces when encoding</span>
<span class="s2">#define </span><span class="s1">JSON_NO_EXTRA_WHITESPACE</span>

<span class="s0">// Max decimals to encode double floating point numbers with</span>
<span class="s2">#ifndef </span><span class="s1">JSON_DOUBLE_MAX_DECIMALS</span>
<span class="s2">#define </span><span class="s1">JSON_DOUBLE_MAX_DECIMALS </span><span class="s3">15</span>
<span class="s2">#endif</span>

<span class="s0">// Max recursion depth, default for encoder</span>
<span class="s2">#ifndef </span><span class="s1">JSON_MAX_RECURSION_DEPTH</span>
<span class="s2">#define </span><span class="s1">JSON_MAX_RECURSION_DEPTH </span><span class="s3">1024</span>
<span class="s2">#endif</span>

<span class="s0">// Max recursion depth, default for decoder</span>
<span class="s2">#ifndef </span><span class="s1">JSON_MAX_OBJECT_DEPTH</span>
<span class="s2">#define </span><span class="s1">JSON_MAX_OBJECT_DEPTH </span><span class="s3">1024</span>
<span class="s2">#endif</span>

<span class="s0">/* 
Dictates and limits how much stack space for buffers UltraJSON will use before resorting to provided heap functions */</span>
<span class="s2">#ifndef </span><span class="s1">JSON_MAX_STACK_BUFFER_SIZE</span>
<span class="s2">#define </span><span class="s1">JSON_MAX_STACK_BUFFER_SIZE </span><span class="s3">131072</span>
<span class="s2">#endif</span>

<span class="s2">#ifdef </span><span class="s1">_WIN32</span>

<span class="s2">typedef </span><span class="s1">__int64 JSINT64;</span>
<span class="s2">typedef unsigned </span><span class="s1">__int64 JSUINT64;</span>

<span class="s2">typedef </span><span class="s1">__int32 JSINT32;</span>
<span class="s2">typedef unsigned </span><span class="s1">__int32 JSUINT32;</span>
<span class="s2">typedef unsigned </span><span class="s1">__int8 JSUINT8;</span>
<span class="s2">typedef unsigned </span><span class="s1">__int16 JSUTF16;</span>
<span class="s2">typedef unsigned </span><span class="s1">__int32 JSUTF32;</span>
<span class="s2">typedef </span><span class="s1">__int64 JSLONG;</span>

<span class="s2">#define </span><span class="s1">EXPORTFUNCTION __declspec(dllexport)</span>

<span class="s2">#define </span><span class="s1">FASTCALL_MSVC __fastcall</span>

<span class="s2">#define </span><span class="s1">INLINE_PREFIX </span><span class="s2">static </span><span class="s1">__inline</span>

<span class="s2">#else</span>

<span class="s2">#include </span><span class="s1">&lt;stdint.h&gt;</span>
<span class="s2">typedef </span><span class="s1">int64_t JSINT64;</span>
<span class="s2">typedef </span><span class="s1">uint64_t JSUINT64;</span>

<span class="s2">typedef </span><span class="s1">int32_t JSINT32;</span>
<span class="s2">typedef </span><span class="s1">uint32_t JSUINT32;</span>

<span class="s2">#define </span><span class="s1">FASTCALL_MSVC</span>

<span class="s2">#define </span><span class="s1">INLINE_PREFIX </span><span class="s2">static </span><span class="s4">inline</span>

<span class="s2">typedef </span><span class="s1">uint8_t JSUINT8;</span>
<span class="s2">typedef </span><span class="s1">uint16_t JSUTF16;</span>
<span class="s2">typedef </span><span class="s1">uint32_t JSUTF32;</span>

<span class="s2">typedef </span><span class="s1">int64_t JSLONG;</span>

<span class="s2">#define </span><span class="s1">EXPORTFUNCTION</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">!(defined(__LITTLE_ENDIAN__) || defined(__BIG_ENDIAN__))</span>

<span class="s2">#if </span><span class="s1">__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span>
<span class="s2">#define </span><span class="s1">__LITTLE_ENDIAN__</span>
<span class="s2">#else</span>

<span class="s2">#if </span><span class="s1">__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span>
<span class="s2">#define </span><span class="s1">__BIG_ENDIAN__</span>
<span class="s2">#endif</span>

<span class="s2">#endif</span>

<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">!defined(__LITTLE_ENDIAN__) &amp;&amp; !defined(__BIG_ENDIAN__)</span>
<span class="s2">#error </span><span class="s5">&quot;Endianness not supported&quot;</span>
<span class="s2">#endif</span>

<span class="s2">enum </span><span class="s1">JSTYPES {</span>
  <span class="s1">JT_NULL,     </span><span class="s0">// NULL</span>
  <span class="s1">JT_TRUE,     </span><span class="s0">// boolean true</span>
  <span class="s1">JT_FALSE,    </span><span class="s0">// boolean false</span>
  <span class="s1">JT_INT,      </span><span class="s0">// (JSINT32 (signed 32-bit))</span>
  <span class="s1">JT_LONG,     </span><span class="s0">// (JSINT64 (signed 64-bit))</span>
  <span class="s1">JT_DOUBLE,   </span><span class="s0">// (double)</span>
  <span class="s1">JT_BIGNUM,   </span><span class="s0">// integer larger than sys.maxsize</span>
  <span class="s1">JT_UTF8,     </span><span class="s0">// (char 8-bit)</span>
  <span class="s1">JT_ARRAY,    </span><span class="s0">// Array structure</span>
  <span class="s1">JT_OBJECT,   </span><span class="s0">// Key/Value structure</span>
  <span class="s1">JT_INVALID,  </span><span class="s0">// Internal, do not return nor expect</span>
  <span class="s1">JT_POS_INF,  </span><span class="s0">// Positive infinity</span>
  <span class="s1">JT_NEG_INF,  </span><span class="s0">// Negative infinity</span>
<span class="s1">};</span>

<span class="s2">typedef void </span><span class="s1">* JSOBJ;</span>
<span class="s2">typedef void </span><span class="s1">* JSITER;</span>

<span class="s2">typedef struct </span><span class="s1">__JSONTypeContext {</span>
  <span class="s2">int </span><span class="s1">type;</span>
  <span class="s2">void </span><span class="s1">*encoder;</span>
  <span class="s2">void </span><span class="s1">*prv;</span>
<span class="s1">} JSONTypeContext;</span>

<span class="s0">/* 
Function pointer declarations, suitable for implementing UltraJSON */</span>
<span class="s2">typedef void </span><span class="s1">(*JSPFN_ITERBEGIN)(JSOBJ obj, JSONTypeContext *tc);</span>
<span class="s2">typedef int </span><span class="s1">(*JSPFN_ITERNEXT)(JSOBJ obj, JSONTypeContext *tc);</span>
<span class="s2">typedef void </span><span class="s1">(*JSPFN_ITEREND)(JSOBJ obj, JSONTypeContext *tc);</span>
<span class="s2">typedef </span><span class="s1">JSOBJ (*JSPFN_ITERGETVALUE)(JSOBJ obj, JSONTypeContext *tc);</span>
<span class="s2">typedef char </span><span class="s1">*(*JSPFN_ITERGETNAME)(JSOBJ obj, JSONTypeContext *tc,</span>
                                   <span class="s1">size_t *outLen);</span>
<span class="s2">typedef void </span><span class="s1">*(*JSPFN_MALLOC)(size_t size);</span>
<span class="s2">typedef void </span><span class="s1">(*JSPFN_FREE)(</span><span class="s2">void </span><span class="s1">*pptr);</span>
<span class="s2">typedef void </span><span class="s1">*(*JSPFN_REALLOC)(</span><span class="s2">void </span><span class="s1">*base, size_t size);</span>

<span class="s2">typedef struct </span><span class="s1">__JSONObjectEncoder {</span>
  <span class="s2">void </span><span class="s1">(*beginTypeContext)(JSOBJ obj, JSONTypeContext *tc);</span>
  <span class="s2">void </span><span class="s1">(*endTypeContext)(JSOBJ obj, JSONTypeContext *tc);</span>
  <span class="s2">const char </span><span class="s1">*(*getStringValue)(JSOBJ obj, JSONTypeContext *tc,</span>
                                <span class="s1">size_t *_outLen);</span>
  <span class="s1">JSINT64 (*getLongValue)(JSOBJ obj, JSONTypeContext *tc);</span>
  <span class="s1">JSINT32 (*getIntValue)(JSOBJ obj, JSONTypeContext *tc);</span>
  <span class="s2">double </span><span class="s1">(*getDoubleValue)(JSOBJ obj, JSONTypeContext *tc);</span>
  <span class="s2">const char </span><span class="s1">*(*getBigNumStringValue)(JSOBJ obj, JSONTypeContext *tc,</span>
                                <span class="s1">size_t *_outLen);</span>

  <span class="s0">/* 
  Begin iteration of an iteratable object (JS_ARRAY or JS_OBJECT) 
  Implementor should setup iteration state in ti-&gt;prv 
  */</span>
  <span class="s1">JSPFN_ITERBEGIN iterBegin;</span>

  <span class="s0">/* 
  Retrieve next object in an iteration. Should return 0 to indicate iteration has reached end or 1 if there are more items. 
  Implementor is responsible for keeping state of the iteration. Use ti-&gt;prv fields for this 
  */</span>
  <span class="s1">JSPFN_ITERNEXT iterNext;</span>

  <span class="s0">/* 
  Ends the iteration of an iteratable object. 
  Any iteration state stored in ti-&gt;prv can be freed here 
  */</span>
  <span class="s1">JSPFN_ITEREND iterEnd;</span>

  <span class="s0">/* 
  Returns a reference to the value object of an iterator 
  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti-&gt;prv to keep track of current object 
  */</span>
  <span class="s1">JSPFN_ITERGETVALUE iterGetValue;</span>

  <span class="s0">/* 
  Return name of iterator. 
  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti-&gt;prv to keep track of current object 
  */</span>
  <span class="s1">JSPFN_ITERGETNAME iterGetName;</span>

  <span class="s0">/* 
  Release a value as indicated by setting ti-&gt;release = 1 in the previous getValue call. 
  The ti-&gt;prv array should contain the necessary context to release the value 
  */</span>
  <span class="s2">void </span><span class="s1">(*releaseObject)(JSOBJ obj);</span>

  <span class="s0">/* Library functions 
  Set to NULL to use STDLIB malloc,realloc,free */</span>
  <span class="s1">JSPFN_MALLOC malloc;</span>
  <span class="s1">JSPFN_REALLOC realloc;</span>
  <span class="s1">JSPFN_FREE free;</span>

  <span class="s0">/* 
  Configuration for max recursion, set to 0 to use default (see JSON_MAX_RECURSION_DEPTH)*/</span>
  <span class="s2">int </span><span class="s1">recursionMax;</span>

  <span class="s0">/* 
  Configuration for max decimals of double floating point numbers to encode (0-9) */</span>
  <span class="s2">int </span><span class="s1">doublePrecision;</span>

  <span class="s0">/* 
  If true output will be ASCII with all characters above 127 encoded as \uXXXX. If false output will be UTF-8 or what ever charset strings are brought as */</span>
  <span class="s2">int </span><span class="s1">forceASCII;</span>

  <span class="s0">/* 
  If true, '&lt;', '&gt;', and '&amp;' characters will be encoded as \u003c, \u003e, and \u0026, respectively. If false, no special encoding will be used. */</span>
  <span class="s2">int </span><span class="s1">encodeHTMLChars;</span>

  <span class="s0">/* 
  Configuration for spaces of indent */</span>
  <span class="s2">int </span><span class="s1">indent;</span>

  <span class="s0">/* 
  Set to an error message if error occurred */</span>
  <span class="s2">const char </span><span class="s1">*errorMsg;</span>
  <span class="s1">JSOBJ errorObj;</span>

  <span class="s0">/* Buffer stuff */</span>
  <span class="s2">char </span><span class="s1">*start;</span>
  <span class="s2">char </span><span class="s1">*offset;</span>
  <span class="s2">char </span><span class="s1">*end;</span>
  <span class="s2">int </span><span class="s1">heap;</span>
  <span class="s2">int </span><span class="s1">level;</span>
<span class="s1">} JSONObjectEncoder;</span>

<span class="s0">/* 
Encode an object structure into JSON. 
 
Arguments: 
obj - An anonymous type representing the object 
enc - Function definitions for querying JSOBJ type 
buffer - Preallocated buffer to store result in. If NULL function allocates own buffer 
cbBuffer - Length of buffer (ignored if buffer is NULL) 
 
Returns: 
Encoded JSON object as a null terminated char string. 
 
NOTE: 
If the supplied buffer wasn't enough to hold the result the function will allocate a new buffer. 
Life cycle of the provided buffer must still be handled by caller. 
 
If the return value doesn't equal the specified buffer caller must release the memory using 
JSONObjectEncoder.free or free() as specified when calling this function. 
*/</span>
<span class="s1">EXPORTFUNCTION </span><span class="s2">char </span><span class="s1">*JSON_EncodeObject(JSOBJ obj, JSONObjectEncoder *enc,</span>
                                       <span class="s2">char </span><span class="s1">*buffer, size_t cbBuffer);</span>

<span class="s2">typedef struct </span><span class="s1">__JSONObjectDecoder {</span>
  <span class="s1">JSOBJ (*newString)(</span><span class="s2">void </span><span class="s1">*prv, </span><span class="s4">wchar_t </span><span class="s1">*start, </span><span class="s4">wchar_t </span><span class="s1">*end);</span>
  <span class="s2">int </span><span class="s1">(*objectAddKey)(</span><span class="s2">void </span><span class="s1">*prv, JSOBJ obj, JSOBJ name, JSOBJ value);</span>
  <span class="s2">int </span><span class="s1">(*arrayAddItem)(</span><span class="s2">void </span><span class="s1">*prv, JSOBJ obj, JSOBJ value);</span>
  <span class="s1">JSOBJ (*newTrue)(</span><span class="s2">void </span><span class="s1">*prv);</span>
  <span class="s1">JSOBJ (*newFalse)(</span><span class="s2">void </span><span class="s1">*prv);</span>
  <span class="s1">JSOBJ (*newNull)(</span><span class="s2">void </span><span class="s1">*prv);</span>
  <span class="s1">JSOBJ (*newPosInf)(</span><span class="s2">void </span><span class="s1">*prv);</span>
  <span class="s1">JSOBJ (*newNegInf)(</span><span class="s2">void </span><span class="s1">*prv);</span>
  <span class="s1">JSOBJ (*newObject)(</span><span class="s2">void </span><span class="s1">*prv, </span><span class="s2">void </span><span class="s1">*decoder);</span>
  <span class="s1">JSOBJ (*endObject)(</span><span class="s2">void </span><span class="s1">*prv, JSOBJ obj);</span>
  <span class="s1">JSOBJ (*newArray)(</span><span class="s2">void </span><span class="s1">*prv, </span><span class="s2">void </span><span class="s1">*decoder);</span>
  <span class="s1">JSOBJ (*endArray)(</span><span class="s2">void </span><span class="s1">*prv, JSOBJ obj);</span>
  <span class="s1">JSOBJ (*newInt)(</span><span class="s2">void </span><span class="s1">*prv, JSINT32 value);</span>
  <span class="s1">JSOBJ (*newLong)(</span><span class="s2">void </span><span class="s1">*prv, JSINT64 value);</span>
  <span class="s1">JSOBJ (*newUnsignedLong)(</span><span class="s2">void </span><span class="s1">*prv, JSUINT64 value);</span>
  <span class="s1">JSOBJ (*newDouble)(</span><span class="s2">void </span><span class="s1">*prv, </span><span class="s2">double </span><span class="s1">value);</span>
  <span class="s2">void </span><span class="s1">(*releaseObject)(</span><span class="s2">void </span><span class="s1">*prv, JSOBJ obj, </span><span class="s2">void </span><span class="s1">*decoder);</span>
  <span class="s1">JSPFN_MALLOC malloc;</span>
  <span class="s1">JSPFN_FREE free;</span>
  <span class="s1">JSPFN_REALLOC realloc;</span>
  <span class="s2">char </span><span class="s1">*errorStr;</span>
  <span class="s2">char </span><span class="s1">*errorOffset;</span>
  <span class="s2">int </span><span class="s1">preciseFloat;</span>
  <span class="s2">void </span><span class="s1">*prv;</span>
<span class="s1">} JSONObjectDecoder;</span>

<span class="s1">EXPORTFUNCTION JSOBJ JSON_DecodeObject(JSONObjectDecoder *dec,</span>
                                       <span class="s2">const char </span><span class="s1">*buffer, size_t cbBuffer);</span>
<span class="s1">EXPORTFUNCTION </span><span class="s2">void </span><span class="s1">encode(JSOBJ, JSONObjectEncoder *, </span><span class="s2">const char </span><span class="s1">*, size_t);</span>

<span class="s2">#endif  </span><span class="s0">// PANDAS__LIBS_SRC_UJSON_LIB_ULTRAJSON_H_</span>
</pre>
</body>
</html>