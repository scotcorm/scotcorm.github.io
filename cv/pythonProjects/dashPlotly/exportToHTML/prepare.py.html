<html>
<head>
<title>prepare.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prepare.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Prepares a distribution for installation 
&quot;&quot;&quot;</span>

<span class="s2"># The following comment should be removed at some point in the future.</span>
<span class="s2"># mypy: strict-optional=False</span>

<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">mimetypes</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span>

<span class="s3">from </span><span class="s1">pip._vendor.packaging.utils </span><span class="s3">import </span><span class="s1">canonicalize_name</span>

<span class="s3">from </span><span class="s1">pip._internal.distributions </span><span class="s3">import </span><span class="s1">make_distribution_for_install_requirement</span>
<span class="s3">from </span><span class="s1">pip._internal.distributions.installed </span><span class="s3">import </span><span class="s1">InstalledDistribution</span>
<span class="s3">from </span><span class="s1">pip._internal.exceptions </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">DirectoryUrlHashUnsupported</span><span class="s3">,</span>
    <span class="s1">HashMismatch</span><span class="s3">,</span>
    <span class="s1">HashUnpinned</span><span class="s3">,</span>
    <span class="s1">InstallationError</span><span class="s3">,</span>
    <span class="s1">NetworkConnectionError</span><span class="s3">,</span>
    <span class="s1">PreviousBuildDirError</span><span class="s3">,</span>
    <span class="s1">VcsHashUnsupported</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">pip._internal.index.package_finder </span><span class="s3">import </span><span class="s1">PackageFinder</span>
<span class="s3">from </span><span class="s1">pip._internal.metadata </span><span class="s3">import </span><span class="s1">BaseDistribution</span>
<span class="s3">from </span><span class="s1">pip._internal.models.link </span><span class="s3">import </span><span class="s1">Link</span>
<span class="s3">from </span><span class="s1">pip._internal.models.wheel </span><span class="s3">import </span><span class="s1">Wheel</span>
<span class="s3">from </span><span class="s1">pip._internal.network.download </span><span class="s3">import </span><span class="s1">BatchDownloader</span><span class="s3">, </span><span class="s1">Downloader</span>
<span class="s3">from </span><span class="s1">pip._internal.network.lazy_wheel </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">HTTPRangeRequestUnsupported</span><span class="s3">,</span>
    <span class="s1">dist_from_wheel_url</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">pip._internal.network.session </span><span class="s3">import </span><span class="s1">PipSession</span>
<span class="s3">from </span><span class="s1">pip._internal.req.req_install </span><span class="s3">import </span><span class="s1">InstallRequirement</span>
<span class="s3">from </span><span class="s1">pip._internal.req.req_tracker </span><span class="s3">import </span><span class="s1">RequirementTracker</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.filesystem </span><span class="s3">import </span><span class="s1">copy2_fixed</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s3">import </span><span class="s1">Hashes</span><span class="s3">, </span><span class="s1">MissingHashes</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.logging </span><span class="s3">import </span><span class="s1">indent_log</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.misc </span><span class="s3">import </span><span class="s1">display_path</span><span class="s3">, </span><span class="s1">hide_url</span><span class="s3">, </span><span class="s1">is_installable_dir</span><span class="s3">, </span><span class="s1">rmtree</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.temp_dir </span><span class="s3">import </span><span class="s1">TempDirectory</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.unpacking </span><span class="s3">import </span><span class="s1">unpack_file</span>
<span class="s3">from </span><span class="s1">pip._internal.vcs </span><span class="s3">import </span><span class="s1">vcs</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s3">def </span><span class="s1">_get_prepared_distribution(</span>
    <span class="s1">req: InstallRequirement</span><span class="s3">,</span>
    <span class="s1">req_tracker: RequirementTracker</span><span class="s3">,</span>
    <span class="s1">finder: PackageFinder</span><span class="s3">,</span>
    <span class="s1">build_isolation: bool</span><span class="s3">,</span>
<span class="s1">) -&gt; BaseDistribution:</span>
    <span class="s0">&quot;&quot;&quot;Prepare a distribution for installation.&quot;&quot;&quot;</span>
    <span class="s1">abstract_dist = make_distribution_for_install_requirement(req)</span>
    <span class="s3">with </span><span class="s1">req_tracker.track(req):</span>
        <span class="s1">abstract_dist.prepare_distribution_metadata(finder</span><span class="s3">, </span><span class="s1">build_isolation)</span>
    <span class="s3">return </span><span class="s1">abstract_dist.get_metadata_distribution()</span>


<span class="s3">def </span><span class="s1">unpack_vcs_link(link: Link</span><span class="s3">, </span><span class="s1">location: str</span><span class="s3">, </span><span class="s1">verbosity: int) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">vcs_backend = vcs.get_backend_for_scheme(link.scheme)</span>
    <span class="s3">assert </span><span class="s1">vcs_backend </span><span class="s3">is not None</span>
    <span class="s1">vcs_backend.unpack(location</span><span class="s3">, </span><span class="s1">url=hide_url(link.url)</span><span class="s3">, </span><span class="s1">verbosity=verbosity)</span>


<span class="s3">class </span><span class="s1">File:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path: str</span><span class="s3">, </span><span class="s1">content_type: Optional[str]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.path = path</span>
        <span class="s3">if </span><span class="s1">content_type </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.content_type = mimetypes.guess_type(path)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.content_type = content_type</span>


<span class="s3">def </span><span class="s1">get_http_url(</span>
    <span class="s1">link: Link</span><span class="s3">,</span>
    <span class="s1">download: Downloader</span><span class="s3">,</span>
    <span class="s1">download_dir: Optional[str] = </span><span class="s3">None,</span>
    <span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None,</span>
<span class="s1">) -&gt; File:</span>
    <span class="s1">temp_dir = TempDirectory(kind=</span><span class="s5">&quot;unpack&quot;</span><span class="s3">, </span><span class="s1">globally_managed=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s2"># If a download dir is specified, is the file already downloaded there?</span>
    <span class="s1">already_downloaded_path = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">download_dir:</span>
        <span class="s1">already_downloaded_path = _check_download_dir(link</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes)</span>

    <span class="s3">if </span><span class="s1">already_downloaded_path:</span>
        <span class="s1">from_path = already_downloaded_path</span>
        <span class="s1">content_type = </span><span class="s3">None</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># let's download to a tmp dir</span>
        <span class="s1">from_path</span><span class="s3">, </span><span class="s1">content_type = download(link</span><span class="s3">, </span><span class="s1">temp_dir.path)</span>
        <span class="s3">if </span><span class="s1">hashes:</span>
            <span class="s1">hashes.check_against_path(from_path)</span>

    <span class="s3">return </span><span class="s1">File(from_path</span><span class="s3">, </span><span class="s1">content_type)</span>


<span class="s3">def </span><span class="s1">_copy2_ignoring_special_files(src: str</span><span class="s3">, </span><span class="s1">dest: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Copying special files is not supported, but as a convenience to users 
    we skip errors copying them. This supports tools that may create e.g. 
    socket files in the project source directory. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">copy2_fixed(src</span><span class="s3">, </span><span class="s1">dest)</span>
    <span class="s3">except </span><span class="s1">shutil.SpecialFileError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s2"># SpecialFileError may be raised due to either the source or</span>
        <span class="s2"># destination. If the destination was the cause then we would actually</span>
        <span class="s2"># care, but since the destination directory is deleted prior to</span>
        <span class="s2"># copy we ignore all of them assuming it is caused by the source.</span>
        <span class="s1">logger.warning(</span>
            <span class="s5">&quot;Ignoring special file error '%s' encountered copying %s to %s.&quot;</span><span class="s3">,</span>
            <span class="s1">str(e)</span><span class="s3">,</span>
            <span class="s1">src</span><span class="s3">,</span>
            <span class="s1">dest</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_copy_source_tree(source: str</span><span class="s3">, </span><span class="s1">target: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">target_abspath = os.path.abspath(target)</span>
    <span class="s1">target_basename = os.path.basename(target_abspath)</span>
    <span class="s1">target_dirname = os.path.dirname(target_abspath)</span>

    <span class="s3">def </span><span class="s1">ignore(d: str</span><span class="s3">, </span><span class="s1">names: List[str]) -&gt; List[str]:</span>
        <span class="s1">skipped: List[str] = []</span>
        <span class="s3">if </span><span class="s1">d == source:</span>
            <span class="s2"># Pulling in those directories can potentially be very slow,</span>
            <span class="s2"># exclude the following directories if they appear in the top</span>
            <span class="s2"># level dir (and only it).</span>
            <span class="s2"># See discussion at https://github.com/pypa/pip/pull/6770</span>
            <span class="s1">skipped += [</span><span class="s5">&quot;.tox&quot;</span><span class="s3">, </span><span class="s5">&quot;.nox&quot;</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">os.path.abspath(d) == target_dirname:</span>
            <span class="s2"># Prevent an infinite recursion if the target is in source.</span>
            <span class="s2"># This can happen when TMPDIR is set to ${PWD}/...</span>
            <span class="s2"># and we copy PWD to TMPDIR.</span>
            <span class="s1">skipped += [target_basename]</span>
        <span class="s3">return </span><span class="s1">skipped</span>

    <span class="s1">shutil.copytree(</span>
        <span class="s1">source</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">,</span>
        <span class="s1">ignore=ignore</span><span class="s3">,</span>
        <span class="s1">symlinks=</span><span class="s3">True,</span>
        <span class="s1">copy_function=_copy2_ignoring_special_files</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">get_file_url(</span>
    <span class="s1">link: Link</span><span class="s3">, </span><span class="s1">download_dir: Optional[str] = </span><span class="s3">None, </span><span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None</span>
<span class="s1">) -&gt; File:</span>
    <span class="s0">&quot;&quot;&quot;Get file and optionally check its hash.&quot;&quot;&quot;</span>
    <span class="s2"># If a download dir is specified, is the file already there and valid?</span>
    <span class="s1">already_downloaded_path = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">download_dir:</span>
        <span class="s1">already_downloaded_path = _check_download_dir(link</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes)</span>

    <span class="s3">if </span><span class="s1">already_downloaded_path:</span>
        <span class="s1">from_path = already_downloaded_path</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">from_path = link.file_path</span>

    <span class="s2"># If --require-hashes is off, `hashes` is either empty, the</span>
    <span class="s2"># link's embedded hash, or MissingHashes; it is required to</span>
    <span class="s2"># match. If --require-hashes is on, we are satisfied by any</span>
    <span class="s2"># hash in `hashes` matching: a URL-based or an option-based</span>
    <span class="s2"># one; no internet-sourced hash will be in `hashes`.</span>
    <span class="s3">if </span><span class="s1">hashes:</span>
        <span class="s1">hashes.check_against_path(from_path)</span>
    <span class="s3">return </span><span class="s1">File(from_path</span><span class="s3">, None</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">unpack_url(</span>
    <span class="s1">link: Link</span><span class="s3">,</span>
    <span class="s1">location: str</span><span class="s3">,</span>
    <span class="s1">download: Downloader</span><span class="s3">,</span>
    <span class="s1">verbosity: int</span><span class="s3">,</span>
    <span class="s1">download_dir: Optional[str] = </span><span class="s3">None,</span>
    <span class="s1">hashes: Optional[Hashes] = </span><span class="s3">None,</span>
<span class="s1">) -&gt; Optional[File]:</span>
    <span class="s0">&quot;&quot;&quot;Unpack link into location, downloading if required. 
 
    :param hashes: A Hashes object, one of whose embedded hashes must match, 
        or HashMismatch will be raised. If the Hashes is empty, no matches are 
        required, and unhashable types of requirements (like VCS ones, which 
        would ordinarily raise HashUnsupported) are allowed. 
    &quot;&quot;&quot;</span>
    <span class="s2"># non-editable vcs urls</span>
    <span class="s3">if </span><span class="s1">link.is_vcs:</span>
        <span class="s1">unpack_vcs_link(link</span><span class="s3">, </span><span class="s1">location</span><span class="s3">, </span><span class="s1">verbosity=verbosity)</span>
        <span class="s3">return None</span>

    <span class="s2"># Once out-of-tree-builds are no longer supported, could potentially</span>
    <span class="s2"># replace the below condition with `assert not link.is_existing_dir`</span>
    <span class="s2"># - unpack_url does not need to be called for in-tree-builds.</span>
    <span class="s2">#</span>
    <span class="s2"># As further cleanup, _copy_source_tree and accompanying tests can</span>
    <span class="s2"># be removed.</span>
    <span class="s2">#</span>
    <span class="s2"># TODO when use-deprecated=out-of-tree-build is removed</span>
    <span class="s3">if </span><span class="s1">link.is_existing_dir():</span>
        <span class="s3">if </span><span class="s1">os.path.isdir(location):</span>
            <span class="s1">rmtree(location)</span>
        <span class="s1">_copy_source_tree(link.file_path</span><span class="s3">, </span><span class="s1">location)</span>
        <span class="s3">return None</span>

    <span class="s2"># file urls</span>
    <span class="s3">if </span><span class="s1">link.is_file:</span>
        <span class="s1">file = get_file_url(link</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes=hashes)</span>

    <span class="s2"># http urls</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">file = get_http_url(</span>
            <span class="s1">link</span><span class="s3">,</span>
            <span class="s1">download</span><span class="s3">,</span>
            <span class="s1">download_dir</span><span class="s3">,</span>
            <span class="s1">hashes=hashes</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2"># unpack the archive to the build dir location. even when only downloading</span>
    <span class="s2"># archives, they have to be unpacked to parse dependencies, except wheels</span>
    <span class="s3">if not </span><span class="s1">link.is_wheel:</span>
        <span class="s1">unpack_file(file.path</span><span class="s3">, </span><span class="s1">location</span><span class="s3">, </span><span class="s1">file.content_type)</span>

    <span class="s3">return </span><span class="s1">file</span>


<span class="s3">def </span><span class="s1">_check_download_dir(</span>
    <span class="s1">link: Link</span><span class="s3">, </span><span class="s1">download_dir: str</span><span class="s3">, </span><span class="s1">hashes: Optional[Hashes]</span>
<span class="s1">) -&gt; Optional[str]:</span>
    <span class="s0">&quot;&quot;&quot;Check download_dir for previously downloaded file with correct hash 
    If a correct file is found return its path else None 
    &quot;&quot;&quot;</span>
    <span class="s1">download_path = os.path.join(download_dir</span><span class="s3">, </span><span class="s1">link.filename)</span>

    <span class="s3">if not </span><span class="s1">os.path.exists(download_path):</span>
        <span class="s3">return None</span>

    <span class="s2"># If already downloaded, does its hash match?</span>
    <span class="s1">logger.info(</span><span class="s5">&quot;File was already downloaded %s&quot;</span><span class="s3">, </span><span class="s1">download_path)</span>
    <span class="s3">if </span><span class="s1">hashes:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">hashes.check_against_path(download_path)</span>
        <span class="s3">except </span><span class="s1">HashMismatch:</span>
            <span class="s1">logger.warning(</span>
                <span class="s5">&quot;Previously-downloaded file %s has bad hash. Re-downloading.&quot;</span><span class="s3">,</span>
                <span class="s1">download_path</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">os.unlink(download_path)</span>
            <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">download_path</span>


<span class="s3">class </span><span class="s1">RequirementPreparer:</span>
    <span class="s0">&quot;&quot;&quot;Prepares a Requirement&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">build_dir: str</span><span class="s3">,</span>
        <span class="s1">download_dir: Optional[str]</span><span class="s3">,</span>
        <span class="s1">src_dir: str</span><span class="s3">,</span>
        <span class="s1">build_isolation: bool</span><span class="s3">,</span>
        <span class="s1">req_tracker: RequirementTracker</span><span class="s3">,</span>
        <span class="s1">session: PipSession</span><span class="s3">,</span>
        <span class="s1">progress_bar: str</span><span class="s3">,</span>
        <span class="s1">finder: PackageFinder</span><span class="s3">,</span>
        <span class="s1">require_hashes: bool</span><span class="s3">,</span>
        <span class="s1">use_user_site: bool</span><span class="s3">,</span>
        <span class="s1">lazy_wheel: bool</span><span class="s3">,</span>
        <span class="s1">verbosity: int</span><span class="s3">,</span>
        <span class="s1">in_tree_build: bool</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">super().__init__()</span>

        <span class="s1">self.src_dir = src_dir</span>
        <span class="s1">self.build_dir = build_dir</span>
        <span class="s1">self.req_tracker = req_tracker</span>
        <span class="s1">self._session = session</span>
        <span class="s1">self._download = Downloader(session</span><span class="s3">, </span><span class="s1">progress_bar)</span>
        <span class="s1">self._batch_download = BatchDownloader(session</span><span class="s3">, </span><span class="s1">progress_bar)</span>
        <span class="s1">self.finder = finder</span>

        <span class="s2"># Where still-packed archives should be written to. If None, they are</span>
        <span class="s2"># not saved, and are deleted immediately after unpacking.</span>
        <span class="s1">self.download_dir = download_dir</span>

        <span class="s2"># Is build isolation allowed?</span>
        <span class="s1">self.build_isolation = build_isolation</span>

        <span class="s2"># Should hash-checking be required?</span>
        <span class="s1">self.require_hashes = require_hashes</span>

        <span class="s2"># Should install in user site-packages?</span>
        <span class="s1">self.use_user_site = use_user_site</span>

        <span class="s2"># Should wheels be downloaded lazily?</span>
        <span class="s1">self.use_lazy_wheel = lazy_wheel</span>

        <span class="s2"># How verbose should underlying tooling be?</span>
        <span class="s1">self.verbosity = verbosity</span>

        <span class="s2"># Should in-tree builds be used for local paths?</span>
        <span class="s1">self.in_tree_build = in_tree_build</span>

        <span class="s2"># Memoized downloaded files, as mapping of url: path.</span>
        <span class="s1">self._downloaded: Dict[str</span><span class="s3">, </span><span class="s1">str] = {}</span>

        <span class="s2"># Previous &quot;header&quot; printed for a link-based InstallRequirement</span>
        <span class="s1">self._previous_requirement_header = (</span><span class="s5">&quot;&quot;</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_log_preparing_link(self</span><span class="s3">, </span><span class="s1">req: InstallRequirement) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Provide context for the requirement being prepared.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">req.link.is_file </span><span class="s3">and not </span><span class="s1">req.original_link_is_in_wheel_cache:</span>
            <span class="s1">message = </span><span class="s5">&quot;Processing %s&quot;</span>
            <span class="s1">information = str(display_path(req.link.file_path))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">message = </span><span class="s5">&quot;Collecting %s&quot;</span>
            <span class="s1">information = str(req.req </span><span class="s3">or </span><span class="s1">req)</span>

        <span class="s3">if </span><span class="s1">(message</span><span class="s3">, </span><span class="s1">information) != self._previous_requirement_header:</span>
            <span class="s1">self._previous_requirement_header = (message</span><span class="s3">, </span><span class="s1">information)</span>
            <span class="s1">logger.info(message</span><span class="s3">, </span><span class="s1">information)</span>

        <span class="s3">if </span><span class="s1">req.original_link_is_in_wheel_cache:</span>
            <span class="s3">with </span><span class="s1">indent_log():</span>
                <span class="s1">logger.info(</span><span class="s5">&quot;Using cached %s&quot;</span><span class="s3">, </span><span class="s1">req.link.filename)</span>

    <span class="s3">def </span><span class="s1">_ensure_link_req_src_dir(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">req: InstallRequirement</span><span class="s3">, </span><span class="s1">parallel_builds: bool</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Ensure source_dir of a linked InstallRequirement.&quot;&quot;&quot;</span>
        <span class="s2"># Since source_dir is only set for editable requirements.</span>
        <span class="s3">if </span><span class="s1">req.link.is_wheel:</span>
            <span class="s2"># We don't need to unpack wheels, so no need for a source</span>
            <span class="s2"># directory.</span>
            <span class="s3">return</span>
        <span class="s3">assert </span><span class="s1">req.source_dir </span><span class="s3">is None</span>
        <span class="s3">if </span><span class="s1">req.link.is_existing_dir() </span><span class="s3">and </span><span class="s1">self.in_tree_build:</span>
            <span class="s2"># build local directories in-tree</span>
            <span class="s1">req.source_dir = req.link.file_path</span>
            <span class="s3">return</span>

        <span class="s2"># We always delete unpacked sdists after pip runs.</span>
        <span class="s1">req.ensure_has_source_dir(</span>
            <span class="s1">self.build_dir</span><span class="s3">,</span>
            <span class="s1">autodelete=</span><span class="s3">True,</span>
            <span class="s1">parallel_builds=parallel_builds</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s2"># If a checkout exists, it's unwise to keep going.  version</span>
        <span class="s2"># inconsistencies are logged later, but do not fail the</span>
        <span class="s2"># installation.</span>
        <span class="s2"># FIXME: this won't upgrade when there's an existing</span>
        <span class="s2"># package unpacked in `req.source_dir`</span>
        <span class="s2"># TODO: this check is now probably dead code</span>
        <span class="s3">if </span><span class="s1">is_installable_dir(req.source_dir):</span>
            <span class="s3">raise </span><span class="s1">PreviousBuildDirError(</span>
                <span class="s5">&quot;pip can't proceed with requirements '{}' due to a&quot;</span>
                <span class="s5">&quot;pre-existing build directory ({}). This is likely &quot;</span>
                <span class="s5">&quot;due to a previous installation that failed . pip is &quot;</span>
                <span class="s5">&quot;being responsible and not assuming it can delete this. &quot;</span>
                <span class="s5">&quot;Please delete it and try again.&quot;</span><span class="s1">.format(req</span><span class="s3">, </span><span class="s1">req.source_dir)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_get_linked_req_hashes(self</span><span class="s3">, </span><span class="s1">req: InstallRequirement) -&gt; Hashes:</span>
        <span class="s2"># By the time this is called, the requirement's link should have</span>
        <span class="s2"># been checked so we can tell what kind of requirements req is</span>
        <span class="s2"># and raise some more informative errors than otherwise.</span>
        <span class="s2"># (For example, we can raise VcsHashUnsupported for a VCS URL</span>
        <span class="s2"># rather than HashMissing.)</span>
        <span class="s3">if not </span><span class="s1">self.require_hashes:</span>
            <span class="s3">return </span><span class="s1">req.hashes(trust_internet=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s2"># We could check these first 2 conditions inside unpack_url</span>
        <span class="s2"># and save repetition of conditions, but then we would</span>
        <span class="s2"># report less-useful error messages for unhashable</span>
        <span class="s2"># requirements, complaining that there's no hash provided.</span>
        <span class="s3">if </span><span class="s1">req.link.is_vcs:</span>
            <span class="s3">raise </span><span class="s1">VcsHashUnsupported()</span>
        <span class="s3">if </span><span class="s1">req.link.is_existing_dir():</span>
            <span class="s3">raise </span><span class="s1">DirectoryUrlHashUnsupported()</span>

        <span class="s2"># Unpinned packages are asking for trouble when a new version</span>
        <span class="s2"># is uploaded.  This isn't a security check, but it saves users</span>
        <span class="s2"># a surprising hash mismatch in the future.</span>
        <span class="s2"># file:/// URLs aren't pinnable, so don't complain about them</span>
        <span class="s2"># not being pinned.</span>
        <span class="s3">if </span><span class="s1">req.original_link </span><span class="s3">is None and not </span><span class="s1">req.is_pinned:</span>
            <span class="s3">raise </span><span class="s1">HashUnpinned()</span>

        <span class="s2"># If known-good hashes are missing for this requirement,</span>
        <span class="s2"># shim it with a facade object that will provoke hash</span>
        <span class="s2"># computation and then raise a HashMissing exception</span>
        <span class="s2"># showing the user what the hash should be.</span>
        <span class="s3">return </span><span class="s1">req.hashes(trust_internet=</span><span class="s3">False</span><span class="s1">) </span><span class="s3">or </span><span class="s1">MissingHashes()</span>

    <span class="s3">def </span><span class="s1">_fetch_metadata_using_lazy_wheel(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">link: Link</span><span class="s3">,</span>
    <span class="s1">) -&gt; Optional[BaseDistribution]:</span>
        <span class="s0">&quot;&quot;&quot;Fetch metadata using lazy wheel, if possible.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self.use_lazy_wheel:</span>
            <span class="s3">return None</span>
        <span class="s3">if </span><span class="s1">self.require_hashes:</span>
            <span class="s1">logger.debug(</span><span class="s5">&quot;Lazy wheel is not used as hash checking is required&quot;</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">if </span><span class="s1">link.is_file </span><span class="s3">or not </span><span class="s1">link.is_wheel:</span>
            <span class="s1">logger.debug(</span>
                <span class="s5">&quot;Lazy wheel is not used as %r does not points to a remote wheel&quot;</span><span class="s3">,</span>
                <span class="s1">link</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">return None</span>

        <span class="s1">wheel = Wheel(link.filename)</span>
        <span class="s1">name = canonicalize_name(wheel.name)</span>
        <span class="s1">logger.info(</span>
            <span class="s5">&quot;Obtaining dependency information from %s %s&quot;</span><span class="s3">,</span>
            <span class="s1">name</span><span class="s3">,</span>
            <span class="s1">wheel.version</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">url = link.url.split(</span><span class="s5">&quot;#&quot;</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">dist_from_wheel_url(name</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">self._session)</span>
        <span class="s3">except </span><span class="s1">HTTPRangeRequestUnsupported:</span>
            <span class="s1">logger.debug(</span><span class="s5">&quot;%s does not support range requests&quot;</span><span class="s3">, </span><span class="s1">url)</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_complete_partial_requirements(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">partially_downloaded_reqs: Iterable[InstallRequirement]</span><span class="s3">,</span>
        <span class="s1">parallel_builds: bool = </span><span class="s3">False,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Download any requirements which were only fetched by metadata.&quot;&quot;&quot;</span>
        <span class="s2"># Download to a temporary directory. These will be copied over as</span>
        <span class="s2"># needed for downstream 'download', 'wheel', and 'install' commands.</span>
        <span class="s1">temp_dir = TempDirectory(kind=</span><span class="s5">&quot;unpack&quot;</span><span class="s3">, </span><span class="s1">globally_managed=</span><span class="s3">True</span><span class="s1">).path</span>

        <span class="s2"># Map each link to the requirement that owns it. This allows us to set</span>
        <span class="s2"># `req.local_file_path` on the appropriate requirement after passing</span>
        <span class="s2"># all the links at once into BatchDownloader.</span>
        <span class="s1">links_to_fully_download: Dict[Link</span><span class="s3">, </span><span class="s1">InstallRequirement] = {}</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">partially_downloaded_reqs:</span>
            <span class="s3">assert </span><span class="s1">req.link</span>
            <span class="s1">links_to_fully_download[req.link] = req</span>

        <span class="s1">batch_download = self._batch_download(</span>
            <span class="s1">links_to_fully_download.keys()</span><span class="s3">,</span>
            <span class="s1">temp_dir</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">link</span><span class="s3">, </span><span class="s1">(filepath</span><span class="s3">, </span><span class="s1">_) </span><span class="s3">in </span><span class="s1">batch_download:</span>
            <span class="s1">logger.debug(</span><span class="s5">&quot;Downloading link %s to %s&quot;</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">filepath)</span>
            <span class="s1">req = links_to_fully_download[link]</span>
            <span class="s1">req.local_file_path = filepath</span>

        <span class="s2"># This step is necessary to ensure all lazy wheels are processed</span>
        <span class="s2"># successfully by the 'download', 'wheel', and 'install' commands.</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">partially_downloaded_reqs:</span>
            <span class="s1">self._prepare_linked_requirement(req</span><span class="s3">, </span><span class="s1">parallel_builds)</span>

    <span class="s3">def </span><span class="s1">prepare_linked_requirement(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">req: InstallRequirement</span><span class="s3">, </span><span class="s1">parallel_builds: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; BaseDistribution:</span>
        <span class="s0">&quot;&quot;&quot;Prepare a requirement to be obtained from req.link.&quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req.link</span>
        <span class="s1">link = req.link</span>
        <span class="s1">self._log_preparing_link(req)</span>
        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s2"># Check if the relevant file is already available</span>
            <span class="s2"># in the download directory</span>
            <span class="s1">file_path = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">self.download_dir </span><span class="s3">is not None and </span><span class="s1">link.is_wheel:</span>
                <span class="s1">hashes = self._get_linked_req_hashes(req)</span>
                <span class="s1">file_path = _check_download_dir(req.link</span><span class="s3">, </span><span class="s1">self.download_dir</span><span class="s3">, </span><span class="s1">hashes)</span>

            <span class="s3">if </span><span class="s1">file_path </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s2"># The file is already available, so mark it as downloaded</span>
                <span class="s1">self._downloaded[req.link.url] = file_path</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># The file is not available, attempt to fetch only metadata</span>
                <span class="s1">wheel_dist = self._fetch_metadata_using_lazy_wheel(link)</span>
                <span class="s3">if </span><span class="s1">wheel_dist </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">req.needs_more_preparation = </span><span class="s3">True</span>
                    <span class="s3">return </span><span class="s1">wheel_dist</span>

            <span class="s2"># None of the optimizations worked, fully prepare the requirement</span>
            <span class="s3">return </span><span class="s1">self._prepare_linked_requirement(req</span><span class="s3">, </span><span class="s1">parallel_builds)</span>

    <span class="s3">def </span><span class="s1">prepare_linked_requirements_more(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">reqs: Iterable[InstallRequirement]</span><span class="s3">, </span><span class="s1">parallel_builds: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Prepare linked requirements more, if needed.&quot;&quot;&quot;</span>
        <span class="s1">reqs = [req </span><span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">reqs </span><span class="s3">if </span><span class="s1">req.needs_more_preparation]</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">reqs:</span>
            <span class="s2"># Determine if any of these requirements were already downloaded.</span>
            <span class="s3">if </span><span class="s1">self.download_dir </span><span class="s3">is not None and </span><span class="s1">req.link.is_wheel:</span>
                <span class="s1">hashes = self._get_linked_req_hashes(req)</span>
                <span class="s1">file_path = _check_download_dir(req.link</span><span class="s3">, </span><span class="s1">self.download_dir</span><span class="s3">, </span><span class="s1">hashes)</span>
                <span class="s3">if </span><span class="s1">file_path </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self._downloaded[req.link.url] = file_path</span>
                    <span class="s1">req.needs_more_preparation = </span><span class="s3">False</span>

        <span class="s2"># Prepare requirements we found were already downloaded for some</span>
        <span class="s2"># reason. The other downloads will be completed separately.</span>
        <span class="s1">partially_downloaded_reqs: List[InstallRequirement] = []</span>
        <span class="s3">for </span><span class="s1">req </span><span class="s3">in </span><span class="s1">reqs:</span>
            <span class="s3">if </span><span class="s1">req.needs_more_preparation:</span>
                <span class="s1">partially_downloaded_reqs.append(req)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._prepare_linked_requirement(req</span><span class="s3">, </span><span class="s1">parallel_builds)</span>

        <span class="s2"># TODO: separate this part out from RequirementPreparer when the v1</span>
        <span class="s2"># resolver can be removed!</span>
        <span class="s1">self._complete_partial_requirements(</span>
            <span class="s1">partially_downloaded_reqs</span><span class="s3">,</span>
            <span class="s1">parallel_builds=parallel_builds</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_prepare_linked_requirement(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">req: InstallRequirement</span><span class="s3">, </span><span class="s1">parallel_builds: bool</span>
    <span class="s1">) -&gt; BaseDistribution:</span>
        <span class="s3">assert </span><span class="s1">req.link</span>
        <span class="s1">link = req.link</span>

        <span class="s1">self._ensure_link_req_src_dir(req</span><span class="s3">, </span><span class="s1">parallel_builds)</span>
        <span class="s1">hashes = self._get_linked_req_hashes(req)</span>

        <span class="s3">if </span><span class="s1">link.is_existing_dir() </span><span class="s3">and </span><span class="s1">self.in_tree_build:</span>
            <span class="s1">local_file = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">link.url </span><span class="s3">not in </span><span class="s1">self._downloaded:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">local_file = unpack_url(</span>
                    <span class="s1">link</span><span class="s3">,</span>
                    <span class="s1">req.source_dir</span><span class="s3">,</span>
                    <span class="s1">self._download</span><span class="s3">,</span>
                    <span class="s1">self.verbosity</span><span class="s3">,</span>
                    <span class="s1">self.download_dir</span><span class="s3">,</span>
                    <span class="s1">hashes</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">except </span><span class="s1">NetworkConnectionError </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s3">raise </span><span class="s1">InstallationError(</span>
                    <span class="s5">&quot;Could not install requirement {} because of HTTP &quot;</span>
                    <span class="s5">&quot;error {} for URL {}&quot;</span><span class="s1">.format(req</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">link)</span>
                <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">file_path = self._downloaded[link.url]</span>
            <span class="s3">if </span><span class="s1">hashes:</span>
                <span class="s1">hashes.check_against_path(file_path)</span>
            <span class="s1">local_file = File(file_path</span><span class="s3">, </span><span class="s1">content_type=</span><span class="s3">None</span><span class="s1">)</span>

        <span class="s2"># For use in later processing,</span>
        <span class="s2"># preserve the file path on the requirement.</span>
        <span class="s3">if </span><span class="s1">local_file:</span>
            <span class="s1">req.local_file_path = local_file.path</span>

        <span class="s1">dist = _get_prepared_distribution(</span>
            <span class="s1">req</span><span class="s3">,</span>
            <span class="s1">self.req_tracker</span><span class="s3">,</span>
            <span class="s1">self.finder</span><span class="s3">,</span>
            <span class="s1">self.build_isolation</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">save_linked_requirement(self</span><span class="s3">, </span><span class="s1">req: InstallRequirement) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">assert </span><span class="s1">self.download_dir </span><span class="s3">is not None</span>
        <span class="s3">assert </span><span class="s1">req.link </span><span class="s3">is not None</span>
        <span class="s1">link = req.link</span>
        <span class="s3">if </span><span class="s1">link.is_vcs </span><span class="s3">or </span><span class="s1">(link.is_existing_dir() </span><span class="s3">and </span><span class="s1">req.editable):</span>
            <span class="s2"># Make a .zip of the source_dir we already created.</span>
            <span class="s1">req.archive(self.download_dir)</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">link.is_existing_dir():</span>
            <span class="s1">logger.debug(</span>
                <span class="s5">&quot;Not copying link to destination directory &quot;</span>
                <span class="s5">&quot;since it is a directory: %s&quot;</span><span class="s3">,</span>
                <span class="s1">link</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">req.local_file_path </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2"># No distribution was downloaded for this requirement.</span>
            <span class="s3">return</span>

        <span class="s1">download_location = os.path.join(self.download_dir</span><span class="s3">, </span><span class="s1">link.filename)</span>
        <span class="s3">if not </span><span class="s1">os.path.exists(download_location):</span>
            <span class="s1">shutil.copy(req.local_file_path</span><span class="s3">, </span><span class="s1">download_location)</span>
            <span class="s1">download_path = display_path(download_location)</span>
            <span class="s1">logger.info(</span><span class="s5">&quot;Saved %s&quot;</span><span class="s3">, </span><span class="s1">download_path)</span>

    <span class="s3">def </span><span class="s1">prepare_editable_requirement(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">req: InstallRequirement</span><span class="s3">,</span>
    <span class="s1">) -&gt; BaseDistribution:</span>
        <span class="s0">&quot;&quot;&quot;Prepare an editable requirement.&quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req.editable</span><span class="s3">, </span><span class="s5">&quot;cannot prepare a non-editable req as editable&quot;</span>

        <span class="s1">logger.info(</span><span class="s5">&quot;Obtaining %s&quot;</span><span class="s3">, </span><span class="s1">req)</span>

        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s3">if </span><span class="s1">self.require_hashes:</span>
                <span class="s3">raise </span><span class="s1">InstallationError(</span>
                    <span class="s5">&quot;The editable requirement {} cannot be installed when &quot;</span>
                    <span class="s5">&quot;requiring hashes, because there is no single file to &quot;</span>
                    <span class="s5">&quot;hash.&quot;</span><span class="s1">.format(req)</span>
                <span class="s1">)</span>
            <span class="s1">req.ensure_has_source_dir(self.src_dir)</span>
            <span class="s1">req.update_editable()</span>

            <span class="s1">dist = _get_prepared_distribution(</span>
                <span class="s1">req</span><span class="s3">,</span>
                <span class="s1">self.req_tracker</span><span class="s3">,</span>
                <span class="s1">self.finder</span><span class="s3">,</span>
                <span class="s1">self.build_isolation</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">req.check_if_exists(self.use_user_site)</span>

        <span class="s3">return </span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">prepare_installed_requirement(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">req: InstallRequirement</span><span class="s3">,</span>
        <span class="s1">skip_reason: str</span><span class="s3">,</span>
    <span class="s1">) -&gt; BaseDistribution:</span>
        <span class="s0">&quot;&quot;&quot;Prepare an already-installed requirement.&quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req.satisfied_by</span><span class="s3">, </span><span class="s5">&quot;req should have been satisfied but isn't&quot;</span>
        <span class="s3">assert </span><span class="s1">skip_reason </span><span class="s3">is not None, </span><span class="s1">(</span>
            <span class="s5">&quot;did not get skip reason skipped but req.satisfied_by &quot;</span>
            <span class="s5">&quot;is set to {}&quot;</span><span class="s1">.format(req.satisfied_by)</span>
        <span class="s1">)</span>
        <span class="s1">logger.info(</span>
            <span class="s5">&quot;Requirement %s: %s (%s)&quot;</span><span class="s3">, </span><span class="s1">skip_reason</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">req.satisfied_by.version</span>
        <span class="s1">)</span>
        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s3">if </span><span class="s1">self.require_hashes:</span>
                <span class="s1">logger.debug(</span>
                    <span class="s5">&quot;Since it is already installed, we are trusting this &quot;</span>
                    <span class="s5">&quot;package without checking its hash. To ensure a &quot;</span>
                    <span class="s5">&quot;completely repeatable environment, install into an &quot;</span>
                    <span class="s5">&quot;empty virtualenv.&quot;</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">InstalledDistribution(req).get_metadata_distribution()</span>
</pre>
</body>
</html>