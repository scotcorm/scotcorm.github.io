<html>
<head>
<title>specifiers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
specifiers.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is dual licensed under the terms of the Apache License, Version</span>
<span class="s0"># 2.0, and the BSD License. See the LICENSE file in the root of this repository</span>
<span class="s0"># for complete details.</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span><span class="s2">, </span><span class="s1">division</span><span class="s2">, </span><span class="s1">print_function</span>

<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">string_types</span><span class="s2">, </span><span class="s1">with_metaclass</span>
<span class="s2">from </span><span class="s1">._typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">canonicalize_version</span>
<span class="s2">from </span><span class="s1">.version </span><span class="s2">import </span><span class="s1">Version</span><span class="s2">, </span><span class="s1">LegacyVersion</span><span class="s2">, </span><span class="s1">parse</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:  </span><span class="s0"># pragma: no cover</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">List</span><span class="s2">,</span>
        <span class="s1">Dict</span><span class="s2">,</span>
        <span class="s1">Union</span><span class="s2">,</span>
        <span class="s1">Iterable</span><span class="s2">,</span>
        <span class="s1">Iterator</span><span class="s2">,</span>
        <span class="s1">Optional</span><span class="s2">,</span>
        <span class="s1">Callable</span><span class="s2">,</span>
        <span class="s1">Tuple</span><span class="s2">,</span>
        <span class="s1">FrozenSet</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">ParsedVersion = Union[Version</span><span class="s2">, </span><span class="s1">LegacyVersion]</span>
    <span class="s1">UnparsedVersion = Union[Version</span><span class="s2">, </span><span class="s1">LegacyVersion</span><span class="s2">, </span><span class="s1">str]</span>
    <span class="s1">CallableOperator = Callable[[ParsedVersion</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">bool]</span>


<span class="s2">class </span><span class="s1">InvalidSpecifier(ValueError):</span>
    <span class="s3">&quot;&quot;&quot; 
    An invalid specifier was found, users should refer to PEP 440. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">BaseSpecifier(with_metaclass(abc.ABCMeta</span><span class="s2">, </span><span class="s1">object)):  </span><span class="s0"># type: ignore</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the str representation of this Specifier like object. This 
        should be representative of the Specifier itself. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s0"># type: () -&gt; int</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a hash value for this Specifier like object. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (object) -&gt; bool</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a boolean representing whether or not the two Specifier like 
        objects are equal. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (object) -&gt; bool</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a boolean representing whether or not the two Specifier like 
        objects are not equal. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abc.abstractproperty</span>
    <span class="s2">def </span><span class="s1">prereleases(self):</span>
        <span class="s0"># type: () -&gt; Optional[bool]</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns whether or not pre-releases as a whole are allowed by this 
        specifier. 
        &quot;&quot;&quot;</span>

    <span class="s1">@prereleases.setter</span>
    <span class="s2">def </span><span class="s1">prereleases(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0"># type: (bool) -&gt; None</span>
        <span class="s3">&quot;&quot;&quot; 
        Sets whether or not pre-releases as a whole are allowed by this 
        specifier. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (str, Optional[bool]) -&gt; bool</span>
        <span class="s3">&quot;&quot;&quot; 
        Determines if the given item is contained within this specifier. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">filter(self</span><span class="s2">, </span><span class="s1">iterable</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (Iterable[UnparsedVersion], Optional[bool]) -&gt; Iterable[UnparsedVersion]</span>
        <span class="s3">&quot;&quot;&quot; 
        Takes an iterable of items and filters them so that only items which 
        are contained within this specifier are allowed in it. 
        &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">_IndividualSpecifier(BaseSpecifier):</span>

    <span class="s1">_operators = {}  </span><span class="s0"># type: Dict[str, str]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">spec=</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (str, Optional[bool]) -&gt; None</span>
        <span class="s1">match = self._regex.search(spec)</span>
        <span class="s2">if not </span><span class="s1">match:</span>
            <span class="s2">raise </span><span class="s1">InvalidSpecifier(</span><span class="s4">&quot;Invalid specifier: '{0}'&quot;</span><span class="s1">.format(spec))</span>

        <span class="s1">self._spec = (</span>
            <span class="s1">match.group(</span><span class="s4">&quot;operator&quot;</span><span class="s1">).strip()</span><span class="s2">,</span>
            <span class="s1">match.group(</span><span class="s4">&quot;version&quot;</span><span class="s1">).strip()</span><span class="s2">,</span>
        <span class="s1">)  </span><span class="s0"># type: Tuple[str, str]</span>

        <span class="s0"># Store whether or not this Specifier should accept prereleases</span>
        <span class="s1">self._prereleases = prereleases</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s1">pre = (</span>
            <span class="s4">&quot;, prereleases={0!r}&quot;</span><span class="s1">.format(self.prereleases)</span>
            <span class="s2">if </span><span class="s1">self._prereleases </span><span class="s2">is not None</span>
            <span class="s2">else </span><span class="s4">&quot;&quot;</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s4">&quot;&lt;{0}({1!r}{2})&gt;&quot;</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">, </span><span class="s1">str(self)</span><span class="s2">, </span><span class="s1">pre)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s2">return </span><span class="s4">&quot;{0}{1}&quot;</span><span class="s1">.format(*self._spec)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_canonical_spec(self):</span>
        <span class="s0"># type: () -&gt; Tuple[str, Union[Version, str]]</span>
        <span class="s2">return </span><span class="s1">self._spec[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">canonicalize_version(self._spec[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s0"># type: () -&gt; int</span>
        <span class="s2">return </span><span class="s1">hash(self._canonical_spec)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (object) -&gt; bool</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">string_types):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">other = self.__class__(str(other))</span>
            <span class="s2">except </span><span class="s1">InvalidSpecifier:</span>
                <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._canonical_spec == other._canonical_spec</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (object) -&gt; bool</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">string_types):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">other = self.__class__(str(other))</span>
            <span class="s2">except </span><span class="s1">InvalidSpecifier:</span>
                <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._spec != other._spec</span>

    <span class="s2">def </span><span class="s1">_get_operator(self</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0"># type: (str) -&gt; CallableOperator</span>
        <span class="s1">operator_callable = getattr(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;_compare_{0}&quot;</span><span class="s1">.format(self._operators[op])</span>
        <span class="s1">)  </span><span class="s0"># type: CallableOperator</span>
        <span class="s2">return </span><span class="s1">operator_callable</span>

    <span class="s2">def </span><span class="s1">_coerce_version(self</span><span class="s2">, </span><span class="s1">version):</span>
        <span class="s0"># type: (UnparsedVersion) -&gt; ParsedVersion</span>
        <span class="s2">if not </span><span class="s1">isinstance(version</span><span class="s2">, </span><span class="s1">(LegacyVersion</span><span class="s2">, </span><span class="s1">Version)):</span>
            <span class="s1">version = parse(version)</span>
        <span class="s2">return </span><span class="s1">version</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">operator(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s2">return </span><span class="s1">self._spec[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">version(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s2">return </span><span class="s1">self._spec[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">prereleases(self):</span>
        <span class="s0"># type: () -&gt; Optional[bool]</span>
        <span class="s2">return </span><span class="s1">self._prereleases</span>

    <span class="s1">@prereleases.setter</span>
    <span class="s2">def </span><span class="s1">prereleases(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0"># type: (bool) -&gt; None</span>
        <span class="s1">self._prereleases = value</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s0"># type: (str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">self.contains(item)</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (UnparsedVersion, Optional[bool]) -&gt; bool</span>

        <span class="s0"># Determine if prereleases are to be allowed or not.</span>
        <span class="s2">if </span><span class="s1">prereleases </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prereleases = self.prereleases</span>

        <span class="s0"># Normalize item to a Version or LegacyVersion, this allows us to have</span>
        <span class="s0"># a shortcut for ``&quot;2.0&quot; in Specifier(&quot;&gt;=2&quot;)</span>
        <span class="s1">normalized_item = self._coerce_version(item)</span>

        <span class="s0"># Determine if we should be supporting prereleases in this specifier</span>
        <span class="s0"># or not, if we do not support prereleases than we can short circuit</span>
        <span class="s0"># logic if this version is a prereleases.</span>
        <span class="s2">if </span><span class="s1">normalized_item.is_prerelease </span><span class="s2">and not </span><span class="s1">prereleases:</span>
            <span class="s2">return False</span>

        <span class="s0"># Actually do the comparison to determine if this item is contained</span>
        <span class="s0"># within this Specifier or not.</span>
        <span class="s1">operator_callable = self._get_operator(self.operator)  </span><span class="s0"># type: CallableOperator</span>
        <span class="s2">return </span><span class="s1">operator_callable(normalized_item</span><span class="s2">, </span><span class="s1">self.version)</span>

    <span class="s2">def </span><span class="s1">filter(self</span><span class="s2">, </span><span class="s1">iterable</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (Iterable[UnparsedVersion], Optional[bool]) -&gt; Iterable[UnparsedVersion]</span>

        <span class="s1">yielded = </span><span class="s2">False</span>
        <span class="s1">found_prereleases = []</span>

        <span class="s1">kw = {</span><span class="s4">&quot;prereleases&quot;</span><span class="s1">: prereleases </span><span class="s2">if </span><span class="s1">prereleases </span><span class="s2">is not None else True</span><span class="s1">}</span>

        <span class="s0"># Attempt to iterate over all the values in the iterable and if any of</span>
        <span class="s0"># them match, yield them.</span>
        <span class="s2">for </span><span class="s1">version </span><span class="s2">in </span><span class="s1">iterable:</span>
            <span class="s1">parsed_version = self._coerce_version(version)</span>

            <span class="s2">if </span><span class="s1">self.contains(parsed_version</span><span class="s2">, </span><span class="s1">**kw):</span>
                <span class="s0"># If our version is a prerelease, and we were not set to allow</span>
                <span class="s0"># prereleases, then we'll store it for later incase nothing</span>
                <span class="s0"># else matches this specifier.</span>
                <span class="s2">if </span><span class="s1">parsed_version.is_prerelease </span><span class="s2">and not </span><span class="s1">(</span>
                    <span class="s1">prereleases </span><span class="s2">or </span><span class="s1">self.prereleases</span>
                <span class="s1">):</span>
                    <span class="s1">found_prereleases.append(version)</span>
                <span class="s0"># Either this is not a prerelease, or we should have been</span>
                <span class="s0"># accepting prereleases from the beginning.</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">yielded = </span><span class="s2">True</span>
                    <span class="s2">yield </span><span class="s1">version</span>

        <span class="s0"># Now that we've iterated over everything, determine if we've yielded</span>
        <span class="s0"># any values, and if we have not and we have any prereleases stored up</span>
        <span class="s0"># then we will go ahead and yield the prereleases.</span>
        <span class="s2">if not </span><span class="s1">yielded </span><span class="s2">and </span><span class="s1">found_prereleases:</span>
            <span class="s2">for </span><span class="s1">version </span><span class="s2">in </span><span class="s1">found_prereleases:</span>
                <span class="s2">yield </span><span class="s1">version</span>


<span class="s2">class </span><span class="s1">LegacySpecifier(_IndividualSpecifier):</span>

    <span class="s1">_regex_str = </span><span class="s4">r&quot;&quot;&quot; 
        (?P&lt;operator&gt;(==|!=|&lt;=|&gt;=|&lt;|&gt;)) 
        \s* 
        (?P&lt;version&gt; 
            [^,;\s)]* # Since this is a &quot;legacy&quot; specifier, and the version 
                      # string can be just about anything, we match everything 
                      # except for whitespace, a semi-colon for marker support, 
                      # a closing paren since versions can be enclosed in 
                      # them, and a comma since it's a version separator. 
        ) 
        &quot;&quot;&quot;</span>

    <span class="s1">_regex = re.compile(</span><span class="s4">r&quot;^\s*&quot; </span><span class="s1">+ _regex_str + </span><span class="s4">r&quot;\s*$&quot;</span><span class="s2">, </span><span class="s1">re.VERBOSE | re.IGNORECASE)</span>

    <span class="s1">_operators = {</span>
        <span class="s4">&quot;==&quot;</span><span class="s1">: </span><span class="s4">&quot;equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;!=&quot;</span><span class="s1">: </span><span class="s4">&quot;not_equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&lt;=&quot;</span><span class="s1">: </span><span class="s4">&quot;less_than_equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&gt;=&quot;</span><span class="s1">: </span><span class="s4">&quot;greater_than_equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&lt;&quot;</span><span class="s1">: </span><span class="s4">&quot;less_than&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&gt;&quot;</span><span class="s1">: </span><span class="s4">&quot;greater_than&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_coerce_version(self</span><span class="s2">, </span><span class="s1">version):</span>
        <span class="s0"># type: (Union[ParsedVersion, str]) -&gt; LegacyVersion</span>
        <span class="s2">if not </span><span class="s1">isinstance(version</span><span class="s2">, </span><span class="s1">LegacyVersion):</span>
            <span class="s1">version = LegacyVersion(str(version))</span>
        <span class="s2">return </span><span class="s1">version</span>

    <span class="s2">def </span><span class="s1">_compare_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (LegacyVersion, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">prospective == self._coerce_version(spec)</span>

    <span class="s2">def </span><span class="s1">_compare_not_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (LegacyVersion, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">prospective != self._coerce_version(spec)</span>

    <span class="s2">def </span><span class="s1">_compare_less_than_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (LegacyVersion, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">prospective &lt;= self._coerce_version(spec)</span>

    <span class="s2">def </span><span class="s1">_compare_greater_than_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (LegacyVersion, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">prospective &gt;= self._coerce_version(spec)</span>

    <span class="s2">def </span><span class="s1">_compare_less_than(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (LegacyVersion, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">prospective &lt; self._coerce_version(spec)</span>

    <span class="s2">def </span><span class="s1">_compare_greater_than(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (LegacyVersion, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">prospective &gt; self._coerce_version(spec)</span>


<span class="s2">def </span><span class="s1">_require_version_compare(</span>
    <span class="s1">fn  </span><span class="s0"># type: (Callable[[Specifier, ParsedVersion, str], bool])</span>
<span class="s1">):</span>
    <span class="s0"># type: (...) -&gt; Callable[[Specifier, ParsedVersion, str], bool]</span>
    <span class="s1">@functools.wraps(fn)</span>
    <span class="s2">def </span><span class="s1">wrapped(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (Specifier, ParsedVersion, str) -&gt; bool</span>
        <span class="s2">if not </span><span class="s1">isinstance(prospective</span><span class="s2">, </span><span class="s1">Version):</span>
            <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">fn(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec)</span>

    <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s2">class </span><span class="s1">Specifier(_IndividualSpecifier):</span>

    <span class="s1">_regex_str = </span><span class="s4">r&quot;&quot;&quot; 
        (?P&lt;operator&gt;(~=|==|!=|&lt;=|&gt;=|&lt;|&gt;|===)) 
        (?P&lt;version&gt; 
            (?: 
                # The identity operators allow for an escape hatch that will 
                # do an exact string match of the version you wish to install. 
                # This will not be parsed by PEP 440 and we cannot determine 
                # any semantic meaning from it. This operator is discouraged 
                # but included entirely as an escape hatch. 
                (?&lt;====)  # Only match for the identity operator 
                \s* 
                [^\s]*    # We just match everything, except for whitespace 
                          # since we are only testing for strict identity. 
            ) 
            | 
            (?: 
                # The (non)equality operators allow for wild card and local 
                # versions to be specified so we have to define these two 
                # operators separately to enable that. 
                (?&lt;===|!=)            # Only match for equals and not equals 
 
                \s* 
                v? 
                (?:[0-9]+!)?          # epoch 
                [0-9]+(?:\.[0-9]+)*   # release 
                (?:                   # pre release 
                    [-_\.]? 
                    (a|b|c|rc|alpha|beta|pre|preview) 
                    [-_\.]? 
                    [0-9]* 
                )? 
                (?:                   # post release 
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*) 
                )? 
 
                # You cannot use a wild card and a dev or local version 
                # together so group them with a | and make them optional. 
                (?: 
                    (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release 
                    (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local 
                    | 
                    \.\*  # Wild card syntax of .* 
                )? 
            ) 
            | 
            (?: 
                # The compatible operator requires at least two digits in the 
                # release segment. 
                (?&lt;=~=)               # Only match for the compatible operator 
 
                \s* 
                v? 
                (?:[0-9]+!)?          # epoch 
                [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *) 
                (?:                   # pre release 
                    [-_\.]? 
                    (a|b|c|rc|alpha|beta|pre|preview) 
                    [-_\.]? 
                    [0-9]* 
                )? 
                (?:                                   # post release 
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*) 
                )? 
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release 
            ) 
            | 
            (?: 
                # All other operators only allow a sub set of what the 
                # (non)equality operators do. Specifically they do not allow 
                # local versions to be specified nor do they allow the prefix 
                # matching wild cards. 
                (?&lt;!==|!=|~=)         # We have special cases for these 
                                      # operators so we want to make sure they 
                                      # don't match here. 
 
                \s* 
                v? 
                (?:[0-9]+!)?          # epoch 
                [0-9]+(?:\.[0-9]+)*   # release 
                (?:                   # pre release 
                    [-_\.]? 
                    (a|b|c|rc|alpha|beta|pre|preview) 
                    [-_\.]? 
                    [0-9]* 
                )? 
                (?:                                   # post release 
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*) 
                )? 
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release 
            ) 
        ) 
        &quot;&quot;&quot;</span>

    <span class="s1">_regex = re.compile(</span><span class="s4">r&quot;^\s*&quot; </span><span class="s1">+ _regex_str + </span><span class="s4">r&quot;\s*$&quot;</span><span class="s2">, </span><span class="s1">re.VERBOSE | re.IGNORECASE)</span>

    <span class="s1">_operators = {</span>
        <span class="s4">&quot;~=&quot;</span><span class="s1">: </span><span class="s4">&quot;compatible&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;==&quot;</span><span class="s1">: </span><span class="s4">&quot;equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;!=&quot;</span><span class="s1">: </span><span class="s4">&quot;not_equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&lt;=&quot;</span><span class="s1">: </span><span class="s4">&quot;less_than_equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&gt;=&quot;</span><span class="s1">: </span><span class="s4">&quot;greater_than_equal&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&lt;&quot;</span><span class="s1">: </span><span class="s4">&quot;less_than&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;&gt;&quot;</span><span class="s1">: </span><span class="s4">&quot;greater_than&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;===&quot;</span><span class="s1">: </span><span class="s4">&quot;arbitrary&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_compatible(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>

        <span class="s0"># Compatible releases have an equivalent combination of &gt;= and ==. That</span>
        <span class="s0"># is that ~=2.2 is equivalent to &gt;=2.2,==2.*. This allows us to</span>
        <span class="s0"># implement this in terms of the other specifiers instead of</span>
        <span class="s0"># implementing it ourselves. The only thing we need to do is construct</span>
        <span class="s0"># the other specifiers.</span>

        <span class="s0"># We want everything but the last item in the version, but we want to</span>
        <span class="s0"># ignore post and dev releases and we want to treat the pre-release as</span>
        <span class="s0"># it's own separate segment.</span>
        <span class="s1">prefix = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(</span>
            <span class="s1">list(</span>
                <span class="s1">itertools.takewhile(</span>
                    <span class="s2">lambda </span><span class="s1">x: (</span><span class="s2">not </span><span class="s1">x.startswith(</span><span class="s4">&quot;post&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">x.startswith(</span><span class="s4">&quot;dev&quot;</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">_version_split(spec)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s0"># Add the prefix notation to the end of our string</span>
        <span class="s1">prefix += </span><span class="s4">&quot;.*&quot;</span>

        <span class="s2">return </span><span class="s1">self._get_operator(</span><span class="s4">&quot;&gt;=&quot;</span><span class="s1">)(prospective</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">and </span><span class="s1">self._get_operator(</span><span class="s4">&quot;==&quot;</span><span class="s1">)(</span>
            <span class="s1">prospective</span><span class="s2">, </span><span class="s1">prefix</span>
        <span class="s1">)</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>

        <span class="s0"># We need special logic to handle prefix matching</span>
        <span class="s2">if </span><span class="s1">spec.endswith(</span><span class="s4">&quot;.*&quot;</span><span class="s1">):</span>
            <span class="s0"># In the case of prefix matching we want to ignore local segment.</span>
            <span class="s1">prospective = Version(prospective.public)</span>
            <span class="s0"># Split the spec out by dots, and pretend that there is an implicit</span>
            <span class="s0"># dot in between a release segment and a pre-release segment.</span>
            <span class="s1">split_spec = _version_split(spec[:-</span><span class="s5">2</span><span class="s1">])  </span><span class="s0"># Remove the trailing .*</span>

            <span class="s0"># Split the prospective version out by dots, and pretend that there</span>
            <span class="s0"># is an implicit dot in between a release segment and a pre-release</span>
            <span class="s0"># segment.</span>
            <span class="s1">split_prospective = _version_split(str(prospective))</span>

            <span class="s0"># Shorten the prospective version to be the same length as the spec</span>
            <span class="s0"># so that we can determine if the specifier is a prefix of the</span>
            <span class="s0"># prospective version or not.</span>
            <span class="s1">shortened_prospective = split_prospective[: len(split_spec)]</span>

            <span class="s0"># Pad out our two sides with zeros so that they both equal the same</span>
            <span class="s0"># length.</span>
            <span class="s1">padded_spec</span><span class="s2">, </span><span class="s1">padded_prospective = _pad_version(</span>
                <span class="s1">split_spec</span><span class="s2">, </span><span class="s1">shortened_prospective</span>
            <span class="s1">)</span>

            <span class="s2">return </span><span class="s1">padded_prospective == padded_spec</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Convert our spec string into a Version</span>
            <span class="s1">spec_version = Version(spec)</span>

            <span class="s0"># If the specifier does not have a local segment, then we want to</span>
            <span class="s0"># act as if the prospective version also does not have a local</span>
            <span class="s0"># segment.</span>
            <span class="s2">if not </span><span class="s1">spec_version.local:</span>
                <span class="s1">prospective = Version(prospective.public)</span>

            <span class="s2">return </span><span class="s1">prospective == spec_version</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_not_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>
        <span class="s2">return not </span><span class="s1">self._compare_equal(prospective</span><span class="s2">, </span><span class="s1">spec)</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_less_than_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>

        <span class="s0"># NB: Local version identifiers are NOT permitted in the version</span>
        <span class="s0"># specifier, so local version labels can be universally removed from</span>
        <span class="s0"># the prospective version.</span>
        <span class="s2">return </span><span class="s1">Version(prospective.public) &lt;= Version(spec)</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_greater_than_equal(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>

        <span class="s0"># NB: Local version identifiers are NOT permitted in the version</span>
        <span class="s0"># specifier, so local version labels can be universally removed from</span>
        <span class="s0"># the prospective version.</span>
        <span class="s2">return </span><span class="s1">Version(prospective.public) &gt;= Version(spec)</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_less_than(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec_str):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>

        <span class="s0"># Convert our spec to a Version instance, since we'll want to work with</span>
        <span class="s0"># it as a version.</span>
        <span class="s1">spec = Version(spec_str)</span>

        <span class="s0"># Check to see if the prospective version is less than the spec</span>
        <span class="s0"># version. If it's not we can short circuit and just return False now</span>
        <span class="s0"># instead of doing extra unneeded work.</span>
        <span class="s2">if not </span><span class="s1">prospective &lt; spec:</span>
            <span class="s2">return False</span>

        <span class="s0"># This special case is here so that, unless the specifier itself</span>
        <span class="s0"># includes is a pre-release version, that we do not accept pre-release</span>
        <span class="s0"># versions for the version mentioned in the specifier (e.g. &lt;3.1 should</span>
        <span class="s0"># not match 3.1.dev0, but should match 3.0.dev0).</span>
        <span class="s2">if not </span><span class="s1">spec.is_prerelease </span><span class="s2">and </span><span class="s1">prospective.is_prerelease:</span>
            <span class="s2">if </span><span class="s1">Version(prospective.base_version) == Version(spec.base_version):</span>
                <span class="s2">return False</span>

        <span class="s0"># If we've gotten to here, it means that prospective version is both</span>
        <span class="s0"># less than the spec version *and* it's not a pre-release of the same</span>
        <span class="s0"># version in the spec.</span>
        <span class="s2">return True</span>

    <span class="s1">@_require_version_compare</span>
    <span class="s2">def </span><span class="s1">_compare_greater_than(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec_str):</span>
        <span class="s0"># type: (ParsedVersion, str) -&gt; bool</span>

        <span class="s0"># Convert our spec to a Version instance, since we'll want to work with</span>
        <span class="s0"># it as a version.</span>
        <span class="s1">spec = Version(spec_str)</span>

        <span class="s0"># Check to see if the prospective version is greater than the spec</span>
        <span class="s0"># version. If it's not we can short circuit and just return False now</span>
        <span class="s0"># instead of doing extra unneeded work.</span>
        <span class="s2">if not </span><span class="s1">prospective &gt; spec:</span>
            <span class="s2">return False</span>

        <span class="s0"># This special case is here so that, unless the specifier itself</span>
        <span class="s0"># includes is a post-release version, that we do not accept</span>
        <span class="s0"># post-release versions for the version mentioned in the specifier</span>
        <span class="s0"># (e.g. &gt;3.1 should not match 3.0.post0, but should match 3.2.post0).</span>
        <span class="s2">if not </span><span class="s1">spec.is_postrelease </span><span class="s2">and </span><span class="s1">prospective.is_postrelease:</span>
            <span class="s2">if </span><span class="s1">Version(prospective.base_version) == Version(spec.base_version):</span>
                <span class="s2">return False</span>

        <span class="s0"># Ensure that we do not allow a local version of the version mentioned</span>
        <span class="s0"># in the specifier, which is technically greater than, to match.</span>
        <span class="s2">if </span><span class="s1">prospective.local </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">Version(prospective.base_version) == Version(spec.base_version):</span>
                <span class="s2">return False</span>

        <span class="s0"># If we've gotten to here, it means that prospective version is both</span>
        <span class="s0"># greater than the spec version *and* it's not a pre-release of the</span>
        <span class="s0"># same version in the spec.</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_compare_arbitrary(self</span><span class="s2">, </span><span class="s1">prospective</span><span class="s2">, </span><span class="s1">spec):</span>
        <span class="s0"># type: (Version, str) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">str(prospective).lower() == str(spec).lower()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">prereleases(self):</span>
        <span class="s0"># type: () -&gt; bool</span>

        <span class="s0"># If there is an explicit prereleases set for this, then we'll just</span>
        <span class="s0"># blindly use that.</span>
        <span class="s2">if </span><span class="s1">self._prereleases </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._prereleases</span>

        <span class="s0"># Look at all of our specifiers and determine if they are inclusive</span>
        <span class="s0"># operators, and if they are if they are including an explicit</span>
        <span class="s0"># prerelease.</span>
        <span class="s1">operator</span><span class="s2">, </span><span class="s1">version = self._spec</span>
        <span class="s2">if </span><span class="s1">operator </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;==&quot;</span><span class="s2">, </span><span class="s4">&quot;&gt;=&quot;</span><span class="s2">, </span><span class="s4">&quot;&lt;=&quot;</span><span class="s2">, </span><span class="s4">&quot;~=&quot;</span><span class="s2">, </span><span class="s4">&quot;===&quot;</span><span class="s1">]:</span>
            <span class="s0"># The == specifier can include a trailing .*, if it does we</span>
            <span class="s0"># want to remove before parsing.</span>
            <span class="s2">if </span><span class="s1">operator == </span><span class="s4">&quot;==&quot; </span><span class="s2">and </span><span class="s1">version.endswith(</span><span class="s4">&quot;.*&quot;</span><span class="s1">):</span>
                <span class="s1">version = version[:-</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s0"># Parse the version, and if it is a pre-release than this</span>
            <span class="s0"># specifier allows pre-releases.</span>
            <span class="s2">if </span><span class="s1">parse(version).is_prerelease:</span>
                <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s1">@prereleases.setter</span>
    <span class="s2">def </span><span class="s1">prereleases(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0"># type: (bool) -&gt; None</span>
        <span class="s1">self._prereleases = value</span>


<span class="s1">_prefix_regex = re.compile(</span><span class="s4">r&quot;^([0-9]+)((?:a|b|c|rc)[0-9]+)$&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_version_split(version):</span>
    <span class="s0"># type: (str) -&gt; List[str]</span>
    <span class="s1">result = []  </span><span class="s0"># type: List[str]</span>
    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">version.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">):</span>
        <span class="s1">match = _prefix_regex.search(item)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">result.extend(match.groups())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result.append(item)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_pad_version(left</span><span class="s2">, </span><span class="s1">right):</span>
    <span class="s0"># type: (List[str], List[str]) -&gt; Tuple[List[str], List[str]]</span>
    <span class="s1">left_split</span><span class="s2">, </span><span class="s1">right_split = []</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s0"># Get the release segment of our versions</span>
    <span class="s1">left_split.append(list(itertools.takewhile(</span><span class="s2">lambda </span><span class="s1">x: x.isdigit()</span><span class="s2">, </span><span class="s1">left)))</span>
    <span class="s1">right_split.append(list(itertools.takewhile(</span><span class="s2">lambda </span><span class="s1">x: x.isdigit()</span><span class="s2">, </span><span class="s1">right)))</span>

    <span class="s0"># Get the rest of our versions</span>
    <span class="s1">left_split.append(left[len(left_split[</span><span class="s5">0</span><span class="s1">]) :])</span>
    <span class="s1">right_split.append(right[len(right_split[</span><span class="s5">0</span><span class="s1">]) :])</span>

    <span class="s0"># Insert our padding</span>
    <span class="s1">left_split.insert(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;0&quot;</span><span class="s1">] * max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(right_split[</span><span class="s5">0</span><span class="s1">]) - len(left_split[</span><span class="s5">0</span><span class="s1">])))</span>
    <span class="s1">right_split.insert(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;0&quot;</span><span class="s1">] * max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(left_split[</span><span class="s5">0</span><span class="s1">]) - len(right_split[</span><span class="s5">0</span><span class="s1">])))</span>

    <span class="s2">return </span><span class="s1">(list(itertools.chain(*left_split))</span><span class="s2">, </span><span class="s1">list(itertools.chain(*right_split)))</span>


<span class="s2">class </span><span class="s1">SpecifierSet(BaseSpecifier):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">specifiers=</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (str, Optional[bool]) -&gt; None</span>

        <span class="s0"># Split on , to break each individual specifier into it's own item, and</span>
        <span class="s0"># strip each item to remove leading/trailing whitespace.</span>
        <span class="s1">split_specifiers = [s.strip() </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">specifiers.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">) </span><span class="s2">if </span><span class="s1">s.strip()]</span>

        <span class="s0"># Parsed each individual specifier, attempting first to make it a</span>
        <span class="s0"># Specifier and falling back to a LegacySpecifier.</span>
        <span class="s1">parsed = set()</span>
        <span class="s2">for </span><span class="s1">specifier </span><span class="s2">in </span><span class="s1">split_specifiers:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">parsed.add(Specifier(specifier))</span>
            <span class="s2">except </span><span class="s1">InvalidSpecifier:</span>
                <span class="s1">parsed.add(LegacySpecifier(specifier))</span>

        <span class="s0"># Turn our parsed specifiers into a frozen set and save them for later.</span>
        <span class="s1">self._specs = frozenset(parsed)</span>

        <span class="s0"># Store our prereleases value so we can use it later to determine if</span>
        <span class="s0"># we accept prereleases or not.</span>
        <span class="s1">self._prereleases = prereleases</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s1">pre = (</span>
            <span class="s4">&quot;, prereleases={0!r}&quot;</span><span class="s1">.format(self.prereleases)</span>
            <span class="s2">if </span><span class="s1">self._prereleases </span><span class="s2">is not None</span>
            <span class="s2">else </span><span class="s4">&quot;&quot;</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s4">&quot;&lt;SpecifierSet({0!r}{1})&gt;&quot;</span><span class="s1">.format(str(self)</span><span class="s2">, </span><span class="s1">pre)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0"># type: () -&gt; str</span>
        <span class="s2">return </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(sorted(str(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self._specs))</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s0"># type: () -&gt; int</span>
        <span class="s2">return </span><span class="s1">hash(self._specs)</span>

    <span class="s2">def </span><span class="s1">__and__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (Union[SpecifierSet, str]) -&gt; SpecifierSet</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">string_types):</span>
            <span class="s1">other = SpecifierSet(other)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SpecifierSet):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s1">specifier = SpecifierSet()</span>
        <span class="s1">specifier._specs = frozenset(self._specs | other._specs)</span>

        <span class="s2">if </span><span class="s1">self._prereleases </span><span class="s2">is None and </span><span class="s1">other._prereleases </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">specifier._prereleases = other._prereleases</span>
        <span class="s2">elif </span><span class="s1">self._prereleases </span><span class="s2">is not None and </span><span class="s1">other._prereleases </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">specifier._prereleases = self._prereleases</span>
        <span class="s2">elif </span><span class="s1">self._prereleases == other._prereleases:</span>
            <span class="s1">specifier._prereleases = self._prereleases</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Cannot combine SpecifierSets with True and False prerelease &quot;</span>
                <span class="s4">&quot;overrides.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">specifier</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (object) -&gt; bool</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">(string_types</span><span class="s2">, </span><span class="s1">_IndividualSpecifier)):</span>
            <span class="s1">other = SpecifierSet(str(other))</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SpecifierSet):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._specs == other._specs</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># type: (object) -&gt; bool</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">(string_types</span><span class="s2">, </span><span class="s1">_IndividualSpecifier)):</span>
            <span class="s1">other = SpecifierSet(str(other))</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SpecifierSet):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._specs != other._specs</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s0"># type: () -&gt; int</span>
        <span class="s2">return </span><span class="s1">len(self._specs)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s0"># type: () -&gt; Iterator[FrozenSet[_IndividualSpecifier]]</span>
        <span class="s2">return </span><span class="s1">iter(self._specs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">prereleases(self):</span>
        <span class="s0"># type: () -&gt; Optional[bool]</span>

        <span class="s0"># If we have been given an explicit prerelease modifier, then we'll</span>
        <span class="s0"># pass that through here.</span>
        <span class="s2">if </span><span class="s1">self._prereleases </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._prereleases</span>

        <span class="s0"># If we don't have any specifiers, and we don't have a forced value,</span>
        <span class="s0"># then we'll just return None since we don't know if this should have</span>
        <span class="s0"># pre-releases or not.</span>
        <span class="s2">if not </span><span class="s1">self._specs:</span>
            <span class="s2">return None</span>

        <span class="s0"># Otherwise we'll see if any of the given specifiers accept</span>
        <span class="s0"># prereleases, if any of them do we'll return True, otherwise False.</span>
        <span class="s2">return </span><span class="s1">any(s.prereleases </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self._specs)</span>

    <span class="s1">@prereleases.setter</span>
    <span class="s2">def </span><span class="s1">prereleases(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0"># type: (bool) -&gt; None</span>
        <span class="s1">self._prereleases = value</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s0"># type: (Union[ParsedVersion, str]) -&gt; bool</span>
        <span class="s2">return </span><span class="s1">self.contains(item)</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">prereleases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type: (Union[ParsedVersion, str], Optional[bool]) -&gt; bool</span>

        <span class="s0"># Ensure that our item is a Version or LegacyVersion instance.</span>
        <span class="s2">if not </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">(LegacyVersion</span><span class="s2">, </span><span class="s1">Version)):</span>
            <span class="s1">item = parse(item)</span>

        <span class="s0"># Determine if we're forcing a prerelease or not, if we're not forcing</span>
        <span class="s0"># one for this particular filter call, then we'll use whatever the</span>
        <span class="s0"># SpecifierSet thinks for whether or not we should support prereleases.</span>
        <span class="s2">if </span><span class="s1">prereleases </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prereleases = self.prereleases</span>

        <span class="s0"># We can determine if we're going to allow pre-releases by looking to</span>
        <span class="s0"># see if any of the underlying items supports them. If none of them do</span>
        <span class="s0"># and this item is a pre-release then we do not allow it and we can</span>
        <span class="s0"># short circuit that here.</span>
        <span class="s0"># Note: This means that 1.0.dev1 would not be contained in something</span>
        <span class="s0">#       like &gt;=1.0.devabc however it would be in &gt;=1.0.debabc,&gt;0.0.dev0</span>
        <span class="s2">if not </span><span class="s1">prereleases </span><span class="s2">and </span><span class="s1">item.is_prerelease:</span>
            <span class="s2">return False</span>

        <span class="s0"># We simply dispatch to the underlying specs here to make sure that the</span>
        <span class="s0"># given version is contained within all of them.</span>
        <span class="s0"># Note: This use of all() here means that an empty set of specifiers</span>
        <span class="s0">#       will always return True, this is an explicit design decision.</span>
        <span class="s2">return </span><span class="s1">all(s.contains(item</span><span class="s2">, </span><span class="s1">prereleases=prereleases) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self._specs)</span>

    <span class="s2">def </span><span class="s1">filter(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">iterable</span><span class="s2">,  </span><span class="s0"># type: Iterable[Union[ParsedVersion, str]]</span>
        <span class="s1">prereleases=</span><span class="s2">None,  </span><span class="s0"># type: Optional[bool]</span>
    <span class="s1">):</span>
        <span class="s0"># type: (...) -&gt; Iterable[Union[ParsedVersion, str]]</span>

        <span class="s0"># Determine if we're forcing a prerelease or not, if we're not forcing</span>
        <span class="s0"># one for this particular filter call, then we'll use whatever the</span>
        <span class="s0"># SpecifierSet thinks for whether or not we should support prereleases.</span>
        <span class="s2">if </span><span class="s1">prereleases </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prereleases = self.prereleases</span>

        <span class="s0"># If we have any specifiers, then we want to wrap our iterable in the</span>
        <span class="s0"># filter method for each one, this will act as a logical AND amongst</span>
        <span class="s0"># each specifier.</span>
        <span class="s2">if </span><span class="s1">self._specs:</span>
            <span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">self._specs:</span>
                <span class="s1">iterable = spec.filter(iterable</span><span class="s2">, </span><span class="s1">prereleases=bool(prereleases))</span>
            <span class="s2">return </span><span class="s1">iterable</span>
        <span class="s0"># If we do not have any specifiers, then we need to have a rough filter</span>
        <span class="s0"># which will filter out any pre-releases, unless there are no final</span>
        <span class="s0"># releases, and which will filter out LegacyVersion in general.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">filtered = []  </span><span class="s0"># type: List[Union[ParsedVersion, str]]</span>
            <span class="s1">found_prereleases = []  </span><span class="s0"># type: List[Union[ParsedVersion, str]]</span>

            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">iterable:</span>
                <span class="s0"># Ensure that we some kind of Version class for this item.</span>
                <span class="s2">if not </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">(LegacyVersion</span><span class="s2">, </span><span class="s1">Version)):</span>
                    <span class="s1">parsed_version = parse(item)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">parsed_version = item</span>

                <span class="s0"># Filter out any item which is parsed as a LegacyVersion</span>
                <span class="s2">if </span><span class="s1">isinstance(parsed_version</span><span class="s2">, </span><span class="s1">LegacyVersion):</span>
                    <span class="s2">continue</span>

                <span class="s0"># Store any item which is a pre-release for later unless we've</span>
                <span class="s0"># already found a final version or we are accepting prereleases</span>
                <span class="s2">if </span><span class="s1">parsed_version.is_prerelease </span><span class="s2">and not </span><span class="s1">prereleases:</span>
                    <span class="s2">if not </span><span class="s1">filtered:</span>
                        <span class="s1">found_prereleases.append(item)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">filtered.append(item)</span>

            <span class="s0"># If we've found no items except for pre-releases, then we'll go</span>
            <span class="s0"># ahead and use the pre-releases</span>
            <span class="s2">if not </span><span class="s1">filtered </span><span class="s2">and </span><span class="s1">found_prereleases </span><span class="s2">and </span><span class="s1">prereleases </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">found_prereleases</span>

            <span class="s2">return </span><span class="s1">filtered</span>
</pre>
</body>
</html>