<html>
<head>
<title>multiarray_api.txt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
multiarray_api.txt</font>
</center></td></tr></table>
<pre>
<span class="s0">===========</span>
<span class="s0">NumPy C-API</span>
<span class="s0">===========</span>
<span class="s0">::</span>

  <span class="s0">unsigned int</span>
  <span class="s0">PyArray_GetNDArrayCVersion(void )</span>


<span class="s0">Included at the very first so not auto-grabbed and thus not labeled.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SetNumericOps(PyObject *dict)</span>

<span class="s0">Set internal structure with number functions that all arrays will use</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_GetNumericOps(void )</span>

<span class="s0">Get dictionary showing number functions that all arrays will use</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_INCREF(PyArrayObject *mp)</span>

<span class="s0">For object arrays, increment all internal references.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_XDECREF(PyArrayObject *mp)</span>

<span class="s0">Decrement all internal references for object arrays.</span>
<span class="s0">(or arrays with object fields)</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_SetStringFunction(PyObject *op, int repr)</span>

<span class="s0">Set the array print function to be a Python function.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrFromType(int type)</span>

<span class="s0">Get the PyArray_Descr structure for a type.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_TypeObjectFromType(int type)</span>

<span class="s0">Get a typeobject from a type-number -- can return NULL.</span>

<span class="s0">New reference</span>

<span class="s0">::</span>

  <span class="s0">char *</span>
  <span class="s0">PyArray_Zero(PyArrayObject *arr)</span>

<span class="s0">Get pointer to zero of correct type for array.</span>

<span class="s0">::</span>

  <span class="s0">char *</span>
  <span class="s0">PyArray_One(PyArrayObject *arr)</span>

<span class="s0">Get pointer to one of correct type for array</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_CastToType(PyArrayObject *arr, PyArray_Descr *dtype, int</span>
                     <span class="s0">is_f_order)</span>

<span class="s0">For backward compatibility</span>

<span class="s0">Cast an array using typecode structure.</span>
<span class="s0">steals reference to dtype --- cannot be NULL</span>

<span class="s0">This function always makes a copy of arr, even if the dtype</span>
<span class="s0">doesn't change.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CastTo(PyArrayObject *out, PyArrayObject *mp)</span>

<span class="s0">Cast to an already created array.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CastAnyTo(PyArrayObject *out, PyArrayObject *mp)</span>

<span class="s0">Cast to an already created array.  Arrays don't have to be &quot;broadcastable&quot;</span>
<span class="s0">Only requirement is they have the same number of elements.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CanCastSafely(int fromtype, int totype)</span>

<span class="s0">Check the type coercion rules.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">PyArray_CanCastTo(PyArray_Descr *from, PyArray_Descr *to)</span>

<span class="s0">leaves reference count alone --- cannot be NULL</span>

<span class="s0">PyArray_CanCastTypeTo is equivalent to this, but adds a 'casting'</span>
<span class="s0">parameter.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ObjectType(PyObject *op, int minimum_type)</span>

<span class="s0">Return the typecode of the array a Python object would be converted to</span>

<span class="s0">Returns the type number the result should have, or NPY_NOTYPE on error.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrFromObject(PyObject *op, PyArray_Descr *mintype)</span>

<span class="s0">new reference -- accepts NULL for mintype</span>

<span class="s0">::</span>

  <span class="s0">PyArrayObject **</span>
  <span class="s0">PyArray_ConvertToCommonType(PyObject *op, int *retn)</span>


<span class="s0">This function is only used in one place within NumPy and should</span>
<span class="s0">generally be avoided. It is provided mainly for backward compatibility.</span>

<span class="s0">The user of the function has to free the returned array with PyDataMem_FREE.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrFromScalar(PyObject *sc)</span>

<span class="s0">Return descr object from array scalar.</span>

<span class="s0">New reference</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrFromTypeObject(PyObject *type)</span>


<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">PyArray_Size(PyObject *op)</span>

<span class="s0">Compute the size of an array (in number of items)</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Scalar(void *data, PyArray_Descr *descr, PyObject *base)</span>

<span class="s0">Get scalar-equivalent to a region of memory described by a descriptor.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromScalar(PyObject *scalar, PyArray_Descr *outcode)</span>

<span class="s0">Get 0-dim array from scalar</span>

<span class="s0">0-dim array from array-scalar object</span>
<span class="s0">always contains a copy of the data</span>
<span class="s0">unless outcode is NULL, it is of void type and the referrer does</span>
<span class="s0">not own it either.</span>

<span class="s0">steals reference to outcode</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_ScalarAsCtype(PyObject *scalar, void *ctypeptr)</span>

<span class="s0">Convert to c-type</span>

<span class="s0">no error checking is performed -- ctypeptr must be same type as scalar</span>
<span class="s0">in case of flexible type, the data is not copied</span>
<span class="s0">into ctypeptr which is expected to be a pointer to pointer</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CastScalarToCtype(PyObject *scalar, void</span>
                            <span class="s0">*ctypeptr, PyArray_Descr *outcode)</span>

<span class="s0">Cast Scalar to c-type</span>

<span class="s0">The output buffer must be large-enough to receive the value</span>
<span class="s0">Even for flexible types which is different from ScalarAsCtype</span>
<span class="s0">where only a reference for flexible types is returned</span>

<span class="s0">This may not work right on narrow builds for NumPy unicode scalars.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CastScalarDirect(PyObject *scalar, PyArray_Descr</span>
                           <span class="s0">*indescr, void *ctypeptr, int outtype)</span>

<span class="s0">Cast Scalar to c-type</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ScalarFromObject(PyObject *object)</span>

<span class="s0">Get an Array Scalar From a Python Object</span>

<span class="s0">Returns NULL if unsuccessful but error is only set if another error occurred.</span>
<span class="s0">Currently only Numeric-like object supported.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_VectorUnaryFunc *</span>
  <span class="s0">PyArray_GetCastFunc(PyArray_Descr *descr, int type_num)</span>

<span class="s0">Get a cast function to cast from the input descriptor to the</span>
<span class="s0">output type_number (must be a registered data-type).</span>
<span class="s0">Returns NULL if un-successful.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromDims(int NPY_UNUSED(nd) , int *NPY_UNUSED(d) , int</span>
                   <span class="s0">NPY_UNUSED(type) )</span>

<span class="s0">Deprecated, use PyArray_SimpleNew instead.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromDimsAndDataAndDescr(int NPY_UNUSED(nd) , int</span>
                                  <span class="s0">*NPY_UNUSED(d) , PyArray_Descr</span>
                                  <span class="s0">*descr, char *NPY_UNUSED(data) )</span>

<span class="s0">Deprecated, use PyArray_NewFromDescr instead.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromAny(PyObject *op, PyArray_Descr *newtype, int</span>
                  <span class="s0">min_depth, int max_depth, int flags, PyObject</span>
                  <span class="s0">*context)</span>

<span class="s0">Does not check for NPY_ARRAY_ENSURECOPY and NPY_ARRAY_NOTSWAPPED in flags</span>
<span class="s0">Steals a reference to newtype --- which can be NULL</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_EnsureArray(PyObject *op)</span>

<span class="s0">This is a quick wrapper around</span>
<span class="s0">PyArray_FromAny(op, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)</span>
<span class="s0">that special cases Arrays and PyArray_Scalars up front</span>
<span class="s0">It *steals a reference* to the object</span>
<span class="s0">It also guarantees that the result is PyArray_Type</span>
<span class="s0">Because it decrefs op if any conversion needs to take place</span>
<span class="s0">so it can be used like PyArray_EnsureArray(some_function(...))</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_EnsureAnyArray(PyObject *op)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromFile(FILE *fp, PyArray_Descr *dtype, npy_intp num, char</span>
                   <span class="s0">*sep)</span>


<span class="s0">Given a ``FILE *`` pointer ``fp``, and a ``PyArray_Descr``, return an</span>
<span class="s0">array corresponding to the data encoded in that file.</span>

<span class="s0">The reference to `dtype` is stolen (it is possible that the passed in</span>
<span class="s0">dtype is not held on to).</span>

<span class="s0">The number of elements to read is given as ``num``; if it is &lt; 0, then</span>
<span class="s0">then as many as possible are read.</span>

<span class="s0">If ``sep`` is NULL or empty, then binary data is assumed, else</span>
<span class="s0">text data, with ``sep`` as the separator between elements. Whitespace in</span>
<span class="s0">the separator matches any length of whitespace in the text, and a match</span>
<span class="s0">for whitespace around the separator is added.</span>

<span class="s0">For memory-mapped files, use the buffer interface. No more data than</span>
<span class="s0">necessary is read by this routine.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromString(char *data, npy_intp slen, PyArray_Descr</span>
                     <span class="s0">*dtype, npy_intp num, char *sep)</span>


<span class="s0">Given a pointer to a string ``data``, a string length ``slen``, and</span>
<span class="s0">a ``PyArray_Descr``, return an array corresponding to the data</span>
<span class="s0">encoded in that string.</span>

<span class="s0">If the dtype is NULL, the default array type is used (double).</span>
<span class="s0">If non-null, the reference is stolen.</span>

<span class="s0">If ``slen`` is &lt; 0, then the end of string is used for text data.</span>
<span class="s0">It is an error for ``slen`` to be &lt; 0 for binary data (since embedded NULLs</span>
<span class="s0">would be the norm).</span>

<span class="s0">The number of elements to read is given as ``num``; if it is &lt; 0, then</span>
<span class="s0">then as many as possible are read.</span>

<span class="s0">If ``sep`` is NULL or empty, then binary data is assumed, else</span>
<span class="s0">text data, with ``sep`` as the separator between elements. Whitespace in</span>
<span class="s0">the separator matches any length of whitespace in the text, and a match</span>
<span class="s0">for whitespace around the separator is added.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromBuffer(PyObject *buf, PyArray_Descr *type, npy_intp</span>
                     <span class="s0">count, npy_intp offset)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromIter(PyObject *obj, PyArray_Descr *dtype, npy_intp count)</span>


<span class="s0">steals a reference to dtype (which cannot be NULL)</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Return(PyArrayObject *mp)</span>


<span class="s0">Return either an array or the appropriate Python object if the array</span>
<span class="s0">is 0d and matches a Python type.</span>
<span class="s0">steals reference to mp</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_GetField(PyArrayObject *self, PyArray_Descr *typed, int</span>
                   <span class="s0">offset)</span>

<span class="s0">Get a subset of bytes from each element of the array</span>
<span class="s0">steals reference to typed, must not be NULL</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SetField(PyArrayObject *self, PyArray_Descr *dtype, int</span>
                   <span class="s0">offset, PyObject *val)</span>

<span class="s0">Set a subset of bytes from each element of the array</span>
<span class="s0">steals reference to dtype, must not be NULL</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Byteswap(PyArrayObject *self, npy_bool inplace)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Resize(PyArrayObject *self, PyArray_Dims *newshape, int</span>
                 <span class="s0">refcheck, NPY_ORDER NPY_UNUSED(order) )</span>

<span class="s0">Resize (reallocate data).  Only works if nothing else is referencing this</span>
<span class="s0">array and it is contiguous.  If refcheck is 0, then the reference count is</span>
<span class="s0">not checked and assumed to be 1.  You still must own this data and have no</span>
<span class="s0">weak-references and no base object.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_MoveInto(PyArrayObject *dst, PyArrayObject *src)</span>

<span class="s0">Move the memory of one array into another, allowing for overlapping data.</span>

<span class="s0">Returns 0 on success, negative on failure.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CopyInto(PyArrayObject *dst, PyArrayObject *src)</span>

<span class="s0">Copy an Array into another array.</span>
<span class="s0">Broadcast to the destination shape if necessary.</span>

<span class="s0">Returns 0 on success, -1 on failure.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CopyAnyInto(PyArrayObject *dst, PyArrayObject *src)</span>

<span class="s0">Copy an Array into another array -- memory must not overlap</span>
<span class="s0">Does not require src and dest to have &quot;broadcastable&quot; shapes</span>
<span class="s0">(only the same number of elements).</span>

<span class="s0">TODO: For NumPy 2.0, this could accept an order parameter which</span>
<span class="s0">only allows NPY_CORDER and NPY_FORDER.  Could also rename</span>
<span class="s0">this to CopyAsFlat to make the name more intuitive.</span>

<span class="s0">Returns 0 on success, -1 on error.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CopyObject(PyArrayObject *dest, PyObject *src_object)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_NewCopy(PyArrayObject *obj, NPY_ORDER order)</span>

<span class="s0">Copy an array.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ToList(PyArrayObject *self)</span>

<span class="s0">To List</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ToString(PyArrayObject *self, NPY_ORDER order)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ToFile(PyArrayObject *self, FILE *fp, char *sep, char *format)</span>

<span class="s0">To File</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_Dump(PyObject *self, PyObject *file, int protocol)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Dumps(PyObject *self, int protocol)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ValidType(int type)</span>

<span class="s0">Is the typenum valid?</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_UpdateFlags(PyArrayObject *ret, int flagmask)</span>

<span class="s0">Update Several Flags at once.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_New(PyTypeObject *subtype, int nd, npy_intp const *dims, int</span>
              <span class="s0">type_num, npy_intp const *strides, void *data, int</span>
              <span class="s0">itemsize, int flags, PyObject *obj)</span>

<span class="s0">Generic new array creation routine.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_NewFromDescr(PyTypeObject *subtype, PyArray_Descr *descr, int</span>
                       <span class="s0">nd, npy_intp const *dims, npy_intp const</span>
                       <span class="s0">*strides, void *data, int flags, PyObject *obj)</span>

<span class="s0">Generic new array creation routine.</span>

<span class="s0">steals a reference to descr. On failure or when dtype-&gt;subarray is</span>
<span class="s0">true, dtype will be decrefed.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrNew(PyArray_Descr *base)</span>

<span class="s0">base cannot be NULL</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrNewFromType(int type_num)</span>


<span class="s0">::</span>

  <span class="s0">double</span>
  <span class="s0">PyArray_GetPriority(PyObject *obj, double default_)</span>

<span class="s0">Get Priority from object</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_IterNew(PyObject *obj)</span>

<span class="s0">Get Iterator.</span>

<span class="s0">::</span>

  <span class="s0">PyObject*</span>
  <span class="s0">PyArray_MultiIterNew(int n, ... )</span>

<span class="s0">Get MultiIterator,</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_PyIntAsInt(PyObject *o)</span>


<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">PyArray_PyIntAsIntp(PyObject *o)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_Broadcast(PyArrayMultiIterObject *mit)</span>


<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_FillObjectArray(PyArrayObject *arr, PyObject *obj)</span>

<span class="s0">Assumes contiguous</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_FillWithScalar(PyArrayObject *arr, PyObject *obj)</span>


<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">PyArray_CheckStrides(int elsize, int nd, npy_intp numbytes, npy_intp</span>
                       <span class="s0">offset, npy_intp const *dims, npy_intp const</span>
                       <span class="s0">*newstrides)</span>


<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_DescrNewByteorder(PyArray_Descr *self, char newendian)</span>


<span class="s0">returns a copy of the PyArray_Descr structure with the byteorder</span>
<span class="s0">altered:</span>
<span class="s0">no arguments:  The byteorder is swapped (in all subfields as well)</span>
<span class="s0">single argument:  The byteorder is forced to the given state</span>
<span class="s0">(in all subfields as well)</span>

<span class="s0">Valid states:  ('big', '&gt;') or ('little' or '&lt;')</span>
<span class="s0">('native', or '=')</span>

<span class="s0">If a descr structure with | is encountered it's own</span>
<span class="s0">byte-order is not changed but any fields are:</span>


<span class="s0">Deep bytorder change of a data-type descriptor</span>
<span class="s0">Leaves reference count of self unchanged --- does not DECREF self ***</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_IterAllButAxis(PyObject *obj, int *inaxis)</span>

<span class="s0">Get Iterator that iterates over all but one axis (don't use this with</span>
<span class="s0">PyArray_ITER_GOTO1D).  The axis will be over-written if negative</span>
<span class="s0">with the axis having the smallest stride.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_CheckFromAny(PyObject *op, PyArray_Descr *descr, int</span>
                       <span class="s0">min_depth, int max_depth, int requires, PyObject</span>
                       <span class="s0">*context)</span>

<span class="s0">steals a reference to descr -- accepts NULL</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromArray(PyArrayObject *arr, PyArray_Descr *newtype, int</span>
                    <span class="s0">flags)</span>

<span class="s0">steals reference to newtype --- acc. NULL</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromInterface(PyObject *origin)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromStructInterface(PyObject *input)</span>


<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FromArrayAttr(PyObject *op, PyArray_Descr *typecode, PyObject</span>
                        <span class="s0">*context)</span>


<span class="s0">::</span>

  <span class="s0">NPY_SCALARKIND</span>
  <span class="s0">PyArray_ScalarKind(int typenum, PyArrayObject **arr)</span>

<span class="s0">ScalarKind</span>

<span class="s0">Returns the scalar kind of a type number, with an</span>
<span class="s0">optional tweak based on the scalar value itself.</span>
<span class="s0">If no scalar is provided, it returns INTPOS_SCALAR</span>
<span class="s0">for both signed and unsigned integers, otherwise</span>
<span class="s0">it checks the sign of any signed integer to choose</span>
<span class="s0">INTNEG_SCALAR when appropriate.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CanCoerceScalar(int thistype, int neededtype, NPY_SCALARKIND</span>
                          <span class="s0">scalar)</span>


<span class="s0">Determines whether the data type 'thistype', with</span>
<span class="s0">scalar kind 'scalar', can be coerced into 'neededtype'.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_NewFlagsObject(PyObject *obj)</span>


<span class="s0">Get New ArrayFlagsObject</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">PyArray_CanCastScalar(PyTypeObject *from, PyTypeObject *to)</span>

<span class="s0">See if array scalars can be cast.</span>

<span class="s0">TODO: For NumPy 2.0, add a NPY_CASTING parameter.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CompareUCS4(npy_ucs4 const *s1, npy_ucs4 const *s2, size_t</span>
                      <span class="s0">len)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_RemoveSmallest(PyArrayMultiIterObject *multi)</span>

<span class="s0">Adjusts previously broadcasted iterators so that the axis with</span>
<span class="s0">the smallest sum of iterator strides is not iterated over.</span>
<span class="s0">Returns dimension which is smallest in the range [0,multi-&gt;nd).</span>
<span class="s0">A -1 is returned if multi-&gt;nd == 0.</span>

<span class="s0">don't use with PyArray_ITER_GOTO1D because factors are not adjusted</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ElementStrides(PyObject *obj)</span>


<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_Item_INCREF(char *data, PyArray_Descr *descr)</span>

<span class="s0">XINCREF all objects in a single array item. This is complicated for</span>
<span class="s0">structured datatypes where the position of objects needs to be extracted.</span>
<span class="s0">The function is execute recursively for each nested field or subarrays dtype</span>
<span class="s0">such as as `np.dtype([(&quot;field1&quot;, &quot;O&quot;), (&quot;field2&quot;, &quot;f,O&quot;, (3,2))])`</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_Item_XDECREF(char *data, PyArray_Descr *descr)</span>


<span class="s0">XDECREF all objects in a single array item. This is complicated for</span>
<span class="s0">structured datatypes where the position of objects needs to be extracted.</span>
<span class="s0">The function is execute recursively for each nested field or subarrays dtype</span>
<span class="s0">such as as `np.dtype([(&quot;field1&quot;, &quot;O&quot;), (&quot;field2&quot;, &quot;f,O&quot;, (3,2))])`</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_FieldNames(PyObject *fields)</span>

<span class="s0">Return the tuple of ordered field names from a dictionary.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Transpose(PyArrayObject *ap, PyArray_Dims *permute)</span>

<span class="s0">Return Transpose.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_TakeFrom(PyArrayObject *self0, PyObject *indices0, int</span>
                   <span class="s0">axis, PyArrayObject *out, NPY_CLIPMODE clipmode)</span>

<span class="s0">Take</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_PutTo(PyArrayObject *self, PyObject*values0, PyObject</span>
                <span class="s0">*indices0, NPY_CLIPMODE clipmode)</span>

<span class="s0">Put values into an array</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_PutMask(PyArrayObject *self, PyObject*values0, PyObject*mask0)</span>

<span class="s0">Put values into an array according to a mask.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Repeat(PyArrayObject *aop, PyObject *op, int axis)</span>

<span class="s0">Repeat the array.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Choose(PyArrayObject *ip, PyObject *op, PyArrayObject</span>
                 <span class="s0">*out, NPY_CLIPMODE clipmode)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_Sort(PyArrayObject *op, int axis, NPY_SORTKIND which)</span>

<span class="s0">Sort an array in-place</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ArgSort(PyArrayObject *op, int axis, NPY_SORTKIND which)</span>

<span class="s0">ArgSort an array</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_SearchSorted(PyArrayObject *op1, PyObject *op2, NPY_SEARCHSIDE</span>
                       <span class="s0">side, PyObject *perm)</span>


<span class="s0">Search the sorted array op1 for the location of the items in op2. The</span>
<span class="s0">result is an array of indexes, one for each element in op2, such that if</span>
<span class="s0">the item were to be inserted in op1 just before that index the array</span>
<span class="s0">would still be in sorted order.</span>

<span class="s0">Parameters</span>
<span class="s0">----------</span>
<span class="s0">op1 : PyArrayObject *</span>
<span class="s0">Array to be searched, must be 1-D.</span>
<span class="s0">op2 : PyObject *</span>
<span class="s0">Array of items whose insertion indexes in op1 are wanted</span>
<span class="s0">side : {NPY_SEARCHLEFT, NPY_SEARCHRIGHT}</span>
<span class="s0">If NPY_SEARCHLEFT, return first valid insertion indexes</span>
<span class="s0">If NPY_SEARCHRIGHT, return last valid insertion indexes</span>
<span class="s0">perm : PyObject *</span>
<span class="s0">Permutation array that sorts op1 (optional)</span>

<span class="s0">Returns</span>
<span class="s0">-------</span>
<span class="s0">ret : PyObject *</span>
<span class="s0">New reference to npy_intp array containing indexes where items in op2</span>
<span class="s0">could be validly inserted into op1. NULL on error.</span>

<span class="s0">Notes</span>
<span class="s0">-----</span>
<span class="s0">Binary search is used to find the indexes.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ArgMax(PyArrayObject *op, int axis, PyArrayObject *out)</span>

<span class="s0">ArgMax</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ArgMin(PyArrayObject *op, int axis, PyArrayObject *out)</span>

<span class="s0">ArgMin</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Reshape(PyArrayObject *self, PyObject *shape)</span>

<span class="s0">Reshape</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Newshape(PyArrayObject *self, PyArray_Dims *newdims, NPY_ORDER</span>
                   <span class="s0">order)</span>

<span class="s0">New shape for an array</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Squeeze(PyArrayObject *self)</span>


<span class="s0">return a new view of the array object with all of its unit-length</span>
<span class="s0">dimensions squeezed out if needed, otherwise</span>
<span class="s0">return the same array.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_View(PyArrayObject *self, PyArray_Descr *type, PyTypeObject</span>
               <span class="s0">*pytype)</span>

<span class="s0">View</span>
<span class="s0">steals a reference to type -- accepts NULL</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_SwapAxes(PyArrayObject *ap, int a1, int a2)</span>

<span class="s0">SwapAxes</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Max(PyArrayObject *ap, int axis, PyArrayObject *out)</span>

<span class="s0">Max</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Min(PyArrayObject *ap, int axis, PyArrayObject *out)</span>

<span class="s0">Min</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Ptp(PyArrayObject *ap, int axis, PyArrayObject *out)</span>

<span class="s0">Ptp</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Mean(PyArrayObject *self, int axis, int rtype, PyArrayObject</span>
               <span class="s0">*out)</span>

<span class="s0">Mean</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Trace(PyArrayObject *self, int offset, int axis1, int</span>
                <span class="s0">axis2, int rtype, PyArrayObject *out)</span>

<span class="s0">Trace</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Diagonal(PyArrayObject *self, int offset, int axis1, int</span>
                   <span class="s0">axis2)</span>

<span class="s0">Diagonal</span>

<span class="s0">In NumPy versions prior to 1.7,  this function always returned a copy of</span>
<span class="s0">the diagonal array. In 1.7, the code has been updated to compute a view</span>
<span class="s0">onto 'self', but it still copies this array before returning, as well as</span>
<span class="s0">setting the internal WARN_ON_WRITE flag. In a future version, it will</span>
<span class="s0">simply return a view onto self.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Clip(PyArrayObject *self, PyObject *min, PyObject</span>
               <span class="s0">*max, PyArrayObject *out)</span>

<span class="s0">Clip</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Conjugate(PyArrayObject *self, PyArrayObject *out)</span>

<span class="s0">Conjugate</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Nonzero(PyArrayObject *self)</span>

<span class="s0">Nonzero</span>

<span class="s0">TODO: In NumPy 2.0, should make the iteration order a parameter.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Std(PyArrayObject *self, int axis, int rtype, PyArrayObject</span>
              <span class="s0">*out, int variance)</span>

<span class="s0">Set variance to 1 to by-pass square-root calculation and return variance</span>
<span class="s0">Std</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Sum(PyArrayObject *self, int axis, int rtype, PyArrayObject</span>
              <span class="s0">*out)</span>

<span class="s0">Sum</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_CumSum(PyArrayObject *self, int axis, int rtype, PyArrayObject</span>
                 <span class="s0">*out)</span>

<span class="s0">CumSum</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Prod(PyArrayObject *self, int axis, int rtype, PyArrayObject</span>
               <span class="s0">*out)</span>

<span class="s0">Prod</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_CumProd(PyArrayObject *self, int axis, int</span>
                  <span class="s0">rtype, PyArrayObject *out)</span>

<span class="s0">CumProd</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_All(PyArrayObject *self, int axis, PyArrayObject *out)</span>

<span class="s0">All</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Any(PyArrayObject *self, int axis, PyArrayObject *out)</span>

<span class="s0">Any</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Compress(PyArrayObject *self, PyObject *condition, int</span>
                   <span class="s0">axis, PyArrayObject *out)</span>

<span class="s0">Compress</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Flatten(PyArrayObject *a, NPY_ORDER order)</span>

<span class="s0">Flatten</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Ravel(PyArrayObject *arr, NPY_ORDER order)</span>

<span class="s0">Ravel</span>
<span class="s0">Returns a contiguous array</span>

<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">PyArray_MultiplyList(npy_intp const *l1, int n)</span>

<span class="s0">Multiply a List</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_MultiplyIntList(int const *l1, int n)</span>

<span class="s0">Multiply a List of ints</span>

<span class="s0">::</span>

  <span class="s0">void *</span>
  <span class="s0">PyArray_GetPtr(PyArrayObject *obj, npy_intp const*ind)</span>

<span class="s0">Produce a pointer into array</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CompareLists(npy_intp const *l1, npy_intp const *l2, int n)</span>

<span class="s0">Compare Lists</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_AsCArray(PyObject **op, void *ptr, npy_intp *dims, int</span>
                   <span class="s0">nd, PyArray_Descr*typedescr)</span>

<span class="s0">Simulate a C-array</span>
<span class="s0">steals a reference to typedescr -- can be NULL</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_As1D(PyObject **NPY_UNUSED(op) , char **NPY_UNUSED(ptr) , int</span>
               <span class="s0">*NPY_UNUSED(d1) , int NPY_UNUSED(typecode) )</span>

<span class="s0">Convert to a 1D C-array</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_As2D(PyObject **NPY_UNUSED(op) , char ***NPY_UNUSED(ptr) , int</span>
               <span class="s0">*NPY_UNUSED(d1) , int *NPY_UNUSED(d2) , int</span>
               <span class="s0">NPY_UNUSED(typecode) )</span>

<span class="s0">Convert to a 2D C-array</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_Free(PyObject *op, void *ptr)</span>

<span class="s0">Free pointers created if As2D is called</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_Converter(PyObject *object, PyObject **address)</span>


<span class="s0">Useful to pass as converter function for O&amp; processing in PyArgs_ParseTuple.</span>

<span class="s0">This conversion function can be used with the &quot;O&amp;&quot; argument for</span>
<span class="s0">PyArg_ParseTuple.  It will immediately return an object of array type</span>
<span class="s0">or will convert to a NPY_ARRAY_CARRAY any other object.</span>

<span class="s0">If you use PyArray_Converter, you must DECREF the array when finished</span>
<span class="s0">as you get a new reference to it.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_IntpFromSequence(PyObject *seq, npy_intp *vals, int maxvals)</span>

<span class="s0">PyArray_IntpFromSequence</span>
<span class="s0">Returns the number of integers converted or -1 if an error occurred.</span>
<span class="s0">vals must be large enough to hold maxvals</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Concatenate(PyObject *op, int axis)</span>

<span class="s0">Concatenate</span>

<span class="s0">Concatenate an arbitrary Python sequence into an array.</span>
<span class="s0">op is a python object supporting the sequence interface.</span>
<span class="s0">Its elements will be concatenated together to form a single</span>
<span class="s0">multidimensional array. If axis is NPY_MAXDIMS or bigger, then</span>
<span class="s0">each sequence object will be flattened before concatenation</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_InnerProduct(PyObject *op1, PyObject *op2)</span>

<span class="s0">Numeric.innerproduct(a,v)</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_MatrixProduct(PyObject *op1, PyObject *op2)</span>

<span class="s0">Numeric.matrixproduct(a,v)</span>
<span class="s0">just like inner product but does the swapaxes stuff on the fly</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_CopyAndTranspose(PyObject *op)</span>

<span class="s0">Copy and Transpose</span>

<span class="s0">Could deprecate this function, as there isn't a speed benefit over</span>
<span class="s0">calling Transpose and then Copy.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Correlate(PyObject *op1, PyObject *op2, int mode)</span>

<span class="s0">Numeric.correlate(a1,a2,mode)</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_TypestrConvert(int itemsize, int gentype)</span>

<span class="s0">Typestr converter</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_DescrConverter(PyObject *obj, PyArray_Descr **at)</span>

<span class="s0">Get typenum from an object -- None goes to NPY_DEFAULT_TYPE</span>
<span class="s0">This function takes a Python object representing a type and converts it</span>
<span class="s0">to a the correct PyArray_Descr * structure to describe the type.</span>

<span class="s0">Many objects can be used to represent a data-type which in NumPy is</span>
<span class="s0">quite a flexible concept.</span>

<span class="s0">This is the central code that converts Python objects to</span>
<span class="s0">Type-descriptor objects that are used throughout numpy.</span>

<span class="s0">Returns a new reference in *at, but the returned should not be</span>
<span class="s0">modified as it may be one of the canonical immutable objects or</span>
<span class="s0">a reference to the input obj.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_DescrConverter2(PyObject *obj, PyArray_Descr **at)</span>

<span class="s0">Get typenum from an object -- None goes to NULL</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_IntpConverter(PyObject *obj, PyArray_Dims *seq)</span>

<span class="s0">Get intp chunk from sequence</span>

<span class="s0">This function takes a Python sequence object and allocates and</span>
<span class="s0">fills in an intp array with the converted values.</span>

<span class="s0">Remember to free the pointer seq.ptr when done using</span>
<span class="s0">PyDimMem_FREE(seq.ptr)**</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_BufferConverter(PyObject *obj, PyArray_Chunk *buf)</span>

<span class="s0">Get buffer chunk from object</span>

<span class="s0">this function takes a Python object which exposes the (single-segment)</span>
<span class="s0">buffer interface and returns a pointer to the data segment</span>

<span class="s0">You should increment the reference count by one of buf-&gt;base</span>
<span class="s0">if you will hang on to a reference</span>

<span class="s0">You only get a borrowed reference to the object. Do not free the</span>
<span class="s0">memory...</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_AxisConverter(PyObject *obj, int *axis)</span>

<span class="s0">Get axis from an object (possibly None) -- a converter function,</span>

<span class="s0">See also PyArray_ConvertMultiAxis, which also handles a tuple of axes.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_BoolConverter(PyObject *object, npy_bool *val)</span>

<span class="s0">Convert an object to true / false</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ByteorderConverter(PyObject *obj, char *endian)</span>

<span class="s0">Convert object to endian</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_OrderConverter(PyObject *object, NPY_ORDER *val)</span>

<span class="s0">Convert an object to FORTRAN / C / ANY / KEEP</span>

<span class="s0">::</span>

  <span class="s0">unsigned char</span>
  <span class="s0">PyArray_EquivTypes(PyArray_Descr *type1, PyArray_Descr *type2)</span>


<span class="s0">This function returns true if the two typecodes are</span>
<span class="s0">equivalent (same basic kind and same itemsize).</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Zeros(int nd, npy_intp const *dims, PyArray_Descr *type, int</span>
                <span class="s0">is_f_order)</span>

<span class="s0">Zeros</span>

<span class="s0">steals a reference to type. On failure or when dtype-&gt;subarray is</span>
<span class="s0">true, dtype will be decrefed.</span>
<span class="s0">accepts NULL type</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Empty(int nd, npy_intp const *dims, PyArray_Descr *type, int</span>
                <span class="s0">is_f_order)</span>

<span class="s0">Empty</span>

<span class="s0">accepts NULL type</span>
<span class="s0">steals a reference to type</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Where(PyObject *condition, PyObject *x, PyObject *y)</span>

<span class="s0">Where</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Arange(double start, double stop, double step, int type_num)</span>

<span class="s0">Arange,</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ArangeObj(PyObject *start, PyObject *stop, PyObject</span>
                    <span class="s0">*step, PyArray_Descr *dtype)</span>


<span class="s0">ArangeObj,</span>

<span class="s0">this doesn't change the references</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SortkindConverter(PyObject *obj, NPY_SORTKIND *sortkind)</span>

<span class="s0">Convert object to sort kind</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_LexSort(PyObject *sort_keys, int axis)</span>

<span class="s0">LexSort an array providing indices that will sort a collection of arrays</span>
<span class="s0">lexicographically.  The first key is sorted on first, followed by the second key</span>
<span class="s0">-- requires that arg&quot;merge&quot;sort is available for each sort_key</span>

<span class="s0">Returns an index array that shows the indexes for the lexicographic sort along</span>
<span class="s0">the given axis.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Round(PyArrayObject *a, int decimals, PyArrayObject *out)</span>

<span class="s0">Round</span>

<span class="s0">::</span>

  <span class="s0">unsigned char</span>
  <span class="s0">PyArray_EquivTypenums(int typenum1, int typenum2)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_RegisterDataType(PyArray_Descr *descr)</span>

<span class="s0">Register Data type</span>
<span class="s0">Does not change the reference count of descr</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_RegisterCastFunc(PyArray_Descr *descr, int</span>
                           <span class="s0">totype, PyArray_VectorUnaryFunc *castfunc)</span>

<span class="s0">Register Casting Function</span>
<span class="s0">Replaces any function currently stored.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_RegisterCanCast(PyArray_Descr *descr, int</span>
                          <span class="s0">totype, NPY_SCALARKIND scalar)</span>

<span class="s0">Register a type number indicating that a descriptor can be cast</span>
<span class="s0">to it safely</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_InitArrFuncs(PyArray_ArrFuncs *f)</span>

<span class="s0">Initialize arrfuncs to NULL</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_IntTupleFromIntp(int len, npy_intp const *vals)</span>

<span class="s0">PyArray_IntTupleFromIntp</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_TypeNumFromName(char const *str)</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ClipmodeConverter(PyObject *object, NPY_CLIPMODE *val)</span>

<span class="s0">Convert an object to NPY_RAISE / NPY_CLIP / NPY_WRAP</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_OutputConverter(PyObject *object, PyArrayObject **address)</span>

<span class="s0">Useful to pass as converter function for O&amp; processing in</span>
<span class="s0">PyArgs_ParseTuple for output arrays</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_BroadcastToShape(PyObject *obj, npy_intp *dims, int nd)</span>

<span class="s0">Get Iterator broadcast to a particular shape</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">_PyArray_SigintHandler(int signum)</span>


<span class="s0">::</span>

  <span class="s0">void*</span>
  <span class="s0">_PyArray_GetSigintBuf(void )</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_DescrAlignConverter(PyObject *obj, PyArray_Descr **at)</span>


<span class="s0">Get type-descriptor from an object forcing alignment if possible</span>
<span class="s0">None goes to DEFAULT type.</span>

<span class="s0">any object with the .fields attribute and/or .itemsize attribute (if the</span>
<span class="s0">.fields attribute does not give the total size -- i.e. a partial record</span>
<span class="s0">naming).  If itemsize is given it must be &gt;= size computed from fields</span>

<span class="s0">The .fields attribute must return a convertible dictionary if present.</span>
<span class="s0">Result inherits from NPY_VOID.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_DescrAlignConverter2(PyObject *obj, PyArray_Descr **at)</span>


<span class="s0">Get type-descriptor from an object forcing alignment if possible</span>
<span class="s0">None goes to NULL.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SearchsideConverter(PyObject *obj, void *addr)</span>

<span class="s0">Convert object to searchsorted side</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_CheckAxis(PyArrayObject *arr, int *axis, int flags)</span>

<span class="s0">PyArray_CheckAxis</span>

<span class="s0">check that axis is valid</span>
<span class="s0">convert 0-d arrays to 1-d arrays</span>

<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">PyArray_OverflowMultiplyList(npy_intp const *l1, int n)</span>

<span class="s0">Multiply a List of Non-negative numbers with over-flow detection.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CompareString(const char *s1, const char *s2, size_t len)</span>


<span class="s0">::</span>

  <span class="s0">PyObject*</span>
  <span class="s0">PyArray_MultiIterFromObjects(PyObject **mps, int n, int nadd, ... )</span>

<span class="s0">Get MultiIterator from array of Python objects and any additional</span>

<span class="s0">PyObject **mps - array of PyObjects</span>
<span class="s0">int n - number of PyObjects in the array</span>
<span class="s0">int nadd - number of additional arrays to include in the iterator.</span>

<span class="s0">Returns a multi-iterator object.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_GetEndianness(void )</span>


<span class="s0">::</span>

  <span class="s0">unsigned int</span>
  <span class="s0">PyArray_GetNDArrayCFeatureVersion(void )</span>

<span class="s0">Returns the built-in (at compilation time) C API version</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_Correlate2(PyObject *op1, PyObject *op2, int mode)</span>

<span class="s0">correlate(a1,a2,mode)</span>

<span class="s0">This function computes the usual correlation (correlate(a1, a2) !=</span>
<span class="s0">correlate(a2, a1), and conjugate the second argument for complex inputs</span>

<span class="s0">::</span>

  <span class="s0">PyObject*</span>
  <span class="s0">PyArray_NeighborhoodIterNew(PyArrayIterObject *x, const npy_intp</span>
                              <span class="s0">*bounds, int mode, PyArrayObject*fill)</span>

<span class="s0">A Neighborhood Iterator object.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_SetDatetimeParseFunction(PyObject *NPY_UNUSED(op) )</span>

<span class="s0">This function is scheduled to be removed</span>

<span class="s0">TO BE REMOVED - NOT USED INTERNALLY.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_DatetimeToDatetimeStruct(npy_datetime NPY_UNUSED(val)</span>
                                   <span class="s0">, NPY_DATETIMEUNIT NPY_UNUSED(fr)</span>
                                   <span class="s0">, npy_datetimestruct *result)</span>

<span class="s0">Fill the datetime struct from the value and resolution unit.</span>

<span class="s0">TO BE REMOVED - NOT USED INTERNALLY.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_TimedeltaToTimedeltaStruct(npy_timedelta NPY_UNUSED(val)</span>
                                     <span class="s0">, NPY_DATETIMEUNIT NPY_UNUSED(fr)</span>
                                     <span class="s0">, npy_timedeltastruct *result)</span>

<span class="s0">Fill the timedelta struct from the timedelta value and resolution unit.</span>

<span class="s0">TO BE REMOVED - NOT USED INTERNALLY.</span>

<span class="s0">::</span>

  <span class="s0">npy_datetime</span>
  <span class="s0">PyArray_DatetimeStructToDatetime(NPY_DATETIMEUNIT NPY_UNUSED(fr)</span>
                                   <span class="s0">, npy_datetimestruct *NPY_UNUSED(d) )</span>

<span class="s0">Create a datetime value from a filled datetime struct and resolution unit.</span>

<span class="s0">TO BE REMOVED - NOT USED INTERNALLY.</span>

<span class="s0">::</span>

  <span class="s0">npy_datetime</span>
  <span class="s0">PyArray_TimedeltaStructToTimedelta(NPY_DATETIMEUNIT NPY_UNUSED(fr)</span>
                                     <span class="s0">, npy_timedeltastruct</span>
                                     <span class="s0">*NPY_UNUSED(d) )</span>

<span class="s0">Create a timedelta value from a filled timedelta struct and resolution unit.</span>

<span class="s0">TO BE REMOVED - NOT USED INTERNALLY.</span>

<span class="s0">::</span>

  <span class="s0">NpyIter *</span>
  <span class="s0">NpyIter_New(PyArrayObject *op, npy_uint32 flags, NPY_ORDER</span>
              <span class="s0">order, NPY_CASTING casting, PyArray_Descr*dtype)</span>

<span class="s0">Allocate a new iterator for one array object.</span>

<span class="s0">::</span>

  <span class="s0">NpyIter *</span>
  <span class="s0">NpyIter_MultiNew(int nop, PyArrayObject **op_in, npy_uint32</span>
                   <span class="s0">flags, NPY_ORDER order, NPY_CASTING</span>
                   <span class="s0">casting, npy_uint32 *op_flags, PyArray_Descr</span>
                   <span class="s0">**op_request_dtypes)</span>

<span class="s0">Allocate a new iterator for more than one array object, using</span>
<span class="s0">standard NumPy broadcasting rules and the default buffer size.</span>

<span class="s0">::</span>

  <span class="s0">NpyIter *</span>
  <span class="s0">NpyIter_AdvancedNew(int nop, PyArrayObject **op_in, npy_uint32</span>
                      <span class="s0">flags, NPY_ORDER order, NPY_CASTING</span>
                      <span class="s0">casting, npy_uint32 *op_flags, PyArray_Descr</span>
                      <span class="s0">**op_request_dtypes, int oa_ndim, int</span>
                      <span class="s0">**op_axes, npy_intp *itershape, npy_intp</span>
                      <span class="s0">buffersize)</span>

<span class="s0">Allocate a new iterator for multiple array objects, and advanced</span>
<span class="s0">options for controlling the broadcasting, shape, and buffer size.</span>

<span class="s0">::</span>

  <span class="s0">NpyIter *</span>
  <span class="s0">NpyIter_Copy(NpyIter *iter)</span>

<span class="s0">Makes a copy of the iterator</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_Deallocate(NpyIter *iter)</span>

<span class="s0">Deallocate an iterator.</span>

<span class="s0">To correctly work when an error is in progress, we have to check</span>
<span class="s0">`PyErr_Occurred()`. This is necessary when buffers are not finalized</span>
<span class="s0">or WritebackIfCopy is used. We could avoid that check by exposing a new</span>
<span class="s0">function which is passed in whether or not a Python error is already set.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_HasDelayedBufAlloc(NpyIter *iter)</span>

<span class="s0">Whether the buffer allocation is being delayed</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_HasExternalLoop(NpyIter *iter)</span>

<span class="s0">Whether the iterator handles the inner loop</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_EnableExternalLoop(NpyIter *iter)</span>

<span class="s0">Removes the inner loop handling (so HasExternalLoop returns true)</span>

<span class="s0">::</span>

  <span class="s0">npy_intp *</span>
  <span class="s0">NpyIter_GetInnerStrideArray(NpyIter *iter)</span>

<span class="s0">Get the array of strides for the inner loop (when HasExternalLoop is true)</span>

<span class="s0">This function may be safely called without holding the Python GIL.</span>

<span class="s0">::</span>

  <span class="s0">npy_intp *</span>
  <span class="s0">NpyIter_GetInnerLoopSizePtr(NpyIter *iter)</span>

<span class="s0">Get a pointer to the size of the inner loop  (when HasExternalLoop is true)</span>

<span class="s0">This function may be safely called without holding the Python GIL.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_Reset(NpyIter *iter, char **errmsg)</span>

<span class="s0">Resets the iterator to its initial state</span>

<span class="s0">The use of errmsg is discouraged, it cannot be guaranteed that the GIL</span>
<span class="s0">will not be grabbed on casting errors even when this is passed.</span>

<span class="s0">If errmsg is non-NULL, it should point to a variable which will</span>
<span class="s0">receive the error message, and no Python exception will be set.</span>
<span class="s0">This is so that the function can be called from code not holding</span>
<span class="s0">the GIL. Note that cast errors may still lead to the GIL being</span>
<span class="s0">grabbed temporarily.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_ResetBasePointers(NpyIter *iter, char **baseptrs, char</span>
                            <span class="s0">**errmsg)</span>

<span class="s0">Resets the iterator to its initial state, with new base data pointers.</span>
<span class="s0">This function requires great caution.</span>

<span class="s0">If errmsg is non-NULL, it should point to a variable which will</span>
<span class="s0">receive the error message, and no Python exception will be set.</span>
<span class="s0">This is so that the function can be called from code not holding</span>
<span class="s0">the GIL. Note that cast errors may still lead to the GIL being</span>
<span class="s0">grabbed temporarily.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_ResetToIterIndexRange(NpyIter *iter, npy_intp istart, npy_intp</span>
                                <span class="s0">iend, char **errmsg)</span>

<span class="s0">Resets the iterator to a new iterator index range</span>

<span class="s0">If errmsg is non-NULL, it should point to a variable which will</span>
<span class="s0">receive the error message, and no Python exception will be set.</span>
<span class="s0">This is so that the function can be called from code not holding</span>
<span class="s0">the GIL. Note that cast errors may still lead to the GIL being</span>
<span class="s0">grabbed temporarily.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_GetNDim(NpyIter *iter)</span>

<span class="s0">Gets the number of dimensions being iterated</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_GetNOp(NpyIter *iter)</span>

<span class="s0">Gets the number of operands being iterated</span>

<span class="s0">::</span>

  <span class="s0">NpyIter_IterNextFunc *</span>
  <span class="s0">NpyIter_GetIterNext(NpyIter *iter, char **errmsg)</span>

<span class="s0">Compute the specialized iteration function for an iterator</span>

<span class="s0">If errmsg is non-NULL, it should point to a variable which will</span>
<span class="s0">receive the error message, and no Python exception will be set.</span>
<span class="s0">This is so that the function can be called from code not holding</span>
<span class="s0">the GIL.</span>

<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">NpyIter_GetIterSize(NpyIter *iter)</span>

<span class="s0">Gets the number of elements being iterated</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">NpyIter_GetIterIndexRange(NpyIter *iter, npy_intp *istart, npy_intp</span>
                            <span class="s0">*iend)</span>

<span class="s0">Gets the range of iteration indices being iterated</span>

<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">NpyIter_GetIterIndex(NpyIter *iter)</span>

<span class="s0">Gets the current iteration index</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_GotoIterIndex(NpyIter *iter, npy_intp iterindex)</span>

<span class="s0">Sets the iterator position to the specified iterindex,</span>
<span class="s0">which matches the iteration order of the iterator.</span>

<span class="s0">Returns NPY_SUCCEED on success, NPY_FAIL on failure.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_HasMultiIndex(NpyIter *iter)</span>

<span class="s0">Whether the iterator is tracking a multi-index</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_GetShape(NpyIter *iter, npy_intp *outshape)</span>

<span class="s0">Gets the broadcast shape if a multi-index is being tracked by the iterator,</span>
<span class="s0">otherwise gets the shape of the iteration as Fortran-order</span>
<span class="s0">(fastest-changing index first).</span>

<span class="s0">The reason Fortran-order is returned when a multi-index</span>
<span class="s0">is not enabled is that this is providing a direct view into how</span>
<span class="s0">the iterator traverses the n-dimensional space. The iterator organizes</span>
<span class="s0">its memory from fastest index to slowest index, and when</span>
<span class="s0">a multi-index is enabled, it uses a permutation to recover the original</span>
<span class="s0">order.</span>

<span class="s0">Returns NPY_SUCCEED or NPY_FAIL.</span>

<span class="s0">::</span>

  <span class="s0">NpyIter_GetMultiIndexFunc *</span>
  <span class="s0">NpyIter_GetGetMultiIndex(NpyIter *iter, char **errmsg)</span>

<span class="s0">Compute a specialized get_multi_index function for the iterator</span>

<span class="s0">If errmsg is non-NULL, it should point to a variable which will</span>
<span class="s0">receive the error message, and no Python exception will be set.</span>
<span class="s0">This is so that the function can be called from code not holding</span>
<span class="s0">the GIL.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_GotoMultiIndex(NpyIter *iter, npy_intp const *multi_index)</span>

<span class="s0">Sets the iterator to the specified multi-index, which must have the</span>
<span class="s0">correct number of entries for 'ndim'.  It is only valid</span>
<span class="s0">when NPY_ITER_MULTI_INDEX was passed to the constructor.  This operation</span>
<span class="s0">fails if the multi-index is out of bounds.</span>

<span class="s0">Returns NPY_SUCCEED on success, NPY_FAIL on failure.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_RemoveMultiIndex(NpyIter *iter)</span>

<span class="s0">Removes multi-index support from an iterator.</span>

<span class="s0">Returns NPY_SUCCEED or NPY_FAIL.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_HasIndex(NpyIter *iter)</span>

<span class="s0">Whether the iterator is tracking an index</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_IsBuffered(NpyIter *iter)</span>

<span class="s0">Whether the iterator is buffered</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_IsGrowInner(NpyIter *iter)</span>

<span class="s0">Whether the inner loop can grow if buffering is unneeded</span>

<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">NpyIter_GetBufferSize(NpyIter *iter)</span>

<span class="s0">Gets the size of the buffer, or 0 if buffering is not enabled</span>

<span class="s0">::</span>

  <span class="s0">npy_intp *</span>
  <span class="s0">NpyIter_GetIndexPtr(NpyIter *iter)</span>

<span class="s0">Get a pointer to the index, if it is being tracked</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_GotoIndex(NpyIter *iter, npy_intp flat_index)</span>

<span class="s0">If the iterator is tracking an index, sets the iterator</span>
<span class="s0">to the specified index.</span>

<span class="s0">Returns NPY_SUCCEED on success, NPY_FAIL on failure.</span>

<span class="s0">::</span>

  <span class="s0">char **</span>
  <span class="s0">NpyIter_GetDataPtrArray(NpyIter *iter)</span>

<span class="s0">Get the array of data pointers (1 per object being iterated)</span>

<span class="s0">This function may be safely called without holding the Python GIL.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr **</span>
  <span class="s0">NpyIter_GetDescrArray(NpyIter *iter)</span>

<span class="s0">Get the array of data type pointers (1 per object being iterated)</span>

<span class="s0">::</span>

  <span class="s0">PyArrayObject **</span>
  <span class="s0">NpyIter_GetOperandArray(NpyIter *iter)</span>

<span class="s0">Get the array of objects being iterated</span>

<span class="s0">::</span>

  <span class="s0">PyArrayObject *</span>
  <span class="s0">NpyIter_GetIterView(NpyIter *iter, npy_intp i)</span>

<span class="s0">Returns a view to the i-th object with the iterator's internal axes</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">NpyIter_GetReadFlags(NpyIter *iter, char *outreadflags)</span>

<span class="s0">Gets an array of read flags (1 per object being iterated)</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">NpyIter_GetWriteFlags(NpyIter *iter, char *outwriteflags)</span>

<span class="s0">Gets an array of write flags (1 per object being iterated)</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">NpyIter_DebugPrint(NpyIter *iter)</span>

<span class="s0">For debugging</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_IterationNeedsAPI(NpyIter *iter)</span>

<span class="s0">Whether the iteration loop, and in particular the iternext()</span>
<span class="s0">function, needs API access.  If this is true, the GIL must</span>
<span class="s0">be retained while iterating.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">NpyIter_GetInnerFixedStrideArray(NpyIter *iter, npy_intp *out_strides)</span>

<span class="s0">Get an array of strides which are fixed.  Any strides which may</span>
<span class="s0">change during iteration receive the value NPY_MAX_INTP.  Once</span>
<span class="s0">the iterator is ready to iterate, call this to get the strides</span>
<span class="s0">which will always be fixed in the inner loop, then choose optimized</span>
<span class="s0">inner loop functions which take advantage of those fixed strides.</span>

<span class="s0">This function may be safely called without holding the Python GIL.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_RemoveAxis(NpyIter *iter, int axis)</span>

<span class="s0">Removes an axis from iteration. This requires that NPY_ITER_MULTI_INDEX</span>
<span class="s0">was set for iterator creation, and does not work if buffering is</span>
<span class="s0">enabled. This function also resets the iterator to its initial state.</span>

<span class="s0">Returns NPY_SUCCEED or NPY_FAIL.</span>

<span class="s0">::</span>

  <span class="s0">npy_intp *</span>
  <span class="s0">NpyIter_GetAxisStrideArray(NpyIter *iter, int axis)</span>

<span class="s0">Gets the array of strides for the specified axis.</span>
<span class="s0">If the iterator is tracking a multi-index, gets the strides</span>
<span class="s0">for the axis specified, otherwise gets the strides for</span>
<span class="s0">the iteration axis as Fortran order (fastest-changing axis first).</span>

<span class="s0">Returns NULL if an error occurs.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_RequiresBuffering(NpyIter *iter)</span>

<span class="s0">Whether the iteration could be done with no buffering.</span>

<span class="s0">::</span>

  <span class="s0">char **</span>
  <span class="s0">NpyIter_GetInitialDataPtrArray(NpyIter *iter)</span>

<span class="s0">Get the array of data pointers (1 per object being iterated),</span>
<span class="s0">directly into the arrays (never pointing to a buffer), for starting</span>
<span class="s0">unbuffered iteration. This always returns the addresses for the</span>
<span class="s0">iterator position as reset to iterator index 0.</span>

<span class="s0">These pointers are different from the pointers accepted by</span>
<span class="s0">NpyIter_ResetBasePointers, because the direction along some</span>
<span class="s0">axes may have been reversed, requiring base offsets.</span>

<span class="s0">This function may be safely called without holding the Python GIL.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">NpyIter_CreateCompatibleStrides(NpyIter *iter, npy_intp</span>
                                  <span class="s0">itemsize, npy_intp *outstrides)</span>

<span class="s0">Builds a set of strides which are the same as the strides of an</span>
<span class="s0">output array created using the NPY_ITER_ALLOCATE flag, where NULL</span>
<span class="s0">was passed for op_axes.  This is for data packed contiguously,</span>
<span class="s0">but not necessarily in C or Fortran order. This should be used</span>
<span class="s0">together with NpyIter_GetShape and NpyIter_GetNDim.</span>

<span class="s0">A use case for this function is to match the shape and layout of</span>
<span class="s0">the iterator and tack on one or more dimensions.  For example,</span>
<span class="s0">in order to generate a vector per input value for a numerical gradient,</span>
<span class="s0">you pass in ndim*itemsize for itemsize, then add another dimension to</span>
<span class="s0">the end with size ndim and stride itemsize.  To do the Hessian matrix,</span>
<span class="s0">you do the same thing but add two dimensions, or take advantage of</span>
<span class="s0">the symmetry and pack it into 1 dimension with a particular encoding.</span>

<span class="s0">This function may only be called if the iterator is tracking a multi-index</span>
<span class="s0">and if NPY_ITER_DONT_NEGATE_STRIDES was used to prevent an axis from</span>
<span class="s0">being iterated in reverse order.</span>

<span class="s0">If an array is created with this method, simply adding 'itemsize'</span>
<span class="s0">for each iteration will traverse the new array matching the</span>
<span class="s0">iterator.</span>

<span class="s0">Returns NPY_SUCCEED or NPY_FAIL.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CastingConverter(PyObject *obj, NPY_CASTING *casting)</span>

<span class="s0">Convert any Python object, *obj*, to an NPY_CASTING enum.</span>

<span class="s0">::</span>

  <span class="s0">npy_intp</span>
  <span class="s0">PyArray_CountNonzero(PyArrayObject *self)</span>

<span class="s0">Counts the number of non-zero elements in the array.</span>

<span class="s0">Returns -1 on error.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_PromoteTypes(PyArray_Descr *type1, PyArray_Descr *type2)</span>

<span class="s0">Produces the smallest size and lowest kind type to which both</span>
<span class="s0">input types can be cast.</span>

<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_MinScalarType(PyArrayObject *arr)</span>

<span class="s0">If arr is a scalar (has 0 dimensions) with a built-in number data type,</span>
<span class="s0">finds the smallest type size/kind which can still represent its data.</span>
<span class="s0">Otherwise, returns the array's data type.</span>


<span class="s0">::</span>

  <span class="s0">PyArray_Descr *</span>
  <span class="s0">PyArray_ResultType(npy_intp narrs, PyArrayObject *arrs[] , npy_intp</span>
                     <span class="s0">ndtypes, PyArray_Descr *descrs[] )</span>


<span class="s0">Produces the result type of a bunch of inputs, using the same rules</span>
<span class="s0">as `np.result_type`.</span>

<span class="s0">NOTE: This function is expected to through a transitional period or</span>
<span class="s0">change behaviour.  DTypes should always be strictly enforced for</span>
<span class="s0">0-D arrays, while &quot;weak DTypes&quot; will be used to represent Python</span>
<span class="s0">integers, floats, and complex in all cases.</span>
<span class="s0">(Within this function, these are currently flagged on the array</span>
<span class="s0">object to work through `np.result_type`, this may change.)</span>

<span class="s0">Until a time where this transition is complete, we probably cannot</span>
<span class="s0">add new &quot;weak DTypes&quot; or allow users to create their own.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">PyArray_CanCastArrayTo(PyArrayObject *arr, PyArray_Descr</span>
                         <span class="s0">*to, NPY_CASTING casting)</span>

<span class="s0">Returns 1 if the array object may be cast to the given data type using</span>
<span class="s0">the casting rule, 0 otherwise.  This differs from PyArray_CanCastTo in</span>
<span class="s0">that it handles scalar arrays (0 dimensions) specially, by checking</span>
<span class="s0">their value.</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">PyArray_CanCastTypeTo(PyArray_Descr *from, PyArray_Descr</span>
                        <span class="s0">*to, NPY_CASTING casting)</span>

<span class="s0">Returns true if data of type 'from' may be cast to data of type</span>
<span class="s0">'to' according to the rule 'casting'.</span>

<span class="s0">::</span>

  <span class="s0">PyArrayObject *</span>
  <span class="s0">PyArray_EinsteinSum(char *subscripts, npy_intp nop, PyArrayObject</span>
                      <span class="s0">**op_in, PyArray_Descr *dtype, NPY_ORDER</span>
                      <span class="s0">order, NPY_CASTING casting, PyArrayObject *out)</span>

<span class="s0">This function provides summation of array elements according to</span>
<span class="s0">the Einstein summation convention.  For example:</span>
<span class="s0">- trace(a)        -&gt; einsum(&quot;ii&quot;, a)</span>
<span class="s0">- transpose(a)    -&gt; einsum(&quot;ji&quot;, a)</span>
<span class="s0">- multiply(a,b)   -&gt; einsum(&quot;,&quot;, a, b)</span>
<span class="s0">- inner(a,b)      -&gt; einsum(&quot;i,i&quot;, a, b)</span>
<span class="s0">- outer(a,b)      -&gt; einsum(&quot;i,j&quot;, a, b)</span>
<span class="s0">- matvec(a,b)     -&gt; einsum(&quot;ij,j&quot;, a, b)</span>
<span class="s0">- matmat(a,b)     -&gt; einsum(&quot;ij,jk&quot;, a, b)</span>

<span class="s0">subscripts: The string of subscripts for einstein summation.</span>
<span class="s0">nop:        The number of operands</span>
<span class="s0">op_in:      The array of operands</span>
<span class="s0">dtype:      Either NULL, or the data type to force the calculation as.</span>
<span class="s0">order:      The order for the calculation/the output axes.</span>
<span class="s0">casting:    What kind of casts should be permitted.</span>
<span class="s0">out:        Either NULL, or an array into which the output should be placed.</span>

<span class="s0">By default, the labels get placed in alphabetical order</span>
<span class="s0">at the end of the output. So, if c = einsum(&quot;i,j&quot;, a, b)</span>
<span class="s0">then c[i,j] == a[i]*b[j], but if c = einsum(&quot;j,i&quot;, a, b)</span>
<span class="s0">then c[i,j] = a[j]*b[i].</span>

<span class="s0">Alternatively, you can control the output order or prevent</span>
<span class="s0">an axis from being summed/force an axis to be summed by providing</span>
<span class="s0">indices for the output. This allows us to turn 'trace' into</span>
<span class="s0">'diag', for example.</span>
<span class="s0">- diag(a)         -&gt; einsum(&quot;ii-&gt;i&quot;, a)</span>
<span class="s0">- sum(a, axis=0)  -&gt; einsum(&quot;i...-&gt;&quot;, a)</span>

<span class="s0">Subscripts at the beginning and end may be specified by</span>
<span class="s0">putting an ellipsis &quot;...&quot; in the middle.  For example,</span>
<span class="s0">the function einsum(&quot;i...i&quot;, a) takes the diagonal of</span>
<span class="s0">the first and last dimensions of the operand, and</span>
<span class="s0">einsum(&quot;ij...,jk...-&gt;ik...&quot;) takes the matrix product using</span>
<span class="s0">the first two indices of each operand instead of the last two.</span>

<span class="s0">When there is only one operand, no axes being summed, and</span>
<span class="s0">no output parameter, this function returns a view</span>
<span class="s0">into the operand instead of making a copy.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_NewLikeArray(PyArrayObject *prototype, NPY_ORDER</span>
                       <span class="s0">order, PyArray_Descr *dtype, int subok)</span>

<span class="s0">Creates a new array with the same shape as the provided one,</span>
<span class="s0">with possible memory layout order and data type changes.</span>

<span class="s0">prototype - The array the new one should be like.</span>
<span class="s0">order     - NPY_CORDER - C-contiguous result.</span>
<span class="s0">NPY_FORTRANORDER - Fortran-contiguous result.</span>
<span class="s0">NPY_ANYORDER - Fortran if prototype is Fortran, C otherwise.</span>
<span class="s0">NPY_KEEPORDER - Keeps the axis ordering of prototype.</span>
<span class="s0">dtype     - If not NULL, overrides the data type of the result.</span>
<span class="s0">subok     - If 1, use the prototype's array subtype, otherwise</span>
<span class="s0">always create a base-class array.</span>

<span class="s0">NOTE: If dtype is not NULL, steals the dtype reference.  On failure or when</span>
<span class="s0">dtype-&gt;subarray is true, dtype will be decrefed.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_GetArrayParamsFromObject(PyObject *NPY_UNUSED(op)</span>
                                   <span class="s0">, PyArray_Descr</span>
                                   <span class="s0">*NPY_UNUSED(requested_dtype)</span>
                                   <span class="s0">, npy_bool NPY_UNUSED(writeable)</span>
                                   <span class="s0">, PyArray_Descr</span>
                                   <span class="s0">**NPY_UNUSED(out_dtype) , int</span>
                                   <span class="s0">*NPY_UNUSED(out_ndim) , npy_intp</span>
                                   <span class="s0">*NPY_UNUSED(out_dims) , PyArrayObject</span>
                                   <span class="s0">**NPY_UNUSED(out_arr) , PyObject</span>
                                   <span class="s0">*NPY_UNUSED(context) )</span>


<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ConvertClipmodeSequence(PyObject *object, NPY_CLIPMODE</span>
                                  <span class="s0">*modes, int n)</span>

<span class="s0">Convert an object to an array of n NPY_CLIPMODE values.</span>
<span class="s0">This is intended to be used in functions where a different mode</span>
<span class="s0">could be applied to each axis, like in ravel_multi_index.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_MatrixProduct2(PyObject *op1, PyObject</span>
                         <span class="s0">*op2, PyArrayObject*out)</span>

<span class="s0">Numeric.matrixproduct2(a,v,out)</span>
<span class="s0">just like inner product but does the swapaxes stuff on the fly</span>

<span class="s0">::</span>

  <span class="s0">npy_bool</span>
  <span class="s0">NpyIter_IsFirstVisit(NpyIter *iter, int iop)</span>

<span class="s0">Checks to see whether this is the first time the elements</span>
<span class="s0">of the specified reduction operand which the iterator points at are</span>
<span class="s0">being seen for the first time. The function returns</span>
<span class="s0">a reasonable answer for reduction operands and when buffering is</span>
<span class="s0">disabled. The answer may be incorrect for buffered non-reduction</span>
<span class="s0">operands.</span>

<span class="s0">This function is intended to be used in EXTERNAL_LOOP mode only,</span>
<span class="s0">and will produce some wrong answers when that mode is not enabled.</span>

<span class="s0">If this function returns true, the caller should also</span>
<span class="s0">check the inner loop stride of the operand, because if</span>
<span class="s0">that stride is 0, then only the first element of the innermost</span>
<span class="s0">external loop is being visited for the first time.</span>

<span class="s0">WARNING: For performance reasons, 'iop' is not bounds-checked,</span>
<span class="s0">it is not confirmed that 'iop' is actually a reduction</span>
<span class="s0">operand, and it is not confirmed that EXTERNAL_LOOP</span>
<span class="s0">mode is enabled. These checks are the responsibility of</span>
<span class="s0">the caller, and should be done outside of any inner loops.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SetBaseObject(PyArrayObject *arr, PyObject *obj)</span>

<span class="s0">Sets the 'base' attribute of the array. This steals a reference</span>
<span class="s0">to 'obj'.</span>

<span class="s0">Returns 0 on success, -1 on failure.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_CreateSortedStridePerm(int ndim, npy_intp const</span>
                                 <span class="s0">*strides, npy_stride_sort_item</span>
                                 <span class="s0">*out_strideperm)</span>


<span class="s0">This function populates the first ndim elements</span>
<span class="s0">of strideperm with sorted descending by their absolute values.</span>
<span class="s0">For example, the stride array (4, -2, 12) becomes</span>
<span class="s0">[(2, 12), (0, 4), (1, -2)].</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_RemoveAxesInPlace(PyArrayObject *arr, const npy_bool *flags)</span>


<span class="s0">Removes the axes flagged as True from the array,</span>
<span class="s0">modifying it in place. If an axis flagged for removal</span>
<span class="s0">has a shape entry bigger than one, this effectively selects</span>
<span class="s0">index zero for that axis.</span>

<span class="s0">WARNING: If an axis flagged for removal has a shape equal to zero,</span>
<span class="s0">the array will point to invalid memory. The caller must</span>
<span class="s0">validate this!</span>
<span class="s0">If an axis flagged for removal has a shape larger than one,</span>
<span class="s0">the aligned flag (and in the future the contiguous flags),</span>
<span class="s0">may need explicit update.</span>
<span class="s0">(check also NPY_RELAXED_STRIDES_CHECKING)</span>

<span class="s0">For example, this can be used to remove the reduction axes</span>
<span class="s0">from a reduction result once its computation is complete.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_DebugPrint(PyArrayObject *obj)</span>

<span class="s0">Prints the raw data of the ndarray in a form useful for debugging</span>
<span class="s0">low-level C issues.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_FailUnlessWriteable(PyArrayObject *obj, const char *name)</span>


<span class="s0">This function does nothing if obj is writeable, and raises an exception</span>
<span class="s0">(and returns -1) if obj is not writeable. It may also do other</span>
<span class="s0">house-keeping, such as issuing warnings on arrays which are transitioning</span>
<span class="s0">to become views. Always call this function at some point before writing to</span>
<span class="s0">an array.</span>

<span class="s0">'name' is a name for the array, used to give better error</span>
<span class="s0">messages. Something like &quot;assignment destination&quot;, &quot;output array&quot;, or even</span>
<span class="s0">just &quot;array&quot;.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SetUpdateIfCopyBase(PyArrayObject *arr, PyArrayObject *base)</span>


<span class="s0">Precondition: 'arr' is a copy of 'base' (though possibly with different</span>
<span class="s0">strides, ordering, etc.). This function sets the UPDATEIFCOPY flag and the</span>
<span class="s0">-&gt;base pointer on 'arr', so that when 'arr' is destructed, it will copy any</span>
<span class="s0">changes back to 'base'. DEPRECATED, use PyArray_SetWritebackIfCopyBase</span>

<span class="s0">Steals a reference to 'base'.</span>

<span class="s0">Returns 0 on success, -1 on failure.</span>

<span class="s0">::</span>

  <span class="s0">void *</span>
  <span class="s0">PyDataMem_NEW(size_t size)</span>

<span class="s0">Allocates memory for array data.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyDataMem_FREE(void *ptr)</span>

<span class="s0">Free memory for array data.</span>

<span class="s0">::</span>

  <span class="s0">void *</span>
  <span class="s0">PyDataMem_RENEW(void *ptr, size_t size)</span>

<span class="s0">Reallocate/resize memory for array data.</span>

<span class="s0">::</span>

  <span class="s0">PyDataMem_EventHookFunc *</span>
  <span class="s0">PyDataMem_SetEventHook(PyDataMem_EventHookFunc *newhook, void</span>
                         <span class="s0">*user_data, void **old_data)</span>

<span class="s0">Sets the allocation event hook for numpy array data.</span>
<span class="s0">Takes a PyDataMem_EventHookFunc *, which has the signature:</span>
<span class="s0">void hook(void *old, void *new, size_t size, void *user_data).</span>
<span class="s0">Also takes a void *user_data, and void **old_data.</span>

<span class="s0">Returns a pointer to the previous hook or NULL.  If old_data is</span>
<span class="s0">non-NULL, the previous user_data pointer will be copied to it.</span>

<span class="s0">If not NULL, hook will be called at the end of each PyDataMem_NEW/FREE/RENEW:</span>
<span class="s0">result = PyDataMem_NEW(size)        -&gt; (*hook)(NULL, result, size, user_data)</span>
<span class="s0">PyDataMem_FREE(ptr)                 -&gt; (*hook)(ptr, NULL, 0, user_data)</span>
<span class="s0">result = PyDataMem_RENEW(ptr, size) -&gt; (*hook)(ptr, result, size, user_data)</span>

<span class="s0">When the hook is called, the GIL will be held by the calling</span>
<span class="s0">thread.  The hook should be written to be reentrant, if it performs</span>
<span class="s0">operations that might cause new allocation events (such as the</span>
<span class="s0">creation/destruction numpy objects, or creating/destroying Python</span>
<span class="s0">objects which might cause a gc)</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_MapIterSwapAxes(PyArrayMapIterObject *mit, PyArrayObject</span>
                          <span class="s0">**ret, int getmap)</span>


<span class="s0">Swap the axes to or from their inserted form. MapIter always puts the</span>
<span class="s0">advanced (array) indices first in the iteration. But if they are</span>
<span class="s0">consecutive, will insert/transpose them back before returning.</span>
<span class="s0">This is stored as `mit-&gt;consec != 0` (the place where they are inserted)</span>
<span class="s0">For assignments, the opposite happens: The values to be assigned are</span>
<span class="s0">transposed (getmap=1 instead of getmap=0). `getmap=0` and `getmap=1`</span>
<span class="s0">undo the other operation.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_MapIterArray(PyArrayObject *a, PyObject *index)</span>


<span class="s0">Use advanced indexing to iterate an array.</span>

<span class="s0">::</span>

  <span class="s0">void</span>
  <span class="s0">PyArray_MapIterNext(PyArrayMapIterObject *mit)</span>

<span class="s0">This function needs to update the state of the map iterator</span>
<span class="s0">and point mit-&gt;dataptr to the memory-location of the next object</span>

<span class="s0">Note that this function never handles an extra operand but provides</span>
<span class="s0">compatibility for an old (exposed) API.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_Partition(PyArrayObject *op, PyArrayObject *ktharray, int</span>
                    <span class="s0">axis, NPY_SELECTKIND which)</span>

<span class="s0">Partition an array in-place</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_ArgPartition(PyArrayObject *op, PyArrayObject *ktharray, int</span>
                       <span class="s0">axis, NPY_SELECTKIND which)</span>

<span class="s0">ArgPartition an array</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SelectkindConverter(PyObject *obj, NPY_SELECTKIND *selectkind)</span>

<span class="s0">Convert object to select kind</span>

<span class="s0">::</span>

  <span class="s0">void *</span>
  <span class="s0">PyDataMem_NEW_ZEROED(size_t nmemb, size_t size)</span>

<span class="s0">Allocates zeroed memory for array data.</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_CheckAnyScalarExact(PyObject *obj)</span>

<span class="s0">return true an object is exactly a numpy scalar</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyArray_MapIterArrayCopyIfOverlap(PyArrayObject *a, PyObject</span>
                                    <span class="s0">*index, int</span>
                                    <span class="s0">copy_if_overlap, PyArrayObject</span>
                                    <span class="s0">*extra_op)</span>


<span class="s0">Same as PyArray_MapIterArray, but:</span>

<span class="s0">If copy_if_overlap != 0, check if `a` has memory overlap with any of the</span>
<span class="s0">arrays in `index` and with `extra_op`. If yes, make copies as appropriate</span>
<span class="s0">to avoid problems if `a` is modified during the iteration.</span>
<span class="s0">`iter-&gt;array` may contain a copied array (UPDATEIFCOPY/WRITEBACKIFCOPY set).</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_ResolveWritebackIfCopy(PyArrayObject *self)</span>


<span class="s0">If WRITEBACKIFCOPY and self has data, reset the base WRITEABLE flag,</span>
<span class="s0">copy the local data to base, release the local data, and set flags</span>
<span class="s0">appropriately. Return 0 if not relevant, 1 if success, &lt; 0 on failure</span>

<span class="s0">::</span>

  <span class="s0">int</span>
  <span class="s0">PyArray_SetWritebackIfCopyBase(PyArrayObject *arr, PyArrayObject</span>
                                 <span class="s0">*base)</span>


<span class="s0">Precondition: 'arr' is a copy of 'base' (though possibly with different</span>
<span class="s0">strides, ordering, etc.). This function sets the WRITEBACKIFCOPY flag and the</span>
<span class="s0">-&gt;base pointer on 'arr', call PyArray_ResolveWritebackIfCopy to copy any</span>
<span class="s0">changes back to 'base' before deallocating the array.</span>

<span class="s0">Steals a reference to 'base'.</span>

<span class="s0">Returns 0 on success, -1 on failure.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyDataMem_SetHandler(PyObject *handler)</span>

<span class="s0">Set a new allocation policy. If the input value is NULL, will reset</span>
<span class="s0">the policy to the default. Return the previous policy, or</span>
<span class="s0">return NULL if an error has occurred. We wrap the user-provided</span>
<span class="s0">functions so they will still call the python and numpy</span>
<span class="s0">memory management callback hooks.</span>

<span class="s0">::</span>

  <span class="s0">PyObject *</span>
  <span class="s0">PyDataMem_GetHandler()</span>

<span class="s0">Return the policy that will be used to allocate data</span>
<span class="s0">for the next PyArrayObject. On failure, return NULL.</span>

</pre>
</body>
</html>