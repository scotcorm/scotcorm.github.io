<html>
<head>
<title>_ufunc.pyi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ufunc.pyi</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;A module with private type-check-only `numpy.ufunc` subclasses. 
 
The signatures of the ufuncs are too varied to reasonably type 
with a single class. So instead, `ufunc` has been expanded into 
four private subclasses, one for each combination of 
`~ufunc.nin` and `~ufunc.nout`. 
 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Generic</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">SupportsIndex</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">_CastingKind</span><span class="s2">, </span><span class="s1">_OrderKACF</span>
<span class="s2">from </span><span class="s1">numpy.typing </span><span class="s2">import </span><span class="s1">NDArray</span>

<span class="s2">from </span><span class="s1">._shape </span><span class="s2">import </span><span class="s1">_ShapeLike</span>
<span class="s2">from </span><span class="s1">._scalars </span><span class="s2">import </span><span class="s1">_ScalarLike_co</span>
<span class="s2">from </span><span class="s1">._array_like </span><span class="s2">import </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">_ArrayLikeBool_co</span><span class="s2">, </span><span class="s1">_ArrayLikeInt_co</span>
<span class="s2">from </span><span class="s1">._dtype_like </span><span class="s2">import </span><span class="s1">DTypeLike</span>

<span class="s1">_T = TypeVar(</span><span class="s3">&quot;_T&quot;</span><span class="s1">)</span>
<span class="s1">_2Tuple = Tuple[_T</span><span class="s2">, </span><span class="s1">_T]</span>
<span class="s1">_3Tuple = Tuple[_T</span><span class="s2">, </span><span class="s1">_T</span><span class="s2">, </span><span class="s1">_T]</span>
<span class="s1">_4Tuple = Tuple[_T</span><span class="s2">, </span><span class="s1">_T</span><span class="s2">, </span><span class="s1">_T</span><span class="s2">, </span><span class="s1">_T]</span>

<span class="s1">_NTypes = TypeVar(</span><span class="s3">&quot;_NTypes&quot;</span><span class="s2">, </span><span class="s1">bound=int)</span>
<span class="s1">_IDType = TypeVar(</span><span class="s3">&quot;_IDType&quot;</span><span class="s2">, </span><span class="s1">bound=Any)</span>
<span class="s1">_NameType = TypeVar(</span><span class="s3">&quot;_NameType&quot;</span><span class="s2">, </span><span class="s1">bound=str)</span>

<span class="s4"># NOTE: In reality `extobj` should be a length of list 3 containing an</span>
<span class="s4"># int, an int, and a callable, but there's no way to properly express</span>
<span class="s4"># non-homogenous lists.</span>
<span class="s4"># Use `Any` over `Union` to avoid issues related to lists invariance.</span>

<span class="s4"># NOTE: `reduce`, `accumulate`, `reduceat` and `outer` raise a ValueError for</span>
<span class="s4"># ufuncs that don't accept two input arguments and return one output argument.</span>
<span class="s4"># In such cases the respective methods are simply typed as `None`.</span>

<span class="s4"># NOTE: Similarly, `at` won't be defined for ufuncs that return</span>
<span class="s4"># multiple outputs; in such cases `at` is typed as `None`</span>

<span class="s4"># NOTE: If 2 output types are returned then `out` must be a</span>
<span class="s4"># 2-tuple of arrays. Otherwise `None` or a plain array are also acceptable</span>

<span class="s2">class </span><span class="s1">_UFunc_Nin1_Nout1(ufunc</span><span class="s2">, </span><span class="s1">Generic[_NameType</span><span class="s2">, </span><span class="s1">_NTypes</span><span class="s2">, </span><span class="s1">_IDType]):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__name__(self) -&gt; _NameType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ntypes(self) -&gt; _NTypes: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">identity(self) -&gt; _IDType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nin(self) -&gt; Literal[</span><span class="s5">1</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nout(self) -&gt; Literal[</span><span class="s5">1</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nargs(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">signature(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduce(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">accumulate(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduceat(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">outer(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _2Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any: ...</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: ArrayLike</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">| NDArray[Any] | Tuple[NDArray[Any]] = ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _2Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; NDArray[Any]: ...</span>

    <span class="s2">def </span><span class="s1">at(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">a: NDArray[Any]</span><span class="s2">,</span>
        <span class="s1">indices: _ArrayLikeInt_co</span><span class="s2">,</span>
        <span class="s1">/</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

<span class="s2">class </span><span class="s1">_UFunc_Nin2_Nout1(ufunc</span><span class="s2">, </span><span class="s1">Generic[_NameType</span><span class="s2">, </span><span class="s1">_NTypes</span><span class="s2">, </span><span class="s1">_IDType]):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__name__(self) -&gt; _NameType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ntypes(self) -&gt; _NTypes: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">identity(self) -&gt; _IDType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nin(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nout(self) -&gt; Literal[</span><span class="s5">1</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nargs(self) -&gt; Literal[</span><span class="s5">3</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">signature(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">__x2: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any: ...</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: ArrayLike</span><span class="s2">,</span>
        <span class="s1">__x2: ArrayLike</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">| NDArray[Any] | Tuple[NDArray[Any]] = ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; NDArray[Any]: ...</span>

    <span class="s2">def </span><span class="s1">at(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">a: NDArray[Any]</span><span class="s2">,</span>
        <span class="s1">indices: _ArrayLikeInt_co</span><span class="s2">,</span>
        <span class="s1">b: ArrayLike</span><span class="s2">,</span>
        <span class="s1">/</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

    <span class="s2">def </span><span class="s1">reduce(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">array: ArrayLike</span><span class="s2">,</span>
        <span class="s1">axis: </span><span class="s2">None </span><span class="s1">| _ShapeLike = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
        <span class="s1">keepdims: bool = ...</span><span class="s2">,</span>
        <span class="s1">initial: Any = ...</span><span class="s2">,</span>
        <span class="s1">where: _ArrayLikeBool_co = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any: ...</span>

    <span class="s2">def </span><span class="s1">accumulate(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">array: ArrayLike</span><span class="s2">,</span>
        <span class="s1">axis: SupportsIndex = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; NDArray[Any]: ...</span>

    <span class="s2">def </span><span class="s1">reduceat(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">array: ArrayLike</span><span class="s2">,</span>
        <span class="s1">indices: _ArrayLikeInt_co</span><span class="s2">,</span>
        <span class="s1">axis: SupportsIndex = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; NDArray[Any]: ...</span>

    <span class="s4"># Expand `**kwargs` into explicit keyword-only arguments</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">outer(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">A: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">B: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">/</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any: ...</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">outer(  </span><span class="s4"># type: ignore[misc]</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">A: ArrayLike</span><span class="s2">,</span>
        <span class="s1">B: ArrayLike</span><span class="s2">,</span>
        <span class="s1">/</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">| NDArray[Any] | Tuple[NDArray[Any]] = ...</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; NDArray[Any]: ...</span>

<span class="s2">class </span><span class="s1">_UFunc_Nin1_Nout2(ufunc</span><span class="s2">, </span><span class="s1">Generic[_NameType</span><span class="s2">, </span><span class="s1">_NTypes</span><span class="s2">, </span><span class="s1">_IDType]):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__name__(self) -&gt; _NameType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ntypes(self) -&gt; _NTypes: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">identity(self) -&gt; _IDType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nin(self) -&gt; Literal[</span><span class="s5">1</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nout(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nargs(self) -&gt; Literal[</span><span class="s5">3</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">signature(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">at(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduce(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">accumulate(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduceat(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">outer(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">__out1: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">__out2: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; _2Tuple[Any]: ...</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: ArrayLike</span><span class="s2">,</span>
        <span class="s1">__out1: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
        <span class="s1">__out2: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">out: _2Tuple[NDArray[Any]] = ...</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; _2Tuple[NDArray[Any]]: ...</span>

<span class="s2">class </span><span class="s1">_UFunc_Nin2_Nout2(ufunc</span><span class="s2">, </span><span class="s1">Generic[_NameType</span><span class="s2">, </span><span class="s1">_NTypes</span><span class="s2">, </span><span class="s1">_IDType]):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__name__(self) -&gt; _NameType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ntypes(self) -&gt; _NTypes: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">identity(self) -&gt; _IDType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nin(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nout(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nargs(self) -&gt; Literal[</span><span class="s5">4</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">signature(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">at(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduce(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">accumulate(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduceat(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">outer(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">__x2: _ScalarLike_co</span><span class="s2">,</span>
        <span class="s1">__out1: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">__out2: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _4Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; _2Tuple[Any]: ...</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: ArrayLike</span><span class="s2">,</span>
        <span class="s1">__x2: ArrayLike</span><span class="s2">,</span>
        <span class="s1">__out1: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
        <span class="s1">__out2: </span><span class="s2">None </span><span class="s1">| NDArray[Any] = ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">out: _2Tuple[NDArray[Any]] = ...</span><span class="s2">,</span>
        <span class="s1">where: </span><span class="s2">None </span><span class="s1">| _ArrayLikeBool_co = ...</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _4Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; _2Tuple[NDArray[Any]]: ...</span>

<span class="s2">class </span><span class="s1">_GUFunc_Nin2_Nout1(ufunc</span><span class="s2">, </span><span class="s1">Generic[_NameType</span><span class="s2">, </span><span class="s1">_NTypes</span><span class="s2">, </span><span class="s1">_IDType]):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__name__(self) -&gt; _NameType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ntypes(self) -&gt; _NTypes: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">identity(self) -&gt; _IDType: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nin(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nout(self) -&gt; Literal[</span><span class="s5">1</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nargs(self) -&gt; Literal[</span><span class="s5">3</span><span class="s1">]: ...</span>

    <span class="s4"># NOTE: In practice the only gufunc in the main name is `matmul`,</span>
    <span class="s4"># so we can use its signature here</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">signature(self) -&gt; Literal[</span><span class="s3">&quot;(n?,k),(k,m?)-&gt;(n?,m?)&quot;</span><span class="s1">]: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduce(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">accumulate(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reduceat(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">outer(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">at(self) -&gt; </span><span class="s2">None</span><span class="s1">: ...</span>

    <span class="s4"># Scalar for 1D array-likes; ndarray otherwise</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: ArrayLike</span><span class="s2">,</span>
        <span class="s1">__x2: ArrayLike</span><span class="s2">,</span>
        <span class="s1">out: </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
        <span class="s1">axes: List[_2Tuple[SupportsIndex]] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any: ...</span>
    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">__x1: ArrayLike</span><span class="s2">,</span>
        <span class="s1">__x2: ArrayLike</span><span class="s2">,</span>
        <span class="s1">out: NDArray[Any] | Tuple[NDArray[Any]]</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">casting: _CastingKind = ...</span><span class="s2">,</span>
        <span class="s1">order: _OrderKACF = ...</span><span class="s2">,</span>
        <span class="s1">dtype: DTypeLike = ...</span><span class="s2">,</span>
        <span class="s1">subok: bool = ...</span><span class="s2">,</span>
        <span class="s1">signature: str | _3Tuple[</span><span class="s2">None </span><span class="s1">| str] = ...</span><span class="s2">,</span>
        <span class="s1">extobj: List[Any] = ...</span><span class="s2">,</span>
        <span class="s1">axes: List[_2Tuple[SupportsIndex]] = ...</span><span class="s2">,</span>
    <span class="s1">) -&gt; NDArray[Any]: ...</span>
</pre>
</body>
</html>