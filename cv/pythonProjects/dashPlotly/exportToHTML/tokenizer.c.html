<html>
<head>
<title>tokenizer.c</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #0f9795;}
.s5 { color: #4646f1;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tokenizer.c</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 
Copyright (c) 2012, Lambda Foundry, Inc., except where noted 
 
Incorporates components of WarrenWeckesser/textreader, licensed under 3-clause 
BSD 
 
See LICENSE for the license 
 
*/</span>

<span class="s0">/* 
 
Low-level ascii-file processing for pandas. Combines some elements from 
Python's built-in csv module and Warren Weckesser's textreader project on 
GitHub. See Python Software Foundation License and BSD licenses for these. 
 
*/</span>

<span class="s2">#include </span><span class="s3">&quot;tokenizer.h&quot;</span>

<span class="s2">#include </span><span class="s1">&lt;ctype.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;</span><span class="s2">float</span><span class="s1">.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;math.h&gt;</span>

<span class="s2">#include </span><span class="s3">&quot;../headers/portable.h&quot;</span>

<span class="s2">void </span><span class="s1">coliter_setup(coliter_t *self, parser_t *parser, int64_t i,</span>
                   <span class="s1">int64_t start) {</span>
    <span class="s0">// column i, starting at 0</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words = parser</span><span class="s4">-&gt;</span><span class="s1">words;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">col = i;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start = parser</span><span class="s4">-&gt;</span><span class="s1">line_start + start;</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">free_if_not_null(</span><span class="s2">void </span><span class="s1">**ptr) {</span>
    <span class="s1">TRACE((</span><span class="s3">&quot;free_if_not_null %p</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, *ptr))</span>
    <span class="s2">if </span><span class="s1">(*ptr != NULL) {</span>
        <span class="s1">free(*ptr);</span>
        <span class="s1">*ptr = NULL;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/* 
 
  Parser / tokenizer 
 
*/</span>

<span class="s2">static void </span><span class="s1">*grow_buffer(</span><span class="s2">void </span><span class="s1">*buffer, uint64_t length, uint64_t *capacity,</span>
                         <span class="s1">int64_t space, int64_t elsize, </span><span class="s2">int </span><span class="s1">*error) {</span>
    <span class="s1">uint64_t cap = *capacity;</span>
    <span class="s2">void </span><span class="s1">*newbuffer = buffer;</span>

    <span class="s0">// Can we fit potentially nbytes tokens (+ null terminators) in the stream?</span>
    <span class="s2">while </span><span class="s1">((length + space &gt;= cap) &amp;&amp; (newbuffer != NULL)) {</span>
        <span class="s1">cap = cap ? cap &lt;&lt; </span><span class="s6">1 </span><span class="s1">: </span><span class="s6">2</span><span class="s1">;</span>
        <span class="s1">buffer = newbuffer;</span>
        <span class="s1">newbuffer = realloc(newbuffer, elsize * cap);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(newbuffer == NULL) {</span>
        <span class="s0">// realloc failed so don't change *capacity, set *error to errno</span>
        <span class="s0">// and return the last good realloc'd buffer so it can be freed</span>
        <span class="s1">*error = errno;</span>
        <span class="s1">newbuffer = buffer;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// realloc worked, update *capacity and set *error to 0</span>
        <span class="s0">// sigh, multiple return values</span>
        <span class="s1">*capacity = cap;</span>
        <span class="s1">*error = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newbuffer;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">parser_set_default_options(parser_t *self) {</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">decimal = </span><span class="s3">'.'</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">sci = </span><span class="s3">'E'</span><span class="s1">;</span>

    <span class="s0">// For tokenization</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">delimiter = </span><span class="s3">','</span><span class="s1">;  </span><span class="s0">// XXX</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">doublequote = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">quotechar = </span><span class="s3">'&quot;'</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">escapechar = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lineterminator = </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">; </span><span class="s0">/* NUL-&gt;standard logic */</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skipinitialspace = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">quoting = QUOTE_MINIMAL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">allow_embedded_newline = </span><span class="s6">1</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">expected_fields = -</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">on_bad_lines = ERROR;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">commentchar = </span><span class="s3">'#'</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">thousands = </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skipset = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skipfunc = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skip_first_N_rows = -</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skip_footer = </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">parser_t *parser_new() { </span><span class="s2">return </span><span class="s1">(parser_t *)calloc(</span><span class="s6">1</span><span class="s1">, </span><span class="s2">sizeof</span><span class="s1">(parser_t)); }</span>

<span class="s2">int </span><span class="s1">parser_clear_data_buffers(parser_t *self) {</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">stream);</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">words);</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">word_starts);</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">line_start);</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">line_fields);</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">parser_cleanup(parser_t *self) {</span>
    <span class="s2">int </span><span class="s1">status = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s0">// XXX where to put this</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">error_msg);</span>
    <span class="s1">free_if_not_null((</span><span class="s2">void </span><span class="s1">*)&amp;self</span><span class="s4">-&gt;</span><span class="s1">warn_msg);</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skipset != NULL) {</span>
        <span class="s1">kh_destroy_int64((kh_int64_t *)self</span><span class="s4">-&gt;</span><span class="s1">skipset);</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skipset = NULL;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(parser_clear_data_buffers(self) &lt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">status = -</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">cb_cleanup != NULL) {</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">cb_cleanup(self</span><span class="s4">-&gt;</span><span class="s1">source) &lt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s1">status = -</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">cb_cleanup = NULL;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">status;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">parser_init(parser_t *self) {</span>
    <span class="s1">int64_t sz;</span>

    <span class="s0">/* 
      Initialize data buffers 
    */</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">warn_msg = NULL;</span>

    <span class="s0">// token stream</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream = malloc(STREAM_INIT_SIZE * </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">char</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">stream == NULL) {</span>
        <span class="s1">parser_cleanup(self);</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_cap = STREAM_INIT_SIZE;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s0">// word pointers and metadata</span>
    <span class="s1">sz = STREAM_INIT_SIZE / </span><span class="s6">10</span><span class="s1">;</span>
    <span class="s1">sz = sz ? sz : </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words = malloc(sz * </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">char </span><span class="s1">*));</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts = malloc(sz * </span><span class="s2">sizeof</span><span class="s1">(int64_t));</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">max_words_cap = sz;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_cap = sz;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_len = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s0">// line pointers and metadata</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start = malloc(sz * </span><span class="s2">sizeof</span><span class="s1">(int64_t));</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields = malloc(sz * </span><span class="s2">sizeof</span><span class="s1">(int64_t));</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines_cap = sz;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">stream == NULL || self</span><span class="s4">-&gt;</span><span class="s1">words == NULL ||</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts == NULL || self</span><span class="s4">-&gt;</span><span class="s1">line_start == NULL ||</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields == NULL) {</span>
        <span class="s1">parser_cleanup(self);</span>

        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>

    <span class="s0">/* amount of bytes buffered */</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datalen = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datapos = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start[</span><span class="s6">0</span><span class="s1">] = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields[</span><span class="s6">0</span><span class="s1">] = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">pword_start = self</span><span class="s4">-&gt;</span><span class="s1">stream;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_start = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = NULL;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">warn_msg = NULL;</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">commentchar = </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">;</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">parser_free(parser_t *self) {</span>
    <span class="s0">// opposite of parser_init</span>
    <span class="s1">parser_cleanup(self);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">parser_del(parser_t *self) {</span>
    <span class="s1">free(self);</span>
<span class="s1">}</span>

<span class="s2">static int </span><span class="s1">make_stream_space(parser_t *self, size_t nbytes) {</span>
    <span class="s1">uint64_t i, cap, length;</span>
    <span class="s2">int </span><span class="s1">status;</span>
    <span class="s2">void </span><span class="s1">*orig_ptr, *newptr;</span>

    <span class="s0">// Can we fit potentially nbytes tokens (+ null terminators) in the stream?</span>

    <span class="s0">/* 
      TOKEN STREAM 
    */</span>

    <span class="s1">orig_ptr = (</span><span class="s2">void </span><span class="s1">*)self</span><span class="s4">-&gt;</span><span class="s1">stream;</span>
    <span class="s1">TRACE(</span>
        <span class="s1">(</span><span class="s3">&quot;</span><span class="s5">\n\n</span><span class="s3">make_stream_space: nbytes = %zu.  grow_buffer(self-&gt;stream...)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
         <span class="s1">nbytes))</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream = (</span><span class="s2">char </span><span class="s1">*)grow_buffer((</span><span class="s2">void </span><span class="s1">*)self</span><span class="s4">-&gt;</span><span class="s1">stream, self</span><span class="s4">-&gt;</span><span class="s1">stream_len,</span>
                                       <span class="s1">&amp;self</span><span class="s4">-&gt;</span><span class="s1">stream_cap, nbytes * </span><span class="s6">2</span><span class="s1">,</span>
                                       <span class="s2">sizeof</span><span class="s1">(</span><span class="s2">char</span><span class="s1">), &amp;status);</span>
    <span class="s1">TRACE(</span>
        <span class="s1">(</span><span class="s3">&quot;make_stream_space: self-&gt;stream=%p, self-&gt;stream_len = %zu, &quot;</span>
         <span class="s3">&quot;self-&gt;stream_cap=%zu, status=%zu</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
         <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream, self</span><span class="s4">-&gt;</span><span class="s1">stream_len, self</span><span class="s4">-&gt;</span><span class="s1">stream_cap, status))</span>

    <span class="s2">if </span><span class="s1">(status != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>

    <span class="s0">// realloc sets errno when moving buffer?</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">stream != orig_ptr) {</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">pword_start = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">word_start;</span>

        <span class="s2">for </span><span class="s1">(i = </span><span class="s6">0</span><span class="s1">; i &lt; self</span><span class="s4">-&gt;</span><span class="s1">words_len; ++i) {</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words[i] = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">word_starts[i];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/* 
      WORD VECTORS 
    */</span>

    <span class="s1">cap = self</span><span class="s4">-&gt;</span><span class="s1">words_cap;</span>

    <span class="s0">/** 
     * If we are reading in chunks, we need to be aware of the maximum number 
     * of words we have seen in previous chunks (self-&gt;max_words_cap), so 
     * that way, we can properly allocate when reading subsequent ones. 
     * 
     * Otherwise, we risk a buffer overflow if we mistakenly under-allocate 
     * just because a recent chunk did not have as many words. 
     */</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">words_len + nbytes &lt; self</span><span class="s4">-&gt;</span><span class="s1">max_words_cap) {</span>
        <span class="s1">length = self</span><span class="s4">-&gt;</span><span class="s1">max_words_cap - nbytes - </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">length = self</span><span class="s4">-&gt;</span><span class="s1">words_len;</span>
    <span class="s1">}</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words =</span>
        <span class="s1">(</span><span class="s2">char </span><span class="s1">**)grow_buffer((</span><span class="s2">void </span><span class="s1">*)self</span><span class="s4">-&gt;</span><span class="s1">words, length,</span>
                             <span class="s1">&amp;self</span><span class="s4">-&gt;</span><span class="s1">words_cap, nbytes,</span>
                             <span class="s2">sizeof</span><span class="s1">(</span><span class="s2">char </span><span class="s1">*), &amp;status);</span>
    <span class="s1">TRACE(</span>
        <span class="s1">(</span><span class="s3">&quot;make_stream_space: grow_buffer(self-&gt;self-&gt;words, %zu, %zu, %zu, &quot;</span>
         <span class="s3">&quot;%d)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
         <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_len, self</span><span class="s4">-&gt;</span><span class="s1">words_cap, nbytes, status))</span>
    <span class="s2">if </span><span class="s1">(status != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>

    <span class="s0">// realloc took place</span>
    <span class="s2">if </span><span class="s1">(cap != self</span><span class="s4">-&gt;</span><span class="s1">words_cap) {</span>
        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;make_stream_space: cap != self-&gt;words_cap, nbytes = %d, &quot;</span>
             <span class="s3">&quot;self-&gt;words_cap=%d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
             <span class="s1">nbytes, self</span><span class="s4">-&gt;</span><span class="s1">words_cap))</span>
        <span class="s1">newptr = realloc((</span><span class="s2">void </span><span class="s1">*)self</span><span class="s4">-&gt;</span><span class="s1">word_starts,</span>
                         <span class="s2">sizeof</span><span class="s1">(int64_t) * self</span><span class="s4">-&gt;</span><span class="s1">words_cap);</span>
        <span class="s2">if </span><span class="s1">(newptr == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts = (int64_t *)newptr;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/* 
      LINE VECTORS 
    */</span>
    <span class="s1">cap = self</span><span class="s4">-&gt;</span><span class="s1">lines_cap;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start =</span>
        <span class="s1">(int64_t *)grow_buffer((</span><span class="s2">void </span><span class="s1">*)self</span><span class="s4">-&gt;</span><span class="s1">line_start, self</span><span class="s4">-&gt;</span><span class="s1">lines + </span><span class="s6">1</span><span class="s1">,</span>
                           <span class="s1">&amp;self</span><span class="s4">-&gt;</span><span class="s1">lines_cap, nbytes,</span>
                           <span class="s2">sizeof</span><span class="s1">(int64_t), &amp;status);</span>
    <span class="s1">TRACE((</span>
        <span class="s3">&quot;make_stream_space: grow_buffer(self-&gt;line_start, %zu, %zu, %zu, %d)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines + </span><span class="s6">1</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">lines_cap, nbytes, status))</span>
    <span class="s2">if </span><span class="s1">(status != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>

    <span class="s0">// realloc took place</span>
    <span class="s2">if </span><span class="s1">(cap != self</span><span class="s4">-&gt;</span><span class="s1">lines_cap) {</span>
        <span class="s1">TRACE((</span><span class="s3">&quot;make_stream_space: cap != self-&gt;lines_cap, nbytes = %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
               <span class="s1">nbytes))</span>
        <span class="s1">newptr = realloc((</span><span class="s2">void </span><span class="s1">*)self</span><span class="s4">-&gt;</span><span class="s1">line_fields,</span>
                         <span class="s2">sizeof</span><span class="s1">(int64_t) * self</span><span class="s4">-&gt;</span><span class="s1">lines_cap);</span>
        <span class="s2">if </span><span class="s1">(newptr == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields = (int64_t *)newptr;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static int </span><span class="s1">push_char(parser_t *self, </span><span class="s2">char </span><span class="s1">c) {</span>
    <span class="s1">TRACE((</span><span class="s3">&quot;push_char: self-&gt;stream[%zu] = %x, stream_cap=%zu</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
           <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len + </span><span class="s6">1</span><span class="s1">, c, self</span><span class="s4">-&gt;</span><span class="s1">stream_cap))</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">stream_len &gt;= self</span><span class="s4">-&gt;</span><span class="s1">stream_cap) {</span>
        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;push_char: ERROR!!! self-&gt;stream_len(%d) &gt;= &quot;</span>
             <span class="s3">&quot;self-&gt;stream_cap(%d)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
             <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len, self</span><span class="s4">-&gt;</span><span class="s1">stream_cap))</span>
        <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>
        <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                 <span class="s3">&quot;Buffer overflow caught - possible malformed input file.</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream[self</span><span class="s4">-&gt;</span><span class="s1">stream_len++] = c;</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">PANDAS_INLINE end_field(parser_t *self) {</span>
    <span class="s0">// XXX cruft</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">words_len &gt;= self</span><span class="s4">-&gt;</span><span class="s1">words_cap) {</span>
        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;end_field: ERROR!!! self-&gt;words_len(%zu) &gt;= &quot;</span>
             <span class="s3">&quot;self-&gt;words_cap(%zu)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
             <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_len, self</span><span class="s4">-&gt;</span><span class="s1">words_cap))</span>
        <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>
        <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                 <span class="s3">&quot;Buffer overflow caught - possible malformed input file.</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
    <span class="s1">}</span>

    <span class="s0">// null terminate token</span>
    <span class="s1">push_char(self, </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">);</span>

    <span class="s0">// set pointer and metadata</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words[self</span><span class="s4">-&gt;</span><span class="s1">words_len] = self</span><span class="s4">-&gt;</span><span class="s1">pword_start;</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;end_field: Char diff: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">pword_start - self</span><span class="s4">-&gt;</span><span class="s1">words[</span><span class="s6">0</span><span class="s1">]));</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;end_field: Saw word %s at: %d. Total: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">pword_start,</span>
           <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_start, self</span><span class="s4">-&gt;</span><span class="s1">words_len + </span><span class="s6">1</span><span class="s1">))</span>

    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts[self</span><span class="s4">-&gt;</span><span class="s1">words_len] = self</span><span class="s4">-&gt;</span><span class="s1">word_start;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_len++;</span>

    <span class="s0">// increment line field count</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines]++;</span>

    <span class="s0">// New field begin in stream</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">pword_start = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_start = self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">append_warning(parser_t *self, </span><span class="s2">const char </span><span class="s1">*msg) {</span>
    <span class="s1">int64_t ex_length;</span>
    <span class="s1">int64_t length = strlen(msg);</span>
    <span class="s2">void </span><span class="s1">*newptr;</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">warn_msg == NULL) {</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">warn_msg = malloc(length + </span><span class="s6">1</span><span class="s1">);</span>
        <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">warn_msg, length + </span><span class="s6">1</span><span class="s1">, </span><span class="s3">&quot;%s&quot;</span><span class="s1">, msg);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ex_length = strlen(self</span><span class="s4">-&gt;</span><span class="s1">warn_msg);</span>
        <span class="s1">newptr = realloc(self</span><span class="s4">-&gt;</span><span class="s1">warn_msg, ex_length + length + </span><span class="s6">1</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(newptr != NULL) {</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">warn_msg = (</span><span class="s2">char </span><span class="s1">*)newptr;</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">warn_msg + ex_length, length + </span><span class="s6">1</span><span class="s1">, </span><span class="s3">&quot;%s&quot;</span><span class="s1">, msg);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static int </span><span class="s1">end_line(parser_t *self) {</span>
    <span class="s2">char </span><span class="s1">*msg;</span>
    <span class="s1">int64_t fields;</span>
    <span class="s1">int64_t ex_fields = self</span><span class="s4">-&gt;</span><span class="s1">expected_fields;</span>
    <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;  </span><span class="s0">// for error or warning messages</span>

    <span class="s1">fields = self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines];</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;end_line: Line end, nfields: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, fields));</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;end_line: lines: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">lines));</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">lines &gt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">expected_fields &gt;= </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s1">ex_fields = self</span><span class="s4">-&gt;</span><span class="s1">expected_fields;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">ex_fields = self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines - </span><span class="s6">1</span><span class="s1">];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TRACE((</span><span class="s3">&quot;end_line: ex_fields: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, ex_fields));</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">state == START_FIELD_IN_SKIP_LINE ||</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state == IN_FIELD_IN_SKIP_LINE ||</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state == IN_QUOTED_FIELD_IN_SKIP_LINE ||</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state == QUOTE_IN_QUOTED_FIELD_IN_SKIP_LINE) {</span>
        <span class="s1">TRACE((</span><span class="s3">&quot;end_line: Skipping row %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">file_lines));</span>
        <span class="s0">// increment file line count</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>

        <span class="s0">// skip the tokens from this bad line</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start[self</span><span class="s4">-&gt;</span><span class="s1">lines] += fields;</span>

        <span class="s0">// reset field count</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines] = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!(self</span><span class="s4">-&gt;</span><span class="s1">lines &lt;= self</span><span class="s4">-&gt;</span><span class="s1">header_end + </span><span class="s6">1</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">(fields &gt; ex_fields) &amp;&amp; !(self</span><span class="s4">-&gt;</span><span class="s1">usecols)) {</span>
        <span class="s0">// increment file line count</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>

        <span class="s0">// skip the tokens from this bad line</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start[self</span><span class="s4">-&gt;</span><span class="s1">lines] += fields;</span>

        <span class="s0">// reset field count</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines] = </span><span class="s6">0</span><span class="s1">;</span>

        <span class="s0">// file_lines is now the actual file line number (starting at 1)</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">on_bad_lines == ERROR) {</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                    <span class="s3">&quot;Expected %&quot; </span><span class="s1">PRId64 </span><span class="s3">&quot; fields in line %&quot; </span><span class="s1">PRIu64 </span><span class="s3">&quot;, saw %&quot;</span>
                    <span class="s1">PRId64 </span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, ex_fields, self</span><span class="s4">-&gt;</span><span class="s1">file_lines, fields);</span>

            <span class="s1">TRACE((</span><span class="s3">&quot;Error at line %d, %d fields</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">file_lines, fields));</span>

            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// simply skip bad lines</span>
            <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">on_bad_lines == WARN) {</span>
                <span class="s0">// pass up error message</span>
                <span class="s1">msg = malloc(bufsize);</span>
                <span class="s1">snprintf(msg, bufsize,</span>
                        <span class="s3">&quot;Skipping line %&quot; </span><span class="s1">PRIu64 </span><span class="s3">&quot;: expected %&quot; </span><span class="s1">PRId64</span>
                        <span class="s3">&quot; fields, saw %&quot; </span><span class="s1">PRId64 </span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines, ex_fields, fields);</span>
                <span class="s1">append_warning(self, msg);</span>
                <span class="s1">free(msg);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// missing trailing delimiters</span>
        <span class="s2">if </span><span class="s1">((self</span><span class="s4">-&gt;</span><span class="s1">lines &gt;= self</span><span class="s4">-&gt;</span><span class="s1">header_end + </span><span class="s6">1</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">fields &lt; ex_fields) {</span>
            <span class="s0">// might overrun the buffer when closing fields</span>
            <span class="s2">if </span><span class="s1">(make_stream_space(self, ex_fields - fields) &lt; </span><span class="s6">0</span><span class="s1">) {</span>
                <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>
                <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize, </span><span class="s3">&quot;out of memory&quot;</span><span class="s1">);</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">while </span><span class="s1">(fields &lt; ex_fields) {</span>
                <span class="s1">end_field(self);</span>
                <span class="s1">fields++;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// increment both line counts</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines++;</span>

        <span class="s0">// good line, set new start point</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">lines &gt;= self</span><span class="s4">-&gt;</span><span class="s1">lines_cap) {</span>
            <span class="s1">TRACE((</span>
                <span class="s3">&quot;end_line: ERROR!!! self-&gt;lines(%zu) &gt;= self-&gt;lines_cap(%zu)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines, self</span><span class="s4">-&gt;</span><span class="s1">lines_cap))</span>
            <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                     <span class="s3">&quot;Buffer overflow caught - &quot;</span>
                     <span class="s3">&quot;possible malformed input file.</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">}</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start[self</span><span class="s4">-&gt;</span><span class="s1">lines] =</span>
            <span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">line_start[self</span><span class="s4">-&gt;</span><span class="s1">lines - </span><span class="s6">1</span><span class="s1">] + fields);</span>

        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;end_line: new line start: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">line_start[self</span><span class="s4">-&gt;</span><span class="s1">lines]));</span>

        <span class="s0">// new line start with 0 fields</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines] = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;end_line: Finished line, at %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">lines));</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">parser_add_skiprow(parser_t *self, int64_t row) {</span>
    <span class="s1">khiter_t k;</span>
    <span class="s1">kh_int64_t *set;</span>
    <span class="s2">int </span><span class="s1">ret = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skipset == NULL) {</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skipset = (</span><span class="s2">void </span><span class="s1">*)kh_init_int64();</span>
    <span class="s1">}</span>

    <span class="s1">set = (kh_int64_t *)self</span><span class="s4">-&gt;</span><span class="s1">skipset;</span>

    <span class="s1">k = kh_put_int64(set, row, &amp;ret);</span>
    <span class="s1">set</span><span class="s4">-&gt;</span><span class="s1">keys[k] = row;</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">parser_set_skipfirstnrows(parser_t *self, int64_t nrows) {</span>
    <span class="s0">// self-&gt;file_lines is zero based so subtract 1 from nrows</span>
    <span class="s2">if </span><span class="s1">(nrows &gt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">skip_first_N_rows = nrows - </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static int </span><span class="s1">parser_buffer_bytes(parser_t *self, size_t nbytes,</span>
                               <span class="s2">const char </span><span class="s1">*encoding_errors) {</span>
    <span class="s2">int </span><span class="s1">status;</span>
    <span class="s1">size_t bytes_read;</span>

    <span class="s1">status = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datapos = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">data = self</span><span class="s4">-&gt;</span><span class="s1">cb_io(self</span><span class="s4">-&gt;</span><span class="s1">source, nbytes, &amp;bytes_read, &amp;status,</span>
                             <span class="s1">encoding_errors);</span>
    <span class="s1">TRACE((</span>
        <span class="s3">&quot;parser_buffer_bytes self-&gt;cb_io: nbytes=%zu, datalen: %d, status=%d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
        <span class="s1">nbytes, bytes_read, status));</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datalen = bytes_read;</span>

    <span class="s2">if </span><span class="s1">(status != REACHED_EOF &amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">data == NULL) {</span>
        <span class="s1">int64_t bufsize = </span><span class="s6">200</span><span class="s1">;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>

        <span class="s2">if </span><span class="s1">(status == CALLING_READ_FAILED) {</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                     <span class="s3">&quot;Calling read(nbytes) on source failed. &quot;</span>
                     <span class="s3">&quot;Try engine='python'.&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize, </span><span class="s3">&quot;Unknown error in IO callback&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;datalen: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">datalen));</span>

    <span class="s2">return </span><span class="s1">status;</span>
<span class="s1">}</span>

<span class="s0">/* 
 
  Tokenization macros and state machine code 
 
*/</span>

<span class="s2">#define </span><span class="s1">PUSH_CHAR(c)                                                          \</span>
    <span class="s1">TRACE(                                                                    \</span>
        <span class="s1">(</span><span class="s3">&quot;PUSH_CHAR: Pushing %c, slen= %d, stream_cap=%zu, stream_len=%zu</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, \</span>
         <span class="s1">c, slen, self</span><span class="s4">-&gt;</span><span class="s1">stream_cap, self</span><span class="s4">-&gt;</span><span class="s1">stream_len))                        \</span>
    <span class="s2">if </span><span class="s1">(slen &gt;= self</span><span class="s4">-&gt;</span><span class="s1">stream_cap) {                                           \</span>
        <span class="s1">TRACE((</span><span class="s3">&quot;PUSH_CHAR: ERROR!!! slen(%d) &gt;= stream_cap(%d)</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, slen,      \</span>
               <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_cap))                                             \</span>
        <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;                                                \</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);                                    \</span>
        <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,                                    \</span>
                 <span class="s3">&quot;Buffer overflow caught - possible malformed input file.</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">);\</span>
        <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;                                          \</span>
    <span class="s1">}                                                                         \</span>
    <span class="s1">*stream++ = c;                                                            \</span>
    <span class="s1">slen++;</span>

<span class="s0">// This is a little bit of a hack but works for now</span>

<span class="s2">#define </span><span class="s1">END_FIELD()                           \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len = slen;                  \</span>
    <span class="s2">if </span><span class="s1">(end_field(self) &lt; </span><span class="s6">0</span><span class="s1">) {                \</span>
        <span class="s2">goto </span><span class="s1">parsingerror;                    \</span>
    <span class="s1">}                                         \</span>
    <span class="s1">stream = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">stream_len; \</span>
    <span class="s1">slen = self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>

<span class="s2">#define </span><span class="s1">END_LINE_STATE(STATE)                                        \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len = slen;                                         \</span>
    <span class="s2">if </span><span class="s1">(end_line(self) &lt; </span><span class="s6">0</span><span class="s1">) {                                        \</span>
        <span class="s2">goto </span><span class="s1">parsingerror;                                           \</span>
    <span class="s1">}                                                                \</span>
    <span class="s1">stream = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">stream_len;                        \</span>
    <span class="s1">slen = self</span><span class="s4">-&gt;</span><span class="s1">stream_len;                                         \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = STATE;                                             \</span>
    <span class="s2">if </span><span class="s1">(line_limit &gt; </span><span class="s6">0 </span><span class="s1">&amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">lines == start_lines + line_limit) { \</span>
        <span class="s2">goto </span><span class="s1">linelimit;                                              \</span>
    <span class="s1">}</span>

<span class="s2">#define </span><span class="s1">END_LINE_AND_FIELD_STATE(STATE)                              \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len = slen;                                         \</span>
    <span class="s2">if </span><span class="s1">(end_line(self) &lt; </span><span class="s6">0</span><span class="s1">) {                                        \</span>
        <span class="s2">goto </span><span class="s1">parsingerror;                                           \</span>
    <span class="s1">}                                                                \</span>
    <span class="s2">if </span><span class="s1">(end_field(self) &lt; </span><span class="s6">0</span><span class="s1">) {                                       \</span>
        <span class="s2">goto </span><span class="s1">parsingerror;                                           \</span>
    <span class="s1">}                                                                \</span>
    <span class="s1">stream = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">stream_len;                        \</span>
    <span class="s1">slen = self</span><span class="s4">-&gt;</span><span class="s1">stream_len;                                         \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = STATE;                                             \</span>
    <span class="s2">if </span><span class="s1">(line_limit &gt; </span><span class="s6">0 </span><span class="s1">&amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">lines == start_lines + line_limit) { \</span>
        <span class="s2">goto </span><span class="s1">linelimit;                                              \</span>
    <span class="s1">}</span>

<span class="s2">#define </span><span class="s1">END_LINE() END_LINE_STATE(START_RECORD)</span>

<span class="s2">#define </span><span class="s1">IS_TERMINATOR(c)                            \</span>
    <span class="s1">(c == line_terminator)</span>

<span class="s2">#define </span><span class="s1">IS_QUOTE(c) ((c == self</span><span class="s4">-&gt;</span><span class="s1">quotechar &amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">quoting != QUOTE_NONE))</span>

<span class="s0">// don't parse '\r' with a custom line terminator</span>
<span class="s2">#define </span><span class="s1">IS_CARRIAGE(c) (c == carriage_symbol)</span>

<span class="s2">#define </span><span class="s1">IS_COMMENT_CHAR(c) (c == comment_symbol)</span>

<span class="s2">#define </span><span class="s1">IS_ESCAPE_CHAR(c) (c == escape_symbol)</span>

<span class="s2">#define </span><span class="s1">IS_SKIPPABLE_SPACE(c) \</span>
    <span class="s1">((!self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace &amp;&amp; c == </span><span class="s3">' ' </span><span class="s1">&amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">skipinitialspace))</span>

<span class="s0">// applied when in a field</span>
<span class="s2">#define </span><span class="s1">IS_DELIMITER(c)                                   \</span>
    <span class="s1">((!self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace &amp;&amp; c == self</span><span class="s4">-&gt;</span><span class="s1">delimiter) || \</span>
     <span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace &amp;&amp; isblank(c)))</span>

<span class="s2">#define </span><span class="s1">_TOKEN_CLEANUP()                                                \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len = slen;                                            \</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datapos = i;                                                  \</span>
    <span class="s1">TRACE((</span><span class="s3">&quot;_TOKEN_CLEANUP: datapos: %d, datalen: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">datapos, \</span>
           <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datalen));</span>

<span class="s2">#define </span><span class="s1">CHECK_FOR_BOM()                                                   \</span>
    <span class="s2">if </span><span class="s1">(*buf == </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ef' </span><span class="s1">&amp;&amp; *(buf + </span><span class="s6">1</span><span class="s1">) == </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">bb' </span><span class="s1">&amp;&amp; *(buf + </span><span class="s6">2</span><span class="s1">) == </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">bf'</span><span class="s1">) { \</span>
        <span class="s1">buf += </span><span class="s6">3</span><span class="s1">;                                                         \</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datapos += </span><span class="s6">3</span><span class="s1">;                                               \</span>
    <span class="s1">}</span>

<span class="s2">int </span><span class="s1">skip_this_line(parser_t *self, int64_t rownum) {</span>
    <span class="s2">int </span><span class="s1">should_skip;</span>
    <span class="s1">PyObject *result;</span>
    <span class="s1">PyGILState_STATE state;</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skipfunc != NULL) {</span>
        <span class="s1">state = PyGILState_Ensure();</span>
        <span class="s1">result = PyObject_CallFunction(self</span><span class="s4">-&gt;</span><span class="s1">skipfunc, </span><span class="s3">&quot;i&quot;</span><span class="s1">, rownum);</span>

        <span class="s0">// Error occurred. It will be processed</span>
        <span class="s0">// and caught at the Cython level.</span>
        <span class="s2">if </span><span class="s1">(result == NULL) {</span>
            <span class="s1">should_skip = -</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">should_skip = PyObject_IsTrue(result);</span>
        <span class="s1">}</span>

        <span class="s1">Py_XDECREF(result);</span>
        <span class="s1">PyGILState_Release(state);</span>

        <span class="s2">return </span><span class="s1">should_skip;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skipset != NULL) {</span>
        <span class="s2">return </span><span class="s1">(kh_get_int64((kh_int64_t *)self</span><span class="s4">-&gt;</span><span class="s1">skipset, self</span><span class="s4">-&gt;</span><span class="s1">file_lines) !=</span>
                <span class="s1">((kh_int64_t *)self</span><span class="s4">-&gt;</span><span class="s1">skipset)</span><span class="s4">-&gt;</span><span class="s1">n_buckets);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">(rownum &lt;= self</span><span class="s4">-&gt;</span><span class="s1">skip_first_N_rows);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">tokenize_bytes(parser_t *self,</span>
                   <span class="s1">size_t line_limit, uint64_t start_lines) {</span>
    <span class="s1">int64_t i;</span>
    <span class="s1">uint64_t slen;</span>
    <span class="s2">int </span><span class="s1">should_skip;</span>
    <span class="s2">char </span><span class="s1">c;</span>
    <span class="s2">char </span><span class="s1">*stream;</span>
    <span class="s2">char </span><span class="s1">*buf = self</span><span class="s4">-&gt;</span><span class="s1">data + self</span><span class="s4">-&gt;</span><span class="s1">datapos;</span>

    <span class="s2">const char </span><span class="s1">line_terminator = (self</span><span class="s4">-&gt;</span><span class="s1">lineterminator == </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) ?</span>
            <span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">: self</span><span class="s4">-&gt;</span><span class="s1">lineterminator;</span>

    <span class="s0">// 1000 is something that couldn't fit in &quot;char&quot;</span>
    <span class="s0">// thus comparing a char to it would always be &quot;false&quot;</span>
    <span class="s2">const int </span><span class="s1">carriage_symbol = (self</span><span class="s4">-&gt;</span><span class="s1">lineterminator == </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\r</span><span class="s3">' </span><span class="s1">: </span><span class="s6">1000</span><span class="s1">;</span>
    <span class="s2">const int </span><span class="s1">comment_symbol = (self</span><span class="s4">-&gt;</span><span class="s1">commentchar != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) ?</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">commentchar : </span><span class="s6">1000</span><span class="s1">;</span>
    <span class="s2">const int </span><span class="s1">escape_symbol = (self</span><span class="s4">-&gt;</span><span class="s1">escapechar != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) ?</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">escapechar : </span><span class="s6">1000</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(make_stream_space(self, self</span><span class="s4">-&gt;</span><span class="s1">datalen - self</span><span class="s4">-&gt;</span><span class="s1">datapos) &lt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = malloc(bufsize);</span>
        <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize, </span><span class="s3">&quot;out of memory&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">stream = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>
    <span class="s1">slen = self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;%s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, buf));</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">file_lines == </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">CHECK_FOR_BOM();</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(i = self</span><span class="s4">-&gt;</span><span class="s1">datapos; i &lt; self</span><span class="s4">-&gt;</span><span class="s1">datalen; ++i) {</span>
        <span class="s0">// next character in file</span>
        <span class="s1">c = *buf++;</span>

        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;tokenize_bytes - Iter: %d Char: 0x%x Line %d field_count %d, &quot;</span>
             <span class="s3">&quot;state %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
             <span class="s1">i, c, self</span><span class="s4">-&gt;</span><span class="s1">file_lines + </span><span class="s6">1</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">line_fields[self</span><span class="s4">-&gt;</span><span class="s1">lines],</span>
             <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state));</span>

        <span class="s2">switch </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">state) {</span>
            <span class="s2">case </span><span class="s1">START_FIELD_IN_SKIP_LINE:</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL_NOP;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_QUOTE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_QUOTED_FIELD_IN_SKIP_LINE;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s0">// Do nothing, we're starting a new field again.</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD_IN_SKIP_LINE;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">IN_FIELD_IN_SKIP_LINE:</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL_NOP;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD_IN_SKIP_LINE;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">IN_QUOTED_FIELD_IN_SKIP_LINE:</span>
                <span class="s2">if </span><span class="s1">(IS_QUOTE(c)) {</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">doublequote) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = QUOTE_IN_QUOTED_FIELD_IN_SKIP_LINE;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD_IN_SKIP_LINE;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">QUOTE_IN_QUOTED_FIELD_IN_SKIP_LINE:</span>
                <span class="s2">if </span><span class="s1">(IS_QUOTE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_QUOTED_FIELD_IN_SKIP_LINE;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL_NOP;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD_IN_SKIP_LINE;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD_IN_SKIP_LINE;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">WHITESPACE_LINE:</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL_NOP;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                    <span class="s2">if </span><span class="s1">(isblank(c) &amp;&amp; c != self</span><span class="s4">-&gt;</span><span class="s1">delimiter) {</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{  </span><span class="s0">// backtrack</span>
                        <span class="s0">// use i + 1 because buf has been incremented but not i</span>
                        <span class="s2">do </span><span class="s1">{</span>
                            <span class="s1">--buf;</span>
                            <span class="s1">--i;</span>
                        <span class="s1">} </span><span class="s2">while </span><span class="s1">(i + </span><span class="s6">1 </span><span class="s1">&gt; self</span><span class="s4">-&gt;</span><span class="s1">datapos &amp;&amp; !IS_TERMINATOR(*buf));</span>

                        <span class="s0">// reached a newline rather than the beginning</span>
                        <span class="s2">if </span><span class="s1">(IS_TERMINATOR(*buf)) {</span>
                            <span class="s1">++buf;  </span><span class="s0">// move pointer to first char after newline</span>
                            <span class="s1">++i;</span>
                        <span class="s1">}</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD;</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s0">// fall through</span>

            <span class="s2">case </span><span class="s1">EAT_WHITESPACE:</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_LINE();</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_COMMENT_CHAR(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_COMMENT;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isblank(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD;</span>
                    <span class="s0">// fall through to subsequent state</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s0">// if whitespace char, keep slurping</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>

            <span class="s2">case </span><span class="s1">START_RECORD:</span>
                <span class="s0">// start of record</span>
                <span class="s1">should_skip = skip_this_line(self, self</span><span class="s4">-&gt;</span><span class="s1">file_lines);</span>

                <span class="s2">if </span><span class="s1">(should_skip == -</span><span class="s6">1</span><span class="s1">) {</span>
                    <span class="s2">goto </span><span class="s1">parsingerror;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(should_skip) {</span>
                    <span class="s2">if </span><span class="s1">(IS_QUOTE(c)) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_QUOTED_FIELD_IN_SKIP_LINE;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD_IN_SKIP_LINE;</span>

                        <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                            <span class="s1">END_LINE();</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s0">// \n\r possible?</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skip_empty_lines) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">END_LINE();</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skip_empty_lines) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL_NOP;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL;</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_COMMENT_CHAR(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_LINE_COMMENT;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isblank(c)) {</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">skip_empty_lines) {</span>
                            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = WHITESPACE_LINE;</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_WHITESPACE;</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(c != self</span><span class="s4">-&gt;</span><span class="s1">delimiter &amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">skip_empty_lines) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = WHITESPACE_LINE;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">// fall through</span>
                <span class="s1">}</span>

                <span class="s0">// normal character - fall through</span>
                <span class="s0">// to handle as START_FIELD</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD;</span>

            <span class="s2">case </span><span class="s1">START_FIELD:</span>
                <span class="s0">// expecting field</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_QUOTE(c)) {</span>
                    <span class="s0">// start quoted field</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_QUOTED_FIELD;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_ESCAPE_CHAR(c)) {</span>
                    <span class="s0">// possible escaped character</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = ESCAPED_CHAR;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_SKIPPABLE_SPACE(c)) {</span>
                    <span class="s0">// ignore space at start of field</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_WHITESPACE;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s0">// save empty field</span>
                        <span class="s1">END_FIELD();</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_COMMENT_CHAR(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_COMMENT;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s0">// begin new unquoted field</span>
                    <span class="s1">PUSH_CHAR(c);</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">ESCAPED_CHAR:</span>
                <span class="s1">PUSH_CHAR(c);</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD;</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">EAT_LINE_COMMENT:</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines++;</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL_NOP;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">IN_FIELD:</span>
                <span class="s0">// in unquoted field</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_ESCAPE_CHAR(c)) {</span>
                    <span class="s0">// possible escaped character</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = ESCAPED_CHAR;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s0">// end of field - end of line not reached yet</span>
                    <span class="s1">END_FIELD();</span>

                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_WHITESPACE;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_COMMENT_CHAR(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_COMMENT;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s0">// normal character - save in field</span>
                    <span class="s1">PUSH_CHAR(c);</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">IN_QUOTED_FIELD:</span>
                <span class="s0">// in quoted field</span>
                <span class="s2">if </span><span class="s1">(IS_ESCAPE_CHAR(c)) {</span>
                    <span class="s0">// possible escape character</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = ESCAPE_IN_QUOTED_FIELD;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_QUOTE(c)) {</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">doublequote) {</span>
                        <span class="s0">// double quote - &quot; represented by &quot;&quot;</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = QUOTE_IN_QUOTED_FIELD;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s0">// end of quote part of field</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s0">// normal character - save in field</span>
                    <span class="s1">PUSH_CHAR(c);</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">ESCAPE_IN_QUOTED_FIELD:</span>
                <span class="s1">PUSH_CHAR(c);</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_QUOTED_FIELD;</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">QUOTE_IN_QUOTED_FIELD:</span>
                <span class="s0">// double quote - seen a quote in an quoted field</span>
                <span class="s2">if </span><span class="s1">(IS_QUOTE(c)) {</span>
                    <span class="s0">// save &quot;&quot; as &quot;</span>

                    <span class="s1">PUSH_CHAR(c);</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_QUOTED_FIELD;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s0">// end of field - end of line not reached yet</span>
                    <span class="s1">END_FIELD();</span>

                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_WHITESPACE;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_FIELD;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">END_FIELD();</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">PUSH_CHAR(c);</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = IN_FIELD;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">EAT_COMMENT:</span>
                <span class="s2">if </span><span class="s1">(IS_TERMINATOR(c)) {</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_CARRIAGE(c)) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = EAT_CRNL;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s0">// only occurs with non-custom line terminator,</span>
            <span class="s0">// which is why we directly check for '\n'</span>
            <span class="s2">case </span><span class="s1">EAT_CRNL:</span>
                <span class="s2">if </span><span class="s1">(c == </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">) {</span>
                    <span class="s1">END_LINE();</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(IS_DELIMITER(c)) {</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                        <span class="s1">END_LINE_STATE(EAT_WHITESPACE);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s0">// Handle \r-delimited files</span>
                        <span class="s1">END_LINE_AND_FIELD_STATE(START_FIELD);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">delim_whitespace) {</span>
                        <span class="s0">/* XXX 
                        * first character of a new record--need to back up and 
                        * reread 
                        * to handle properly... 
                        */</span>
                        <span class="s1">i--;</span>
                        <span class="s1">buf--;  </span><span class="s0">// back up one character (HACK!)</span>
                        <span class="s1">END_LINE_STATE(START_RECORD);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s0">// \r line terminator</span>
                        <span class="s0">// UGH. we don't actually want</span>
                        <span class="s0">// to consume the token. fix this later</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len = slen;</span>
                        <span class="s2">if </span><span class="s1">(end_line(self) &lt; </span><span class="s6">0</span><span class="s1">) {</span>
                            <span class="s2">goto </span><span class="s1">parsingerror;</span>
                        <span class="s1">}</span>

                        <span class="s1">stream = self</span><span class="s4">-&gt;</span><span class="s1">stream + self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>
                        <span class="s1">slen = self</span><span class="s4">-&gt;</span><span class="s1">stream_len;</span>
                        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>

                        <span class="s1">--i;</span>
                        <span class="s1">buf--;  </span><span class="s0">// let's try this character again (HACK!)</span>
                        <span class="s2">if </span><span class="s1">(line_limit &gt; </span><span class="s6">0 </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines == start_lines + line_limit) {</span>
                            <span class="s2">goto </span><span class="s1">linelimit;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>

            <span class="s0">// only occurs with non-custom line terminator,</span>
            <span class="s0">// which is why we directly check for '\n'</span>
            <span class="s2">case </span><span class="s1">EAT_CRNL_NOP:  </span><span class="s0">// inside an ignored comment line</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = START_RECORD;</span>
                <span class="s0">// \r line terminator -- parse this character again</span>
                <span class="s2">if </span><span class="s1">(c != </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">&amp;&amp; !IS_DELIMITER(c)) {</span>
                    <span class="s1">--i;</span>
                    <span class="s1">--buf;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_TOKEN_CLEANUP();</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;Finished tokenizing input</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">))</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>

<span class="s1">parsingerror:</span>
    <span class="s1">i++;</span>
    <span class="s1">_TOKEN_CLEANUP();</span>

    <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>

<span class="s1">linelimit:</span>
    <span class="s1">i++;</span>
    <span class="s1">_TOKEN_CLEANUP();</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static int </span><span class="s1">parser_handle_eof(parser_t *self) {</span>
    <span class="s1">int64_t bufsize = </span><span class="s6">100</span><span class="s1">;</span>

    <span class="s1">TRACE(</span>
        <span class="s1">(</span><span class="s3">&quot;handling eof, datalen: %d, pstate: %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">datalen, self</span><span class="s4">-&gt;</span><span class="s1">state))</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">datalen != </span><span class="s6">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>

    <span class="s2">switch </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">state) {</span>
        <span class="s2">case </span><span class="s1">START_RECORD:</span>
        <span class="s2">case </span><span class="s1">WHITESPACE_LINE:</span>
        <span class="s2">case </span><span class="s1">EAT_CRNL_NOP:</span>
        <span class="s2">case </span><span class="s1">EAT_LINE_COMMENT:</span>
            <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ESCAPE_IN_QUOTED_FIELD:</span>
        <span class="s2">case </span><span class="s1">IN_QUOTED_FIELD:</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = (</span><span class="s2">char </span><span class="s1">*)malloc(bufsize);</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                    <span class="s3">&quot;EOF inside string starting at row %&quot; </span><span class="s1">PRIu64,</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">file_lines);</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ESCAPED_CHAR:</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">error_msg = (</span><span class="s2">char </span><span class="s1">*)malloc(bufsize);</span>
            <span class="s1">snprintf(self</span><span class="s4">-&gt;</span><span class="s1">error_msg, bufsize,</span>
                     <span class="s3">&quot;EOF following escape character&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">IN_FIELD:</span>
        <span class="s2">case </span><span class="s1">START_FIELD:</span>
        <span class="s2">case </span><span class="s1">QUOTE_IN_QUOTED_FIELD:</span>
            <span class="s2">if </span><span class="s1">(end_field(self) &lt; </span><span class="s6">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(end_line(self) &lt; </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s2">else</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">parser_consume_rows(parser_t *self, size_t nrows) {</span>
    <span class="s1">int64_t offset, word_deletions;</span>
    <span class="s1">uint64_t char_count, i;</span>

    <span class="s2">if </span><span class="s1">(nrows &gt; self</span><span class="s4">-&gt;</span><span class="s1">lines) {</span>
        <span class="s1">nrows = self</span><span class="s4">-&gt;</span><span class="s1">lines;</span>
    <span class="s1">}</span>

    <span class="s0">/* do nothing */</span>
    <span class="s2">if </span><span class="s1">(nrows == </span><span class="s6">0</span><span class="s1">) </span><span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s0">/* cannot guarantee that nrows + 1 has been observed */</span>
    <span class="s1">word_deletions = self</span><span class="s4">-&gt;</span><span class="s1">line_start[nrows - </span><span class="s6">1</span><span class="s1">] + self</span><span class="s4">-&gt;</span><span class="s1">line_fields[nrows - </span><span class="s6">1</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(word_deletions &gt;= </span><span class="s6">1</span><span class="s1">) {</span>
        <span class="s1">char_count = (self</span><span class="s4">-&gt;</span><span class="s1">word_starts[word_deletions - </span><span class="s6">1</span><span class="s1">] +</span>
                      <span class="s1">strlen(self</span><span class="s4">-&gt;</span><span class="s1">words[word_deletions - </span><span class="s6">1</span><span class="s1">]) + </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* if word_deletions == 0 (i.e. this case) then char_count must 
         * be 0 too, as no data needs to be skipped */</span>
        <span class="s1">char_count = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">TRACE((</span><span class="s3">&quot;parser_consume_rows: Deleting %d words, %d chars</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, word_deletions,</span>
           <span class="s1">char_count));</span>

    <span class="s0">/* move stream, only if something to move */</span>
    <span class="s2">if </span><span class="s1">(char_count &lt; self</span><span class="s4">-&gt;</span><span class="s1">stream_len) {</span>
        <span class="s1">memmove(self</span><span class="s4">-&gt;</span><span class="s1">stream, (self</span><span class="s4">-&gt;</span><span class="s1">stream + char_count),</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len - char_count);</span>
    <span class="s1">}</span>
    <span class="s0">/* buffer counts */</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_len -= char_count;</span>

    <span class="s0">/* move token metadata */</span>
    <span class="s0">// Note: We should always have words_len &lt; word_deletions, so this</span>
    <span class="s0">//  subtraction will remain appropriately-typed.</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s6">0</span><span class="s1">; i &lt; self</span><span class="s4">-&gt;</span><span class="s1">words_len - word_deletions; ++i) {</span>
        <span class="s1">offset = i + word_deletions;</span>

        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words[i] = self</span><span class="s4">-&gt;</span><span class="s1">words[offset] - char_count;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts[i] = self</span><span class="s4">-&gt;</span><span class="s1">word_starts[offset] - char_count;</span>
    <span class="s1">}</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_len -= word_deletions;</span>

    <span class="s0">/* move current word pointer to stream */</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">pword_start -= char_count;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_start -= char_count;</span>

    <span class="s0">/* move line metadata */</span>
    <span class="s0">// Note: We should always have self-&gt;lines - nrows + 1 &gt;= 0, so this</span>
    <span class="s0">//  subtraction will remain appropriately-typed.</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s6">0</span><span class="s1">; i &lt; self</span><span class="s4">-&gt;</span><span class="s1">lines - nrows + </span><span class="s6">1</span><span class="s1">; ++i) {</span>
        <span class="s1">offset = i + nrows;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start[i] = self</span><span class="s4">-&gt;</span><span class="s1">line_start[offset] - word_deletions;</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields[i] = self</span><span class="s4">-&gt;</span><span class="s1">line_fields[offset];</span>
    <span class="s1">}</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines -= nrows;</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">size_t _next_pow2(size_t sz) {</span>
    <span class="s1">size_t result = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(result &lt; sz) result *= </span><span class="s6">2</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">parser_trim_buffers(parser_t *self) {</span>
    <span class="s0">/* 
      Free memory 
     */</span>
    <span class="s1">size_t new_cap;</span>
    <span class="s2">void </span><span class="s1">*newptr;</span>

    <span class="s1">uint64_t i;</span>

    <span class="s0">/** 
     * Before we free up space and trim, we should 
     * save how many words we saw when parsing, if 
     * it exceeds the maximum number we saw before. 
     * 
     * This is important for when we read in chunks, 
     * so that we can inform subsequent chunk parsing 
     * as to how many words we could possibly see. 
     */</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">words_cap &gt; self</span><span class="s4">-&gt;</span><span class="s1">max_words_cap) {</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">max_words_cap = self</span><span class="s4">-&gt;</span><span class="s1">words_cap;</span>
    <span class="s1">}</span>

    <span class="s0">/* trim words, word_starts */</span>
    <span class="s1">new_cap = _next_pow2(self</span><span class="s4">-&gt;</span><span class="s1">words_len) + </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(new_cap &lt; self</span><span class="s4">-&gt;</span><span class="s1">words_cap) {</span>
        <span class="s1">TRACE((</span><span class="s3">&quot;parser_trim_buffers: new_cap &lt; self-&gt;words_cap</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">));</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words = realloc(self</span><span class="s4">-&gt;</span><span class="s1">words, new_cap * </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">char </span><span class="s1">*));</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">words == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">}</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">word_starts = realloc(self</span><span class="s4">-&gt;</span><span class="s1">word_starts,</span>
                                    <span class="s1">new_cap * </span><span class="s2">sizeof</span><span class="s1">(int64_t));</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">word_starts == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">}</span>
        <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words_cap = new_cap;</span>
    <span class="s1">}</span>

    <span class="s0">/* trim stream */</span>
    <span class="s1">new_cap = _next_pow2(self</span><span class="s4">-&gt;</span><span class="s1">stream_len) + </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">TRACE(</span>
        <span class="s1">(</span><span class="s3">&quot;parser_trim_buffers: new_cap = %zu, stream_cap = %zu, lines_cap = &quot;</span>
         <span class="s3">&quot;%zu</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
         <span class="s1">new_cap, self</span><span class="s4">-&gt;</span><span class="s1">stream_cap, self</span><span class="s4">-&gt;</span><span class="s1">lines_cap));</span>
    <span class="s2">if </span><span class="s1">(new_cap &lt; self</span><span class="s4">-&gt;</span><span class="s1">stream_cap) {</span>
        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;parser_trim_buffers: new_cap &lt; self-&gt;stream_cap, calling &quot;</span>
             <span class="s3">&quot;realloc</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">));</span>
        <span class="s1">newptr = realloc(self</span><span class="s4">-&gt;</span><span class="s1">stream, new_cap);</span>
        <span class="s2">if </span><span class="s1">(newptr == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Update the pointers in the self-&gt;words array (char **) if</span>
            <span class="s0">// `realloc`</span>
            <span class="s0">//  moved the `self-&gt;stream` buffer. This block mirrors a similar</span>
            <span class="s0">//  block in</span>
            <span class="s0">//  `make_stream_space`.</span>
            <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">stream != newptr) {</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">pword_start = (</span><span class="s2">char </span><span class="s1">*)newptr + self</span><span class="s4">-&gt;</span><span class="s1">word_start;</span>

                <span class="s2">for </span><span class="s1">(i = </span><span class="s6">0</span><span class="s1">; i &lt; self</span><span class="s4">-&gt;</span><span class="s1">words_len; ++i) {</span>
                    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">words[i] = (</span><span class="s2">char </span><span class="s1">*)newptr + self</span><span class="s4">-&gt;</span><span class="s1">word_starts[i];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream = newptr;</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">stream_cap = new_cap;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/* trim line_start, line_fields */</span>
    <span class="s1">new_cap = _next_pow2(self</span><span class="s4">-&gt;</span><span class="s1">lines) + </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(new_cap &lt; self</span><span class="s4">-&gt;</span><span class="s1">lines_cap) {</span>
        <span class="s1">TRACE((</span><span class="s3">&quot;parser_trim_buffers: new_cap &lt; self-&gt;lines_cap</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">));</span>
        <span class="s1">newptr = realloc(self</span><span class="s4">-&gt;</span><span class="s1">line_start,</span>
                              <span class="s1">new_cap * </span><span class="s2">sizeof</span><span class="s1">(int64_t));</span>
        <span class="s2">if </span><span class="s1">(newptr == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_start = newptr;</span>
        <span class="s1">}</span>
        <span class="s1">newptr = realloc(self</span><span class="s4">-&gt;</span><span class="s1">line_fields,</span>
                              <span class="s1">new_cap * </span><span class="s2">sizeof</span><span class="s1">(int64_t));</span>
        <span class="s2">if </span><span class="s1">(newptr == NULL) {</span>
            <span class="s2">return </span><span class="s1">PARSER_OUT_OF_MEMORY;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">line_fields = newptr;</span>
            <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">lines_cap = new_cap;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/* 
  nrows : number of rows to tokenize (or until reach EOF) 
  all : tokenize all the data vs. certain number of rows 
 */</span>

<span class="s2">int </span><span class="s1">_tokenize_helper(parser_t *self, size_t nrows, </span><span class="s2">int </span><span class="s1">all,</span>
                     <span class="s2">const char </span><span class="s1">*encoding_errors) {</span>
    <span class="s2">int </span><span class="s1">status = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">uint64_t start_lines = self</span><span class="s4">-&gt;</span><span class="s1">lines;</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">state == FINISHED) {</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">TRACE((</span>
        <span class="s3">&quot;_tokenize_helper: Asked to tokenize %d rows, datapos=%d, datalen=%d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
        <span class="s1">nrows, self</span><span class="s4">-&gt;</span><span class="s1">datapos, self</span><span class="s4">-&gt;</span><span class="s1">datalen));</span>

    <span class="s2">while </span><span class="s1">(</span><span class="s6">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!all &amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">lines - start_lines &gt;= nrows) </span><span class="s2">break</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">datapos == self</span><span class="s4">-&gt;</span><span class="s1">datalen) {</span>
            <span class="s1">status = parser_buffer_bytes(self, self</span><span class="s4">-&gt;</span><span class="s1">chunksize,</span>
                                         <span class="s1">encoding_errors);</span>

            <span class="s2">if </span><span class="s1">(status == REACHED_EOF) {</span>
                <span class="s0">// close out last line</span>
                <span class="s1">status = parser_handle_eof(self);</span>
                <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">state = FINISHED;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(status != </span><span class="s6">0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">status;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">TRACE(</span>
            <span class="s1">(</span><span class="s3">&quot;_tokenize_helper: Trying to process %d bytes, datalen=%d, &quot;</span>
             <span class="s3">&quot;datapos= %d</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
             <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">datalen - self</span><span class="s4">-&gt;</span><span class="s1">datapos, self</span><span class="s4">-&gt;</span><span class="s1">datalen, self</span><span class="s4">-&gt;</span><span class="s1">datapos));</span>

        <span class="s1">status = tokenize_bytes(self, nrows, start_lines);</span>

        <span class="s2">if </span><span class="s1">(status &lt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s0">// XXX</span>
            <span class="s1">TRACE(</span>
                <span class="s1">(</span><span class="s3">&quot;_tokenize_helper: Status %d returned from tokenize_bytes, &quot;</span>
                 <span class="s3">&quot;breaking</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,</span>
                 <span class="s1">status));</span>
            <span class="s1">status = -</span><span class="s6">1</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TRACE((</span><span class="s3">&quot;leaving tokenize_helper</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">));</span>
    <span class="s2">return </span><span class="s1">status;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">tokenize_nrows(parser_t *self, size_t nrows, </span><span class="s2">const char </span><span class="s1">*encoding_errors) {</span>
    <span class="s2">int </span><span class="s1">status = _tokenize_helper(self, nrows, </span><span class="s6">0</span><span class="s1">, encoding_errors);</span>
    <span class="s2">return </span><span class="s1">status;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">tokenize_all_rows(parser_t *self, </span><span class="s2">const char </span><span class="s1">*encoding_errors) {</span>
    <span class="s2">int </span><span class="s1">status = _tokenize_helper(self, -</span><span class="s6">1</span><span class="s1">, </span><span class="s6">1</span><span class="s1">, encoding_errors);</span>
    <span class="s2">return </span><span class="s1">status;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Function: to_boolean 
 * -------------------- 
 * 
 * Validate if item should be recognized as a boolean field. 
 * 
 * item: const char* representing parsed text 
 * val : pointer to a uint8_t of boolean representation 
 * 
 * If item is determined to be boolean, this method will set 
 * the appropriate value of val and return 0. A non-zero exit 
 * status means that item was not inferred to be boolean, and 
 * leaves the value of *val unmodified. 
 */</span>
<span class="s2">int </span><span class="s1">to_boolean(</span><span class="s2">const char </span><span class="s1">*item, uint8_t *val) {</span>
    <span class="s2">if </span><span class="s1">(strcasecmp(item, </span><span class="s3">&quot;TRUE&quot;</span><span class="s1">) == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">*val = </span><span class="s6">1</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(strcasecmp(item, </span><span class="s3">&quot;FALSE&quot;</span><span class="s1">) == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">*val = </span><span class="s6">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// ---------------------------------------------------------------------------</span>
<span class="s0">// Implementation of xstrtod</span>

<span class="s0">//</span>
<span class="s0">// strtod.c</span>
<span class="s0">//</span>
<span class="s0">// Convert string to double</span>
<span class="s0">//</span>
<span class="s0">// Copyright (C) 2002 Michael Ringgaard. All rights reserved.</span>
<span class="s0">//</span>
<span class="s0">// Redistribution and use in source and binary forms, with or without</span>
<span class="s0">// modification, are permitted provided that the following conditions</span>
<span class="s0">// are met:</span>
<span class="s0">//</span>
<span class="s0">// 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">//    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">// 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="s0">//    notice, this list of conditions and the following disclaimer in the</span>
<span class="s0">//    documentation and/or other materials provided with the distribution.</span>
<span class="s0">// 3. Neither the name of the project nor the names of its contributors</span>
<span class="s0">//    may be used to endorse or promote products derived from this software</span>
<span class="s0">//    without specific prior written permission.</span>
<span class="s0">//</span>
<span class="s0">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="s0">// AND</span>
<span class="s0">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="s0">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0">// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="s0">// LIABLE</span>
<span class="s0">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="s0">// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="s0">// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="s0">// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<span class="s0">// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span class="s0">// SUCH DAMAGE.</span>
<span class="s0">//</span>
<span class="s0">// -----------------------------------------------------------------------</span>
<span class="s0">// Modifications by Warren Weckesser, March 2011:</span>
<span class="s0">// * Rename strtod() to xstrtod().</span>
<span class="s0">// * Added decimal and sci arguments.</span>
<span class="s0">// * Skip trailing spaces.</span>
<span class="s0">// * Commented out the other functions.</span>
<span class="s0">// Modifications by Richard T Guy, August 2013:</span>
<span class="s0">// * Add tsep argument for thousands separator</span>
<span class="s0">//</span>

<span class="s0">// pessimistic but quick assessment,</span>
<span class="s0">// assuming that each decimal digit requires 4 bits to store</span>
<span class="s2">const int </span><span class="s1">max_int_decimal_digits = (</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">unsigned int</span><span class="s1">) * </span><span class="s6">8</span><span class="s1">) / </span><span class="s6">4</span><span class="s1">;</span>

<span class="s2">double </span><span class="s1">xstrtod(</span><span class="s2">const char </span><span class="s1">*str, </span><span class="s2">char </span><span class="s1">**endptr, </span><span class="s2">char </span><span class="s1">decimal, </span><span class="s2">char </span><span class="s1">sci,</span>
               <span class="s2">char </span><span class="s1">tsep, </span><span class="s2">int </span><span class="s1">skip_trailing, </span><span class="s2">int </span><span class="s1">*error, </span><span class="s2">int </span><span class="s1">*maybe_int) {</span>
    <span class="s2">double </span><span class="s1">number;</span>
    <span class="s2">unsigned int </span><span class="s1">i_number = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">int </span><span class="s1">exponent;</span>
    <span class="s2">int </span><span class="s1">negative;</span>
    <span class="s2">char </span><span class="s1">*p = (</span><span class="s2">char </span><span class="s1">*)str;</span>
    <span class="s2">double </span><span class="s1">p10;</span>
    <span class="s2">int </span><span class="s1">n;</span>
    <span class="s2">int </span><span class="s1">num_digits;</span>
    <span class="s2">int </span><span class="s1">num_decimals;</span>

    <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s0">// Skip leading whitespace.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) p++;</span>

    <span class="s0">// Handle optional sign.</span>
    <span class="s1">negative = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">switch </span><span class="s1">(*p) {</span>
        <span class="s2">case </span><span class="s3">'-'</span><span class="s1">:</span>
            <span class="s1">negative = </span><span class="s6">1</span><span class="s1">;  </span><span class="s0">// Fall through to increment position.</span>
        <span class="s2">case </span><span class="s3">'+'</span><span class="s1">:</span>
            <span class="s1">p++;</span>
    <span class="s1">}</span>

    <span class="s1">exponent = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">num_digits = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">num_decimals = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s0">// Process string of digits.</span>
    <span class="s2">while </span><span class="s1">(isdigit_ascii(*p) &amp;&amp; num_digits &lt;= max_int_decimal_digits) {</span>
        <span class="s1">i_number = i_number * </span><span class="s6">10 </span><span class="s1">+ (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
        <span class="s1">p++;</span>
        <span class="s1">num_digits++;</span>

        <span class="s1">p += (tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">' </span><span class="s1">&amp;&amp; *p == tsep);</span>
    <span class="s1">}</span>
    <span class="s1">number = i_number;</span>

    <span class="s2">if </span><span class="s1">(num_digits &gt; max_int_decimal_digits) {</span>
        <span class="s0">// process what's left as double</span>
        <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
            <span class="s1">number = number * </span><span class="s6">10</span><span class="s1">. + (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
            <span class="s1">p++;</span>
            <span class="s1">num_digits++;</span>

            <span class="s1">p += (tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">' </span><span class="s1">&amp;&amp; *p == tsep);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Process decimal part.</span>
    <span class="s2">if </span><span class="s1">(*p == decimal) {</span>
        <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">p++;</span>

        <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
            <span class="s1">number = number * </span><span class="s6">10</span><span class="s1">. + (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
            <span class="s1">p++;</span>
            <span class="s1">num_digits++;</span>
            <span class="s1">num_decimals++;</span>
        <span class="s1">}</span>

        <span class="s1">exponent -= num_decimals;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(num_digits == </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">*error = ERANGE;</span>
        <span class="s2">return </span><span class="s6">0.0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Correct for sign.</span>
    <span class="s2">if </span><span class="s1">(negative) number = -number;</span>

    <span class="s0">// Process an exponent string.</span>
    <span class="s2">if </span><span class="s1">(toupper_ascii(*p) == toupper_ascii(sci)) {</span>
        <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">0</span><span class="s1">;</span>

        <span class="s0">// Handle optional sign.</span>
        <span class="s1">negative = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s2">switch </span><span class="s1">(*++p) {</span>
            <span class="s2">case </span><span class="s3">'-'</span><span class="s1">:</span>
                <span class="s1">negative = </span><span class="s6">1</span><span class="s1">;  </span><span class="s0">// Fall through to increment pos.</span>
            <span class="s2">case </span><span class="s3">'+'</span><span class="s1">:</span>
                <span class="s1">p++;</span>
        <span class="s1">}</span>

        <span class="s0">// Process string of digits.</span>
        <span class="s1">num_digits = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">n = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
            <span class="s1">n = n * </span><span class="s6">10 </span><span class="s1">+ (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
            <span class="s1">num_digits++;</span>
            <span class="s1">p++;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(negative)</span>
            <span class="s1">exponent -= n;</span>
        <span class="s2">else</span>
            <span class="s1">exponent += n;</span>

        <span class="s0">// If no digits, after the 'e'/'E', un-consume it</span>
        <span class="s2">if </span><span class="s1">(num_digits == </span><span class="s6">0</span><span class="s1">) p--;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(exponent &lt; DBL_MIN_EXP || exponent &gt; DBL_MAX_EXP) {</span>
        <span class="s1">*error = ERANGE;</span>
        <span class="s2">return </span><span class="s1">HUGE_VAL;</span>
    <span class="s1">}</span>

    <span class="s0">// Scale the result.</span>
    <span class="s1">p10 = </span><span class="s6">10</span><span class="s1">.;</span>
    <span class="s1">n = exponent;</span>
    <span class="s2">if </span><span class="s1">(n &lt; </span><span class="s6">0</span><span class="s1">) n = -n;</span>
    <span class="s2">while </span><span class="s1">(n) {</span>
        <span class="s2">if </span><span class="s1">(n &amp; </span><span class="s6">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(exponent &lt; </span><span class="s6">0</span><span class="s1">)</span>
                <span class="s1">number /= p10;</span>
            <span class="s2">else</span>
                <span class="s1">number *= p10;</span>
        <span class="s1">}</span>
        <span class="s1">n &gt;&gt;= </span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">p10 *= p10;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(number == HUGE_VAL) {</span>
        <span class="s1">*error = ERANGE;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(skip_trailing) {</span>
        <span class="s0">// Skip trailing whitespace.</span>
        <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) p++;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(endptr) *endptr = p;</span>
    <span class="s2">return </span><span class="s1">number;</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">precise_xstrtod(</span><span class="s2">const char </span><span class="s1">*str, </span><span class="s2">char </span><span class="s1">**endptr, </span><span class="s2">char </span><span class="s1">decimal,</span>
                       <span class="s2">char </span><span class="s1">sci, </span><span class="s2">char </span><span class="s1">tsep, </span><span class="s2">int </span><span class="s1">skip_trailing,</span>
                       <span class="s2">int </span><span class="s1">*error, </span><span class="s2">int </span><span class="s1">*maybe_int) {</span>
    <span class="s2">double </span><span class="s1">number;</span>
    <span class="s2">int </span><span class="s1">exponent;</span>
    <span class="s2">int </span><span class="s1">negative;</span>
    <span class="s2">char </span><span class="s1">*p = (</span><span class="s2">char </span><span class="s1">*)str;</span>
    <span class="s2">int </span><span class="s1">num_digits;</span>
    <span class="s2">int </span><span class="s1">num_decimals;</span>
    <span class="s2">int </span><span class="s1">max_digits = </span><span class="s6">17</span><span class="s1">;</span>
    <span class="s2">int </span><span class="s1">n;</span>

    <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s0">// Cache powers of 10 in memory.</span>
    <span class="s2">static double </span><span class="s1">e[] = {</span>
        <span class="s6">1</span><span class="s1">.,    </span><span class="s6">1</span><span class="s1">e1,   </span><span class="s6">1</span><span class="s1">e2,   </span><span class="s6">1</span><span class="s1">e3,   </span><span class="s6">1</span><span class="s1">e4,   </span><span class="s6">1</span><span class="s1">e5,   </span><span class="s6">1</span><span class="s1">e6,   </span><span class="s6">1</span><span class="s1">e7,   </span><span class="s6">1</span><span class="s1">e8,   </span><span class="s6">1</span><span class="s1">e9,</span>
        <span class="s6">1</span><span class="s1">e10,  </span><span class="s6">1</span><span class="s1">e11,  </span><span class="s6">1</span><span class="s1">e12,  </span><span class="s6">1</span><span class="s1">e13,  </span><span class="s6">1</span><span class="s1">e14,  </span><span class="s6">1</span><span class="s1">e15,  </span><span class="s6">1</span><span class="s1">e16,  </span><span class="s6">1</span><span class="s1">e17,  </span><span class="s6">1</span><span class="s1">e18,  </span><span class="s6">1</span><span class="s1">e19,</span>
        <span class="s6">1</span><span class="s1">e20,  </span><span class="s6">1</span><span class="s1">e21,  </span><span class="s6">1</span><span class="s1">e22,  </span><span class="s6">1</span><span class="s1">e23,  </span><span class="s6">1</span><span class="s1">e24,  </span><span class="s6">1</span><span class="s1">e25,  </span><span class="s6">1</span><span class="s1">e26,  </span><span class="s6">1</span><span class="s1">e27,  </span><span class="s6">1</span><span class="s1">e28,  </span><span class="s6">1</span><span class="s1">e29,</span>
        <span class="s6">1</span><span class="s1">e30,  </span><span class="s6">1</span><span class="s1">e31,  </span><span class="s6">1</span><span class="s1">e32,  </span><span class="s6">1</span><span class="s1">e33,  </span><span class="s6">1</span><span class="s1">e34,  </span><span class="s6">1</span><span class="s1">e35,  </span><span class="s6">1</span><span class="s1">e36,  </span><span class="s6">1</span><span class="s1">e37,  </span><span class="s6">1</span><span class="s1">e38,  </span><span class="s6">1</span><span class="s1">e39,</span>
        <span class="s6">1</span><span class="s1">e40,  </span><span class="s6">1</span><span class="s1">e41,  </span><span class="s6">1</span><span class="s1">e42,  </span><span class="s6">1</span><span class="s1">e43,  </span><span class="s6">1</span><span class="s1">e44,  </span><span class="s6">1</span><span class="s1">e45,  </span><span class="s6">1</span><span class="s1">e46,  </span><span class="s6">1</span><span class="s1">e47,  </span><span class="s6">1</span><span class="s1">e48,  </span><span class="s6">1</span><span class="s1">e49,</span>
        <span class="s6">1</span><span class="s1">e50,  </span><span class="s6">1</span><span class="s1">e51,  </span><span class="s6">1</span><span class="s1">e52,  </span><span class="s6">1</span><span class="s1">e53,  </span><span class="s6">1</span><span class="s1">e54,  </span><span class="s6">1</span><span class="s1">e55,  </span><span class="s6">1</span><span class="s1">e56,  </span><span class="s6">1</span><span class="s1">e57,  </span><span class="s6">1</span><span class="s1">e58,  </span><span class="s6">1</span><span class="s1">e59,</span>
        <span class="s6">1</span><span class="s1">e60,  </span><span class="s6">1</span><span class="s1">e61,  </span><span class="s6">1</span><span class="s1">e62,  </span><span class="s6">1</span><span class="s1">e63,  </span><span class="s6">1</span><span class="s1">e64,  </span><span class="s6">1</span><span class="s1">e65,  </span><span class="s6">1</span><span class="s1">e66,  </span><span class="s6">1</span><span class="s1">e67,  </span><span class="s6">1</span><span class="s1">e68,  </span><span class="s6">1</span><span class="s1">e69,</span>
        <span class="s6">1</span><span class="s1">e70,  </span><span class="s6">1</span><span class="s1">e71,  </span><span class="s6">1</span><span class="s1">e72,  </span><span class="s6">1</span><span class="s1">e73,  </span><span class="s6">1</span><span class="s1">e74,  </span><span class="s6">1</span><span class="s1">e75,  </span><span class="s6">1</span><span class="s1">e76,  </span><span class="s6">1</span><span class="s1">e77,  </span><span class="s6">1</span><span class="s1">e78,  </span><span class="s6">1</span><span class="s1">e79,</span>
        <span class="s6">1</span><span class="s1">e80,  </span><span class="s6">1</span><span class="s1">e81,  </span><span class="s6">1</span><span class="s1">e82,  </span><span class="s6">1</span><span class="s1">e83,  </span><span class="s6">1</span><span class="s1">e84,  </span><span class="s6">1</span><span class="s1">e85,  </span><span class="s6">1</span><span class="s1">e86,  </span><span class="s6">1</span><span class="s1">e87,  </span><span class="s6">1</span><span class="s1">e88,  </span><span class="s6">1</span><span class="s1">e89,</span>
        <span class="s6">1</span><span class="s1">e90,  </span><span class="s6">1</span><span class="s1">e91,  </span><span class="s6">1</span><span class="s1">e92,  </span><span class="s6">1</span><span class="s1">e93,  </span><span class="s6">1</span><span class="s1">e94,  </span><span class="s6">1</span><span class="s1">e95,  </span><span class="s6">1</span><span class="s1">e96,  </span><span class="s6">1</span><span class="s1">e97,  </span><span class="s6">1</span><span class="s1">e98,  </span><span class="s6">1</span><span class="s1">e99,</span>
        <span class="s6">1</span><span class="s1">e100, </span><span class="s6">1</span><span class="s1">e101, </span><span class="s6">1</span><span class="s1">e102, </span><span class="s6">1</span><span class="s1">e103, </span><span class="s6">1</span><span class="s1">e104, </span><span class="s6">1</span><span class="s1">e105, </span><span class="s6">1</span><span class="s1">e106, </span><span class="s6">1</span><span class="s1">e107, </span><span class="s6">1</span><span class="s1">e108, </span><span class="s6">1</span><span class="s1">e109,</span>
        <span class="s6">1</span><span class="s1">e110, </span><span class="s6">1</span><span class="s1">e111, </span><span class="s6">1</span><span class="s1">e112, </span><span class="s6">1</span><span class="s1">e113, </span><span class="s6">1</span><span class="s1">e114, </span><span class="s6">1</span><span class="s1">e115, </span><span class="s6">1</span><span class="s1">e116, </span><span class="s6">1</span><span class="s1">e117, </span><span class="s6">1</span><span class="s1">e118, </span><span class="s6">1</span><span class="s1">e119,</span>
        <span class="s6">1</span><span class="s1">e120, </span><span class="s6">1</span><span class="s1">e121, </span><span class="s6">1</span><span class="s1">e122, </span><span class="s6">1</span><span class="s1">e123, </span><span class="s6">1</span><span class="s1">e124, </span><span class="s6">1</span><span class="s1">e125, </span><span class="s6">1</span><span class="s1">e126, </span><span class="s6">1</span><span class="s1">e127, </span><span class="s6">1</span><span class="s1">e128, </span><span class="s6">1</span><span class="s1">e129,</span>
        <span class="s6">1</span><span class="s1">e130, </span><span class="s6">1</span><span class="s1">e131, </span><span class="s6">1</span><span class="s1">e132, </span><span class="s6">1</span><span class="s1">e133, </span><span class="s6">1</span><span class="s1">e134, </span><span class="s6">1</span><span class="s1">e135, </span><span class="s6">1</span><span class="s1">e136, </span><span class="s6">1</span><span class="s1">e137, </span><span class="s6">1</span><span class="s1">e138, </span><span class="s6">1</span><span class="s1">e139,</span>
        <span class="s6">1</span><span class="s1">e140, </span><span class="s6">1</span><span class="s1">e141, </span><span class="s6">1</span><span class="s1">e142, </span><span class="s6">1</span><span class="s1">e143, </span><span class="s6">1</span><span class="s1">e144, </span><span class="s6">1</span><span class="s1">e145, </span><span class="s6">1</span><span class="s1">e146, </span><span class="s6">1</span><span class="s1">e147, </span><span class="s6">1</span><span class="s1">e148, </span><span class="s6">1</span><span class="s1">e149,</span>
        <span class="s6">1</span><span class="s1">e150, </span><span class="s6">1</span><span class="s1">e151, </span><span class="s6">1</span><span class="s1">e152, </span><span class="s6">1</span><span class="s1">e153, </span><span class="s6">1</span><span class="s1">e154, </span><span class="s6">1</span><span class="s1">e155, </span><span class="s6">1</span><span class="s1">e156, </span><span class="s6">1</span><span class="s1">e157, </span><span class="s6">1</span><span class="s1">e158, </span><span class="s6">1</span><span class="s1">e159,</span>
        <span class="s6">1</span><span class="s1">e160, </span><span class="s6">1</span><span class="s1">e161, </span><span class="s6">1</span><span class="s1">e162, </span><span class="s6">1</span><span class="s1">e163, </span><span class="s6">1</span><span class="s1">e164, </span><span class="s6">1</span><span class="s1">e165, </span><span class="s6">1</span><span class="s1">e166, </span><span class="s6">1</span><span class="s1">e167, </span><span class="s6">1</span><span class="s1">e168, </span><span class="s6">1</span><span class="s1">e169,</span>
        <span class="s6">1</span><span class="s1">e170, </span><span class="s6">1</span><span class="s1">e171, </span><span class="s6">1</span><span class="s1">e172, </span><span class="s6">1</span><span class="s1">e173, </span><span class="s6">1</span><span class="s1">e174, </span><span class="s6">1</span><span class="s1">e175, </span><span class="s6">1</span><span class="s1">e176, </span><span class="s6">1</span><span class="s1">e177, </span><span class="s6">1</span><span class="s1">e178, </span><span class="s6">1</span><span class="s1">e179,</span>
        <span class="s6">1</span><span class="s1">e180, </span><span class="s6">1</span><span class="s1">e181, </span><span class="s6">1</span><span class="s1">e182, </span><span class="s6">1</span><span class="s1">e183, </span><span class="s6">1</span><span class="s1">e184, </span><span class="s6">1</span><span class="s1">e185, </span><span class="s6">1</span><span class="s1">e186, </span><span class="s6">1</span><span class="s1">e187, </span><span class="s6">1</span><span class="s1">e188, </span><span class="s6">1</span><span class="s1">e189,</span>
        <span class="s6">1</span><span class="s1">e190, </span><span class="s6">1</span><span class="s1">e191, </span><span class="s6">1</span><span class="s1">e192, </span><span class="s6">1</span><span class="s1">e193, </span><span class="s6">1</span><span class="s1">e194, </span><span class="s6">1</span><span class="s1">e195, </span><span class="s6">1</span><span class="s1">e196, </span><span class="s6">1</span><span class="s1">e197, </span><span class="s6">1</span><span class="s1">e198, </span><span class="s6">1</span><span class="s1">e199,</span>
        <span class="s6">1</span><span class="s1">e200, </span><span class="s6">1</span><span class="s1">e201, </span><span class="s6">1</span><span class="s1">e202, </span><span class="s6">1</span><span class="s1">e203, </span><span class="s6">1</span><span class="s1">e204, </span><span class="s6">1</span><span class="s1">e205, </span><span class="s6">1</span><span class="s1">e206, </span><span class="s6">1</span><span class="s1">e207, </span><span class="s6">1</span><span class="s1">e208, </span><span class="s6">1</span><span class="s1">e209,</span>
        <span class="s6">1</span><span class="s1">e210, </span><span class="s6">1</span><span class="s1">e211, </span><span class="s6">1</span><span class="s1">e212, </span><span class="s6">1</span><span class="s1">e213, </span><span class="s6">1</span><span class="s1">e214, </span><span class="s6">1</span><span class="s1">e215, </span><span class="s6">1</span><span class="s1">e216, </span><span class="s6">1</span><span class="s1">e217, </span><span class="s6">1</span><span class="s1">e218, </span><span class="s6">1</span><span class="s1">e219,</span>
        <span class="s6">1</span><span class="s1">e220, </span><span class="s6">1</span><span class="s1">e221, </span><span class="s6">1</span><span class="s1">e222, </span><span class="s6">1</span><span class="s1">e223, </span><span class="s6">1</span><span class="s1">e224, </span><span class="s6">1</span><span class="s1">e225, </span><span class="s6">1</span><span class="s1">e226, </span><span class="s6">1</span><span class="s1">e227, </span><span class="s6">1</span><span class="s1">e228, </span><span class="s6">1</span><span class="s1">e229,</span>
        <span class="s6">1</span><span class="s1">e230, </span><span class="s6">1</span><span class="s1">e231, </span><span class="s6">1</span><span class="s1">e232, </span><span class="s6">1</span><span class="s1">e233, </span><span class="s6">1</span><span class="s1">e234, </span><span class="s6">1</span><span class="s1">e235, </span><span class="s6">1</span><span class="s1">e236, </span><span class="s6">1</span><span class="s1">e237, </span><span class="s6">1</span><span class="s1">e238, </span><span class="s6">1</span><span class="s1">e239,</span>
        <span class="s6">1</span><span class="s1">e240, </span><span class="s6">1</span><span class="s1">e241, </span><span class="s6">1</span><span class="s1">e242, </span><span class="s6">1</span><span class="s1">e243, </span><span class="s6">1</span><span class="s1">e244, </span><span class="s6">1</span><span class="s1">e245, </span><span class="s6">1</span><span class="s1">e246, </span><span class="s6">1</span><span class="s1">e247, </span><span class="s6">1</span><span class="s1">e248, </span><span class="s6">1</span><span class="s1">e249,</span>
        <span class="s6">1</span><span class="s1">e250, </span><span class="s6">1</span><span class="s1">e251, </span><span class="s6">1</span><span class="s1">e252, </span><span class="s6">1</span><span class="s1">e253, </span><span class="s6">1</span><span class="s1">e254, </span><span class="s6">1</span><span class="s1">e255, </span><span class="s6">1</span><span class="s1">e256, </span><span class="s6">1</span><span class="s1">e257, </span><span class="s6">1</span><span class="s1">e258, </span><span class="s6">1</span><span class="s1">e259,</span>
        <span class="s6">1</span><span class="s1">e260, </span><span class="s6">1</span><span class="s1">e261, </span><span class="s6">1</span><span class="s1">e262, </span><span class="s6">1</span><span class="s1">e263, </span><span class="s6">1</span><span class="s1">e264, </span><span class="s6">1</span><span class="s1">e265, </span><span class="s6">1</span><span class="s1">e266, </span><span class="s6">1</span><span class="s1">e267, </span><span class="s6">1</span><span class="s1">e268, </span><span class="s6">1</span><span class="s1">e269,</span>
        <span class="s6">1</span><span class="s1">e270, </span><span class="s6">1</span><span class="s1">e271, </span><span class="s6">1</span><span class="s1">e272, </span><span class="s6">1</span><span class="s1">e273, </span><span class="s6">1</span><span class="s1">e274, </span><span class="s6">1</span><span class="s1">e275, </span><span class="s6">1</span><span class="s1">e276, </span><span class="s6">1</span><span class="s1">e277, </span><span class="s6">1</span><span class="s1">e278, </span><span class="s6">1</span><span class="s1">e279,</span>
        <span class="s6">1</span><span class="s1">e280, </span><span class="s6">1</span><span class="s1">e281, </span><span class="s6">1</span><span class="s1">e282, </span><span class="s6">1</span><span class="s1">e283, </span><span class="s6">1</span><span class="s1">e284, </span><span class="s6">1</span><span class="s1">e285, </span><span class="s6">1</span><span class="s1">e286, </span><span class="s6">1</span><span class="s1">e287, </span><span class="s6">1</span><span class="s1">e288, </span><span class="s6">1</span><span class="s1">e289,</span>
        <span class="s6">1</span><span class="s1">e290, </span><span class="s6">1</span><span class="s1">e291, </span><span class="s6">1</span><span class="s1">e292, </span><span class="s6">1</span><span class="s1">e293, </span><span class="s6">1</span><span class="s1">e294, </span><span class="s6">1</span><span class="s1">e295, </span><span class="s6">1</span><span class="s1">e296, </span><span class="s6">1</span><span class="s1">e297, </span><span class="s6">1</span><span class="s1">e298, </span><span class="s6">1</span><span class="s1">e299,</span>
        <span class="s6">1</span><span class="s1">e300, </span><span class="s6">1</span><span class="s1">e301, </span><span class="s6">1</span><span class="s1">e302, </span><span class="s6">1</span><span class="s1">e303, </span><span class="s6">1</span><span class="s1">e304, </span><span class="s6">1</span><span class="s1">e305, </span><span class="s6">1</span><span class="s1">e306, </span><span class="s6">1</span><span class="s1">e307, </span><span class="s6">1</span><span class="s1">e308};</span>

    <span class="s0">// Skip leading whitespace.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) p++;</span>

    <span class="s0">// Handle optional sign.</span>
    <span class="s1">negative = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">switch </span><span class="s1">(*p) {</span>
        <span class="s2">case </span><span class="s3">'-'</span><span class="s1">:</span>
            <span class="s1">negative = </span><span class="s6">1</span><span class="s1">;  </span><span class="s0">// Fall through to increment position.</span>
        <span class="s2">case </span><span class="s3">'+'</span><span class="s1">:</span>
            <span class="s1">p++;</span>
    <span class="s1">}</span>

    <span class="s1">number = </span><span class="s6">0</span><span class="s1">.;</span>
    <span class="s1">exponent = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">num_digits = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">num_decimals = </span><span class="s6">0</span><span class="s1">;</span>

    <span class="s0">// Process string of digits.</span>
    <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
        <span class="s2">if </span><span class="s1">(num_digits &lt; max_digits) {</span>
            <span class="s1">number = number * </span><span class="s6">10</span><span class="s1">. + (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
            <span class="s1">num_digits++;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">++exponent;</span>
        <span class="s1">}</span>

        <span class="s1">p++;</span>
        <span class="s1">p += (tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">' </span><span class="s1">&amp;&amp; *p == tsep);</span>
    <span class="s1">}</span>

    <span class="s0">// Process decimal part</span>
    <span class="s2">if </span><span class="s1">(*p == decimal) {</span>
        <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">p++;</span>

        <span class="s2">while </span><span class="s1">(num_digits &lt; max_digits &amp;&amp; isdigit_ascii(*p)) {</span>
            <span class="s1">number = number * </span><span class="s6">10</span><span class="s1">. + (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
            <span class="s1">p++;</span>
            <span class="s1">num_digits++;</span>
            <span class="s1">num_decimals++;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(num_digits &gt;= max_digits)  </span><span class="s0">// Consume extra decimal digits.</span>
            <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) ++p;</span>

        <span class="s1">exponent -= num_decimals;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(num_digits == </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">*error = ERANGE;</span>
        <span class="s2">return </span><span class="s6">0.0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Correct for sign.</span>
    <span class="s2">if </span><span class="s1">(negative) number = -number;</span>

    <span class="s0">// Process an exponent string.</span>
    <span class="s2">if </span><span class="s1">(toupper_ascii(*p) == toupper_ascii(sci)) {</span>
        <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">0</span><span class="s1">;</span>

        <span class="s0">// Handle optional sign</span>
        <span class="s1">negative = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s2">switch </span><span class="s1">(*++p) {</span>
            <span class="s2">case </span><span class="s3">'-'</span><span class="s1">:</span>
                <span class="s1">negative = </span><span class="s6">1</span><span class="s1">;  </span><span class="s0">// Fall through to increment pos.</span>
            <span class="s2">case </span><span class="s3">'+'</span><span class="s1">:</span>
                <span class="s1">p++;</span>
        <span class="s1">}</span>

        <span class="s0">// Process string of digits.</span>
        <span class="s1">num_digits = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">n = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s2">while </span><span class="s1">(num_digits &lt; max_digits &amp;&amp; isdigit_ascii(*p)) {</span>
            <span class="s1">n = n * </span><span class="s6">10 </span><span class="s1">+ (*p - </span><span class="s3">'0'</span><span class="s1">);</span>
            <span class="s1">num_digits++;</span>
            <span class="s1">p++;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(negative)</span>
            <span class="s1">exponent -= n;</span>
        <span class="s2">else</span>
            <span class="s1">exponent += n;</span>

        <span class="s0">// If no digits after the 'e'/'E', un-consume it.</span>
        <span class="s2">if </span><span class="s1">(num_digits == </span><span class="s6">0</span><span class="s1">) p--;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(exponent &gt; </span><span class="s6">308</span><span class="s1">) {</span>
        <span class="s1">*error = ERANGE;</span>
        <span class="s2">return </span><span class="s1">HUGE_VAL;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(exponent &gt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">number *= e[exponent];</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(exponent &lt; -</span><span class="s6">308</span><span class="s1">) {  </span><span class="s0">// Subnormal</span>
        <span class="s2">if </span><span class="s1">(exponent &lt; -</span><span class="s6">616</span><span class="s1">) {  </span><span class="s0">// Prevent invalid array access.</span>
            <span class="s1">number = </span><span class="s6">0</span><span class="s1">.;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">number /= e[-</span><span class="s6">308 </span><span class="s1">- exponent];</span>
            <span class="s1">number /= e[</span><span class="s6">308</span><span class="s1">];</span>
        <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">number /= e[-exponent];</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(number == HUGE_VAL || number == -HUGE_VAL) *error = ERANGE;</span>

    <span class="s2">if </span><span class="s1">(skip_trailing) {</span>
        <span class="s0">// Skip trailing whitespace.</span>
        <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) p++;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(endptr) *endptr = p;</span>
    <span class="s2">return </span><span class="s1">number;</span>
<span class="s1">}</span>

<span class="s0">/* copy a decimal number string with `decimal`, `tsep` as decimal point 
   and thousands separator to an equivalent c-locale decimal string (striping 
   `tsep`, replacing `decimal` with '.'). The returned memory should be free-d 
   with a call to `free`. 
*/</span>

<span class="s2">char</span><span class="s1">* _str_copy_decimal_str_c(</span><span class="s2">const char </span><span class="s1">*s, </span><span class="s2">char </span><span class="s1">**endpos, </span><span class="s2">char </span><span class="s1">decimal,</span>
                              <span class="s2">char </span><span class="s1">tsep) {</span>
    <span class="s2">const char </span><span class="s1">*p = s;</span>
    <span class="s1">size_t length = strlen(s);</span>
    <span class="s2">char </span><span class="s1">*s_copy = malloc(length + </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s2">char </span><span class="s1">*dst = s_copy;</span>
    <span class="s0">// Skip leading whitespace.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) p++;</span>
    <span class="s0">// Copy Leading sign</span>
    <span class="s2">if </span><span class="s1">(*p == </span><span class="s3">'+' </span><span class="s1">|| *p == </span><span class="s3">'-'</span><span class="s1">) {</span>
        <span class="s1">*dst++ = *p++;</span>
    <span class="s1">}</span>
    <span class="s0">// Copy integer part dropping `tsep`</span>
    <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
        <span class="s1">*dst++ = *p++;</span>
        <span class="s1">p += (tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">' </span><span class="s1">&amp;&amp; *p == tsep);</span>
    <span class="s1">}</span>
    <span class="s0">// Replace `decimal` with '.'</span>
    <span class="s2">if </span><span class="s1">(*p == decimal) {</span>
       <span class="s1">*dst++ = </span><span class="s3">'.'</span><span class="s1">;</span>
       <span class="s1">p++;</span>
    <span class="s1">}</span>
    <span class="s0">// Copy fractional part after decimal (if any)</span>
    <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
       <span class="s1">*dst++ = *p++;</span>
    <span class="s1">}</span>
    <span class="s0">// Copy exponent if any</span>
    <span class="s2">if </span><span class="s1">(toupper_ascii(*p) == toupper_ascii(</span><span class="s3">'E'</span><span class="s1">)) {</span>
       <span class="s1">*dst++ = *p++;</span>
       <span class="s0">// Copy leading exponent sign (if any)</span>
       <span class="s2">if </span><span class="s1">(*p == </span><span class="s3">'+' </span><span class="s1">|| *p == </span><span class="s3">'-'</span><span class="s1">) {</span>
           <span class="s1">*dst++ = *p++;</span>
       <span class="s1">}</span>
       <span class="s0">// Copy exponent digits</span>
       <span class="s2">while </span><span class="s1">(isdigit_ascii(*p)) {</span>
           <span class="s1">*dst++ = *p++;</span>
       <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">*dst++ = </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">;  </span><span class="s0">// terminate</span>
    <span class="s2">if </span><span class="s1">(endpos != NULL)</span>
        <span class="s1">*endpos = (</span><span class="s2">char </span><span class="s1">*)p;</span>
    <span class="s2">return </span><span class="s1">s_copy;</span>
<span class="s1">}</span>


<span class="s2">double </span><span class="s1">round_trip(</span><span class="s2">const char </span><span class="s1">*p, </span><span class="s2">char </span><span class="s1">**q, </span><span class="s2">char </span><span class="s1">decimal, </span><span class="s2">char </span><span class="s1">sci, </span><span class="s2">char </span><span class="s1">tsep,</span>
                  <span class="s2">int </span><span class="s1">skip_trailing, </span><span class="s2">int </span><span class="s1">*error, </span><span class="s2">int </span><span class="s1">*maybe_int) {</span>
    <span class="s0">// 'normalize' representation to C-locale; replace decimal with '.' and</span>
    <span class="s0">// remove t(housand)sep.</span>
    <span class="s2">char </span><span class="s1">*endptr;</span>
    <span class="s2">char </span><span class="s1">*pc = _str_copy_decimal_str_c(p, &amp;endptr, decimal, tsep);</span>
    <span class="s0">// This is called from a nogil block in parsers.pyx</span>
    <span class="s0">// so need to explicitly get GIL before Python calls</span>
    <span class="s1">PyGILState_STATE gstate;</span>
    <span class="s1">gstate = PyGILState_Ensure();</span>
    <span class="s2">char </span><span class="s1">*endpc;</span>
    <span class="s2">double </span><span class="s1">r = PyOS_string_to_double(pc, &amp;endpc, </span><span class="s6">0</span><span class="s1">);</span>
    <span class="s0">// PyOS_string_to_double needs to consume the whole string</span>
    <span class="s2">if </span><span class="s1">(endpc == pc + strlen(pc)) {</span>
        <span class="s2">if </span><span class="s1">(q != NULL) {</span>
           <span class="s0">// report endptr from source string (p)</span>
            <span class="s1">*q = endptr;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">*error = -</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(q != NULL) {</span>
           <span class="s0">// p and pc are different len due to tsep removal. Can't report</span>
           <span class="s0">// how much it has consumed of p. Just rewind to beginning.</span>
           <span class="s1">*q = (</span><span class="s2">char </span><span class="s1">*)p;  </span><span class="s0">// TODO(willayd): this could be undefined behavior</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(maybe_int != NULL) *maybe_int = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(PyErr_Occurred() != NULL) *error = -</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s2">else if </span><span class="s1">(r == Py_HUGE_VAL) *error = (</span><span class="s2">int</span><span class="s1">)Py_HUGE_VAL;</span>
    <span class="s1">PyErr_Clear();</span>

    <span class="s1">PyGILState_Release(gstate);</span>
    <span class="s1">free(pc);</span>
    <span class="s2">if </span><span class="s1">(skip_trailing &amp;&amp; q != NULL &amp;&amp; *q != p) {</span>
        <span class="s2">while </span><span class="s1">(isspace_ascii(**q)) {</span>
            <span class="s1">(*q)++;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">r;</span>
<span class="s1">}</span>

<span class="s0">// End of xstrtod code</span>
<span class="s0">// ---------------------------------------------------------------------------</span>

<span class="s2">void </span><span class="s1">uint_state_init(uint_state *self) {</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">seen_sint = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">seen_uint = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">seen_null = </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">uint64_conflict(uint_state *self) {</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">seen_uint &amp;&amp; (self</span><span class="s4">-&gt;</span><span class="s1">seen_sint || self</span><span class="s4">-&gt;</span><span class="s1">seen_null);</span>
<span class="s1">}</span>

<span class="s1">int64_t str_to_int64(</span><span class="s2">const char </span><span class="s1">*p_item, int64_t int_min, int64_t int_max,</span>
                     <span class="s2">int </span><span class="s1">*error, </span><span class="s2">char </span><span class="s1">tsep) {</span>
    <span class="s2">const char </span><span class="s1">*p = p_item;</span>
    <span class="s2">int </span><span class="s1">isneg = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">int64_t number = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">int </span><span class="s1">d;</span>

    <span class="s0">// Skip leading spaces.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) {</span>
        <span class="s1">++p;</span>
    <span class="s1">}</span>

    <span class="s0">// Handle sign.</span>
    <span class="s2">if </span><span class="s1">(*p == </span><span class="s3">'-'</span><span class="s1">) {</span>
        <span class="s1">isneg = </span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">++p;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(*p == </span><span class="s3">'+'</span><span class="s1">) {</span>
        <span class="s1">p++;</span>
    <span class="s1">}</span>

    <span class="s0">// Check that there is a first digit.</span>
    <span class="s2">if </span><span class="s1">(!isdigit_ascii(*p)) {</span>
        <span class="s0">// Error...</span>
        <span class="s1">*error = ERROR_NO_DIGITS;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isneg) {</span>
        <span class="s0">// If number is greater than pre_min, at least one more digit</span>
        <span class="s0">// can be processed without overflowing.</span>
        <span class="s2">int </span><span class="s1">dig_pre_min = -(int_min % </span><span class="s6">10</span><span class="s1">);</span>
        <span class="s1">int64_t pre_min = int_min / </span><span class="s6">10</span><span class="s1">;</span>

        <span class="s0">// Process the digits.</span>
        <span class="s1">d = *p;</span>
        <span class="s2">if </span><span class="s1">(tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) {</span>
            <span class="s2">while </span><span class="s1">(</span><span class="s6">1</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(d == tsep) {</span>
                    <span class="s1">d = *++p;</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isdigit_ascii(d)) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((number &gt; pre_min) ||</span>
                    <span class="s1">((number == pre_min) &amp;&amp; (d - </span><span class="s3">'0' </span><span class="s1">&lt;= dig_pre_min))) {</span>
                    <span class="s1">number = number * </span><span class="s6">10 </span><span class="s1">- (d - </span><span class="s3">'0'</span><span class="s1">);</span>
                    <span class="s1">d = *++p;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">*error = ERROR_OVERFLOW;</span>
                    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">while </span><span class="s1">(isdigit_ascii(d)) {</span>
                <span class="s2">if </span><span class="s1">((number &gt; pre_min) ||</span>
                    <span class="s1">((number == pre_min) &amp;&amp; (d - </span><span class="s3">'0' </span><span class="s1">&lt;= dig_pre_min))) {</span>
                    <span class="s1">number = number * </span><span class="s6">10 </span><span class="s1">- (d - </span><span class="s3">'0'</span><span class="s1">);</span>
                    <span class="s1">d = *++p;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">*error = ERROR_OVERFLOW;</span>
                    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// If number is less than pre_max, at least one more digit</span>
        <span class="s0">// can be processed without overflowing.</span>
        <span class="s1">int64_t pre_max = int_max / </span><span class="s6">10</span><span class="s1">;</span>
        <span class="s2">int </span><span class="s1">dig_pre_max = int_max % </span><span class="s6">10</span><span class="s1">;</span>

        <span class="s0">// Process the digits.</span>
        <span class="s1">d = *p;</span>
        <span class="s2">if </span><span class="s1">(tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) {</span>
            <span class="s2">while </span><span class="s1">(</span><span class="s6">1</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(d == tsep) {</span>
                    <span class="s1">d = *++p;</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isdigit_ascii(d)) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((number &lt; pre_max) ||</span>
                    <span class="s1">((number == pre_max) &amp;&amp; (d - </span><span class="s3">'0' </span><span class="s1">&lt;= dig_pre_max))) {</span>
                    <span class="s1">number = number * </span><span class="s6">10 </span><span class="s1">+ (d - </span><span class="s3">'0'</span><span class="s1">);</span>
                    <span class="s1">d = *++p;</span>

                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">*error = ERROR_OVERFLOW;</span>
                    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">while </span><span class="s1">(isdigit_ascii(d)) {</span>
                <span class="s2">if </span><span class="s1">((number &lt; pre_max) ||</span>
                    <span class="s1">((number == pre_max) &amp;&amp; (d - </span><span class="s3">'0' </span><span class="s1">&lt;= dig_pre_max))) {</span>
                    <span class="s1">number = number * </span><span class="s6">10 </span><span class="s1">+ (d - </span><span class="s3">'0'</span><span class="s1">);</span>
                    <span class="s1">d = *++p;</span>

                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">*error = ERROR_OVERFLOW;</span>
                    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Skip trailing spaces.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) {</span>
        <span class="s1">++p;</span>
    <span class="s1">}</span>

    <span class="s0">// Did we use up all the characters?</span>
    <span class="s2">if </span><span class="s1">(*p) {</span>
        <span class="s1">*error = ERROR_INVALID_CHARS;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">*error = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">number;</span>
<span class="s1">}</span>

<span class="s1">uint64_t str_to_uint64(uint_state *state, </span><span class="s2">const char </span><span class="s1">*p_item, int64_t int_max,</span>
                       <span class="s1">uint64_t uint_max, </span><span class="s2">int </span><span class="s1">*error, </span><span class="s2">char </span><span class="s1">tsep) {</span>
    <span class="s2">const char </span><span class="s1">*p = p_item;</span>
    <span class="s1">uint64_t pre_max = uint_max / </span><span class="s6">10</span><span class="s1">;</span>
    <span class="s2">int </span><span class="s1">dig_pre_max = uint_max % </span><span class="s6">10</span><span class="s1">;</span>
    <span class="s1">uint64_t number = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">int </span><span class="s1">d;</span>

    <span class="s0">// Skip leading spaces.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) {</span>
        <span class="s1">++p;</span>
    <span class="s1">}</span>

    <span class="s0">// Handle sign.</span>
    <span class="s2">if </span><span class="s1">(*p == </span><span class="s3">'-'</span><span class="s1">) {</span>
        <span class="s1">state</span><span class="s4">-&gt;</span><span class="s1">seen_sint = </span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">*error = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(*p == </span><span class="s3">'+'</span><span class="s1">) {</span>
        <span class="s1">p++;</span>
    <span class="s1">}</span>

    <span class="s0">// Check that there is a first digit.</span>
    <span class="s2">if </span><span class="s1">(!isdigit_ascii(*p)) {</span>
        <span class="s0">// Error...</span>
        <span class="s1">*error = ERROR_NO_DIGITS;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// If number is less than pre_max, at least one more digit</span>
    <span class="s0">// can be processed without overflowing.</span>
    <span class="s0">//</span>
    <span class="s0">// Process the digits.</span>
    <span class="s1">d = *p;</span>
    <span class="s2">if </span><span class="s1">(tsep != </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">) {</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s6">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(d == tsep) {</span>
                <span class="s1">d = *++p;</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isdigit_ascii(d)) {</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((number &lt; pre_max) ||</span>
                <span class="s1">((number == pre_max) &amp;&amp; (d - </span><span class="s3">'0' </span><span class="s1">&lt;= dig_pre_max))) {</span>
                <span class="s1">number = number * </span><span class="s6">10 </span><span class="s1">+ (d - </span><span class="s3">'0'</span><span class="s1">);</span>
                <span class="s1">d = *++p;</span>

            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">*error = ERROR_OVERFLOW;</span>
                <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">while </span><span class="s1">(isdigit_ascii(d)) {</span>
            <span class="s2">if </span><span class="s1">((number &lt; pre_max) ||</span>
                <span class="s1">((number == pre_max) &amp;&amp; (d - </span><span class="s3">'0' </span><span class="s1">&lt;= dig_pre_max))) {</span>
                <span class="s1">number = number * </span><span class="s6">10 </span><span class="s1">+ (d - </span><span class="s3">'0'</span><span class="s1">);</span>
                <span class="s1">d = *++p;</span>

            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">*error = ERROR_OVERFLOW;</span>
                <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Skip trailing spaces.</span>
    <span class="s2">while </span><span class="s1">(isspace_ascii(*p)) {</span>
        <span class="s1">++p;</span>
    <span class="s1">}</span>

    <span class="s0">// Did we use up all the characters?</span>
    <span class="s2">if </span><span class="s1">(*p) {</span>
        <span class="s1">*error = ERROR_INVALID_CHARS;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(number &gt; (uint64_t)int_max) {</span>
        <span class="s1">state</span><span class="s4">-&gt;</span><span class="s1">seen_uint = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">*error = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">number;</span>
<span class="s1">}</span>
</pre>
</body>
</html>