<html>
<head>
<title>asserters.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
asserters.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">cast</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs.lib </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">NoDefault</span><span class="s0">,</span>
    <span class="s1">no_default</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.missing </span><span class="s0">import </span><span class="s1">is_matching_na</span>
<span class="s0">import </span><span class="s1">pandas._libs.testing </span><span class="s0">as </span><span class="s1">_testing</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s0">,</span>
    <span class="s1">is_categorical_dtype</span><span class="s0">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s0">,</span>
    <span class="s1">is_interval_dtype</span><span class="s0">,</span>
    <span class="s1">is_number</span><span class="s0">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s0">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CategoricalDtype</span><span class="s0">,</span>
    <span class="s1">PandasDtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">array_equivalent</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">IntervalIndex</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">PeriodIndex</span><span class="s0">,</span>
    <span class="s1">RangeIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.algorithms </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">safe_sort</span><span class="s0">,</span>
    <span class="s1">take_nd</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
    <span class="s1">ExtensionArray</span><span class="s0">,</span>
    <span class="s1">IntervalArray</span><span class="s0">,</span>
    <span class="s1">PeriodArray</span><span class="s0">,</span>
    <span class="s1">TimedeltaArray</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.datetimelike </span><span class="s0">import </span><span class="s1">DatetimeLikeArrayMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s0">import </span><span class="s1">StringDtype</span>

<span class="s0">from </span><span class="s1">pandas.io.formats.printing </span><span class="s0">import </span><span class="s1">pprint_thing</span>


<span class="s0">def </span><span class="s1">assert_almost_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype: bool | str = </span><span class="s2">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_less_precise: bool | int | NoDefault = no_default</span><span class="s0">,</span>
    <span class="s1">rtol: float = </span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol: float = </span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that the left and right objects are approximately equal. 
 
    By approximately equal, we refer to objects that are numbers or that 
    contain numbers which may be equivalent to specific levels of precision. 
 
    Parameters 
    ---------- 
    left : object 
    right : object 
    check_dtype : bool or {'equiv'}, default 'equiv' 
        Check dtype if both a and b are the same type. If 'equiv' is passed in, 
        then `RangeIndex` and `Int64Index` are also considered equivalent 
        when doing type checking. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. 5 digits (False) or 3 digits (True) 
        after decimal points are compared. If int, then specify the number 
        of digits to compare. 
 
        When comparing two numbers, if the first number has magnitude less 
        than 1e-5, we compare the two numbers directly and check whether 
        they are equivalent within the specified precision. Otherwise, we 
        compare the **ratio** of the second number to the first number and 
        check whether it is equivalent to 1 within the specified precision. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    rtol : float, default 1e-5 
        Relative tolerance. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. 
 
        .. versionadded:: 1.1.0 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s2">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s2">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s5"># https://github.com/python/mypy/issues/7642</span>
        <span class="s5"># error: Argument 1 to &quot;_get_tol_from_less_precise&quot; has incompatible</span>
        <span class="s5"># type &quot;Union[bool, int, NoDefault]&quot;; expected &quot;Union[bool, int]&quot;</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(</span>
            <span class="s1">check_less_precise  </span><span class="s5"># type: ignore[arg-type]</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">Index):</span>
        <span class="s1">assert_index_equal(</span>
            <span class="s1">left</span><span class="s0">,</span>
            <span class="s1">right</span><span class="s0">,</span>
            <span class="s1">check_exact=</span><span class="s0">False,</span>
            <span class="s1">exact=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">assert_series_equal(</span>
            <span class="s1">left</span><span class="s0">,</span>
            <span class="s1">right</span><span class="s0">,</span>
            <span class="s1">check_exact=</span><span class="s0">False,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s1">assert_frame_equal(</span>
            <span class="s1">left</span><span class="s0">,</span>
            <span class="s1">right</span><span class="s0">,</span>
            <span class="s1">check_exact=</span><span class="s0">False,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># Other sequences.</span>
        <span class="s0">if </span><span class="s1">check_dtype:</span>
            <span class="s0">if </span><span class="s1">is_number(left) </span><span class="s0">and </span><span class="s1">is_number(right):</span>
                <span class="s5"># Do not compare numeric classes, like np.float64 and float.</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">is_bool(left) </span><span class="s0">and </span><span class="s1">is_bool(right):</span>
                <span class="s5"># Do not compare bool classes, like np.bool_ and bool.</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                    <span class="s1">obj = </span><span class="s2">&quot;numpy array&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">obj = </span><span class="s2">&quot;Input&quot;</span>
                <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

        <span class="s5"># if we have &quot;equiv&quot;, this becomes True</span>
        <span class="s1">check_dtype = bool(check_dtype)</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get_tol_from_less_precise(check_less_precise: bool | int) -&gt; float:</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the tolerance equivalent to the deprecated `check_less_precise` 
    parameter. 
 
    Parameters 
    ---------- 
    check_less_precise : bool or int 
 
    Returns 
    ------- 
    float 
        Tolerance to be used as relative/absolute tolerance. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; # Using check_less_precise as a bool: 
    &gt;&gt;&gt; _get_tol_from_less_precise(False) 
    5e-06 
    &gt;&gt;&gt; _get_tol_from_less_precise(True) 
    0.0005 
    &gt;&gt;&gt; # Using check_less_precise as an int representing the decimal 
    &gt;&gt;&gt; # tolerance intended: 
    &gt;&gt;&gt; _get_tol_from_less_precise(2) 
    0.005 
    &gt;&gt;&gt; _get_tol_from_less_precise(8) 
    5e-09 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(check_less_precise</span><span class="s0">, </span><span class="s1">bool):</span>
        <span class="s0">if </span><span class="s1">check_less_precise:</span>
            <span class="s5"># 3-digit tolerance</span>
            <span class="s0">return </span><span class="s3">0.5e-3</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># 5-digit tolerance</span>
            <span class="s0">return </span><span class="s3">0.5e-5</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># Equivalent to setting checking_less_precise=&lt;decimals&gt;</span>
        <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">* </span><span class="s3">10 </span><span class="s1">** -check_less_precise</span>


<span class="s0">def </span><span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">cls):</span>
    <span class="s4">&quot;&quot;&quot; 
    Helper method for our assert_* methods that ensures that 
    the two objects being compared have the right type before 
    proceeding with the comparison. 
 
    Parameters 
    ---------- 
    left : The first object being compared. 
    right : The second object being compared. 
    cls : The class type to check against. 
 
    Raises 
    ------ 
    AssertionError : Either `left` or `right` is not an instance of `cls`. 
    &quot;&quot;&quot;</span>
    <span class="s1">cls_name = cls.__name__</span>

    <span class="s0">if not </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span>
            <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">cls_name</span><span class="s0">} </span><span class="s2">Expected type </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s2">, found </span><span class="s0">{</span><span class="s1">type(left)</span><span class="s0">} </span><span class="s2">instead&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span>
            <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">cls_name</span><span class="s0">} </span><span class="s2">Expected type </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s2">, found </span><span class="s0">{</span><span class="s1">type(right)</span><span class="s0">} </span><span class="s2">instead&quot;</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_dict_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">compare_keys: bool = </span><span class="s0">True</span><span class="s1">):</span>

    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">dict)</span>
    <span class="s1">_testing.assert_dict_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">compare_keys=compare_keys)</span>


<span class="s0">def </span><span class="s1">assert_index_equal(</span>
    <span class="s1">left: Index</span><span class="s0">,</span>
    <span class="s1">right: Index</span><span class="s0">,</span>
    <span class="s1">exact: bool | str = </span><span class="s2">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_names: bool = </span><span class="s0">True,</span>
    <span class="s1">check_less_precise: bool | int | NoDefault = no_default</span><span class="s0">,</span>
    <span class="s1">check_exact: bool = </span><span class="s0">True,</span>
    <span class="s1">check_categorical: bool = </span><span class="s0">True,</span>
    <span class="s1">check_order: bool = </span><span class="s0">True,</span>
    <span class="s1">rtol: float = </span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol: float = </span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">obj: str = </span><span class="s2">&quot;Index&quot;</span><span class="s0">,</span>
<span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that left and right Index are equal. 
 
    Parameters 
    ---------- 
    left : Index 
    right : Index 
    exact : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. If 'equiv', then RangeIndex can be substituted for 
        Int64Index as well. 
    check_names : bool, default True 
        Whether to check the names attribute. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_exact : bool, default True 
        Whether to compare number exactly. 
    check_categorical : bool, default True 
        Whether to compare internal Categorical exactly. 
    check_order : bool, default True 
        Whether to compare the order of index entries as well as their values. 
        If True, both indexes must contain the same elements, in the same order. 
        If False, both indexes must contain the same elements, but in any order. 
 
        .. versionadded:: 1.2.0 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    obj : str, default 'Index' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas import testing as tm 
    &gt;&gt;&gt; a = pd.Index([1, 2, 3]) 
    &gt;&gt;&gt; b = pd.Index([1, 2, 3]) 
    &gt;&gt;&gt; tm.assert_index_equal(a, b) 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_check_types(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;Index&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">exact:</span>
            <span class="s0">return</span>

        <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">exact=exact</span><span class="s0">, </span><span class="s1">obj=obj)</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;inferred_type&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

        <span class="s5"># Skip exact dtype checking when `check_categorical` is False</span>
        <span class="s0">if </span><span class="s1">is_categorical_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_categorical_dtype(right.dtype):</span>
            <span class="s0">if </span><span class="s1">check_categorical:</span>
                <span class="s1">assert_attr_equal(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
                <span class="s1">assert_index_equal(left.categories</span><span class="s0">, </span><span class="s1">right.categories</span><span class="s0">, </span><span class="s1">exact=exact)</span>
            <span class="s0">return</span>

        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s0">def </span><span class="s1">_get_ilevel_values(index</span><span class="s0">, </span><span class="s1">level):</span>
        <span class="s5"># accept level number only</span>
        <span class="s1">unique = index.levels[level]</span>
        <span class="s1">level_codes = index.codes[level]</span>
        <span class="s1">filled = take_nd(unique._values</span><span class="s0">, </span><span class="s1">level_codes</span><span class="s0">, </span><span class="s1">fill_value=unique._na_value)</span>
        <span class="s0">return </span><span class="s1">unique._shallow_copy(filled</span><span class="s0">, </span><span class="s1">name=index.names[level])</span>

    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s2">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s2">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s5"># https://github.com/python/mypy/issues/7642</span>
        <span class="s5"># error: Argument 1 to &quot;_get_tol_from_less_precise&quot; has incompatible</span>
        <span class="s5"># type &quot;Union[bool, int, NoDefault]&quot;; expected &quot;Union[bool, int]&quot;</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(</span>
            <span class="s1">check_less_precise  </span><span class="s5"># type: ignore[arg-type]</span>
        <span class="s1">)</span>

    <span class="s5"># instance validation</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">Index)</span>

    <span class="s5"># class / dtype comparison</span>
    <span class="s1">_check_types(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s5"># level comparison</span>
    <span class="s0">if </span><span class="s1">left.nlevels != right.nlevels:</span>
        <span class="s1">msg1 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">levels are different&quot;</span>
        <span class="s1">msg2 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">left.nlevels</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">left</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">msg3 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">right.nlevels</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">right</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg1</span><span class="s0">, </span><span class="s1">msg2</span><span class="s0">, </span><span class="s1">msg3)</span>

    <span class="s5"># length comparison</span>
    <span class="s0">if </span><span class="s1">len(left) != len(right):</span>
        <span class="s1">msg1 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">length are different&quot;</span>
        <span class="s1">msg2 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">len(left)</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">left</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">msg3 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">len(right)</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">right</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg1</span><span class="s0">, </span><span class="s1">msg2</span><span class="s0">, </span><span class="s1">msg3)</span>

    <span class="s5"># If order doesn't matter then sort the index entries</span>
    <span class="s0">if not </span><span class="s1">check_order:</span>
        <span class="s1">left = Index(safe_sort(left))</span>
        <span class="s1">right = Index(safe_sort(right))</span>

    <span class="s5"># MultiIndex special comparison for little-friendly error messages</span>
    <span class="s0">if </span><span class="s1">left.nlevels &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">left = cast(MultiIndex</span><span class="s0">, </span><span class="s1">left)</span>
        <span class="s1">right = cast(MultiIndex</span><span class="s0">, </span><span class="s1">right)</span>

        <span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">range(left.nlevels):</span>
            <span class="s5"># cannot use get_level_values here because it can change dtype</span>
            <span class="s1">llevel = _get_ilevel_values(left</span><span class="s0">, </span><span class="s1">level)</span>
            <span class="s1">rlevel = _get_ilevel_values(right</span><span class="s0">, </span><span class="s1">level)</span>

            <span class="s1">lobj = </span><span class="s2">f&quot;MultiIndex level [</span><span class="s0">{</span><span class="s1">level</span><span class="s0">}</span><span class="s2">]&quot;</span>
            <span class="s1">assert_index_equal(</span>
                <span class="s1">llevel</span><span class="s0">,</span>
                <span class="s1">rlevel</span><span class="s0">,</span>
                <span class="s1">exact=exact</span><span class="s0">,</span>
                <span class="s1">check_names=check_names</span><span class="s0">,</span>
                <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
                <span class="s1">rtol=rtol</span><span class="s0">,</span>
                <span class="s1">atol=atol</span><span class="s0">,</span>
                <span class="s1">obj=lobj</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s5"># get_level_values may change dtype</span>
            <span class="s1">_check_types(left.levels[level]</span><span class="s0">, </span><span class="s1">right.levels[level]</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s5"># skip exact index checking when `check_categorical` is False</span>
    <span class="s0">if </span><span class="s1">check_exact </span><span class="s0">and </span><span class="s1">check_categorical:</span>
        <span class="s0">if not </span><span class="s1">left.equals(right):</span>
            <span class="s1">mismatch = left._values != right._values</span>

            <span class="s1">diff = np.sum(mismatch.astype(int)) * </span><span class="s3">100.0 </span><span class="s1">/ len(left)</span>
            <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">values are different (</span><span class="s0">{</span><span class="s1">np.round(diff</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">} </span><span class="s2">%)&quot;</span>
            <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right)</span>
    <span class="s0">else</span><span class="s1">:</span>

        <span class="s5"># if we have &quot;equiv&quot;, this becomes True</span>
        <span class="s1">exact_bool = bool(exact)</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left.values</span><span class="s0">,</span>
            <span class="s1">right.values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=exact_bool</span><span class="s0">,</span>
            <span class="s1">obj=obj</span><span class="s0">,</span>
            <span class="s1">lobj=left</span><span class="s0">,</span>
            <span class="s1">robj=right</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s5"># metadata comparison</span>
    <span class="s0">if </span><span class="s1">check_names:</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;names&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">PeriodIndex) </span><span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">PeriodIndex):</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">IntervalIndex) </span><span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
        <span class="s1">assert_interval_array_equal(left._values</span><span class="s0">, </span><span class="s1">right._values)</span>

    <span class="s0">if </span><span class="s1">check_categorical:</span>
        <span class="s0">if </span><span class="s1">is_categorical_dtype(left.dtype) </span><span class="s0">or </span><span class="s1">is_categorical_dtype(right.dtype):</span>
            <span class="s1">assert_categorical_equal(left._values</span><span class="s0">, </span><span class="s1">right._values</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">category&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">exact: bool | str = </span><span class="s0">True, </span><span class="s1">obj=</span><span class="s2">&quot;Input&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Checks classes are equal. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pandas.core.indexes.numeric </span><span class="s0">import </span><span class="s1">NumericIndex</span>

    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">repr_class(x):</span>
        <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s5"># return Index as it is to include values in the error message</span>
            <span class="s0">return </span><span class="s1">x</span>

        <span class="s0">return </span><span class="s1">type(x).__name__</span>

    <span class="s0">if </span><span class="s1">type(left) == type(right):</span>
        <span class="s0">return</span>

    <span class="s0">if </span><span class="s1">exact == </span><span class="s2">&quot;equiv&quot;</span><span class="s1">:</span>
        <span class="s5"># accept equivalence of NumericIndex (sub-)classes</span>
        <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">NumericIndex) </span><span class="s0">and </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">NumericIndex):</span>
            <span class="s0">return</span>

    <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">classes are different&quot;</span>
    <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">repr_class(left)</span><span class="s0">, </span><span class="s1">repr_class(right))</span>


<span class="s0">def </span><span class="s1">assert_attr_equal(attr: str</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj: str = </span><span class="s2">&quot;Attributes&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check attributes are equal. Both objects must have attribute. 
 
    Parameters 
    ---------- 
    attr : str 
        Attribute name being compared. 
    left : object 
    right : object 
    obj : str, default 'Attributes' 
        Specify object name being compared, internally used to show appropriate 
        assertion message 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s1">left_attr = getattr(left</span><span class="s0">, </span><span class="s1">attr)</span>
    <span class="s1">right_attr = getattr(right</span><span class="s0">, </span><span class="s1">attr)</span>

    <span class="s0">if </span><span class="s1">left_attr </span><span class="s0">is </span><span class="s1">right_attr:</span>
        <span class="s0">return True</span>
    <span class="s0">elif </span><span class="s1">is_matching_na(left_attr</span><span class="s0">, </span><span class="s1">right_attr):</span>
        <span class="s5"># e.g. both np.nan, both NaT, both pd.NA, ...</span>
        <span class="s0">return True</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">result = left_attr == right_attr</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s5"># datetimetz on rhs may raise TypeError</span>
        <span class="s1">result = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">(left_attr </span><span class="s0">is </span><span class="s1">pd.NA) ^ (right_attr </span><span class="s0">is </span><span class="s1">pd.NA):</span>
        <span class="s1">result = </span><span class="s0">False</span>
    <span class="s0">elif not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">bool):</span>
        <span class="s1">result = result.all()</span>

    <span class="s0">if </span><span class="s1">result:</span>
        <span class="s0">return True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">f'Attribute &quot;</span><span class="s0">{</span><span class="s1">attr</span><span class="s0">}</span><span class="s2">&quot; are different'</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">left_attr</span><span class="s0">, </span><span class="s1">right_attr)</span>


<span class="s0">def </span><span class="s1">assert_is_valid_plot_return_object(objs):</span>
    <span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>

    <span class="s0">if </span><span class="s1">isinstance(objs</span><span class="s0">, </span><span class="s1">(Series</span><span class="s0">, </span><span class="s1">np.ndarray)):</span>
        <span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">objs.ravel():</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;one of 'objs' is not a matplotlib Axes instance, &quot;</span>
                <span class="s2">f&quot;type encountered </span><span class="s0">{</span><span class="s1">repr(type(el).__name__)</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">isinstance(el</span><span class="s0">, </span><span class="s1">(plt.Axes</span><span class="s0">, </span><span class="s1">dict))</span><span class="s0">, </span><span class="s1">msg</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;objs is neither an ndarray of Artist instances nor a single &quot;</span>
            <span class="s2">&quot;ArtistArtist instance, tuple, or dict, 'objs' is a &quot;</span>
            <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(type(objs).__name__)</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(objs</span><span class="s0">, </span><span class="s1">(plt.Artist</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">dict))</span><span class="s0">, </span><span class="s1">msg</span>


<span class="s0">def </span><span class="s1">assert_is_sorted(seq):</span>
    <span class="s4">&quot;&quot;&quot;Assert that the sequence is sorted.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(seq</span><span class="s0">, </span><span class="s1">(Index</span><span class="s0">, </span><span class="s1">Series)):</span>
        <span class="s1">seq = seq.values</span>
    <span class="s5"># sorting does not change precisions</span>
    <span class="s1">assert_numpy_array_equal(seq</span><span class="s0">, </span><span class="s1">np.sort(np.array(seq)))</span>


<span class="s0">def </span><span class="s1">assert_categorical_equal(</span>
    <span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">True, </span><span class="s1">check_category_order=</span><span class="s0">True, </span><span class="s1">obj=</span><span class="s2">&quot;Categorical&quot;</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Test that Categoricals are equivalent. 
 
    Parameters 
    ---------- 
    left : Categorical 
    right : Categorical 
    check_dtype : bool, default True 
        Check that integer dtype of the codes are the same. 
    check_category_order : bool, default True 
        Whether the order of the categories should be compared, which 
        implies identical integer codes.  If False, only the resulting 
        values are compared.  The ordered attribute is 
        checked regardless. 
    obj : str, default 'Categorical' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">Categorical)</span>

    <span class="s1">exact: bool | str</span>
    <span class="s0">if </span><span class="s1">isinstance(left.categories</span><span class="s0">, </span><span class="s1">RangeIndex) </span><span class="s0">or </span><span class="s1">isinstance(</span>
        <span class="s1">right.categories</span><span class="s0">, </span><span class="s1">RangeIndex</span>
    <span class="s1">):</span>
        <span class="s1">exact = </span><span class="s2">&quot;equiv&quot;</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># We still want to require exact matches for NumericIndex</span>
        <span class="s1">exact = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">check_category_order:</span>
        <span class="s1">assert_index_equal(</span>
            <span class="s1">left.categories</span><span class="s0">, </span><span class="s1">right.categories</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.categories&quot;</span><span class="s0">, </span><span class="s1">exact=exact</span>
        <span class="s1">)</span>
        <span class="s1">assert_numpy_array_equal(</span>
            <span class="s1">left.codes</span><span class="s0">, </span><span class="s1">right.codes</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.codes&quot;</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">lc = left.categories.sort_values()</span>
            <span class="s1">rc = right.categories.sort_values()</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s5"># e.g. '&lt;' not supported between instances of 'int' and 'str'</span>
            <span class="s1">lc</span><span class="s0">, </span><span class="s1">rc = left.categories</span><span class="s0">, </span><span class="s1">right.categories</span>
        <span class="s1">assert_index_equal(lc</span><span class="s0">, </span><span class="s1">rc</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.categories&quot;</span><span class="s0">, </span><span class="s1">exact=exact)</span>
        <span class="s1">assert_index_equal(</span>
            <span class="s1">left.categories.take(left.codes)</span><span class="s0">,</span>
            <span class="s1">right.categories.take(right.codes)</span><span class="s0">,</span>
            <span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.values&quot;</span><span class="s0">,</span>
            <span class="s1">exact=exact</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">assert_attr_equal(</span><span class="s2">&quot;ordered&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_interval_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">exact=</span><span class="s2">&quot;equiv&quot;</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;IntervalArray&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Test that two IntervalArrays are equivalent. 
 
    Parameters 
    ---------- 
    left, right : IntervalArray 
        The IntervalArrays to compare. 
    exact : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. If 'equiv', then RangeIndex can be substituted for 
        Int64Index as well. 
    obj : str, default 'IntervalArray' 
        Specify object name being compared, internally used to show appropriate 
        assertion message 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">IntervalArray)</span>

    <span class="s1">kwargs = {}</span>
    <span class="s0">if </span><span class="s1">left._left.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s2">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s5"># We have a DatetimeArray or TimedeltaArray</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;check_freq&quot;</span><span class="s1">] = </span><span class="s0">False</span>

    <span class="s1">assert_equal(left._left</span><span class="s0">, </span><span class="s1">right._left</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.left&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">assert_equal(left._right</span><span class="s0">, </span><span class="s1">right._right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.left&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">assert_attr_equal(</span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_period_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;PeriodArray&quot;</span><span class="s1">):</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">PeriodArray)</span>

    <span class="s1">assert_numpy_array_equal(left._data</span><span class="s0">, </span><span class="s1">right._data</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">._data&quot;</span><span class="s1">)</span>
    <span class="s1">assert_attr_equal(</span><span class="s2">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_datetime_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;DatetimeArray&quot;</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">DatetimeArray)</span>

    <span class="s1">assert_numpy_array_equal(left._data</span><span class="s0">, </span><span class="s1">right._data</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">._data&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">check_freq:</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s1">assert_attr_equal(</span><span class="s2">&quot;tz&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_timedelta_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;TimedeltaArray&quot;</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">TimedeltaArray)</span>
    <span class="s1">assert_numpy_array_equal(left._data</span><span class="s0">, </span><span class="s1">right._data</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">._data&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">check_freq:</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">message</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">diff=</span><span class="s0">None, </span><span class="s1">index_values=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s1">msg = </span><span class="s2">f&quot;&quot;&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">are different</span>

<span class="s0">{</span><span class="s1">message</span><span class="s0">}</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(index_values</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">msg += </span><span class="s2">f&quot;</span><span class="s0">\n</span><span class="s2">[index]: </span><span class="s0">{</span><span class="s1">pprint_thing(index_values)</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">left = pprint_thing(left)</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">CategoricalDtype)</span>
        <span class="s0">or </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">PandasDtype)</span>
        <span class="s0">or </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">StringDtype)</span>
    <span class="s1">):</span>
        <span class="s1">left = repr(left)</span>

    <span class="s0">if </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">right = pprint_thing(right)</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">CategoricalDtype)</span>
        <span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">PandasDtype)</span>
        <span class="s0">or </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">StringDtype)</span>
    <span class="s1">):</span>
        <span class="s1">right = repr(right)</span>

    <span class="s1">msg += </span><span class="s2">f&quot;&quot;&quot;</span>
<span class="s2">[left]:  </span><span class="s0">{</span><span class="s1">left</span><span class="s0">}</span>
<span class="s2">[right]: </span><span class="s0">{</span><span class="s1">right</span><span class="s0">}</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">diff </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">msg += </span><span class="s2">f&quot;</span><span class="s0">\n</span><span class="s2">[diff]: </span><span class="s0">{</span><span class="s1">diff</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">raise </span><span class="s1">AssertionError(msg)</span>


<span class="s0">def </span><span class="s1">assert_numpy_array_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">strict_nan=</span><span class="s0">False,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">err_msg=</span><span class="s0">None,</span>
    <span class="s1">check_same=</span><span class="s0">None,</span>
    <span class="s1">obj=</span><span class="s2">&quot;numpy array&quot;</span><span class="s0">,</span>
    <span class="s1">index_values=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that 'np.ndarray' is equivalent. 
 
    Parameters 
    ---------- 
    left, right : numpy.ndarray or iterable 
        The two arrays to be compared. 
    strict_nan : bool, default False 
        If True, consider NaN and None to be different. 
    check_dtype : bool, default True 
        Check dtype if both a and b are np.ndarray. 
    err_msg : str, default None 
        If provided, used as assertion message. 
    check_same : None|'copy'|'same', default None 
        Ensure left and right refer/do not refer to the same memory area. 
    obj : str, default 'numpy array' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
    index_values : numpy.ndarray, default None 
        optional index (shared by both left and right), used in output. 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s5"># instance validation</span>
    <span class="s5"># Show a detailed error message when classes are different</span>
    <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>
    <span class="s5"># both classes must be an np.ndarray</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

    <span class="s0">def </span><span class="s1">_get_base(obj):</span>
        <span class="s0">return </span><span class="s1">obj.base </span><span class="s0">if </span><span class="s1">getattr(obj</span><span class="s0">, </span><span class="s2">&quot;base&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None else </span><span class="s1">obj</span>

    <span class="s1">left_base = _get_base(left)</span>
    <span class="s1">right_base = _get_base(right)</span>

    <span class="s0">if </span><span class="s1">check_same == </span><span class="s2">&quot;same&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">left_base </span><span class="s0">is not </span><span class="s1">right_base:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(left_base)</span><span class="s0">} </span><span class="s2">is not </span><span class="s0">{</span><span class="s1">repr(right_base)</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">check_same == </span><span class="s2">&quot;copy&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">left_base </span><span class="s0">is </span><span class="s1">right_base:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(left_base)</span><span class="s0">} </span><span class="s2">is </span><span class="s0">{</span><span class="s1">repr(right_base)</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_raise(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">err_msg):</span>
        <span class="s0">if </span><span class="s1">err_msg </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">left.shape != right.shape:</span>
                <span class="s1">raise_assert_detail(</span>
                    <span class="s1">obj</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">shapes are different&quot;</span><span class="s0">, </span><span class="s1">left.shape</span><span class="s0">, </span><span class="s1">right.shape</span>
                <span class="s1">)</span>

            <span class="s1">diff = </span><span class="s3">0</span>
            <span class="s0">for </span><span class="s1">left_arr</span><span class="s0">, </span><span class="s1">right_arr </span><span class="s0">in </span><span class="s1">zip(left</span><span class="s0">, </span><span class="s1">right):</span>
                <span class="s5"># count up differences</span>
                <span class="s0">if not </span><span class="s1">array_equivalent(left_arr</span><span class="s0">, </span><span class="s1">right_arr</span><span class="s0">, </span><span class="s1">strict_nan=strict_nan):</span>
                    <span class="s1">diff += </span><span class="s3">1</span>

            <span class="s1">diff = diff * </span><span class="s3">100.0 </span><span class="s1">/ left.size</span>
            <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">values are different (</span><span class="s0">{</span><span class="s1">np.round(diff</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">} </span><span class="s2">%)&quot;</span>
            <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">index_values=index_values)</span>

        <span class="s0">raise </span><span class="s1">AssertionError(err_msg)</span>

    <span class="s5"># compare shape and values</span>
    <span class="s0">if not </span><span class="s1">array_equivalent(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">strict_nan=strict_nan):</span>
        <span class="s1">_raise(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">err_msg)</span>

    <span class="s0">if </span><span class="s1">check_dtype:</span>
        <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">assert_attr_equal(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>


<span class="s0">def </span><span class="s1">assert_extension_array_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">index_values=</span><span class="s0">None,</span>
    <span class="s1">check_less_precise=no_default</span><span class="s0">,</span>
    <span class="s1">check_exact=</span><span class="s0">False,</span>
    <span class="s1">rtol: float = </span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol: float = </span><span class="s3">1.0e-8</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that left and right ExtensionArrays are equal. 
 
    Parameters 
    ---------- 
    left, right : ExtensionArray 
        The two arrays to compare. 
    check_dtype : bool, default True 
        Whether to check if the ExtensionArray dtypes are identical. 
    index_values : numpy.ndarray, default None 
        Optional index (shared by both left and right), used in output. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_exact : bool, default False 
        Whether to compare number exactly. 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
 
    Notes 
    ----- 
    Missing values are checked separately from valid values. 
    A mask of missing values is computed for each and checked to match. 
    The remaining all-valid values are cast to object dtype and checked. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas import testing as tm 
    &gt;&gt;&gt; a = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; b, c = a.array, a.array 
    &gt;&gt;&gt; tm.assert_extension_array_equal(b, c) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s2">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s2">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s0">assert </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">ExtensionArray)</span><span class="s0">, </span><span class="s2">&quot;left is not an ExtensionArray&quot;</span>
    <span class="s0">assert </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">ExtensionArray)</span><span class="s0">, </span><span class="s2">&quot;right is not an ExtensionArray&quot;</span>
    <span class="s0">if </span><span class="s1">check_dtype:</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;ExtensionArray&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">DatetimeLikeArrayMixin)</span>
        <span class="s0">and </span><span class="s1">isinstance(right</span><span class="s0">, </span><span class="s1">DatetimeLikeArrayMixin)</span>
        <span class="s0">and </span><span class="s1">type(right) == type(left)</span>
    <span class="s1">):</span>
        <span class="s5"># Avoid slow object-dtype comparisons</span>
        <span class="s5"># np.asarray for case where we have a np.MaskedArray</span>
        <span class="s1">assert_numpy_array_equal(</span>
            <span class="s1">np.asarray(left.asi8)</span><span class="s0">, </span><span class="s1">np.asarray(right.asi8)</span><span class="s0">, </span><span class="s1">index_values=index_values</span>
        <span class="s1">)</span>
        <span class="s0">return</span>

    <span class="s1">left_na = np.asarray(left.isna())</span>
    <span class="s1">right_na = np.asarray(right.isna())</span>
    <span class="s1">assert_numpy_array_equal(</span>
        <span class="s1">left_na</span><span class="s0">, </span><span class="s1">right_na</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;ExtensionArray NA mask&quot;</span><span class="s0">, </span><span class="s1">index_values=index_values</span>
    <span class="s1">)</span>

    <span class="s1">left_valid = np.asarray(left[~left_na].astype(object))</span>
    <span class="s1">right_valid = np.asarray(right[~right_na].astype(object))</span>
    <span class="s0">if </span><span class="s1">check_exact:</span>
        <span class="s1">assert_numpy_array_equal(</span>
            <span class="s1">left_valid</span><span class="s0">, </span><span class="s1">right_valid</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">&quot;ExtensionArray&quot;</span><span class="s0">, </span><span class="s1">index_values=index_values</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left_valid</span><span class="s0">,</span>
            <span class="s1">right_valid</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">obj=</span><span class="s2">&quot;ExtensionArray&quot;</span><span class="s0">,</span>
            <span class="s1">index_values=index_values</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s5"># This could be refactored to use the NDFrame.equals method</span>
<span class="s0">def </span><span class="s1">assert_series_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">check_index_type=</span><span class="s2">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_series_type=</span><span class="s0">True,</span>
    <span class="s1">check_less_precise=no_default</span><span class="s0">,</span>
    <span class="s1">check_names=</span><span class="s0">True,</span>
    <span class="s1">check_exact=</span><span class="s0">False,</span>
    <span class="s1">check_datetimelike_compat=</span><span class="s0">False,</span>
    <span class="s1">check_categorical=</span><span class="s0">True,</span>
    <span class="s1">check_category_order=</span><span class="s0">True,</span>
    <span class="s1">check_freq=</span><span class="s0">True,</span>
    <span class="s1">check_flags=</span><span class="s0">True,</span>
    <span class="s1">rtol=</span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol=</span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">obj=</span><span class="s2">&quot;Series&quot;</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">check_index=</span><span class="s0">True,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that left and right Series are equal. 
 
    Parameters 
    ---------- 
    left : Series 
    right : Series 
    check_dtype : bool, default True 
        Whether to check the Series dtype is identical. 
    check_index_type : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. 
    check_series_type : bool, default True 
         Whether to check the Series class is identical. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        When comparing two numbers, if the first number has magnitude less 
        than 1e-5, we compare the two numbers directly and check whether 
        they are equivalent within the specified precision. Otherwise, we 
        compare the **ratio** of the second number to the first number and 
        check whether it is equivalent to 1 within the specified precision. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_names : bool, default True 
        Whether to check the Series and Index names attribute. 
    check_exact : bool, default False 
        Whether to compare number exactly. 
    check_datetimelike_compat : bool, default False 
        Compare datetime-like which is comparable ignoring dtype. 
    check_categorical : bool, default True 
        Whether to compare internal Categorical exactly. 
    check_category_order : bool, default True 
        Whether to compare category order of internal Categoricals. 
 
        .. versionadded:: 1.0.2 
    check_freq : bool, default True 
        Whether to check the `freq` attribute on a DatetimeIndex or TimedeltaIndex. 
 
        .. versionadded:: 1.1.0 
    check_flags : bool, default True 
        Whether to check the `flags` attribute. 
 
        .. versionadded:: 1.2.0 
 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    obj : str, default 'Series' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
    check_index : bool, default True 
        Whether to check index equivalence. If False, then compare only values. 
 
        .. versionadded:: 1.3.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas import testing as tm 
    &gt;&gt;&gt; a = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; b = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; tm.assert_series_equal(a, b) 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s2">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s2">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s5"># instance validation</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">Series)</span>

    <span class="s0">if </span><span class="s1">check_series_type:</span>
        <span class="s1">assert_class_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s5"># length comparison</span>
    <span class="s0">if </span><span class="s1">len(left) != len(right):</span>
        <span class="s1">msg1 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">len(left)</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">left.index</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">msg2 = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">len(right)</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">right.index</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">raise_assert_detail(obj</span><span class="s0">, </span><span class="s2">&quot;Series length are different&quot;</span><span class="s0">, </span><span class="s1">msg1</span><span class="s0">, </span><span class="s1">msg2)</span>

    <span class="s0">if </span><span class="s1">check_flags:</span>
        <span class="s0">assert </span><span class="s1">left.flags == right.flags</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(left.flags)</span><span class="s0">} </span><span class="s2">!= </span><span class="s0">{</span><span class="s1">repr(right.flags)</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">if </span><span class="s1">check_index:</span>
        <span class="s5"># GH #38183</span>
        <span class="s1">assert_index_equal(</span>
            <span class="s1">left.index</span><span class="s0">,</span>
            <span class="s1">right.index</span><span class="s0">,</span>
            <span class="s1">exact=check_index_type</span><span class="s0">,</span>
            <span class="s1">check_names=check_names</span><span class="s0">,</span>
            <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
            <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.index&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_freq </span><span class="s0">and </span><span class="s1">isinstance(left.index</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">TimedeltaIndex)):</span>
        <span class="s1">lidx = left.index</span>
        <span class="s1">ridx = right.index</span>
        <span class="s0">assert </span><span class="s1">lidx.freq == ridx.freq</span><span class="s0">, </span><span class="s1">(lidx.freq</span><span class="s0">, </span><span class="s1">ridx.freq)</span>

    <span class="s0">if </span><span class="s1">check_dtype:</span>
        <span class="s5"># We want to skip exact dtype checking when `check_categorical`</span>
        <span class="s5"># is False. We'll still raise if only one is a `Categorical`,</span>
        <span class="s5"># regardless of `check_categorical`</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(left.dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype)</span>
            <span class="s0">and </span><span class="s1">isinstance(right.dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype)</span>
            <span class="s0">and not </span><span class="s1">check_categorical</span>
        <span class="s1">):</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_attr_equal(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=</span><span class="s2">f&quot;Attributes of </span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_exact </span><span class="s0">and </span><span class="s1">is_numeric_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_numeric_dtype(right.dtype):</span>
        <span class="s1">left_values = left._values</span>
        <span class="s1">right_values = right._values</span>
        <span class="s5"># Only check exact if dtype is numeric</span>
        <span class="s0">if </span><span class="s1">isinstance(left_values</span><span class="s0">, </span><span class="s1">ExtensionArray) </span><span class="s0">and </span><span class="s1">isinstance(</span>
            <span class="s1">right_values</span><span class="s0">, </span><span class="s1">ExtensionArray</span>
        <span class="s1">):</span>
            <span class="s1">assert_extension_array_equal(</span>
                <span class="s1">left_values</span><span class="s0">,</span>
                <span class="s1">right_values</span><span class="s0">,</span>
                <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
                <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_numpy_array_equal(</span>
                <span class="s1">left_values</span><span class="s0">,</span>
                <span class="s1">right_values</span><span class="s0">,</span>
                <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
                <span class="s1">obj=str(obj)</span><span class="s0">,</span>
                <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
            <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">check_datetimelike_compat </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">needs_i8_conversion(left.dtype) </span><span class="s0">or </span><span class="s1">needs_i8_conversion(right.dtype)</span>
    <span class="s1">):</span>
        <span class="s5"># we want to check only if we have compat dtypes</span>
        <span class="s5"># e.g. integer and M|m are NOT compat, but we can simply check</span>
        <span class="s5"># the values in that case</span>

        <span class="s5"># datetimelike may have different objects (e.g. datetime.datetime</span>
        <span class="s5"># vs Timestamp) but will compare equal</span>
        <span class="s0">if not </span><span class="s1">Index(left._values).equals(Index(right._values)):</span>
            <span class="s1">msg = (</span>
                <span class="s2">f&quot;[datetimelike_compat=True] </span><span class="s0">{</span><span class="s1">left._values</span><span class="s0">} </span><span class="s2">&quot;</span>
                <span class="s2">f&quot;is not equal to </span><span class="s0">{</span><span class="s1">right._values</span><span class="s0">}</span><span class="s2">.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">AssertionError(msg)</span>
    <span class="s0">elif </span><span class="s1">is_interval_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_interval_dtype(right.dtype):</span>
        <span class="s1">assert_interval_array_equal(left.array</span><span class="s0">, </span><span class="s1">right.array)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left.dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype) </span><span class="s0">or </span><span class="s1">isinstance(</span>
        <span class="s1">right.dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype</span>
    <span class="s1">):</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">obj=str(obj)</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">is_extension_array_dtype(left.dtype) </span><span class="s0">and </span><span class="s1">is_extension_array_dtype(right.dtype):</span>
        <span class="s1">assert_extension_array_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">is_extension_array_dtype_and_needs_i8_conversion(</span>
        <span class="s1">left.dtype</span><span class="s0">, </span><span class="s1">right.dtype</span>
    <span class="s1">) </span><span class="s0">or </span><span class="s1">is_extension_array_dtype_and_needs_i8_conversion(right.dtype</span><span class="s0">, </span><span class="s1">left.dtype):</span>
        <span class="s1">assert_extension_array_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">needs_i8_conversion(left.dtype) </span><span class="s0">and </span><span class="s1">needs_i8_conversion(right.dtype):</span>
        <span class="s5"># DatetimeArray or TimedeltaArray</span>
        <span class="s1">assert_extension_array_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_testing.assert_almost_equal(</span>
            <span class="s1">left._values</span><span class="s0">,</span>
            <span class="s1">right._values</span><span class="s0">,</span>
            <span class="s1">rtol=rtol</span><span class="s0">,</span>
            <span class="s1">atol=atol</span><span class="s0">,</span>
            <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
            <span class="s1">obj=str(obj)</span><span class="s0">,</span>
            <span class="s1">index_values=np.asarray(left.index)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s5"># metadata comparison</span>
    <span class="s0">if </span><span class="s1">check_names:</span>
        <span class="s1">assert_attr_equal(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">obj=obj)</span>

    <span class="s0">if </span><span class="s1">check_categorical:</span>
        <span class="s0">if </span><span class="s1">isinstance(left.dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype) </span><span class="s0">or </span><span class="s1">isinstance(</span>
            <span class="s1">right.dtype</span><span class="s0">, </span><span class="s1">CategoricalDtype</span>
        <span class="s1">):</span>
            <span class="s1">assert_categorical_equal(</span>
                <span class="s1">left._values</span><span class="s0">,</span>
                <span class="s1">right._values</span><span class="s0">,</span>
                <span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">category&quot;</span><span class="s0">,</span>
                <span class="s1">check_category_order=check_category_order</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s5"># This could be refactored to use the NDFrame.equals method</span>
<span class="s0">def </span><span class="s1">assert_frame_equal(</span>
    <span class="s1">left</span><span class="s0">,</span>
    <span class="s1">right</span><span class="s0">,</span>
    <span class="s1">check_dtype=</span><span class="s0">True,</span>
    <span class="s1">check_index_type=</span><span class="s2">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_column_type=</span><span class="s2">&quot;equiv&quot;</span><span class="s0">,</span>
    <span class="s1">check_frame_type=</span><span class="s0">True,</span>
    <span class="s1">check_less_precise=no_default</span><span class="s0">,</span>
    <span class="s1">check_names=</span><span class="s0">True,</span>
    <span class="s1">by_blocks=</span><span class="s0">False,</span>
    <span class="s1">check_exact=</span><span class="s0">False,</span>
    <span class="s1">check_datetimelike_compat=</span><span class="s0">False,</span>
    <span class="s1">check_categorical=</span><span class="s0">True,</span>
    <span class="s1">check_like=</span><span class="s0">False,</span>
    <span class="s1">check_freq=</span><span class="s0">True,</span>
    <span class="s1">check_flags=</span><span class="s0">True,</span>
    <span class="s1">rtol=</span><span class="s3">1.0e-5</span><span class="s0">,</span>
    <span class="s1">atol=</span><span class="s3">1.0e-8</span><span class="s0">,</span>
    <span class="s1">obj=</span><span class="s2">&quot;DataFrame&quot;</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that left and right DataFrame are equal. 
 
    This function is intended to compare two DataFrames and output any 
    differences. Is is mostly intended for use in unit tests. 
    Additional parameters allow varying the strictness of the 
    equality checks performed. 
 
    Parameters 
    ---------- 
    left : DataFrame 
        First DataFrame to compare. 
    right : DataFrame 
        Second DataFrame to compare. 
    check_dtype : bool, default True 
        Whether to check the DataFrame dtype is identical. 
    check_index_type : bool or {'equiv'}, default 'equiv' 
        Whether to check the Index class, dtype and inferred_type 
        are identical. 
    check_column_type : bool or {'equiv'}, default 'equiv' 
        Whether to check the columns class, dtype and inferred_type 
        are identical. Is passed as the ``exact`` argument of 
        :func:`assert_index_equal`. 
    check_frame_type : bool, default True 
        Whether to check the DataFrame class is identical. 
    check_less_precise : bool or int, default False 
        Specify comparison precision. Only used when check_exact is False. 
        5 digits (False) or 3 digits (True) after decimal points are compared. 
        If int, then specify the digits to compare. 
 
        When comparing two numbers, if the first number has magnitude less 
        than 1e-5, we compare the two numbers directly and check whether 
        they are equivalent within the specified precision. Otherwise, we 
        compare the **ratio** of the second number to the first number and 
        check whether it is equivalent to 1 within the specified precision. 
 
        .. deprecated:: 1.1.0 
           Use `rtol` and `atol` instead to define relative/absolute 
           tolerance, respectively. Similar to :func:`math.isclose`. 
    check_names : bool, default True 
        Whether to check that the `names` attribute for both the `index` 
        and `column` attributes of the DataFrame is identical. 
    by_blocks : bool, default False 
        Specify how to compare internal data. If False, compare by columns. 
        If True, compare by blocks. 
    check_exact : bool, default False 
        Whether to compare number exactly. 
    check_datetimelike_compat : bool, default False 
        Compare datetime-like which is comparable ignoring dtype. 
    check_categorical : bool, default True 
        Whether to compare internal Categorical exactly. 
    check_like : bool, default False 
        If True, ignore the order of index &amp; columns. 
        Note: index labels must match their respective rows 
        (same as in columns) - same labels must be with the same data. 
    check_freq : bool, default True 
        Whether to check the `freq` attribute on a DatetimeIndex or TimedeltaIndex. 
 
        .. versionadded:: 1.1.0 
    check_flags : bool, default True 
        Whether to check the `flags` attribute. 
    rtol : float, default 1e-5 
        Relative tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    atol : float, default 1e-8 
        Absolute tolerance. Only used when check_exact is False. 
 
        .. versionadded:: 1.1.0 
    obj : str, default 'DataFrame' 
        Specify object name being compared, internally used to show appropriate 
        assertion message. 
 
    See Also 
    -------- 
    assert_series_equal : Equivalent method for asserting Series equality. 
    DataFrame.equals : Check DataFrame equality. 
 
    Examples 
    -------- 
    This example shows comparing two DataFrames that are equal 
    but with columns of differing dtypes. 
 
    &gt;&gt;&gt; from pandas.testing import assert_frame_equal 
    &gt;&gt;&gt; df1 = pd.DataFrame({'a': [1, 2], 'b': [3, 4]}) 
    &gt;&gt;&gt; df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]}) 
 
    df1 equals itself. 
 
    &gt;&gt;&gt; assert_frame_equal(df1, df1) 
 
    df1 differs from df2 as column 'b' is of a different type. 
 
    &gt;&gt;&gt; assert_frame_equal(df1, df2) 
    Traceback (most recent call last): 
    ... 
    AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=&quot;b&quot;) are different 
 
    Attribute &quot;dtype&quot; are different 
    [left]:  int64 
    [right]: float64 
 
    Ignore differing dtypes in columns with check_dtype. 
 
    &gt;&gt;&gt; assert_frame_equal(df1, df2, check_dtype=False) 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">check_less_precise </span><span class="s0">is not </span><span class="s1">no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The 'check_less_precise' keyword in testing.assert_*_equal &quot;</span>
            <span class="s2">&quot;is deprecated and will be removed in a future version. &quot;</span>
            <span class="s2">&quot;You can stop passing 'check_less_precise' to silence this warning.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rtol = atol = _get_tol_from_less_precise(check_less_precise)</span>

    <span class="s5"># instance validation</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">DataFrame)</span>

    <span class="s0">if </span><span class="s1">check_frame_type:</span>
        <span class="s0">assert </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">type(right))</span>
        <span class="s5"># assert_class_equal(left, right, obj=obj)</span>

    <span class="s5"># shape comparison</span>
    <span class="s0">if </span><span class="s1">left.shape != right.shape:</span>
        <span class="s1">raise_assert_detail(</span>
            <span class="s1">obj</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s2">shape mismatch&quot;</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(left.shape)</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(right.shape)</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_flags:</span>
        <span class="s0">assert </span><span class="s1">left.flags == right.flags</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">repr(left.flags)</span><span class="s0">} </span><span class="s2">!= </span><span class="s0">{</span><span class="s1">repr(right.flags)</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s5"># index comparison</span>
    <span class="s1">assert_index_equal(</span>
        <span class="s1">left.index</span><span class="s0">,</span>
        <span class="s1">right.index</span><span class="s0">,</span>
        <span class="s1">exact=check_index_type</span><span class="s0">,</span>
        <span class="s1">check_names=check_names</span><span class="s0">,</span>
        <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
        <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
        <span class="s1">check_order=</span><span class="s0">not </span><span class="s1">check_like</span><span class="s0">,</span>
        <span class="s1">rtol=rtol</span><span class="s0">,</span>
        <span class="s1">atol=atol</span><span class="s0">,</span>
        <span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.index&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s5"># column comparison</span>
    <span class="s1">assert_index_equal(</span>
        <span class="s1">left.columns</span><span class="s0">,</span>
        <span class="s1">right.columns</span><span class="s0">,</span>
        <span class="s1">exact=check_column_type</span><span class="s0">,</span>
        <span class="s1">check_names=check_names</span><span class="s0">,</span>
        <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
        <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
        <span class="s1">check_order=</span><span class="s0">not </span><span class="s1">check_like</span><span class="s0">,</span>
        <span class="s1">rtol=rtol</span><span class="s0">,</span>
        <span class="s1">atol=atol</span><span class="s0">,</span>
        <span class="s1">obj=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.columns&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">check_like:</span>
        <span class="s1">left</span><span class="s0">, </span><span class="s1">right = left.reindex_like(right)</span><span class="s0">, </span><span class="s1">right</span>

    <span class="s5"># compare by blocks</span>
    <span class="s0">if </span><span class="s1">by_blocks:</span>
        <span class="s1">rblocks = right._to_dict_of_blocks()</span>
        <span class="s1">lblocks = left._to_dict_of_blocks()</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">list(set(list(lblocks.keys()) + list(rblocks.keys()))):</span>
            <span class="s0">assert </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">lblocks</span>
            <span class="s0">assert </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">rblocks</span>
            <span class="s1">assert_frame_equal(</span>
                <span class="s1">lblocks[dtype]</span><span class="s0">, </span><span class="s1">rblocks[dtype]</span><span class="s0">, </span><span class="s1">check_dtype=check_dtype</span><span class="s0">, </span><span class="s1">obj=obj</span>
            <span class="s1">)</span>

    <span class="s5"># compare by columns</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate(left.columns):</span>
            <span class="s5"># We have already checked that columns match, so we can do</span>
            <span class="s5">#  fast location-based lookups</span>
            <span class="s1">lcol = left._ixs(i</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">rcol = right._ixs(i</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s5"># GH #38183</span>
            <span class="s5"># use check_index=False, because we do not want to run</span>
            <span class="s5"># assert_index_equal for each column,</span>
            <span class="s5"># as we already checked it for the whole dataframe before.</span>
            <span class="s1">assert_series_equal(</span>
                <span class="s1">lcol</span><span class="s0">,</span>
                <span class="s1">rcol</span><span class="s0">,</span>
                <span class="s1">check_dtype=check_dtype</span><span class="s0">,</span>
                <span class="s1">check_index_type=check_index_type</span><span class="s0">,</span>
                <span class="s1">check_exact=check_exact</span><span class="s0">,</span>
                <span class="s1">check_names=check_names</span><span class="s0">,</span>
                <span class="s1">check_datetimelike_compat=check_datetimelike_compat</span><span class="s0">,</span>
                <span class="s1">check_categorical=check_categorical</span><span class="s0">,</span>
                <span class="s1">check_freq=check_freq</span><span class="s0">,</span>
                <span class="s1">obj=</span><span class="s2">f'</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">}</span><span class="s2">.iloc[:, </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">] (column name=&quot;</span><span class="s0">{</span><span class="s1">col</span><span class="s0">}</span><span class="s2">&quot;)'</span><span class="s0">,</span>
                <span class="s1">rtol=rtol</span><span class="s0">,</span>
                <span class="s1">atol=atol</span><span class="s0">,</span>
                <span class="s1">check_index=</span><span class="s0">False,</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Wrapper for tm.assert_*_equal to dispatch to the appropriate test function. 
 
    Parameters 
    ---------- 
    left, right : Index, Series, DataFrame, ExtensionArray, or np.ndarray 
        The two items to be compared. 
    **kwargs 
        All keyword arguments are passed through to the underlying assert method. 
    &quot;&quot;&quot;</span>
    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">Index):</span>
        <span class="s1">assert_index_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">TimedeltaIndex)):</span>
            <span class="s0">assert </span><span class="s1">left.freq == right.freq</span><span class="s0">, </span><span class="s1">(left.freq</span><span class="s0">, </span><span class="s1">right.freq)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">assert_series_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s1">assert_frame_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">IntervalArray):</span>
        <span class="s1">assert_interval_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">PeriodArray):</span>
        <span class="s1">assert_period_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">DatetimeArray):</span>
        <span class="s1">assert_datetime_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">TimedeltaArray):</span>
        <span class="s1">assert_timedelta_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
        <span class="s1">assert_extension_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">assert_numpy_array_equal(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(left</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">assert </span><span class="s1">kwargs == {}</span>
        <span class="s0">assert </span><span class="s1">left == right</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">kwargs == {}</span>
        <span class="s1">assert_almost_equal(left</span><span class="s0">, </span><span class="s1">right)</span>


<span class="s0">def </span><span class="s1">assert_sp_array_equal(left</span><span class="s0">, </span><span class="s1">right):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that the left and right SparseArray are equal. 
 
    Parameters 
    ---------- 
    left : SparseArray 
    right : SparseArray 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_isinstance(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">pd.arrays.SparseArray)</span>

    <span class="s1">assert_numpy_array_equal(left.sp_values</span><span class="s0">, </span><span class="s1">right.sp_values)</span>

    <span class="s5"># SparseIndex comparison</span>
    <span class="s0">assert </span><span class="s1">isinstance(left.sp_index</span><span class="s0">, </span><span class="s1">pd._libs.sparse.SparseIndex)</span>
    <span class="s0">assert </span><span class="s1">isinstance(right.sp_index</span><span class="s0">, </span><span class="s1">pd._libs.sparse.SparseIndex)</span>

    <span class="s1">left_index = left.sp_index</span>
    <span class="s1">right_index = right.sp_index</span>

    <span class="s0">if not </span><span class="s1">left_index.equals(right_index):</span>
        <span class="s1">raise_assert_detail(</span>
            <span class="s2">&quot;SparseArray.index&quot;</span><span class="s0">, </span><span class="s2">&quot;index are not equal&quot;</span><span class="s0">, </span><span class="s1">left_index</span><span class="s0">, </span><span class="s1">right_index</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># Just ensure a</span>
        <span class="s0">pass</span>

    <span class="s1">assert_attr_equal(</span><span class="s2">&quot;fill_value&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right)</span>
    <span class="s1">assert_attr_equal(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right)</span>
    <span class="s1">assert_numpy_array_equal(left.to_dense()</span><span class="s0">, </span><span class="s1">right.to_dense())</span>


<span class="s0">def </span><span class="s1">assert_contains_all(iterable</span><span class="s0">, </span><span class="s1">dic):</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">assert </span><span class="s1">k </span><span class="s0">in </span><span class="s1">dic</span><span class="s0">, </span><span class="s2">f&quot;Did not contain item: </span><span class="s0">{</span><span class="s1">repr(k)</span><span class="s0">}</span><span class="s2">&quot;</span>


<span class="s0">def </span><span class="s1">assert_copy(iter1</span><span class="s0">, </span><span class="s1">iter2</span><span class="s0">, </span><span class="s1">**eql_kwargs):</span>
    <span class="s4">&quot;&quot;&quot; 
    iter1, iter2: iterables that produce elements 
    comparable with assert_almost_equal 
 
    Checks that the elements are equal, but not 
    the same object. (Does not check that items 
    in sequences are also not the same object) 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">elem1</span><span class="s0">, </span><span class="s1">elem2 </span><span class="s0">in </span><span class="s1">zip(iter1</span><span class="s0">, </span><span class="s1">iter2):</span>
        <span class="s1">assert_almost_equal(elem1</span><span class="s0">, </span><span class="s1">elem2</span><span class="s0">, </span><span class="s1">**eql_kwargs)</span>
        <span class="s1">msg = (</span>
            <span class="s2">f&quot;Expected object </span><span class="s0">{</span><span class="s1">repr(type(elem1))</span><span class="s0">} </span><span class="s2">and object </span><span class="s0">{</span><span class="s1">repr(type(elem2))</span><span class="s0">} </span><span class="s2">to be &quot;</span>
            <span class="s2">&quot;different objects, but they were the same object.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">elem1 </span><span class="s0">is not </span><span class="s1">elem2</span><span class="s0">, </span><span class="s1">msg</span>


<span class="s0">def </span><span class="s1">is_extension_array_dtype_and_needs_i8_conversion(left_dtype</span><span class="s0">, </span><span class="s1">right_dtype) -&gt; bool:</span>
    <span class="s4">&quot;&quot;&quot; 
    Checks that we have the combination of an ExtensionArraydtype and 
    a dtype that should be converted to int64 
 
    Returns 
    ------- 
    bool 
 
    Related to issue #37609 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">is_extension_array_dtype(left_dtype) </span><span class="s0">and </span><span class="s1">needs_i8_conversion(right_dtype)</span>


<span class="s0">def </span><span class="s1">assert_indexing_slices_equivalent(ser: Series</span><span class="s0">, </span><span class="s1">l_slc: slice</span><span class="s0">, </span><span class="s1">i_slc: slice):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that ser.iloc[i_slc] matches ser.loc[l_slc] and, if applicable, 
    ser[l_slc]. 
    &quot;&quot;&quot;</span>
    <span class="s1">expected = ser.iloc[i_slc]</span>

    <span class="s1">assert_series_equal(ser.loc[l_slc]</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">if not </span><span class="s1">ser.index.is_integer():</span>
        <span class="s5"># For integer indices, .loc and plain getitem are position-based.</span>
        <span class="s1">assert_series_equal(ser[l_slc]</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">assert_metadata_equivalent(left</span><span class="s0">, </span><span class="s1">right):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check that ._metadata attributes are equivalent. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">left._metadata:</span>
        <span class="s1">val = getattr(left</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">right </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">val </span><span class="s0">is None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">val == getattr(right</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)</span>
</pre>
</body>
</html>