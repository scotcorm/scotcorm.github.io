<html>
<head>
<title>response.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
response.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">http </span><span class="s0">import </span><span class="s1">HTTPStatus</span>

<span class="s0">from </span><span class="s1">.._internal </span><span class="s0">import </span><span class="s1">_to_bytes</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">Headers</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">remove_entity_headers</span>
<span class="s0">from </span><span class="s1">..sansio.response </span><span class="s0">import </span><span class="s1">Response </span><span class="s0">as </span><span class="s1">_SansIOResponse</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">iri_to_uri</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">url_join</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">ClosingIterator</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_current_url</span>
<span class="s0">from </span><span class="s1">werkzeug._internal </span><span class="s0">import </span><span class="s1">_get_environ</span>
<span class="s0">from </span><span class="s1">werkzeug.http </span><span class="s0">import </span><span class="s1">generate_etag</span>
<span class="s0">from </span><span class="s1">werkzeug.http </span><span class="s0">import </span><span class="s1">http_date</span>
<span class="s0">from </span><span class="s1">werkzeug.http </span><span class="s0">import </span><span class="s1">is_resource_modified</span>
<span class="s0">from </span><span class="s1">werkzeug.http </span><span class="s0">import </span><span class="s1">parse_etags</span>
<span class="s0">from </span><span class="s1">werkzeug.http </span><span class="s0">import </span><span class="s1">parse_range_header</span>
<span class="s0">from </span><span class="s1">werkzeug.wsgi </span><span class="s0">import </span><span class="s1">_RangeWrapper</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">import </span><span class="s1">typing_extensions </span><span class="s0">as </span><span class="s1">te</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">StartResponse</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIApplication</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIEnvironment</span>


<span class="s0">def </span><span class="s1">_warn_if_string(iterable: t.Iterable) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Helper for the response objects to check if the iterable returned 
    to the WSGI server is not a string. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(iterable</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Response iterable was set to a string. This will appear to&quot;</span>
            <span class="s3">&quot; work but means that the server will send the data to the&quot;</span>
            <span class="s3">&quot; client one character at a time. This is almost never&quot;</span>
            <span class="s3">&quot; intended behavior, use 'response.data' to assign strings&quot;</span>
            <span class="s3">&quot; to the response object.&quot;</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_iter_encoded(</span>
    <span class="s1">iterable: t.Iterable[t.Union[str</span><span class="s0">, </span><span class="s1">bytes]]</span><span class="s0">, </span><span class="s1">charset: str</span>
<span class="s1">) -&gt; t.Iterator[bytes]:</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">if </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">yield </span><span class="s1">item.encode(charset)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">item</span>


<span class="s0">def </span><span class="s1">_clean_accept_ranges(accept_ranges: t.Union[bool</span><span class="s0">, </span><span class="s1">str]) -&gt; str:</span>
    <span class="s0">if </span><span class="s1">accept_ranges </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s3">&quot;bytes&quot;</span>
    <span class="s0">elif </span><span class="s1">accept_ranges </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s3">&quot;none&quot;</span>
    <span class="s0">elif </span><span class="s1">isinstance(accept_ranges</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">return </span><span class="s1">accept_ranges</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid accept_ranges value&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Response(_SansIOResponse):</span>
    <span class="s2">&quot;&quot;&quot;Represents an outgoing WSGI HTTP response with body, status, and 
    headers. Has properties and methods for using the functionality 
    defined by various HTTP specs. 
 
    The response body is flexible to support different use cases. The 
    simple form is passing bytes, or a string which will be encoded as 
    UTF-8. Passing an iterable of bytes or strings makes this a 
    streaming response. A generator is particularly useful for building 
    a CSV file in memory or using SSE (Server Sent Events). A file-like 
    object is also iterable, although the 
    :func:`~werkzeug.utils.send_file` helper should be used in that 
    case. 
 
    The response object is itself a WSGI application callable. When 
    called (:meth:`__call__`) with ``environ`` and ``start_response``, 
    it will pass its status and headers to ``start_response`` then 
    return its body as an iterable. 
 
    .. code-block:: python 
 
        from werkzeug.wrappers.response import Response 
 
        def index(): 
            return Response(&quot;Hello, World!&quot;) 
 
        def application(environ, start_response): 
            path = environ.get(&quot;PATH_INFO&quot;) or &quot;/&quot; 
 
            if path == &quot;/&quot;: 
                response = index() 
            else: 
                response = Response(&quot;Not Found&quot;, status=404) 
 
            return response(environ, start_response) 
 
    :param response: The data for the body of the response. A string or 
        bytes, or tuple or list of strings or bytes, for a fixed-length 
        response, or any other iterable of strings or bytes for a 
        streaming response. Defaults to an empty body. 
    :param status: The status code for the response. Either an int, in 
        which case the default status message is added, or a string in 
        the form ``{code} {message}``, like ``404 Not Found``. Defaults 
        to 200. 
    :param headers: A :class:`~werkzeug.datastructures.Headers` object, 
        or a list of ``(key, value)`` tuples that will be converted to a 
        ``Headers`` object. 
    :param mimetype: The mime type (content type without charset or 
        other parameters) of the response. If the value starts with 
        ``text/`` (or matches some other special cases), the charset 
        will be added to create the ``content_type``. 
    :param content_type: The full content type of the response. 
        Overrides building the value from ``mimetype``. 
    :param direct_passthrough: Pass the response body directly through 
        as the WSGI iterable. This can be used when the body is a binary 
        file or other iterator of bytes, to skip some unnecessary 
        checks. Use :func:`~werkzeug.utils.send_file` instead of setting 
        this manually. 
 
    .. versionchanged:: 2.0 
        Combine ``BaseResponse`` and mixins into a single ``Response`` 
        class. Using the old classes is deprecated and will be removed 
        in Werkzeug 2.1. 
 
    .. versionchanged:: 0.5 
        The ``direct_passthrough`` parameter was added. 
    &quot;&quot;&quot;</span>

    <span class="s5">#: if set to `False` accessing properties on the response object will</span>
    <span class="s5">#: not try to consume the response iterator and convert it into a list.</span>
    <span class="s5">#:</span>
    <span class="s5">#: .. versionadded:: 0.6.2</span>
    <span class="s5">#:</span>
    <span class="s5">#:    That attribute was previously called `implicit_seqence_conversion`.</span>
    <span class="s5">#:    (Notice the typo).  If you did use this feature, you have to adapt</span>
    <span class="s5">#:    your code to the name change.</span>
    <span class="s1">implicit_sequence_conversion = </span><span class="s0">True</span>

    <span class="s5">#: Should this response object correct the location header to be RFC</span>
    <span class="s5">#: conformant?  This is true by default.</span>
    <span class="s5">#:</span>
    <span class="s5">#: .. versionadded:: 0.8</span>
    <span class="s1">autocorrect_location_header = </span><span class="s0">True</span>

    <span class="s5">#: Should this response object automatically set the content-length</span>
    <span class="s5">#: header if possible?  This is true by default.</span>
    <span class="s5">#:</span>
    <span class="s5">#: .. versionadded:: 0.8</span>
    <span class="s1">automatically_set_content_length = </span><span class="s0">True</span>

    <span class="s5">#: The response body to send as the WSGI iterable. A list of strings</span>
    <span class="s5">#: or bytes represents a fixed-length response, any other iterable</span>
    <span class="s5">#: is a streaming response. Strings are encoded to bytes as UTF-8.</span>
    <span class="s5">#:</span>
    <span class="s5">#: Do not set to a plain string or bytes, that will cause sending</span>
    <span class="s5">#: the response to be very inefficient as it will iterate one byte</span>
    <span class="s5">#: at a time.</span>
    <span class="s1">response: t.Union[t.Iterable[str]</span><span class="s0">, </span><span class="s1">t.Iterable[bytes]]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">response: t.Optional[</span>
            <span class="s1">t.Union[t.Iterable[bytes]</span><span class="s0">, </span><span class="s1">bytes</span><span class="s0">, </span><span class="s1">t.Iterable[str]</span><span class="s0">, </span><span class="s1">str]</span>
        <span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">status: t.Optional[t.Union[int</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">HTTPStatus]] = </span><span class="s0">None,</span>
        <span class="s1">headers: t.Optional[</span>
            <span class="s1">t.Union[</span>
                <span class="s1">t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Union[str</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">t.Iterable[t.Union[str</span><span class="s0">, </span><span class="s1">int]]]]</span><span class="s0">,</span>
                <span class="s1">t.Iterable[t.Tuple[str</span><span class="s0">, </span><span class="s1">t.Union[str</span><span class="s0">, </span><span class="s1">int]]]</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">mimetype: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">content_type: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">direct_passthrough: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">status=status</span><span class="s0">,</span>
            <span class="s1">headers=headers</span><span class="s0">,</span>
            <span class="s1">mimetype=mimetype</span><span class="s0">,</span>
            <span class="s1">content_type=content_type</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5">#: Pass the response body directly through as the WSGI iterable.</span>
        <span class="s5">#: This can be used when the body is a binary file or other</span>
        <span class="s5">#: iterator of bytes, to skip some unnecessary checks. Use</span>
        <span class="s5">#: :func:`~werkzeug.utils.send_file` instead of setting this</span>
        <span class="s5">#: manually.</span>
        <span class="s1">self.direct_passthrough = direct_passthrough</span>
        <span class="s1">self._on_close: t.List[t.Callable[[]</span><span class="s0">, </span><span class="s1">t.Any]] = []</span>

        <span class="s5"># we set the response after the headers so that if a class changes</span>
        <span class="s5"># the charset attribute, the data is set in the correct charset.</span>
        <span class="s0">if </span><span class="s1">response </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.response = []</span>
        <span class="s0">elif </span><span class="s1">isinstance(response</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes</span><span class="s0">, </span><span class="s1">bytearray)):</span>
            <span class="s1">self.set_data(response)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.response = response</span>

    <span class="s0">def </span><span class="s1">call_on_close(self</span><span class="s0">, </span><span class="s1">func: t.Callable[[]</span><span class="s0">, </span><span class="s1">t.Any]) -&gt; t.Callable[[]</span><span class="s0">, </span><span class="s1">t.Any]:</span>
        <span class="s2">&quot;&quot;&quot;Adds a function to the internal list of functions that should 
        be called as part of closing down the response.  Since 0.7 this 
        function also returns the function that was passed so that this 
        can be used as a decorator. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s1">self._on_close.append(func)</span>
        <span class="s0">return </span><span class="s1">func</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.is_sequence:</span>
            <span class="s1">body_info = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">sum(map(len</span><span class="s0">, </span><span class="s1">self.iter_encoded()))</span><span class="s0">} </span><span class="s3">bytes&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">body_info = </span><span class="s3">&quot;streamed&quot; </span><span class="s0">if </span><span class="s1">self.is_streamed </span><span class="s0">else </span><span class="s3">&quot;likely-streamed&quot;</span>
        <span class="s0">return </span><span class="s3">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">body_info</span><span class="s0">} </span><span class="s3">[</span><span class="s0">{</span><span class="s1">self.status</span><span class="s0">}</span><span class="s3">]&gt;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">force_type(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">response: </span><span class="s3">&quot;Response&quot;</span><span class="s0">, </span><span class="s1">environ: t.Optional[</span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Response&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Enforce that the WSGI response is a response object of the current 
        type.  Werkzeug will use the :class:`Response` internally in many 
        situations like the exceptions.  If you call :meth:`get_response` on an 
        exception you will get back a regular :class:`Response` object, even 
        if you are using a custom subclass. 
 
        This method can enforce a given response type, and it will also 
        convert arbitrary WSGI callables into response objects if an environ 
        is provided:: 
 
            # convert a Werkzeug response object into an instance of the 
            # MyResponseClass subclass. 
            response = MyResponseClass.force_type(response) 
 
            # convert any WSGI application into a response object 
            response = MyResponseClass.force_type(response, environ) 
 
        This is especially useful if you want to post-process responses in 
        the main dispatcher and use functionality provided by your subclass. 
 
        Keep in mind that this will modify response objects in place if 
        possible! 
 
        :param response: a response object or wsgi application. 
        :param environ: a WSGI environment object. 
        :return: a response object. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(response</span><span class="s0">, </span><span class="s1">Response):</span>
            <span class="s0">if </span><span class="s1">environ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;cannot convert WSGI application into response&quot;</span>
                    <span class="s3">&quot; objects without an environ&quot;</span>
                <span class="s1">)</span>

            <span class="s0">from </span><span class="s1">..test </span><span class="s0">import </span><span class="s1">run_wsgi_app</span>

            <span class="s1">response = Response(*run_wsgi_app(response</span><span class="s0">, </span><span class="s1">environ))</span>

        <span class="s1">response.__class__ = cls</span>
        <span class="s0">return </span><span class="s1">response</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_app(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">app: </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s0">, </span><span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s0">, </span><span class="s1">buffered: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Response&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Create a new response object from an application output.  This 
        works best if you pass it an application that returns a generator all 
        the time.  Sometimes applications may use the `write()` callable 
        returned by the `start_response` function.  This tries to resolve such 
        edge cases automatically.  But if you don't get the expected output 
        you should set `buffered` to `True` which enforces buffering. 
 
        :param app: the WSGI application to execute. 
        :param environ: the WSGI environment to execute against. 
        :param buffered: set to `True` to enforce buffering. 
        :return: a response object. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">..test </span><span class="s0">import </span><span class="s1">run_wsgi_app</span>

        <span class="s0">return </span><span class="s1">cls(*run_wsgi_app(app</span><span class="s0">, </span><span class="s1">environ</span><span class="s0">, </span><span class="s1">buffered))</span>

    <span class="s1">@typing.overload</span>
    <span class="s0">def </span><span class="s1">get_data(self</span><span class="s0">, </span><span class="s1">as_text: </span><span class="s3">&quot;te.Literal[False]&quot; </span><span class="s1">= </span><span class="s0">False</span><span class="s1">) -&gt; bytes:</span>
        <span class="s1">...</span>

    <span class="s1">@typing.overload</span>
    <span class="s0">def </span><span class="s1">get_data(self</span><span class="s0">, </span><span class="s1">as_text: </span><span class="s3">&quot;te.Literal[True]&quot;</span><span class="s1">) -&gt; str:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">get_data(self</span><span class="s0">, </span><span class="s1">as_text: bool = </span><span class="s0">False</span><span class="s1">) -&gt; t.Union[bytes</span><span class="s0">, </span><span class="s1">str]:</span>
        <span class="s2">&quot;&quot;&quot;The string representation of the response body.  Whenever you call 
        this property the response iterable is encoded and flattened.  This 
        can lead to unwanted behavior if you stream big data. 
 
        This behavior can be disabled by setting 
        :attr:`implicit_sequence_conversion` to `False`. 
 
        If `as_text` is set to `True` the return value will be a decoded 
        string. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">self._ensure_sequence()</span>
        <span class="s1">rv = </span><span class="s6">b&quot;&quot;</span><span class="s1">.join(self.iter_encoded())</span>

        <span class="s0">if </span><span class="s1">as_text:</span>
            <span class="s0">return </span><span class="s1">rv.decode(self.charset)</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">set_data(self</span><span class="s0">, </span><span class="s1">value: t.Union[bytes</span><span class="s0">, </span><span class="s1">str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Sets a new string as response.  The value must be a string or 
        bytes. If a string is set it's encoded to the charset of the 
        response (utf-8 by default). 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s5"># if a string is set, it's encoded directly so that we</span>
        <span class="s5"># can set the content length</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">value = value.encode(self.charset)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">value = bytes(value)</span>
        <span class="s1">self.response = [value]</span>
        <span class="s0">if </span><span class="s1">self.automatically_set_content_length:</span>
            <span class="s1">self.headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = str(len(value))</span>

    <span class="s1">data = property(</span>
        <span class="s1">get_data</span><span class="s0">,</span>
        <span class="s1">set_data</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;A descriptor that calls :meth:`get_data` and :meth:`set_data`.&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">calculate_content_length(self) -&gt; t.Optional[int]:</span>
        <span class="s2">&quot;&quot;&quot;Returns the content length if available or `None` otherwise.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._ensure_sequence()</span>
        <span class="s0">except </span><span class="s1">RuntimeError:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">sum(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.iter_encoded())</span>

    <span class="s0">def </span><span class="s1">_ensure_sequence(self</span><span class="s0">, </span><span class="s1">mutable: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;This method can be called by methods that need a sequence.  If 
        `mutable` is true, it will also ensure that the response sequence 
        is a standard Python list. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_sequence:</span>
            <span class="s5"># if we need a mutable object, we ensure it's a list.</span>
            <span class="s0">if </span><span class="s1">mutable </span><span class="s0">and not </span><span class="s1">isinstance(self.response</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">self.response = list(self.response)  </span><span class="s5"># type: ignore</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self.direct_passthrough:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;Attempted implicit sequence conversion but the&quot;</span>
                <span class="s3">&quot; response object is in direct passthrough mode.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">self.implicit_sequence_conversion:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;The response object required the iterable to be a&quot;</span>
                <span class="s3">&quot; sequence, but the implicit conversion was disabled.&quot;</span>
                <span class="s3">&quot; Call make_sequence() yourself.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self.make_sequence()</span>

    <span class="s0">def </span><span class="s1">make_sequence(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Converts the response iterator in a list.  By default this happens 
        automatically if required.  If `implicit_sequence_conversion` is 
        disabled, this method is not automatically called and some properties 
        might raise exceptions.  This also encodes all the items. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_sequence:</span>
            <span class="s5"># if we consume an iterable we have to ensure that the close</span>
            <span class="s5"># method of the iterable is called if available when we tear</span>
            <span class="s5"># down the response</span>
            <span class="s1">close = getattr(self.response</span><span class="s0">, </span><span class="s3">&quot;close&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">self.response = list(self.iter_encoded())</span>
            <span class="s0">if </span><span class="s1">close </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.call_on_close(close)</span>

    <span class="s0">def </span><span class="s1">iter_encoded(self) -&gt; t.Iterator[bytes]:</span>
        <span class="s2">&quot;&quot;&quot;Iter the response encoded with the encoding of the response. 
        If the response object is invoked as WSGI application the return 
        value of this method is used as application iterator unless 
        :attr:`direct_passthrough` was activated. 
        &quot;&quot;&quot;</span>
        <span class="s0">if __debug__</span><span class="s1">:</span>
            <span class="s1">_warn_if_string(self.response)</span>
        <span class="s5"># Encode in a separate function so that self.response is fetched</span>
        <span class="s5"># early.  This allows us to wrap the response with the return</span>
        <span class="s5"># value from get_app_iter or iter_encoded.</span>
        <span class="s0">return </span><span class="s1">_iter_encoded(self.response</span><span class="s0">, </span><span class="s1">self.charset)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_streamed(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;If the response is streamed (the response is not an iterable with 
        a length information) this property is `True`.  In this case streamed 
        means that there is no information about the number of iterations. 
        This is usually `True` if a generator is passed to the response object. 
 
        This is useful for checking before applying some sort of post 
        filtering that should not take place for streamed responses. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">len(self.response)  </span><span class="s5"># type: ignore</span>
        <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">AttributeError):</span>
            <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_sequence(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;If the iterator is buffered, this property will be `True`.  A 
        response object will consider an iterator to be buffered if the 
        response attribute is a list or tuple. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">isinstance(self.response</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list))</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Close the wrapped response if possible.  You can also use the object 
        in a with statement which will automatically close it. 
 
        .. versionadded:: 0.9 
           Can now be used in a with statement. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr(self.response</span><span class="s0">, </span><span class="s3">&quot;close&quot;</span><span class="s1">):</span>
            <span class="s1">self.response.close()  </span><span class="s5"># type: ignore</span>
        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self._on_close:</span>
            <span class="s1">func()</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s3">&quot;Response&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">tb):  </span><span class="s5"># type: ignore</span>
        <span class="s1">self.close()</span>

    <span class="s0">def </span><span class="s1">freeze(self</span><span class="s0">, </span><span class="s1">no_etag: </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Make the response object ready to be pickled. Does the 
        following: 
 
        *   Buffer the response into a list, ignoring 
            :attr:`implicity_sequence_conversion` and 
            :attr:`direct_passthrough`. 
        *   Set the ``Content-Length`` header. 
        *   Generate an ``ETag`` header if one is not already set. 
 
        .. versionchanged:: 2.0 
            An ``ETag`` header is added, the ``no_etag`` parameter is 
            deprecated and will be removed in Werkzeug 2.1. 
 
        .. versionchanged:: 0.6 
            The ``Content-Length`` header is set. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Always freeze the encoded response body, ignore</span>
        <span class="s5"># implicit_sequence_conversion and direct_passthrough.</span>
        <span class="s1">self.response = list(self.iter_encoded())</span>
        <span class="s1">self.headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = str(sum(map(len</span><span class="s0">, </span><span class="s1">self.response)))</span>

        <span class="s0">if </span><span class="s1">no_etag </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;The 'no_etag' parameter is deprecated and will be&quot;</span>
                <span class="s3">&quot; removed in Werkzeug 2.1.&quot;</span><span class="s0">,</span>
                <span class="s1">DeprecationWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">self.add_etag()</span>

    <span class="s0">def </span><span class="s1">get_wsgi_headers(self</span><span class="s0">, </span><span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">) -&gt; Headers:</span>
        <span class="s2">&quot;&quot;&quot;This is automatically called right before the response is started 
        and returns headers modified for the given environment.  It returns a 
        copy of the headers from the response with some modifications applied 
        if necessary. 
 
        For example the location header (if present) is joined with the root 
        URL of the environment.  Also the content length is automatically set 
        to zero here for certain status codes. 
 
        .. versionchanged:: 0.6 
           Previously that function was called `fix_headers` and modified 
           the response object in place.  Also since 0.6, IRIs in location 
           and content-location headers are handled properly. 
 
           Also starting with 0.6, Werkzeug will attempt to set the content 
           length if it is able to figure it out on its own.  This is the 
           case if all the strings in the response iterable are already 
           encoded and the iterable is buffered. 
 
        :param environ: the WSGI environment of the request. 
        :return: returns a new :class:`~werkzeug.datastructures.Headers` 
                 object. 
        &quot;&quot;&quot;</span>
        <span class="s1">headers = Headers(self.headers)</span>
        <span class="s1">location: t.Optional[str] = </span><span class="s0">None</span>
        <span class="s1">content_location: t.Optional[str] = </span><span class="s0">None</span>
        <span class="s1">content_length: t.Optional[t.Union[str</span><span class="s0">, </span><span class="s1">int]] = </span><span class="s0">None</span>
        <span class="s1">status = self.status_code</span>

        <span class="s5"># iterate over the headers to find all values in one go.  Because</span>
        <span class="s5"># get_wsgi_headers is used each response that gives us a tiny</span>
        <span class="s5"># speedup.</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">headers:</span>
            <span class="s1">ikey = key.lower()</span>
            <span class="s0">if </span><span class="s1">ikey == </span><span class="s3">&quot;location&quot;</span><span class="s1">:</span>
                <span class="s1">location = value</span>
            <span class="s0">elif </span><span class="s1">ikey == </span><span class="s3">&quot;content-location&quot;</span><span class="s1">:</span>
                <span class="s1">content_location = value</span>
            <span class="s0">elif </span><span class="s1">ikey == </span><span class="s3">&quot;content-length&quot;</span><span class="s1">:</span>
                <span class="s1">content_length = value</span>

        <span class="s5"># make sure the location header is an absolute URL</span>
        <span class="s0">if </span><span class="s1">location </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">old_location = location</span>
            <span class="s0">if </span><span class="s1">isinstance(location</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s5"># Safe conversion is necessary here as we might redirect</span>
                <span class="s5"># to a broken URI scheme (for instance itms-services).</span>
                <span class="s1">location = iri_to_uri(location</span><span class="s0">, </span><span class="s1">safe_conversion=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.autocorrect_location_header:</span>
                <span class="s1">current_url = get_current_url(environ</span><span class="s0">, </span><span class="s1">strip_querystring=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(current_url</span><span class="s0">, </span><span class="s1">str):</span>
                    <span class="s1">current_url = iri_to_uri(current_url)</span>
                <span class="s1">location = url_join(current_url</span><span class="s0">, </span><span class="s1">location)</span>
            <span class="s0">if </span><span class="s1">location != old_location:</span>
                <span class="s1">headers[</span><span class="s3">&quot;Location&quot;</span><span class="s1">] = location</span>

        <span class="s5"># make sure the content location is a URL</span>
        <span class="s0">if </span><span class="s1">content_location </span><span class="s0">is not None and </span><span class="s1">isinstance(content_location</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">headers[</span><span class="s3">&quot;Content-Location&quot;</span><span class="s1">] = iri_to_uri(content_location)</span>

        <span class="s0">if </span><span class="s4">100 </span><span class="s1">&lt;= status &lt; </span><span class="s4">200 </span><span class="s0">or </span><span class="s1">status == </span><span class="s4">204</span><span class="s1">:</span>
            <span class="s5"># Per section 3.3.2 of RFC 7230, &quot;a server MUST NOT send a</span>
            <span class="s5"># Content-Length header field in any response with a status</span>
            <span class="s5"># code of 1xx (Informational) or 204 (No Content).&quot;</span>
            <span class="s1">headers.remove(</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">status == </span><span class="s4">304</span><span class="s1">:</span>
            <span class="s1">remove_entity_headers(headers)</span>

        <span class="s5"># if we can determine the content length automatically, we</span>
        <span class="s5"># should try to do that.  But only if this does not involve</span>
        <span class="s5"># flattening the iterator or encoding of strings in the</span>
        <span class="s5"># response. We however should not do that if we have a 304</span>
        <span class="s5"># response.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">self.automatically_set_content_length</span>
            <span class="s0">and </span><span class="s1">self.is_sequence</span>
            <span class="s0">and </span><span class="s1">content_length </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">status </span><span class="s0">not in </span><span class="s1">(</span><span class="s4">204</span><span class="s0">, </span><span class="s4">304</span><span class="s1">)</span>
            <span class="s0">and not </span><span class="s1">(</span><span class="s4">100 </span><span class="s1">&lt;= status &lt; </span><span class="s4">200</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">content_length = sum(len(_to_bytes(x</span><span class="s0">, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.response)</span>
            <span class="s0">except </span><span class="s1">UnicodeError:</span>
                <span class="s5"># Something other than bytes, can't safely figure out</span>
                <span class="s5"># the length of the response.</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = str(content_length)</span>

        <span class="s0">return </span><span class="s1">headers</span>

    <span class="s0">def </span><span class="s1">get_app_iter(self</span><span class="s0">, </span><span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">) -&gt; t.Iterable[bytes]:</span>
        <span class="s2">&quot;&quot;&quot;Returns the application iterator for the given environ.  Depending 
        on the request method and the current status code the return value 
        might be an empty response rather than the one from the response. 
 
        If the request method is `HEAD` or the status code is in a range 
        where the HTTP specification requires an empty response, an empty 
        iterable is returned. 
 
        .. versionadded:: 0.6 
 
        :param environ: the WSGI environment of the request. 
        :return: a response iterable. 
        &quot;&quot;&quot;</span>
        <span class="s1">status = self.status_code</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">environ[</span><span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">] == </span><span class="s3">&quot;HEAD&quot;</span>
            <span class="s0">or </span><span class="s4">100 </span><span class="s1">&lt;= status &lt; </span><span class="s4">200</span>
            <span class="s0">or </span><span class="s1">status </span><span class="s0">in </span><span class="s1">(</span><span class="s4">204</span><span class="s0">, </span><span class="s4">304</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">iterable: t.Iterable[bytes] = ()</span>
        <span class="s0">elif </span><span class="s1">self.direct_passthrough:</span>
            <span class="s0">if __debug__</span><span class="s1">:</span>
                <span class="s1">_warn_if_string(self.response)</span>
            <span class="s0">return </span><span class="s1">self.response  </span><span class="s5"># type: ignore</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">iterable = self.iter_encoded()</span>
        <span class="s0">return </span><span class="s1">ClosingIterator(iterable</span><span class="s0">, </span><span class="s1">self.close)</span>

    <span class="s0">def </span><span class="s1">get_wsgi_response(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span>
    <span class="s1">) -&gt; t.Tuple[t.Iterable[bytes]</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">t.List[t.Tuple[str</span><span class="s0">, </span><span class="s1">str]]]:</span>
        <span class="s2">&quot;&quot;&quot;Returns the final WSGI response as tuple.  The first item in 
        the tuple is the application iterator, the second the status and 
        the third the list of headers.  The response returned is created 
        specially for the given environment.  For example if the request 
        method in the WSGI environment is ``'HEAD'`` the response will 
        be empty and only the headers and status code will be present. 
 
        .. versionadded:: 0.6 
 
        :param environ: the WSGI environment of the request. 
        :return: an ``(app_iter, status, headers)`` tuple. 
        &quot;&quot;&quot;</span>
        <span class="s1">headers = self.get_wsgi_headers(environ)</span>
        <span class="s1">app_iter = self.get_app_iter(environ)</span>
        <span class="s0">return </span><span class="s1">app_iter</span><span class="s0">, </span><span class="s1">self.status</span><span class="s0">, </span><span class="s1">headers.to_wsgi_list()</span>

    <span class="s0">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s0">, </span><span class="s1">start_response: </span><span class="s3">&quot;StartResponse&quot;</span>
    <span class="s1">) -&gt; t.Iterable[bytes]:</span>
        <span class="s2">&quot;&quot;&quot;Process this response as WSGI application. 
 
        :param environ: the WSGI environment. 
        :param start_response: the response callable provided by the WSGI 
                               server. 
        :return: an application iterator 
        &quot;&quot;&quot;</span>
        <span class="s1">app_iter</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">headers = self.get_wsgi_response(environ)</span>
        <span class="s1">start_response(status</span><span class="s0">, </span><span class="s1">headers)</span>
        <span class="s0">return </span><span class="s1">app_iter</span>

    <span class="s5"># JSON</span>

    <span class="s5">#: A module or other object that has ``dumps`` and ``loads``</span>
    <span class="s5">#: functions that match the API of the built-in :mod:`json` module.</span>
    <span class="s1">json_module = json</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">json(self) -&gt; t.Optional[t.Any]:</span>
        <span class="s2">&quot;&quot;&quot;The parsed JSON data if :attr:`mimetype` indicates JSON 
        (:mimetype:`application/json`, see :attr:`is_json`). 
 
        Calls :meth:`get_json` with default arguments. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_json()</span>

    <span class="s0">def </span><span class="s1">get_json(self</span><span class="s0">, </span><span class="s1">force: bool = </span><span class="s0">False, </span><span class="s1">silent: bool = </span><span class="s0">False</span><span class="s1">) -&gt; t.Optional[t.Any]:</span>
        <span class="s2">&quot;&quot;&quot;Parse :attr:`data` as JSON. Useful during testing. 
 
        If the mimetype does not indicate JSON 
        (:mimetype:`application/json`, see :attr:`is_json`), this 
        returns ``None``. 
 
        Unlike :meth:`Request.get_json`, the result is not cached. 
 
        :param force: Ignore the mimetype and always try to parse JSON. 
        :param silent: Silence parsing errors and return ``None`` 
            instead. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">(force </span><span class="s0">or </span><span class="s1">self.is_json):</span>
            <span class="s0">return None</span>

        <span class="s1">data = self.get_data()</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.json_module.loads(data)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">if not </span><span class="s1">silent:</span>
                <span class="s0">raise</span>

            <span class="s0">return None</span>

    <span class="s5"># Stream</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">stream(self) -&gt; </span><span class="s3">&quot;ResponseStream&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;The response iterable as write-only stream.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ResponseStream(self)</span>

    <span class="s0">def </span><span class="s1">_wrap_range_response(self</span><span class="s0">, </span><span class="s1">start: int</span><span class="s0">, </span><span class="s1">length: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Wrap existing Response in case of Range Request context.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.status_code == </span><span class="s4">206</span><span class="s1">:</span>
            <span class="s1">self.response = _RangeWrapper(self.response</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">length)  </span><span class="s5"># type: ignore</span>

    <span class="s0">def </span><span class="s1">_is_range_request_processable(self</span><span class="s0">, </span><span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return ``True`` if `Range` header is present and if underlying 
        resource is considered unchanged when compared with `If-Range` header. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s3">&quot;HTTP_IF_RANGE&quot; </span><span class="s0">not in </span><span class="s1">environ</span>
            <span class="s0">or not </span><span class="s1">is_resource_modified(</span>
                <span class="s1">environ</span><span class="s0">,</span>
                <span class="s1">self.headers.get(</span><span class="s3">&quot;etag&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s0">None,</span>
                <span class="s1">self.headers.get(</span><span class="s3">&quot;last-modified&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">ignore_if_range=</span><span class="s0">False,</span>
            <span class="s1">)</span>
        <span class="s1">) </span><span class="s0">and </span><span class="s3">&quot;HTTP_RANGE&quot; </span><span class="s0">in </span><span class="s1">environ</span>

    <span class="s0">def </span><span class="s1">_process_range_request(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s0">,</span>
        <span class="s1">complete_length: t.Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">accept_ranges: t.Optional[t.Union[bool</span><span class="s0">, </span><span class="s1">str]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Handle Range Request related headers (RFC7233).  If `Accept-Ranges` 
        header is valid, and Range Request is processable, we set the headers 
        as described by the RFC, and wrap the underlying response in a 
        RangeWrapper. 
 
        Returns ``True`` if Range Request can be fulfilled, ``False`` otherwise. 
 
        :raises: :class:`~werkzeug.exceptions.RequestedRangeNotSatisfiable` 
                 if `Range` header could not be parsed or satisfied. 
 
        .. versionchanged:: 2.0 
            Returns ``False`` if the length is 0. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">..exceptions </span><span class="s0">import </span><span class="s1">RequestedRangeNotSatisfiable</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">accept_ranges </span><span class="s0">is None</span>
            <span class="s0">or </span><span class="s1">complete_length </span><span class="s0">is None</span>
            <span class="s0">or </span><span class="s1">complete_length == </span><span class="s4">0</span>
            <span class="s0">or not </span><span class="s1">self._is_range_request_processable(environ)</span>
        <span class="s1">):</span>
            <span class="s0">return False</span>

        <span class="s1">parsed_range = parse_range_header(environ.get(</span><span class="s3">&quot;HTTP_RANGE&quot;</span><span class="s1">))</span>

        <span class="s0">if </span><span class="s1">parsed_range </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RequestedRangeNotSatisfiable(complete_length)</span>

        <span class="s1">range_tuple = parsed_range.range_for_length(complete_length)</span>
        <span class="s1">content_range_header = parsed_range.to_content_range_header(complete_length)</span>

        <span class="s0">if </span><span class="s1">range_tuple </span><span class="s0">is None or </span><span class="s1">content_range_header </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RequestedRangeNotSatisfiable(complete_length)</span>

        <span class="s1">content_length = range_tuple[</span><span class="s4">1</span><span class="s1">] - range_tuple[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = content_length</span>
        <span class="s1">self.headers[</span><span class="s3">&quot;Accept-Ranges&quot;</span><span class="s1">] = accept_ranges</span>
        <span class="s1">self.content_range = content_range_header  </span><span class="s5"># type: ignore</span>
        <span class="s1">self.status_code = </span><span class="s4">206</span>
        <span class="s1">self._wrap_range_response(range_tuple[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">content_length)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">make_conditional(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">request_or_environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s0">,</span>
        <span class="s1">accept_ranges: t.Union[bool</span><span class="s0">, </span><span class="s1">str] = </span><span class="s0">False,</span>
        <span class="s1">complete_length: t.Optional[int] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Response&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Make the response conditional to the request.  This method works 
        best if an etag was defined for the response already.  The `add_etag` 
        method can be used to do that.  If called without etag just the date 
        header is set. 
 
        This does nothing if the request method in the request or environ is 
        anything but GET or HEAD. 
 
        For optimal performance when handling range requests, it's recommended 
        that your response data object implements `seekable`, `seek` and `tell` 
        methods as described by :py:class:`io.IOBase`.  Objects returned by 
        :meth:`~werkzeug.wsgi.wrap_file` automatically implement those methods. 
 
        It does not remove the body of the response because that's something 
        the :meth:`__call__` function does for us automatically. 
 
        Returns self so that you can do ``return resp.make_conditional(req)`` 
        but modifies the object in-place. 
 
        :param request_or_environ: a request object or WSGI environment to be 
                                   used to make the response conditional 
                                   against. 
        :param accept_ranges: This parameter dictates the value of 
                              `Accept-Ranges` header. If ``False`` (default), 
                              the header is not set. If ``True``, it will be set 
                              to ``&quot;bytes&quot;``. If ``None``, it will be set to 
                              ``&quot;none&quot;``. If it's a string, it will use this 
                              value. 
        :param complete_length: Will be used only in valid Range Requests. 
                                It will set `Content-Range` complete length 
                                value and compute `Content-Length` real value. 
                                This parameter is mandatory for successful 
                                Range Requests completion. 
        :raises: :class:`~werkzeug.exceptions.RequestedRangeNotSatisfiable` 
                 if `Range` header could not be parsed or satisfied. 
 
        .. versionchanged:: 2.0 
            Range processing is skipped if length is 0 instead of 
            raising a 416 Range Not Satisfiable error. 
        &quot;&quot;&quot;</span>
        <span class="s1">environ = _get_environ(request_or_environ)</span>
        <span class="s0">if </span><span class="s1">environ[</span><span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">] </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;GET&quot;</span><span class="s0">, </span><span class="s3">&quot;HEAD&quot;</span><span class="s1">):</span>
            <span class="s5"># if the date is not in the headers, add it now.  We however</span>
            <span class="s5"># will not override an already existing header.  Unfortunately</span>
            <span class="s5"># this header will be overriden by many WSGI servers including</span>
            <span class="s5"># wsgiref.</span>
            <span class="s0">if </span><span class="s3">&quot;date&quot; </span><span class="s0">not in </span><span class="s1">self.headers:</span>
                <span class="s1">self.headers[</span><span class="s3">&quot;Date&quot;</span><span class="s1">] = http_date()</span>
            <span class="s1">accept_ranges = _clean_accept_ranges(accept_ranges)</span>
            <span class="s1">is206 = self._process_range_request(environ</span><span class="s0">, </span><span class="s1">complete_length</span><span class="s0">, </span><span class="s1">accept_ranges)</span>
            <span class="s0">if not </span><span class="s1">is206 </span><span class="s0">and not </span><span class="s1">is_resource_modified(</span>
                <span class="s1">environ</span><span class="s0">,</span>
                <span class="s1">self.headers.get(</span><span class="s3">&quot;etag&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s0">None,</span>
                <span class="s1">self.headers.get(</span><span class="s3">&quot;last-modified&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">):</span>
                <span class="s0">if </span><span class="s1">parse_etags(environ.get(</span><span class="s3">&quot;HTTP_IF_MATCH&quot;</span><span class="s1">)):</span>
                    <span class="s1">self.status_code = </span><span class="s4">412</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.status_code = </span><span class="s4">304</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">self.automatically_set_content_length</span>
                <span class="s0">and </span><span class="s3">&quot;content-length&quot; </span><span class="s0">not in </span><span class="s1">self.headers</span>
            <span class="s1">):</span>
                <span class="s1">length = self.calculate_content_length()</span>
                <span class="s0">if </span><span class="s1">length </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">self.headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = length</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">add_etag(self</span><span class="s0">, </span><span class="s1">overwrite: bool = </span><span class="s0">False, </span><span class="s1">weak: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Add an etag for the current response if there is none yet. 
 
        .. versionchanged:: 2.0 
            SHA-1 is used to generate the value. MD5 may not be 
            available in some environments. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">overwrite </span><span class="s0">or </span><span class="s3">&quot;etag&quot; </span><span class="s0">not in </span><span class="s1">self.headers:</span>
            <span class="s1">self.set_etag(generate_etag(self.get_data())</span><span class="s0">, </span><span class="s1">weak)</span>


<span class="s0">class </span><span class="s1">ResponseStream:</span>
    <span class="s2">&quot;&quot;&quot;A file descriptor like object used by the :class:`ResponseStreamMixin` to 
    represent the body of the stream.  It directly pushes into the response 
    iterable of the response object. 
    &quot;&quot;&quot;</span>

    <span class="s1">mode = </span><span class="s3">&quot;wb+&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">response: Response):</span>
        <span class="s1">self.response = response</span>
        <span class="s1">self.closed = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">write(self</span><span class="s0">, </span><span class="s1">value: bytes) -&gt; int:</span>
        <span class="s0">if </span><span class="s1">self.closed:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>
        <span class="s1">self.response._ensure_sequence(mutable=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.response.response.append(value)  </span><span class="s5"># type: ignore</span>
        <span class="s1">self.response.headers.pop(</span><span class="s3">&quot;Content-Length&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">len(value)</span>

    <span class="s0">def </span><span class="s1">writelines(self</span><span class="s0">, </span><span class="s1">seq: t.Iterable[bytes]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
            <span class="s1">self.write(item)</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.closed = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">flush(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self.closed:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">isatty(self) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">self.closed:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">tell(self) -&gt; int:</span>
        <span class="s1">self.response._ensure_sequence()</span>
        <span class="s0">return </span><span class="s1">sum(map(len</span><span class="s0">, </span><span class="s1">self.response.response))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">encoding(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.response.charset</span>


<span class="s0">class </span><span class="s1">ResponseStreamMixin:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args: t.Any</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;'ResponseStreamMixin' is deprecated and will be removed in&quot;</span>
            <span class="s3">&quot; Werkzeug 2.1. 'Response' now includes the functionality&quot;</span>
            <span class="s3">&quot; directly.&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)  </span><span class="s5"># type: ignore</span>
</pre>
</body>
</html>