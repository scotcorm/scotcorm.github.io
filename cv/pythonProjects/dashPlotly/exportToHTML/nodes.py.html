<html>
<head>
<title>nodes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
nodes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;AST nodes generated by the parser for the compiler. Also provides 
some node tree helper functions used by the parser and compiler in order 
to normalize nodes. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>

<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">Markup</span>

<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">_PassArg</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>

<span class="s1">_NodeBound = t.TypeVar(</span><span class="s3">&quot;_NodeBound&quot;</span><span class="s2">, </span><span class="s1">bound=</span><span class="s3">&quot;Node&quot;</span><span class="s1">)</span>

<span class="s1">_binop_to_func: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Callable[[t.Any</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = {</span>
    <span class="s3">&quot;*&quot;</span><span class="s1">: operator.mul</span><span class="s2">,</span>
    <span class="s3">&quot;/&quot;</span><span class="s1">: operator.truediv</span><span class="s2">,</span>
    <span class="s3">&quot;//&quot;</span><span class="s1">: operator.floordiv</span><span class="s2">,</span>
    <span class="s3">&quot;**&quot;</span><span class="s1">: operator.pow</span><span class="s2">,</span>
    <span class="s3">&quot;%&quot;</span><span class="s1">: operator.mod</span><span class="s2">,</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: operator.add</span><span class="s2">,</span>
    <span class="s3">&quot;-&quot;</span><span class="s1">: operator.sub</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">_uaop_to_func: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = {</span>
    <span class="s3">&quot;not&quot;</span><span class="s1">: operator.not_</span><span class="s2">,</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: operator.pos</span><span class="s2">,</span>
    <span class="s3">&quot;-&quot;</span><span class="s1">: operator.neg</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">_cmpop_to_func: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Callable[[t.Any</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = {</span>
    <span class="s3">&quot;eq&quot;</span><span class="s1">: operator.eq</span><span class="s2">,</span>
    <span class="s3">&quot;ne&quot;</span><span class="s1">: operator.ne</span><span class="s2">,</span>
    <span class="s3">&quot;gt&quot;</span><span class="s1">: operator.gt</span><span class="s2">,</span>
    <span class="s3">&quot;gteq&quot;</span><span class="s1">: operator.ge</span><span class="s2">,</span>
    <span class="s3">&quot;lt&quot;</span><span class="s1">: operator.lt</span><span class="s2">,</span>
    <span class="s3">&quot;lteq&quot;</span><span class="s1">: operator.le</span><span class="s2">,</span>
    <span class="s3">&quot;in&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a </span><span class="s2">in </span><span class="s1">b</span><span class="s2">,</span>
    <span class="s3">&quot;notin&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a </span><span class="s2">not in </span><span class="s1">b</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">Impossible(Exception):</span>
    <span class="s0">&quot;&quot;&quot;Raised if the node could not perform a requested action.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">NodeType(type):</span>
    <span class="s0">&quot;&quot;&quot;A metaclass for nodes that handles the field and attribute 
    inheritance.  fields and attributes from the parent class are 
    automatically forwarded to the child.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__new__(mcs</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">d):  </span><span class="s4"># type: ignore</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s3">&quot;fields&quot;</span><span class="s2">, </span><span class="s3">&quot;attributes&quot;</span><span class="s1">:</span>
            <span class="s1">storage = []</span>
            <span class="s1">storage.extend(getattr(bases[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">bases </span><span class="s2">else </span><span class="s1">object</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">()))</span>
            <span class="s1">storage.extend(d.get(attr</span><span class="s2">, </span><span class="s1">()))</span>
            <span class="s2">assert </span><span class="s1">len(bases) &lt;= </span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;multiple inheritance not allowed&quot;</span>
            <span class="s2">assert </span><span class="s1">len(storage) == len(set(storage))</span><span class="s2">, </span><span class="s3">&quot;layout conflict&quot;</span>
            <span class="s1">d[attr] = tuple(storage)</span>
        <span class="s1">d.setdefault(</span><span class="s3">&quot;abstract&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">type.__new__(mcs</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">d)</span>


<span class="s2">class </span><span class="s1">EvalContext:</span>
    <span class="s0">&quot;&quot;&quot;Holds evaluation time information.  Custom attributes can be attached 
    to it in extensions. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template_name: t.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.environment = environment</span>
        <span class="s2">if </span><span class="s1">callable(environment.autoescape):</span>
            <span class="s1">self.autoescape = environment.autoescape(template_name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.autoescape = environment.autoescape</span>
        <span class="s1">self.volatile = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">save(self) -&gt; t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s2">return </span><span class="s1">self.__dict__.copy()</span>

    <span class="s2">def </span><span class="s1">revert(self</span><span class="s2">, </span><span class="s1">old: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.__dict__.clear()</span>
        <span class="s1">self.__dict__.update(old)</span>


<span class="s2">def </span><span class="s1">get_eval_context(node: </span><span class="s3">&quot;Node&quot;</span><span class="s2">, </span><span class="s1">ctx: t.Optional[EvalContext]) -&gt; EvalContext:</span>
    <span class="s2">if </span><span class="s1">ctx </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">node.environment </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;if no eval context is passed, the node must have an&quot;</span>
                <span class="s3">&quot; attached environment.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">EvalContext(node.environment)</span>
    <span class="s2">return </span><span class="s1">ctx</span>


<span class="s2">class </span><span class="s1">Node(metaclass=NodeType):</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for all Jinja nodes.  There are a number of nodes available 
    of different types.  There are four major types: 
 
    -   :class:`Stmt`: statements 
    -   :class:`Expr`: expressions 
    -   :class:`Helper`: helper nodes 
    -   :class:`Template`: the outermost wrapper node 
 
    All nodes have fields and attributes.  Fields may be other nodes, lists, 
    or arbitrary values.  Fields are passed to the constructor as regular 
    positional arguments, attributes as keyword arguments.  Each node has 
    two attributes: `lineno` (the line number of the node) and `environment`. 
    The `environment` attribute is set at the end of the parsing process for 
    all nodes automatically. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields: t.Tuple[str</span><span class="s2">, </span><span class="s1">...] = ()</span>
    <span class="s1">attributes: t.Tuple[str</span><span class="s2">, </span><span class="s1">...] = (</span><span class="s3">&quot;lineno&quot;</span><span class="s2">, </span><span class="s3">&quot;environment&quot;</span><span class="s1">)</span>
    <span class="s1">abstract = </span><span class="s2">True</span>

    <span class="s1">lineno: int</span>
    <span class="s1">environment: t.Optional[</span><span class="s3">&quot;Environment&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*fields: t.Any</span><span class="s2">, </span><span class="s1">**attributes: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.abstract:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;abstract nodes are not instantiable&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fields:</span>
            <span class="s2">if </span><span class="s1">len(fields) != len(self.fields):</span>
                <span class="s2">if not </span><span class="s1">self.fields:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">!r} </span><span class="s3">takes 0 arguments&quot;</span><span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">!r} </span><span class="s3">takes 0 or </span><span class="s2">{</span><span class="s1">len(self.fields)</span><span class="s2">}</span><span class="s3">&quot;</span>
                    <span class="s3">f&quot; argument</span><span class="s2">{</span><span class="s3">'s' </span><span class="s2">if </span><span class="s1">len(self.fields) != </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">''</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">zip(self.fields</span><span class="s2">, </span><span class="s1">fields):</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">arg)</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.attributes:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">attributes.pop(attr</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">attributes:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;unknown attribute </span><span class="s2">{</span><span class="s1">next(iter(attributes))</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">iter_fields(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">exclude: t.Optional[t.Container[str]] = </span><span class="s2">None,</span>
        <span class="s1">only: t.Optional[t.Container[str]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Iterator[t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
        <span class="s0">&quot;&quot;&quot;This method iterates over all fields that are defined and yields 
        ``(key, value)`` tuples.  Per default all fields are returned, but 
        it's possible to limit that to some fields by providing the `only` 
        parameter or to exclude some using the `exclude` parameter.  Both 
        should be sets or tuples of field names. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.fields:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">(exclude </span><span class="s2">is None and </span><span class="s1">only </span><span class="s2">is None</span><span class="s1">)</span>
                <span class="s2">or </span><span class="s1">(exclude </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">exclude)</span>
                <span class="s2">or </span><span class="s1">(only </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">only)</span>
            <span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">yield </span><span class="s1">name</span><span class="s2">, </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">iter_child_nodes(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">exclude: t.Optional[t.Container[str]] = </span><span class="s2">None,</span>
        <span class="s1">only: t.Optional[t.Container[str]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Node&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Iterates over all direct child nodes of the node.  This iterates 
        over all fields and yields the values of they are nodes.  If the value 
        of a field is a list all the nodes in that list are returned. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.iter_fields(exclude</span><span class="s2">, </span><span class="s1">only):</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">item:</span>
                    <span class="s2">if </span><span class="s1">isinstance(n</span><span class="s2">, </span><span class="s1">Node):</span>
                        <span class="s2">yield </span><span class="s1">n</span>
            <span class="s2">elif </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">Node):</span>
                <span class="s2">yield </span><span class="s1">item</span>

    <span class="s2">def </span><span class="s1">find(self</span><span class="s2">, </span><span class="s1">node_type: t.Type[_NodeBound]) -&gt; t.Optional[_NodeBound]:</span>
        <span class="s0">&quot;&quot;&quot;Find the first node of a given type.  If no such node exists the 
        return value is `None`. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">self.find_all(node_type):</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">find_all(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node_type: t.Union[t.Type[_NodeBound]</span><span class="s2">, </span><span class="s1">t.Tuple[t.Type[_NodeBound]</span><span class="s2">, </span><span class="s1">...]]</span>
    <span class="s1">) -&gt; t.Iterator[_NodeBound]:</span>
        <span class="s0">&quot;&quot;&quot;Find all the nodes of a given type.  If the type is a tuple, 
        the check is performed for any of the tuple items. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">self.iter_child_nodes():</span>
            <span class="s2">if </span><span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">node_type):</span>
                <span class="s2">yield </span><span class="s1">child  </span><span class="s4"># type: ignore</span>
            <span class="s2">yield from </span><span class="s1">child.find_all(node_type)</span>

    <span class="s2">def </span><span class="s1">set_ctx(self</span><span class="s2">, </span><span class="s1">ctx: str) -&gt; </span><span class="s3">&quot;Node&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Reset the context of a node and all child nodes.  Per default the 
        parser will all generate nodes that have a 'load' context as it's the 
        most common one.  This method is used in the parser to set assignment 
        targets and other nodes to a store context. 
        &quot;&quot;&quot;</span>
        <span class="s1">todo = deque([self])</span>
        <span class="s2">while </span><span class="s1">todo:</span>
            <span class="s1">node = todo.popleft()</span>
            <span class="s2">if </span><span class="s3">&quot;ctx&quot; </span><span class="s2">in </span><span class="s1">node.fields:</span>
                <span class="s1">node.ctx = ctx  </span><span class="s4"># type: ignore</span>
            <span class="s1">todo.extend(node.iter_child_nodes())</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_lineno(self</span><span class="s2">, </span><span class="s1">lineno: int</span><span class="s2">, </span><span class="s1">override: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s3">&quot;Node&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Set the line numbers of the node and children.&quot;&quot;&quot;</span>
        <span class="s1">todo = deque([self])</span>
        <span class="s2">while </span><span class="s1">todo:</span>
            <span class="s1">node = todo.popleft()</span>
            <span class="s2">if </span><span class="s3">&quot;lineno&quot; </span><span class="s2">in </span><span class="s1">node.attributes:</span>
                <span class="s2">if </span><span class="s1">node.lineno </span><span class="s2">is None or </span><span class="s1">override:</span>
                    <span class="s1">node.lineno = lineno</span>
            <span class="s1">todo.extend(node.iter_child_nodes())</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_environment(self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s1">) -&gt; </span><span class="s3">&quot;Node&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Set the environment for all nodes.&quot;&quot;&quot;</span>
        <span class="s1">todo = deque([self])</span>
        <span class="s2">while </span><span class="s1">todo:</span>
            <span class="s1">node = todo.popleft()</span>
            <span class="s1">node.environment = environment</span>
            <span class="s1">todo.extend(node.iter_child_nodes())</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: t.Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">type(self) </span><span class="s2">is not </span><span class="s1">type(other):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">tuple(self.iter_fields()) == tuple(other.iter_fields())</span>

    <span class="s1">__hash__ = object.__hash__</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">args_str = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s2">}</span><span class="s3">=</span><span class="s2">{</span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">!r}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.fields)</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">args_str</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s2">def </span><span class="s1">dump(self) -&gt; str:</span>
        <span class="s2">def </span><span class="s1">_dump(node: t.Union[Node</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(node</span><span class="s2">, </span><span class="s1">Node):</span>
                <span class="s1">buf.append(repr(node))</span>
                <span class="s2">return</span>

            <span class="s1">buf.append(</span><span class="s3">f&quot;nodes.</span><span class="s2">{</span><span class="s1">type(node).__name__</span><span class="s2">}</span><span class="s3">(&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">node.fields:</span>
                <span class="s1">buf.append(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
                <span class="s2">return</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">field </span><span class="s2">in </span><span class="s1">enumerate(node.fields):</span>
                <span class="s2">if </span><span class="s1">idx:</span>
                    <span class="s1">buf.append(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s1">value = getattr(node</span><span class="s2">, </span><span class="s1">field)</span>
                <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">list):</span>
                    <span class="s1">buf.append(</span><span class="s3">&quot;[&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">enumerate(value):</span>
                        <span class="s2">if </span><span class="s1">idx:</span>
                            <span class="s1">buf.append(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
                        <span class="s1">_dump(item)</span>
                    <span class="s1">buf.append(</span><span class="s3">&quot;]&quot;</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_dump(value)</span>
            <span class="s1">buf.append(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>

        <span class="s1">buf: t.List[str] = []</span>
        <span class="s1">_dump(self)</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(buf)</span>


<span class="s2">class </span><span class="s1">Stmt(Node):</span>
    <span class="s0">&quot;&quot;&quot;Base node for all statements.&quot;&quot;&quot;</span>

    <span class="s1">abstract = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">Helper(Node):</span>
    <span class="s0">&quot;&quot;&quot;Nodes that exist in a specific context only.&quot;&quot;&quot;</span>

    <span class="s1">abstract = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">Template(Node):</span>
    <span class="s0">&quot;&quot;&quot;Node that represents a template.  This must be the outermost node that 
    is passed to the compiler. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;body&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">Output(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A node that holds multiple expressions which are then printed out. 
    This is used both for the `print` statement and the regular template data. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;nodes&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">nodes: t.List[</span><span class="s3">&quot;Expr&quot;</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Extends(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Represents an extends statement.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;template&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">template: </span><span class="s3">&quot;Expr&quot;</span>


<span class="s2">class </span><span class="s1">For(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;The for loop.  `target` is the target for the iteration (usually a 
    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list 
    of nodes that are used as loop-body, and `else_` a list of nodes for the 
    `else` block.  If no else node exists it has to be an empty list. 
 
    For filtered nodes an expression can be stored as `test`, otherwise `None`. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;target&quot;</span><span class="s2">, </span><span class="s3">&quot;iter&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s2">, </span><span class="s3">&quot;else_&quot;</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s3">&quot;recursive&quot;</span><span class="s1">)</span>
    <span class="s1">target: Node</span>
    <span class="s1">iter: Node</span>
    <span class="s1">body: t.List[Node]</span>
    <span class="s1">else_: t.List[Node]</span>
    <span class="s1">test: t.Optional[Node]</span>
    <span class="s1">recursive: bool</span>


<span class="s2">class </span><span class="s1">If(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;If `test` is true, `body` is rendered, else `else_`.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s2">, </span><span class="s3">&quot;elif_&quot;</span><span class="s2">, </span><span class="s3">&quot;else_&quot;</span><span class="s1">)</span>
    <span class="s1">test: Node</span>
    <span class="s1">body: t.List[Node]</span>
    <span class="s1">elif_: t.List[</span><span class="s3">&quot;If&quot;</span><span class="s1">]</span>
    <span class="s1">else_: t.List[Node]</span>


<span class="s2">class </span><span class="s1">Macro(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A macro definition.  `name` is the name of the macro, `args` a list of 
    arguments and `defaults` a list of defaults if there are any.  `body` is 
    a list of nodes for the macro body. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;defaults&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">name: str</span>
    <span class="s1">args: t.List[</span><span class="s3">&quot;Name&quot;</span><span class="s1">]</span>
    <span class="s1">defaults: t.List[</span><span class="s3">&quot;Expr&quot;</span><span class="s1">]</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">CallBlock(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Like a macro without a name but a call instead.  `call` is called with 
    the unnamed macro as `caller` argument this node holds. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;call&quot;</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;defaults&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">call: </span><span class="s3">&quot;Call&quot;</span>
    <span class="s1">args: t.List[</span><span class="s3">&quot;Name&quot;</span><span class="s1">]</span>
    <span class="s1">defaults: t.List[</span><span class="s3">&quot;Expr&quot;</span><span class="s1">]</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">FilterBlock(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Node for filter sections.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;body&quot;</span><span class="s2">, </span><span class="s3">&quot;filter&quot;</span><span class="s1">)</span>
    <span class="s1">body: t.List[Node]</span>
    <span class="s1">filter: </span><span class="s3">&quot;Filter&quot;</span>


<span class="s2">class </span><span class="s1">With(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Specific node for with statements.  In older versions of Jinja the 
    with statement was implemented on the base of the `Scope` node instead. 
 
    .. versionadded:: 2.9.3 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;targets&quot;</span><span class="s2">, </span><span class="s3">&quot;values&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">targets: t.List[</span><span class="s3">&quot;Expr&quot;</span><span class="s1">]</span>
    <span class="s1">values: t.List[</span><span class="s3">&quot;Expr&quot;</span><span class="s1">]</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">Block(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A node that represents a block. 
 
    .. versionchanged:: 3.0.0 
        the `required` field was added. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s2">, </span><span class="s3">&quot;scoped&quot;</span><span class="s2">, </span><span class="s3">&quot;required&quot;</span><span class="s1">)</span>
    <span class="s1">name: str</span>
    <span class="s1">body: t.List[Node]</span>
    <span class="s1">scoped: bool</span>
    <span class="s1">required: bool</span>


<span class="s2">class </span><span class="s1">Include(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A node that represents the include tag.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;template&quot;</span><span class="s2">, </span><span class="s3">&quot;with_context&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore_missing&quot;</span><span class="s1">)</span>
    <span class="s1">template: </span><span class="s3">&quot;Expr&quot;</span>
    <span class="s1">with_context: bool</span>
    <span class="s1">ignore_missing: bool</span>


<span class="s2">class </span><span class="s1">Import(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A node that represents the import tag.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;template&quot;</span><span class="s2">, </span><span class="s3">&quot;target&quot;</span><span class="s2">, </span><span class="s3">&quot;with_context&quot;</span><span class="s1">)</span>
    <span class="s1">template: </span><span class="s3">&quot;Expr&quot;</span>
    <span class="s1">target: str</span>
    <span class="s1">with_context: bool</span>


<span class="s2">class </span><span class="s1">FromImport(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A node that represents the from import tag.  It's important to not 
    pass unsafe names to the name attribute.  The compiler translates the 
    attribute lookups directly into getattr calls and does *not* use the 
    subscript callback of the interface.  As exported variables may not 
    start with double underscores (which the parser asserts) this is not a 
    problem for regular Jinja code, but if this node is used in an extension 
    extra care must be taken. 
 
    The list of names may contain tuples if aliases are wanted. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;template&quot;</span><span class="s2">, </span><span class="s3">&quot;names&quot;</span><span class="s2">, </span><span class="s3">&quot;with_context&quot;</span><span class="s1">)</span>
    <span class="s1">template: </span><span class="s3">&quot;Expr&quot;</span>
    <span class="s1">names: t.List[t.Union[str</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]]</span>
    <span class="s1">with_context: bool</span>


<span class="s2">class </span><span class="s1">ExprStmt(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;A statement that evaluates an expression and discards the result.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;node&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">node: Node</span>


<span class="s2">class </span><span class="s1">Assign(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Assigns an expression to a target.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;target&quot;</span><span class="s2">, </span><span class="s3">&quot;node&quot;</span><span class="s1">)</span>
    <span class="s1">target: </span><span class="s3">&quot;Expr&quot;</span>
    <span class="s1">node: Node</span>


<span class="s2">class </span><span class="s1">AssignBlock(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Assigns a block to a target.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;target&quot;</span><span class="s2">, </span><span class="s3">&quot;filter&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">target: </span><span class="s3">&quot;Expr&quot;</span>
    <span class="s1">filter: t.Optional[</span><span class="s3">&quot;Filter&quot;</span><span class="s1">]</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">Expr(Node):</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for all expressions.&quot;&quot;&quot;</span>

    <span class="s1">abstract = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Return the value of the expression as constant or raise 
        :exc:`Impossible` if this was not possible. 
 
        An :class:`EvalContext` can be provided, if none is given 
        a default context is created which requires the nodes to have 
        an attached environment. 
 
        .. versionchanged:: 2.4 
           the `eval_ctx` parameter was added. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">Impossible()</span>

    <span class="s2">def </span><span class="s1">can_assign(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Check if it's possible to assign something to this node.&quot;&quot;&quot;</span>
        <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">BinExpr(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for all binary expressions.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s1">)</span>
    <span class="s1">left: Expr</span>
    <span class="s1">right: Expr</span>
    <span class="s1">operator: str</span>
    <span class="s1">abstract = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>

        <span class="s4"># intercepted operators cannot be folded at compile time</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">eval_ctx.environment.sandboxed</span>
            <span class="s2">and </span><span class="s1">self.operator </span><span class="s2">in </span><span class="s1">eval_ctx.environment.intercepted_binops  </span><span class="s4"># type: ignore</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>
        <span class="s1">f = _binop_to_func[self.operator]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">f(self.left.as_const(eval_ctx)</span><span class="s2">, </span><span class="s1">self.right.as_const(eval_ctx))</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">class </span><span class="s1">UnaryExpr(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for all unary expressions.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;node&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">node: Expr</span>
    <span class="s1">operator: str</span>
    <span class="s1">abstract = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>

        <span class="s4"># intercepted operators cannot be folded at compile time</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">eval_ctx.environment.sandboxed</span>
            <span class="s2">and </span><span class="s1">self.operator </span><span class="s2">in </span><span class="s1">eval_ctx.environment.intercepted_unops  </span><span class="s4"># type: ignore</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>
        <span class="s1">f = _uaop_to_func[self.operator]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">f(self.node.as_const(eval_ctx))</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">class </span><span class="s1">Name(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Looks up a name or stores a value in a name. 
    The `ctx` of the node can be one of the following values: 
 
    -   `store`: store a value in the name 
    -   `load`: load that name 
    -   `param`: like `store` but if the name was defined as function parameter. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;ctx&quot;</span><span class="s1">)</span>
    <span class="s1">name: str</span>
    <span class="s1">ctx: str</span>

    <span class="s2">def </span><span class="s1">can_assign(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.name </span><span class="s2">not in </span><span class="s1">{</span><span class="s3">&quot;true&quot;</span><span class="s2">, </span><span class="s3">&quot;false&quot;</span><span class="s2">, </span><span class="s3">&quot;none&quot;</span><span class="s2">, </span><span class="s3">&quot;True&quot;</span><span class="s2">, </span><span class="s3">&quot;False&quot;</span><span class="s2">, </span><span class="s3">&quot;None&quot;</span><span class="s1">}</span>


<span class="s2">class </span><span class="s1">NSRef(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Reference to a namespace value assignment&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;attr&quot;</span><span class="s1">)</span>
    <span class="s1">name: str</span>
    <span class="s1">attr: str</span>

    <span class="s2">def </span><span class="s1">can_assign(self) -&gt; bool:</span>
        <span class="s4"># We don't need any special checks here; NSRef assignments have a</span>
        <span class="s4"># runtime check to ensure the target is a namespace object which will</span>
        <span class="s4"># have been checked already as it is created using a normal assignment</span>
        <span class="s4"># which goes through a `Name` node.</span>
        <span class="s2">return True</span>


<span class="s2">class </span><span class="s1">Literal(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for literals.&quot;&quot;&quot;</span>

    <span class="s1">abstract = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">Const(Literal):</span>
    <span class="s0">&quot;&quot;&quot;All constant values.  The parser will return this node for simple 
    constants such as ``42`` or ``&quot;foo&quot;`` but it can be used to store more 
    complex values such as lists too.  Only constants with a safe 
    representation (objects where ``eval(repr(x)) == x`` is true). 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;value&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">value: t.Any</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_untrusted(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">value: t.Any</span><span class="s2">,</span>
        <span class="s1">lineno: t.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">environment: </span><span class="s3">&quot;t.Optional[Environment]&quot; </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Const&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Return a const object if the value is representable as 
        constant value in the generated code, otherwise it will raise 
        an `Impossible` exception. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.compiler </span><span class="s2">import </span><span class="s1">has_safe_repr</span>

        <span class="s2">if not </span><span class="s1">has_safe_repr(value):</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>
        <span class="s2">return </span><span class="s1">cls(value</span><span class="s2">, </span><span class="s1">lineno=lineno</span><span class="s2">, </span><span class="s1">environment=environment)</span>


<span class="s2">class </span><span class="s1">TemplateData(Literal):</span>
    <span class="s0">&quot;&quot;&quot;A constant template string.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;data&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">data: str</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">if </span><span class="s1">eval_ctx.volatile:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>
        <span class="s2">if </span><span class="s1">eval_ctx.autoescape:</span>
            <span class="s2">return </span><span class="s1">Markup(self.data)</span>
        <span class="s2">return </span><span class="s1">self.data</span>


<span class="s2">class </span><span class="s1">Tuple(Literal):</span>
    <span class="s0">&quot;&quot;&quot;For loop unpacking and some other things like multiple arguments 
    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple 
    is used for loading the names or storing. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;items&quot;</span><span class="s2">, </span><span class="s3">&quot;ctx&quot;</span><span class="s1">)</span>
    <span class="s1">items: t.List[Expr]</span>
    <span class="s1">ctx: str</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Tuple[t.Any</span><span class="s2">, </span><span class="s1">...]:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">tuple(x.as_const(eval_ctx) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.items)</span>

    <span class="s2">def </span><span class="s1">can_assign(self) -&gt; bool:</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s2">if not </span><span class="s1">item.can_assign():</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>


<span class="s2">class </span><span class="s1">List(Literal):</span>
    <span class="s0">&quot;&quot;&quot;Any list literal such as ``[1, 2, 3]``&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;items&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">items: t.List[Expr]</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.List[t.Any]:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">[x.as_const(eval_ctx) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.items]</span>


<span class="s2">class </span><span class="s1">Dict(Literal):</span>
    <span class="s0">&quot;&quot;&quot;Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of 
    :class:`Pair` nodes. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;items&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">items: t.List[</span><span class="s3">&quot;Pair&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">as_const(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; t.Dict[t.Any</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">dict(x.as_const(eval_ctx) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.items)</span>


<span class="s2">class </span><span class="s1">Pair(Helper):</span>
    <span class="s0">&quot;&quot;&quot;A key, value pair for dicts.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;key&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s1">key: Expr</span>
    <span class="s1">value: Expr</span>

    <span class="s2">def </span><span class="s1">as_const(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; t.Tuple[t.Any</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">self.key.as_const(eval_ctx)</span><span class="s2">, </span><span class="s1">self.value.as_const(eval_ctx)</span>


<span class="s2">class </span><span class="s1">Keyword(Helper):</span>
    <span class="s0">&quot;&quot;&quot;A key, value pair for keyword arguments where key is a string.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;key&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s1">key: str</span>
    <span class="s1">value: Expr</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">self.key</span><span class="s2">, </span><span class="s1">self.value.as_const(eval_ctx)</span>


<span class="s2">class </span><span class="s1">CondExpr(Expr):</span>
    <span class="s0">&quot;&quot;&quot;A conditional expression (inline if expression).  (``{{ 
    foo if bar else baz }}``) 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s3">&quot;expr1&quot;</span><span class="s2">, </span><span class="s3">&quot;expr2&quot;</span><span class="s1">)</span>
    <span class="s1">test: Expr</span>
    <span class="s1">expr1: Expr</span>
    <span class="s1">expr2: t.Optional[Expr]</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">if </span><span class="s1">self.test.as_const(eval_ctx):</span>
            <span class="s2">return </span><span class="s1">self.expr1.as_const(eval_ctx)</span>

        <span class="s4"># if we evaluate to an undefined object, we better do that at runtime</span>
        <span class="s2">if </span><span class="s1">self.expr2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s2">return </span><span class="s1">self.expr2.as_const(eval_ctx)</span>


<span class="s2">def </span><span class="s1">args_as_const(</span>
    <span class="s1">node: t.Union[</span><span class="s3">&quot;_FilterTestCommon&quot;</span><span class="s2">, </span><span class="s3">&quot;Call&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext]</span>
<span class="s1">) -&gt; t.Tuple[t.List[t.Any]</span><span class="s2">, </span><span class="s1">t.Dict[t.Any</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
    <span class="s1">args = [x.as_const(eval_ctx) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">node.args]</span>
    <span class="s1">kwargs = dict(x.as_const(eval_ctx) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">node.kwargs)</span>

    <span class="s2">if </span><span class="s1">node.dyn_args </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">args.extend(node.dyn_args.as_const(eval_ctx))</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">node.dyn_kwargs </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">kwargs.update(node.dyn_kwargs.as_const(eval_ctx))</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">return </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span>


<span class="s2">class </span><span class="s1">_FilterTestCommon(Expr):</span>
    <span class="s1">fields = (</span><span class="s3">&quot;node&quot;</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;kwargs&quot;</span><span class="s2">, </span><span class="s3">&quot;dyn_args&quot;</span><span class="s2">, </span><span class="s3">&quot;dyn_kwargs&quot;</span><span class="s1">)</span>
    <span class="s1">node: Expr</span>
    <span class="s1">name: str</span>
    <span class="s1">args: t.List[Expr]</span>
    <span class="s1">kwargs: t.List[Pair]</span>
    <span class="s1">dyn_args: t.Optional[Expr]</span>
    <span class="s1">dyn_kwargs: t.Optional[Expr]</span>
    <span class="s1">abstract = </span><span class="s2">True</span>
    <span class="s1">_is_filter = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>

        <span class="s2">if </span><span class="s1">eval_ctx.volatile:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s2">if </span><span class="s1">self._is_filter:</span>
            <span class="s1">env_map = eval_ctx.environment.filters</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">env_map = eval_ctx.environment.tests</span>

        <span class="s1">func = env_map.get(self.name)</span>
        <span class="s1">pass_arg = _PassArg.from_obj(func)  </span><span class="s4"># type: ignore</span>

        <span class="s2">if </span><span class="s1">func </span><span class="s2">is None or </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.context:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s2">if </span><span class="s1">eval_ctx.environment.is_async </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">getattr(func</span><span class="s2">, </span><span class="s3">&quot;jinja_async_variant&quot;</span><span class="s2">, False</span><span class="s1">) </span><span class="s2">is True</span>
            <span class="s2">or </span><span class="s1">inspect.iscoroutinefunction(func)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = args_as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">self.node.as_const(eval_ctx))</span>

        <span class="s2">if </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.eval_context:</span>
            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">elif </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.environment:</span>
            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">eval_ctx.environment)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">class </span><span class="s1">Filter(_FilterTestCommon):</span>
    <span class="s0">&quot;&quot;&quot;Apply a filter to an expression. ``name`` is the name of the 
    filter, the other fields are the same as :class:`Call`. 
 
    If ``node`` is ``None``, the filter is being used in a filter block 
    and is applied to the content of the block. 
    &quot;&quot;&quot;</span>

    <span class="s1">node: t.Optional[Expr]  </span><span class="s4"># type: ignore</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">self.node </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s2">return </span><span class="s1">super().as_const(eval_ctx=eval_ctx)</span>


<span class="s2">class </span><span class="s1">Test(_FilterTestCommon):</span>
    <span class="s0">&quot;&quot;&quot;Apply a test to an expression. ``name`` is the name of the test, 
    the other field are the same as :class:`Call`. 
 
    .. versionchanged:: 3.0 
        ``as_const`` shares the same logic for filters and tests. Tests 
        check for volatile, async, and ``@pass_context`` etc. 
        decorators. 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_filter = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">Call(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Calls an expression.  `args` is a list of arguments, `kwargs` a list 
    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args` 
    and `dyn_kwargs` has to be either `None` or a node that is used as 
    node for dynamic positional (``*args``) or keyword (``**kwargs``) 
    arguments. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;node&quot;</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;kwargs&quot;</span><span class="s2">, </span><span class="s3">&quot;dyn_args&quot;</span><span class="s2">, </span><span class="s3">&quot;dyn_kwargs&quot;</span><span class="s1">)</span>
    <span class="s1">node: Expr</span>
    <span class="s1">args: t.List[Expr]</span>
    <span class="s1">kwargs: t.List[Keyword]</span>
    <span class="s1">dyn_args: t.Optional[Expr]</span>
    <span class="s1">dyn_kwargs: t.Optional[Expr]</span>


<span class="s2">class </span><span class="s1">Getitem(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Get an attribute or item from an expression and prefer the item.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;node&quot;</span><span class="s2">, </span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s3">&quot;ctx&quot;</span><span class="s1">)</span>
    <span class="s1">node: Expr</span>
    <span class="s1">arg: Expr</span>
    <span class="s1">ctx: str</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">self.ctx != </span><span class="s3">&quot;load&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">eval_ctx.environment.getitem(</span>
                <span class="s1">self.node.as_const(eval_ctx)</span><span class="s2">, </span><span class="s1">self.arg.as_const(eval_ctx)</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">class </span><span class="s1">Getattr(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Get an attribute or item from an expression that is a ascii-only 
    bytestring and prefer the attribute. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;node&quot;</span><span class="s2">, </span><span class="s3">&quot;attr&quot;</span><span class="s2">, </span><span class="s3">&quot;ctx&quot;</span><span class="s1">)</span>
    <span class="s1">node: Expr</span>
    <span class="s1">attr: str</span>
    <span class="s1">ctx: str</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">self.ctx != </span><span class="s3">&quot;load&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>

        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">eval_ctx.environment.getattr(self.node.as_const(eval_ctx)</span><span class="s2">, </span><span class="s1">self.attr)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">class </span><span class="s1">Slice(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Represents a slice object.  This must only be used as argument for 
    :class:`Subscript`. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;start&quot;</span><span class="s2">, </span><span class="s3">&quot;stop&quot;</span><span class="s2">, </span><span class="s3">&quot;step&quot;</span><span class="s1">)</span>
    <span class="s1">start: t.Optional[Expr]</span>
    <span class="s1">stop: t.Optional[Expr]</span>
    <span class="s1">step: t.Optional[Expr]</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; slice:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>

        <span class="s2">def </span><span class="s1">const(obj: t.Optional[Expr]) -&gt; t.Optional[t.Any]:</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">obj.as_const(eval_ctx)</span>

        <span class="s2">return </span><span class="s1">slice(const(self.start)</span><span class="s2">, </span><span class="s1">const(self.stop)</span><span class="s2">, </span><span class="s1">const(self.step))</span>


<span class="s2">class </span><span class="s1">Concat(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Concatenates the list of expressions provided after converting 
    them to strings. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;nodes&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">nodes: t.List[Expr]</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(str(x.as_const(eval_ctx)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.nodes)</span>


<span class="s2">class </span><span class="s1">Compare(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Compares an expression with some other expressions.  `ops` must be a 
    list of :class:`Operand`\\s. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;expr&quot;</span><span class="s2">, </span><span class="s3">&quot;ops&quot;</span><span class="s1">)</span>
    <span class="s1">expr: Expr</span>
    <span class="s1">ops: t.List[</span><span class="s3">&quot;Operand&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s1">result = value = self.expr.as_const(eval_ctx)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">self.ops:</span>
                <span class="s1">new_value = op.expr.as_const(eval_ctx)</span>
                <span class="s1">result = _cmpop_to_func[op.op](value</span><span class="s2">, </span><span class="s1">new_value)</span>

                <span class="s2">if not </span><span class="s1">result:</span>
                    <span class="s2">return False</span>

                <span class="s1">value = new_value</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">Impossible() </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">Operand(Helper):</span>
    <span class="s0">&quot;&quot;&quot;Holds an operator and an expression.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;op&quot;</span><span class="s2">, </span><span class="s3">&quot;expr&quot;</span><span class="s1">)</span>
    <span class="s1">op: str</span>
    <span class="s1">expr: Expr</span>


<span class="s2">class </span><span class="s1">Mul(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Multiplies the left with the right node.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;*&quot;</span>


<span class="s2">class </span><span class="s1">Div(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Divides the left by the right node.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;/&quot;</span>


<span class="s2">class </span><span class="s1">FloorDiv(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Divides the left by the right node and converts the 
    result into an integer by truncating. 
    &quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;//&quot;</span>


<span class="s2">class </span><span class="s1">Add(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Add the left to the right node.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;+&quot;</span>


<span class="s2">class </span><span class="s1">Sub(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Subtract the right from the left node.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;-&quot;</span>


<span class="s2">class </span><span class="s1">Mod(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Left modulo right.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;%&quot;</span>


<span class="s2">class </span><span class="s1">Pow(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Left to the power of right.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;**&quot;</span>


<span class="s2">class </span><span class="s1">And(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Short circuited AND.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;and&quot;</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">self.left.as_const(eval_ctx) </span><span class="s2">and </span><span class="s1">self.right.as_const(eval_ctx)</span>


<span class="s2">class </span><span class="s1">Or(BinExpr):</span>
    <span class="s0">&quot;&quot;&quot;Short circuited OR.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;or&quot;</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">self.left.as_const(eval_ctx) </span><span class="s2">or </span><span class="s1">self.right.as_const(eval_ctx)</span>


<span class="s2">class </span><span class="s1">Not(UnaryExpr):</span>
    <span class="s0">&quot;&quot;&quot;Negate the expression.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;not&quot;</span>


<span class="s2">class </span><span class="s1">Neg(UnaryExpr):</span>
    <span class="s0">&quot;&quot;&quot;Make the expression negative.&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;-&quot;</span>


<span class="s2">class </span><span class="s1">Pos(UnaryExpr):</span>
    <span class="s0">&quot;&quot;&quot;Make the expression positive (noop for most expressions)&quot;&quot;&quot;</span>

    <span class="s1">operator = </span><span class="s3">&quot;+&quot;</span>


<span class="s4"># Helpers for extensions</span>


<span class="s2">class </span><span class="s1">EnvironmentAttribute(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Loads an attribute from the environment object.  This is useful for 
    extensions that want to call a callback stored on the environment. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;name&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">name: str</span>


<span class="s2">class </span><span class="s1">ExtensionAttribute(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Returns the attribute of an extension bound to the environment. 
    The identifier is the identifier of the :class:`Extension`. 
 
    This node is usually constructed by calling the 
    :meth:`~jinja2.ext.Extension.attr` method on an extension. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;identifier&quot;</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
    <span class="s1">identifier: str</span>
    <span class="s1">name: str</span>


<span class="s2">class </span><span class="s1">ImportedName(Expr):</span>
    <span class="s0">&quot;&quot;&quot;If created with an import name the import name is returned on node 
    access.  For example ``ImportedName('cgi.escape')`` returns the `escape` 
    function from the cgi module on evaluation.  Imports are optimized by the 
    compiler so there is no need to assign them to local variables. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;importname&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">importname: str</span>


<span class="s2">class </span><span class="s1">InternalName(Expr):</span>
    <span class="s0">&quot;&quot;&quot;An internal name in the compiler.  You cannot create these nodes 
    yourself but the parser provides a 
    :meth:`~jinja2.parser.Parser.free_identifier` method that creates 
    a new identifier for you.  This identifier is not available from the 
    template and is not treated specially by the compiler. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;name&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">name: str</span>

    <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">&quot;Can't create internal names.  Use the &quot;</span>
            <span class="s3">&quot;`free_identifier` method on a parser.&quot;</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">MarkSafe(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Mark the wrapped expression as safe (wrap it as `Markup`).&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;expr&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">expr: Expr</span>

    <span class="s2">def </span><span class="s1">as_const(self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span><span class="s1">) -&gt; Markup:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">return </span><span class="s1">Markup(self.expr.as_const(eval_ctx))</span>


<span class="s2">class </span><span class="s1">MarkSafeIfAutoescape(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Mark the wrapped expression as safe (wrap it as `Markup`) but 
    only if autoescaping is active. 
 
    .. versionadded:: 2.5 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;expr&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">expr: Expr</span>

    <span class="s2">def </span><span class="s1">as_const(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; t.Union[Markup</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s1">eval_ctx = get_eval_context(self</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">if </span><span class="s1">eval_ctx.volatile:</span>
            <span class="s2">raise </span><span class="s1">Impossible()</span>
        <span class="s1">expr = self.expr.as_const(eval_ctx)</span>
        <span class="s2">if </span><span class="s1">eval_ctx.autoescape:</span>
            <span class="s2">return </span><span class="s1">Markup(expr)</span>
        <span class="s2">return </span><span class="s1">expr</span>


<span class="s2">class </span><span class="s1">ContextReference(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Returns the current template context.  It can be used like a 
    :class:`Name` node, with a ``'load'`` ctx and will return the 
    current :class:`~jinja2.runtime.Context` object. 
 
    Here an example that assigns the current template name to a 
    variable named `foo`:: 
 
        Assign(Name('foo', ctx='store'), 
               Getattr(ContextReference(), 'name')) 
 
    This is basically equivalent to using the 
    :func:`~jinja2.pass_context` decorator when using the high-level 
    API, which causes a reference to the context to be passed as the 
    first argument to a function. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">DerivedContextReference(Expr):</span>
    <span class="s0">&quot;&quot;&quot;Return the current template context including locals. Behaves 
    exactly like :class:`ContextReference`, but includes local 
    variables, such as from a ``for`` loop. 
 
    .. versionadded:: 2.11 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Continue(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Continue a loop.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Break(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Break a loop.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Scope(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;An artificial scope.&quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;body&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">OverlayScope(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;An overlay scope for extensions.  This is a largely unoptimized scope 
    that however can be used to introduce completely arbitrary variables into 
    a sub scope from a dictionary or dictionary like object.  The `context` 
    field has to evaluate to a dictionary object. 
 
    Example usage:: 
 
        OverlayScope(context=self.call_method('get_context'), 
                     body=[...]) 
 
    .. versionadded:: 2.10 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;context&quot;</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">context: Expr</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s2">class </span><span class="s1">EvalContextModifier(Stmt):</span>
    <span class="s0">&quot;&quot;&quot;Modifies the eval context.  For each option that should be modified, 
    a :class:`Keyword` has to be added to the :attr:`options` list. 
 
    Example to change the `autoescape` setting:: 
 
        EvalContextModifier(options=[Keyword('autoescape', Const(True))]) 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;options&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">options: t.List[Keyword]</span>


<span class="s2">class </span><span class="s1">ScopedEvalContextModifier(EvalContextModifier):</span>
    <span class="s0">&quot;&quot;&quot;Modifies the eval context and reverts it later.  Works exactly like 
    :class:`EvalContextModifier` but will only modify the 
    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`. 
    &quot;&quot;&quot;</span>

    <span class="s1">fields = (</span><span class="s3">&quot;body&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">body: t.List[Node]</span>


<span class="s4"># make sure nobody creates custom nodes</span>
<span class="s2">def </span><span class="s1">_failing_new(*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s3">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;can't create custom node types&quot;</span><span class="s1">)</span>


<span class="s1">NodeType.__new__ = staticmethod(_failing_new)  </span><span class="s4"># type: ignore</span>
<span class="s2">del </span><span class="s1">_failing_new</span>
</pre>
</body>
</html>