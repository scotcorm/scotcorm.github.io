<html>
<head>
<title>test_interval_range.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_interval_range.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">timedelta</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">is_integer</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DateOffset</span><span class="s0">,</span>
    <span class="s1">Interval</span><span class="s0">,</span>
    <span class="s1">IntervalIndex</span><span class="s0">,</span>
    <span class="s1">Timedelta</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
    <span class="s1">interval_range</span><span class="s0">,</span>
    <span class="s1">timedelta_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>

<span class="s0">from </span><span class="s1">pandas.tseries.offsets </span><span class="s0">import </span><span class="s1">Day</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s2">&quot;class&quot;</span><span class="s0">, </span><span class="s1">params=[</span><span class="s0">None, </span><span class="s2">&quot;foo&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">name(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s0">class </span><span class="s1">TestIntervalRange:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;freq, periods&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">40</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">25</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_constructor_numeric(self</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">periods):</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = </span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span>
        <span class="s1">breaks = np.arange(</span><span class="s3">101</span><span class="s0">, </span><span class="s1">step=freq)</span>
        <span class="s1">expected = IntervalIndex.from_breaks(breaks</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed)</span>

        <span class="s4"># defined from start/end/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># defined from start/periods/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># defined from end/periods/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># GH 20976: linspace behavior defined from start/end/periods</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;tz&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;freq, periods&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s3">364</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;2D&quot;</span><span class="s0">, </span><span class="s3">182</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;22D18H&quot;</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_constructor_timestamp(self</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">periods</span><span class="s0">, </span><span class="s1">tz):</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = Timestamp(</span><span class="s2">&quot;20180101&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s2">&quot;20181231&quot;</span><span class="s0">, </span><span class="s1">tz=tz)</span>
        <span class="s1">breaks = date_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">expected = IntervalIndex.from_breaks(breaks</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed)</span>

        <span class="s4"># defined from start/end/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># defined from start/periods/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># defined from end/periods/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># GH 20976: linspace behavior defined from start/end/periods</span>
        <span class="s0">if not </span><span class="s1">breaks.freq.is_anchored() </span><span class="s0">and </span><span class="s1">tz </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># matches expected only for non-anchored offsets and tz naive</span>
            <span class="s4"># (anchored/DST transitions cause unequal spacing in expected)</span>
            <span class="s1">result = interval_range(</span>
                <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;freq, periods&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;2D12H&quot;</span><span class="s0">, </span><span class="s3">40</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;5D&quot;</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;25D&quot;</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_constructor_timedelta(self</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">periods):</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = Timedelta(</span><span class="s2">&quot;0 days&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timedelta(</span><span class="s2">&quot;100 days&quot;</span><span class="s1">)</span>
        <span class="s1">breaks = timedelta_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">expected = IntervalIndex.from_breaks(breaks</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed)</span>

        <span class="s4"># defined from start/end/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># defined from start/periods/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># defined from end/periods/freq</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># GH 20976: linspace behavior defined from start/end/periods</span>
        <span class="s1">result = interval_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=periods</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">closed=closed</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;start, end, freq, expected_endpoint&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">9.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(Timedelta(</span><span class="s2">&quot;0D&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timedelta(</span><span class="s2">&quot;10D&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;2D4H&quot;</span><span class="s0">, </span><span class="s1">Timedelta(</span><span class="s2">&quot;8D16H&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-01-01&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-02-09&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;MS&quot;</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-02-01&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-01-01&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-01-20&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;5D12H&quot;</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-01-17 12:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_early_truncation(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">expected_endpoint):</span>
        <span class="s4"># index truncates early if freq causes end to be skipped</span>
        <span class="s1">result = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">result_endpoint = result.right[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">result_endpoint == expected_endpoint</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;start, end, freq&quot;</span><span class="s0">,</span>
        <span class="s1">[(</span><span class="s3">0.5</span><span class="s0">, None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, </span><span class="s3">4.5</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.5</span><span class="s0">, None, </span><span class="s3">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, </span><span class="s3">6.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">)]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_no_invalid_float_truncation(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">freq):</span>
        <span class="s4"># GH 21161</span>
        <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">breaks = [</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">3.5</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">breaks = [</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.5</span><span class="s0">, </span><span class="s3">5.0</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">]</span>
        <span class="s1">expected = IntervalIndex.from_breaks(breaks)</span>

        <span class="s1">result = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;start, mid, end&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-03-10&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-03-10 23:30:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-03-12&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-11-03&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-11-04 00:30:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">Timestamp(</span><span class="s2">&quot;2018-11-05&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_linspace_dst_transition(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">mid</span><span class="s0">, </span><span class="s1">end):</span>
        <span class="s4"># GH 20976: linspace behavior defined from start/end/periods</span>
        <span class="s4"># accounts for the hour gained/lost during DST transition</span>
        <span class="s1">result = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">expected = IntervalIndex.from_breaks([start</span><span class="s0">, </span><span class="s1">mid</span><span class="s0">, </span><span class="s1">end])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;end&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10.0</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;start&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_float_subtype(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">freq):</span>
        <span class="s4"># Has float subtype if any of start/end/freq are float, even if all</span>
        <span class="s4"># resulting endpoints can safely be upcast to integers</span>

        <span class="s4"># defined from start/end/freq</span>
        <span class="s1">index = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">result = index.dtype.subtype</span>
        <span class="s1">expected = </span><span class="s2">&quot;int64&quot; </span><span class="s0">if </span><span class="s1">is_integer(start + end + freq) </span><span class="s0">else </span><span class="s2">&quot;float64&quot;</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

        <span class="s4"># defined from start/periods/freq</span>
        <span class="s1">index = interval_range(start=start</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">result = index.dtype.subtype</span>
        <span class="s1">expected = </span><span class="s2">&quot;int64&quot; </span><span class="s0">if </span><span class="s1">is_integer(start + freq) </span><span class="s0">else </span><span class="s2">&quot;float64&quot;</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

        <span class="s4"># defined from end/periods/freq</span>
        <span class="s1">index = interval_range(end=end</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">freq=freq)</span>
        <span class="s1">result = index.dtype.subtype</span>
        <span class="s1">expected = </span><span class="s2">&quot;int64&quot; </span><span class="s0">if </span><span class="s1">is_integer(end + freq) </span><span class="s0">else </span><span class="s2">&quot;float64&quot;</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

        <span class="s4"># GH 20976: linspace behavior defined from start/end/periods</span>
        <span class="s1">index = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">result = index.dtype.subtype</span>
        <span class="s1">expected = </span><span class="s2">&quot;int64&quot; </span><span class="s0">if </span><span class="s1">is_integer(start + end) </span><span class="s0">else </span><span class="s2">&quot;float64&quot;</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_constructor_coverage(self):</span>
        <span class="s4"># float value for periods</span>
        <span class="s1">expected = interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">result = interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10.5</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># equivalent timestamp-like start/end</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = Timestamp(</span><span class="s2">&quot;2017-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s2">&quot;2017-01-15&quot;</span><span class="s1">)</span>
        <span class="s1">expected = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end)</span>

        <span class="s1">result = interval_range(start=start.to_pydatetime()</span><span class="s0">, </span><span class="s1">end=end.to_pydatetime())</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = interval_range(start=start.asm8</span><span class="s0">, </span><span class="s1">end=end.asm8)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># equivalent freq with timestamp</span>
        <span class="s1">equiv_freq = [</span>
            <span class="s2">&quot;D&quot;</span><span class="s0">,</span>
            <span class="s1">Day()</span><span class="s0">,</span>
            <span class="s1">Timedelta(days=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">timedelta(days=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">DateOffset(days=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s0">for </span><span class="s1">freq </span><span class="s0">in </span><span class="s1">equiv_freq:</span>
            <span class="s1">result = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># equivalent timedelta-like start/end</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end = Timedelta(days=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timedelta(days=</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">expected = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end)</span>

        <span class="s1">result = interval_range(start=start.to_pytimedelta()</span><span class="s0">, </span><span class="s1">end=end.to_pytimedelta())</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = interval_range(start=start.asm8</span><span class="s0">, </span><span class="s1">end=end.asm8)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># equivalent freq with timedelta</span>
        <span class="s1">equiv_freq = [</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s1">Day()</span><span class="s0">, </span><span class="s1">Timedelta(days=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta(days=</span><span class="s3">1</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">freq </span><span class="s0">in </span><span class="s1">equiv_freq:</span>
            <span class="s1">result = interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=freq)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_errors(self):</span>
        <span class="s4"># not enough params</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;Of the four parameters: start, end, periods, and freq, &quot;</span>
            <span class="s2">&quot;exactly three must be specified&quot;</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(end=</span><span class="s3">5</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(periods=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range()</span>

        <span class="s4"># too many params</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">1.5</span><span class="s1">)</span>

        <span class="s4"># mixed units</span>
        <span class="s1">msg = </span><span class="s2">&quot;start, end, freq need to be type compatible&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end=Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end=Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(</span>
                <span class="s1">start=Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end=Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(</span>
                <span class="s1">start=Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end=Timestamp(</span><span class="s2">&quot;20130110&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">2</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(</span>
                <span class="s1">start=Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end=Timestamp(</span><span class="s2">&quot;20130110&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end=Timedelta(</span><span class="s2">&quot;10 days&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s4"># invalid periods</span>
        <span class="s1">msg = </span><span class="s2">&quot;periods must be a number, got foo&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s4"># invalid start</span>
        <span class="s1">msg = </span><span class="s2">&quot;start must be numeric or datetime-like, got foo&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s4"># invalid end</span>
        <span class="s1">msg = </span><span class="s2">r&quot;end must be numeric or datetime-like, got \(0, 1\]&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(end=Interval(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s4"># invalid freq for datetime-like</span>
        <span class="s1">msg = </span><span class="s2">&quot;freq must be numeric or convertible to DateOffset, got foo&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(end=Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s4"># mixed tz</span>
        <span class="s1">start = Timestamp(</span><span class="s2">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">end = Timestamp(</span><span class="s2">&quot;2017-01-07&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Pacific&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s2">&quot;Start and end cannot both be tz-aware with different timezones&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">interval_range(start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
</pre>
</body>
</html>