<html>
<head>
<title>_trisurf.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_trisurf.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">from </span><span class="s1">plotly </span><span class="s0">import </span><span class="s1">exceptions</span><span class="s0">, </span><span class="s1">optional_imports</span>
<span class="s0">import </span><span class="s1">plotly.colors </span><span class="s0">as </span><span class="s1">clrs</span>
<span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">graph_objs</span>

<span class="s1">np = optional_imports.get_module(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">map_face2color(face</span><span class="s0">, </span><span class="s1">colormap</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
    <span class="s3">&quot;&quot;&quot; 
    Normalize facecolor values by vmin/vmax and return rgb-color strings 
 
    This function takes a tuple color along with a colormap and a minimum 
    (vmin) and maximum (vmax) range of possible mean distances for the 
    given parametrized surface. It returns an rgb color based on the mean 
    distance between vmin and vmax 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">vmin &gt;= vmax:</span>
        <span class="s0">raise </span><span class="s1">exceptions.PlotlyError(</span>
            <span class="s2">&quot;Incorrect relation between vmin &quot;</span>
            <span class="s2">&quot;and vmax. The vmin value cannot be &quot;</span>
            <span class="s2">&quot;bigger than or equal to the value &quot;</span>
            <span class="s2">&quot;of vmax.&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">len(colormap) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s5"># color each triangle face with the same color in colormap</span>
        <span class="s1">face_color = colormap[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">face_color = clrs.convert_to_RGB_255(face_color)</span>
        <span class="s1">face_color = clrs.label_rgb(face_color)</span>
        <span class="s0">return </span><span class="s1">face_color</span>
    <span class="s0">if </span><span class="s1">face == vmax:</span>
        <span class="s5"># pick last color in colormap</span>
        <span class="s1">face_color = colormap[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">face_color = clrs.convert_to_RGB_255(face_color)</span>
        <span class="s1">face_color = clrs.label_rgb(face_color)</span>
        <span class="s0">return </span><span class="s1">face_color</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">scale </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># find the normalized distance t of a triangle face between</span>
            <span class="s5"># vmin and vmax where the distance is between 0 and 1</span>
            <span class="s1">t = (face - vmin) / float((vmax - vmin))</span>
            <span class="s1">low_color_index = int(t / (</span><span class="s4">1.0 </span><span class="s1">/ (len(colormap) - </span><span class="s4">1</span><span class="s1">)))</span>

            <span class="s1">face_color = clrs.find_intermediate_color(</span>
                <span class="s1">colormap[low_color_index]</span><span class="s0">,</span>
                <span class="s1">colormap[low_color_index + </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">t * (len(colormap) - </span><span class="s4">1</span><span class="s1">) - low_color_index</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">face_color = clrs.convert_to_RGB_255(face_color)</span>
            <span class="s1">face_color = clrs.label_rgb(face_color)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># find the face color for a non-linearly interpolated scale</span>
            <span class="s1">t = (face - vmin) / float((vmax - vmin))</span>

            <span class="s1">low_color_index = </span><span class="s4">0</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(len(scale) - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">scale[k] &lt;= t &lt; scale[k + </span><span class="s4">1</span><span class="s1">]:</span>
                    <span class="s0">break</span>
                <span class="s1">low_color_index += </span><span class="s4">1</span>

            <span class="s1">low_scale_val = scale[low_color_index]</span>
            <span class="s1">high_scale_val = scale[low_color_index + </span><span class="s4">1</span><span class="s1">]</span>

            <span class="s1">face_color = clrs.find_intermediate_color(</span>
                <span class="s1">colormap[low_color_index]</span><span class="s0">,</span>
                <span class="s1">colormap[low_color_index + </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">(t - low_scale_val) / (high_scale_val - low_scale_val)</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">face_color = clrs.convert_to_RGB_255(face_color)</span>
            <span class="s1">face_color = clrs.label_rgb(face_color)</span>
        <span class="s0">return </span><span class="s1">face_color</span>


<span class="s0">def </span><span class="s1">trisurf(</span>
    <span class="s1">x</span><span class="s0">,</span>
    <span class="s1">y</span><span class="s0">,</span>
    <span class="s1">z</span><span class="s0">,</span>
    <span class="s1">simplices</span><span class="s0">,</span>
    <span class="s1">show_colorbar</span><span class="s0">,</span>
    <span class="s1">edges_color</span><span class="s0">,</span>
    <span class="s1">scale</span><span class="s0">,</span>
    <span class="s1">colormap=</span><span class="s0">None,</span>
    <span class="s1">color_func=</span><span class="s0">None,</span>
    <span class="s1">plot_edges=</span><span class="s0">False,</span>
    <span class="s1">x_edge=</span><span class="s0">None,</span>
    <span class="s1">y_edge=</span><span class="s0">None,</span>
    <span class="s1">z_edge=</span><span class="s0">None,</span>
    <span class="s1">facecolor=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Refer to FigureFactory.create_trisurf() for docstring 
    &quot;&quot;&quot;</span>
    <span class="s5"># numpy import check</span>
    <span class="s0">if not </span><span class="s1">np:</span>
        <span class="s0">raise </span><span class="s1">ImportError(</span><span class="s2">&quot;FigureFactory._trisurf() requires &quot; &quot;numpy imported.&quot;</span><span class="s1">)</span>
    <span class="s1">points3D = np.vstack((x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)).T</span>
    <span class="s1">simplices = np.atleast_2d(simplices)</span>

    <span class="s5"># vertices of the surface triangles</span>
    <span class="s1">tri_vertices = points3D[simplices]</span>

    <span class="s5"># Define colors for the triangle faces</span>
    <span class="s0">if </span><span class="s1">color_func </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s5"># mean values of z-coordinates of triangle vertices</span>
        <span class="s1">mean_dists = tri_vertices[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s4">2</span><span class="s1">].mean(-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">isinstance(color_func</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">np.ndarray)):</span>
        <span class="s5"># Pre-computed list / array of values to map onto color</span>
        <span class="s0">if </span><span class="s1">len(color_func) != len(simplices):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;If color_func is a list/array, it must &quot;</span>
                <span class="s2">&quot;be the same length as simplices.&quot;</span>
            <span class="s1">)</span>

        <span class="s5"># convert all colors in color_func to rgb</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(color_func)):</span>
            <span class="s0">if </span><span class="s1">isinstance(color_func[index]</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">if </span><span class="s2">&quot;#&quot; </span><span class="s0">in </span><span class="s1">color_func[index]:</span>
                    <span class="s1">foo = clrs.hex_to_rgb(color_func[index])</span>
                    <span class="s1">color_func[index] = clrs.label_rgb(foo)</span>

            <span class="s0">if </span><span class="s1">isinstance(color_func[index]</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">foo = clrs.convert_to_RGB_255(color_func[index])</span>
                <span class="s1">color_func[index] = clrs.label_rgb(foo)</span>

        <span class="s1">mean_dists = np.asarray(color_func)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># apply user inputted function to calculate</span>
        <span class="s5"># custom coloring for triangle vertices</span>
        <span class="s1">mean_dists = []</span>
        <span class="s0">for </span><span class="s1">triangle </span><span class="s0">in </span><span class="s1">tri_vertices:</span>
            <span class="s1">dists = []</span>
            <span class="s0">for </span><span class="s1">vertex </span><span class="s0">in </span><span class="s1">triangle:</span>
                <span class="s1">dist = color_func(vertex[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">vertex[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">vertex[</span><span class="s4">2</span><span class="s1">])</span>
                <span class="s1">dists.append(dist)</span>
            <span class="s1">mean_dists.append(np.mean(dists))</span>
        <span class="s1">mean_dists = np.asarray(mean_dists)</span>

    <span class="s5"># Check if facecolors are already strings and can be skipped</span>
    <span class="s0">if </span><span class="s1">isinstance(mean_dists[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">facecolor = mean_dists</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">min_mean_dists = np.min(mean_dists)</span>
        <span class="s1">max_mean_dists = np.max(mean_dists)</span>

        <span class="s0">if </span><span class="s1">facecolor </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">facecolor = []</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(mean_dists)):</span>
            <span class="s1">color = map_face2color(</span>
                <span class="s1">mean_dists[index]</span><span class="s0">, </span><span class="s1">colormap</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">min_mean_dists</span><span class="s0">, </span><span class="s1">max_mean_dists</span>
            <span class="s1">)</span>
            <span class="s1">facecolor.append(color)</span>

    <span class="s5"># Make sure facecolor is a list so output is consistent across Pythons</span>
    <span class="s1">facecolor = np.asarray(facecolor)</span>
    <span class="s1">ii</span><span class="s0">, </span><span class="s1">jj</span><span class="s0">, </span><span class="s1">kk = simplices.T</span>

    <span class="s1">triangles = graph_objs.Mesh3d(</span>
        <span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">z=z</span><span class="s0">, </span><span class="s1">facecolor=facecolor</span><span class="s0">, </span><span class="s1">i=ii</span><span class="s0">, </span><span class="s1">j=jj</span><span class="s0">, </span><span class="s1">k=kk</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;&quot;</span>
    <span class="s1">)</span>

    <span class="s1">mean_dists_are_numbers = </span><span class="s0">not </span><span class="s1">isinstance(mean_dists[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str)</span>

    <span class="s0">if </span><span class="s1">mean_dists_are_numbers </span><span class="s0">and </span><span class="s1">show_colorbar </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s5"># make a colorscale from the colors</span>
        <span class="s1">colorscale = clrs.make_colorscale(colormap</span><span class="s0">, </span><span class="s1">scale)</span>
        <span class="s1">colorscale = clrs.convert_colorscale_to_rgb(colorscale)</span>

        <span class="s1">colorbar = graph_objs.Scatter3d(</span>
            <span class="s1">x=x[:</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">y=y[:</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">z=z[:</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">mode=</span><span class="s2">&quot;markers&quot;</span><span class="s0">,</span>
            <span class="s1">marker=dict(</span>
                <span class="s1">size=</span><span class="s4">0.1</span><span class="s0">,</span>
                <span class="s1">color=[min_mean_dists</span><span class="s0">, </span><span class="s1">max_mean_dists]</span><span class="s0">,</span>
                <span class="s1">colorscale=colorscale</span><span class="s0">,</span>
                <span class="s1">showscale=</span><span class="s0">True,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">hoverinfo=</span><span class="s2">&quot;none&quot;</span><span class="s0">,</span>
            <span class="s1">showlegend=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s5"># the triangle sides are not plotted</span>
    <span class="s0">if </span><span class="s1">plot_edges </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">mean_dists_are_numbers </span><span class="s0">and </span><span class="s1">show_colorbar </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[triangles</span><span class="s0">, </span><span class="s1">colorbar]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[triangles]</span>

    <span class="s5"># define the lists x_edge, y_edge and z_edge, of x, y, resp z</span>
    <span class="s5"># coordinates of edge end points for each triangle</span>
    <span class="s5"># None separates data corresponding to two consecutive triangles</span>
    <span class="s1">is_none = [ii </span><span class="s0">is None for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">[x_edge</span><span class="s0">, </span><span class="s1">y_edge</span><span class="s0">, </span><span class="s1">z_edge]]</span>
    <span class="s0">if </span><span class="s1">any(is_none):</span>
        <span class="s0">if not </span><span class="s1">all(is_none):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;If any (x_edge, y_edge, z_edge) is None, &quot; &quot;all must be None&quot;</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x_edge = []</span>
            <span class="s1">y_edge = []</span>
            <span class="s1">z_edge = []</span>

    <span class="s5"># Pull indices we care about, then add a None column to separate tris</span>
    <span class="s1">ixs_triangles = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">pull_edges = tri_vertices[:</span><span class="s0">, </span><span class="s1">ixs_triangles</span><span class="s0">, </span><span class="s1">:]</span>
    <span class="s1">x_edge_pull = np.hstack(</span>
        <span class="s1">[pull_edges[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.tile(</span><span class="s0">None, </span><span class="s1">[pull_edges.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])]</span>
    <span class="s1">)</span>
    <span class="s1">y_edge_pull = np.hstack(</span>
        <span class="s1">[pull_edges[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.tile(</span><span class="s0">None, </span><span class="s1">[pull_edges.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])]</span>
    <span class="s1">)</span>
    <span class="s1">z_edge_pull = np.hstack(</span>
        <span class="s1">[pull_edges[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.tile(</span><span class="s0">None, </span><span class="s1">[pull_edges.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])]</span>
    <span class="s1">)</span>

    <span class="s5"># Now unravel the edges into a 1-d vector for plotting</span>
    <span class="s1">x_edge = np.hstack([x_edge</span><span class="s0">, </span><span class="s1">x_edge_pull.reshape([</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">y_edge = np.hstack([y_edge</span><span class="s0">, </span><span class="s1">y_edge_pull.reshape([</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">z_edge = np.hstack([z_edge</span><span class="s0">, </span><span class="s1">z_edge_pull.reshape([</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]])</span>

    <span class="s0">if not </span><span class="s1">(len(x_edge) == len(y_edge) == len(z_edge)):</span>
        <span class="s0">raise </span><span class="s1">exceptions.PlotlyError(</span>
            <span class="s2">&quot;The lengths of x_edge, y_edge and &quot; &quot;z_edge are not the same.&quot;</span>
        <span class="s1">)</span>

    <span class="s5"># define the lines for plotting</span>
    <span class="s1">lines = graph_objs.Scatter3d(</span>
        <span class="s1">x=x_edge</span><span class="s0">,</span>
        <span class="s1">y=y_edge</span><span class="s0">,</span>
        <span class="s1">z=z_edge</span><span class="s0">,</span>
        <span class="s1">mode=</span><span class="s2">&quot;lines&quot;</span><span class="s0">,</span>
        <span class="s1">line=graph_objs.scatter3d.Line(color=edges_color</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">1.5</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">showlegend=</span><span class="s0">False,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">mean_dists_are_numbers </span><span class="s0">and </span><span class="s1">show_colorbar </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">[triangles</span><span class="s0">, </span><span class="s1">lines</span><span class="s0">, </span><span class="s1">colorbar]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">[triangles</span><span class="s0">, </span><span class="s1">lines]</span>


<span class="s0">def </span><span class="s1">create_trisurf(</span>
    <span class="s1">x</span><span class="s0">,</span>
    <span class="s1">y</span><span class="s0">,</span>
    <span class="s1">z</span><span class="s0">,</span>
    <span class="s1">simplices</span><span class="s0">,</span>
    <span class="s1">colormap=</span><span class="s0">None,</span>
    <span class="s1">show_colorbar=</span><span class="s0">True,</span>
    <span class="s1">scale=</span><span class="s0">None,</span>
    <span class="s1">color_func=</span><span class="s0">None,</span>
    <span class="s1">title=</span><span class="s2">&quot;Trisurf Plot&quot;</span><span class="s0">,</span>
    <span class="s1">plot_edges=</span><span class="s0">True,</span>
    <span class="s1">showbackground=</span><span class="s0">True,</span>
    <span class="s1">backgroundcolor=</span><span class="s2">&quot;rgb(230, 230, 230)&quot;</span><span class="s0">,</span>
    <span class="s1">gridcolor=</span><span class="s2">&quot;rgb(255, 255, 255)&quot;</span><span class="s0">,</span>
    <span class="s1">zerolinecolor=</span><span class="s2">&quot;rgb(255, 255, 255)&quot;</span><span class="s0">,</span>
    <span class="s1">edges_color=</span><span class="s2">&quot;rgb(50, 50, 50)&quot;</span><span class="s0">,</span>
    <span class="s1">height=</span><span class="s4">800</span><span class="s0">,</span>
    <span class="s1">width=</span><span class="s4">800</span><span class="s0">,</span>
    <span class="s1">aspectratio=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns figure for a triangulated surface plot 
 
    :param (array) x: data values of x in a 1D array 
    :param (array) y: data values of y in a 1D array 
    :param (array) z: data values of z in a 1D array 
    :param (array) simplices: an array of shape (ntri, 3) where ntri is 
        the number of triangles in the triangularization. Each row of the 
        array contains the indicies of the verticies of each triangle 
    :param (str|tuple|list) colormap: either a plotly scale name, an rgb 
        or hex color, a color tuple or a list of colors. An rgb color is 
        of the form 'rgb(x, y, z)' where x, y, z belong to the interval 
        [0, 255] and a color tuple is a tuple of the form (a, b, c) where 
        a, b and c belong to [0, 1]. If colormap is a list, it must 
        contain the valid color types aforementioned as its members 
    :param (bool) show_colorbar: determines if colorbar is visible 
    :param (list|array) scale: sets the scale values to be used if a non- 
        linearly interpolated colormap is desired. If left as None, a 
        linear interpolation between the colors will be excecuted 
    :param (function|list) color_func: The parameter that determines the 
        coloring of the surface. Takes either a function with 3 arguments 
        x, y, z or a list/array of color values the same length as 
        simplices. If None, coloring will only depend on the z axis 
    :param (str) title: title of the plot 
    :param (bool) plot_edges: determines if the triangles on the trisurf 
        are visible 
    :param (bool) showbackground: makes background in plot visible 
    :param (str) backgroundcolor: color of background. Takes a string of 
        the form 'rgb(x,y,z)' x,y,z are between 0 and 255 inclusive 
    :param (str) gridcolor: color of the gridlines besides the axes. Takes 
        a string of the form 'rgb(x,y,z)' x,y,z are between 0 and 255 
        inclusive 
    :param (str) zerolinecolor: color of the axes. Takes a string of the 
        form 'rgb(x,y,z)' x,y,z are between 0 and 255 inclusive 
    :param (str) edges_color: color of the edges, if plot_edges is True 
    :param (int|float) height: the height of the plot (in pixels) 
    :param (int|float) width: the width of the plot (in pixels) 
    :param (dict) aspectratio: a dictionary of the aspect ratio values for 
        the x, y and z axes. 'x', 'y' and 'z' take (int|float) values 
 
    Example 1: Sphere 
 
    &gt;&gt;&gt; # Necessary Imports for Trisurf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial import Delaunay 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_trisurf 
    &gt;&gt;&gt; from plotly.graph_objs import graph_objs 
 
    &gt;&gt;&gt; # Make data for plot 
    &gt;&gt;&gt; u = np.linspace(0, 2*np.pi, 20) 
    &gt;&gt;&gt; v = np.linspace(0, np.pi, 20) 
    &gt;&gt;&gt; u,v = np.meshgrid(u,v) 
    &gt;&gt;&gt; u = u.flatten() 
    &gt;&gt;&gt; v = v.flatten() 
 
    &gt;&gt;&gt; x = np.sin(v)*np.cos(u) 
    &gt;&gt;&gt; y = np.sin(v)*np.sin(u) 
    &gt;&gt;&gt; z = np.cos(v) 
 
    &gt;&gt;&gt; points2D = np.vstack([u,v]).T 
    &gt;&gt;&gt; tri = Delaunay(points2D) 
    &gt;&gt;&gt; simplices = tri.simplices 
 
    &gt;&gt;&gt; # Create a figure 
    &gt;&gt;&gt; fig1 = create_trisurf(x=x, y=y, z=z, colormap=&quot;Rainbow&quot;, 
    ...                       simplices=simplices) 
 
    Example 2: Torus 
 
    &gt;&gt;&gt; # Necessary Imports for Trisurf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial import Delaunay 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_trisurf 
    &gt;&gt;&gt; from plotly.graph_objs import graph_objs 
 
    &gt;&gt;&gt; # Make data for plot 
    &gt;&gt;&gt; u = np.linspace(0, 2*np.pi, 20) 
    &gt;&gt;&gt; v = np.linspace(0, 2*np.pi, 20) 
    &gt;&gt;&gt; u,v = np.meshgrid(u,v) 
    &gt;&gt;&gt; u = u.flatten() 
    &gt;&gt;&gt; v = v.flatten() 
 
    &gt;&gt;&gt; x = (3 + (np.cos(v)))*np.cos(u) 
    &gt;&gt;&gt; y = (3 + (np.cos(v)))*np.sin(u) 
    &gt;&gt;&gt; z = np.sin(v) 
 
    &gt;&gt;&gt; points2D = np.vstack([u,v]).T 
    &gt;&gt;&gt; tri = Delaunay(points2D) 
    &gt;&gt;&gt; simplices = tri.simplices 
 
    &gt;&gt;&gt; # Create a figure 
    &gt;&gt;&gt; fig1 = create_trisurf(x=x, y=y, z=z, colormap=&quot;Viridis&quot;, 
    ...                       simplices=simplices) 
 
    Example 3: Mobius Band 
 
    &gt;&gt;&gt; # Necessary Imports for Trisurf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial import Delaunay 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_trisurf 
    &gt;&gt;&gt; from plotly.graph_objs import graph_objs 
 
    &gt;&gt;&gt; # Make data for plot 
    &gt;&gt;&gt; u = np.linspace(0, 2*np.pi, 24) 
    &gt;&gt;&gt; v = np.linspace(-1, 1, 8) 
    &gt;&gt;&gt; u,v = np.meshgrid(u,v) 
    &gt;&gt;&gt; u = u.flatten() 
    &gt;&gt;&gt; v = v.flatten() 
 
    &gt;&gt;&gt; tp = 1 + 0.5*v*np.cos(u/2.) 
    &gt;&gt;&gt; x = tp*np.cos(u) 
    &gt;&gt;&gt; y = tp*np.sin(u) 
    &gt;&gt;&gt; z = 0.5*v*np.sin(u/2.) 
 
    &gt;&gt;&gt; points2D = np.vstack([u,v]).T 
    &gt;&gt;&gt; tri = Delaunay(points2D) 
    &gt;&gt;&gt; simplices = tri.simplices 
 
    &gt;&gt;&gt; # Create a figure 
    &gt;&gt;&gt; fig1 = create_trisurf(x=x, y=y, z=z, colormap=[(0.2, 0.4, 0.6), (1, 1, 1)], 
    ...                       simplices=simplices) 
 
    Example 4: Using a Custom Colormap Function with Light Cone 
 
    &gt;&gt;&gt; # Necessary Imports for Trisurf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial import Delaunay 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_trisurf 
    &gt;&gt;&gt; from plotly.graph_objs import graph_objs 
 
    &gt;&gt;&gt; # Make data for plot 
    &gt;&gt;&gt; u=np.linspace(-np.pi, np.pi, 30) 
    &gt;&gt;&gt; v=np.linspace(-np.pi, np.pi, 30) 
    &gt;&gt;&gt; u,v=np.meshgrid(u,v) 
    &gt;&gt;&gt; u=u.flatten() 
    &gt;&gt;&gt; v=v.flatten() 
 
    &gt;&gt;&gt; x = u 
    &gt;&gt;&gt; y = u*np.cos(v) 
    &gt;&gt;&gt; z = u*np.sin(v) 
 
    &gt;&gt;&gt; points2D = np.vstack([u,v]).T 
    &gt;&gt;&gt; tri = Delaunay(points2D) 
    &gt;&gt;&gt; simplices = tri.simplices 
 
    &gt;&gt;&gt; # Define distance function 
    &gt;&gt;&gt; def dist_origin(x, y, z): 
    ...     return np.sqrt((1.0 * x)**2 + (1.0 * y)**2 + (1.0 * z)**2) 
 
    &gt;&gt;&gt; # Create a figure 
    &gt;&gt;&gt; fig1 = create_trisurf(x=x, y=y, z=z, 
    ...                       colormap=['#FFFFFF', '#E4FFFE', 
    ...                                 '#A4F6F9', '#FF99FE', 
    ...                                 '#BA52ED'], 
    ...                       scale=[0, 0.6, 0.71, 0.89, 1], 
    ...                       simplices=simplices, 
    ...                       color_func=dist_origin) 
 
    Example 5: Enter color_func as a list of colors 
 
    &gt;&gt;&gt; # Necessary Imports for Trisurf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial import Delaunay 
    &gt;&gt;&gt; import random 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_trisurf 
    &gt;&gt;&gt; from plotly.graph_objs import graph_objs 
 
    &gt;&gt;&gt; # Make data for plot 
    &gt;&gt;&gt; u=np.linspace(-np.pi, np.pi, 30) 
    &gt;&gt;&gt; v=np.linspace(-np.pi, np.pi, 30) 
    &gt;&gt;&gt; u,v=np.meshgrid(u,v) 
    &gt;&gt;&gt; u=u.flatten() 
    &gt;&gt;&gt; v=v.flatten() 
 
    &gt;&gt;&gt; x = u 
    &gt;&gt;&gt; y = u*np.cos(v) 
    &gt;&gt;&gt; z = u*np.sin(v) 
 
    &gt;&gt;&gt; points2D = np.vstack([u,v]).T 
    &gt;&gt;&gt; tri = Delaunay(points2D) 
    &gt;&gt;&gt; simplices = tri.simplices 
 
 
    &gt;&gt;&gt; colors = [] 
    &gt;&gt;&gt; color_choices = ['rgb(0, 0, 0)', '#6c4774', '#d6c7dd'] 
 
    &gt;&gt;&gt; for index in range(len(simplices)): 
    ...     colors.append(random.choice(color_choices)) 
 
    &gt;&gt;&gt; fig = create_trisurf( 
    ...     x, y, z, simplices, 
    ...     color_func=colors, 
    ...     show_colorbar=True, 
    ...     edges_color='rgb(2, 85, 180)', 
    ...     title=' Modern Art' 
    ... ) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">aspectratio </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">aspectratio = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span>

    <span class="s5"># Validate colormap</span>
    <span class="s1">clrs.validate_colors(colormap)</span>
    <span class="s1">colormap</span><span class="s0">, </span><span class="s1">scale = clrs.convert_colors_to_same_type(</span>
        <span class="s1">colormap</span><span class="s0">, </span><span class="s1">colortype=</span><span class="s2">&quot;tuple&quot;</span><span class="s0">, </span><span class="s1">return_default_colors=</span><span class="s0">True, </span><span class="s1">scale=scale</span>
    <span class="s1">)</span>

    <span class="s1">data1 = trisurf(</span>
        <span class="s1">x</span><span class="s0">,</span>
        <span class="s1">y</span><span class="s0">,</span>
        <span class="s1">z</span><span class="s0">,</span>
        <span class="s1">simplices</span><span class="s0">,</span>
        <span class="s1">show_colorbar=show_colorbar</span><span class="s0">,</span>
        <span class="s1">color_func=color_func</span><span class="s0">,</span>
        <span class="s1">colormap=colormap</span><span class="s0">,</span>
        <span class="s1">scale=scale</span><span class="s0">,</span>
        <span class="s1">edges_color=edges_color</span><span class="s0">,</span>
        <span class="s1">plot_edges=plot_edges</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">axis = dict(</span>
        <span class="s1">showbackground=showbackground</span><span class="s0">,</span>
        <span class="s1">backgroundcolor=backgroundcolor</span><span class="s0">,</span>
        <span class="s1">gridcolor=gridcolor</span><span class="s0">,</span>
        <span class="s1">zerolinecolor=zerolinecolor</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">layout = graph_objs.Layout(</span>
        <span class="s1">title=title</span><span class="s0">,</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">height=height</span><span class="s0">,</span>
        <span class="s1">scene=graph_objs.layout.Scene(</span>
            <span class="s1">xaxis=graph_objs.layout.scene.XAxis(**axis)</span><span class="s0">,</span>
            <span class="s1">yaxis=graph_objs.layout.scene.YAxis(**axis)</span><span class="s0">,</span>
            <span class="s1">zaxis=graph_objs.layout.scene.ZAxis(**axis)</span><span class="s0">,</span>
            <span class="s1">aspectratio=dict(</span>
                <span class="s1">x=aspectratio[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y=aspectratio[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">z=aspectratio[</span><span class="s2">&quot;z&quot;</span><span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">graph_objs.Figure(data=data1</span><span class="s0">, </span><span class="s1">layout=layout)</span>
</pre>
</body>
</html>