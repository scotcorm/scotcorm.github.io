<html>
<head>
<title>sysconfig.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sysconfig.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Provide access to Python's configuration information.  The specific 
configuration variables available depend heavily on the platform and 
configuration.  The values may be retrieved using 
get_config_var(name), and the list of variables is available via 
get_config_vars().keys().  Additional convenience functions are also 
available. 
 
Written by:   Fred L. Drake, Jr. 
Email:        &lt;fdrake@acm.org&gt; 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">_imp</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>

<span class="s2">from </span><span class="s1">.errors </span><span class="s2">import </span><span class="s1">DistutilsPlatformError</span>

<span class="s1">IS_PYPY = </span><span class="s3">'__pypy__' </span><span class="s2">in </span><span class="s1">sys.builtin_module_names</span>

<span class="s4"># These are needed in a couple of spots, so just compute them once.</span>
<span class="s1">PREFIX = os.path.normpath(sys.prefix)</span>
<span class="s1">EXEC_PREFIX = os.path.normpath(sys.exec_prefix)</span>
<span class="s1">BASE_PREFIX = os.path.normpath(sys.base_prefix)</span>
<span class="s1">BASE_EXEC_PREFIX = os.path.normpath(sys.base_exec_prefix)</span>

<span class="s4"># Path to the base directory of the project. On Windows the binary may</span>
<span class="s4"># live in project/PCbuild/win32 or project/PCbuild/amd64.</span>
<span class="s4"># set for cross builds</span>
<span class="s2">if </span><span class="s3">&quot;_PYTHON_PROJECT_BASE&quot; </span><span class="s2">in </span><span class="s1">os.environ:</span>
    <span class="s1">project_base = os.path.abspath(os.environ[</span><span class="s3">&quot;_PYTHON_PROJECT_BASE&quot;</span><span class="s1">])</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">sys.executable:</span>
        <span class="s1">project_base = os.path.dirname(os.path.abspath(sys.executable))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># sys.executable can be empty if argv[0] has been changed and Python is</span>
        <span class="s4"># unable to retrieve the real program name</span>
        <span class="s1">project_base = os.getcwd()</span>


<span class="s4"># python_build: (Boolean) if true, we're either building Python or</span>
<span class="s4"># building an extension with an un-installed Python, so we use</span>
<span class="s4"># different (hard-wired) directories.</span>
<span class="s2">def </span><span class="s1">_is_python_source_dir(d):</span>
    <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;Setup&quot;</span><span class="s2">, </span><span class="s3">&quot;Setup.local&quot;</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(os.path.join(d</span><span class="s2">, </span><span class="s3">&quot;Modules&quot;</span><span class="s2">, </span><span class="s1">fn)):</span>
            <span class="s2">return True</span>
    <span class="s2">return False</span>

<span class="s1">_sys_home = getattr(sys</span><span class="s2">, </span><span class="s3">'_home'</span><span class="s2">, None</span><span class="s1">)</span>

<span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
    <span class="s2">def </span><span class="s1">_fix_pcbuild(d):</span>
        <span class="s2">if </span><span class="s1">d </span><span class="s2">and </span><span class="s1">os.path.normcase(d).startswith(</span>
                <span class="s1">os.path.normcase(os.path.join(PREFIX</span><span class="s2">, </span><span class="s3">&quot;PCbuild&quot;</span><span class="s1">))):</span>
            <span class="s2">return </span><span class="s1">PREFIX</span>
        <span class="s2">return </span><span class="s1">d</span>
    <span class="s1">project_base = _fix_pcbuild(project_base)</span>
    <span class="s1">_sys_home = _fix_pcbuild(_sys_home)</span>

<span class="s2">def </span><span class="s1">_python_build():</span>
    <span class="s2">if </span><span class="s1">_sys_home:</span>
        <span class="s2">return </span><span class="s1">_is_python_source_dir(_sys_home)</span>
    <span class="s2">return </span><span class="s1">_is_python_source_dir(project_base)</span>

<span class="s1">python_build = _python_build()</span>


<span class="s4"># Calculate the build qualifier flags if they are defined.  Adding the flags</span>
<span class="s4"># to the include and lib directories only makes sense for an installation, not</span>
<span class="s4"># an in-source build.</span>
<span class="s1">build_flags = </span><span class="s3">''</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">if not </span><span class="s1">python_build:</span>
        <span class="s1">build_flags = sys.abiflags</span>
<span class="s2">except </span><span class="s1">AttributeError:</span>
    <span class="s4"># It's not a configure-based build, so the sys module doesn't have</span>
    <span class="s4"># this attribute, which is fine.</span>
    <span class="s2">pass</span>

<span class="s2">def </span><span class="s1">get_python_version():</span>
    <span class="s0">&quot;&quot;&quot;Return a string containing the major and minor Python version, 
    leaving off the patchlevel.  Sample return values could be '1.5' 
    or '2.2'. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">'%d.%d' </span><span class="s1">% sys.version_info[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">get_python_inc(plat_specific=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return the directory containing installed Python header files. 
 
    If 'plat_specific' is false (the default), this is the path to the 
    non-platform-specific header files, i.e. Python.h and so on; 
    otherwise, this is the path to platform-specific header files 
    (namely pyconfig.h). 
 
    If 'prefix' is supplied, use it instead of sys.base_prefix or 
    sys.base_exec_prefix -- i.e., ignore 'plat_specific'. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">prefix = plat_specific </span><span class="s2">and </span><span class="s1">BASE_EXEC_PREFIX </span><span class="s2">or </span><span class="s1">BASE_PREFIX</span>
    <span class="s2">if </span><span class="s1">IS_PYPY:</span>
        <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">'include'</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">os.name == </span><span class="s3">&quot;posix&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">python_build:</span>
            <span class="s4"># Assume the executable is in the build directory.  The</span>
            <span class="s4"># pyconfig.h file should be in the same directory.  Since</span>
            <span class="s4"># the build directory may not be the source directory, we</span>
            <span class="s4"># must use &quot;srcdir&quot; from the makefile to find the &quot;Include&quot;</span>
            <span class="s4"># directory.</span>
            <span class="s2">if </span><span class="s1">plat_specific:</span>
                <span class="s2">return </span><span class="s1">_sys_home </span><span class="s2">or </span><span class="s1">project_base</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">incdir = os.path.join(get_config_var(</span><span class="s3">'srcdir'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'Include'</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">os.path.normpath(incdir)</span>
        <span class="s1">python_dir = </span><span class="s3">'python' </span><span class="s1">+ get_python_version() + build_flags</span>
        <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;include&quot;</span><span class="s2">, </span><span class="s1">python_dir)</span>
    <span class="s2">elif </span><span class="s1">os.name == </span><span class="s3">&quot;nt&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">python_build:</span>
            <span class="s4"># Include both the include and PC dir to ensure we can find</span>
            <span class="s4"># pyconfig.h</span>
            <span class="s2">return </span><span class="s1">(os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;include&quot;</span><span class="s1">) + os.path.pathsep +</span>
                    <span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;PC&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;include&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span>
            <span class="s3">&quot;I don't know where Python installs its C header files &quot;</span>
            <span class="s3">&quot;on platform '%s'&quot; </span><span class="s1">% os.name)</span>


<span class="s2">def </span><span class="s1">get_python_lib(plat_specific=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">standard_lib=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return the directory containing the Python library (standard or 
    site additions). 
 
    If 'plat_specific' is true, return the directory containing 
    platform-specific modules, i.e. any module from a non-pure-Python 
    module distribution; otherwise, return the platform-shared library 
    directory.  If 'standard_lib' is true, return the directory 
    containing standard Python library modules; otherwise, return the 
    directory for site-specific modules. 
 
    If 'prefix' is supplied, use it instead of sys.base_prefix or 
    sys.base_exec_prefix -- i.e., ignore 'plat_specific'. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">IS_PYPY:</span>
        <span class="s4"># PyPy-specific schema</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prefix = PREFIX</span>
        <span class="s2">if </span><span class="s1">standard_lib:</span>
            <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;lib-python&quot;</span><span class="s2">, </span><span class="s1">sys.version[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">'site-packages'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">standard_lib:</span>
            <span class="s1">prefix = plat_specific </span><span class="s2">and </span><span class="s1">BASE_EXEC_PREFIX </span><span class="s2">or </span><span class="s1">BASE_PREFIX</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prefix = plat_specific </span><span class="s2">and </span><span class="s1">EXEC_PREFIX </span><span class="s2">or </span><span class="s1">PREFIX</span>

    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">&quot;posix&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">plat_specific </span><span class="s2">or </span><span class="s1">standard_lib:</span>
            <span class="s4"># Platform-specific modules (any module from a non-pure-Python</span>
            <span class="s4"># module distribution) or standard Python library modules.</span>
            <span class="s1">libdir = getattr(sys</span><span class="s2">, </span><span class="s3">&quot;platlibdir&quot;</span><span class="s2">, </span><span class="s3">&quot;lib&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Pure Python</span>
            <span class="s1">libdir = </span><span class="s3">&quot;lib&quot;</span>
        <span class="s1">libpython = os.path.join(prefix</span><span class="s2">, </span><span class="s1">libdir</span><span class="s2">,</span>
                                 <span class="s3">&quot;python&quot; </span><span class="s1">+ get_python_version())</span>
        <span class="s2">if </span><span class="s1">standard_lib:</span>
            <span class="s2">return </span><span class="s1">libpython</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">os.path.join(libpython</span><span class="s2">, </span><span class="s3">&quot;site-packages&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">os.name == </span><span class="s3">&quot;nt&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">standard_lib:</span>
            <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;Lib&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">os.path.join(prefix</span><span class="s2">, </span><span class="s3">&quot;Lib&quot;</span><span class="s2">, </span><span class="s3">&quot;site-packages&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span>
            <span class="s3">&quot;I don't know where Python installs its library &quot;</span>
            <span class="s3">&quot;on platform '%s'&quot; </span><span class="s1">% os.name)</span>



<span class="s2">def </span><span class="s1">customize_compiler(compiler):</span>
    <span class="s0">&quot;&quot;&quot;Do any platform-specific customization of a CCompiler instance. 
 
    Mainly needed on Unix, so we can plug in the information that 
    varies across Unices and is stored in Python's Makefile. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">compiler.compiler_type == </span><span class="s3">&quot;unix&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s3">&quot;darwin&quot;</span><span class="s1">:</span>
            <span class="s4"># Perform first-time customization of compiler-related</span>
            <span class="s4"># config vars on OS X now that we know we need a compiler.</span>
            <span class="s4"># This is primarily to support Pythons from binary</span>
            <span class="s4"># installers.  The kind and paths to build tools on</span>
            <span class="s4"># the user system may vary significantly from the system</span>
            <span class="s4"># that Python itself was built on.  Also the user OS</span>
            <span class="s4"># version and build tools may not support the same set</span>
            <span class="s4"># of CPU architectures for universal builds.</span>
            <span class="s2">global </span><span class="s1">_config_vars</span>
            <span class="s4"># Use get_config_var() to ensure _config_vars is initialized.</span>
            <span class="s2">if not </span><span class="s1">get_config_var(</span><span class="s3">'CUSTOMIZED_OSX_COMPILER'</span><span class="s1">):</span>
                <span class="s2">import </span><span class="s1">_osx_support</span>
                <span class="s1">_osx_support.customize_compiler(_config_vars)</span>
                <span class="s1">_config_vars[</span><span class="s3">'CUSTOMIZED_OSX_COMPILER'</span><span class="s1">] = </span><span class="s3">'True'</span>

        <span class="s1">(cc</span><span class="s2">, </span><span class="s1">cxx</span><span class="s2">, </span><span class="s1">cflags</span><span class="s2">, </span><span class="s1">ccshared</span><span class="s2">, </span><span class="s1">ldshared</span><span class="s2">, </span><span class="s1">shlib_suffix</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">ar_flags) = \</span>
            <span class="s1">get_config_vars(</span><span class="s3">'CC'</span><span class="s2">, </span><span class="s3">'CXX'</span><span class="s2">, </span><span class="s3">'CFLAGS'</span><span class="s2">,</span>
                            <span class="s3">'CCSHARED'</span><span class="s2">, </span><span class="s3">'LDSHARED'</span><span class="s2">, </span><span class="s3">'SHLIB_SUFFIX'</span><span class="s2">, </span><span class="s3">'AR'</span><span class="s2">, </span><span class="s3">'ARFLAGS'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s3">'CC' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">newcc = os.environ[</span><span class="s3">'CC'</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">(sys.platform == </span><span class="s3">'darwin'</span>
                    <span class="s2">and </span><span class="s3">'LDSHARED' </span><span class="s2">not in </span><span class="s1">os.environ</span>
                    <span class="s2">and </span><span class="s1">ldshared.startswith(cc)):</span>
                <span class="s4"># On OS X, if CC is overridden, use that as the default</span>
                <span class="s4">#       command for LDSHARED as well</span>
                <span class="s1">ldshared = newcc + ldshared[len(cc):]</span>
            <span class="s1">cc = newcc</span>
        <span class="s2">if </span><span class="s3">'CXX' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">cxx = os.environ[</span><span class="s3">'CXX'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'LDSHARED' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">ldshared = os.environ[</span><span class="s3">'LDSHARED'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'CPP' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">cpp = os.environ[</span><span class="s3">'CPP'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cpp = cc + </span><span class="s3">&quot; -E&quot;           </span><span class="s4"># not always</span>
        <span class="s2">if </span><span class="s3">'LDFLAGS' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">ldshared = ldshared + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'LDFLAGS'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'CFLAGS' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">cflags = cflags + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'CFLAGS'</span><span class="s1">]</span>
            <span class="s1">ldshared = ldshared + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'CFLAGS'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'CPPFLAGS' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">cpp = cpp + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'CPPFLAGS'</span><span class="s1">]</span>
            <span class="s1">cflags = cflags + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'CPPFLAGS'</span><span class="s1">]</span>
            <span class="s1">ldshared = ldshared + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'CPPFLAGS'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'AR' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">ar = os.environ[</span><span class="s3">'AR'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'ARFLAGS' </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">archiver = ar + </span><span class="s3">' ' </span><span class="s1">+ os.environ[</span><span class="s3">'ARFLAGS'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">archiver = ar + </span><span class="s3">' ' </span><span class="s1">+ ar_flags</span>

        <span class="s1">cc_cmd = cc + </span><span class="s3">' ' </span><span class="s1">+ cflags</span>
        <span class="s1">compiler.set_executables(</span>
            <span class="s1">preprocessor=cpp</span><span class="s2">,</span>
            <span class="s1">compiler=cc_cmd</span><span class="s2">,</span>
            <span class="s1">compiler_so=cc_cmd + </span><span class="s3">' ' </span><span class="s1">+ ccshared</span><span class="s2">,</span>
            <span class="s1">compiler_cxx=cxx</span><span class="s2">,</span>
            <span class="s1">linker_so=ldshared</span><span class="s2">,</span>
            <span class="s1">linker_exe=cc</span><span class="s2">,</span>
            <span class="s1">archiver=archiver)</span>

        <span class="s1">compiler.shared_lib_extension = shlib_suffix</span>


<span class="s2">def </span><span class="s1">get_config_h_filename():</span>
    <span class="s0">&quot;&quot;&quot;Return full pathname of installed pyconfig.h file.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">python_build:</span>
        <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">&quot;nt&quot;</span><span class="s1">:</span>
            <span class="s1">inc_dir = os.path.join(_sys_home </span><span class="s2">or </span><span class="s1">project_base</span><span class="s2">, </span><span class="s3">&quot;PC&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">inc_dir = _sys_home </span><span class="s2">or </span><span class="s1">project_base</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">inc_dir = get_python_inc(plat_specific=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">os.path.join(inc_dir</span><span class="s2">, </span><span class="s3">'pyconfig.h'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_makefile_filename():</span>
    <span class="s0">&quot;&quot;&quot;Return full pathname of installed Makefile from the Python build.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">python_build:</span>
        <span class="s2">return </span><span class="s1">os.path.join(_sys_home </span><span class="s2">or </span><span class="s1">project_base</span><span class="s2">, </span><span class="s3">&quot;Makefile&quot;</span><span class="s1">)</span>
    <span class="s1">lib_dir = get_python_lib(plat_specific=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">standard_lib=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">config_file = </span><span class="s3">'config-{}{}'</span><span class="s1">.format(get_python_version()</span><span class="s2">, </span><span class="s1">build_flags)</span>
    <span class="s2">if </span><span class="s1">hasattr(sys.implementation</span><span class="s2">, </span><span class="s3">'_multiarch'</span><span class="s1">):</span>
        <span class="s1">config_file += </span><span class="s3">'-%s' </span><span class="s1">% sys.implementation._multiarch</span>
    <span class="s2">return </span><span class="s1">os.path.join(lib_dir</span><span class="s2">, </span><span class="s1">config_file</span><span class="s2">, </span><span class="s3">'Makefile'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">parse_config_h(fp</span><span class="s2">, </span><span class="s1">g=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Parse a config.h-style file. 
 
    A dictionary containing name/value pairs is returned.  If an 
    optional dictionary is passed in as the second argument, it is 
    used instead of a new dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">g </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">g = {}</span>
    <span class="s1">define_rx = re.compile(</span><span class="s3">&quot;#define ([A-Z][A-Za-z0-9_]+) (.*)</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">undef_rx = re.compile(</span><span class="s3">&quot;/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s4">#</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">line = fp.readline()</span>
        <span class="s2">if not </span><span class="s1">line:</span>
            <span class="s2">break</span>
        <span class="s1">m = define_rx.match(line)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">v = m.group(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">: v = int(v)</span>
            <span class="s2">except </span><span class="s1">ValueError: </span><span class="s2">pass</span>
            <span class="s1">g[n] = v</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">m = undef_rx.match(line)</span>
            <span class="s2">if </span><span class="s1">m:</span>
                <span class="s1">g[m.group(</span><span class="s5">1</span><span class="s1">)] = </span><span class="s5">0</span>
    <span class="s2">return </span><span class="s1">g</span>


<span class="s4"># Regexes needed for parsing Makefile (and similar syntaxes,</span>
<span class="s4"># like old-style Setup files).</span>
<span class="s1">_variable_rx = re.compile(</span><span class="s3">r&quot;([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)&quot;</span><span class="s1">)</span>
<span class="s1">_findvar1_rx = re.compile(</span><span class="s3">r&quot;\$\(([A-Za-z][A-Za-z0-9_]*)\)&quot;</span><span class="s1">)</span>
<span class="s1">_findvar2_rx = re.compile(</span><span class="s3">r&quot;\${([A-Za-z][A-Za-z0-9_]*)}&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">parse_makefile(fn</span><span class="s2">, </span><span class="s1">g=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Parse a Makefile-style file. 
 
    A dictionary containing name/value pairs is returned.  If an 
    optional dictionary is passed in as the second argument, it is 
    used instead of a new dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">distutils.text_file </span><span class="s2">import </span><span class="s1">TextFile</span>
    <span class="s1">fp = TextFile(fn</span><span class="s2">, </span><span class="s1">strip_comments=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">skip_blanks=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">join_lines=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;surrogateescape&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">g </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">g = {}</span>
    <span class="s1">done = {}</span>
    <span class="s1">notdone = {}</span>

    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">line = fp.readline()</span>
        <span class="s2">if </span><span class="s1">line </span><span class="s2">is None</span><span class="s1">: </span><span class="s4"># eof</span>
            <span class="s2">break</span>
        <span class="s1">m = _variable_rx.match(line)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">v = m.group(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">v = v.strip()</span>
            <span class="s4"># `$$' is a literal `$' in make</span>
            <span class="s1">tmpv = v.replace(</span><span class="s3">'$$'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s3">&quot;$&quot; </span><span class="s2">in </span><span class="s1">tmpv:</span>
                <span class="s1">notdone[n] = v</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">v = int(v)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s4"># insert literal `$'</span>
                    <span class="s1">done[n] = v.replace(</span><span class="s3">'$$'</span><span class="s2">, </span><span class="s3">'$'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">done[n] = v</span>

    <span class="s4"># Variables with a 'PY_' prefix in the makefile. These need to</span>
    <span class="s4"># be made available without that prefix through sysconfig.</span>
    <span class="s4"># Special care is needed to ensure that variable expansion works, even</span>
    <span class="s4"># if the expansion uses the name without a prefix.</span>
    <span class="s1">renamed_variables = (</span><span class="s3">'CFLAGS'</span><span class="s2">, </span><span class="s3">'LDFLAGS'</span><span class="s2">, </span><span class="s3">'CPPFLAGS'</span><span class="s1">)</span>

    <span class="s4"># do variable interpolation here</span>
    <span class="s2">while </span><span class="s1">notdone:</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">list(notdone):</span>
            <span class="s1">value = notdone[name]</span>
            <span class="s1">m = _findvar1_rx.search(value) </span><span class="s2">or </span><span class="s1">_findvar2_rx.search(value)</span>
            <span class="s2">if </span><span class="s1">m:</span>
                <span class="s1">n = m.group(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">found = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">n </span><span class="s2">in </span><span class="s1">done:</span>
                    <span class="s1">item = str(done[n])</span>
                <span class="s2">elif </span><span class="s1">n </span><span class="s2">in </span><span class="s1">notdone:</span>
                    <span class="s4"># get it on a subsequent round</span>
                    <span class="s1">found = </span><span class="s2">False</span>
                <span class="s2">elif </span><span class="s1">n </span><span class="s2">in </span><span class="s1">os.environ:</span>
                    <span class="s4"># do it like make: fall back to environment</span>
                    <span class="s1">item = os.environ[n]</span>

                <span class="s2">elif </span><span class="s1">n </span><span class="s2">in </span><span class="s1">renamed_variables:</span>
                    <span class="s2">if </span><span class="s1">name.startswith(</span><span class="s3">'PY_'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">name[</span><span class="s5">3</span><span class="s1">:] </span><span class="s2">in </span><span class="s1">renamed_variables:</span>
                        <span class="s1">item = </span><span class="s3">&quot;&quot;</span>

                    <span class="s2">elif </span><span class="s3">'PY_' </span><span class="s1">+ n </span><span class="s2">in </span><span class="s1">notdone:</span>
                        <span class="s1">found = </span><span class="s2">False</span>

                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">item = str(done[</span><span class="s3">'PY_' </span><span class="s1">+ n])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">done[n] = item = </span><span class="s3">&quot;&quot;</span>
                <span class="s2">if </span><span class="s1">found:</span>
                    <span class="s1">after = value[m.end():]</span>
                    <span class="s1">value = value[:m.start()] + item + after</span>
                    <span class="s2">if </span><span class="s3">&quot;$&quot; </span><span class="s2">in </span><span class="s1">after:</span>
                        <span class="s1">notdone[name] = value</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">try</span><span class="s1">: value = int(value)</span>
                        <span class="s2">except </span><span class="s1">ValueError:</span>
                            <span class="s1">done[name] = value.strip()</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">done[name] = value</span>
                        <span class="s2">del </span><span class="s1">notdone[name]</span>

                        <span class="s2">if </span><span class="s1">name.startswith(</span><span class="s3">'PY_'</span><span class="s1">) \</span>
                            <span class="s2">and </span><span class="s1">name[</span><span class="s5">3</span><span class="s1">:] </span><span class="s2">in </span><span class="s1">renamed_variables:</span>

                            <span class="s1">name = name[</span><span class="s5">3</span><span class="s1">:]</span>
                            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">done:</span>
                                <span class="s1">done[name] = value</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># bogus variable reference; just drop it since we can't deal</span>
                <span class="s2">del </span><span class="s1">notdone[name]</span>

    <span class="s1">fp.close()</span>

    <span class="s4"># strip spurious spaces</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">done.items():</span>
        <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">done[k] = v.strip()</span>

    <span class="s4"># save the results in the global dictionary</span>
    <span class="s1">g.update(done)</span>
    <span class="s2">return </span><span class="s1">g</span>


<span class="s2">def </span><span class="s1">expand_makefile_vars(s</span><span class="s2">, </span><span class="s1">vars):</span>
    <span class="s0">&quot;&quot;&quot;Expand Makefile-style variables -- &quot;${foo}&quot; or &quot;$(foo)&quot; -- in 
    'string' according to 'vars' (a dictionary mapping variable names to 
    values).  Variables not present in 'vars' are silently expanded to the 
    empty string.  The variable values in 'vars' should not contain further 
    variable expansions; if 'vars' is the output of 'parse_makefile()', 
    you're fine.  Returns a variable-expanded version of 's'. 
    &quot;&quot;&quot;</span>

    <span class="s4"># This algorithm does multiple expansion, so if vars['foo'] contains</span>
    <span class="s4"># &quot;${bar}&quot;, it will expand ${foo} to ${bar}, and then expand</span>
    <span class="s4"># ${bar}... and so forth.  This is fine as long as 'vars' comes from</span>
    <span class="s4"># 'parse_makefile()', which takes care of such expansions eagerly,</span>
    <span class="s4"># according to make's variable expansion semantics.</span>

    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">m = _findvar1_rx.search(s) </span><span class="s2">or </span><span class="s1">_findvar2_rx.search(s)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">(beg</span><span class="s2">, </span><span class="s1">end) = m.span()</span>
            <span class="s1">s = s[</span><span class="s5">0</span><span class="s1">:beg] + vars.get(m.group(</span><span class="s5">1</span><span class="s1">)) + s[end:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s1">_config_vars = </span><span class="s2">None</span>

<span class="s2">def </span><span class="s1">_init_posix():</span>
    <span class="s0">&quot;&quot;&quot;Initialize the module as appropriate for POSIX systems.&quot;&quot;&quot;</span>
    <span class="s4"># _sysconfigdata is generated at build time, see the sysconfig module</span>
    <span class="s1">name = os.environ.get(</span><span class="s3">'_PYTHON_SYSCONFIGDATA_NAME'</span><span class="s2">,</span>
        <span class="s3">'_sysconfigdata_{abi}_{platform}_{multiarch}'</span><span class="s1">.format(</span>
        <span class="s1">abi=sys.abiflags</span><span class="s2">,</span>
        <span class="s1">platform=sys.platform</span><span class="s2">,</span>
        <span class="s1">multiarch=getattr(sys.implementation</span><span class="s2">, </span><span class="s3">'_multiarch'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">))</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">_temp = __import__(name</span><span class="s2">, </span><span class="s1">globals()</span><span class="s2">, </span><span class="s1">locals()</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'build_time_vars'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s4"># Python 3.5 and pypy 7.3.1</span>
        <span class="s1">_temp = __import__(</span>
            <span class="s3">'_sysconfigdata'</span><span class="s2">, </span><span class="s1">globals()</span><span class="s2">, </span><span class="s1">locals()</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'build_time_vars'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">build_time_vars = _temp.build_time_vars</span>
    <span class="s2">global </span><span class="s1">_config_vars</span>
    <span class="s1">_config_vars = {}</span>
    <span class="s1">_config_vars.update(build_time_vars)</span>


<span class="s2">def </span><span class="s1">_init_nt():</span>
    <span class="s0">&quot;&quot;&quot;Initialize the module as appropriate for NT&quot;&quot;&quot;</span>
    <span class="s1">g = {}</span>
    <span class="s4"># set basic install directories</span>
    <span class="s1">g[</span><span class="s3">'LIBDEST'</span><span class="s1">] = get_python_lib(plat_specific=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">standard_lib=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">g[</span><span class="s3">'BINLIBDEST'</span><span class="s1">] = get_python_lib(plat_specific=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">standard_lib=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># XXX hmmm.. a normal install puts include files here</span>
    <span class="s1">g[</span><span class="s3">'INCLUDEPY'</span><span class="s1">] = get_python_inc(plat_specific=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">g[</span><span class="s3">'EXT_SUFFIX'</span><span class="s1">] = _imp.extension_suffixes()[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">g[</span><span class="s3">'EXE'</span><span class="s1">] = </span><span class="s3">&quot;.exe&quot;</span>
    <span class="s1">g[</span><span class="s3">'VERSION'</span><span class="s1">] = get_python_version().replace(</span><span class="s3">&quot;.&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">g[</span><span class="s3">'BINDIR'</span><span class="s1">] = os.path.dirname(os.path.abspath(sys.executable))</span>

    <span class="s2">global </span><span class="s1">_config_vars</span>
    <span class="s1">_config_vars = g</span>


<span class="s2">def </span><span class="s1">get_config_vars(*args):</span>
    <span class="s0">&quot;&quot;&quot;With no arguments, return a dictionary of all configuration 
    variables relevant for the current platform.  Generally this includes 
    everything needed to build extensions and install both pure modules and 
    extensions.  On Unix, this means every variable defined in Python's 
    installed Makefile; on Windows it's a much smaller set. 
 
    With arguments, return a list of values that result from looking up 
    each argument in the configuration variable dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_config_vars</span>
    <span class="s2">if </span><span class="s1">_config_vars </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">func = globals().get(</span><span class="s3">&quot;_init_&quot; </span><span class="s1">+ os.name)</span>
        <span class="s2">if </span><span class="s1">func:</span>
            <span class="s1">func()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_config_vars = {}</span>

        <span class="s4"># Normalized versions of prefix and exec_prefix are handy to have;</span>
        <span class="s4"># in fact, these are the standard versions used most places in the</span>
        <span class="s4"># Distutils.</span>
        <span class="s1">_config_vars[</span><span class="s3">'prefix'</span><span class="s1">] = PREFIX</span>
        <span class="s1">_config_vars[</span><span class="s3">'exec_prefix'</span><span class="s1">] = EXEC_PREFIX</span>

        <span class="s2">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s4"># For backward compatibility, see issue19555</span>
            <span class="s1">SO = _config_vars.get(</span><span class="s3">'EXT_SUFFIX'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">SO </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_config_vars[</span><span class="s3">'SO'</span><span class="s1">] = SO</span>

            <span class="s4"># Always convert srcdir to an absolute path</span>
            <span class="s1">srcdir = _config_vars.get(</span><span class="s3">'srcdir'</span><span class="s2">, </span><span class="s1">project_base)</span>
            <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">python_build:</span>
                    <span class="s4"># If srcdir is a relative path (typically '.' or '..')</span>
                    <span class="s4"># then it should be interpreted relative to the directory</span>
                    <span class="s4"># containing Makefile.</span>
                    <span class="s1">base = os.path.dirname(get_makefile_filename())</span>
                    <span class="s1">srcdir = os.path.join(base</span><span class="s2">, </span><span class="s1">srcdir)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s4"># srcdir is not meaningful since the installation is</span>
                    <span class="s4"># spread about the filesystem.  We choose the</span>
                    <span class="s4"># directory containing the Makefile since we know it</span>
                    <span class="s4"># exists.</span>
                    <span class="s1">srcdir = os.path.dirname(get_makefile_filename())</span>
            <span class="s1">_config_vars[</span><span class="s3">'srcdir'</span><span class="s1">] = os.path.abspath(os.path.normpath(srcdir))</span>

            <span class="s4"># Convert srcdir into an absolute path if it appears necessary.</span>
            <span class="s4"># Normally it is relative to the build directory.  However, during</span>
            <span class="s4"># testing, for example, we might be running a non-installed python</span>
            <span class="s4"># from a different directory.</span>
            <span class="s2">if </span><span class="s1">python_build </span><span class="s2">and </span><span class="s1">os.name == </span><span class="s3">&quot;posix&quot;</span><span class="s1">:</span>
                <span class="s1">base = project_base</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">os.path.isabs(_config_vars[</span><span class="s3">'srcdir'</span><span class="s1">]) </span><span class="s2">and</span>
                    <span class="s1">base != os.getcwd()):</span>
                    <span class="s4"># srcdir is relative and we are not in the same directory</span>
                    <span class="s4"># as the executable. Assume executable is in the build</span>
                    <span class="s4"># directory and make srcdir absolute.</span>
                    <span class="s1">srcdir = os.path.join(base</span><span class="s2">, </span><span class="s1">_config_vars[</span><span class="s3">'srcdir'</span><span class="s1">])</span>
                    <span class="s1">_config_vars[</span><span class="s3">'srcdir'</span><span class="s1">] = os.path.normpath(srcdir)</span>

        <span class="s4"># OS X platforms require special customization to handle</span>
        <span class="s4"># multi-architecture, multi-os-version installers</span>
        <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s3">'darwin'</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">_osx_support</span>
            <span class="s1">_osx_support.customize_config_vars(_config_vars)</span>

    <span class="s2">if </span><span class="s1">args:</span>
        <span class="s1">vals = []</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">args:</span>
            <span class="s1">vals.append(_config_vars.get(name))</span>
        <span class="s2">return </span><span class="s1">vals</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_config_vars</span>

<span class="s2">def </span><span class="s1">get_config_var(name):</span>
    <span class="s0">&quot;&quot;&quot;Return the value of a single variable using the dictionary 
    returned by 'get_config_vars()'.  Equivalent to 
    get_config_vars().get(name) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">name == </span><span class="s3">'SO'</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">warnings</span>
        <span class="s1">warnings.warn(</span><span class="s3">'SO is deprecated, use EXT_SUFFIX'</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">get_config_vars().get(name)</span>
</pre>
</body>
</html>