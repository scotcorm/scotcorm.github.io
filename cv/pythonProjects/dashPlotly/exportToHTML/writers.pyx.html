<html>
<head>
<title>writers.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
writers.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import cython</span>
<span class="s0">import numpy as np</span>

<span class="s0">from cpython cimport (</span>
    <span class="s0">PyBytes_GET_SIZE,</span>
    <span class="s0">PyUnicode_GET_LENGTH,</span>
<span class="s0">)</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
<span class="s0">)</span>

<span class="s0">ctypedef fused pandas_string:</span>
    <span class="s0">str</span>
    <span class="s0">bytes</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def write_csv_rows(</span>
    <span class="s0">list data,</span>
    <span class="s0">ndarray data_index,</span>
    <span class="s0">Py_ssize_t nlevels,</span>
    <span class="s0">ndarray cols,</span>
    <span class="s0">object writer</span>
<span class="s0">) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Write the given data to the writer object, pre-allocating where possible</span>
    <span class="s0">for performance improvements.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">data : list[ArrayLike]</span>
    <span class="s0">data_index : ndarray</span>
    <span class="s0">nlevels : int</span>
    <span class="s0">cols : ndarray</span>
    <span class="s0">writer : _csv.writer</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># In crude testing, N&gt;100 yields little marginal improvement</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j = 0, k = len(data_index), N = 100, ncols = len(cols)</span>
        <span class="s0">list rows</span>

    <span class="s0"># pre-allocate rows</span>
    <span class="s0">rows = [[None] * (nlevels + ncols) for _ in range(N)]</span>

    <span class="s0">if nlevels == 1:</span>
        <span class="s0">for j in range(k):</span>
            <span class="s0">row = rows[j % N]</span>
            <span class="s0">row[0] = data_index[j]</span>
            <span class="s0">for i in range(ncols):</span>
                <span class="s0">row[1 + i] = data[i][j]</span>

            <span class="s0">if j &gt;= N - 1 and j % N == N - 1:</span>
                <span class="s0">writer.writerows(rows)</span>
    <span class="s0">elif nlevels &gt; 1:</span>
        <span class="s0">for j in range(k):</span>
            <span class="s0">row = rows[j % N]</span>
            <span class="s0">row[:nlevels] = list(data_index[j])</span>
            <span class="s0">for i in range(ncols):</span>
                <span class="s0">row[nlevels + i] = data[i][j]</span>

            <span class="s0">if j &gt;= N - 1 and j % N == N - 1:</span>
                <span class="s0">writer.writerows(rows)</span>
    <span class="s0">else:</span>
        <span class="s0">for j in range(k):</span>
            <span class="s0">row = rows[j % N]</span>
            <span class="s0">for i in range(ncols):</span>
                <span class="s0">row[i] = data[i][j]</span>

            <span class="s0">if j &gt;= N - 1 and j % N == N - 1:</span>
                <span class="s0">writer.writerows(rows)</span>

    <span class="s0">if j &gt;= 0 and (j &lt; N - 1 or (j % N) != N - 1):</span>
        <span class="s0">writer.writerows(rows[:((j + 1) % N)])</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def convert_json_to_lines(arr: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">replace comma separated json with line feeds, paying special attention</span>
    <span class="s0">to quotes &amp; brackets</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i = 0, num_open_brackets_seen = 0, length</span>
        <span class="s0">bint in_quotes = False, is_escaping = False</span>
        <span class="s0">ndarray[uint8_t, ndim=1] narr</span>
        <span class="s0">unsigned char val, newline, comma, left_bracket, right_bracket, quote</span>
        <span class="s0">unsigned char backslash</span>

    <span class="s0">newline = ord('\n')</span>
    <span class="s0">comma = ord(',')</span>
    <span class="s0">left_bracket = ord('{')</span>
    <span class="s0">right_bracket = ord('}')</span>
    <span class="s0">quote = ord('&quot;')</span>
    <span class="s0">backslash = ord('\\')</span>

    <span class="s0">narr = np.frombuffer(arr.encode('utf-8'), dtype='u1').copy()</span>
    <span class="s0">length = narr.shape[0]</span>
    <span class="s0">for i in range(length):</span>
        <span class="s0">val = narr[i]</span>
        <span class="s0">if val == quote and i &gt; 0 and not is_escaping:</span>
            <span class="s0">in_quotes = ~in_quotes</span>
        <span class="s0">if val == backslash or is_escaping:</span>
            <span class="s0">is_escaping = ~is_escaping</span>
        <span class="s0">if val == comma:  # commas that should be \n</span>
            <span class="s0">if num_open_brackets_seen == 0 and not in_quotes:</span>
                <span class="s0">narr[i] = newline</span>
        <span class="s0">elif val == left_bracket:</span>
            <span class="s0">if not in_quotes:</span>
                <span class="s0">num_open_brackets_seen += 1</span>
        <span class="s0">elif val == right_bracket:</span>
            <span class="s0">if not in_quotes:</span>
                <span class="s0">num_open_brackets_seen -= 1</span>

    <span class="s0">return narr.tobytes().decode('utf-8') + '\n'  # GH:36888</span>


<span class="s0"># stata, pytables</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def max_len_string_array(pandas_string[:] arr) -&gt; Py_ssize_t:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return the maximum size of elements in a 1-dim string array.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, m = 0, wlen = 0, length = arr.shape[0]</span>
        <span class="s0">pandas_string val</span>

    <span class="s0">for i in range(length):</span>
        <span class="s0">val = arr[i]</span>
        <span class="s0">wlen = word_len(val)</span>

        <span class="s0">if wlen &gt; m:</span>
            <span class="s0">m = wlen</span>

    <span class="s0">return m</span>


<span class="s0">cpdef inline Py_ssize_t word_len(object val):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return the maximum length of a string or bytes value.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t wlen = 0</span>

    <span class="s0">if isinstance(val, str):</span>
        <span class="s0">wlen = PyUnicode_GET_LENGTH(val)</span>
    <span class="s0">elif isinstance(val, bytes):</span>
        <span class="s0">wlen = PyBytes_GET_SIZE(val)</span>

    <span class="s0">return wlen</span>

<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># PyTables Helpers</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def string_array_replace_from_nan_rep(</span>
    <span class="s0">ndarray[object, ndim=1] arr,</span>
    <span class="s0">object nan_rep,</span>
    <span class="s0">object replace=np.nan</span>
<span class="s0">) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Replace the values in the array with 'replacement' if</span>
    <span class="s0">they are 'nan_rep'. Return the same array.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t length = len(arr), i = 0</span>

    <span class="s0">for i in range(length):</span>
        <span class="s0">if arr[i] == nan_rep:</span>
            <span class="s0">arr[i] = replace</span>
</pre>
</body>
</html>