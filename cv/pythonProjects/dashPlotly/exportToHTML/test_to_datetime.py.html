<html>
<head>
<title>test_to_datetime.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_to_datetime.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; test to_datetime &quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">calendar</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">import </span><span class="s1">locale</span>

<span class="s2">from </span><span class="s1">dateutil.parser </span><span class="s2">import </span><span class="s1">parse</span>
<span class="s2">from </span><span class="s1">dateutil.tz.tz </span><span class="s2">import </span><span class="s1">tzoffset</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">pytz</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">tslib</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">iNaT</span><span class="s2">,</span>
    <span class="s1">parsing</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">OutOfBoundsDatetime</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsTimedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas.util._test_decorators </span><span class="s2">as </span><span class="s1">td</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">is_datetime64_ns_dtype</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">to_datetime</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>
<span class="s2">from </span><span class="s1">pandas.core.tools </span><span class="s2">import </span><span class="s1">datetimes </span><span class="s2">as </span><span class="s1">tools</span>
<span class="s2">from </span><span class="s1">pandas.core.tools.datetimes </span><span class="s2">import </span><span class="s1">start_caching_at</span>
<span class="s2">from </span><span class="s1">pandas.util.version </span><span class="s2">import </span><span class="s1">Version</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">cache(request):</span>
    <span class="s0">&quot;&quot;&quot; 
    cache keyword to pass to to_datetime. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s2">class </span><span class="s1">TestTimeConversionFormats:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;readonly&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_readonly(self</span><span class="s2">, </span><span class="s1">readonly):</span>
        <span class="s4"># GH#34857</span>
        <span class="s1">arr = np.array([]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">if </span><span class="s1">readonly:</span>
            <span class="s1">arr.setflags(write=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(arr)</span>
        <span class="s1">expected = to_datetime([])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;box&quot;</span><span class="s2">, </span><span class="s1">[Series</span><span class="s2">, </span><span class="s1">Index])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;format, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20000101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000201&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000301&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20000101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000102&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000103&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">values = box([</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;1/3/2000&quot;</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = box(expected)</span>
        <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">Series):</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, expected, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000101&quot;</span><span class="s2">, </span><span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000101&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000201&quot;</span><span class="s2">, </span><span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000102&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000301&quot;</span><span class="s2">, </span><span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000103&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_scalar(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series([</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">19801222</span><span class="s1">] + [</span><span class="s5">19810105</span><span class="s1">] * </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">expected = Series([Timestamp(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ser.apply(str)])</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(ser.apply(str)</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_with_nat(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series([</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">19801222</span><span class="s1">] + [</span><span class="s5">19810105</span><span class="s1">] * </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s4"># with NaT</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)] + [Timestamp(</span><span class="s3">&quot;19810105&quot;</span><span class="s1">)] * </span><span class="s5">5</span>
        <span class="s1">)</span>
        <span class="s1">expected[</span><span class="s5">2</span><span class="s1">] = np.nan</span>
        <span class="s1">ser[</span><span class="s5">2</span><span class="s1">] = np.nan</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># string with NaT</span>
        <span class="s1">ser2 = ser.apply(str)</span>
        <span class="s1">ser2[</span><span class="s5">2</span><span class="s1">] = </span><span class="s3">&quot;nat&quot;</span>
        <span class="s1">result = to_datetime(ser2</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_ignore(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># coercion</span>
        <span class="s4"># GH 7930</span>
        <span class="s1">ser = Series([</span><span class="s5">20121231</span><span class="s2">, </span><span class="s5">20141231</span><span class="s2">, </span><span class="s5">99991231</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">31</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">31</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">9999</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">31</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_coercion(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># coercion</span>
        <span class="s4"># GH 7930</span>
        <span class="s1">ser = Series([</span><span class="s5">20121231</span><span class="s2">, </span><span class="s5">20141231</span><span class="s2">, </span><span class="s5">99991231</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([</span><span class="s3">&quot;20121231&quot;</span><span class="s2">, </span><span class="s3">&quot;20141231&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input_s&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4"># Null values with Strings</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># Null values with Integers</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_with_none(self</span><span class="s2">, </span><span class="s1">input_s):</span>
        <span class="s4"># GH 30011</span>
        <span class="s4"># format='%Y%m%d'</span>
        <span class="s4"># with None</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20010112&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">result = Series(to_datetime(input_s</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input_s, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4"># NaN before strings with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;20010012&quot;</span><span class="s2">, </span><span class="s3">&quot;10019999&quot;</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># NaN after strings with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010012&quot;</span><span class="s2">, </span><span class="s3">&quot;10019999&quot;</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># NaN before integers with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s5">20190813</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">20010012</span><span class="s2">, </span><span class="s5">20019999</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;20190813&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># NaN after integers with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s5">20190813</span><span class="s2">, </span><span class="s5">20010012</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">20019999</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;20190813&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_overflow(self</span><span class="s2">, </span><span class="s1">input_s</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 25512</span>
        <span class="s4"># format='%Y%m%d', errors='coerce'</span>
        <span class="s1">result = to_datetime(input_s</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;data, format, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">([pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%Y%m%d%H%M%S&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([pd.NA]</span><span class="s2">, None, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">[pd.NA</span><span class="s2">, </span><span class="s3">&quot;20210202202020&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;%Y%m%d%H%M%S&quot;</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2021-02-02 20:20:20&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s3">&quot;201010&quot;</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%y%m%d&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;2020-10-10&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s3">&quot;201010&quot;</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%d%m%y&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;2010-10-20&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s3">&quot;201010&quot;</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, None, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;2010-10-20&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s2">None, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, None, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s2">None, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_NA(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH#42957</span>
        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_integer(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 10178</span>
        <span class="s1">ser = Series([</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">2001</span><span class="s2">, </span><span class="s5">2002</span><span class="s1">])</span>
        <span class="s1">expected = Series([Timestamp(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ser.apply(str)])</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">ser = Series([</span><span class="s5">200001</span><span class="s2">, </span><span class="s5">200105</span><span class="s2">, </span><span class="s5">200206</span><span class="s1">])</span>
        <span class="s1">expected = Series([Timestamp(x[:</span><span class="s5">4</span><span class="s1">] + </span><span class="s3">&quot;-&quot; </span><span class="s1">+ x[</span><span class="s5">4</span><span class="s1">:]) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ser.apply(str)])</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;int_date, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4"># valid date, length == 8</span>
            <span class="s1">[</span><span class="s5">20121030</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">30</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s4"># short valid date, length == 6</span>
            <span class="s1">[</span><span class="s5">199934</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">1999</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s4"># long integer date partially parsed to datetime(2012,1,1), length &gt; 8</span>
            <span class="s1">[</span><span class="s5">2012010101</span><span class="s2">, </span><span class="s5">2012010101</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># invalid date partially parsed to datetime(2012,9,9), length == 8</span>
            <span class="s1">[</span><span class="s5">20129930</span><span class="s2">, </span><span class="s5">20129930</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># short integer date partially parsed to datetime(2012,9,9), length &lt; 8</span>
            <span class="s1">[</span><span class="s5">2012993</span><span class="s2">, </span><span class="s5">2012993</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># short invalid date, length == 4</span>
            <span class="s1">[</span><span class="s5">2121</span><span class="s2">, </span><span class="s5">2121</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_int_to_datetime_format_YYYYMMDD_typeerror(self</span><span class="s2">, </span><span class="s1">int_date</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 26583</span>
        <span class="s1">result = to_datetime(int_date</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_microsecond(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">month_abbr = calendar.month_abbr[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">val = </span><span class="s3">f&quot;01-</span><span class="s2">{</span><span class="s1">month_abbr</span><span class="s2">}</span><span class="s3">-2011 00:00:01.978&quot;</span>

        <span class="s1">format = </span><span class="s3">&quot;%d-%b-%Y %H:%M:%S.%f&quot;</span>
        <span class="s1">result = to_datetime(val</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">exp = datetime.strptime(val</span><span class="s2">, </span><span class="s1">format)</span>
        <span class="s2">assert </span><span class="s1">result == exp</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;value, format, dt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;01/10/2010 15:20&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y %H:%M&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 15:20&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;01/10/2010 05:43&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y %I:%M&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 05:43&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;01/10/2010 13:56:01&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %H:%M:%S&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 13:56:01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;01/10/2010 08:14 PM&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %I:%M %p&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 20:14&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">locale.getlocale()[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;it_IT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;01/10/2010 07:40 AM&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %I:%M %p&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 07:40&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">locale.getlocale()[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;it_IT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;01/10/2010 09:12:56 AM&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %I:%M:%S %p&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 09:12:56&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">locale.getlocale()[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;it_IT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_time(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache) == dt</span>

    <span class="s1">@td.skip_if_has_locale</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_non_exact(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 10834</span>
        <span class="s4"># 8904</span>
        <span class="s4"># exact kw</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;19MAY11&quot;</span><span class="s2">, </span><span class="s3">&quot;foobar19MAY11&quot;</span><span class="s2">, </span><span class="s3">&quot;19MAY11:00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;19MAY11 00:00:00Z&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%d%b%y&quot;</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">False, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = to_datetime(</span>
            <span class="s1">ser.str.extract(</span><span class="s3">r&quot;(\d+\w+\d+)&quot;</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%d%b%y&quot;</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;2012-01-01 09:00:00.000000001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.000001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.001000&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.001000000&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parse_nanoseconds_with_formula(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg):</span>

        <span class="s4"># GH8989</span>
        <span class="s4"># truncating the nanoseconds when a format was provided</span>
        <span class="s1">expected = to_datetime(arg</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;value,fmt,expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2009324&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y%W%w&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2009-08-13&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2013020&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y%U%w&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-13&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_weeks(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s2">assert </span><span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">cache=cache) == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt,dates,expected_dates&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %Z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 UTC&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)] * </span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %Z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s3">&quot;2010-01-01 12:00:00 UTC&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;2010-01-01 12:00:00 GMT&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;2010-01-01 12:00:00 US/Pacific&quot;</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;GMT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00+0100&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">60</span><span class="s1">))] * </span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 +0100&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">60</span><span class="s1">))] * </span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 +0100&quot;</span><span class="s2">, </span><span class="s3">&quot;2010-01-01 12:00:00 -0100&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">60</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(-</span><span class="s5">60</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 Z&quot;</span><span class="s2">, </span><span class="s3">&quot;2010-01-01 12:00:00 Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span>
                        <span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s1">)</span><span class="s2">,  </span><span class="s4"># pytz coerces to UTC</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_parse_tzname_or_tzoffset(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">dates</span><span class="s2">, </span><span class="s1">expected_dates):</span>
        <span class="s4"># GH 13486</span>
        <span class="s1">result = to_datetime(dates</span><span class="s2">, </span><span class="s1">format=fmt)</span>
        <span class="s1">expected = Index(expected_dates)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_parse_tzname_or_tzoffset_different_tz_to_utc(self):</span>
        <span class="s4"># GH 32792</span>
        <span class="s1">dates = [</span>
            <span class="s3">&quot;2010-01-01 12:00:00 +0100&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 12:00:00 -0100&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 12:00:00 +0300&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 12:00:00 +0400&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">expected_dates = [</span>
            <span class="s3">&quot;2010-01-01 11:00:00+00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 13:00:00+00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 09:00:00+00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 08:00:00+00:00&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">fmt = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>

        <span class="s1">result = to_datetime(dates</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(expected_dates)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;offset&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;+0&quot;</span><span class="s2">, </span><span class="s3">&quot;-1foo&quot;</span><span class="s2">, </span><span class="s3">&quot;UTCbar&quot;</span><span class="s2">, </span><span class="s3">&quot;:10&quot;</span><span class="s2">, </span><span class="s3">&quot;+01:000:01&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_parse_timezone_malformed(self</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s1">fmt = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>
        <span class="s1">date = </span><span class="s3">&quot;2010-01-01 12:00:00 &quot; </span><span class="s1">+ offset</span>

        <span class="s1">msg = </span><span class="s3">&quot;does not match format|unconverted data remains&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([date]</span><span class="s2">, </span><span class="s1">format=fmt)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_parse_timezone_keeps_name(self):</span>
        <span class="s4"># GH 21697</span>
        <span class="s1">fmt = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>
        <span class="s1">arg = Index([</span><span class="s3">&quot;2010-01-01 12:00:00 Z&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">format=fmt)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestToDatetime:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;s, _format, dt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2015-1-1&quot;</span><span class="s2">, </span><span class="s3">&quot;%G-%V-%u&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">29</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-1-4&quot;</span><span class="s2">, </span><span class="s3">&quot;%G-%V-%u&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-1-7&quot;</span><span class="s2">, </span><span class="s3">&quot;%G-%V-%u&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso_week_year_format(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">_format</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s4"># See GH#16607</span>
        <span class="s2">assert </span><span class="s1">to_datetime(s</span><span class="s2">, </span><span class="s1">format=_format) == dt</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;msg, s, _format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 50&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %V&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 Monday&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %A&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 Mon&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %a&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 6&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %w&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 6&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %u&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2051&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;Day of the year directive '%j' is not compatible with ISO year &quot;</span>
                <span class="s3">&quot;directive '%G'. Use '%Y' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 6 256&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %V %u %j&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 Sunday&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %A&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 Sun&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %a&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 1&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %w&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 1&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %u&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;20&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_error_iso_week_year(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">_format):</span>
        <span class="s4"># See GH#16607</span>
        <span class="s4"># This test checks for errors thrown when giving the wrong format</span>
        <span class="s4"># However, as discussed on PR#25541, overriding the locale</span>
        <span class="s4"># causes a different error to be thrown due to the format being</span>
        <span class="s4"># locale specific, but the test data is in english.</span>
        <span class="s4"># Therefore, the tests only run when locale is not overwritten,</span>
        <span class="s4"># as a sort of solution to this problem.</span>
        <span class="s2">if </span><span class="s1">locale.getlocale() != (</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;UTF-8&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">locale.getlocale() != (</span>
            <span class="s3">&quot;it_IT&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;UTF-8&quot;</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(s</span><span class="s2">, </span><span class="s1">format=_format)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Central&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dtarr(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s4"># DatetimeArray</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;1965-04-03&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">19</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2W&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">arr = DatetimeArray(dti)</span>

        <span class="s1">result = to_datetime(arr)</span>
        <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">arr</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_pydatetime(self):</span>
        <span class="s1">actual = to_datetime(datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">15</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">actual == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_YYYYMMDD(self):</span>
        <span class="s1">actual = to_datetime(</span><span class="s3">&quot;20080115&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">actual == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unparseable_ignore(self):</span>
        <span class="s4"># unparsable</span>
        <span class="s1">ser = </span><span class="s3">&quot;Month 1, 1999&quot;</span>
        <span class="s2">assert </span><span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">) == ser</span>

    <span class="s1">@td.skip_if_windows  </span><span class="s4"># `tm.set_timezone` does not work in windows</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_now(self):</span>
        <span class="s4"># See GH#18666</span>
        <span class="s2">with </span><span class="s1">tm.set_timezone(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;The parsing of 'now' in pd.to_datetime&quot;</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span>
                <span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">match=msg</span><span class="s2">, </span><span class="s1">check_stacklevel=</span><span class="s2">False</span>
            <span class="s1">):</span>
                <span class="s4"># checking stacklevel is tricky because we go through cython code</span>
                <span class="s4"># GH#18705</span>
                <span class="s1">npnow = np.datetime64(</span><span class="s3">&quot;now&quot;</span><span class="s1">).astype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
                <span class="s1">pdnow = to_datetime(</span><span class="s3">&quot;now&quot;</span><span class="s1">)</span>
                <span class="s1">pdnow2 = to_datetime([</span><span class="s3">&quot;now&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s4"># These should all be equal with infinite perf; this gives</span>
            <span class="s4"># a generous margin of 10 seconds</span>
            <span class="s2">assert </span><span class="s1">abs(pdnow.value - npnow.astype(np.int64)) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdnow2.value - npnow.astype(np.int64)) &lt; </span><span class="s5">1e10</span>

            <span class="s2">assert </span><span class="s1">pdnow.tzinfo </span><span class="s2">is None</span>
            <span class="s2">assert </span><span class="s1">pdnow2.tzinfo </span><span class="s2">is None</span>

    <span class="s1">@td.skip_if_windows  </span><span class="s4"># `tm.set_timezone` does not work in windows</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;Pacific/Auckland&quot;</span><span class="s2">, </span><span class="s3">&quot;US/Samoa&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_today(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s4"># See GH#18666</span>
        <span class="s4"># Test with one timezone far ahead of UTC and another far behind, so</span>
        <span class="s4"># one of these will _almost_ always be in a different day from UTC.</span>
        <span class="s4"># Unfortunately this test between 12 and 1 AM Samoa time</span>
        <span class="s4"># this both of these timezones _and_ UTC will all be in the same day,</span>
        <span class="s4"># so this test will not detect the regression introduced in #18666.</span>
        <span class="s2">with </span><span class="s1">tm.set_timezone(tz):</span>
            <span class="s1">nptoday = np.datetime64(</span><span class="s3">&quot;today&quot;</span><span class="s1">).astype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">).astype(np.int64)</span>
            <span class="s1">pdtoday = to_datetime(</span><span class="s3">&quot;today&quot;</span><span class="s1">)</span>
            <span class="s1">pdtoday2 = to_datetime([</span><span class="s3">&quot;today&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">tstoday = Timestamp(</span><span class="s3">&quot;today&quot;</span><span class="s1">)</span>
            <span class="s1">tstoday2 = Timestamp.today()</span>

            <span class="s4"># These should all be equal with infinite perf; this gives</span>
            <span class="s4"># a generous margin of 10 seconds</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday.normalize().value - nptoday) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday2.normalize().value - nptoday) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday.value - tstoday.value) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday.value - tstoday2.value) &lt; </span><span class="s5">1e10</span>

            <span class="s2">assert </span><span class="s1">pdtoday.tzinfo </span><span class="s2">is None</span>
            <span class="s2">assert </span><span class="s1">pdtoday2.tzinfo </span><span class="s2">is None</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;now&quot;</span><span class="s2">, </span><span class="s3">&quot;today&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_today_now_unicode_bytes(self</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s1">warn = FutureWarning </span><span class="s2">if </span><span class="s1">arg == </span><span class="s3">&quot;now&quot; </span><span class="s2">else None</span>
        <span class="s1">msg = </span><span class="s3">&quot;The parsing of 'now' in pd.to_datetime&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">match=msg</span><span class="s2">, </span><span class="s1">check_stacklevel=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s4"># checking stacklevel is tricky because we go through cython code</span>
            <span class="s4"># GH#18705</span>
            <span class="s1">to_datetime([arg])</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt&quot;</span><span class="s2">, </span><span class="s1">[np.datetime64(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2000-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dt64s(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">to_datetime(dt</span><span class="s2">, </span><span class="s1">cache=cache) == Timestamp(dt)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt&quot;</span><span class="s2">, </span><span class="s1">[np.datetime64(</span><span class="s3">&quot;1000-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;5000-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dt64s_out_of_bounds(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s1">msg = </span><span class="s3">f&quot;Out of bounds nanosecond timestamp: </span><span class="s2">{</span><span class="s1">dt</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(dt</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">Timestamp(dt)</span>
        <span class="s2">assert </span><span class="s1">to_datetime(dt</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_array_of_dt64s(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/31491</span>
        <span class="s4"># Need at least 50 to ensure cache is used.</span>
        <span class="s1">dts = [</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s1">unit)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2000-01-02&quot;</span><span class="s2">, </span><span class="s1">unit)</span><span class="s2">,</span>
        <span class="s1">] * </span><span class="s5">30</span>
        <span class="s4"># Assuming all datetimes are in bounds, to_datetime() returns</span>
        <span class="s4"># an array that is equal to Timestamp() parsing</span>
        <span class="s1">tm.assert_index_equal(</span>
            <span class="s1">to_datetime(dts</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">DatetimeIndex([Timestamp(x).asm8 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dts])</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s4"># A list of datetimes where the last one is out of bounds</span>
        <span class="s1">dts_with_oob = dts + [np.datetime64(</span><span class="s3">&quot;9999-01-01&quot;</span><span class="s1">)]</span>

        <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp: 9999-01-01 00:00:00&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(dts_with_oob</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_index_equal(</span>
            <span class="s1">to_datetime(dts_with_oob</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">DatetimeIndex(</span>
                <span class="s1">[Timestamp(dts_with_oob[</span><span class="s5">0</span><span class="s1">]).asm8</span><span class="s2">, </span><span class="s1">Timestamp(dts_with_oob[</span><span class="s5">1</span><span class="s1">]).asm8] * </span><span class="s5">30</span>
                <span class="s1">+ [NaT]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s4"># With errors='ignore', out of bounds datetime64s</span>
        <span class="s4"># are converted to their .item(), which depending on the version of</span>
        <span class="s4"># numpy is either a python datetime.datetime or datetime.date</span>
        <span class="s1">tm.assert_index_equal(</span>
            <span class="s1">to_datetime(dts_with_oob</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">Index([dt.item() </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">dts_with_oob])</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz(self</span><span class="s2">, </span><span class="s1">cache):</span>

        <span class="s4"># xref 8260</span>
        <span class="s4"># uniform returns a DatetimeIndex</span>
        <span class="s1">arr = [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 13:00:00-0800&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 14:00:00-0800&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2013-01-01 13:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2013-01-02 14:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz_mixed_raises(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># mixed tzs will raise</span>
        <span class="s1">arr = [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 13:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 14:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Tz-aware datetime.datetime cannot be &quot;</span>
            <span class="s3">&quot;converted to datetime64 unless utc=True&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_different_offsets(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># inspired by asv timeseries.ToDatetimeNONISO8601 benchmark</span>
        <span class="s4"># see GH-26097 for more</span>
        <span class="s1">ts_string_1 = </span><span class="s3">&quot;March 1, 2018 12:00:00+0400&quot;</span>
        <span class="s1">ts_string_2 = </span><span class="s3">&quot;March 1, 2018 12:00:00+0500&quot;</span>
        <span class="s1">arr = [ts_string_1] * </span><span class="s5">5 </span><span class="s1">+ [ts_string_2] * </span><span class="s5">5</span>
        <span class="s1">expected = Index([parse(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arr])</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz_pytz(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># see gh-8260</span>
        <span class="s1">us_eastern = pytz.timezone(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">arr = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">us_eastern.localize(</span>
                    <span class="s1">datetime(year=</span><span class="s5">2000</span><span class="s2">, </span><span class="s1">month=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">minute=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">us_eastern.localize(</span>
                    <span class="s1">datetime(year=</span><span class="s5">2000</span><span class="s2">, </span><span class="s1">month=</span><span class="s5">6</span><span class="s2">, </span><span class="s1">day=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">minute=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-06-01 07:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
            <span class="s1">freq=</span><span class="s2">None,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;init_constructor, end_constructor&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(Index</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span><span class="s2">,</span>
            <span class="s1">(list</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span><span class="s2">,</span>
            <span class="s1">(np.array</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span><span class="s2">,</span>
            <span class="s1">(Series</span><span class="s2">, </span><span class="s1">Series)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">init_constructor</span><span class="s2">, </span><span class="s1">end_constructor):</span>
        <span class="s4"># See gh-11934 &amp; gh-6415</span>
        <span class="s1">data = [</span><span class="s3">&quot;20100102 121314&quot;</span><span class="s2">, </span><span class="s3">&quot;20100102 121315&quot;</span><span class="s1">]</span>
        <span class="s1">expected_data = [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:14&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:15&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">result = to_datetime(</span>
            <span class="s1">init_constructor(data)</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d %H%M%S&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">expected = end_constructor(expected_data)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;scalar, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;20100102 121314&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:14&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;20100102 121315&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:15&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_scalar(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># Test scalar case as well</span>
        <span class="s1">result = to_datetime(scalar</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d %H%M%S&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_with_series_single_value(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 15760 UTC=True with Series</span>
        <span class="s1">ts = </span><span class="s5">1.5e18</span>
        <span class="s1">result = to_datetime(Series([ts])</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([Timestamp(ts</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_with_series_tzaware_string(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ts = </span><span class="s3">&quot;2013-01-01 00:00:00-01:00&quot;</span>
        <span class="s1">expected_ts = </span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span>
        <span class="s1">data = Series([ts] * </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([Timestamp(expected_ts</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)] * </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date, dtype&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_with_series_datetime_ns(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">date</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)])</span>
        <span class="s1">result = to_datetime(Series([date]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no(</span><span class="s3">&quot;psycopg2&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_tz_psycopg2(self</span><span class="s2">, </span><span class="s1">request</span><span class="s2">, </span><span class="s1">cache):</span>

        <span class="s4"># xref 8260</span>
        <span class="s2">import </span><span class="s1">psycopg2</span>

        <span class="s4"># https://www.psycopg.org/docs/news.html#what-s-new-in-psycopg-2-9</span>
        <span class="s1">request.node.add_marker(</span>
            <span class="s1">pytest.mark.xfail(</span>
                <span class="s1">Version(psycopg2.__version__.split()[</span><span class="s5">0</span><span class="s1">]) &gt; Version(</span><span class="s3">&quot;2.8.7&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">raises=AttributeError</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">&quot;psycopg2.tz is deprecated (and appears dropped) in 2.9&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s4"># misc cases</span>
        <span class="s1">tz1 = psycopg2.tz.FixedOffsetTimezone(offset=-</span><span class="s5">300</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">tz2 = psycopg2.tz.FixedOffsetTimezone(offset=-</span><span class="s5">240</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">arr = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tz1)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tz2)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-06-01 07:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
            <span class="s1">freq=</span><span class="s2">None,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># dtype coercion</span>
        <span class="s1">i = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">tz=psycopg2.tz.FixedOffsetTimezone(offset=-</span><span class="s5">300</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">is_datetime64_ns_dtype(i)</span>

        <span class="s4"># tz coercion</span>
        <span class="s1">result = to_datetime(i</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">i)</span>

        <span class="s1">result = to_datetime(i</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2000-01-01 13:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_bool(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s4"># GH13176</span>
        <span class="s1">msg = </span><span class="s3">r&quot;dtype bool cannot be converted to datetime64\[ns\]&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg)</span>
        <span class="s2">assert </span><span class="s1">to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">is </span><span class="s1">arg</span>

    <span class="s2">def </span><span class="s1">test_datetime_bool_arrays_mixed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(cache)</span><span class="s2">} </span><span class="s3">is not convertible to datetime&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s2">False, </span><span class="s1">datetime.today()]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(</span>
            <span class="s1">to_datetime([</span><span class="s5">0</span><span class="s2">, False, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">DatetimeIndex(</span>
                <span class="s1">[to_datetime(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">to_datetime(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cache=cache)]</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[bool</span><span class="s2">, </span><span class="s1">to_datetime])</span>
    <span class="s2">def </span><span class="s1">test_datetime_invalid_datatype(self</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s4"># GH13176</span>
        <span class="s1">msg = </span><span class="s3">&quot;is not convertible to datetime&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;00:01:99&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;H%:M%:S%&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_invalid_scalar(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">infer):</span>
        <span class="s4"># GH24763</span>
        <span class="s1">res = to_datetime(</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res == value</span>

        <span class="s1">res = to_datetime(</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NaT</span>

        <span class="s1">msg = (</span>
            <span class="s3">&quot;is a bad directive in format|&quot;</span>
            <span class="s3">&quot;second must be in 0..59|&quot;</span>
            <span class="s3">&quot;Given date string not likely a datetime&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span>
                <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;3000/12/11 00:00:00&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;H%:M%:S%&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_outofbounds_scalar(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">infer):</span>
        <span class="s4"># GH24763</span>
        <span class="s1">res = to_datetime(</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res == value</span>

        <span class="s1">res = to_datetime(</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NaT</span>

        <span class="s2">if </span><span class="s1">format </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;is a bad directive in format|Out of bounds nanosecond timestamp&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(</span>
                    <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(</span>
                    <span class="s1">value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
                <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;values&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;00:01:99&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;99:00:00&quot;</span><span class="s1">]])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;H%:M%:S%&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_invalid_index(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">infer):</span>
        <span class="s4"># GH24763</span>
        <span class="s1">res = to_datetime(</span>
            <span class="s1">values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">Index(values))</span>

        <span class="s1">res = to_datetime(</span>
            <span class="s1">values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">DatetimeIndex([NaT] * len(values)))</span>

        <span class="s1">msg = (</span>
            <span class="s3">&quot;is a bad directive in format|&quot;</span>
            <span class="s3">&quot;Given date string not likely a datetime|&quot;</span>
            <span class="s3">&quot;second must be in 0..59&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span>
                <span class="s1">values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">infer_datetime_format=infer</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;utc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%Y%m%d %H:%M:%S&quot;</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;constructor&quot;</span><span class="s2">, </span><span class="s1">[list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.array</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">deque])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_cache(self</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">constructor):</span>
        <span class="s1">date = </span><span class="s3">&quot;20130101 00:00:00&quot;</span>
        <span class="s1">test_dates = [date] * </span><span class="s5">10 </span><span class="s1">** </span><span class="s5">5</span>
        <span class="s1">data = constructor(test_dates)</span>

        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_from_deque(self):</span>
        <span class="s4"># GH 29403</span>
        <span class="s1">result = to_datetime(deque([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">))</span>
        <span class="s1">expected = to_datetime([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;utc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%Y%m%d %H:%M:%S&quot;</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_cache_series(self</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s1">date = </span><span class="s3">&quot;20130101 00:00:00&quot;</span>
        <span class="s1">test_dates = [date] * </span><span class="s5">10 </span><span class="s1">** </span><span class="s5">5</span>
        <span class="s1">data = Series(test_dates)</span>
        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_cache_scalar(self):</span>
        <span class="s1">date = </span><span class="s3">&quot;20130101 00:00:00&quot;</span>
        <span class="s1">result = to_datetime(date</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;20130101 00:00:00&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;datetimelikes,expected_values&quot;</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s2">None, </span><span class="s1">np.nan) + (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span><span class="s2">,</span>
                <span class="s1">(NaT</span><span class="s2">,</span><span class="s1">) * (start_caching_at + </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s2">None, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">)) + (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span><span class="s2">,</span>
                <span class="s1">(NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">)) + (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s2">None,</span><span class="s1">)</span>
                <span class="s1">+ (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span>
                <span class="s1">+ (</span><span class="s3">&quot;2012 July 26&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">(NaT</span><span class="s2">,</span><span class="s1">) * (start_caching_at + </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">+ (Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_convert_object_to_datetime_with_cache(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">datetimelikes</span><span class="s2">, </span><span class="s1">expected_values</span>
    <span class="s1">):</span>
        <span class="s4"># GH#39882</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">datetimelikes</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result_series = to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected_series = Series(</span>
            <span class="s1">expected_values</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result_series</span><span class="s2">, </span><span class="s1">expected_series)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2017-20&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%W&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sunday&quot;</span><span class="s2">, </span><span class="s3">&quot;%W %A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sun&quot;</span><span class="s2">, </span><span class="s3">&quot;%W %a&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2017-21&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%U&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sunday&quot;</span><span class="s2">, </span><span class="s3">&quot;%U %A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sun&quot;</span><span class="s2">, </span><span class="s3">&quot;%U %a&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_week_without_day_and_calendar_year(self</span><span class="s2">, </span><span class="s1">date</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH16774</span>

        <span class="s1">msg = </span><span class="s3">&quot;Cannot use '%W' or '%U' without day and year&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(date</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_coerce(self):</span>
        <span class="s4"># GH 26122</span>
        <span class="s1">ts_strings = [</span>
            <span class="s3">&quot;March 1, 2018 12:00:00+0400&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;March 1, 2018 12:00:00+0500&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;20100240&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Index(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">14400</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">18000</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_coerce_malformed(self):</span>
        <span class="s4"># GH 28299</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;200622-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;111111-24-11&quot;</span><span class="s1">]</span>
        <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Index([NaT</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso_8601_strings_with_same_offset(self):</span>
        <span class="s4"># GH 17697, 11736</span>
        <span class="s1">ts_str = </span><span class="s3">&quot;2015-11-18 15:30:00+05:30&quot;</span>
        <span class="s1">result = to_datetime(ts_str)</span>
        <span class="s1">expected = Timestamp(ts_str)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">expected = DatetimeIndex([Timestamp(ts_str)] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">result = to_datetime([ts_str] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = DatetimeIndex([ts_str] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso_8601_strings_with_different_offsets(self):</span>
        <span class="s4"># GH 17697, 11736</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;2015-11-18 15:30:00+05:30&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-11-18 16:30:00+06:30&quot;</span><span class="s2">, </span><span class="s1">NaT]</span>
        <span class="s1">result = to_datetime(ts_strings)</span>
        <span class="s1">expected = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">15</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">19800</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">16</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">23400</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s4"># GH 21864</span>
        <span class="s1">expected = Index(expected)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso_8601_strings_with_different_offsets_utc(self):</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;2015-11-18 15:30:00+05:30&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-11-18 16:30:00+06:30&quot;</span><span class="s2">, </span><span class="s1">NaT]</span>
        <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[Timestamp(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso8601_strings_mixed_offsets_with_naive(self):</span>
        <span class="s4"># GH 24992</span>
        <span class="s1">result = to_datetime(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-28T00:00:00+12:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-28T00:00:00+06:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">utc=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s1">expected = to_datetime(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-27T12:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-27T18:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">utc=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso8601_strings_mixed_offsets_with_naive_reversed(self):</span>
        <span class="s1">items = [</span><span class="s3">&quot;2018-11-28T00:00:00+12:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2018-11-28T00:00:00&quot;</span><span class="s1">]</span>
        <span class="s1">result = to_datetime(items</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(list(reversed(items))</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_mixed_offsets_with_native_datetime_raises(self):</span>
        <span class="s4"># GH 25978</span>

        <span class="s1">vals = [</span>
            <span class="s3">&quot;nan&quot;</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;1990-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;2015-03-14T16:15:14.123-08:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2019-03-04T21:56:32.620-07:00&quot;</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span>
        <span class="s1">ser = Series(vals)</span>
        <span class="s2">assert </span><span class="s1">all(ser[i] </span><span class="s2">is </span><span class="s1">vals[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(vals)))  </span><span class="s4"># GH#40111</span>

        <span class="s1">mixed = to_datetime(ser)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;NaT&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;1990-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2015-03-14T16:15:14.123-08:00&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2019-03-04T21:56:32.620-07:00&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
                <span class="s2">None,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(mixed</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Tz-aware datetime.datetime&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(mixed)</span>

    <span class="s2">def </span><span class="s1">test_non_iso_strings_with_tz_offset(self):</span>
        <span class="s1">result = to_datetime([</span><span class="s3">&quot;March 1, 2018 12:00:00+0400&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">240</span><span class="s1">))] * </span><span class="s5">2</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;ts, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01 08:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_timestamp_utc_true(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 24415</span>
        <span class="s1">result = to_datetime(ts</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dt_str&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;00010101&quot;</span><span class="s2">, </span><span class="s3">&quot;13000101&quot;</span><span class="s2">, </span><span class="s3">&quot;30000101&quot;</span><span class="s2">, </span><span class="s3">&quot;99990101&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_format_out_of_bounds(self</span><span class="s2">, </span><span class="s1">dt_str):</span>
        <span class="s4"># GH 9107</span>
        <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(dt_str</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_utc(self):</span>
        <span class="s1">arr = np.array([parse(</span><span class="s3">&quot;2012-06-13T01:39:00Z&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.tz </span><span class="s2">is </span><span class="s1">pytz.utc</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_fixed_offset(self):</span>
        <span class="s2">from </span><span class="s1">pandas.tests.indexes.datetimes.test_timezones </span><span class="s2">import </span><span class="s1">fixed_off</span>

        <span class="s1">dates = [</span>
            <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">tzinfo=fixed_off)</span><span class="s2">,</span>
            <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">tzinfo=fixed_off)</span><span class="s2">,</span>
            <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">tzinfo=fixed_off)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">result = to_datetime(dates)</span>
        <span class="s2">assert </span><span class="s1">result.tz == fixed_off</span>


<span class="s2">class </span><span class="s1">TestToDatetimeUnit:</span>
    <span class="s2">def </span><span class="s1">test_unit(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 11758</span>
        <span class="s4"># test proper behavior with errors</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot specify both format and unit&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_unit_array_mixed_nans(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">values = [</span><span class="s5">11111111</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">iNaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span>
        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Index(</span>
            <span class="s1">[</span>
                <span class="s5">11111111</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;1970-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;1970-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot convert input 11111111 with the unit 'D'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(values</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_unit_array_mixed_nans_large_int(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">values = [</span><span class="s5">1420043460000</span><span class="s2">, </span><span class="s1">iNaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span>

        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Index([</span><span class="s5">1420043460000</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot convert input 1420043460000 with the unit 's'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_invalid_str_not_out_of_bounds_valuerror(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># if we have a string, then we raise a ValueError</span>
        <span class="s4"># and NOT an OutOfBoundsDatetime</span>
        <span class="s1">msg = </span><span class="s3">&quot;non convertible value foo with the unit 's'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_unit_consistency(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">error):</span>
        <span class="s4"># consistency of conversions</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;1970-05-09 14:25:11&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(</span><span class="s5">11111111</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">errors=error</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;float64&quot;</span><span class="s2">, </span><span class="s3">&quot;int64&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_unit_with_numeric(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH 13180</span>
        <span class="s4"># coercions from floats/ints are ok</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2015-06-19 05:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-05-27 22:33:20&quot;</span><span class="s1">])</span>
        <span class="s1">arr = np.array([</span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s1">]).astype(dtype)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=errors</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;exp, arr&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-06-19 05:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-05-27 22:33:20&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">&quot;2015-06-19 05:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-05-27 22:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_unit_with_numeric_coerce(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s4"># but we want to make sure that we are coercing</span>
        <span class="s4"># if we have ints/strings</span>
        <span class="s1">expected = DatetimeIndex(exp)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;exp, arr&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2013-01-01&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_unit_mixed(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">arr):</span>

        <span class="s4"># mixed integers/datetimes</span>
        <span class="s1">expected = DatetimeIndex(exp)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;mixed datetimes and integers in passed array&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_unit_rounding(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 14156 &amp; GH 20445: argument will incur floating point errors</span>
        <span class="s4"># but no premature rounding</span>
        <span class="s1">result = to_datetime(</span><span class="s5">1434743731.8770001</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2015-06-19 19:55:31.877000192&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_unit_ignore_keeps_name(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 21697</span>
        <span class="s1">expected = Index([</span><span class="s5">15e9</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(expected</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_errors_ignore_utc_true(self):</span>
        <span class="s4"># GH#23758</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;1970-01-01 00:00:01&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s4"># TODO: this is moved from tests.series.test_timeseries, may be redundant</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[int</span><span class="s2">, </span><span class="s1">float])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_unit(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">epoch = </span><span class="s5">1370745748</span>
        <span class="s1">ser = Series([epoch + t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)]).astype(dtype)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;2013-06-09 02:42:28&quot;</span><span class="s1">) + timedelta(seconds=t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;null&quot;</span><span class="s2">, </span><span class="s1">[iNaT</span><span class="s2">, </span><span class="s1">np.nan])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_unit_with_nulls(self</span><span class="s2">, </span><span class="s1">null):</span>
        <span class="s1">epoch = </span><span class="s5">1370745748</span>
        <span class="s1">ser = Series([epoch + t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)] + [null])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;2013-06-09 02:42:28&quot;</span><span class="s1">) + timedelta(seconds=t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)]</span>
            <span class="s1">+ [NaT]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unit_fractional_seconds(self):</span>

        <span class="s4"># GH13834</span>
        <span class="s1">epoch = </span><span class="s5">1370745748</span>
        <span class="s1">ser = Series([epoch + t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.25</span><span class="s1">)] + [iNaT]).astype(float)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2013-06-09 02:42:28&quot;</span><span class="s1">) + timedelta(seconds=t)</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.25</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">+ [NaT]</span>
        <span class="s1">)</span>
        <span class="s4"># GH20455 argument will incur floating point errors but no premature rounding</span>
        <span class="s1">result = result.round(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unit_na_values(self):</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-03&quot;</span><span class="s1">)] + [</span><span class="s3">&quot;NaT&quot;</span><span class="s1">] * </span><span class="s5">3</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bad_val&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">111111111</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_unit_invalid(self</span><span class="s2">, </span><span class="s1">bad_val):</span>
        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">bad_val</span><span class="s2">} </span><span class="s3">with the unit 'D'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">bad_val]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bad_val&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">111111111</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_timestamp_unit_coerce(self</span><span class="s2">, </span><span class="s1">bad_val):</span>
        <span class="s4"># coerce we can process</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-03&quot;</span><span class="s1">)] + [</span><span class="s3">&quot;NaT&quot;</span><span class="s1">] * </span><span class="s5">1</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">bad_val]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestToDatetimeDataFrame:</span>
    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">df(self):</span>
        <span class="s2">return </span><span class="s1">DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;hour&quot;</span><span class="s1">: [</span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;minute&quot;</span><span class="s1">: [</span><span class="s5">58</span><span class="s2">, </span><span class="s5">59</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;second&quot;</span><span class="s1">: [</span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;ms&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;us&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;ns&quot;</span><span class="s1">: [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dataframe(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>

        <span class="s1">result = to_datetime(</span>
            <span class="s1">{</span><span class="s3">&quot;year&quot;</span><span class="s1">: df[</span><span class="s3">&quot;year&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: df[</span><span class="s3">&quot;month&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: df[</span><span class="s3">&quot;day&quot;</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 00:0:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># dict-like</span>
        <span class="s1">result = to_datetime(df[[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]].to_dict()</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_dict_with_constructable(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># dict but with constructable</span>
        <span class="s1">df2 = df[[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]].to_dict()</span>
        <span class="s1">df2[</span><span class="s3">&quot;month&quot;</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">result = to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected2 = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160205 00:0:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected2)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;unit&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">{</span>
                <span class="s3">&quot;year&quot;</span><span class="s1">: </span><span class="s3">&quot;years&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s3">&quot;months&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s3">&quot;days&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;hour&quot;</span><span class="s1">: </span><span class="s3">&quot;hours&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;minute&quot;</span><span class="s1">: </span><span class="s3">&quot;minutes&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;second&quot;</span><span class="s1">: </span><span class="s3">&quot;seconds&quot;</span><span class="s2">,</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;year&quot;</span><span class="s1">: </span><span class="s3">&quot;year&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s3">&quot;month&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s3">&quot;day&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;hour&quot;</span><span class="s1">: </span><span class="s3">&quot;hour&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;minute&quot;</span><span class="s1">: </span><span class="s3">&quot;minute&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;second&quot;</span><span class="s1">: </span><span class="s3">&quot;second&quot;</span><span class="s2">,</span>
            <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dataframe_field_aliases_column_subset(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># unit mappings</span>
        <span class="s1">result = to_datetime(df[list(unit.keys())].rename(columns=unit)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 06:58:10&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 07:59:11&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_field_aliases(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">d = {</span>
            <span class="s3">&quot;year&quot;</span><span class="s1">: </span><span class="s3">&quot;year&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s3">&quot;month&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s3">&quot;day&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;hour&quot;</span><span class="s1">: </span><span class="s3">&quot;hour&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;minute&quot;</span><span class="s1">: </span><span class="s3">&quot;minute&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;second&quot;</span><span class="s1">: </span><span class="s3">&quot;second&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;ms&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s3">&quot;us&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;ns&quot;</span><span class="s1">: </span><span class="s3">&quot;ns&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s1">result = to_datetime(df.rename(columns=d)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20150204 06:58:10.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20160305 07:59:11.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_str_dtype(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># coerce back to int</span>
        <span class="s1">result = to_datetime(df.astype(str)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20150204 06:58:10.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20160305 07:59:11.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_coerce(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># passing coerce</span>
        <span class="s1">df2 = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>

        <span class="s1">msg = (</span>
            <span class="s3">&quot;cannot assemble the datetimes: time data .+ does not &quot;</span>
            <span class="s3">r&quot;match format '%Y%m%d' \(match\)&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = to_datetime(df2</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_extra_keys_raisesm(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># extra columns</span>
        <span class="s1">msg = </span><span class="s3">r&quot;extra keys have been passed to the datetime assemblage: \[foo\]&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df2 = df.copy()</span>
            <span class="s1">df2[</span><span class="s3">&quot;foo&quot;</span><span class="s1">] = </span><span class="s5">1</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;cols&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;second&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s2">, </span><span class="s3">&quot;second&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dataframe_missing_keys_raises(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">cols):</span>
        <span class="s4"># not enough</span>
        <span class="s1">msg = (</span>
            <span class="s3">r&quot;to assemble mappings requires at least that \[year, month, &quot;</span>
            <span class="s3">r&quot;day\] be specified: \[.+\] is missing&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df[cols]</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_duplicate_columns_raises(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># duplicates</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot assemble with duplicate keys&quot;</span>
        <span class="s1">df2 = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
        <span class="s1">df2.columns = [</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">df2 = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;hour&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]}</span>
        <span class="s1">)</span>
        <span class="s1">df2.columns = [</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_int16(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH#13451</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>

        <span class="s4"># int16</span>
        <span class="s1">result = to_datetime(df.astype(</span><span class="s3">&quot;int16&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 00:00:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_mixed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># mixed dtypes</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
        <span class="s1">df[</span><span class="s3">&quot;month&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;month&quot;</span><span class="s1">].astype(</span><span class="s3">&quot;int8&quot;</span><span class="s1">)</span>
        <span class="s1">df[</span><span class="s3">&quot;day&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;day&quot;</span><span class="s1">].astype(</span><span class="s3">&quot;int8&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(df</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 00:00:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_float(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># float</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">2001</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]})</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot assemble the datetimes: unconverted data remains: 1&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_utc_true(self):</span>
        <span class="s4"># GH#23760</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
        <span class="s1">result = to_datetime(df</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">np.array([</span><span class="s3">&quot;2015-02-04&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-03-05&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">).dt.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestToDatetimeMisc:</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_barely_out_of_bounds(self):</span>
        <span class="s4"># GH#19529</span>
        <span class="s4"># GH#19382 close enough to bounds that dropping nanos would result</span>
        <span class="s4"># in an in-bounds datetime</span>
        <span class="s1">arr = np.array([</span><span class="s3">&quot;2262-04-11 23:47:16.854775808&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arr)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, exp_str&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2012-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2012-01-01 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;20121001&quot;</span><span class="s2">, </span><span class="s3">&quot;2012-10-01&quot;</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># bad iso 8601</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">exp_str):</span>
        <span class="s1">result = to_datetime([arg]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">exp = Timestamp(exp_str)</span>
        <span class="s2">assert </span><span class="s1">result[</span><span class="s5">0</span><span class="s1">] == exp</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_default(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">rs = to_datetime(</span><span class="s3">&quot;2001&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">xp = datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">rs == xp</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s3">&quot;fails to enforce dayfirst=True, which would raise&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_respects_dayfirst(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># dayfirst is essentially broken</span>

        <span class="s4"># The msg here is not important since it isn't actually raised yet.</span>
        <span class="s1">msg = </span><span class="s3">&quot;Invalid date specified&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s4"># if dayfirst is respected, then this would parse as month=13, which</span>
            <span class="s4">#  would raise</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Provide format&quot;</span><span class="s1">):</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;01-13-2012&quot;</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_on_datetime64_series(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># #2699</span>
        <span class="s1">ser = Series(date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">10</span><span class="s1">))</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result[</span><span class="s5">0</span><span class="s1">] == ser[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_with_space_in_series(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 6428</span>
        <span class="s1">ser = Series([</span><span class="s3">&quot;10/18/2006&quot;</span><span class="s2">, </span><span class="s3">&quot;10/18/2008&quot;</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s3">r&quot;(\(')?String does not contain a date(:', ' '\))?&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">result_coerce = to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected_coerce = Series([datetime(</span><span class="s5">2006</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">18</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">18</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_series_equal(result_coerce</span><span class="s2">, </span><span class="s1">expected_coerce)</span>
        <span class="s1">result_ignore = to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result_ignore</span><span class="s2">, </span><span class="s1">ser)</span>

    <span class="s1">@td.skip_if_has_locale</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_apply(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># this is only locale tested with US/None locales</span>
        <span class="s4"># GH 5195</span>
        <span class="s4"># with a format and coerce a single item to_datetime fails</span>
        <span class="s1">td = Series([</span><span class="s3">&quot;May 04&quot;</span><span class="s2">, </span><span class="s3">&quot;Jun 02&quot;</span><span class="s2">, </span><span class="s3">&quot;Dec 11&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">expected = to_datetime(td</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">result = td.apply(to_datetime</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_has_locale</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_apply_with_empty_str(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># this is only locale tested with US/None locales</span>
        <span class="s4"># GH 5195</span>
        <span class="s4"># with a format and coerce a single item to_datetime fails</span>
        <span class="s1">td = Series([</span><span class="s3">&quot;May 04&quot;</span><span class="s2">, </span><span class="s3">&quot;Jun 02&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s3">r&quot;time data '' does not match format '%b %y' \(match\)&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(td</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td.apply(to_datetime</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = to_datetime(td</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = td.apply(</span>
            <span class="s2">lambda </span><span class="s1">x: to_datetime(x</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_empty_stt(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># empty string</span>
        <span class="s1">result = to_datetime(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_empty_str_list(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">result = to_datetime([</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">isna(result).all()</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_zero(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># ints</span>
        <span class="s1">result = Timestamp(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_strings(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 3888 (strings)</span>
        <span class="s1">expected = to_datetime([</span><span class="s3">&quot;2012&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">result = to_datetime(</span><span class="s3">&quot;2012&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_strings_variation(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">array = [</span><span class="s3">&quot;2012&quot;</span><span class="s2">, </span><span class="s3">&quot;20120101&quot;</span><span class="s2">, </span><span class="s3">&quot;20120101 12:01:01&quot;</span><span class="s1">]</span>
        <span class="s1">expected = list(to_datetime(array</span><span class="s2">, </span><span class="s1">cache=cache))</span>
        <span class="s1">result = [Timestamp(date_str) </span><span class="s2">for </span><span class="s1">date_str </span><span class="s2">in </span><span class="s1">array]</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;result&quot;</span><span class="s2">, </span><span class="s1">[Timestamp(</span><span class="s3">&quot;2012&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">to_datetime(</span><span class="s3">&quot;2012&quot;</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_strings_vs_constructor(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unprocessable_input(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 4928</span>
        <span class="s4"># GH 21864</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">expected = Index(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;O&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;invalid string coercion to datetime&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unhashable_input(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">series = Series([[</span><span class="s3">&quot;a&quot;</span><span class="s1">]] * </span><span class="s5">100</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(series</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(series</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_other_datetime64_units(self):</span>
        <span class="s4"># 5/25/2012</span>
        <span class="s1">scalar = np.int64(</span><span class="s5">1337904000000000</span><span class="s1">).view(</span><span class="s3">&quot;M8[us]&quot;</span><span class="s1">)</span>
        <span class="s1">as_obj = scalar.astype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s1">index = DatetimeIndex([scalar])</span>
        <span class="s2">assert </span><span class="s1">index[</span><span class="s5">0</span><span class="s1">] == scalar.astype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s1">value = Timestamp(scalar)</span>
        <span class="s2">assert </span><span class="s1">value == as_obj</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_list_of_integers(self):</span>
        <span class="s1">rng = date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">rng = DatetimeIndex(rng.values)</span>

        <span class="s1">ints = list(rng.asi8)</span>

        <span class="s1">result = DatetimeIndex(ints)</span>

        <span class="s1">tm.assert_index_equal(rng</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_overflow(self):</span>
        <span class="s4"># gh-17637</span>
        <span class="s4"># we are overflowing Timedelta range here</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;Python int too large to convert to C long&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;long too big to convert&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;int too big to convert&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsTimedelta</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">date_range(start=</span><span class="s3">&quot;1/1/1700&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">100000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_string_na_nat_conversion(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH #999, #858</span>

        <span class="s1">strings = np.array(</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;1/4/2000, 12:34:56&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object</span>
        <span class="s1">)</span>

        <span class="s1">expected = np.empty(</span><span class="s5">4</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">enumerate(strings):</span>
            <span class="s2">if </span><span class="s1">isna(val):</span>
                <span class="s1">expected[i] = iNaT</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expected[i] = parse(val)</span>

        <span class="s1">result = tslib.array_to_datetime(strings)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result2 = to_datetime(strings</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result2</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">result2.values)</span>

    <span class="s2">def </span><span class="s1">test_string_na_nat_conversion_malformed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">malformed = np.array([</span><span class="s3">&quot;1/100/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s4"># GH 10636, default is now 'raise'</span>
        <span class="s1">msg = </span><span class="s3">r&quot;Unknown string format:|day is out of range for month&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(malformed</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = to_datetime(malformed</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s4"># GH 21864</span>
        <span class="s1">expected = Index(malformed)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(malformed</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_string_na_nat_conversion_with_name(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">idx = [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]</span>
        <span class="s1">series = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;1/5/2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=idx</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span>
        <span class="s1">)</span>
        <span class="s1">dseries = Series(</span>
            <span class="s1">[</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;1/5/2000&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=idx</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">result = to_datetime(series</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">dresult = to_datetime(dseries</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">expected = Series(np.empty(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=idx)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">):</span>
            <span class="s1">x = series[i]</span>
            <span class="s2">if </span><span class="s1">isna(x):</span>
                <span class="s1">expected[i] = NaT</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expected[i] = to_datetime(x</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.name == </span><span class="s3">&quot;foo&quot;</span>

        <span class="s1">tm.assert_series_equal(dresult</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">dresult.name == </span><span class="s3">&quot;foo&quot;</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dtype&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;datetime64[h]&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;datetime64[m]&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;datetime64[s]&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;datetime64[ms]&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;datetime64[us]&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dti_constructor_numpy_timeunits(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH 9114</span>
        <span class="s1">base = to_datetime([</span><span class="s3">&quot;2000-01-01T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-02T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">values = base.values.astype(dtype)</span>

        <span class="s1">tm.assert_index_equal(DatetimeIndex(values)</span><span class="s2">, </span><span class="s1">base)</span>
        <span class="s1">tm.assert_index_equal(to_datetime(values</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">, </span><span class="s1">base)</span>

    <span class="s2">def </span><span class="s1">test_dayfirst(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 5917</span>
        <span class="s1">arr = [</span><span class="s3">&quot;10/02/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;11/02/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;12/02/2014&quot;</span><span class="s1">]</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">idx1 = DatetimeIndex(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">idx2 = DatetimeIndex(np.array(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">idx3 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">idx4 = to_datetime(np.array(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">idx5 = DatetimeIndex(Index(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">idx6 = DatetimeIndex(Series(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx1)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx2)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx3)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx4)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx5)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx6)</span>

    <span class="s2">def </span><span class="s1">test_dayfirst_warnings_valid_input(self):</span>
        <span class="s4"># GH 12585</span>
        <span class="s1">warning_msg_day_first = (</span>
            <span class="s3">&quot;Parsing '31/12/2014' in DD/MM/YYYY format. Provide &quot;</span>
            <span class="s3">&quot;format or specify infer_datetime_format=True for consistent parsing.&quot;</span>
        <span class="s1">)</span>

        <span class="s4"># CASE 1: valid input</span>
        <span class="s1">arr = [</span><span class="s3">&quot;31/12/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;10/03/2011&quot;</span><span class="s1">]</span>
        <span class="s1">expected_consistent = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-03-10&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span>
        <span class="s1">)</span>
        <span class="s1">expected_inconsistent = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-10-03&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span>
        <span class="s1">)</span>

        <span class="s4"># A. dayfirst arg correct, no warning</span>
        <span class="s1">res1 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected_consistent</span><span class="s2">, </span><span class="s1">res1)</span>

        <span class="s4"># B. dayfirst arg incorrect, warning + incorrect output</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg_day_first):</span>
            <span class="s1">res2 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected_inconsistent</span><span class="s2">, </span><span class="s1">res2)</span>

        <span class="s4"># C. dayfirst default arg, same as B</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg_day_first):</span>
            <span class="s1">res3 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected_inconsistent</span><span class="s2">, </span><span class="s1">res3)</span>

        <span class="s4"># D. infer_datetime_format=True overrides dayfirst default</span>
        <span class="s4"># no warning + correct result</span>
        <span class="s1">res4 = to_datetime(arr</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected_consistent</span><span class="s2">, </span><span class="s1">res4)</span>

    <span class="s2">def </span><span class="s1">test_dayfirst_warnings_invalid_input(self):</span>
        <span class="s4"># CASE 2: invalid input</span>
        <span class="s4"># cannot consistently process with single format</span>
        <span class="s4"># warnings *always* raised</span>
        <span class="s1">warning_msg_day_first = (</span>
            <span class="s3">&quot;Parsing '31/12/2014' in DD/MM/YYYY format. Provide &quot;</span>
            <span class="s3">&quot;format or specify infer_datetime_format=True for consistent parsing.&quot;</span>
        <span class="s1">)</span>
        <span class="s1">warning_msg_month_first = (</span>
            <span class="s3">&quot;Parsing '03/30/2011' in MM/DD/YYYY format. Provide &quot;</span>
            <span class="s3">&quot;format or specify infer_datetime_format=True for consistent parsing.&quot;</span>
        <span class="s1">)</span>

        <span class="s1">arr = [</span><span class="s3">&quot;31/12/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;03/30/2011&quot;</span><span class="s1">]</span>
        <span class="s4"># first in DD/MM/YYYY, second in MM/DD/YYYY</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-03-30&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span>
        <span class="s1">)</span>

        <span class="s4"># A. use dayfirst=True</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg_month_first):</span>
            <span class="s1">res5 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">res5)</span>

        <span class="s4"># B. use dayfirst=False</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg_day_first):</span>
            <span class="s1">res6 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">res6)</span>

        <span class="s4"># C. use dayfirst default arg, same as B</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg_day_first):</span>
            <span class="s1">res7 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">res7)</span>

        <span class="s4"># D. use infer_datetime_format=True</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg_day_first):</span>
            <span class="s1">res8 = to_datetime(arr</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">res8)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;klass&quot;</span><span class="s2">, </span><span class="s1">[DatetimeIndex</span><span class="s2">, </span><span class="s1">DatetimeArray])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dta_tz(self</span><span class="s2">, </span><span class="s1">klass):</span>
        <span class="s4"># GH#27733</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2015-04-05&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">3</span><span class="s1">).rename(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">expected = dti.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>

        <span class="s1">obj = klass(dti)</span>
        <span class="s1">expected = klass(expected)</span>

        <span class="s1">result = to_datetime(obj</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestGuessDatetimeFormat:</span>
    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;test_array&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">, </span><span class="s3">&quot;random_string&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_guess_datetime_format_for_array(self</span><span class="s2">, </span><span class="s1">test_array):</span>
        <span class="s1">expected_format = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>
        <span class="s2">assert </span><span class="s1">tools._guess_datetime_format_for_array(test_array) == expected_format</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s2">def </span><span class="s1">test_guess_datetime_format_for_array_all_nans(self):</span>
        <span class="s1">format_for_string_of_nans = tools._guess_datetime_format_for_array(</span>
            <span class="s1">np.array([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">format_for_string_of_nans </span><span class="s2">is None</span>


<span class="s2">class </span><span class="s1">TestToDatetimeInferFormat:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;test_format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%m-%d-%Y&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y %H:%M:%S.%f&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_infer_datetime_format_consistent_format(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">test_format</span>
    <span class="s1">):</span>
        <span class="s1">ser = Series(date_range(</span><span class="s3">&quot;20000101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">))</span>

        <span class="s1">s_as_dt_strings = ser.apply(</span><span class="s2">lambda </span><span class="s1">x: x.strftime(test_format))</span>

        <span class="s1">with_format = to_datetime(s_as_dt_strings</span><span class="s2">, </span><span class="s1">format=test_format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">no_infer = to_datetime(</span>
            <span class="s1">s_as_dt_strings</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">False, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">yes_infer = to_datetime(</span>
            <span class="s1">s_as_dt_strings</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>

        <span class="s4"># Whether the format is explicitly passed, it is inferred, or</span>
        <span class="s4"># it is not inferred, the results should all be the same</span>
        <span class="s1">tm.assert_series_equal(with_format</span><span class="s2">, </span><span class="s1">no_infer)</span>
        <span class="s1">tm.assert_series_equal(no_infer</span><span class="s2">, </span><span class="s1">yes_infer)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;data&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;01/01/2011 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;01-02-2011 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-03T00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;Jan/01/2011&quot;</span><span class="s2">, </span><span class="s3">&quot;Feb/01/2011&quot;</span><span class="s2">, </span><span class="s3">&quot;Mar/01/2011&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_infer_datetime_format_inconsistent_format(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">ser = Series(np.array(data))</span>

        <span class="s4"># When the format is inconsistent, infer_datetime_format should just</span>
        <span class="s4"># fallback to the default parsing</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">False, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_infer_datetime_format_series_with_nans(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span><span class="s3">&quot;01/01/2011 00:00:00&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;01/03/2011 00:00:00&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                <span class="s1">dtype=object</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">False, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_infer_datetime_format_series_start_with_nans(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span>
                    <span class="s1">np.nan</span><span class="s2">,</span>
                    <span class="s1">np.nan</span><span class="s2">,</span>
                    <span class="s3">&quot;01/01/2011 00:00:00&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;01/02/2011 00:00:00&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;01/03/2011 00:00:00&quot;</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s1">dtype=object</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">False, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;tz_name, offset&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;UTC-3&quot;</span><span class="s2">, </span><span class="s5">180</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;UTC+3&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s5">180</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_infer_datetime_format_tz_name(self</span><span class="s2">, </span><span class="s1">tz_name</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s4"># GH 33133</span>
        <span class="s1">ser = Series([</span><span class="s3">f&quot;2019-02-02 08:07:13 </span><span class="s2">{</span><span class="s1">tz_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;2019-02-02 08:07:13&quot;</span><span class="s1">).tz_localize(pytz.FixedOffset(offset))]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;ts,zero_tz&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13.012345&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13.012345&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_infer_datetime_format_zero_tz(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">zero_tz):</span>
        <span class="s4"># GH 41047</span>
        <span class="s1">ser = Series([ts + zero_tz])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tz = pytz.utc </span><span class="s2">if </span><span class="s1">zero_tz == </span><span class="s3">&quot;Z&quot; </span><span class="s2">else None</span>
        <span class="s1">expected = Series([Timestamp(ts</span><span class="s2">, </span><span class="s1">tz=tz)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_noleading_0s(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH 11871</span>
        <span class="s1">ser = Series([</span><span class="s3">&quot;2014-1-1&quot;</span><span class="s2">, </span><span class="s3">&quot;2014-2-2&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-3-3&quot;</span><span class="s1">])</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2014-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2014-02-02&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2015-03-03&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(to_datetime(ser</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestDaysInMonth:</span>
    <span class="s4"># tests for issue #10154</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-32&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-04-31&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_day_not_in_month_coerce(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s2">assert </span><span class="s1">isna(to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache))</span>

    <span class="s2">def </span><span class="s1">test_day_not_in_month_raise(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">msg = </span><span class="s3">&quot;day is out of range for month&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-02-32&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-04-31&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_day_not_in_month_raise_value(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s1">msg = </span><span class="s3">f&quot;time data </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">} </span><span class="s3">doesn't match format specified&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;expected, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-04-31&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_day_not_in_month_ignore(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s1">result = to_datetime(expected</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">class </span><span class="s1">TestDatetimeParsingWrappers:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_str,expected&quot;</span><span class="s2">,</span>
        <span class="s1">list(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;2011-01-01&quot;</span><span class="s1">: datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2Q2005&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2Q05&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005Q1&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;05Q1&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2011Q3&quot;</span><span class="s1">: datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;11Q3&quot;</span><span class="s1">: datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;3Q2011&quot;</span><span class="s1">: datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;3Q11&quot;</span><span class="s1">: datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4"># quarterly without space</span>
                <span class="s3">&quot;2000Q4&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;00Q4&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;4Q2000&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;4Q00&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2000q4&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2000-Q4&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;00-Q4&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;4Q-2000&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;4Q-00&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;00q4&quot;</span><span class="s1">: datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005-11&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005 11&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;11-2005&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;11 2005&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;200511&quot;</span><span class="s1">: datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;20051109&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;20051109 10:15&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;20051109 08H&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005-11-09 10:15&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005-11-09 08H&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005/11/09 10:15&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2005/11/09 08H&quot;</span><span class="s1">: datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;Thu Sep 25 10:36:28 2003&quot;</span><span class="s1">: datetime(</span><span class="s5">2003</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">25</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">36</span><span class="s2">, </span><span class="s5">28</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;Thu Sep 25 2003&quot;</span><span class="s1">: datetime(</span><span class="s5">2003</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;Sep 25 2003&quot;</span><span class="s1">: datetime(</span><span class="s5">2003</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;January 1 2014&quot;</span><span class="s1">: datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4"># GHE10537</span>
                <span class="s3">&quot;2014-06&quot;</span><span class="s1">: datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;06-2014&quot;</span><span class="s1">: datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;2014-6&quot;</span><span class="s1">: datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;6-2014&quot;</span><span class="s1">: datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;20010101 12&quot;</span><span class="s1">: datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;20010101 1234&quot;</span><span class="s1">: datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;20010101 123456&quot;</span><span class="s1">: datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">}.items()</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers(self</span><span class="s2">, </span><span class="s1">date_str</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">cache):</span>

        <span class="s4"># dateutil &gt;= 2.5.0 defaults to yearfirst=True</span>
        <span class="s4"># https://github.com/dateutil/dateutil/issues/217</span>
        <span class="s1">yearfirst = </span><span class="s2">True</span>

        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_time_string(date_str</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s1">result2 = to_datetime(date_str</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s1">result3 = to_datetime([date_str]</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s4"># result5 is used below</span>
        <span class="s1">result4 = to_datetime(</span>
            <span class="s1">np.array([date_str]</span><span class="s2">, </span><span class="s1">dtype=object)</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">result6 = DatetimeIndex([date_str]</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s4"># result7 is used below</span>
        <span class="s1">result8 = DatetimeIndex(Index([date_str])</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s1">result9 = DatetimeIndex(Series([date_str])</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>

        <span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">[result1</span><span class="s2">, </span><span class="s1">result2]:</span>
            <span class="s2">assert </span><span class="s1">res == expected</span>
        <span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">[result3</span><span class="s2">, </span><span class="s1">result4</span><span class="s2">, </span><span class="s1">result6</span><span class="s2">, </span><span class="s1">result8</span><span class="s2">, </span><span class="s1">result9]:</span>
            <span class="s1">exp = DatetimeIndex([Timestamp(expected)])</span>
            <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s4"># these really need to have yearfirst, but we don't support</span>
        <span class="s2">if not </span><span class="s1">yearfirst:</span>
            <span class="s1">result5 = Timestamp(date_str)</span>
            <span class="s2">assert </span><span class="s1">result5 == expected</span>
            <span class="s1">result7 = date_range(date_str</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;S&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
            <span class="s2">assert </span><span class="s1">result7 == expected</span>

    <span class="s2">def </span><span class="s1">test_na_values_with_cache(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unique_nulls_fixture</span><span class="s2">, </span><span class="s1">unique_nulls_fixture2</span>
    <span class="s1">):</span>
        <span class="s4"># GH22305</span>
        <span class="s1">expected = Index([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime([unique_nulls_fixture</span><span class="s2">, </span><span class="s1">unique_nulls_fixture2]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_parsers_nat(self):</span>
        <span class="s4"># Test that each of several string-accepting methods return pd.NaT</span>
        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_time_string(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">result2 = to_datetime(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">result3 = Timestamp(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">result4 = DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">result1 </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">result2 </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">result3 </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">result4 </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_str, dayfirst, yearfirst, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, False, False, </span><span class="s1">datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, True, False, </span><span class="s1">datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, False, True, </span><span class="s1">datetime(</span><span class="s5">2010</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">12</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, True, True, </span><span class="s1">datetime(</span><span class="s5">2010</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, False, False, </span><span class="s1">datetime(</span><span class="s5">2021</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">20</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, True, False, </span><span class="s1">datetime(</span><span class="s5">2021</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">20</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, False, True, </span><span class="s1">datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">21</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, True, True, </span><span class="s1">datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">21</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers_dayfirst_yearfirst(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">date_str</span><span class="s2">, </span><span class="s1">dayfirst</span><span class="s2">, </span><span class="s1">yearfirst</span><span class="s2">, </span><span class="s1">expected</span>
    <span class="s1">):</span>
        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=0, yearfirst=0] -&gt; 2012-10-11 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2012-10-11 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=0, yearfirst=0] -&gt; 2012-10-11 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>

        <span class="s4"># bug fix in 2.5.2</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=1, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=1, yearfirst=1] -&gt; 2010-12-11 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=1, yearfirst=1] -&gt; 2010-12-11 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=1, yearfirst=0] -&gt; 2012-11-10 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=1, yearfirst=0] -&gt; 2012-11-10 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=1, yearfirst=0] -&gt; 2012-11-10 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=0, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=0, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=0, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=0, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=0, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=0, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>

        <span class="s4"># revert of bug in 2.5.2</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=1, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=1, yearfirst=1] -&gt; month must be in 1..12</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=1, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=1, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=1, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=1, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>

        <span class="s4"># str : dayfirst, yearfirst, expected</span>

        <span class="s4"># compare with dateutil result</span>
        <span class="s1">dateutil_result = parse(date_str</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s2">assert </span><span class="s1">dateutil_result == expected</span>

        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_time_string(</span>
            <span class="s1">date_str</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span>
        <span class="s1">)</span>

        <span class="s4"># we don't support dayfirst/yearfirst here:</span>
        <span class="s2">if not </span><span class="s1">dayfirst </span><span class="s2">and not </span><span class="s1">yearfirst:</span>
            <span class="s1">result2 = Timestamp(date_str)</span>
            <span class="s2">assert </span><span class="s1">result2 == expected</span>

        <span class="s1">result3 = to_datetime(</span>
            <span class="s1">date_str</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>

        <span class="s1">result4 = DatetimeIndex([date_str]</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">assert </span><span class="s1">result1 == expected</span>
        <span class="s2">assert </span><span class="s1">result3 == expected</span>
        <span class="s2">assert </span><span class="s1">result4 == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_str, exp_def&quot;</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">&quot;10:15&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;9:05&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)]]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers_timestring(self</span><span class="s2">, </span><span class="s1">date_str</span><span class="s2">, </span><span class="s1">exp_def):</span>
        <span class="s4"># must be the same as dateutil result</span>
        <span class="s1">exp_now = parse(date_str)</span>

        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_time_string(date_str)</span>
        <span class="s1">result2 = to_datetime(date_str)</span>
        <span class="s1">result3 = to_datetime([date_str])</span>
        <span class="s1">result4 = Timestamp(date_str)</span>
        <span class="s1">result5 = DatetimeIndex([date_str])[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4"># parse time string return time string based on default date</span>
        <span class="s4"># others are not, and can't be changed because it is used in</span>
        <span class="s4"># time series plot</span>
        <span class="s2">assert </span><span class="s1">result1 == exp_def</span>
        <span class="s2">assert </span><span class="s1">result2 == exp_now</span>
        <span class="s2">assert </span><span class="s1">result3 == exp_now</span>
        <span class="s2">assert </span><span class="s1">result4 == exp_now</span>
        <span class="s2">assert </span><span class="s1">result5 == exp_now</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt_string, tz, dt_string_repr&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2013-01-01 05:45+0545&quot;</span><span class="s2">,</span>
                <span class="s1">pytz.FixedOffset(</span><span class="s5">345</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;Timestamp('2013-01-01 05:45:00+0545', tz='pytz.FixedOffset(345)')&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2013-01-01 05:30+0530&quot;</span><span class="s2">,</span>
                <span class="s1">pytz.FixedOffset(</span><span class="s5">330</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;Timestamp('2013-01-01 05:30:00+0530', tz='pytz.FixedOffset(330)')&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers_timezone_minute_offsets_roundtrip(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dt_string</span><span class="s2">, </span><span class="s1">tz</span><span class="s2">, </span><span class="s1">dt_string_repr</span>
    <span class="s1">):</span>
        <span class="s4"># GH11708</span>
        <span class="s1">base = to_datetime(</span><span class="s3">&quot;2013-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">base = base.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz_convert(tz)</span>
        <span class="s1">dt_time = to_datetime(dt_string</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">base == dt_time</span>
        <span class="s2">assert </span><span class="s1">dt_string_repr == repr(dt_time)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">units(request):</span>
    <span class="s0">&quot;&quot;&quot;Day and some time units. 
 
    * D 
    * s 
    * ms 
    * us 
    * ns 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">epoch_1960():</span>
    <span class="s0">&quot;&quot;&quot;Timestamp at 1960-01-01.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Timestamp(</span><span class="s3">&quot;1960-01-01&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">units_from_epochs():</span>
    <span class="s2">return </span><span class="s1">list(range(</span><span class="s5">5</span><span class="s1">))</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;timestamp&quot;</span><span class="s2">, </span><span class="s3">&quot;pydatetime&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;str_1960&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">epochs(epoch_1960</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s0">&quot;&quot;&quot;Timestamp at 1960-01-01 in various forms. 
 
    * Timestamp 
    * datetime.datetime 
    * numpy.datetime64 
    * str 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">request.param </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;timestamp&quot;</span><span class="s2">, </span><span class="s3">&quot;pydatetime&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;str_1960&quot;</span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">request.param == </span><span class="s3">&quot;timestamp&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">epoch_1960</span>
    <span class="s2">elif </span><span class="s1">request.param == </span><span class="s3">&quot;pydatetime&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">epoch_1960.to_pydatetime()</span>
    <span class="s2">elif </span><span class="s1">request.param == </span><span class="s3">&quot;datetime64&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">epoch_1960.to_datetime64()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">str(epoch_1960)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">julian_dates():</span>
    <span class="s2">return </span><span class="s1">date_range(</span><span class="s3">&quot;2014-1-1&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">10</span><span class="s1">).to_julian_date().values</span>


<span class="s2">class </span><span class="s1">TestOrigin:</span>
    <span class="s2">def </span><span class="s1">test_julian(self</span><span class="s2">, </span><span class="s1">julian_dates):</span>
        <span class="s4"># gh-11276, gh-11745</span>
        <span class="s4"># for origin as julian</span>

        <span class="s1">result = Series(to_datetime(julian_dates</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s1">))</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">to_datetime(julian_dates - Timestamp(</span><span class="s5">0</span><span class="s1">).to_julian_date()</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_unix(self):</span>
        <span class="s1">result = Series(to_datetime([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;unix&quot;</span><span class="s1">))</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;1970-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-03&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_julian_round_trip(self):</span>
        <span class="s1">result = to_datetime(</span><span class="s5">2456658</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.to_julian_date() == </span><span class="s5">2456658</span>

        <span class="s4"># out-of-bounds</span>
        <span class="s1">msg = </span><span class="s3">&quot;1 is Out of Bounds for origin='julian'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_invalid_unit(self</span><span class="s2">, </span><span class="s1">units</span><span class="s2">, </span><span class="s1">julian_dates):</span>

        <span class="s4"># checking for invalid combination of origin='julian' and unit != D</span>
        <span class="s2">if </span><span class="s1">units != </span><span class="s3">&quot;D&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;unit must be 'D' for origin='julian'&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(julian_dates</span><span class="s2">, </span><span class="s1">unit=units</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_invalid_origin(self</span><span class="s2">, </span><span class="s1">unit):</span>

        <span class="s4"># need to have a numeric specified</span>
        <span class="s1">msg = </span><span class="s3">&quot;it must be numeric with a unit specified&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;2005-01-01&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1960-01-01&quot;</span><span class="s2">, </span><span class="s1">unit=unit)</span>

    <span class="s2">def </span><span class="s1">test_epoch(self</span><span class="s2">, </span><span class="s1">units</span><span class="s2">, </span><span class="s1">epochs</span><span class="s2">, </span><span class="s1">epoch_1960</span><span class="s2">, </span><span class="s1">units_from_epochs):</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[pd.Timedelta(x</span><span class="s2">, </span><span class="s1">unit=units) + epoch_1960 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">units_from_epochs]</span>
        <span class="s1">)</span>

        <span class="s1">result = Series(to_datetime(units_from_epochs</span><span class="s2">, </span><span class="s1">unit=units</span><span class="s2">, </span><span class="s1">origin=epochs))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;origin, exc&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;random_string&quot;</span><span class="s2">, </span><span class="s1">ValueError)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;epoch&quot;</span><span class="s2">, </span><span class="s1">ValueError)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;13-24-1990&quot;</span><span class="s2">, </span><span class="s1">ValueError)</span><span class="s2">,</span>
            <span class="s1">(datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">OutOfBoundsDatetime)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_invalid_origins(self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">exc</span><span class="s2">, </span><span class="s1">units</span><span class="s2">, </span><span class="s1">units_from_epochs):</span>

        <span class="s1">msg = </span><span class="s3">f&quot;origin </span><span class="s2">{</span><span class="s1">origin</span><span class="s2">} </span><span class="s3">(is Out of Bounds|cannot be converted to a Timestamp)&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(exc</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(units_from_epochs</span><span class="s2">, </span><span class="s1">unit=units</span><span class="s2">, </span><span class="s1">origin=origin)</span>

    <span class="s2">def </span><span class="s1">test_invalid_origins_tzinfo(self):</span>
        <span class="s4"># GH16842</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;must be tz-naive&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">tzinfo=pytz.utc))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_out_of_bounds_with_format_arg(self</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># see gh-23830</span>
        <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;2417-10-27 00:00:00&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, origin, expected_str&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">200 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s3">&quot;unix&quot;</span><span class="s2">, </span><span class="s3">&quot;2169-11-13 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">200 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s3">&quot;1870-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2069-11-13 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">300 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s3">&quot;1870-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2169-10-20 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_processing_order(self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">expected_str):</span>
        <span class="s4"># make sure we handle out-of-bounds *before*</span>
        <span class="s4"># constructing the dates</span>

        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=origin)</span>
        <span class="s1">expected = Timestamp(expected_str)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = to_datetime(</span><span class="s5">200 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1870-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2069-11-13 00:00:00&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = to_datetime(</span><span class="s5">300 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1870-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2169-10-20 00:00:00&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;offset,utc,exp&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;Z&quot;</span><span class="s2">, True, </span><span class="s3">&quot;2019-01-01T00:00:00.000Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;Z&quot;</span><span class="s2">, None, </span><span class="s3">&quot;2019-01-01T00:00:00.000Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;-01:00&quot;</span><span class="s2">, True, </span><span class="s3">&quot;2019-01-01T01:00:00.000Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;-01:00&quot;</span><span class="s2">, None, </span><span class="s3">&quot;2019-01-01T00:00:00.000-01:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_arg_tz_ns_unit(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">exp):</span>
        <span class="s4"># GH 25546</span>
        <span class="s1">arg = </span><span class="s3">&quot;2019-01-01T00:00:00.000&quot; </span><span class="s1">+ offset</span>
        <span class="s1">result = to_datetime([arg]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">utc=utc)</span>
        <span class="s1">expected = to_datetime([exp])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestShouldCache:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;listlike,do_caching&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_should_cache(self</span><span class="s2">, </span><span class="s1">listlike</span><span class="s2">, </span><span class="s1">do_caching):</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">tools.should_cache(listlike</span><span class="s2">, </span><span class="s1">check_count=len(listlike)</span><span class="s2">, </span><span class="s1">unique_share=</span><span class="s5">0.7</span><span class="s1">)</span>
            <span class="s1">== do_caching</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;unique_share,check_count, err_message&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s3">r&quot;check_count must be in next bounds: \[0; len\(arg\)\]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s3">r&quot;unique_share must be in next bounds: \(0; 1\)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_should_cache_errors(self</span><span class="s2">, </span><span class="s1">unique_share</span><span class="s2">, </span><span class="s1">check_count</span><span class="s2">, </span><span class="s1">err_message):</span>
        <span class="s1">arg = [</span><span class="s5">5</span><span class="s1">] * </span><span class="s5">10</span>

        <span class="s2">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s2">, </span><span class="s1">match=err_message):</span>
            <span class="s1">tools.should_cache(arg</span><span class="s2">, </span><span class="s1">unique_share</span><span class="s2">, </span><span class="s1">check_count)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;listlike&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(deque([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(tuple([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_no_slicing_errors_in_should_cache(self</span><span class="s2">, </span><span class="s1">listlike):</span>
        <span class="s4"># GH#29403</span>
        <span class="s2">assert </span><span class="s1">tools.should_cache(listlike) </span><span class="s2">is True</span>


<span class="s2">def </span><span class="s1">test_nullable_integer_to_datetime():</span>
    <span class="s4"># Test for #30050</span>
    <span class="s1">ser = Series([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, None, </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">61</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">ser = ser.astype(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>
    <span class="s1">ser_copy = ser.copy()</span>

    <span class="s1">res = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

    <span class="s1">expected = Series(</span>
        <span class="s1">[</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;1970-01-01 00:00:00.000000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;1970-01-01 00:00:00.000000002&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2043-01-25 23:56:49.213693952&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s4"># Check that ser isn't mutated</span>
    <span class="s1">tm.assert_series_equal(ser</span><span class="s2">, </span><span class="s1">ser_copy)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;klass&quot;</span><span class="s2">, </span><span class="s1">[np.array</span><span class="s2">, </span><span class="s1">list])</span>
<span class="s2">def </span><span class="s1">test_na_to_datetime(nulls_fixture</span><span class="s2">, </span><span class="s1">klass):</span>

    <span class="s2">if </span><span class="s1">isinstance(nulls_fixture</span><span class="s2">, </span><span class="s1">Decimal):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;not convertible to datetime&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(klass([nulls_fixture]))</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = to_datetime(klass([nulls_fixture]))</span>

        <span class="s2">assert </span><span class="s1">result[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">NaT</span>


<span class="s2">def </span><span class="s1">test_empty_string_datetime_coerce_format():</span>
    <span class="s4"># GH13044</span>
    <span class="s1">td = Series([</span><span class="s3">&quot;03/24/2016&quot;</span><span class="s2">, </span><span class="s3">&quot;03/25/2016&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">])</span>
    <span class="s1">format = </span><span class="s3">&quot;%m/%d/%Y&quot;</span>

    <span class="s4"># coerce empty string to pd.NaT</span>
    <span class="s1">result = to_datetime(td</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;2016-03-24&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-03-25&quot;</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s4"># raise an exception in case a format is given</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;does not match format&quot;</span><span class="s1">):</span>
        <span class="s1">to_datetime(td</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>

    <span class="s4"># don't raise an exception in case no format is given</span>
    <span class="s1">result = to_datetime(td</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_empty_string_datetime_coerce__unit():</span>
    <span class="s4"># GH13044</span>
    <span class="s4"># coerce empty string to pd.NaT</span>
    <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;1970-01-01 00:00:01&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s4"># verify that no exception is raised even when errors='raise' is set</span>
    <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>


<span class="s1">@td.skip_if_no(</span><span class="s3">&quot;xarray&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_xarray_coerce_unit():</span>
    <span class="s4"># GH44053</span>
    <span class="s2">import </span><span class="s1">xarray </span><span class="s2">as </span><span class="s1">xr</span>

    <span class="s1">arr = xr.DataArray([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DatetimeIndex(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;1970-01-01 00:00:00.000000001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;1970-01-01 00:00:00.000000002&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;1970-01-01 00:00:00.000000003&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">,</span>
        <span class="s1">freq=</span><span class="s2">None,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;cache&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_to_datetime_monotonic_increasing_index(cache):</span>
    <span class="s4"># GH28238</span>
    <span class="s1">cstart = start_caching_at</span>
    <span class="s1">times = date_range(Timestamp(</span><span class="s3">&quot;1980&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=cstart</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;YS&quot;</span><span class="s1">)</span>
    <span class="s1">times = times.to_frame(index=</span><span class="s2">False, </span><span class="s1">name=</span><span class="s3">&quot;DT&quot;</span><span class="s1">).sample(n=cstart</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">times.index = times.index.to_series().astype(float) / </span><span class="s5">1000</span>
    <span class="s1">result = to_datetime(times.iloc[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
    <span class="s1">expected = times.iloc[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>