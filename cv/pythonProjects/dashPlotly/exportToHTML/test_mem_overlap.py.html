<html>
<head>
<title>test_mem_overlap.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_mem_overlap.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.core._multiarray_tests </span><span class="s0">import </span><span class="s1">solve_diophantine</span><span class="s0">, </span><span class="s1">internal_overlap</span>
<span class="s0">from </span><span class="s1">numpy.core </span><span class="s0">import </span><span class="s1">_umath_tests</span>
<span class="s0">from </span><span class="s1">numpy.lib.stride_tricks </span><span class="s0">import </span><span class="s1">as_strided</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span>
    <span class="s1">)</span>


<span class="s1">ndims = </span><span class="s2">2</span>
<span class="s1">size = </span><span class="s2">10</span>
<span class="s1">shape = tuple([size] * ndims)</span>

<span class="s1">MAY_SHARE_BOUNDS = </span><span class="s2">0</span>
<span class="s1">MAY_SHARE_EXACT = -</span><span class="s2">1</span>


<span class="s0">def </span><span class="s1">_indices_for_nelems(nelems):</span>
    <span class="s3">&quot;&quot;&quot;Returns slices of length nelems, from start onwards, in direction sign.&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">nelems == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">[size // </span><span class="s2">2</span><span class="s1">]  </span><span class="s4"># int index</span>

    <span class="s1">res = []</span>
    <span class="s0">for </span><span class="s1">step </span><span class="s0">in </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">sign </span><span class="s0">in </span><span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">start = size // </span><span class="s2">2 </span><span class="s1">- nelems * step * sign // </span><span class="s2">2</span>
            <span class="s1">stop = start + nelems * step * sign</span>
            <span class="s1">res.append(slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step * sign))</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_indices_for_axis():</span>
    <span class="s3">&quot;&quot;&quot;Returns (src, dst) pairs of indices.&quot;&quot;&quot;</span>

    <span class="s1">res = []</span>
    <span class="s0">for </span><span class="s1">nelems </span><span class="s0">in </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">):</span>
        <span class="s1">ind = _indices_for_nelems(nelems)</span>
        <span class="s1">res.extend(itertools.product(ind</span><span class="s0">, </span><span class="s1">ind))  </span><span class="s4"># all assignments of size &quot;nelems&quot;</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_indices(ndims):</span>
    <span class="s3">&quot;&quot;&quot;Returns ((axis0_src, axis0_dst), (axis1_src, axis1_dst), ... ) index pairs.&quot;&quot;&quot;</span>

    <span class="s1">ind = _indices_for_axis()</span>
    <span class="s0">return </span><span class="s1">itertools.product(ind</span><span class="s0">, </span><span class="s1">repeat=ndims)</span>


<span class="s0">def </span><span class="s1">_check_assignment(srcidx</span><span class="s0">, </span><span class="s1">dstidx):</span>
    <span class="s3">&quot;&quot;&quot;Check assignment arr[dstidx] = arr[srcidx] works.&quot;&quot;&quot;</span>

    <span class="s1">arr = np.arange(np.product(shape)).reshape(shape)</span>

    <span class="s1">cpy = arr.copy()</span>

    <span class="s1">cpy[dstidx] = arr[srcidx]</span>
    <span class="s1">arr[dstidx] = arr[srcidx]</span>

    <span class="s1">assert_(np.all(arr == cpy)</span><span class="s0">,</span>
            <span class="s5">'assigning arr[%s] = arr[%s]' </span><span class="s1">% (dstidx</span><span class="s0">, </span><span class="s1">srcidx))</span>


<span class="s0">def </span><span class="s1">test_overlapping_assignments():</span>
    <span class="s4"># Test automatically generated assignments which overlap in memory.</span>

    <span class="s1">inds = _indices(ndims)</span>

    <span class="s0">for </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">inds:</span>
        <span class="s1">srcidx = tuple([a[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">ind])</span>
        <span class="s1">dstidx = tuple([a[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">ind])</span>

        <span class="s1">_check_assignment(srcidx</span><span class="s0">, </span><span class="s1">dstidx)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_diophantine_fuzz():</span>
    <span class="s4"># Fuzz test the diophantine solver</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>

    <span class="s1">max_int = np.iinfo(np.intp).max</span>

    <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
        <span class="s1">feasible_count = </span><span class="s2">0</span>
        <span class="s1">infeasible_count = </span><span class="s2">0</span>

        <span class="s1">min_count = </span><span class="s2">500</span><span class="s1">//(ndim + </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">while </span><span class="s1">min(feasible_count</span><span class="s0">, </span><span class="s1">infeasible_count) &lt; min_count:</span>
            <span class="s4"># Ensure big and small integer problems</span>
            <span class="s1">A_max = </span><span class="s2">1 </span><span class="s1">+ rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">dtype=np.intp)**</span><span class="s2">6</span>
            <span class="s1">U_max = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">dtype=np.intp)**</span><span class="s2">6</span>

            <span class="s1">A_max = min(max_int</span><span class="s0">, </span><span class="s1">A_max)</span>
            <span class="s1">U_max = min(max_int-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">U_max)</span>

            <span class="s1">A = tuple(int(rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">A_max+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.intp))</span>
                      <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ndim))</span>
            <span class="s1">U = tuple(int(rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">U_max+</span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.intp))</span>
                      <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ndim))</span>

            <span class="s1">b_ub = min(max_int-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">sum(a*ub </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ub </span><span class="s0">in </span><span class="s1">zip(A</span><span class="s0">, </span><span class="s1">U)))</span>
            <span class="s1">b = rng.randint(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">b_ub+</span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

            <span class="s0">if </span><span class="s1">ndim == </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">feasible_count &lt; min_count:</span>
                <span class="s1">b = </span><span class="s2">0</span>

            <span class="s1">X = solve_diophantine(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">b)</span>

            <span class="s0">if </span><span class="s1">X </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s4"># Check the simplified decision problem agrees</span>
                <span class="s1">X_simplified = solve_diophantine(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s2">1</span><span class="s1">)</span>
                <span class="s1">assert_(X_simplified </span><span class="s0">is None, </span><span class="s1">(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">X_simplified))</span>

                <span class="s4"># Check no solution exists (provided the problem is</span>
                <span class="s4"># small enough so that brute force checking doesn't</span>
                <span class="s4"># take too long)</span>
                <span class="s1">ranges = tuple(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">a*ub+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ub </span><span class="s0">in </span><span class="s1">zip(A</span><span class="s0">, </span><span class="s1">U))</span>

                <span class="s1">size = </span><span class="s2">1</span>
                <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">ranges:</span>
                    <span class="s1">size *= len(r)</span>
                <span class="s0">if </span><span class="s1">size &lt; </span><span class="s2">100000</span><span class="s1">:</span>
                    <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">any(sum(w) == b </span><span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">itertools.product(*ranges)))</span>
                    <span class="s1">infeasible_count += </span><span class="s2">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># Check the simplified decision problem agrees</span>
                <span class="s1">X_simplified = solve_diophantine(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s2">1</span><span class="s1">)</span>
                <span class="s1">assert_(X_simplified </span><span class="s0">is not None, </span><span class="s1">(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">X_simplified))</span>

                <span class="s4"># Check validity</span>
                <span class="s1">assert_(sum(a*x </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">zip(A</span><span class="s0">, </span><span class="s1">X)) == b)</span>
                <span class="s1">assert_(all(</span><span class="s2">0 </span><span class="s1">&lt;= x &lt;= ub </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">ub </span><span class="s0">in </span><span class="s1">zip(X</span><span class="s0">, </span><span class="s1">U)))</span>
                <span class="s1">feasible_count += </span><span class="s2">1</span>


<span class="s0">def </span><span class="s1">test_diophantine_overflow():</span>
    <span class="s4"># Smoke test integer overflow detection</span>
    <span class="s1">max_intp = np.iinfo(np.intp).max</span>
    <span class="s1">max_int64 = np.iinfo(np.int64).max</span>

    <span class="s0">if </span><span class="s1">max_int64 &lt;= max_intp:</span>
        <span class="s4"># Check that the algorithm works internally in 128-bit;</span>
        <span class="s4"># solving this problem requires large intermediate numbers</span>
        <span class="s1">A = (max_int64//</span><span class="s2">2</span><span class="s0">, </span><span class="s1">max_int64//</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">U = (max_int64//</span><span class="s2">2</span><span class="s0">, </span><span class="s1">max_int64//</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">b = </span><span class="s2">2</span><span class="s1">*(max_int64//</span><span class="s2">2</span><span class="s1">) - </span><span class="s2">10</span>

        <span class="s1">assert_equal(solve_diophantine(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">check_may_share_memory_exact(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s1">got = np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">max_work=MAY_SHARE_EXACT)</span>

    <span class="s1">assert_equal(np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
                 <span class="s1">np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">max_work=MAY_SHARE_BOUNDS))</span>

    <span class="s1">a.fill(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">b.fill(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">a.fill(</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">exact = b.any()</span>

    <span class="s1">err_msg = </span><span class="s5">&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">got != exact:</span>
        <span class="s1">err_msg = </span><span class="s5">&quot;    &quot; </span><span class="s1">+ </span><span class="s5">&quot;</span><span class="s0">\n    </span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">&quot;base_a - base_b = %r&quot; </span><span class="s1">% (a.__array_interface__[</span><span class="s5">'data'</span><span class="s1">][</span><span class="s2">0</span><span class="s1">] - b.__array_interface__[</span><span class="s5">'data'</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;shape_a = %r&quot; </span><span class="s1">% (a.shape</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;shape_b = %r&quot; </span><span class="s1">% (b.shape</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;strides_a = %r&quot; </span><span class="s1">% (a.strides</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;strides_b = %r&quot; </span><span class="s1">% (b.strides</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;size_a = %r&quot; </span><span class="s1">% (a.size</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;size_b = %r&quot; </span><span class="s1">% (b.size</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">])</span>

    <span class="s1">assert_equal(got</span><span class="s0">, </span><span class="s1">exact</span><span class="s0">, </span><span class="s1">err_msg=err_msg)</span>


<span class="s0">def </span><span class="s1">test_may_share_memory_manual():</span>
    <span class="s4"># Manual test cases for may_share_memory</span>

    <span class="s4"># Base arrays</span>
    <span class="s1">xs0 = [</span>
        <span class="s1">np.zeros([</span><span class="s2">13</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">22</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span><span class="s0">,</span>
        <span class="s1">np.zeros([</span><span class="s2">13</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">23</span><span class="s1">*</span><span class="s2">2</span><span class="s0">, </span><span class="s2">22</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)[:</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">2</span><span class="s0">,</span><span class="s1">:]</span>
    <span class="s1">]</span>

    <span class="s4"># Generate all negative stride combinations</span>
    <span class="s1">xs = []</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">xs0:</span>
        <span class="s0">for </span><span class="s1">ss </span><span class="s0">in </span><span class="s1">itertools.product(*(([slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)]</span><span class="s0">,</span><span class="s1">)*</span><span class="s2">4</span><span class="s1">)):</span>
            <span class="s1">xp = x[ss]</span>
            <span class="s1">xs.append(xp)</span>

    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">xs:</span>
        <span class="s4"># The default is a simple extent check</span>
        <span class="s1">assert_(np.may_share_memory(x[:</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:]))</span>
        <span class="s1">assert_(np.may_share_memory(x[:</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">max_work=</span><span class="s0">None</span><span class="s1">))</span>

        <span class="s4"># Exact checks</span>
        <span class="s1">check_may_share_memory_exact(x[:</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">check_may_share_memory_exact(x[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s2">3</span><span class="s1">::</span><span class="s2">3</span><span class="s1">])</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">xp = x.ravel()</span>
            <span class="s0">if </span><span class="s1">xp.flags.owndata:</span>
                <span class="s0">continue</span>
            <span class="s1">xp = xp.view(np.int16)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">continue</span>

        <span class="s4"># 0-size arrays cannot overlap</span>
        <span class="s1">check_may_share_memory_exact(x.ravel()[</span><span class="s2">6</span><span class="s1">:</span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">xp.reshape(</span><span class="s2">13</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">7</span><span class="s1">])</span>

        <span class="s4"># Test itemsize is dealt with</span>
        <span class="s1">check_may_share_memory_exact(x[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">xp.reshape(</span><span class="s2">13</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">11</span><span class="s1">))</span>
        <span class="s1">check_may_share_memory_exact(x[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">xp.reshape(</span><span class="s2">13</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)[:</span><span class="s0">,</span><span class="s2">3</span><span class="s1">::</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">check_may_share_memory_exact(x.ravel()[</span><span class="s2">6</span><span class="s1">:</span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">xp.reshape(</span><span class="s2">13</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">7</span><span class="s1">])</span>

    <span class="s4"># Check unit size</span>
    <span class="s1">x = np.zeros([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span>
    <span class="s1">check_may_share_memory_exact(x</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s1">check_may_share_memory_exact(x</span><span class="s0">, </span><span class="s1">x.copy())</span>


<span class="s0">def </span><span class="s1">iter_random_view_pairs(x</span><span class="s0">, </span><span class="s1">same_steps=</span><span class="s0">True, </span><span class="s1">equal_size=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">equal_size </span><span class="s0">and </span><span class="s1">same_steps:</span>
        <span class="s0">raise </span><span class="s1">ValueError()</span>

    <span class="s0">def </span><span class="s1">random_slice(n</span><span class="s0">, </span><span class="s1">step):</span>
        <span class="s1">start = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">stop = rng.randint(start</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.intp) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">stop</span><span class="s0">, </span><span class="s1">start = start</span><span class="s0">, </span><span class="s1">stop</span>
            <span class="s1">step *= -</span><span class="s2">1</span>
        <span class="s0">return </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>

    <span class="s0">def </span><span class="s1">random_slice_fixed_size(n</span><span class="s0">, </span><span class="s1">step</span><span class="s0">, </span><span class="s1">size):</span>
        <span class="s1">start = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1 </span><span class="s1">- size*step)</span>
        <span class="s1">stop = start + (size-</span><span class="s2">1</span><span class="s1">)*step + </span><span class="s2">1</span>
        <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">stop</span><span class="s0">, </span><span class="s1">start = start-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">stop-</span><span class="s2">1</span>
            <span class="s0">if </span><span class="s1">stop &lt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">stop = </span><span class="s0">None</span>
            <span class="s1">step *= -</span><span class="s2">1</span>
        <span class="s0">return </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>

    <span class="s4"># First a few regular views</span>
    <span class="s0">yield </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">3</span><span class="s1">):</span>
        <span class="s0">yield </span><span class="s1">x[j:]</span><span class="s0">, </span><span class="s1">x[:-j]</span>
        <span class="s0">yield </span><span class="s1">x[...</span><span class="s0">,</span><span class="s1">j:]</span><span class="s0">, </span><span class="s1">x[...</span><span class="s0">,</span><span class="s1">:-j]</span>

    <span class="s4"># An array with zero stride internal overlap</span>
    <span class="s1">strides = list(x.strides)</span>
    <span class="s1">strides[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">0</span>
    <span class="s1">xp = as_strided(x</span><span class="s0">, </span><span class="s1">shape=x.shape</span><span class="s0">, </span><span class="s1">strides=strides)</span>
    <span class="s0">yield </span><span class="s1">x</span><span class="s0">, </span><span class="s1">xp</span>
    <span class="s0">yield </span><span class="s1">xp</span><span class="s0">, </span><span class="s1">xp</span>

    <span class="s4"># An array with non-zero stride internal overlap</span>
    <span class="s1">strides = list(x.strides)</span>
    <span class="s0">if </span><span class="s1">strides[</span><span class="s2">0</span><span class="s1">] &gt; </span><span class="s2">1</span><span class="s1">:</span>
        <span class="s1">strides[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">1</span>
    <span class="s1">xp = as_strided(x</span><span class="s0">, </span><span class="s1">shape=x.shape</span><span class="s0">, </span><span class="s1">strides=strides)</span>
    <span class="s0">yield </span><span class="s1">x</span><span class="s0">, </span><span class="s1">xp</span>
    <span class="s0">yield </span><span class="s1">xp</span><span class="s0">, </span><span class="s1">xp</span>

    <span class="s4"># Then discontiguous views</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s1">steps = tuple(rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                      <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.intp) == </span><span class="s2">0 </span><span class="s0">else </span><span class="s2">1</span>
                      <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(x.ndim))</span>
        <span class="s1">s1 = tuple(random_slice(p</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">zip(x.shape</span><span class="s0">, </span><span class="s1">steps))</span>

        <span class="s1">t1 = np.arange(x.ndim)</span>
        <span class="s1">rng.shuffle(t1)</span>

        <span class="s0">if </span><span class="s1">equal_size:</span>
            <span class="s1">t2 = t1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">t2 = np.arange(x.ndim)</span>
            <span class="s1">rng.shuffle(t2)</span>

        <span class="s1">a = x[s1]</span>

        <span class="s0">if </span><span class="s1">equal_size:</span>
            <span class="s0">if </span><span class="s1">a.size == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s0">continue</span>

            <span class="s1">steps2 = tuple(rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">max(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">p//(</span><span class="s2">1</span><span class="s1">+pa)))</span>
                           <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) == </span><span class="s2">0 </span><span class="s0">else </span><span class="s2">1</span>
                           <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">pa </span><span class="s0">in </span><span class="s1">zip(x.shape</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">a.shape))</span>
            <span class="s1">s2 = tuple(random_slice_fixed_size(p</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">pa)</span>
                       <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">pa </span><span class="s0">in </span><span class="s1">zip(x.shape</span><span class="s0">, </span><span class="s1">steps2</span><span class="s0">, </span><span class="s1">a.shape))</span>
        <span class="s0">elif </span><span class="s1">same_steps:</span>
            <span class="s1">steps2 = steps</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">steps2 = tuple(rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                           <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.intp) == </span><span class="s2">0 </span><span class="s0">else </span><span class="s2">1</span>
                           <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(x.ndim))</span>

        <span class="s0">if not </span><span class="s1">equal_size:</span>
            <span class="s1">s2 = tuple(random_slice(p</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">zip(x.shape</span><span class="s0">, </span><span class="s1">steps2))</span>

        <span class="s1">a = a.transpose(t1)</span>
        <span class="s1">b = x[s2].transpose(t2)</span>

        <span class="s0">yield </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span>


<span class="s0">def </span><span class="s1">check_may_share_memory_easy_fuzz(get_max_work</span><span class="s0">, </span><span class="s1">same_steps</span><span class="s0">, </span><span class="s1">min_count):</span>
    <span class="s4"># Check that overlap problems with common strides are solved with</span>
    <span class="s4"># little work.</span>
    <span class="s1">x = np.zeros([</span><span class="s2">17</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">97</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>

    <span class="s1">feasible = </span><span class="s2">0</span>
    <span class="s1">infeasible = </span><span class="s2">0</span>

    <span class="s1">pair_iter = iter_random_view_pairs(x</span><span class="s0">, </span><span class="s1">same_steps)</span>

    <span class="s0">while </span><span class="s1">min(feasible</span><span class="s0">, </span><span class="s1">infeasible) &lt; min_count:</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = next(pair_iter)</span>

        <span class="s1">bounds_overlap = np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">may_share_answer = np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">easy_answer = np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">max_work=get_max_work(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s1">exact_answer = np.may_share_memory(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">max_work=MAY_SHARE_EXACT)</span>

        <span class="s0">if </span><span class="s1">easy_answer != exact_answer:</span>
            <span class="s4"># assert_equal is slow...</span>
            <span class="s1">assert_equal(easy_answer</span><span class="s0">, </span><span class="s1">exact_answer)</span>

        <span class="s0">if </span><span class="s1">may_share_answer != bounds_overlap:</span>
            <span class="s1">assert_equal(may_share_answer</span><span class="s0">, </span><span class="s1">bounds_overlap)</span>

        <span class="s0">if </span><span class="s1">bounds_overlap:</span>
            <span class="s0">if </span><span class="s1">exact_answer:</span>
                <span class="s1">feasible += </span><span class="s2">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">infeasible += </span><span class="s2">1</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_may_share_memory_easy_fuzz():</span>
    <span class="s4"># Check that overlap problems with common strides are always</span>
    <span class="s4"># solved with little work.</span>

    <span class="s1">check_may_share_memory_easy_fuzz(get_max_work=</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: </span><span class="s2">1</span><span class="s0">,</span>
                                     <span class="s1">same_steps=</span><span class="s0">True,</span>
                                     <span class="s1">min_count=</span><span class="s2">2000</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_may_share_memory_harder_fuzz():</span>
    <span class="s4"># Overlap problems with not necessarily common strides take more</span>
    <span class="s4"># work.</span>
    <span class="s4">#</span>
    <span class="s4"># The work bound below can't be reduced much. Harder problems can</span>
    <span class="s4"># also exist but not be detected here, as the set of problems</span>
    <span class="s4"># comes from RNG.</span>

    <span class="s1">check_may_share_memory_easy_fuzz(get_max_work=</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: max(a.size</span><span class="s0">, </span><span class="s1">b.size)//</span><span class="s2">2</span><span class="s0">,</span>
                                     <span class="s1">same_steps=</span><span class="s0">False,</span>
                                     <span class="s1">min_count=</span><span class="s2">2000</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_shares_memory_api():</span>
    <span class="s1">x = np.zeros([</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span>

    <span class="s1">assert_equal(np.shares_memory(x</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(np.shares_memory(x</span><span class="s0">, </span><span class="s1">x.copy())</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">a = x[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">2</span><span class="s0">,</span><span class="s1">::</span><span class="s2">3</span><span class="s1">]</span>
    <span class="s1">b = x[:</span><span class="s0">,</span><span class="s1">::</span><span class="s2">3</span><span class="s0">,</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>
    <span class="s1">assert_equal(np.shares_memory(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(np.shares_memory(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">max_work=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">)</span>
    <span class="s1">assert_raises(np.TooHardError</span><span class="s0">, </span><span class="s1">np.shares_memory</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">max_work=</span><span class="s2">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_may_share_memory_bad_max_work():</span>
    <span class="s1">x = np.zeros([</span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">np.may_share_memory</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">max_work=</span><span class="s2">10</span><span class="s1">**</span><span class="s2">100</span><span class="s1">)</span>
    <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">np.shares_memory</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">max_work=</span><span class="s2">10</span><span class="s1">**</span><span class="s2">100</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_internal_overlap_diophantine():</span>
    <span class="s0">def </span><span class="s1">check(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">exists=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">X = solve_diophantine(A</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">require_ub_nontrivial=</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">exists </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">exists = (X </span><span class="s0">is not None</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">X </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">assert_(sum(a*x </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">zip(A</span><span class="s0">, </span><span class="s1">X)) == sum(a*u//</span><span class="s2">2 </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">u </span><span class="s0">in </span><span class="s1">zip(A</span><span class="s0">, </span><span class="s1">U)))</span>
            <span class="s1">assert_(all(</span><span class="s2">0 </span><span class="s1">&lt;= x &lt;= u </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">u </span><span class="s0">in </span><span class="s1">zip(X</span><span class="s0">, </span><span class="s1">U)))</span>
            <span class="s1">assert_(any(x != u//</span><span class="s2">2 </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">u </span><span class="s0">in </span><span class="s1">zip(X</span><span class="s0">, </span><span class="s1">U)))</span>

        <span class="s0">if </span><span class="s1">exists:</span>
            <span class="s1">assert_(X </span><span class="s0">is not None, </span><span class="s1">repr(X))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_(X </span><span class="s0">is None, </span><span class="s1">repr(X))</span>

    <span class="s4"># Smoke tests</span>
    <span class="s1">check((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s1">*</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">*</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exists=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">check((</span><span class="s2">3</span><span class="s1">*</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">15</span><span class="s1">*</span><span class="s2">2</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s1">-</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exists=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_internal_overlap_slices():</span>
    <span class="s4"># Slicing an array never generates internal overlap</span>

    <span class="s1">x = np.zeros([</span><span class="s2">17</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">97</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>

    <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">random_slice(n</span><span class="s0">, </span><span class="s1">step):</span>
        <span class="s1">start = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">stop = rng.randint(start</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.intp) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">stop</span><span class="s0">, </span><span class="s1">start = start</span><span class="s0">, </span><span class="s1">stop</span>
            <span class="s1">step *= -</span><span class="s2">1</span>
        <span class="s0">return </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>

    <span class="s1">cases = </span><span class="s2">0</span>
    <span class="s1">min_count = </span><span class="s2">5000</span>

    <span class="s0">while </span><span class="s1">cases &lt; min_count:</span>
        <span class="s1">steps = tuple(rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                      <span class="s0">if </span><span class="s1">rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.intp) == </span><span class="s2">0 </span><span class="s0">else </span><span class="s2">1</span>
                      <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(x.ndim))</span>
        <span class="s1">t1 = np.arange(x.ndim)</span>
        <span class="s1">rng.shuffle(t1)</span>
        <span class="s1">s1 = tuple(random_slice(p</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">zip(x.shape</span><span class="s0">, </span><span class="s1">steps))</span>
        <span class="s1">a = x[s1].transpose(t1)</span>

        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">internal_overlap(a))</span>
        <span class="s1">cases += </span><span class="s2">1</span>


<span class="s0">def </span><span class="s1">check_internal_overlap(a</span><span class="s0">, </span><span class="s1">manual_expected=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">got = internal_overlap(a)</span>

    <span class="s4"># Brute-force check</span>
    <span class="s1">m = set()</span>
    <span class="s1">ranges = tuple(range(n) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">a.shape)</span>
    <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">itertools.product(*ranges):</span>
        <span class="s1">offset = sum(s*w </span><span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">w </span><span class="s0">in </span><span class="s1">zip(a.strides</span><span class="s0">, </span><span class="s1">v))</span>
        <span class="s0">if </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">m:</span>
            <span class="s1">expected = </span><span class="s0">True</span>
            <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">m.add(offset)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">expected = </span><span class="s0">False</span>

    <span class="s4"># Compare</span>
    <span class="s0">if </span><span class="s1">got != expected:</span>
        <span class="s1">assert_equal(got</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">err_msg=repr((a.strides</span><span class="s0">, </span><span class="s1">a.shape)))</span>
    <span class="s0">if </span><span class="s1">manual_expected </span><span class="s0">is not None and </span><span class="s1">expected != manual_expected:</span>
        <span class="s1">assert_equal(expected</span><span class="s0">, </span><span class="s1">manual_expected)</span>
    <span class="s0">return </span><span class="s1">got</span>


<span class="s0">def </span><span class="s1">test_internal_overlap_manual():</span>
    <span class="s4"># Stride tricks can construct arrays with internal overlap</span>

    <span class="s4"># We don't care about memory bounds, the array is not</span>
    <span class="s4"># read/write accessed</span>
    <span class="s1">x = np.arange(</span><span class="s2">1</span><span class="s1">).astype(np.int8)</span>

    <span class="s4"># Check low-dimensional special cases</span>

    <span class="s1">check_internal_overlap(x</span><span class="s0">, False</span><span class="s1">) </span><span class="s4"># 1-dim</span>
    <span class="s1">check_internal_overlap(x.reshape([])</span><span class="s0">, False</span><span class="s1">) </span><span class="s4"># 0-dim</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">9993</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">87</span><span class="s0">, </span><span class="s2">22</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">9993</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">22</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">9993</span><span class="s1">)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">22</span><span class="s1">))</span>
    <span class="s1">check_internal_overlap(a</span><span class="s0">, False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_internal_overlap_fuzz():</span>
    <span class="s4"># Fuzz check; the brute-force check is fairly slow</span>

    <span class="s1">x = np.arange(</span><span class="s2">1</span><span class="s1">).astype(np.int8)</span>

    <span class="s1">overlap = </span><span class="s2">0</span>
    <span class="s1">no_overlap = </span><span class="s2">0</span>
    <span class="s1">min_count = </span><span class="s2">100</span>

    <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>

    <span class="s0">while </span><span class="s1">min(overlap</span><span class="s0">, </span><span class="s1">no_overlap) &lt; min_count:</span>
        <span class="s1">ndim = rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s1">strides = tuple(rng.randint(-</span><span class="s2">1000</span><span class="s0">, </span><span class="s2">1000</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ndim))</span>
        <span class="s1">shape = tuple(rng.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                      <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ndim))</span>

        <span class="s1">a = as_strided(x</span><span class="s0">, </span><span class="s1">strides=strides</span><span class="s0">, </span><span class="s1">shape=shape)</span>
        <span class="s1">result = check_internal_overlap(a)</span>

        <span class="s0">if </span><span class="s1">result:</span>
            <span class="s1">overlap += </span><span class="s2">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">no_overlap += </span><span class="s2">1</span>


<span class="s0">def </span><span class="s1">test_non_ndarray_inputs():</span>
    <span class="s4"># Regression check for gh-5604</span>

    <span class="s0">class </span><span class="s1">MyArray:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">data):</span>
            <span class="s1">self.data = data</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">__array_interface__(self):</span>
            <span class="s0">return </span><span class="s1">self.data.__array_interface__</span>

    <span class="s0">class </span><span class="s1">MyArray2:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">data):</span>
            <span class="s1">self.data = data</span>

        <span class="s0">def </span><span class="s1">__array__(self):</span>
            <span class="s0">return </span><span class="s1">self.data</span>

    <span class="s0">for </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">[MyArray</span><span class="s0">, </span><span class="s1">MyArray2]:</span>
        <span class="s1">x = np.arange(</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">assert_(np.may_share_memory(cls(x[::</span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.shares_memory(cls(x[::</span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]))</span>

        <span class="s1">assert_(np.shares_memory(cls(x[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[::</span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_(np.may_share_memory(cls(x[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[::</span><span class="s2">2</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">view_element_first_byte(x):</span>
    <span class="s3">&quot;&quot;&quot;Construct an array viewing the first byte of each element of `x`&quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy.lib.stride_tricks </span><span class="s0">import </span><span class="s1">DummyArray</span>
    <span class="s1">interface = dict(x.__array_interface__)</span>
    <span class="s1">interface[</span><span class="s5">'typestr'</span><span class="s1">] = </span><span class="s5">'|b1'</span>
    <span class="s1">interface[</span><span class="s5">'descr'</span><span class="s1">] = [(</span><span class="s5">''</span><span class="s0">, </span><span class="s5">'|b1'</span><span class="s1">)]</span>
    <span class="s0">return </span><span class="s1">np.asarray(DummyArray(interface</span><span class="s0">, </span><span class="s1">x))</span>


<span class="s0">def </span><span class="s1">assert_copy_equivalent(operation</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">out</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s3">&quot;&quot;&quot; 
    Check that operation(*args, out=out) produces results 
    equivalent to out[...] = operation(*args, out=out.copy()) 
    &quot;&quot;&quot;</span>

    <span class="s1">kwargs[</span><span class="s5">'out'</span><span class="s1">] = out</span>
    <span class="s1">kwargs2 = dict(kwargs)</span>
    <span class="s1">kwargs2[</span><span class="s5">'out'</span><span class="s1">] = out.copy()</span>

    <span class="s1">out_orig = out.copy()</span>
    <span class="s1">out[...] = operation(*args</span><span class="s0">, </span><span class="s1">**kwargs2)</span>
    <span class="s1">expected = out.copy()</span>
    <span class="s1">out[...] = out_orig</span>

    <span class="s1">got = operation(*args</span><span class="s0">, </span><span class="s1">**kwargs).copy()</span>

    <span class="s0">if </span><span class="s1">(got != expected).any():</span>
        <span class="s1">assert_equal(got</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestUFunc:</span>
    <span class="s3">&quot;&quot;&quot; 
    Test ufunc call memory overlap handling 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">check_unary_fuzz(self</span><span class="s0">, </span><span class="s1">operation</span><span class="s0">, </span><span class="s1">get_out_axis_size</span><span class="s0">, </span><span class="s1">dtype=np.int16</span><span class="s0">,</span>
                             <span class="s1">count=</span><span class="s2">5000</span><span class="s1">):</span>
        <span class="s1">shapes = [</span><span class="s2">7</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">29</span><span class="s0">, </span><span class="s2">32</span><span class="s1">]</span>

        <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">):</span>
            <span class="s1">x = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">**</span><span class="s2">16</span><span class="s0">, </span><span class="s1">size=shapes[:ndim]).astype(dtype)</span>

            <span class="s1">it = iter_random_view_pairs(x</span><span class="s0">, </span><span class="s1">same_steps=</span><span class="s0">False, </span><span class="s1">equal_size=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">min_count = count // (ndim + </span><span class="s2">1</span><span class="s1">)**</span><span class="s2">2</span>

            <span class="s1">overlapping = </span><span class="s2">0</span>
            <span class="s0">while </span><span class="s1">overlapping &lt; min_count:</span>
                <span class="s1">a</span><span class="s0">, </span><span class="s1">b = next(it)</span>

                <span class="s1">a_orig = a.copy()</span>
                <span class="s1">b_orig = b.copy()</span>

                <span class="s0">if </span><span class="s1">get_out_axis_size </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">assert_copy_equivalent(operation</span><span class="s0">, </span><span class="s1">[a]</span><span class="s0">, </span><span class="s1">out=b)</span>

                    <span class="s0">if </span><span class="s1">np.shares_memory(a</span><span class="s0">, </span><span class="s1">b):</span>
                        <span class="s1">overlapping += </span><span class="s2">1</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">itertools.chain(range(ndim)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]):</span>
                        <span class="s1">a[...] = a_orig</span>
                        <span class="s1">b[...] = b_orig</span>

                        <span class="s4"># Determine size for reduction axis (None if scalar)</span>
                        <span class="s1">outsize</span><span class="s0">, </span><span class="s1">scalarize = get_out_axis_size(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis)</span>
                        <span class="s0">if </span><span class="s1">outsize == </span><span class="s5">'skip'</span><span class="s1">:</span>
                            <span class="s0">continue</span>

                        <span class="s4"># Slice b to get an output array of the correct size</span>
                        <span class="s1">sl = [slice(</span><span class="s0">None</span><span class="s1">)] * ndim</span>
                        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
                            <span class="s0">if </span><span class="s1">outsize </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s1">sl = [slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)] + [</span><span class="s2">0</span><span class="s1">]*(ndim - </span><span class="s2">1</span><span class="s1">)</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">sl = [slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">outsize)] + [</span><span class="s2">0</span><span class="s1">]*(ndim - </span><span class="s2">1</span><span class="s1">)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s0">if </span><span class="s1">outsize </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s1">k = b.shape[axis]//</span><span class="s2">2</span>
                                <span class="s0">if </span><span class="s1">ndim == </span><span class="s2">1</span><span class="s1">:</span>
                                    <span class="s1">sl[axis] = slice(k</span><span class="s0">, </span><span class="s1">k + </span><span class="s2">1</span><span class="s1">)</span>
                                <span class="s0">else</span><span class="s1">:</span>
                                    <span class="s1">sl[axis] = k</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s0">assert </span><span class="s1">b.shape[axis] &gt;= outsize</span>
                                <span class="s1">sl[axis] = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">outsize)</span>
                        <span class="s1">b_out = b[tuple(sl)]</span>

                        <span class="s0">if </span><span class="s1">scalarize:</span>
                            <span class="s1">b_out = b_out.reshape([])</span>

                        <span class="s0">if </span><span class="s1">np.shares_memory(a</span><span class="s0">, </span><span class="s1">b_out):</span>
                            <span class="s1">overlapping += </span><span class="s2">1</span>

                        <span class="s4"># Check result</span>
                        <span class="s1">assert_copy_equivalent(operation</span><span class="s0">, </span><span class="s1">[a]</span><span class="s0">, </span><span class="s1">out=b_out</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_unary_ufunc_call_fuzz(self):</span>
        <span class="s1">self.check_unary_fuzz(np.invert</span><span class="s0">, None, </span><span class="s1">np.int16)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_unary_ufunc_call_complex_fuzz(self):</span>
        <span class="s4"># Complex typically has a smaller alignment than itemsize</span>
        <span class="s1">self.check_unary_fuzz(np.negative</span><span class="s0">, None, </span><span class="s1">np.complex128</span><span class="s0">, </span><span class="s1">count=</span><span class="s2">500</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_binary_ufunc_accumulate_fuzz(self):</span>
        <span class="s0">def </span><span class="s1">get_out_axis_size(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis):</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">a.ndim == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">a.size</span><span class="s0">, False</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s5">'skip'</span><span class="s0">, False  </span><span class="s4"># accumulate doesn't support this</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">a.shape[axis]</span><span class="s0">, False</span>

        <span class="s1">self.check_unary_fuzz(np.add.accumulate</span><span class="s0">, </span><span class="s1">get_out_axis_size</span><span class="s0">,</span>
                              <span class="s1">dtype=np.int16</span><span class="s0">, </span><span class="s1">count=</span><span class="s2">500</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_binary_ufunc_reduce_fuzz(self):</span>
        <span class="s0">def </span><span class="s1">get_out_axis_size(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis):</span>
            <span class="s0">return None, </span><span class="s1">(axis </span><span class="s0">is None or </span><span class="s1">a.ndim == </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">self.check_unary_fuzz(np.add.reduce</span><span class="s0">, </span><span class="s1">get_out_axis_size</span><span class="s0">,</span>
                              <span class="s1">dtype=np.int16</span><span class="s0">, </span><span class="s1">count=</span><span class="s2">500</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_binary_ufunc_reduceat_fuzz(self):</span>
        <span class="s0">def </span><span class="s1">get_out_axis_size(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis):</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">a.ndim == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">a.size</span><span class="s0">, False</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s5">'skip'</span><span class="s0">, False  </span><span class="s4"># reduceat doesn't support this</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">a.shape[axis]</span><span class="s0">, False</span>

        <span class="s0">def </span><span class="s1">do_reduceat(a</span><span class="s0">, </span><span class="s1">out</span><span class="s0">, </span><span class="s1">axis):</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">size = len(a)</span>
                <span class="s1">step = size//len(out)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">size = a.shape[axis]</span>
                <span class="s1">step = a.shape[axis] // out.shape[axis]</span>
            <span class="s1">idx = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">step)</span>
            <span class="s0">return </span><span class="s1">np.add.reduceat(a</span><span class="s0">, </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">axis=axis)</span>

        <span class="s1">self.check_unary_fuzz(do_reduceat</span><span class="s0">, </span><span class="s1">get_out_axis_size</span><span class="s0">,</span>
                              <span class="s1">dtype=np.int16</span><span class="s0">, </span><span class="s1">count=</span><span class="s2">500</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_binary_ufunc_reduceat_manual(self):</span>
        <span class="s0">def </span><span class="s1">check(ufunc</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">out):</span>
            <span class="s1">c1 = ufunc.reduceat(a.copy()</span><span class="s0">, </span><span class="s1">ind.copy()</span><span class="s0">, </span><span class="s1">out=out.copy())</span>
            <span class="s1">c2 = ufunc.reduceat(a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">out=out)</span>
            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c2)</span>

        <span class="s4"># Exactly same input/output arrays</span>
        <span class="s1">a = np.arange(</span><span class="s2">10000</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">check(np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a[::-</span><span class="s2">1</span><span class="s1">].copy()</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s4"># Overlap with index</span>
        <span class="s1">a = np.arange(</span><span class="s2">10000</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">check(np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a[::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_unary_gufunc_fuzz(self):</span>
        <span class="s1">shapes = [</span><span class="s2">7</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">29</span><span class="s0">, </span><span class="s2">32</span><span class="s1">]</span>
        <span class="s1">gufunc = _umath_tests.euclidean_pdist</span>

        <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">):</span>
            <span class="s1">x = rng.rand(*shapes[:ndim])</span>

            <span class="s1">it = iter_random_view_pairs(x</span><span class="s0">, </span><span class="s1">same_steps=</span><span class="s0">False, </span><span class="s1">equal_size=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">min_count = </span><span class="s2">500 </span><span class="s1">// (ndim + </span><span class="s2">1</span><span class="s1">)**</span><span class="s2">2</span>

            <span class="s1">overlapping = </span><span class="s2">0</span>
            <span class="s0">while </span><span class="s1">overlapping &lt; min_count:</span>
                <span class="s1">a</span><span class="s0">, </span><span class="s1">b = next(it)</span>

                <span class="s0">if </span><span class="s1">min(a.shape[-</span><span class="s2">2</span><span class="s1">:]) &lt; </span><span class="s2">2 </span><span class="s0">or </span><span class="s1">min(b.shape[-</span><span class="s2">2</span><span class="s1">:]) &lt; </span><span class="s2">2 </span><span class="s0">or </span><span class="s1">a.shape[-</span><span class="s2">1</span><span class="s1">] &lt; </span><span class="s2">2</span><span class="s1">:</span>
                    <span class="s0">continue</span>

                <span class="s4"># Ensure the shapes are so that euclidean_pdist is happy</span>
                <span class="s0">if </span><span class="s1">b.shape[-</span><span class="s2">1</span><span class="s1">] &gt; b.shape[-</span><span class="s2">2</span><span class="s1">]:</span>
                    <span class="s1">b = b[...</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s1">:]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">b = b[...</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span>

                <span class="s1">n = a.shape[-</span><span class="s2">2</span><span class="s1">]</span>
                <span class="s1">p = n * (n - </span><span class="s2">1</span><span class="s1">) // </span><span class="s2">2</span>
                <span class="s0">if </span><span class="s1">p &lt;= b.shape[-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">and </span><span class="s1">p &gt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">b = b[...</span><span class="s0">,</span><span class="s1">:p]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">n = max(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">int(np.sqrt(b.shape[-</span><span class="s2">1</span><span class="s1">]))//</span><span class="s2">2</span><span class="s1">)</span>
                    <span class="s1">p = n * (n - </span><span class="s2">1</span><span class="s1">) // </span><span class="s2">2</span>
                    <span class="s1">a = a[...</span><span class="s0">,</span><span class="s1">:n</span><span class="s0">,</span><span class="s1">:]</span>
                    <span class="s1">b = b[...</span><span class="s0">,</span><span class="s1">:p]</span>

                <span class="s4"># Call</span>
                <span class="s0">if </span><span class="s1">np.shares_memory(a</span><span class="s0">, </span><span class="s1">b):</span>
                    <span class="s1">overlapping += </span><span class="s2">1</span>

                <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s5">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
                    <span class="s1">assert_copy_equivalent(gufunc</span><span class="s0">, </span><span class="s1">[a]</span><span class="s0">, </span><span class="s1">out=b)</span>

    <span class="s0">def </span><span class="s1">test_ufunc_at_manual(self):</span>
        <span class="s0">def </span><span class="s1">check(ufunc</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">b=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">a0 = a.copy()</span>
            <span class="s0">if </span><span class="s1">b </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">ufunc.at(a0</span><span class="s0">, </span><span class="s1">ind.copy())</span>
                <span class="s1">c1 = a0.copy()</span>
                <span class="s1">ufunc.at(a</span><span class="s0">, </span><span class="s1">ind)</span>
                <span class="s1">c2 = a.copy()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ufunc.at(a0</span><span class="s0">, </span><span class="s1">ind.copy()</span><span class="s0">, </span><span class="s1">b.copy())</span>
                <span class="s1">c1 = a0.copy()</span>
                <span class="s1">ufunc.at(a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">b)</span>
                <span class="s1">c2 = a.copy()</span>
            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c2)</span>

        <span class="s4"># Overlap with index</span>
        <span class="s1">a = np.arange(</span><span class="s2">10000</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">check(np.invert</span><span class="s0">, </span><span class="s1">a[::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s4"># Overlap with second data array</span>
        <span class="s1">a = np.arange(</span><span class="s2">100</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">ind = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">check(np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">25</span><span class="s1">:</span><span class="s2">75</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_unary_ufunc_1d_manual(self):</span>
        <span class="s4"># Exercise ufunc fast-paths (that avoid creation of an `np.nditer`)</span>

        <span class="s0">def </span><span class="s1">check(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s1">a_orig = a.copy()</span>
            <span class="s1">b_orig = b.copy()</span>

            <span class="s1">b0 = b.copy()</span>
            <span class="s1">c1 = ufunc(a</span><span class="s0">, </span><span class="s1">out=b0)</span>
            <span class="s1">c2 = ufunc(a</span><span class="s0">, </span><span class="s1">out=b)</span>
            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c2)</span>

            <span class="s4"># Trigger &quot;fancy ufunc loop&quot; code path</span>
            <span class="s1">mask = view_element_first_byte(b).view(np.bool_)</span>

            <span class="s1">a[...] = a_orig</span>
            <span class="s1">b[...] = b_orig</span>
            <span class="s1">c1 = ufunc(a</span><span class="s0">, </span><span class="s1">out=b.copy()</span><span class="s0">, </span><span class="s1">where=mask.copy()).copy()</span>

            <span class="s1">a[...] = a_orig</span>
            <span class="s1">b[...] = b_orig</span>
            <span class="s1">c2 = ufunc(a</span><span class="s0">, </span><span class="s1">out=b</span><span class="s0">, </span><span class="s1">where=mask.copy()).copy()</span>

            <span class="s4"># Also, mask overlapping with output</span>
            <span class="s1">a[...] = a_orig</span>
            <span class="s1">b[...] = b_orig</span>
            <span class="s1">c3 = ufunc(a</span><span class="s0">, </span><span class="s1">out=b</span><span class="s0">, </span><span class="s1">where=mask).copy()</span>

            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c2)</span>
            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c3)</span>

        <span class="s1">dtypes = [np.int8</span><span class="s0">, </span><span class="s1">np.int16</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">np.int64</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">,</span>
                  <span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]</span>
        <span class="s1">dtypes = [np.dtype(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dtypes]</span>

        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">dtypes:</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.integer):</span>
                <span class="s1">ufunc = np.invert</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ufunc = np.reciprocal</span>

            <span class="s1">n = </span><span class="s2">1000</span>
            <span class="s1">k = </span><span class="s2">10</span>
            <span class="s1">indices = [</span>
                <span class="s1">np.index_exp[:n]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[k:k+n]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[n-</span><span class="s2">1</span><span class="s1">::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[k+n-</span><span class="s2">1</span><span class="s1">:k-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[:</span><span class="s2">2</span><span class="s1">*n:</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[k:k+</span><span class="s2">2</span><span class="s1">*n:</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[</span><span class="s2">2</span><span class="s1">*n-</span><span class="s2">1</span><span class="s1">::-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">np.index_exp[k+</span><span class="s2">2</span><span class="s1">*n-</span><span class="s2">1</span><span class="s1">:k-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span>

            <span class="s0">for </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi </span><span class="s0">in </span><span class="s1">itertools.product(indices</span><span class="s0">, </span><span class="s1">indices):</span>
                <span class="s1">v = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ n*</span><span class="s2">2 </span><span class="s1">+ k</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
                <span class="s1">x = v[xi]</span>
                <span class="s1">y = v[yi]</span>

                <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s5">'ignore'</span><span class="s1">):</span>
                    <span class="s1">check(x</span><span class="s0">, </span><span class="s1">y)</span>

                    <span class="s4"># Scalar cases</span>
                    <span class="s1">check(x[:</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y)</span>
                    <span class="s1">check(x[-</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">y)</span>
                    <span class="s1">check(x[:</span><span class="s2">1</span><span class="s1">].reshape([])</span><span class="s0">, </span><span class="s1">y)</span>
                    <span class="s1">check(x[-</span><span class="s2">1</span><span class="s1">:].reshape([])</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_unary_ufunc_where_same(self):</span>
        <span class="s4"># Check behavior at wheremask overlap</span>
        <span class="s1">ufunc = np.invert</span>

        <span class="s0">def </span><span class="s1">check(a</span><span class="s0">, </span><span class="s1">out</span><span class="s0">, </span><span class="s1">mask):</span>
            <span class="s1">c1 = ufunc(a</span><span class="s0">, </span><span class="s1">out=out.copy()</span><span class="s0">, </span><span class="s1">where=mask.copy())</span>
            <span class="s1">c2 = ufunc(a</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">where=mask)</span>
            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c2)</span>

        <span class="s4"># Check behavior with same input and output arrays</span>
        <span class="s1">x = np.arange(</span><span class="s2">100</span><span class="s1">).astype(np.bool_)</span>
        <span class="s1">check(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">check(x</span><span class="s0">, </span><span class="s1">x.copy()</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">check(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x.copy())</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_binary_ufunc_1d_manual(self):</span>
        <span class="s1">ufunc = np.add</span>

        <span class="s0">def </span><span class="s1">check(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c):</span>
            <span class="s1">c0 = c.copy()</span>
            <span class="s1">c1 = ufunc(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c0)</span>
            <span class="s1">c2 = ufunc(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c)</span>
            <span class="s1">assert_array_equal(c1</span><span class="s0">, </span><span class="s1">c2)</span>

        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[np.int8</span><span class="s0">, </span><span class="s1">np.int16</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">np.int64</span><span class="s0">,</span>
                      <span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
            <span class="s4"># Check different data dependency orders</span>

            <span class="s1">n = </span><span class="s2">1000</span>
            <span class="s1">k = </span><span class="s2">10</span>

            <span class="s1">indices = []</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]:</span>
                <span class="s1">indices.extend([</span>
                    <span class="s1">np.index_exp[:p*n:p]</span><span class="s0">,</span>
                    <span class="s1">np.index_exp[k:k+p*n:p]</span><span class="s0">,</span>
                    <span class="s1">np.index_exp[p*n-</span><span class="s2">1</span><span class="s1">::-p]</span><span class="s0">,</span>
                    <span class="s1">np.index_exp[k+p*n-</span><span class="s2">1</span><span class="s1">:k-</span><span class="s2">1</span><span class="s1">:-p]</span><span class="s0">,</span>
                <span class="s1">])</span>

            <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z </span><span class="s0">in </span><span class="s1">itertools.product(indices</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">indices):</span>
                <span class="s1">v = np.arange(</span><span class="s2">6</span><span class="s1">*n).astype(dtype)</span>
                <span class="s1">x = v[x]</span>
                <span class="s1">y = v[y]</span>
                <span class="s1">z = v[z]</span>

                <span class="s1">check(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>

                <span class="s4"># Scalar cases</span>
                <span class="s1">check(x[:</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x[-</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x[:</span><span class="s2">1</span><span class="s1">].reshape([])</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x[-</span><span class="s2">1</span><span class="s1">:].reshape([])</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x</span><span class="s0">, </span><span class="s1">y[:</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x</span><span class="s0">, </span><span class="s1">y[-</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x</span><span class="s0">, </span><span class="s1">y[:</span><span class="s2">1</span><span class="s1">].reshape([])</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">check(x</span><span class="s0">, </span><span class="s1">y[-</span><span class="s2">1</span><span class="s1">:].reshape([])</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s0">def </span><span class="s1">test_inplace_op_simple_manual(self):</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s2">1234</span><span class="s1">)</span>
        <span class="s1">x = rng.rand(</span><span class="s2">200</span><span class="s0">, </span><span class="s2">200</span><span class="s1">)  </span><span class="s4"># bigger than bufsize</span>

        <span class="s1">x += x.T</span>
        <span class="s1">assert_array_equal(x - x.T</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
</pre>
</body>
</html>