<html>
<head>
<title>browser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
browser.py</font>
</center></td></tr></table>
<pre><span class="s0"># pylint: disable=missing-docstring</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">percy</span>

<span class="s2">from </span><span class="s1">selenium </span><span class="s2">import </span><span class="s1">webdriver</span>
<span class="s2">from </span><span class="s1">selenium.webdriver.support </span><span class="s2">import </span><span class="s1">expected_conditions </span><span class="s2">as </span><span class="s1">EC</span>
<span class="s2">from </span><span class="s1">selenium.webdriver.common.by </span><span class="s2">import </span><span class="s1">By</span>
<span class="s2">from </span><span class="s1">selenium.webdriver.support.wait </span><span class="s2">import </span><span class="s1">WebDriverWait</span>
<span class="s2">from </span><span class="s1">selenium.webdriver.common.keys </span><span class="s2">import </span><span class="s1">Keys</span>
<span class="s2">from </span><span class="s1">selenium.webdriver.common.desired_capabilities </span><span class="s2">import </span><span class="s1">DesiredCapabilities</span>
<span class="s2">from </span><span class="s1">selenium.webdriver.common.action_chains </span><span class="s2">import </span><span class="s1">ActionChains</span>

<span class="s2">from </span><span class="s1">selenium.common.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">WebDriverException</span><span class="s2">,</span>
    <span class="s1">TimeoutException</span><span class="s2">,</span>
    <span class="s1">MoveTargetOutOfBoundsException</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">webdriver_manager.chrome </span><span class="s2">import </span><span class="s1">ChromeDriverManager</span>
<span class="s2">from </span><span class="s1">webdriver_manager.utils </span><span class="s2">import </span><span class="s1">ChromeType</span>
<span class="s2">from </span><span class="s1">webdriver_manager.firefox </span><span class="s2">import </span><span class="s1">GeckoDriverManager</span>

<span class="s2">from </span><span class="s1">dash.testing.wait </span><span class="s2">import </span><span class="s1">text_to_equal</span><span class="s2">, </span><span class="s1">style_to_equal</span><span class="s2">, </span><span class="s1">contains_text</span><span class="s2">, </span><span class="s1">until</span>
<span class="s2">from </span><span class="s1">dash.testing.dash_page </span><span class="s2">import </span><span class="s1">DashPageMixin</span>
<span class="s2">from </span><span class="s1">dash.testing.errors </span><span class="s2">import </span><span class="s1">DashAppLoadingError</span><span class="s2">, </span><span class="s1">BrowserError</span><span class="s2">, </span><span class="s1">TestingTimeoutError</span>
<span class="s2">from </span><span class="s1">dash.testing.consts </span><span class="s2">import </span><span class="s1">SELENIUM_GRID_DEFAULT</span>


<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">class </span><span class="s1">Browser(DashPageMixin):</span>
    <span class="s0"># pylint: disable=too-many-arguments</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">browser</span><span class="s2">,</span>
        <span class="s1">remote=</span><span class="s2">False,</span>
        <span class="s1">remote_url=</span><span class="s2">None,</span>
        <span class="s1">headless=</span><span class="s2">False,</span>
        <span class="s1">options=</span><span class="s2">None,</span>
        <span class="s1">download_path=</span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">percy_run=</span><span class="s2">True,</span>
        <span class="s1">percy_finalize=</span><span class="s2">True,</span>
        <span class="s1">percy_assets_root=</span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">wait_timeout=</span><span class="s4">10</span><span class="s2">,</span>
        <span class="s1">pause=</span><span class="s2">False,</span>
    <span class="s1">):</span>
        <span class="s1">self._browser = browser.lower()</span>
        <span class="s1">self._remote_url = remote_url</span>
        <span class="s1">self._remote = (</span>
            <span class="s2">True if </span><span class="s1">remote_url </span><span class="s2">and </span><span class="s1">remote_url != SELENIUM_GRID_DEFAULT </span><span class="s2">else </span><span class="s1">remote</span>
        <span class="s1">)</span>
        <span class="s1">self._headless = headless</span>
        <span class="s1">self._options = options</span>
        <span class="s1">self._download_path = download_path</span>
        <span class="s1">self._wait_timeout = wait_timeout</span>
        <span class="s1">self._percy_finalize = percy_finalize</span>
        <span class="s1">self._percy_run = percy_run</span>
        <span class="s1">self._pause = pause</span>

        <span class="s1">self._driver = until(self.get_webdriver</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self._driver.implicitly_wait(</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">self._wd_wait = WebDriverWait(self.driver</span><span class="s2">, </span><span class="s1">wait_timeout)</span>
        <span class="s1">self._last_ts = </span><span class="s4">0</span>
        <span class="s1">self._url = </span><span class="s2">None</span>

        <span class="s1">self._window_idx = </span><span class="s4">0  </span><span class="s0"># switch browser tabs</span>

        <span class="s2">if </span><span class="s1">self._percy_run:</span>
            <span class="s1">self.percy_runner = percy.Runner(</span>
                <span class="s1">loader=percy.ResourceLoader(</span>
                    <span class="s1">webdriver=self.driver</span><span class="s2">,</span>
                    <span class="s1">base_url=</span><span class="s3">&quot;/assets&quot;</span><span class="s2">,</span>
                    <span class="s1">root_dir=percy_assets_root</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">self.percy_runner.initialize_build()</span>

        <span class="s1">logger.debug(</span><span class="s3">&quot;initialize browser with arguments&quot;</span><span class="s1">)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;  headless =&gt; %s&quot;</span><span class="s2">, </span><span class="s1">self._headless)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;  download_path =&gt; %s&quot;</span><span class="s2">, </span><span class="s1">self._download_path)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;  percy asset root =&gt; %s&quot;</span><span class="s2">, </span><span class="s1">os.path.abspath(percy_assets_root))</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">exc_type</span><span class="s2">, </span><span class="s1">exc_val</span><span class="s2">, </span><span class="s1">traceback):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.driver.quit()</span>
            <span class="s2">if </span><span class="s1">self._percy_run </span><span class="s2">and </span><span class="s1">self._percy_finalize:</span>
                <span class="s1">logger.info(</span><span class="s3">&quot;percy runner finalize build now&quot;</span><span class="s1">)</span>
                <span class="s1">self.percy_runner.finalize_build()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">logger.info(</span><span class="s3">&quot;percy finalize relies on CI job&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">WebDriverException:</span>
            <span class="s1">logger.exception(</span><span class="s3">&quot;webdriver quit was not successful&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">percy.errors.Error:</span>
            <span class="s1">logger.exception(</span><span class="s3">&quot;percy runner failed to finalize properly&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">visit_and_snapshot(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">resource_path</span><span class="s2">,</span>
        <span class="s1">hook_id</span><span class="s2">,</span>
        <span class="s1">wait_for_callbacks=</span><span class="s2">True,</span>
        <span class="s1">convert_canvases=</span><span class="s2">False,</span>
        <span class="s1">assert_check=</span><span class="s2">True,</span>
        <span class="s1">stay_on_page=</span><span class="s2">False,</span>
        <span class="s1">widths=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">path = resource_path.lstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">path != resource_path:</span>
                <span class="s1">logger.warning(</span><span class="s3">&quot;we stripped the left '/' in resource_path&quot;</span><span class="s1">)</span>
            <span class="s1">self.driver.get(</span><span class="s3">&quot;{}/{}&quot;</span><span class="s1">.format(self.server_url.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">path))</span>

            <span class="s0"># wait for the hook_id to present and all callbacks get fired</span>
            <span class="s1">self.wait_for_element_by_id(hook_id)</span>
            <span class="s1">self.percy_snapshot(</span>
                <span class="s1">path</span><span class="s2">,</span>
                <span class="s1">wait_for_callbacks=wait_for_callbacks</span><span class="s2">,</span>
                <span class="s1">convert_canvases=convert_canvases</span><span class="s2">,</span>
                <span class="s1">widths=widths</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">assert_check:</span>
                <span class="s2">assert not </span><span class="s1">self.driver.find_elements_by_css_selector(</span>
                    <span class="s3">&quot;div.dash-debug-alert&quot;</span>
                <span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;devtools should not raise an error alert&quot;</span>
            <span class="s2">if not </span><span class="s1">stay_on_page:</span>
                <span class="s1">self.driver.back()</span>
        <span class="s2">except </span><span class="s1">WebDriverException </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">logger.exception(</span><span class="s3">&quot;snapshot at resource %s error&quot;</span><span class="s2">, </span><span class="s1">path)</span>
            <span class="s2">raise </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">percy_snapshot(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">wait_for_callbacks=</span><span class="s2">False, </span><span class="s1">convert_canvases=</span><span class="s2">False, </span><span class="s1">widths=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;percy_snapshot - visual test api shortcut to `percy_runner.snapshot`. 
        It also combines the snapshot `name` with the Python version, 
        args: 
        - name: combined with the python version to give the final snapshot name 
        - wait_for_callbacks: default False, whether to wait for Dash callbacks, 
            after an extra second to ensure that any relevant callbacks have 
            been initiated 
        - convert_canvases: default False, whether to convert all canvas elements 
            in the DOM into static images for percy to see. They will be restored 
            after the snapshot is complete. 
        - widths: a list of pixel widths for percy to render the page with. Note 
            that this does not change the browser in which the DOM is constructed, 
            so the width will only affect CSS, not JS-driven layout. 
            Defaults to [375, 1280] 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">widths </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">widths = [</span><span class="s4">375</span><span class="s2">, </span><span class="s4">1280</span><span class="s1">]</span>
        <span class="s1">snapshot_name = </span><span class="s3">&quot;{} - py{}.{}&quot;</span><span class="s1">.format(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">sys.version_info.major</span><span class="s2">, </span><span class="s1">sys.version_info.minor</span>
        <span class="s1">)</span>
        <span class="s1">logger.info(</span><span class="s3">&quot;taking snapshot name =&gt; %s&quot;</span><span class="s2">, </span><span class="s1">snapshot_name)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">wait_for_callbacks:</span>
                <span class="s0"># the extra one second sleep adds safe margin in the context</span>
                <span class="s0"># of wait_for_callbacks</span>
                <span class="s1">time.sleep(</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">until(self._wait_for_callbacks</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s4">40</span><span class="s2">, </span><span class="s1">poll=</span><span class="s4">0.3</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">TestingTimeoutError:</span>
            <span class="s0"># API will log the error but this TimeoutError should not block</span>
            <span class="s0"># the test execution to continue and it will still do a snapshot</span>
            <span class="s0"># as diff reference for the build run.</span>
            <span class="s1">logger.error(</span>
                <span class="s3">&quot;wait_for_callbacks failed =&gt; status of invalid rqs %s&quot;</span><span class="s2">,</span>
                <span class="s1">self.redux_state_rqs</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">convert_canvases:</span>
            <span class="s1">self.driver.execute_script(</span>
                <span class="s3">&quot;&quot;&quot; 
                const stash = window._canvasStash = []; 
                Array.from(document.querySelectorAll('canvas')).forEach(c =&gt; { 
                    const i = document.createElement('img'); 
                    i.src = c.toDataURL(); 
                    i.width = c.width; 
                    i.height = c.height; 
                    i.setAttribute('style', c.getAttribute('style')); 
                    i.className = c.className; 
                    i.setAttribute('data-canvasnum', stash.length); 
                    stash.push(c); 
                    c.parentElement.insertBefore(i, c); 
                    c.parentElement.removeChild(c); 
                }); 
            &quot;&quot;&quot;</span>
            <span class="s1">)</span>

            <span class="s1">self.percy_runner.snapshot(name=snapshot_name</span><span class="s2">, </span><span class="s1">widths=widths)</span>

            <span class="s1">self.driver.execute_script(</span>
                <span class="s3">&quot;&quot;&quot; 
                const stash = window._canvasStash; 
                Array.from( 
                    document.querySelectorAll('img[data-canvasnum]') 
                ).forEach(i =&gt; { 
                    const c = stash[+i.getAttribute('data-canvasnum')]; 
                    i.parentElement.insertBefore(c, i); 
                    i.parentElement.removeChild(i); 
                }); 
                delete window._canvasStash; 
            &quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.percy_runner.snapshot(name=snapshot_name</span><span class="s2">, </span><span class="s1">widths=widths)</span>

    <span class="s2">def </span><span class="s1">take_snapshot(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot;Hook method to take snapshot when a selenium test fails. The 
        snapshot is placed under. 
 
            - `/tmp/dash_artifacts` in linux 
            - `%TEMP` in windows 
        with a filename combining test case name and the 
        running selenium session id 
        &quot;&quot;&quot;</span>
        <span class="s1">target = </span><span class="s3">&quot;/tmp/dash_artifacts&quot; </span><span class="s2">if not </span><span class="s1">self._is_windows() </span><span class="s2">else </span><span class="s1">os.getenv(</span><span class="s3">&quot;TEMP&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(target):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">os.mkdir(target)</span>
            <span class="s2">except </span><span class="s1">OSError:</span>
                <span class="s1">logger.exception(</span><span class="s3">&quot;cannot make artifacts&quot;</span><span class="s1">)</span>

        <span class="s1">self.driver.save_screenshot(</span>
            <span class="s3">&quot;{}/{}_{}.png&quot;</span><span class="s1">.format(target</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self.session_id)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">find_element(self</span><span class="s2">, </span><span class="s1">selector):</span>
        <span class="s5">&quot;&quot;&quot;find_element returns the first found element by the css `selector` 
        shortcut to `driver.find_element_by_css_selector`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.driver.find_element_by_css_selector(selector)</span>

    <span class="s2">def </span><span class="s1">find_elements(self</span><span class="s2">, </span><span class="s1">selector):</span>
        <span class="s5">&quot;&quot;&quot;find_elements returns a list of all elements matching the css 
        `selector`. 
 
        shortcut to `driver.find_elements_by_css_selector`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.driver.find_elements_by_css_selector(selector)</span>

    <span class="s2">def </span><span class="s1">_get_element(self</span><span class="s2">, </span><span class="s1">elem_or_selector):</span>
        <span class="s2">if </span><span class="s1">isinstance(elem_or_selector</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">self.find_element(elem_or_selector)</span>
        <span class="s2">return </span><span class="s1">elem_or_selector</span>

    <span class="s2">def </span><span class="s1">_wait_for(self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">msg):</span>
        <span class="s5">&quot;&quot;&quot;Abstract generic pattern for explicit WebDriverWait.&quot;&quot;&quot;</span>
        <span class="s1">_wait = (</span>
            <span class="s1">self._wd_wait </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">is None else </span><span class="s1">WebDriverWait(self.driver</span><span class="s2">, </span><span class="s1">timeout)</span>
        <span class="s1">)</span>
        <span class="s1">logger.debug(</span>
            <span class="s3">&quot;method, timeout, poll =&gt; %s %s %s&quot;</span><span class="s2">,</span>
            <span class="s1">method</span><span class="s2">,</span>
            <span class="s1">_wait._timeout</span><span class="s2">,  </span><span class="s0"># pylint: disable=protected-access</span>
            <span class="s1">_wait._poll</span><span class="s2">,  </span><span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_wait.until(method(*args)</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">wait_for_element(self</span><span class="s2">, </span><span class="s1">selector</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;wait_for_element is shortcut to `wait_for_element_by_css_selector` 
        timeout if not set, equals to the fixture's `wait_timeout`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.wait_for_element_by_css_selector(selector</span><span class="s2">, </span><span class="s1">timeout)</span>

    <span class="s2">def </span><span class="s1">wait_for_element_by_css_selector(self</span><span class="s2">, </span><span class="s1">selector</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Explicit wait until the element is present, timeout if not set, 
        equals to the fixture's `wait_timeout` shortcut to `WebDriverWait` with 
        `EC.presence_of_element_located`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._wait_for(</span>
            <span class="s1">EC.presence_of_element_located</span><span class="s2">,</span>
            <span class="s1">((By.CSS_SELECTOR</span><span class="s2">, </span><span class="s1">selector)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">timeout</span><span class="s2">,</span>
            <span class="s3">&quot;timeout {}s =&gt; waiting for selector {}&quot;</span><span class="s1">.format(</span>
                <span class="s1">timeout </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">else </span><span class="s1">self._wait_timeout</span><span class="s2">, </span><span class="s1">selector</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">wait_for_no_elements(self</span><span class="s2">, </span><span class="s1">selector</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Explicit wait until an element is NOT found. timeout defaults to 
        the fixture's `wait_timeout`.&quot;&quot;&quot;</span>
        <span class="s1">until(</span>
            <span class="s0"># if we use get_elements it waits a long time to see if they appear</span>
            <span class="s0"># so this one calls out directly to execute_script</span>
            <span class="s2">lambda</span><span class="s1">: self.driver.execute_script(</span>
                <span class="s3">&quot;return document.querySelectorAll('{}').length&quot;</span><span class="s1">.format(selector)</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">timeout </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">else </span><span class="s1">self._wait_timeout</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">wait_for_element_by_id(self</span><span class="s2">, </span><span class="s1">element_id</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Explicit wait until the element is present, timeout if not set, 
        equals to the fixture's `wait_timeout` shortcut to `WebDriverWait` with 
        `EC.presence_of_element_located`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._wait_for(</span>
            <span class="s1">EC.presence_of_element_located</span><span class="s2">,</span>
            <span class="s1">((By.ID</span><span class="s2">, </span><span class="s1">element_id)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">timeout</span><span class="s2">,</span>
            <span class="s3">&quot;timeout {}s =&gt; waiting for element id {}&quot;</span><span class="s1">.format(</span>
                <span class="s1">timeout </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">else </span><span class="s1">self._wait_timeout</span><span class="s2">, </span><span class="s1">element_id</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">wait_for_style_to_equal(self</span><span class="s2">, </span><span class="s1">selector</span><span class="s2">, </span><span class="s1">style</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Explicit wait until the element's style has expected `value` timeout 
        if not set, equals to the fixture's `wait_timeout` shortcut to 
        `WebDriverWait` with customized `style_to_equal` condition.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._wait_for(</span>
            <span class="s1">method=style_to_equal</span><span class="s2">,</span>
            <span class="s1">args=(selector</span><span class="s2">, </span><span class="s1">style</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">,</span>
            <span class="s1">timeout=timeout</span><span class="s2">,</span>
            <span class="s1">msg=</span><span class="s3">&quot;style val =&gt; {} {} not found within {}s&quot;</span><span class="s1">.format(</span>
                <span class="s1">style</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">timeout </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">else </span><span class="s1">self._wait_timeout</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">wait_for_text_to_equal(self</span><span class="s2">, </span><span class="s1">selector</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Explicit wait until the element's text equals the expected `text`. 
 
        timeout if not set, equals to the fixture's `wait_timeout` 
        shortcut to `WebDriverWait` with customized `text_to_equal` 
        condition. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._wait_for(</span>
            <span class="s1">method=text_to_equal</span><span class="s2">,</span>
            <span class="s1">args=(selector</span><span class="s2">, </span><span class="s1">text)</span><span class="s2">,</span>
            <span class="s1">timeout=timeout</span><span class="s2">,</span>
            <span class="s1">msg=</span><span class="s3">&quot;text -&gt; {} not found within {}s&quot;</span><span class="s1">.format(</span>
                <span class="s1">text</span><span class="s2">, </span><span class="s1">timeout </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">else </span><span class="s1">self._wait_timeout</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">wait_for_contains_text(self</span><span class="s2">, </span><span class="s1">selector</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Explicit wait until the element's text contains the expected `text`. 
 
        timeout if not set, equals to the fixture's `wait_timeout` 
        shortcut to `WebDriverWait` with customized `contains_text` 
        condition. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._wait_for(</span>
            <span class="s1">method=contains_text</span><span class="s2">,</span>
            <span class="s1">args=(selector</span><span class="s2">, </span><span class="s1">text)</span><span class="s2">,</span>
            <span class="s1">timeout=timeout</span><span class="s2">,</span>
            <span class="s1">msg=</span><span class="s3">&quot;text -&gt; {} not found inside element within {}s&quot;</span><span class="s1">.format(</span>
                <span class="s1">text</span><span class="s2">, </span><span class="s1">timeout </span><span class="s2">if </span><span class="s1">timeout </span><span class="s2">else </span><span class="s1">self._wait_timeout</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">wait_for_page(self</span><span class="s2">, </span><span class="s1">url=</span><span class="s2">None, </span><span class="s1">timeout=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;wait_for_page navigates to the url in webdriver wait until the 
        renderer is loaded in browser. 
 
        use the `server_url` if url is not provided. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.driver.get(self.server_url </span><span class="s2">if </span><span class="s1">url </span><span class="s2">is None else </span><span class="s1">url)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.wait_for_element_by_css_selector(</span>
                <span class="s1">self.dash_entry_locator</span><span class="s2">, </span><span class="s1">timeout=timeout</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">TimeoutException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">logger.exception(</span><span class="s3">&quot;dash server is not loaded within %s seconds&quot;</span><span class="s2">, </span><span class="s1">timeout)</span>
            <span class="s1">logger.debug(self.get_logs())</span>
            <span class="s2">raise </span><span class="s1">DashAppLoadingError(</span>
                <span class="s3">&quot;the expected Dash react entry point cannot be loaded&quot;</span>
                <span class="s3">&quot; in browser</span><span class="s2">\n </span><span class="s3">HTML =&gt; {}</span><span class="s2">\n </span><span class="s3">Console Logs =&gt; {}</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.format(</span>
                    <span class="s1">self.driver.find_element_by_tag_name(</span><span class="s3">&quot;body&quot;</span><span class="s1">).get_property(</span>
                        <span class="s3">&quot;innerHTML&quot;</span>
                    <span class="s1">)</span><span class="s2">,</span>
                    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join((str(log) </span><span class="s2">for </span><span class="s1">log </span><span class="s2">in </span><span class="s1">self.get_logs()))</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>

        <span class="s2">if </span><span class="s1">self._pause:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">import </span><span class="s1">pdb </span><span class="s2">as </span><span class="s1">pdb_  </span><span class="s0"># pylint: disable=import-outside-toplevel</span>
            <span class="s2">except </span><span class="s1">ImportError:</span>
                <span class="s2">import </span><span class="s1">ipdb </span><span class="s2">as </span><span class="s1">pdb_  </span><span class="s0"># pylint: disable=import-outside-toplevel</span>

            <span class="s1">pdb_.set_trace()  </span><span class="s0"># pylint: disable=forgotten-debug-statement</span>

    <span class="s2">def </span><span class="s1">select_dcc_dropdown(self</span><span class="s2">, </span><span class="s1">elem_or_selector</span><span class="s2">, </span><span class="s1">value=</span><span class="s2">None, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">dropdown = self._get_element(elem_or_selector)</span>
        <span class="s1">dropdown.click()</span>

        <span class="s1">menu = dropdown.find_element_by_css_selector(</span><span class="s3">&quot;div.Select-menu-outer&quot;</span><span class="s1">)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;the available options are %s&quot;</span><span class="s2">, </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(menu.text.split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)))</span>

        <span class="s1">options = menu.find_elements_by_css_selector(</span><span class="s3">&quot;div.VirtualizedSelectOption&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">options:</span>
            <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s1">options[index].click()</span>
                <span class="s2">return</span>

            <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">options:</span>
                <span class="s2">if </span><span class="s1">option.text == value:</span>
                    <span class="s1">option.click()</span>
                    <span class="s2">return</span>

        <span class="s1">logger.error(</span>
            <span class="s3">&quot;cannot find matching option using value=%s or index=%s&quot;</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">index</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">toggle_window(self):</span>
        <span class="s5">&quot;&quot;&quot;Switch between the current working window and the new opened one.&quot;&quot;&quot;</span>
        <span class="s1">idx = (self._window_idx + </span><span class="s4">1</span><span class="s1">) % </span><span class="s4">2</span>
        <span class="s1">self.switch_window(idx=idx)</span>
        <span class="s1">self._window_idx += </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">switch_window(self</span><span class="s2">, </span><span class="s1">idx=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Switch to window by window index shortcut to 
        `driver.switch_to.window`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.driver.window_handles) &lt;= idx:</span>
            <span class="s2">raise </span><span class="s1">BrowserError(</span><span class="s3">&quot;there is no second window in Browser&quot;</span><span class="s1">)</span>

        <span class="s1">self.driver.switch_to.window(self.driver.window_handles[idx])</span>

    <span class="s2">def </span><span class="s1">open_new_tab(self</span><span class="s2">, </span><span class="s1">url=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Open a new tab in browser url is not set, equals to `server_url`.&quot;&quot;&quot;</span>
        <span class="s1">self.driver.execute_script(</span>
            <span class="s3">'window.open(&quot;{}&quot;, &quot;new window&quot;)'</span><span class="s1">.format(</span>
                <span class="s1">self.server_url </span><span class="s2">if </span><span class="s1">url </span><span class="s2">is None else </span><span class="s1">url</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_webdriver(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;_get_{}&quot;</span><span class="s1">.format(self._browser))()</span>
        <span class="s2">except </span><span class="s1">WebDriverException:</span>
            <span class="s1">logger.exception(</span><span class="s3">&quot;&lt;&lt;&lt;Webdriver not initialized correctly&gt;&gt;&gt;&quot;</span><span class="s1">)</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_wd_options(self):</span>
        <span class="s1">options = (</span>
            <span class="s1">self._options[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self._options </span><span class="s2">and </span><span class="s1">isinstance(self._options</span><span class="s2">, </span><span class="s1">list)</span>
            <span class="s2">else </span><span class="s1">getattr(webdriver</span><span class="s2">, </span><span class="s1">self._browser).options.Options()</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._headless:</span>
            <span class="s1">options.headless = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">options</span>

    <span class="s2">def </span><span class="s1">_get_chrome(self):</span>
        <span class="s1">options = self._get_wd_options()</span>

        <span class="s1">capabilities = DesiredCapabilities.CHROME</span>
        <span class="s1">capabilities[</span><span class="s3">&quot;loggingPrefs&quot;</span><span class="s1">] = {</span><span class="s3">&quot;browser&quot;</span><span class="s1">: </span><span class="s3">&quot;SEVERE&quot;</span><span class="s1">}</span>
        <span class="s1">capabilities[</span><span class="s3">&quot;goog:loggingPrefs&quot;</span><span class="s1">] = {</span><span class="s3">&quot;browser&quot;</span><span class="s1">: </span><span class="s3">&quot;SEVERE&quot;</span><span class="s1">}</span>

        <span class="s2">if </span><span class="s3">&quot;DASH_TEST_CHROMEPATH&quot; </span><span class="s2">in </span><span class="s1">os.environ:</span>
            <span class="s1">options.binary_location = os.environ[</span><span class="s3">&quot;DASH_TEST_CHROMEPATH&quot;</span><span class="s1">]</span>

        <span class="s1">options.add_experimental_option(</span>
            <span class="s3">&quot;prefs&quot;</span><span class="s2">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;download.default_directory&quot;</span><span class="s1">: self.download_path</span><span class="s2">,</span>
                <span class="s3">&quot;download.prompt_for_download&quot;</span><span class="s1">: </span><span class="s2">False,</span>
                <span class="s3">&quot;download.directory_upgrade&quot;</span><span class="s1">: </span><span class="s2">True,</span>
                <span class="s3">&quot;safebrowsing.enabled&quot;</span><span class="s1">: </span><span class="s2">False,</span>
                <span class="s3">&quot;safebrowsing.disable_download_protection&quot;</span><span class="s1">: </span><span class="s2">True,</span>
            <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">chrome = (</span>
            <span class="s1">webdriver.Remote(</span>
                <span class="s1">command_executor=self._remote_url</span><span class="s2">,</span>
                <span class="s1">options=options</span><span class="s2">,</span>
                <span class="s1">desired_capabilities=capabilities</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self._remote</span>
            <span class="s2">else </span><span class="s1">webdriver.Chrome(</span>
                <span class="s1">ChromeDriverManager(chrome_type=ChromeType.GOOGLE).install()</span><span class="s2">,</span>
                <span class="s1">options=options</span><span class="s2">,</span>
                <span class="s1">desired_capabilities=capabilities</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s0"># https://bugs.chromium.org/p/chromium/issues/detail?id=696481</span>
        <span class="s2">if </span><span class="s1">self._headless:</span>
            <span class="s0"># pylint: disable=protected-access</span>
            <span class="s1">chrome.command_executor._commands[</span><span class="s3">&quot;send_command&quot;</span><span class="s1">] = (</span>
                <span class="s3">&quot;POST&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;/session/$sessionId/chromium/send_command&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">params = {</span>
                <span class="s3">&quot;cmd&quot;</span><span class="s1">: </span><span class="s3">&quot;Page.setDownloadBehavior&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;params&quot;</span><span class="s1">: {</span><span class="s3">&quot;behavior&quot;</span><span class="s1">: </span><span class="s3">&quot;allow&quot;</span><span class="s2">, </span><span class="s3">&quot;downloadPath&quot;</span><span class="s1">: self.download_path}</span><span class="s2">,</span>
            <span class="s1">}</span>
            <span class="s1">res = chrome.execute(</span><span class="s3">&quot;send_command&quot;</span><span class="s2">, </span><span class="s1">params)</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;enabled headless download returns %s&quot;</span><span class="s2">, </span><span class="s1">res)</span>

        <span class="s1">chrome.set_window_position(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">chrome</span>

    <span class="s2">def </span><span class="s1">_get_firefox(self):</span>
        <span class="s1">options = self._get_wd_options()</span>

        <span class="s1">capabilities = DesiredCapabilities.FIREFOX</span>
        <span class="s1">capabilities[</span><span class="s3">&quot;loggingPrefs&quot;</span><span class="s1">] = {</span><span class="s3">&quot;browser&quot;</span><span class="s1">: </span><span class="s3">&quot;SEVERE&quot;</span><span class="s1">}</span>
        <span class="s1">capabilities[</span><span class="s3">&quot;marionette&quot;</span><span class="s1">] = </span><span class="s2">True</span>

        <span class="s0"># https://developer.mozilla.org/en-US/docs/Download_Manager_preferences</span>
        <span class="s1">fp = webdriver.FirefoxProfile()</span>
        <span class="s1">fp.set_preference(</span><span class="s3">&quot;browser.download.dir&quot;</span><span class="s2">, </span><span class="s1">self.download_path)</span>
        <span class="s1">fp.set_preference(</span><span class="s3">&quot;browser.download.folderList&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">fp.set_preference(</span>
            <span class="s3">&quot;browser.helperApps.neverAsk.saveToDisk&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;application/octet-stream&quot;</span><span class="s2">,  </span><span class="s0"># this MIME is generic for binary</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">webdriver.Remote(</span>
                <span class="s1">command_executor=self._remote_url</span><span class="s2">,</span>
                <span class="s1">options=options</span><span class="s2">,</span>
                <span class="s1">desired_capabilities=capabilities</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self._remote</span>
            <span class="s2">else </span><span class="s1">webdriver.Firefox(</span>
                <span class="s1">executable_path=GeckoDriverManager().install()</span><span class="s2">,</span>
                <span class="s1">firefox_profile=fp</span><span class="s2">,</span>
                <span class="s1">options=options</span><span class="s2">,</span>
                <span class="s1">capabilities=capabilities</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_is_windows():</span>
        <span class="s2">return </span><span class="s1">sys.platform == </span><span class="s3">&quot;win32&quot;</span>

    <span class="s2">def </span><span class="s1">multiple_click(self</span><span class="s2">, </span><span class="s1">elem_or_selector</span><span class="s2">, </span><span class="s1">clicks):</span>
        <span class="s5">&quot;&quot;&quot;multiple_click click the element with number of `clicks`.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(clicks):</span>
            <span class="s1">self._get_element(elem_or_selector).click()</span>

    <span class="s2">def </span><span class="s1">clear_input(self</span><span class="s2">, </span><span class="s1">elem_or_selector):</span>
        <span class="s5">&quot;&quot;&quot;Simulate key press to clear the input.&quot;&quot;&quot;</span>
        <span class="s1">elem = self._get_element(elem_or_selector)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;clear input with %s =&gt; %s&quot;</span><span class="s2">, </span><span class="s1">elem_or_selector</span><span class="s2">, </span><span class="s1">elem)</span>
        <span class="s1">(</span>
            <span class="s1">ActionChains(self.driver)</span>
            <span class="s1">.move_to_element(elem)</span>
            <span class="s1">.pause(</span><span class="s4">0.2</span><span class="s1">)</span>
            <span class="s1">.click(elem)</span>
            <span class="s1">.send_keys(Keys.END)</span>
            <span class="s1">.key_down(Keys.SHIFT)</span>
            <span class="s1">.send_keys(Keys.HOME)</span>
            <span class="s1">.key_up(Keys.SHIFT)</span>
            <span class="s1">.send_keys(Keys.DELETE)</span>
        <span class="s1">).perform()</span>

    <span class="s2">def </span><span class="s1">zoom_in_graph_by_ratio(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">elem_or_selector</span><span class="s2">, </span><span class="s1">start_fraction=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">zoom_box_fraction=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">compare=</span><span class="s2">True</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Zoom out a graph with a zoom box fraction of component dimension 
        default start at middle with a rectangle of 1/5 of the dimension use 
        `compare` to control if we check the svg get changed.&quot;&quot;&quot;</span>
        <span class="s1">elem = self._get_element(elem_or_selector)</span>

        <span class="s1">prev = elem.get_attribute(</span><span class="s3">&quot;innerHTML&quot;</span><span class="s1">)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = elem.size[</span><span class="s3">&quot;width&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">elem.size[</span><span class="s3">&quot;height&quot;</span><span class="s1">]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ActionChains(self.driver).move_to_element_with_offset(</span>
                <span class="s1">elem</span><span class="s2">, </span><span class="s1">w * start_fraction</span><span class="s2">, </span><span class="s1">h * start_fraction</span>
            <span class="s1">).drag_and_drop_by_offset(</span>
                <span class="s1">elem</span><span class="s2">, </span><span class="s1">w * zoom_box_fraction</span><span class="s2">, </span><span class="s1">h * zoom_box_fraction</span>
            <span class="s1">).perform()</span>
        <span class="s2">except </span><span class="s1">MoveTargetOutOfBoundsException:</span>
            <span class="s1">logger.exception(</span><span class="s3">&quot;graph offset outside of the boundary&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">compare:</span>
            <span class="s2">assert </span><span class="s1">prev != elem.get_attribute(</span>
                <span class="s3">&quot;innerHTML&quot;</span>
            <span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;SVG content should be different after zoom&quot;</span>

    <span class="s2">def </span><span class="s1">click_at_coord_fractions(self</span><span class="s2">, </span><span class="s1">elem_or_selector</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">fy):</span>
        <span class="s1">elem = self._get_element(elem_or_selector)</span>

        <span class="s1">ActionChains(self.driver).move_to_element_with_offset(</span>
            <span class="s1">elem</span><span class="s2">, </span><span class="s1">elem.size[</span><span class="s3">&quot;width&quot;</span><span class="s1">] * fx</span><span class="s2">, </span><span class="s1">elem.size[</span><span class="s3">&quot;height&quot;</span><span class="s1">] * fy</span>
        <span class="s1">).click().perform()</span>

    <span class="s2">def </span><span class="s1">get_logs(self):</span>
        <span class="s5">&quot;&quot;&quot;Return a list of `SEVERE` level logs after last reset time stamps 
        (default to 0, resettable by `reset_log_timestamp`. 
 
        Chrome only 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.driver.name.lower() == </span><span class="s3">&quot;chrome&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">entry</span>
                <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">self.driver.get_log(</span><span class="s3">&quot;browser&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">entry[</span><span class="s3">&quot;timestamp&quot;</span><span class="s1">] &gt; self._last_ts</span>
            <span class="s1">]</span>
        <span class="s1">warnings.warn(</span><span class="s3">&quot;get_logs always return None with webdrivers other than Chrome&quot;</span><span class="s1">)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">reset_log_timestamp(self):</span>
        <span class="s5">&quot;&quot;&quot;reset_log_timestamp only work with chrome webdriver.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.driver.name.lower() == </span><span class="s3">&quot;chrome&quot;</span><span class="s1">:</span>
            <span class="s1">entries = self.driver.get_log(</span><span class="s3">&quot;browser&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">entries:</span>
                <span class="s1">self._last_ts = entries[-</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;timestamp&quot;</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">driver(self):</span>
        <span class="s5">&quot;&quot;&quot;Expose the selenium webdriver as fixture property.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._driver</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">session_id(self):</span>
        <span class="s2">return </span><span class="s1">self.driver.session_id</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">server_url(self):</span>
        <span class="s2">return </span><span class="s1">self._url</span>

    <span class="s1">@server_url.setter</span>
    <span class="s2">def </span><span class="s1">server_url(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s5">&quot;&quot;&quot;Set the server url so the selenium is aware of the local server 
        port. 
 
        It also implicitly calls `wait_for_page`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._url = value</span>
        <span class="s1">self.wait_for_page()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">download_path(self):</span>
        <span class="s2">return </span><span class="s1">self._download_path</span>
</pre>
</body>
</html>