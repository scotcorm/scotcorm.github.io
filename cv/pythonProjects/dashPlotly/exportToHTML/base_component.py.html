<html>
<head>
<title>base_component.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base_component.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">uuid</span>
<span class="s0">import </span><span class="s1">random</span>

<span class="s0">from </span><span class="s1">.._utils </span><span class="s0">import </span><span class="s1">patch_collections_abc</span><span class="s0">, </span><span class="s1">stringify_id</span>

<span class="s1">MutableSequence = patch_collections_abc(</span><span class="s2">&quot;MutableSequence&quot;</span><span class="s1">)</span>

<span class="s1">rd = random.Random(</span><span class="s3">0</span><span class="s1">)</span>


<span class="s4"># pylint: disable=no-init,too-few-public-methods</span>
<span class="s0">class </span><span class="s1">ComponentRegistry:</span>
    <span class="s5">&quot;&quot;&quot;Holds a registry of the namespaces used by components.&quot;&quot;&quot;</span>

    <span class="s1">registry = set()</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">get_resources(cls</span><span class="s0">, </span><span class="s1">resource_name):</span>
        <span class="s1">resources = []</span>

        <span class="s0">for </span><span class="s1">module_name </span><span class="s0">in </span><span class="s1">cls.registry:</span>
            <span class="s1">module = sys.modules[module_name]</span>
            <span class="s1">resources.extend(getattr(module</span><span class="s0">, </span><span class="s1">resource_name</span><span class="s0">, </span><span class="s1">[]))</span>

        <span class="s0">return </span><span class="s1">resources</span>


<span class="s0">class </span><span class="s1">ComponentMeta(abc.ABCMeta):</span>

    <span class="s4"># pylint: disable=arguments-differ</span>
    <span class="s0">def </span><span class="s1">__new__(mcs</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">attributes):</span>
        <span class="s1">component = abc.ABCMeta.__new__(mcs</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">attributes)</span>
        <span class="s1">module = attributes[</span><span class="s2">&quot;__module__&quot;</span><span class="s1">].split(</span><span class="s2">&quot;.&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s2">&quot;Component&quot; </span><span class="s0">or </span><span class="s1">module == </span><span class="s2">&quot;builtins&quot;</span><span class="s1">:</span>
            <span class="s4"># Don't do the base component</span>
            <span class="s4"># and the components loaded dynamically by load_component</span>
            <span class="s4"># as it doesn't have the namespace.</span>
            <span class="s0">return </span><span class="s1">component</span>

        <span class="s1">ComponentRegistry.registry.add(module)</span>

        <span class="s0">return </span><span class="s1">component</span>


<span class="s0">def </span><span class="s1">is_number(s):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">float(s)</span>
        <span class="s0">return True</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">_check_if_has_indexable_children(item):</span>
    <span class="s0">if not </span><span class="s1">hasattr(item</span><span class="s0">, </span><span class="s2">&quot;children&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s0">not </span><span class="s1">isinstance(item.children</span><span class="s0">, </span><span class="s1">Component)</span>
        <span class="s0">and not </span><span class="s1">isinstance(item.children</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">MutableSequence))</span>
    <span class="s1">):</span>

        <span class="s0">raise </span><span class="s1">KeyError</span>


<span class="s0">class </span><span class="s1">Component(metaclass=ComponentMeta):</span>
    <span class="s0">class </span><span class="s1">_UNDEFINED:</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s2">&quot;undefined&quot;</span>

        <span class="s0">def </span><span class="s1">__str__(self):</span>
            <span class="s0">return </span><span class="s2">&quot;undefined&quot;</span>

    <span class="s1">UNDEFINED = _UNDEFINED()</span>

    <span class="s0">class </span><span class="s1">_REQUIRED:</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s2">&quot;required&quot;</span>

        <span class="s0">def </span><span class="s1">__str__(self):</span>
            <span class="s0">return </span><span class="s2">&quot;required&quot;</span>

    <span class="s1">REQUIRED = _REQUIRED()</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">import </span><span class="s1">dash  </span><span class="s4"># pylint: disable=import-outside-toplevel, cyclic-import</span>

        <span class="s4"># pylint: disable=super-init-not-called</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">list(kwargs.items()):</span>
            <span class="s4"># pylint: disable=no-member</span>
            <span class="s1">k_in_propnames = k </span><span class="s0">in </span><span class="s1">self._prop_names</span>
            <span class="s1">k_in_wildcards = any(</span>
                <span class="s1">k.startswith(w) </span><span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">self._valid_wildcard_attributes</span>
            <span class="s1">)</span>
            <span class="s4"># e.g. &quot;The dash_core_components.Dropdown component (version 1.6.0)</span>
            <span class="s4"># with the ID &quot;my-dropdown&quot;</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s4"># Get fancy error strings that have the version numbers</span>
                <span class="s1">error_string_prefix = </span><span class="s2">&quot;The `{}.{}` component (version {}){}&quot;</span>
                <span class="s4"># These components are part of dash now, so extract the dash version:</span>
                <span class="s1">dash_packages = {</span>
                    <span class="s2">&quot;dash_html_components&quot;</span><span class="s1">: </span><span class="s2">&quot;html&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;dash_core_components&quot;</span><span class="s1">: </span><span class="s2">&quot;dcc&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;dash_table&quot;</span><span class="s1">: </span><span class="s2">&quot;dash_table&quot;</span><span class="s0">,</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">self._namespace </span><span class="s0">in </span><span class="s1">dash_packages:</span>
                    <span class="s1">error_string_prefix = error_string_prefix.format(</span>
                        <span class="s1">dash_packages[self._namespace]</span><span class="s0">,</span>
                        <span class="s1">self._type</span><span class="s0">,</span>
                        <span class="s1">dash.__version__</span><span class="s0">,</span>
                        <span class="s2">' with the ID &quot;{}&quot;'</span><span class="s1">.format(kwargs[</span><span class="s2">&quot;id&quot;</span><span class="s1">])</span>
                        <span class="s0">if </span><span class="s2">&quot;id&quot; </span><span class="s0">in </span><span class="s1">kwargs</span>
                        <span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s4"># Otherwise import the package and extract the version number</span>
                    <span class="s1">error_string_prefix = error_string_prefix.format(</span>
                        <span class="s1">self._namespace</span><span class="s0">,</span>
                        <span class="s1">self._type</span><span class="s0">,</span>
                        <span class="s1">getattr(__import__(self._namespace)</span><span class="s0">, </span><span class="s2">&quot;__version__&quot;</span><span class="s0">, </span><span class="s2">&quot;unknown&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s2">' with the ID &quot;{}&quot;'</span><span class="s1">.format(kwargs[</span><span class="s2">&quot;id&quot;</span><span class="s1">])</span>
                        <span class="s0">if </span><span class="s2">&quot;id&quot; </span><span class="s0">in </span><span class="s1">kwargs</span>
                        <span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
                    <span class="s1">)</span>
            <span class="s0">except </span><span class="s1">ImportError:</span>
                <span class="s4"># Our tests create mock components with libraries that</span>
                <span class="s4"># aren't importable</span>
                <span class="s1">error_string_prefix = </span><span class="s2">&quot;The `{}` component{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">self._type</span><span class="s0">,</span>
                    <span class="s2">' with the ID &quot;{}&quot;'</span><span class="s1">.format(kwargs[</span><span class="s2">&quot;id&quot;</span><span class="s1">]) </span><span class="s0">if </span><span class="s2">&quot;id&quot; </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
                <span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">k_in_propnames </span><span class="s0">and not </span><span class="s1">k_in_wildcards:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;{} received an unexpected keyword argument: `{}`&quot;</span><span class="s1">.format(</span>
                        <span class="s1">error_string_prefix</span><span class="s0">, </span><span class="s1">k</span>
                    <span class="s1">)</span>
                    <span class="s1">+ </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">Allowed arguments: {}&quot;</span><span class="s1">.format(  </span><span class="s4"># pylint: disable=no-member</span>
                        <span class="s2">&quot;, &quot;</span><span class="s1">.join(sorted(self._prop_names))</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">k != </span><span class="s2">&quot;children&quot; </span><span class="s0">and </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">Component):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s1">error_string_prefix</span>
                    <span class="s1">+ </span><span class="s2">&quot; detected a Component for a prop other than `children`</span><span class="s0">\n</span><span class="s2">&quot;</span>
                    <span class="s1">+ </span><span class="s2">&quot;Did you forget to wrap multiple `children` in an array?</span><span class="s0">\n</span><span class="s2">&quot;</span>
                    <span class="s1">+ </span><span class="s2">&quot;Prop {} has value {}</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.format(k</span><span class="s0">, </span><span class="s1">repr(v))</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">k == </span><span class="s2">&quot;id&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">dict):</span>
                    <span class="s0">for </span><span class="s1">id_key</span><span class="s0">, </span><span class="s1">id_val </span><span class="s0">in </span><span class="s1">v.items():</span>
                        <span class="s0">if not </span><span class="s1">isinstance(id_key</span><span class="s0">, </span><span class="s1">str):</span>
                            <span class="s0">raise </span><span class="s1">TypeError(</span>
                                <span class="s2">&quot;dict id keys must be strings,</span><span class="s0">\n</span><span class="s2">&quot;</span>
                                <span class="s1">+ </span><span class="s2">&quot;found {!r} in id {!r}&quot;</span><span class="s1">.format(id_key</span><span class="s0">, </span><span class="s1">v)</span>
                            <span class="s1">)</span>
                        <span class="s0">if not </span><span class="s1">isinstance(id_val</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">bool)):</span>
                            <span class="s0">raise </span><span class="s1">TypeError(</span>
                                <span class="s2">&quot;dict id values must be strings, numbers or bools,</span><span class="s0">\n</span><span class="s2">&quot;</span>
                                <span class="s1">+ </span><span class="s2">&quot;found {!r} in id {!r}&quot;</span><span class="s1">.format(id_val</span><span class="s0">, </span><span class="s1">v)</span>
                            <span class="s1">)</span>
                <span class="s0">elif not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">str):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s2">&quot;`id` prop must be a string or dict, not {!r}&quot;</span><span class="s1">.format(v)</span>
                    <span class="s1">)</span>

            <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v)</span>

    <span class="s0">def </span><span class="s1">_set_random_id(self):</span>

        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">)</span>

        <span class="s1">kind = </span><span class="s2">f&quot;`</span><span class="s0">{</span><span class="s1">self._namespace</span><span class="s0">}</span><span class="s2">.</span><span class="s0">{</span><span class="s1">self._type</span><span class="s0">}</span><span class="s2">`&quot;  </span><span class="s4"># pylint: disable=no-member</span>

        <span class="s0">if </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s2">&quot;persistence&quot;</span><span class="s0">, False</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s2">f&quot;&quot;&quot;</span>
                <span class="s2">Attempting to use an auto-generated ID with the `persistence` prop.</span>
                <span class="s2">This is prohibited because persistence is tied to component IDs and</span>
                <span class="s2">auto-generated IDs can easily change.</span>

                <span class="s2">Please assign an explicit ID to this </span><span class="s0">{</span><span class="s1">kind</span><span class="s0">} </span><span class="s2">component.</span>
                <span class="s2">&quot;&quot;&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;dash_snapshots&quot; </span><span class="s0">in </span><span class="s1">sys.modules:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s2">f&quot;&quot;&quot;</span>
                <span class="s2">Attempting to use an auto-generated ID in an app with `dash_snapshots`.</span>
                <span class="s2">This is prohibited because snapshots saves the whole app layout,</span>
                <span class="s2">including component IDs, and auto-generated IDs can easily change.</span>
                <span class="s2">Callbacks referencing the new IDs will not work with old snapshots.</span>

                <span class="s2">Please assign an explicit ID to this </span><span class="s0">{</span><span class="s1">kind</span><span class="s0">} </span><span class="s2">component.</span>
                <span class="s2">&quot;&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s1">v = str(uuid.UUID(int=rd.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">128</span><span class="s1">)))</span>
        <span class="s1">setattr(self</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s1">v)</span>
        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">to_plotly_json(self):</span>
        <span class="s4"># Add normal properties</span>
        <span class="s1">props = {</span>
            <span class="s1">p: getattr(self</span><span class="s0">, </span><span class="s1">p)</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self._prop_names  </span><span class="s4"># pylint: disable=no-member</span>
            <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s1">}</span>
        <span class="s4"># Add the wildcard properties data-* and aria-*</span>
        <span class="s1">props.update(</span>
            <span class="s1">{</span>
                <span class="s1">k: getattr(self</span><span class="s0">, </span><span class="s1">k)</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.__dict__</span>
                <span class="s0">if </span><span class="s1">any(</span>
                    <span class="s1">k.startswith(w)</span>
                    <span class="s4"># pylint:disable=no-member</span>
                    <span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">self._valid_wildcard_attributes</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">as_json = {</span>
            <span class="s2">&quot;props&quot;</span><span class="s1">: props</span><span class="s0">,</span>
            <span class="s2">&quot;type&quot;</span><span class="s1">: self._type</span><span class="s0">,  </span><span class="s4"># pylint: disable=no-member</span>
            <span class="s2">&quot;namespace&quot;</span><span class="s1">: self._namespace</span><span class="s0">,  </span><span class="s4"># pylint: disable=no-member</span>
        <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">as_json</span>

    <span class="s4"># pylint: disable=too-many-branches, too-many-return-statements</span>
    <span class="s4"># pylint: disable=redefined-builtin, inconsistent-return-statements</span>
    <span class="s0">def </span><span class="s1">_get_set_or_delete(self</span><span class="s0">, </span><span class="s1">id</span><span class="s0">, </span><span class="s1">operation</span><span class="s0">, </span><span class="s1">new_item=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">_check_if_has_indexable_children(self)</span>

        <span class="s4"># pylint: disable=access-member-before-definition,</span>
        <span class="s4"># pylint: disable=attribute-defined-outside-init</span>
        <span class="s0">if </span><span class="s1">isinstance(self.children</span><span class="s0">, </span><span class="s1">Component):</span>
            <span class="s0">if </span><span class="s1">getattr(self.children</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># Woohoo! It's the item that we're looking for</span>
                <span class="s0">if </span><span class="s1">self.children.id == id:</span>
                    <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;get&quot;</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">self.children</span>
                    <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;set&quot;</span><span class="s1">:</span>
                        <span class="s1">self.children = new_item</span>
                        <span class="s0">return</span>
                    <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;delete&quot;</span><span class="s1">:</span>
                        <span class="s1">self.children = </span><span class="s0">None</span>
                        <span class="s0">return</span>

            <span class="s4"># Recursively dig into its subtree</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;get&quot;</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">self.children.__getitem__(id)</span>
                <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;set&quot;</span><span class="s1">:</span>
                    <span class="s1">self.children.__setitem__(id</span><span class="s0">, </span><span class="s1">new_item)</span>
                    <span class="s0">return</span>
                <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;delete&quot;</span><span class="s1">:</span>
                    <span class="s1">self.children.__delitem__(id)</span>
                    <span class="s0">return</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">pass</span>

        <span class="s4"># if children is like a list</span>
        <span class="s0">if </span><span class="s1">isinstance(self.children</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">MutableSequence)):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate(self.children):</span>
                <span class="s4"># If the item itself is the one we're looking for</span>
                <span class="s0">if </span><span class="s1">getattr(item</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s0">, None</span><span class="s1">) == id:</span>
                    <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;get&quot;</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">item</span>
                    <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;set&quot;</span><span class="s1">:</span>
                        <span class="s1">self.children[i] = new_item</span>
                        <span class="s0">return</span>
                    <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;delete&quot;</span><span class="s1">:</span>
                        <span class="s0">del </span><span class="s1">self.children[i]</span>
                        <span class="s0">return</span>

                <span class="s4"># Otherwise, recursively dig into that item's subtree</span>
                <span class="s4"># Make sure it's not like a string</span>
                <span class="s0">elif </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">Component):</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;get&quot;</span><span class="s1">:</span>
                            <span class="s0">return </span><span class="s1">item.__getitem__(id)</span>
                        <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;set&quot;</span><span class="s1">:</span>
                            <span class="s1">item.__setitem__(id</span><span class="s0">, </span><span class="s1">new_item)</span>
                            <span class="s0">return</span>
                        <span class="s0">if </span><span class="s1">operation == </span><span class="s2">&quot;delete&quot;</span><span class="s1">:</span>
                            <span class="s1">item.__delitem__(id)</span>
                            <span class="s0">return</span>
                    <span class="s0">except </span><span class="s1">KeyError:</span>
                        <span class="s0">pass</span>

        <span class="s4"># The end of our branch</span>
        <span class="s4"># If we were in a list, then this exception will get caught</span>
        <span class="s0">raise </span><span class="s1">KeyError(id)</span>

    <span class="s4"># Magic methods for a mapping interface:</span>
    <span class="s4"># - __getitem__</span>
    <span class="s4"># - __setitem__</span>
    <span class="s4"># - __delitem__</span>
    <span class="s4"># - __iter__</span>
    <span class="s4"># - __len__</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">id):  </span><span class="s4"># pylint: disable=redefined-builtin</span>
        <span class="s5">&quot;&quot;&quot;Recursively find the element with the given ID through the tree of 
        children.&quot;&quot;&quot;</span>

        <span class="s4"># A component's children can be undefined, a string, another component,</span>
        <span class="s4"># or a list of components.</span>
        <span class="s0">return </span><span class="s1">self._get_set_or_delete(id</span><span class="s0">, </span><span class="s2">&quot;get&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">id</span><span class="s0">, </span><span class="s1">item):  </span><span class="s4"># pylint: disable=redefined-builtin</span>
        <span class="s5">&quot;&quot;&quot;Set an element by its ID.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._get_set_or_delete(id</span><span class="s0">, </span><span class="s2">&quot;set&quot;</span><span class="s0">, </span><span class="s1">item)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">id):  </span><span class="s4"># pylint: disable=redefined-builtin</span>
        <span class="s5">&quot;&quot;&quot;Delete items by ID in the tree of children.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._get_set_or_delete(id</span><span class="s0">, </span><span class="s2">&quot;delete&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_traverse(self):</span>
        <span class="s5">&quot;&quot;&quot;Yield each item in the tree.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self._traverse_with_paths():</span>
            <span class="s0">yield </span><span class="s1">t[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_id_str(component):</span>
        <span class="s1">id_ = stringify_id(getattr(component</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">id_ </span><span class="s0">and </span><span class="s2">&quot; (id={:s})&quot;</span><span class="s1">.format(id_)</span>

    <span class="s0">def </span><span class="s1">_traverse_with_paths(self):</span>
        <span class="s5">&quot;&quot;&quot;Yield each item with its path in the tree.&quot;&quot;&quot;</span>
        <span class="s1">children = getattr(self</span><span class="s0">, </span><span class="s2">&quot;children&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">children_type = type(children).__name__</span>
        <span class="s1">children_string = children_type + self._id_str(children)</span>

        <span class="s4"># children is just a component</span>
        <span class="s0">if </span><span class="s1">isinstance(children</span><span class="s0">, </span><span class="s1">Component):</span>
            <span class="s0">yield </span><span class="s2">&quot;[*] &quot; </span><span class="s1">+ children_string</span><span class="s0">, </span><span class="s1">children</span>
            <span class="s4"># pylint: disable=protected-access</span>
            <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">children._traverse_with_paths():</span>
                <span class="s0">yield </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.join([</span><span class="s2">&quot;[*] &quot; </span><span class="s1">+ children_string</span><span class="s0">, </span><span class="s1">p])</span><span class="s0">, </span><span class="s1">t</span>

        <span class="s4"># children is a list of components</span>
        <span class="s0">elif </span><span class="s1">isinstance(children</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">MutableSequence)):</span>
            <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">enumerate(children):</span>
                <span class="s1">list_path = </span><span class="s2">&quot;[{:d}] {:s}{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">idx</span><span class="s0">, </span><span class="s1">type(i).__name__</span><span class="s0">, </span><span class="s1">self._id_str(i)</span>
                <span class="s1">)</span>
                <span class="s0">yield </span><span class="s1">list_path</span><span class="s0">, </span><span class="s1">i</span>

                <span class="s0">if </span><span class="s1">isinstance(i</span><span class="s0">, </span><span class="s1">Component):</span>
                    <span class="s4"># pylint: disable=protected-access</span>
                    <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">i._traverse_with_paths():</span>
                        <span class="s0">yield </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.join([list_path</span><span class="s0">, </span><span class="s1">p])</span><span class="s0">, </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">_traverse_ids(self):</span>
        <span class="s5">&quot;&quot;&quot;Yield components with IDs in the tree of children.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self._traverse():</span>
            <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">Component) </span><span class="s0">and </span><span class="s1">getattr(t</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s5">&quot;&quot;&quot;Yield IDs in the tree of children.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self._traverse_ids():</span>
            <span class="s0">yield </span><span class="s1">t.id</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s5">&quot;&quot;&quot;Return the number of items in the tree.&quot;&quot;&quot;</span>
        <span class="s4"># TODO - Should we return the number of items that have IDs</span>
        <span class="s4"># or just the number of items?</span>
        <span class="s4"># The number of items is more intuitive but returning the number</span>
        <span class="s4"># of IDs matches __iter__ better.</span>
        <span class="s1">length = </span><span class="s3">0</span>
        <span class="s0">if </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s2">&quot;children&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">length = </span><span class="s3">0</span>
        <span class="s0">elif </span><span class="s1">isinstance(self.children</span><span class="s0">, </span><span class="s1">Component):</span>
            <span class="s1">length = </span><span class="s3">1</span>
            <span class="s1">length += len(self.children)</span>
        <span class="s0">elif </span><span class="s1">isinstance(self.children</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">MutableSequence)):</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self.children:</span>
                <span class="s1">length += </span><span class="s3">1</span>
                <span class="s0">if </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">Component):</span>
                    <span class="s1">length += len(c)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># string or number</span>
            <span class="s1">length = </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">length</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s4"># pylint: disable=no-member</span>
        <span class="s1">props_with_values = [</span>
            <span class="s1">c </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._prop_names </span><span class="s0">if </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span>
        <span class="s1">] + [</span>
            <span class="s1">c</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self.__dict__</span>
            <span class="s0">if </span><span class="s1">any(c.startswith(wc_attr) </span><span class="s0">for </span><span class="s1">wc_attr </span><span class="s0">in </span><span class="s1">self._valid_wildcard_attributes)</span>
        <span class="s1">]</span>
        <span class="s0">if </span><span class="s1">any(p != </span><span class="s2">&quot;children&quot; </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">props_with_values):</span>
            <span class="s1">props_string = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s2">&quot;{prop}={value}&quot;</span><span class="s1">.format(prop=p</span><span class="s0">, </span><span class="s1">value=repr(getattr(self</span><span class="s0">, </span><span class="s1">p)))</span>
                <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">props_with_values</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">props_string = repr(getattr(self</span><span class="s0">, </span><span class="s2">&quot;children&quot;</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s2">&quot;{type}({props_string})&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=self._type</span><span class="s0">, </span><span class="s1">props_string=props_string</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_explicitize_args(func):</span>
    <span class="s4"># Python 2</span>
    <span class="s0">if </span><span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">&quot;func_code&quot;</span><span class="s1">):</span>
        <span class="s1">varnames = func.func_code.co_varnames</span>
    <span class="s4"># Python 3</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">varnames = func.__code__.co_varnames</span>

    <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s2">&quot;_explicit_args&quot; </span><span class="s0">in </span><span class="s1">kwargs.keys():</span>
            <span class="s0">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Variable _explicit_args should not be set.&quot;</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;_explicit_args&quot;</span><span class="s1">] = list(</span>
            <span class="s1">set(list(varnames[: len(args)]) + [k </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">kwargs.items()])</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;self&quot; </span><span class="s0">in </span><span class="s1">kwargs[</span><span class="s2">&quot;_explicit_args&quot;</span><span class="s1">]:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;_explicit_args&quot;</span><span class="s1">].remove(</span><span class="s2">&quot;self&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s4"># If Python 3, we can set the function signature to be correct</span>
    <span class="s0">if </span><span class="s1">hasattr(inspect</span><span class="s0">, </span><span class="s2">&quot;signature&quot;</span><span class="s1">):</span>
        <span class="s4"># pylint: disable=no-member</span>
        <span class="s1">new_sig = inspect.signature(wrapper).replace(</span>
            <span class="s1">parameters=inspect.signature(func).parameters.values()</span>
        <span class="s1">)</span>
        <span class="s1">wrapper.__signature__ = new_sig</span>
    <span class="s0">return </span><span class="s1">wrapper</span>
</pre>
</body>
</html>