<html>
<head>
<title>hashtable_class_helper.pxi.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hashtable_class_helper.pxi.in</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Template for each `dtype` helper function for hashtable</span>

<span class="s0">WARNING: DO NOT edit .pxi FILE directly, .pxi is generated from .pxi.in</span>
<span class="s0">&quot;&quot;&quot;</span>


<span class="s0">{{py:</span>

<span class="s0"># name</span>
<span class="s0">complex_types = ['complex64',</span>
                 <span class="s0">'complex128']</span>
<span class="s0">}}</span>

<span class="s0">{{for name in complex_types}}</span>
<span class="s0">cdef kh{{name}}_t to_kh{{name}}_t({{name}}_t val) nogil:</span>
    <span class="s0">cdef kh{{name}}_t res</span>
    <span class="s0">res.real = val.real</span>
    <span class="s0">res.imag = val.imag</span>
    <span class="s0">return res</span>

<span class="s0">{{endfor}}</span>


<span class="s0">{{py:</span>


<span class="s0"># name</span>
<span class="s0">c_types = ['khcomplex128_t',</span>
           <span class="s0">'khcomplex64_t',</span>
           <span class="s0">'float64_t',</span>
           <span class="s0">'float32_t',</span>
           <span class="s0">'int64_t',</span>
           <span class="s0">'int32_t',</span>
           <span class="s0">'int16_t',</span>
           <span class="s0">'int8_t',</span>
           <span class="s0">'uint64_t',</span>
           <span class="s0">'uint32_t',</span>
           <span class="s0">'uint16_t',</span>
           <span class="s0">'uint8_t']</span>
<span class="s0">}}</span>

<span class="s0">{{for c_type in c_types}}</span>

<span class="s0">cdef bint is_nan_{{c_type}}({{c_type}} val) nogil:</span>
    <span class="s0">{{if c_type in {'khcomplex128_t', 'khcomplex64_t'} }}</span>
    <span class="s0">return val.real != val.real or val.imag != val.imag</span>
    <span class="s0">{{elif c_type in {'float64_t', 'float32_t'} }}</span>
    <span class="s0">return val != val</span>
    <span class="s0">{{else}}</span>
    <span class="s0">return False</span>
    <span class="s0">{{endif}}</span>


<span class="s0">{{if c_type in {'khcomplex128_t', 'khcomplex64_t', 'float64_t', 'float32_t'} }}</span>
<span class="s0"># are_equivalent_{{c_type}} is cimported via khash.pxd</span>
<span class="s0">{{else}}</span>
<span class="s0">cdef bint are_equivalent_{{c_type}}({{c_type}} val1, {{c_type}} val2) nogil:</span>
    <span class="s0">return val1 == val2</span>
<span class="s0">{{endif}}</span>

<span class="s0">{{endfor}}</span>


<span class="s0">{{py:</span>

<span class="s0"># name</span>
<span class="s0">cimported_types = ['complex64',</span>
                   <span class="s0">'complex128',</span>
                   <span class="s0">'float32',</span>
                   <span class="s0">'float64',</span>
                   <span class="s0">'int8',</span>
                   <span class="s0">'int16',</span>
                   <span class="s0">'int32',</span>
                   <span class="s0">'int64',</span>
                   <span class="s0">'pymap',</span>
                   <span class="s0">'str',</span>
                   <span class="s0">'strbox',</span>
                   <span class="s0">'uint8',</span>
                   <span class="s0">'uint16',</span>
                   <span class="s0">'uint32',</span>
                   <span class="s0">'uint64']</span>
<span class="s0">}}</span>

<span class="s0">{{for name in cimported_types}}</span>
<span class="s0">from pandas._libs.khash cimport (</span>
    <span class="s0">kh_destroy_{{name}},</span>
    <span class="s0">kh_exist_{{name}},</span>
    <span class="s0">kh_get_{{name}},</span>
    <span class="s0">kh_init_{{name}},</span>
    <span class="s0">kh_put_{{name}},</span>
    <span class="s0">kh_resize_{{name}},</span>
<span class="s0">)</span>

<span class="s0">{{endfor}}</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># VectorData</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">from pandas._libs.tslibs.util cimport get_c_string</span>
<span class="s0">from pandas._libs.missing cimport C_NA</span>

<span class="s0">{{py:</span>

<span class="s0"># name, dtype, c_type</span>
<span class="s0"># the generated StringVector is not actually used</span>
<span class="s0"># but is included for completeness (rather ObjectVector is used</span>
<span class="s0"># for uniques in hashtables)</span>

<span class="s0">dtypes = [('Complex128', 'complex128', 'khcomplex128_t'),</span>
          <span class="s0">('Complex64', 'complex64', 'khcomplex64_t'),</span>
          <span class="s0">('Float64', 'float64', 'float64_t'),</span>
          <span class="s0">('Float32', 'float32', 'float32_t'),</span>
          <span class="s0">('Int64', 'int64', 'int64_t'),</span>
          <span class="s0">('Int32', 'int32', 'int32_t'),</span>
          <span class="s0">('Int16', 'int16', 'int16_t'),</span>
          <span class="s0">('Int8', 'int8', 'int8_t'),</span>
          <span class="s0">('String', 'string', 'char *'),</span>
          <span class="s0">('UInt64', 'uint64', 'uint64_t'),</span>
          <span class="s0">('UInt32', 'uint32', 'uint32_t'),</span>
          <span class="s0">('UInt16', 'uint16', 'uint16_t'),</span>
          <span class="s0">('UInt8', 'uint8', 'uint8_t')]</span>
<span class="s0">}}</span>

<span class="s0">{{for name, dtype, c_type in dtypes}}</span>


<span class="s0">{{if dtype != 'int64'}}</span>
<span class="s0"># Int64VectorData is defined in the .pxd file because it is needed (indirectly)</span>
<span class="s0">#  by IntervalTree</span>

<span class="s0">ctypedef struct {{name}}VectorData:</span>
    <span class="s0">{{c_type}} *data</span>
    <span class="s0">Py_ssize_t n, m</span>

<span class="s0">{{endif}}</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef inline void append_data_{{dtype}}({{name}}VectorData *data,</span>
                                       <span class="s0">{{c_type}} x) nogil:</span>

    <span class="s0">data.data[data.n] = x</span>
    <span class="s0">data.n += 1</span>

<span class="s0">{{endfor}}</span>

<span class="s0">ctypedef fused vector_data:</span>
    <span class="s0">Int64VectorData</span>
    <span class="s0">Int32VectorData</span>
    <span class="s0">Int16VectorData</span>
    <span class="s0">Int8VectorData</span>
    <span class="s0">UInt64VectorData</span>
    <span class="s0">UInt32VectorData</span>
    <span class="s0">UInt16VectorData</span>
    <span class="s0">UInt8VectorData</span>
    <span class="s0">Float64VectorData</span>
    <span class="s0">Float32VectorData</span>
    <span class="s0">Complex128VectorData</span>
    <span class="s0">Complex64VectorData</span>
    <span class="s0">StringVectorData</span>

<span class="s0">cdef inline bint needs_resize(vector_data *data) nogil:</span>
    <span class="s0">return data.n == data.m</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Vector</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cdef class Vector:</span>
    <span class="s0"># cdef readonly:</span>
    <span class="s0">#    bint external_view_exists</span>

    <span class="s0">def __cinit__(self):</span>
        <span class="s0">self.external_view_exists = False</span>


<span class="s0">{{py:</span>

<span class="s0"># name, dtype, c_type</span>
<span class="s0">dtypes = [('Complex128', 'complex128', 'khcomplex128_t'),</span>
          <span class="s0">('Complex64', 'complex64', 'khcomplex64_t'),</span>
          <span class="s0">('Float64', 'float64', 'float64_t'),</span>
          <span class="s0">('UInt64', 'uint64', 'uint64_t'),</span>
          <span class="s0">('Int64', 'int64', 'int64_t'),</span>
          <span class="s0">('Float32', 'float32', 'float32_t'),</span>
          <span class="s0">('UInt32', 'uint32', 'uint32_t'),</span>
          <span class="s0">('Int32', 'int32', 'int32_t'),</span>
          <span class="s0">('UInt16', 'uint16', 'uint16_t'),</span>
          <span class="s0">('Int16', 'int16', 'int16_t'),</span>
          <span class="s0">('UInt8', 'uint8', 'uint8_t'),</span>
          <span class="s0">('Int8', 'int8', 'int8_t')]</span>

<span class="s0">}}</span>

<span class="s0">{{for name, dtype, c_type in dtypes}}</span>

<span class="s0">cdef class {{name}}Vector(Vector):</span>

    <span class="s0"># For int64 we have to put this declaration in the .pxd file;</span>
    <span class="s0"># Int64Vector is the only one we need exposed for other cython files.</span>
    <span class="s0">{{if dtype != 'int64'}}</span>
    <span class="s0">cdef:</span>
        <span class="s0">{{name}}VectorData *data</span>
        <span class="s0">ndarray ao</span>
    <span class="s0">{{endif}}</span>

    <span class="s0">def __cinit__(self):</span>
        <span class="s0">self.data = &lt;{{name}}VectorData *&gt;PyMem_Malloc(</span>
            <span class="s0">sizeof({{name}}VectorData))</span>
        <span class="s0">if not self.data:</span>
            <span class="s0">raise MemoryError()</span>
        <span class="s0">self.data.n = 0</span>
        <span class="s0">self.data.m = _INIT_VEC_CAP</span>
        <span class="s0">self.ao = np.empty(self.data.m, dtype=np.{{dtype}})</span>
        <span class="s0">self.data.data = &lt;{{c_type}}*&gt;self.ao.data</span>

    <span class="s0">cdef resize(self):</span>
        <span class="s0">self.data.m = max(self.data.m * 4, _INIT_VEC_CAP)</span>
        <span class="s0">self.ao.resize(self.data.m, refcheck=False)</span>
        <span class="s0">self.data.data = &lt;{{c_type}}*&gt;self.ao.data</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">if self.data is not NULL:</span>
            <span class="s0">PyMem_Free(self.data)</span>
            <span class="s0">self.data = NULL</span>

    <span class="s0">def __len__(self) -&gt; int:</span>
        <span class="s0">return self.data.n</span>

    <span class="s0">cpdef ndarray to_array(self):</span>
        <span class="s0">if self.data.m != self.data.n:</span>
            <span class="s0">if self.external_view_exists:</span>
                <span class="s0"># should never happen</span>
                <span class="s0">raise ValueError(&quot;should have raised on append()&quot;)</span>
            <span class="s0">self.ao.resize(self.data.n, refcheck=False)</span>
            <span class="s0">self.data.m = self.data.n</span>
        <span class="s0">self.external_view_exists = True</span>
        <span class="s0">return self.ao</span>

    <span class="s0">cdef inline void append(self, {{c_type}} x):</span>

        <span class="s0">if needs_resize(self.data):</span>
            <span class="s0">if self.external_view_exists:</span>
                <span class="s0">raise ValueError(&quot;external reference but &quot;</span>
                                 <span class="s0">&quot;Vector.resize() needed&quot;)</span>
            <span class="s0">self.resize()</span>

        <span class="s0">append_data_{{dtype}}(self.data, x)</span>

    <span class="s0">cdef extend(self, const {{c_type}}[:] x):</span>
        <span class="s0">for i in range(len(x)):</span>
            <span class="s0">self.append(x[i])</span>

<span class="s0">{{endfor}}</span>

<span class="s0">cdef class StringVector(Vector):</span>

    <span class="s0">cdef:</span>
        <span class="s0">StringVectorData *data</span>

    <span class="s0">def __cinit__(self):</span>
        <span class="s0">self.data = &lt;StringVectorData *&gt;PyMem_Malloc(sizeof(StringVectorData))</span>
        <span class="s0">if not self.data:</span>
            <span class="s0">raise MemoryError()</span>
        <span class="s0">self.data.n = 0</span>
        <span class="s0">self.data.m = _INIT_VEC_CAP</span>
        <span class="s0">self.data.data = &lt;char **&gt;malloc(self.data.m * sizeof(char *))</span>
        <span class="s0">if not self.data.data:</span>
            <span class="s0">raise MemoryError()</span>

    <span class="s0">cdef resize(self):</span>
        <span class="s0">cdef:</span>
            <span class="s0">char **orig_data</span>
            <span class="s0">Py_ssize_t i, m</span>

        <span class="s0">m = self.data.m</span>
        <span class="s0">self.data.m = max(self.data.m * 4, _INIT_VEC_CAP)</span>

        <span class="s0">orig_data = self.data.data</span>
        <span class="s0">self.data.data = &lt;char **&gt;malloc(self.data.m * sizeof(char *))</span>
        <span class="s0">if not self.data.data:</span>
            <span class="s0">raise MemoryError()</span>
        <span class="s0">for i in range(m):</span>
            <span class="s0">self.data.data[i] = orig_data[i]</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">if self.data is not NULL:</span>
            <span class="s0">if self.data.data is not NULL:</span>
                <span class="s0">free(self.data.data)</span>
            <span class="s0">PyMem_Free(self.data)</span>
            <span class="s0">self.data = NULL</span>

    <span class="s0">def __len__(self) -&gt; int:</span>
        <span class="s0">return self.data.n</span>

    <span class="s0">cpdef ndarray[object, ndim=1] to_array(self):</span>
        <span class="s0">cdef:</span>
            <span class="s0">ndarray ao</span>
            <span class="s0">Py_ssize_t n</span>
            <span class="s0">object val</span>

        <span class="s0">ao = np.empty(self.data.n, dtype=object)</span>
        <span class="s0">for i in range(self.data.n):</span>
            <span class="s0">val = self.data.data[i]</span>
            <span class="s0">ao[i] = val</span>
        <span class="s0">self.external_view_exists = True</span>
        <span class="s0">self.data.m = self.data.n</span>
        <span class="s0">return ao</span>

    <span class="s0">cdef inline void append(self, char *x):</span>

        <span class="s0">if needs_resize(self.data):</span>
            <span class="s0">self.resize()</span>

        <span class="s0">append_data_string(self.data, x)</span>

    <span class="s0">cdef extend(self, ndarray[object] x):</span>
        <span class="s0">for i in range(len(x)):</span>
            <span class="s0">self.append(x[i])</span>


<span class="s0">cdef class ObjectVector(Vector):</span>

    <span class="s0">cdef:</span>
        <span class="s0">PyObject **data</span>
        <span class="s0">Py_ssize_t n, m</span>
        <span class="s0">ndarray ao</span>

    <span class="s0">def __cinit__(self):</span>
        <span class="s0">self.n = 0</span>
        <span class="s0">self.m = _INIT_VEC_CAP</span>
        <span class="s0">self.ao = np.empty(_INIT_VEC_CAP, dtype=object)</span>
        <span class="s0">self.data = &lt;PyObject**&gt;self.ao.data</span>

    <span class="s0">def __len__(self) -&gt; int:</span>
        <span class="s0">return self.n</span>

    <span class="s0">cdef inline append(self, object obj):</span>
        <span class="s0">if self.n == self.m:</span>
            <span class="s0">if self.external_view_exists:</span>
                <span class="s0">raise ValueError(&quot;external reference but &quot;</span>
                                 <span class="s0">&quot;Vector.resize() needed&quot;)</span>
            <span class="s0">self.m = max(self.m * 2, _INIT_VEC_CAP)</span>
            <span class="s0">self.ao.resize(self.m, refcheck=False)</span>
            <span class="s0">self.data = &lt;PyObject**&gt;self.ao.data</span>

        <span class="s0">Py_INCREF(obj)</span>
        <span class="s0">self.data[self.n] = &lt;PyObject*&gt;obj</span>
        <span class="s0">self.n += 1</span>

    <span class="s0">cpdef ndarray[object, ndim=1] to_array(self):</span>
        <span class="s0">if self.m != self.n:</span>
            <span class="s0">if self.external_view_exists:</span>
                <span class="s0">raise ValueError(&quot;should have raised on append()&quot;)</span>
            <span class="s0">self.ao.resize(self.n, refcheck=False)</span>
            <span class="s0">self.m = self.n</span>
        <span class="s0">self.external_view_exists = True</span>
        <span class="s0">return self.ao</span>

    <span class="s0">cdef extend(self, ndarray[object] x):</span>
        <span class="s0">for i in range(len(x)):</span>
            <span class="s0">self.append(x[i])</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># HashTable</span>
<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">cdef class HashTable:</span>

    <span class="s0">pass</span>

<span class="s0">{{py:</span>

<span class="s0"># name, dtype, c_type, to_c_type</span>
<span class="s0">dtypes = [('Complex128', 'complex128', 'khcomplex128_t', 'to_khcomplex128_t'),</span>
          <span class="s0">('Float64', 'float64', 'float64_t', ''),</span>
          <span class="s0">('UInt64', 'uint64', 'uint64_t', ''),</span>
          <span class="s0">('Int64', 'int64', 'int64_t', ''),</span>
          <span class="s0">('Complex64', 'complex64', 'khcomplex64_t', 'to_khcomplex64_t'),</span>
          <span class="s0">('Float32', 'float32', 'float32_t', ''),</span>
          <span class="s0">('UInt32', 'uint32', 'uint32_t', ''),</span>
          <span class="s0">('Int32', 'int32', 'int32_t', ''),</span>
          <span class="s0">('UInt16', 'uint16', 'uint16_t', ''),</span>
          <span class="s0">('Int16', 'int16', 'int16_t', ''),</span>
          <span class="s0">('UInt8', 'uint8', 'uint8_t', ''),</span>
          <span class="s0">('Int8', 'int8', 'int8_t', '')]</span>

<span class="s0">}}</span>


<span class="s0">{{for name, dtype, c_type, to_c_type in dtypes}}</span>

<span class="s0">cdef class {{name}}HashTable(HashTable):</span>

    <span class="s0">def __cinit__(self, int64_t size_hint=1):</span>
        <span class="s0">self.table = kh_init_{{dtype}}()</span>
        <span class="s0">size_hint = min(kh_needed_n_buckets(size_hint), SIZE_HINT_LIMIT)</span>
        <span class="s0">kh_resize_{{dtype}}(self.table, size_hint)</span>

    <span class="s0">def __len__(self) -&gt; int:</span>
        <span class="s0">return self.table.size</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">if self.table is not NULL:</span>
            <span class="s0">kh_destroy_{{dtype}}(self.table)</span>
            <span class="s0">self.table = NULL</span>

    <span class="s0">def __contains__(self, object key) -&gt; bool:</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">{{c_type}} ckey</span>
        <span class="s0">ckey = {{to_c_type}}(key)</span>
        <span class="s0">k = kh_get_{{dtype}}(self.table, ckey)</span>
        <span class="s0">return k != self.table.n_buckets</span>

    <span class="s0">def sizeof(self, deep: bool = False) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; return the size of my table in bytes &quot;&quot;&quot;</span>
        <span class="s0">overhead = 4 * sizeof(uint32_t) + 3 * sizeof(uint32_t*)</span>
        <span class="s0">for_flags = max(1, self.table.n_buckets &gt;&gt; 5) * sizeof(uint32_t)</span>
        <span class="s0">for_pairs =  self.table.n_buckets * (sizeof({{dtype}}_t) + # keys</span>
                                             <span class="s0">sizeof(Py_ssize_t))   # vals</span>
        <span class="s0">return overhead + for_flags + for_pairs</span>

    <span class="s0">def get_state(self) -&gt; dict[str, int]:</span>
        <span class="s0">&quot;&quot;&quot; returns infos about the state of the hashtable&quot;&quot;&quot;</span>
        <span class="s0">return {</span>
            <span class="s0">'n_buckets' : self.table.n_buckets,</span>
            <span class="s0">'size' : self.table.size,</span>
            <span class="s0">'n_occupied' : self.table.n_occupied,</span>
            <span class="s0">'upper_bound' : self.table.upper_bound,</span>
        <span class="s0">}</span>

    <span class="s0">cpdef get_item(self, {{dtype}}_t val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">{{c_type}} cval</span>
        <span class="s0">cval = {{to_c_type}}(val)</span>
        <span class="s0">k = kh_get_{{dtype}}(self.table, cval)</span>
        <span class="s0">if k != self.table.n_buckets:</span>
            <span class="s0">return self.table.vals[k]</span>
        <span class="s0">else:</span>
            <span class="s0">raise KeyError(val)</span>

    <span class="s0">cpdef set_item(self, {{dtype}}_t key, Py_ssize_t val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">{{c_type}} ckey</span>
        <span class="s0">ckey = {{to_c_type}}(key)</span>
        <span class="s0">k = kh_put_{{dtype}}(self.table, ckey, &amp;ret)</span>
        <span class="s0">if kh_exist_{{dtype}}(self.table, k):</span>
            <span class="s0">self.table.vals[k] = val</span>
        <span class="s0">else:</span>
            <span class="s0">raise KeyError(key)</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def map(self, const {{dtype}}_t[:] keys, const int64_t[:] values) -&gt; None:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">{{c_type}} key</span>
            <span class="s0">khiter_t k</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">key = {{to_c_type}}(keys[i])</span>
                <span class="s0">k = kh_put_{{dtype}}(self.table, key, &amp;ret)</span>
                <span class="s0">self.table.vals[k] = &lt;Py_ssize_t&gt;values[i]</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def map_locations(self, const {{dtype}}_t[:] values) -&gt; None:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">{{c_type}} val</span>
            <span class="s0">khiter_t k</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">val= {{to_c_type}}(values[i])</span>
                <span class="s0">k = kh_put_{{dtype}}(self.table, val, &amp;ret)</span>
                <span class="s0">self.table.vals[k] = i</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def lookup(self, const {{dtype}}_t[:] values) -&gt; ndarray:</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">{{c_type}} val</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">intp_t[:] locs = np.empty(n, dtype=np.intp)</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">val = {{to_c_type}}(values[i])</span>
                <span class="s0">k = kh_get_{{dtype}}(self.table, val)</span>
                <span class="s0">if k != self.table.n_buckets:</span>
                    <span class="s0">locs[i] = self.table.vals[k]</span>
                <span class="s0">else:</span>
                    <span class="s0">locs[i] = -1</span>

        <span class="s0">return np.asarray(locs)</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">def _unique(self, const {{dtype}}_t[:] values, {{name}}Vector uniques,</span>
                <span class="s0">Py_ssize_t count_prior=0, Py_ssize_t na_sentinel=-1,</span>
                <span class="s0">object na_value=None, bint ignore_na=False,</span>
                <span class="s0">object mask=None, bint return_inverse=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[{{dtype}}]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">uniques : {{name}}Vector</span>
            <span class="s0">Vector into which uniques will be written</span>
        <span class="s0">count_prior : Py_ssize_t, default 0</span>
            <span class="s0">Number of existing entries in uniques</span>
        <span class="s0">na_sentinel : Py_ssize_t, default -1</span>
            <span class="s0">Sentinel value used for all NA-values in inverse</span>
        <span class="s0">na_value : object, default None</span>
            <span class="s0">Value to identify as missing. If na_value is None, then</span>
            <span class="s0">any value &quot;val&quot; satisfying val != val is considered missing.</span>
            <span class="s0">If na_value is not None, then _additionally_, any value &quot;val&quot;</span>
            <span class="s0">satisfying val == na_value is considered missing.</span>
        <span class="s0">ignore_na : bool, default False</span>
            <span class="s0">Whether NA-values should be ignored for calculating the uniques. If</span>
            <span class="s0">True, the labels corresponding to missing values will be set to</span>
            <span class="s0">na_sentinel.</span>
        <span class="s0">mask : ndarray[bool], optional</span>
            <span class="s0">If not None, the mask is used as indicator for missing values</span>
            <span class="s0">(True = missing, False = valid) instead of `na_value` or</span>
            <span class="s0">condition &quot;val != val&quot;.</span>
        <span class="s0">return_inverse : bool, default False</span>
            <span class="s0">Whether the mapping of the original array values to their location</span>
            <span class="s0">in the vector of uniques should be returned.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[{{dtype}}]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t] (if return_inverse=True)</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, idx, count = count_prior, n = len(values)</span>
            <span class="s0">intp_t[:] labels</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">{{c_type}} val, na_value2</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">{{name}}VectorData *ud</span>
            <span class="s0">bint use_na_value, use_mask</span>
            <span class="s0">uint8_t[:] mask_values</span>

        <span class="s0">if return_inverse:</span>
            <span class="s0">labels = np.empty(n, dtype=np.intp)</span>
        <span class="s0">ud = uniques.data</span>
        <span class="s0">use_na_value = na_value is not None</span>
        <span class="s0">use_mask = mask is not None</span>

        <span class="s0">if use_mask:</span>
            <span class="s0">mask_values = mask.view(&quot;uint8&quot;)</span>

        <span class="s0">if use_na_value:</span>
            <span class="s0"># We need this na_value2 because we want to allow users</span>
            <span class="s0"># to *optionally* specify an NA sentinel *of the correct* type.</span>
            <span class="s0"># We use None, to make it optional, which requires `object` type</span>
            <span class="s0"># for the parameter. To please the compiler, we use na_value2,</span>
            <span class="s0"># which is only used if it's *specified*.</span>
            <span class="s0">na_value2 = {{to_c_type}}(na_value)</span>
        <span class="s0">else:</span>
            <span class="s0">na_value2 = {{to_c_type}}(0)</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">val = {{to_c_type}}(values[i])</span>

                <span class="s0">if ignore_na and use_mask:</span>
                    <span class="s0">if mask_values[i]:</span>
                        <span class="s0">labels[i] = na_sentinel</span>
                        <span class="s0">continue</span>
                <span class="s0">elif ignore_na and (</span>
                   <span class="s0">is_nan_{{c_type}}(val) or</span>
                   <span class="s0">(use_na_value and are_equivalent_{{c_type}}(val, na_value2))</span>
                <span class="s0">):</span>
                    <span class="s0"># if missing values do not count as unique values (i.e. if</span>
                    <span class="s0"># ignore_na is True), skip the hashtable entry for them,</span>
                    <span class="s0"># and replace the corresponding label with na_sentinel</span>
                    <span class="s0">labels[i] = na_sentinel</span>
                    <span class="s0">continue</span>

                <span class="s0">k = kh_get_{{dtype}}(self.table, val)</span>

                <span class="s0">if k == self.table.n_buckets:</span>
                    <span class="s0"># k hasn't been seen yet</span>
                    <span class="s0">k = kh_put_{{dtype}}(self.table, val, &amp;ret)</span>

                    <span class="s0">if needs_resize(ud):</span>
                        <span class="s0">with gil:</span>
                            <span class="s0">if uniques.external_view_exists:</span>
                                <span class="s0">raise ValueError(&quot;external reference to &quot;</span>
                                                 <span class="s0">&quot;uniques held, but &quot;</span>
                                                 <span class="s0">&quot;Vector.resize() needed&quot;)</span>
                            <span class="s0">uniques.resize()</span>
                    <span class="s0">append_data_{{dtype}}(ud, val)</span>
                    <span class="s0">if return_inverse:</span>
                        <span class="s0">self.table.vals[k] = count</span>
                        <span class="s0">labels[i] = count</span>
                        <span class="s0">count += 1</span>
                <span class="s0">elif return_inverse:</span>
                    <span class="s0"># k falls into a previous bucket</span>
                    <span class="s0"># only relevant in case we need to construct the inverse</span>
                    <span class="s0">idx = self.table.vals[k]</span>
                    <span class="s0">labels[i] = idx</span>

        <span class="s0">if return_inverse:</span>
            <span class="s0">return uniques.to_array(), labels.base  # .base -&gt; underlying ndarray</span>
        <span class="s0">return uniques.to_array()</span>

    <span class="s0">def unique(self, const {{dtype}}_t[:] values, bint return_inverse=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[{{dtype}}]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">return_inverse : bool, default False</span>
            <span class="s0">Whether the mapping of the original array values to their location</span>
            <span class="s0">in the vector of uniques should be returned.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[{{dtype}}]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t] (if return_inverse)</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">uniques = {{name}}Vector()</span>
        <span class="s0">return self._unique(values, uniques, ignore_na=False,</span>
                            <span class="s0">return_inverse=return_inverse)</span>

    <span class="s0">def factorize(self, const {{dtype}}_t[:] values, Py_ssize_t na_sentinel=-1,</span>
                  <span class="s0">object na_value=None, object mask=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Missing values are not included in the &quot;uniques&quot; for this method.</span>
        <span class="s0">The labels for any missing values will be set to &quot;na_sentinel&quot;</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[{{dtype}}]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">na_sentinel : Py_ssize_t, default -1</span>
            <span class="s0">Sentinel value used for all NA-values in inverse</span>
        <span class="s0">na_value : object, default None</span>
            <span class="s0">Value to identify as missing. If na_value is None, then</span>
            <span class="s0">any value &quot;val&quot; satisfying val != val is considered missing.</span>
            <span class="s0">If na_value is not None, then _additionally_, any value &quot;val&quot;</span>
            <span class="s0">satisfying val == na_value is considered missing.</span>
        <span class="s0">mask : ndarray[bool], optional</span>
            <span class="s0">If not None, the mask is used as indicator for missing values</span>
            <span class="s0">(True = missing, False = valid) instead of `na_value` or</span>
            <span class="s0">condition &quot;val != val&quot;.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[{{dtype}}]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t]</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">uniques_vector = {{name}}Vector()</span>
        <span class="s0">return self._unique(values, uniques_vector, na_sentinel=na_sentinel,</span>
                            <span class="s0">na_value=na_value, ignore_na=True, mask=mask,</span>
                            <span class="s0">return_inverse=True)</span>

    <span class="s0">def get_labels(self, const {{dtype}}_t[:] values, {{name}}Vector uniques,</span>
                   <span class="s0">Py_ssize_t count_prior=0, Py_ssize_t na_sentinel=-1,</span>
                   <span class="s0">object na_value=None):</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">_, labels = self._unique(values, uniques, count_prior=count_prior,</span>
                                 <span class="s0">na_sentinel=na_sentinel, na_value=na_value,</span>
                                 <span class="s0">ignore_na=True, return_inverse=True)</span>
        <span class="s0">return labels</span>

    <span class="s0">{{if dtype == 'int64'}}</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def get_labels_groupby(</span>
        <span class="s0">self, const {{dtype}}_t[:] values</span>
    <span class="s0">) -&gt; tuple[ndarray, ndarray]:</span>
        <span class="s0"># tuple[np.ndarray[np.intp], np.ndarray[{{dtype}}]]</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">intp_t[:] labels</span>
            <span class="s0">Py_ssize_t idx, count = 0</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">{{c_type}} val</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">{{name}}Vector uniques = {{name}}Vector()</span>
            <span class="s0">{{name}}VectorData *ud</span>

        <span class="s0">labels = np.empty(n, dtype=np.intp)</span>
        <span class="s0">ud = uniques.data</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">val = {{to_c_type}}(values[i])</span>

                <span class="s0"># specific for groupby</span>
                <span class="s0">if val &lt; 0:</span>
                    <span class="s0">labels[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">k = kh_get_{{dtype}}(self.table, val)</span>
                <span class="s0">if k != self.table.n_buckets:</span>
                    <span class="s0">idx = self.table.vals[k]</span>
                    <span class="s0">labels[i] = idx</span>
                <span class="s0">else:</span>
                    <span class="s0">k = kh_put_{{dtype}}(self.table, val, &amp;ret)</span>
                    <span class="s0">self.table.vals[k] = count</span>

                    <span class="s0">if needs_resize(ud):</span>
                        <span class="s0">with gil:</span>
                            <span class="s0">uniques.resize()</span>
                    <span class="s0">append_data_{{dtype}}(ud, val)</span>
                    <span class="s0">labels[i] = count</span>
                    <span class="s0">count += 1</span>

        <span class="s0">arr_uniques = uniques.to_array()</span>

        <span class="s0">return np.asarray(labels), arr_uniques</span>
    <span class="s0">{{endif}}</span>

<span class="s0">{{endfor}}</span>


<span class="s0">cdef class StringHashTable(HashTable):</span>
    <span class="s0"># these by-definition *must* be strings</span>
    <span class="s0"># or a sentinel np.nan / None missing value</span>
    <span class="s0">na_string_sentinel = '__nan__'</span>

    <span class="s0">def __init__(self, int64_t size_hint=1):</span>
        <span class="s0">self.table = kh_init_str()</span>
        <span class="s0">size_hint = min(kh_needed_n_buckets(size_hint), SIZE_HINT_LIMIT)</span>
        <span class="s0">kh_resize_str(self.table, size_hint)</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">if self.table is not NULL:</span>
            <span class="s0">kh_destroy_str(self.table)</span>
            <span class="s0">self.table = NULL</span>

    <span class="s0">def sizeof(self, deep: bool = False) -&gt; int:</span>
        <span class="s0">overhead = 4 * sizeof(uint32_t) + 3 * sizeof(uint32_t*)</span>
        <span class="s0">for_flags = max(1, self.table.n_buckets &gt;&gt; 5) * sizeof(uint32_t)</span>
        <span class="s0">for_pairs =  self.table.n_buckets * (sizeof(char *) +      # keys</span>
                                             <span class="s0">sizeof(Py_ssize_t))   # vals</span>
        <span class="s0">return overhead + for_flags + for_pairs</span>

    <span class="s0">def get_state(self) -&gt; dict[str, int]:</span>
        <span class="s0">&quot;&quot;&quot; returns infos about the state of the hashtable&quot;&quot;&quot;</span>
        <span class="s0">return {</span>
            <span class="s0">'n_buckets' : self.table.n_buckets,</span>
            <span class="s0">'size' : self.table.size,</span>
            <span class="s0">'n_occupied' : self.table.n_occupied,</span>
            <span class="s0">'upper_bound' : self.table.upper_bound,</span>
        <span class="s0">}</span>

    <span class="s0">cpdef get_item(self, str val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">const char *v</span>
        <span class="s0">v = get_c_string(val)</span>

        <span class="s0">k = kh_get_str(self.table, v)</span>
        <span class="s0">if k != self.table.n_buckets:</span>
            <span class="s0">return self.table.vals[k]</span>
        <span class="s0">else:</span>
            <span class="s0">raise KeyError(val)</span>

    <span class="s0">cpdef set_item(self, str key, Py_ssize_t val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">const char *v</span>

        <span class="s0">v = get_c_string(key)</span>

        <span class="s0">k = kh_put_str(self.table, v, &amp;ret)</span>
        <span class="s0">if kh_exist_str(self.table, k):</span>
            <span class="s0">self.table.vals[k] = val</span>
        <span class="s0">else:</span>
            <span class="s0">raise KeyError(key)</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def get_indexer(self, ndarray[object] values) -&gt; ndarray:</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">ndarray[intp_t] labels = np.empty(n, dtype=np.intp)</span>
            <span class="s0">intp_t *resbuf = &lt;intp_t*&gt;labels.data</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">kh_str_t *table = self.table</span>
            <span class="s0">const char *v</span>
            <span class="s0">const char **vecs</span>

        <span class="s0">vecs = &lt;const char **&gt;malloc(n * sizeof(char *))</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>
            <span class="s0">v = get_c_string(val)</span>
            <span class="s0">vecs[i] = v</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">k = kh_get_str(table, vecs[i])</span>
                <span class="s0">if k != table.n_buckets:</span>
                    <span class="s0">resbuf[i] = table.vals[k]</span>
                <span class="s0">else:</span>
                    <span class="s0">resbuf[i] = -1</span>

        <span class="s0">free(vecs)</span>
        <span class="s0">return labels</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def lookup(self, ndarray[object] values) -&gt; ndarray:</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">object val</span>
            <span class="s0">const char *v</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">intp_t[:] locs = np.empty(n, dtype=np.intp)</span>

        <span class="s0"># these by-definition *must* be strings</span>
        <span class="s0">vecs = &lt;const char **&gt;malloc(n * sizeof(char *))</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>

            <span class="s0">if isinstance(val, str):</span>
                <span class="s0"># GH#31499 if we have a np.str_ get_c_string won't recognize</span>
                <span class="s0">#  it as a str, even though isinstance does.</span>
                <span class="s0">v = get_c_string(&lt;str&gt;val)</span>
            <span class="s0">else:</span>
                <span class="s0">v = get_c_string(self.na_string_sentinel)</span>
            <span class="s0">vecs[i] = v</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">v = vecs[i]</span>
                <span class="s0">k = kh_get_str(self.table, v)</span>
                <span class="s0">if k != self.table.n_buckets:</span>
                    <span class="s0">locs[i] = self.table.vals[k]</span>
                <span class="s0">else:</span>
                    <span class="s0">locs[i] = -1</span>

        <span class="s0">free(vecs)</span>
        <span class="s0">return np.asarray(locs)</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def map_locations(self, ndarray[object] values) -&gt; None:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">object val</span>
            <span class="s0">const char *v</span>
            <span class="s0">const char **vecs</span>
            <span class="s0">khiter_t k</span>

        <span class="s0"># these by-definition *must* be strings</span>
        <span class="s0">vecs = &lt;const char **&gt;malloc(n * sizeof(char *))</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>

            <span class="s0">if isinstance(val, str):</span>
                <span class="s0"># GH#31499 if we have a np.str_ get_c_string won't recognize</span>
                <span class="s0">#  it as a str, even though isinstance does.</span>
                <span class="s0">v = get_c_string(&lt;str&gt;val)</span>
            <span class="s0">else:</span>
                <span class="s0">v = get_c_string(self.na_string_sentinel)</span>
            <span class="s0">vecs[i] = v</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">v = vecs[i]</span>
                <span class="s0">k = kh_put_str(self.table, v, &amp;ret)</span>
                <span class="s0">self.table.vals[k] = i</span>
        <span class="s0">free(vecs)</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">def _unique(self, ndarray[object] values, ObjectVector uniques,</span>
                <span class="s0">Py_ssize_t count_prior=0, Py_ssize_t na_sentinel=-1,</span>
                <span class="s0">object na_value=None, bint ignore_na=False,</span>
                <span class="s0">bint return_inverse=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[object]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">uniques : ObjectVector</span>
            <span class="s0">Vector into which uniques will be written</span>
        <span class="s0">count_prior : Py_ssize_t, default 0</span>
            <span class="s0">Number of existing entries in uniques</span>
        <span class="s0">na_sentinel : Py_ssize_t, default -1</span>
            <span class="s0">Sentinel value used for all NA-values in inverse</span>
        <span class="s0">na_value : object, default None</span>
            <span class="s0">Value to identify as missing. If na_value is None, then any value</span>
            <span class="s0">that is not a string is considered missing. If na_value is</span>
            <span class="s0">not None, then _additionally_ any value &quot;val&quot; satisfying</span>
            <span class="s0">val == na_value is considered missing.</span>
        <span class="s0">ignore_na : bool, default False</span>
            <span class="s0">Whether NA-values should be ignored for calculating the uniques. If</span>
            <span class="s0">True, the labels corresponding to missing values will be set to</span>
            <span class="s0">na_sentinel.</span>
        <span class="s0">return_inverse : bool, default False</span>
            <span class="s0">Whether the mapping of the original array values to their location</span>
            <span class="s0">in the vector of uniques should be returned.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[object]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t] (if return_inverse=True)</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, idx, count = count_prior, n = len(values)</span>
            <span class="s0">intp_t[:] labels</span>
            <span class="s0">int64_t[:] uindexer</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">object val</span>
            <span class="s0">const char *v</span>
            <span class="s0">const char **vecs</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">bint use_na_value</span>

        <span class="s0">if return_inverse:</span>
            <span class="s0">labels = np.zeros(n, dtype=np.intp)</span>
        <span class="s0">uindexer = np.empty(n, dtype=np.int64)</span>
        <span class="s0">use_na_value = na_value is not None</span>

        <span class="s0"># assign pointers and pre-filter out missing (if ignore_na)</span>
        <span class="s0">vecs = &lt;const char **&gt;malloc(n * sizeof(char *))</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>

            <span class="s0">if (ignore_na</span>
                <span class="s0">and (not isinstance(val, str)</span>
                     <span class="s0">or (use_na_value and val == na_value))):</span>
                <span class="s0"># if missing values do not count as unique values (i.e. if</span>
                <span class="s0"># ignore_na is True), we can skip the actual value, and</span>
                <span class="s0"># replace the label with na_sentinel directly</span>
                <span class="s0">labels[i] = na_sentinel</span>
            <span class="s0">else:</span>
                <span class="s0"># if ignore_na is False, we also stringify NaN/None/etc.</span>
                <span class="s0">try:</span>
                    <span class="s0">v = get_c_string(&lt;str&gt;val)</span>
                <span class="s0">except UnicodeEncodeError:</span>
                    <span class="s0">v = get_c_string(&lt;str&gt;repr(val))</span>
                <span class="s0">vecs[i] = v</span>

        <span class="s0"># compute</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">if ignore_na and labels[i] == na_sentinel:</span>
                    <span class="s0"># skip entries for ignored missing values (see above)</span>
                    <span class="s0">continue</span>

                <span class="s0">v = vecs[i]</span>
                <span class="s0">k = kh_get_str(self.table, v)</span>
                <span class="s0">if k == self.table.n_buckets:</span>
                    <span class="s0"># k hasn't been seen yet</span>
                    <span class="s0">k = kh_put_str(self.table, v, &amp;ret)</span>
                    <span class="s0">uindexer[count] = i</span>
                    <span class="s0">if return_inverse:</span>
                        <span class="s0">self.table.vals[k] = count</span>
                        <span class="s0">labels[i] = count</span>
                    <span class="s0">count += 1</span>
                <span class="s0">elif return_inverse:</span>
                    <span class="s0"># k falls into a previous bucket</span>
                    <span class="s0"># only relevant in case we need to construct the inverse</span>
                    <span class="s0">idx = self.table.vals[k]</span>
                    <span class="s0">labels[i] = idx</span>

        <span class="s0">free(vecs)</span>

        <span class="s0"># uniques</span>
        <span class="s0">for i in range(count):</span>
            <span class="s0">uniques.append(values[uindexer[i]])</span>

        <span class="s0">if return_inverse:</span>
            <span class="s0">return uniques.to_array(), labels.base  # .base -&gt; underlying ndarray</span>
        <span class="s0">return uniques.to_array()</span>

    <span class="s0">def unique(self, ndarray[object] values, bint return_inverse=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[object]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">return_inverse : bool, default False</span>
            <span class="s0">Whether the mapping of the original array values to their location</span>
            <span class="s0">in the vector of uniques should be returned.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[object]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t] (if return_inverse)</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">uniques = ObjectVector()</span>
        <span class="s0">return self._unique(values, uniques, ignore_na=False,</span>
                            <span class="s0">return_inverse=return_inverse)</span>

    <span class="s0">def factorize(self, ndarray[object] values, Py_ssize_t na_sentinel=-1,</span>
                  <span class="s0">object na_value=None, object mask=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Missing values are not included in the &quot;uniques&quot; for this method.</span>
        <span class="s0">The labels for any missing values will be set to &quot;na_sentinel&quot;</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[object]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">na_sentinel : Py_ssize_t, default -1</span>
            <span class="s0">Sentinel value used for all NA-values in inverse</span>
        <span class="s0">na_value : object, default None</span>
            <span class="s0">Value to identify as missing. If na_value is None, then any value</span>
            <span class="s0">that is not a string is considered missing. If na_value is</span>
            <span class="s0">not None, then _additionally_ any value &quot;val&quot; satisfying</span>
            <span class="s0">val == na_value is considered missing.</span>
        <span class="s0">mask : ndarray[bool], optional</span>
            <span class="s0">Not yet implemented for StringHashTable.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[object]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp]</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">uniques_vector = ObjectVector()</span>
        <span class="s0">return self._unique(values, uniques_vector, na_sentinel=na_sentinel,</span>
                            <span class="s0">na_value=na_value, ignore_na=True,</span>
                            <span class="s0">return_inverse=True)</span>

    <span class="s0">def get_labels(self, ndarray[object] values, ObjectVector uniques,</span>
                   <span class="s0">Py_ssize_t count_prior=0, Py_ssize_t na_sentinel=-1,</span>
                   <span class="s0">object na_value=None):</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">_, labels = self._unique(values, uniques, count_prior=count_prior,</span>
                                 <span class="s0">na_sentinel=na_sentinel, na_value=na_value,</span>
                                 <span class="s0">ignore_na=True, return_inverse=True)</span>
        <span class="s0">return labels</span>


<span class="s0">cdef class PyObjectHashTable(HashTable):</span>

    <span class="s0">def __init__(self, int64_t size_hint=1):</span>
        <span class="s0">self.table = kh_init_pymap()</span>
        <span class="s0">size_hint = min(kh_needed_n_buckets(size_hint), SIZE_HINT_LIMIT)</span>
        <span class="s0">kh_resize_pymap(self.table, size_hint)</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">if self.table is not NULL:</span>
            <span class="s0">kh_destroy_pymap(self.table)</span>
            <span class="s0">self.table = NULL</span>

    <span class="s0">def __len__(self) -&gt; int:</span>
        <span class="s0">return self.table.size</span>

    <span class="s0">def __contains__(self, object key) -&gt; bool:</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
        <span class="s0">hash(key)</span>

        <span class="s0">k = kh_get_pymap(self.table, &lt;PyObject*&gt;key)</span>
        <span class="s0">return k != self.table.n_buckets</span>

    <span class="s0">def sizeof(self, deep: bool = False) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; return the size of my table in bytes &quot;&quot;&quot;</span>
        <span class="s0">overhead = 4 * sizeof(uint32_t) + 3 * sizeof(uint32_t*)</span>
        <span class="s0">for_flags = max(1, self.table.n_buckets &gt;&gt; 5) * sizeof(uint32_t)</span>
        <span class="s0">for_pairs =  self.table.n_buckets * (sizeof(PyObject *) +  # keys</span>
                                             <span class="s0">sizeof(Py_ssize_t))   # vals</span>
        <span class="s0">return overhead + for_flags + for_pairs</span>

    <span class="s0">def get_state(self) -&gt; dict[str, int]:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">returns infos about the current state of the hashtable like size,</span>
        <span class="s0">number of buckets and so on.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return {</span>
            <span class="s0">'n_buckets' : self.table.n_buckets,</span>
            <span class="s0">'size' : self.table.size,</span>
            <span class="s0">'n_occupied' : self.table.n_occupied,</span>
            <span class="s0">'upper_bound' : self.table.upper_bound,</span>
        <span class="s0">}</span>

    <span class="s0">cpdef get_item(self, object val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>

        <span class="s0">k = kh_get_pymap(self.table, &lt;PyObject*&gt;val)</span>
        <span class="s0">if k != self.table.n_buckets:</span>
            <span class="s0">return self.table.vals[k]</span>
        <span class="s0">else:</span>
            <span class="s0">raise KeyError(val)</span>

    <span class="s0">cpdef set_item(self, object key, Py_ssize_t val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">char* buf</span>

        <span class="s0">hash(key)</span>

        <span class="s0">k = kh_put_pymap(self.table, &lt;PyObject*&gt;key, &amp;ret)</span>
        <span class="s0">if kh_exist_pymap(self.table, k):</span>
            <span class="s0">self.table.vals[k] = val</span>
        <span class="s0">else:</span>
            <span class="s0">raise KeyError(key)</span>

    <span class="s0">def map_locations(self, ndarray[object] values) -&gt; None:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">object val</span>
            <span class="s0">khiter_t k</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>
            <span class="s0">hash(val)</span>

            <span class="s0">k = kh_put_pymap(self.table, &lt;PyObject*&gt;val, &amp;ret)</span>
            <span class="s0">self.table.vals[k] = i</span>

    <span class="s0">def lookup(self, ndarray[object] values) -&gt; ndarray:</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, n = len(values)</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">object val</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">intp_t[:] locs = np.empty(n, dtype=np.intp)</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>
            <span class="s0">hash(val)</span>

            <span class="s0">k = kh_get_pymap(self.table, &lt;PyObject*&gt;val)</span>
            <span class="s0">if k != self.table.n_buckets:</span>
                <span class="s0">locs[i] = self.table.vals[k]</span>
            <span class="s0">else:</span>
                <span class="s0">locs[i] = -1</span>

        <span class="s0">return np.asarray(locs)</span>

    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">def _unique(self, ndarray[object] values, ObjectVector uniques,</span>
                <span class="s0">Py_ssize_t count_prior=0, Py_ssize_t na_sentinel=-1,</span>
                <span class="s0">object na_value=None, bint ignore_na=False,</span>
                <span class="s0">bint return_inverse=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[object]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">uniques : ObjectVector</span>
            <span class="s0">Vector into which uniques will be written</span>
        <span class="s0">count_prior : Py_ssize_t, default 0</span>
            <span class="s0">Number of existing entries in uniques</span>
        <span class="s0">na_sentinel : Py_ssize_t, default -1</span>
            <span class="s0">Sentinel value used for all NA-values in inverse</span>
        <span class="s0">na_value : object, default None</span>
            <span class="s0">Value to identify as missing. If na_value is None, then None _plus_</span>
            <span class="s0">any value &quot;val&quot; satisfying val != val is considered missing.</span>
            <span class="s0">If na_value is not None, then _additionally_, any value &quot;val&quot;</span>
            <span class="s0">satisfying val == na_value is considered missing.</span>
        <span class="s0">ignore_na : bool, default False</span>
            <span class="s0">Whether NA-values should be ignored for calculating the uniques. If</span>
            <span class="s0">True, the labels corresponding to missing values will be set to</span>
            <span class="s0">na_sentinel.</span>
        <span class="s0">return_inverse : bool, default False</span>
            <span class="s0">Whether the mapping of the original array values to their location</span>
            <span class="s0">in the vector of uniques should be returned.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[object]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t] (if return_inverse=True)</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, idx, count = count_prior, n = len(values)</span>
            <span class="s0">intp_t[:] labels</span>
            <span class="s0">int ret = 0</span>
            <span class="s0">object val</span>
            <span class="s0">khiter_t k</span>
            <span class="s0">bint use_na_value</span>

        <span class="s0">if return_inverse:</span>
            <span class="s0">labels = np.empty(n, dtype=np.intp)</span>
        <span class="s0">use_na_value = na_value is not None</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0">val = values[i]</span>
            <span class="s0">hash(val)</span>

            <span class="s0">if ignore_na and (</span>
                <span class="s0">checknull(val)</span>
                <span class="s0">or (use_na_value and val == na_value)</span>
            <span class="s0">):</span>
                <span class="s0"># if missing values do not count as unique values (i.e. if</span>
                <span class="s0"># ignore_na is True), skip the hashtable entry for them, and</span>
                <span class="s0"># replace the corresponding label with na_sentinel</span>
                <span class="s0">labels[i] = na_sentinel</span>
                <span class="s0">continue</span>

            <span class="s0">k = kh_get_pymap(self.table, &lt;PyObject*&gt;val)</span>
            <span class="s0">if k == self.table.n_buckets:</span>
                <span class="s0"># k hasn't been seen yet</span>
                <span class="s0">k = kh_put_pymap(self.table, &lt;PyObject*&gt;val, &amp;ret)</span>
                <span class="s0">uniques.append(val)</span>
                <span class="s0">if return_inverse:</span>
                    <span class="s0">self.table.vals[k] = count</span>
                    <span class="s0">labels[i] = count</span>
                    <span class="s0">count += 1</span>
            <span class="s0">elif return_inverse:</span>
                <span class="s0"># k falls into a previous bucket</span>
                <span class="s0"># only relevant in case we need to construct the inverse</span>
                <span class="s0">idx = self.table.vals[k]</span>
                <span class="s0">labels[i] = idx</span>

        <span class="s0">if return_inverse:</span>
            <span class="s0">return uniques.to_array(), labels.base  # .base -&gt; underlying ndarray</span>
        <span class="s0">return uniques.to_array()</span>

    <span class="s0">def unique(self, ndarray[object] values, bint return_inverse=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[object]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">return_inverse : bool, default False</span>
            <span class="s0">Whether the mapping of the original array values to their location</span>
            <span class="s0">in the vector of uniques should be returned.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[object]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t] (if return_inverse)</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">uniques = ObjectVector()</span>
        <span class="s0">return self._unique(values, uniques, ignore_na=False,</span>
                            <span class="s0">return_inverse=return_inverse)</span>

    <span class="s0">def factorize(self, ndarray[object] values, Py_ssize_t na_sentinel=-1,</span>
                  <span class="s0">object na_value=None, object mask=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Calculate unique values and labels (no sorting!)</span>

        <span class="s0">Missing values are not included in the &quot;uniques&quot; for this method.</span>
        <span class="s0">The labels for any missing values will be set to &quot;na_sentinel&quot;</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : ndarray[object]</span>
            <span class="s0">Array of values of which unique will be calculated</span>
        <span class="s0">na_sentinel : Py_ssize_t, default -1</span>
            <span class="s0">Sentinel value used for all NA-values in inverse</span>
        <span class="s0">na_value : object, default None</span>
            <span class="s0">Value to identify as missing. If na_value is None, then None _plus_</span>
            <span class="s0">any value &quot;val&quot; satisfying val != val is considered missing.</span>
            <span class="s0">If na_value is not None, then _additionally_, any value &quot;val&quot;</span>
            <span class="s0">satisfying val == na_value is considered missing.</span>
        <span class="s0">mask : ndarray[bool], optional</span>
            <span class="s0">Not yet implemented for PyObjectHashTable.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">uniques : ndarray[object]</span>
            <span class="s0">Unique values of input, not sorted</span>
        <span class="s0">labels : ndarray[intp_t]</span>
            <span class="s0">The labels from values to uniques</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">uniques_vector = ObjectVector()</span>
        <span class="s0">return self._unique(values, uniques_vector, na_sentinel=na_sentinel,</span>
                            <span class="s0">na_value=na_value, ignore_na=True,</span>
                            <span class="s0">return_inverse=True)</span>

    <span class="s0">def get_labels(self, ndarray[object] values, ObjectVector uniques,</span>
                   <span class="s0">Py_ssize_t count_prior=0, Py_ssize_t na_sentinel=-1,</span>
                   <span class="s0">object na_value=None):</span>
        <span class="s0"># -&gt; np.ndarray[np.intp]</span>
        <span class="s0">_, labels = self._unique(values, uniques, count_prior=count_prior,</span>
                                 <span class="s0">na_sentinel=na_sentinel, na_value=na_value,</span>
                                 <span class="s0">ignore_na=True, return_inverse=True)</span>
        <span class="s0">return labels</span>
</pre>
</body>
</html>