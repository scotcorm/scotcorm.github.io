<html>
<head>
<title>imshow_utils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
imshow_utils.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Vendored code from scikit-image in order to limit the number of dependencies 
Extracted from scikit-image/skimage/exposure/exposure.py 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>

<span class="s1">_integer_types = (</span>
    <span class="s1">np.byte</span><span class="s2">,</span>
    <span class="s1">np.ubyte</span><span class="s2">,  </span><span class="s3"># 8 bits</span>
    <span class="s1">np.short</span><span class="s2">,</span>
    <span class="s1">np.ushort</span><span class="s2">,  </span><span class="s3"># 16 bits</span>
    <span class="s1">np.intc</span><span class="s2">,</span>
    <span class="s1">np.uintc</span><span class="s2">,  </span><span class="s3"># 16 or 32 or 64 bits</span>
    <span class="s1">np.int_</span><span class="s2">,</span>
    <span class="s1">np.uint</span><span class="s2">,  </span><span class="s3"># 32 or 64 bits</span>
    <span class="s1">np.longlong</span><span class="s2">,</span>
    <span class="s1">np.ulonglong</span><span class="s2">,</span>
<span class="s1">)  </span><span class="s3"># 64 bits</span>
<span class="s1">_integer_ranges = {t: (np.iinfo(t).min</span><span class="s2">, </span><span class="s1">np.iinfo(t).max) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_integer_types}</span>
<span class="s1">dtype_range = {</span>
    <span class="s1">np.bool_: (</span><span class="s2">False, True</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.bool8: (</span><span class="s2">False, True</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.float16: (-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.float32: (-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.float64: (-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>
<span class="s1">dtype_range.update(_integer_ranges)</span>


<span class="s1">DTYPE_RANGE = dtype_range.copy()</span>
<span class="s1">DTYPE_RANGE.update((d.__name__</span><span class="s2">, </span><span class="s1">limits) </span><span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">limits </span><span class="s2">in </span><span class="s1">dtype_range.items())</span>
<span class="s1">DTYPE_RANGE.update(</span>
    <span class="s1">{</span>
        <span class="s5">&quot;uint10&quot;</span><span class="s1">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">10 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;uint12&quot;</span><span class="s1">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">12 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;uint14&quot;</span><span class="s1">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">14 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;bool&quot;</span><span class="s1">: dtype_range[np.bool_]</span><span class="s2">,</span>
        <span class="s5">&quot;float&quot;</span><span class="s1">: dtype_range[np.float64]</span><span class="s2">,</span>
    <span class="s1">}</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">intensity_range(image</span><span class="s2">, </span><span class="s1">range_values=</span><span class="s5">&quot;image&quot;</span><span class="s2">, </span><span class="s1">clip_negative=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return image intensity range (min, max) based on desired value type. 
 
    Parameters 
    ---------- 
    image : array 
        Input image. 
    range_values : str or 2-tuple, optional 
        The image intensity range is configured by this parameter. 
        The possible values for this parameter are enumerated below. 
 
        'image' 
            Return image min/max as the range. 
        'dtype' 
            Return min/max of the image's dtype as the range. 
        dtype-name 
            Return intensity range based on desired `dtype`. Must be valid key 
            in `DTYPE_RANGE`. Note: `image` is ignored for this range type. 
        2-tuple 
            Return `range_values` as min/max intensities. Note that there's no 
            reason to use this function if you just want to specify the 
            intensity range explicitly. This option is included for functions 
            that use `intensity_range` to support all desired range types. 
 
    clip_negative : bool, optional 
        If True, clip the negative range (i.e. return 0 for min intensity) 
        even if the image dtype allows negative values. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">range_values == </span><span class="s5">&quot;dtype&quot;</span><span class="s1">:</span>
        <span class="s1">range_values = image.dtype.type</span>

    <span class="s2">if </span><span class="s1">range_values == </span><span class="s5">&quot;image&quot;</span><span class="s1">:</span>
        <span class="s1">i_min = np.min(image)</span>
        <span class="s1">i_max = np.max(image)</span>
    <span class="s2">elif </span><span class="s1">range_values </span><span class="s2">in </span><span class="s1">DTYPE_RANGE:</span>
        <span class="s1">i_min</span><span class="s2">, </span><span class="s1">i_max = DTYPE_RANGE[range_values]</span>
        <span class="s2">if </span><span class="s1">clip_negative:</span>
            <span class="s1">i_min = </span><span class="s4">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">i_min</span><span class="s2">, </span><span class="s1">i_max = range_values</span>
    <span class="s2">return </span><span class="s1">i_min</span><span class="s2">, </span><span class="s1">i_max</span>


<span class="s2">def </span><span class="s1">_output_dtype(dtype_or_range):</span>
    <span class="s0">&quot;&quot;&quot;Determine the output dtype for rescale_intensity. 
 
    The dtype is determined according to the following rules: 
    - if ``dtype_or_range`` is a dtype, that is the output dtype. 
    - if ``dtype_or_range`` is a dtype string, that is the dtype used, unless 
      it is not a NumPy data type (e.g. 'uint12' for 12-bit unsigned integers), 
      in which case the data type that can contain it will be used 
      (e.g. uint16 in this case). 
    - if ``dtype_or_range`` is a pair of values, the output data type will be 
      float. 
 
    Parameters 
    ---------- 
    dtype_or_range : type, string, or 2-tuple of int/float 
        The desired range for the output, expressed as either a NumPy dtype or 
        as a (min, max) pair of numbers. 
 
    Returns 
    ------- 
    out_dtype : type 
        The data type appropriate for the desired output. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">type(dtype_or_range) </span><span class="s2">in </span><span class="s1">[list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray]:</span>
        <span class="s3"># pair of values: always return float.</span>
        <span class="s2">return </span><span class="s1">np.float_</span>
    <span class="s2">if </span><span class="s1">type(dtype_or_range) == type:</span>
        <span class="s3"># already a type: return it</span>
        <span class="s2">return </span><span class="s1">dtype_or_range</span>
    <span class="s2">if </span><span class="s1">dtype_or_range </span><span class="s2">in </span><span class="s1">DTYPE_RANGE:</span>
        <span class="s3"># string key in DTYPE_RANGE dictionary</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># if it's a canonical numpy dtype, convert</span>
            <span class="s2">return </span><span class="s1">np.dtype(dtype_or_range).type</span>
        <span class="s2">except </span><span class="s1">TypeError:  </span><span class="s3"># uint10, uint12, uint14</span>
            <span class="s3"># otherwise, return uint16</span>
            <span class="s2">return </span><span class="s1">np.uint16</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s5">&quot;Incorrect value for out_range, should be a valid image data &quot;</span>
            <span class="s5">&quot;type or a pair of values, got %s.&quot; </span><span class="s1">% str(dtype_or_range)</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">rescale_intensity(image</span><span class="s2">, </span><span class="s1">in_range=</span><span class="s5">&quot;image&quot;</span><span class="s2">, </span><span class="s1">out_range=</span><span class="s5">&quot;dtype&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return image after stretching or shrinking its intensity levels. 
 
    The desired intensity range of the input and output, `in_range` and 
    `out_range` respectively, are used to stretch or shrink the intensity range 
    of the input image. See examples below. 
 
    Parameters 
    ---------- 
    image : array 
        Image array. 
    in_range, out_range : str or 2-tuple, optional 
        Min and max intensity values of input and output image. 
        The possible values for this parameter are enumerated below. 
 
        'image' 
            Use image min/max as the intensity range. 
        'dtype' 
            Use min/max of the image's dtype as the intensity range. 
        dtype-name 
            Use intensity range based on desired `dtype`. Must be valid key 
            in `DTYPE_RANGE`. 
        2-tuple 
            Use `range_values` as explicit min/max intensities. 
 
    Returns 
    ------- 
    out : array 
        Image array after rescaling its intensity. This image is the same dtype 
        as the input image. 
 
    Notes 
    ----- 
    .. versionchanged:: 0.17 
        The dtype of the output array has changed to match the output dtype, or 
        float if the output range is specified by a pair of floats. 
 
    See Also 
    -------- 
    equalize_hist 
 
    Examples 
    -------- 
    By default, the min/max intensities of the input image are stretched to 
    the limits allowed by the image's dtype, since `in_range` defaults to 
    'image' and `out_range` defaults to 'dtype': 
 
    &gt;&gt;&gt; image = np.array([51, 102, 153], dtype=np.uint8) 
    &gt;&gt;&gt; rescale_intensity(image) 
    array([  0, 127, 255], dtype=uint8) 
 
    It's easy to accidentally convert an image dtype from uint8 to float: 
 
    &gt;&gt;&gt; 1.0 * image 
    array([ 51., 102., 153.]) 
 
    Use `rescale_intensity` to rescale to the proper range for float dtypes: 
 
    &gt;&gt;&gt; image_float = 1.0 * image 
    &gt;&gt;&gt; rescale_intensity(image_float) 
    array([0. , 0.5, 1. ]) 
 
    To maintain the low contrast of the original, use the `in_range` parameter: 
 
    &gt;&gt;&gt; rescale_intensity(image_float, in_range=(0, 255)) 
    array([0.2, 0.4, 0.6]) 
 
    If the min/max value of `in_range` is more/less than the min/max image 
    intensity, then the intensity levels are clipped: 
 
    &gt;&gt;&gt; rescale_intensity(image_float, in_range=(0, 102)) 
    array([0.5, 1. , 1. ]) 
 
    If you have an image with signed integers but want to rescale the image to 
    just the positive range, use the `out_range` parameter. In that case, the 
    output dtype will be float: 
 
    &gt;&gt;&gt; image = np.array([-10, 0, 10], dtype=np.int8) 
    &gt;&gt;&gt; rescale_intensity(image, out_range=(0, 127)) 
    array([  0. ,  63.5, 127. ]) 
 
    To get the desired range with a specific dtype, use ``.astype()``: 
 
    &gt;&gt;&gt; rescale_intensity(image, out_range=(0, 127)).astype(np.int8) 
    array([  0,  63, 127], dtype=int8) 
 
    If the input image is constant, the output will be clipped directly to the 
    output range: 
    &gt;&gt;&gt; image = np.array([130, 130, 130], dtype=np.int32) 
    &gt;&gt;&gt; rescale_intensity(image, out_range=(0, 127)).astype(np.int32) 
    array([127, 127, 127], dtype=int32) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">out_range </span><span class="s2">in </span><span class="s1">[</span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s5">&quot;image&quot;</span><span class="s1">]:</span>
        <span class="s1">out_dtype = _output_dtype(image.dtype.type)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">out_dtype = _output_dtype(out_range)</span>

    <span class="s1">imin</span><span class="s2">, </span><span class="s1">imax = map(float</span><span class="s2">, </span><span class="s1">intensity_range(image</span><span class="s2">, </span><span class="s1">in_range))</span>
    <span class="s1">omin</span><span class="s2">, </span><span class="s1">omax = map(</span>
        <span class="s1">float</span><span class="s2">, </span><span class="s1">intensity_range(image</span><span class="s2">, </span><span class="s1">out_range</span><span class="s2">, </span><span class="s1">clip_negative=(imin &gt;= </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">np.any(np.isnan([imin</span><span class="s2">, </span><span class="s1">imax</span><span class="s2">, </span><span class="s1">omin</span><span class="s2">, </span><span class="s1">omax])):</span>
        <span class="s1">warn(</span>
            <span class="s5">&quot;One or more intensity levels are NaN. Rescaling will broadcast &quot;</span>
            <span class="s5">&quot;NaN to the full image. Provide intensity levels yourself to &quot;</span>
            <span class="s5">&quot;avoid this. E.g. with np.nanmin(image), np.nanmax(image).&quot;</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">image = np.clip(image</span><span class="s2">, </span><span class="s1">imin</span><span class="s2">, </span><span class="s1">imax)</span>

    <span class="s2">if </span><span class="s1">imin != imax:</span>
        <span class="s1">image = (image - imin) / (imax - imin)</span>
        <span class="s2">return </span><span class="s1">np.asarray(image * (omax - omin) + omin</span><span class="s2">, </span><span class="s1">dtype=out_dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.clip(image</span><span class="s2">, </span><span class="s1">omin</span><span class="s2">, </span><span class="s1">omax).astype(out_dtype)</span>
</pre>
</body>
</html>