<html>
<head>
<title>cb_rules.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cb_rules.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
 
Build call-back mechanism for f2py2e. 
 
Copyright 2000 Pearu Peterson all rights reserved, 
Pearu Peterson &lt;pearu@ioc.ee&gt; 
Permission to use, modify, and distribute this software is given under the 
terms of the NumPy License. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
$Date: 2005/07/20 11:27:58 $ 
Pearu Peterson 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">__version__</span>
<span class="s3">from </span><span class="s1">.auxfuncs </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">applyrules</span><span class="s3">, </span><span class="s1">debugcapi</span><span class="s3">, </span><span class="s1">dictappend</span><span class="s3">, </span><span class="s1">errmess</span><span class="s3">, </span><span class="s1">getargs</span><span class="s3">, </span><span class="s1">hasnote</span><span class="s3">, </span><span class="s1">isarray</span><span class="s3">,</span>
    <span class="s1">iscomplex</span><span class="s3">, </span><span class="s1">iscomplexarray</span><span class="s3">, </span><span class="s1">iscomplexfunction</span><span class="s3">, </span><span class="s1">isfunction</span><span class="s3">, </span><span class="s1">isintent_c</span><span class="s3">,</span>
    <span class="s1">isintent_hide</span><span class="s3">, </span><span class="s1">isintent_in</span><span class="s3">, </span><span class="s1">isintent_inout</span><span class="s3">, </span><span class="s1">isintent_nothide</span><span class="s3">,</span>
    <span class="s1">isintent_out</span><span class="s3">, </span><span class="s1">isoptional</span><span class="s3">, </span><span class="s1">isrequired</span><span class="s3">, </span><span class="s1">isscalar</span><span class="s3">, </span><span class="s1">isstring</span><span class="s3">,</span>
    <span class="s1">isstringfunction</span><span class="s3">, </span><span class="s1">issubroutine</span><span class="s3">, </span><span class="s1">l_and</span><span class="s3">, </span><span class="s1">l_not</span><span class="s3">, </span><span class="s1">l_or</span><span class="s3">, </span><span class="s1">outmess</span><span class="s3">, </span><span class="s1">replace</span><span class="s3">,</span>
    <span class="s1">stripcomma</span><span class="s3">, </span><span class="s1">throw_error</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">cfuncs</span>

<span class="s1">f2py_version = __version__.version</span>


<span class="s0">################## Rules for callback function ##############</span>

<span class="s1">cb_routine_rules = {</span>
    <span class="s4">'cbtypedefs'</span><span class="s1">: </span><span class="s4">'typedef #rctype#(*#name#_typedef)(#optargs_td##args_td##strarglens_td##noargs#);'</span><span class="s3">,</span>
    <span class="s4">'body'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#begintitle# 
typedef struct { 
    PyObject *capi; 
    PyTupleObject *args_capi; 
    int nofargs; 
    jmp_buf jmpbuf; 
} #name#_t; 
 
#if defined(F2PY_THREAD_LOCAL_DECL) &amp;&amp; !defined(F2PY_USE_PYTHON_TLS) 
 
static F2PY_THREAD_LOCAL_DECL #name#_t *_active_#name# = NULL; 
 
static #name#_t *swap_active_#name#(#name#_t *ptr) { 
    #name#_t *prev = _active_#name#; 
    _active_#name# = ptr; 
    return prev; 
} 
 
static #name#_t *get_active_#name#(void) { 
    return _active_#name#; 
} 
 
#else 
 
static #name#_t *swap_active_#name#(#name#_t *ptr) { 
    char *key = &quot;__f2py_cb_#name#&quot;; 
    return (#name#_t *)F2PySwapThreadLocalCallbackPtr(key, ptr); 
} 
 
static #name#_t *get_active_#name#(void) { 
    char *key = &quot;__f2py_cb_#name#&quot;; 
    return (#name#_t *)F2PyGetThreadLocalCallbackPtr(key); 
} 
 
#endif 
 
/*typedef #rctype#(*#name#_typedef)(#optargs_td##args_td##strarglens_td##noargs#);*/ 
#static# #rctype# #callbackname# (#optargs##args##strarglens##noargs#) { 
    #name#_t cb_local = { NULL, NULL, 0 }; 
    #name#_t *cb = NULL; 
    PyTupleObject *capi_arglist = NULL; 
    PyObject *capi_return = NULL; 
    PyObject *capi_tmp = NULL; 
    PyObject *capi_arglist_list = NULL; 
    int capi_j,capi_i = 0; 
    int capi_longjmp_ok = 1; 
#decl# 
#ifdef F2PY_REPORT_ATEXIT 
f2py_cb_start_clock(); 
#endif 
    cb = get_active_#name#(); 
    if (cb == NULL) { 
        capi_longjmp_ok = 0; 
        cb = &amp;cb_local; 
    } 
    capi_arglist = cb-&gt;args_capi; 
    CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">cb:Call-back function #name# (maxnofargs=#maxnofargs#(-#nofoptargs#))</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
    CFUNCSMESSPY(</span><span class="s3">\&quot;</span><span class="s4">cb:#name#_capi=</span><span class="s3">\&quot;</span><span class="s4">,cb-&gt;capi); 
    if (cb-&gt;capi==NULL) { 
        capi_longjmp_ok = 0; 
        cb-&gt;capi = PyObject_GetAttrString(#modulename#_module,</span><span class="s3">\&quot;</span><span class="s4">#argname#</span><span class="s3">\&quot;</span><span class="s4">); 
        CFUNCSMESSPY(</span><span class="s3">\&quot;</span><span class="s4">cb:#name#_capi=</span><span class="s3">\&quot;</span><span class="s4">,cb-&gt;capi); 
    } 
    if (cb-&gt;capi==NULL) { 
        PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">cb: Callback #argname# not defined (as an argument or module #modulename# attribute).</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        goto capi_fail; 
    } 
    if (F2PyCapsule_Check(cb-&gt;capi)) { 
    #name#_typedef #name#_cptr; 
    #name#_cptr = F2PyCapsule_AsVoidPtr(cb-&gt;capi); 
    #returncptr#(*#name#_cptr)(#optargs_nm##args_nm##strarglens_nm#); 
    #return# 
    } 
    if (capi_arglist==NULL) { 
        capi_longjmp_ok = 0; 
        capi_tmp = PyObject_GetAttrString(#modulename#_module,</span><span class="s3">\&quot;</span><span class="s4">#argname#_extra_args</span><span class="s3">\&quot;</span><span class="s4">); 
        if (capi_tmp) { 
            capi_arglist = (PyTupleObject *)PySequence_Tuple(capi_tmp); 
            Py_DECREF(capi_tmp); 
            if (capi_arglist==NULL) { 
                PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">Failed to convert #modulename#.#argname#_extra_args to tuple.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
                goto capi_fail; 
            } 
        } else { 
            PyErr_Clear(); 
            capi_arglist = (PyTupleObject *)Py_BuildValue(</span><span class="s3">\&quot;</span><span class="s4">()</span><span class="s3">\&quot;</span><span class="s4">); 
        } 
    } 
    if (capi_arglist == NULL) { 
        PyErr_SetString(#modulename#_error,</span><span class="s3">\&quot;</span><span class="s4">Callback #argname# argument list is not set.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        goto capi_fail; 
    } 
#setdims# 
#ifdef PYPY_VERSION 
#define CAPI_ARGLIST_SETITEM(idx, value) PyList_SetItem((PyObject *)capi_arglist_list, idx, value) 
    capi_arglist_list = PySequence_List(capi_arglist); 
    if (capi_arglist_list == NULL) goto capi_fail; 
#else 
#define CAPI_ARGLIST_SETITEM(idx, value) PyTuple_SetItem((PyObject *)capi_arglist, idx, value) 
#endif 
#pyobjfrom# 
#undef CAPI_ARGLIST_SETITEM 
#ifdef PYPY_VERSION 
    CFUNCSMESSPY(</span><span class="s3">\&quot;</span><span class="s4">cb:capi_arglist=</span><span class="s3">\&quot;</span><span class="s4">,capi_arglist_list); 
#else 
    CFUNCSMESSPY(</span><span class="s3">\&quot;</span><span class="s4">cb:capi_arglist=</span><span class="s3">\&quot;</span><span class="s4">,capi_arglist); 
#endif 
    CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">cb:Call-back calling Python function #argname#.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#ifdef F2PY_REPORT_ATEXIT 
f2py_cb_start_call_clock(); 
#endif 
#ifdef PYPY_VERSION 
    capi_return = PyObject_CallObject(cb-&gt;capi,(PyObject *)capi_arglist_list); 
    Py_DECREF(capi_arglist_list); 
    capi_arglist_list = NULL; 
#else 
    capi_return = PyObject_CallObject(cb-&gt;capi,(PyObject *)capi_arglist); 
#endif 
#ifdef F2PY_REPORT_ATEXIT 
f2py_cb_stop_call_clock(); 
#endif 
    CFUNCSMESSPY(</span><span class="s3">\&quot;</span><span class="s4">cb:capi_return=</span><span class="s3">\&quot;</span><span class="s4">,capi_return); 
    if (capi_return == NULL) { 
        fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">capi_return is NULL</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
        goto capi_fail; 
    } 
    if (capi_return == Py_None) { 
        Py_DECREF(capi_return); 
        capi_return = Py_BuildValue(</span><span class="s3">\&quot;</span><span class="s4">()</span><span class="s3">\&quot;</span><span class="s4">); 
    } 
    else if (!PyTuple_Check(capi_return)) { 
        capi_return = Py_BuildValue(</span><span class="s3">\&quot;</span><span class="s4">(N)</span><span class="s3">\&quot;</span><span class="s4">,capi_return); 
    } 
    capi_j = PyTuple_Size(capi_return); 
    capi_i = 0; 
#frompyobj# 
    CFUNCSMESS(</span><span class="s3">\&quot;</span><span class="s4">cb:#name#:successful</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
    Py_DECREF(capi_return); 
#ifdef F2PY_REPORT_ATEXIT 
f2py_cb_stop_clock(); 
#endif 
    goto capi_return_pt; 
capi_fail: 
    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">Call-back #name# failed.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
    Py_XDECREF(capi_return); 
    Py_XDECREF(capi_arglist_list); 
    if (capi_longjmp_ok) { 
        longjmp(cb-&gt;jmpbuf,-1); 
    } 
capi_return_pt: 
    ; 
#return# 
} 
#endtitle# 
&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'setjmp.h'</span><span class="s3">, </span><span class="s4">'CFUNCSMESS'</span><span class="s3">, </span><span class="s4">'F2PY_THREAD_LOCAL_DECL'</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s4">'maxnofargs'</span><span class="s1">: </span><span class="s4">'#maxnofargs#'</span><span class="s3">,</span>
    <span class="s4">'nofoptargs'</span><span class="s1">: </span><span class="s4">'#nofoptargs#'</span><span class="s3">,</span>
    <span class="s4">'docstr'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">def #argname#(#docsignature#): return #docreturn#</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\\</span>
<span class="s4">#docstrsigns#&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">'latexdocstr'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
{{}</span><span class="s3">\\</span><span class="s4">verb@def #argname#(#latexdocsignature#): return #docreturn#@{}} 
#routnote# 
 
#latexdocstrsigns#&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">'docstrshort'</span><span class="s1">: </span><span class="s4">'def #argname#(#docsignature#): return #docreturn#'</span>
<span class="s1">}</span>
<span class="s1">cb_rout_rules = [</span>
    <span class="s1">{  </span><span class="s0"># Init</span>
        <span class="s4">'separatorsfor'</span><span class="s1">: {</span><span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'args'</span><span class="s1">: </span><span class="s4">','</span><span class="s3">, </span><span class="s4">'optargs'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'pyobjfrom'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'freemem'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'args_td'</span><span class="s1">: </span><span class="s4">','</span><span class="s3">, </span><span class="s4">'optargs_td'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
                          <span class="s4">'args_nm'</span><span class="s1">: </span><span class="s4">','</span><span class="s3">, </span><span class="s4">'optargs_nm'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
                          <span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'setdims'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'docstrsigns'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">n&quot;</span><span class="s3">\n</span><span class="s4">&quot;'</span><span class="s3">,</span>
                          <span class="s4">'latexdocstrsigns'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'latexdocstrreq'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'latexdocstropt'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s4">'latexdocstrout'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">, </span><span class="s4">'latexdocstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span>
                          <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'/*decl*/'</span><span class="s3">, </span><span class="s4">'pyobjfrom'</span><span class="s1">: </span><span class="s4">'/*pyobjfrom*/'</span><span class="s3">, </span><span class="s4">'frompyobj'</span><span class="s1">: </span><span class="s4">'/*frompyobj*/'</span><span class="s3">,</span>
        <span class="s4">'args'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'optargs'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'return'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'strarglens'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'freemem'</span><span class="s1">: </span><span class="s4">'/*freemem*/'</span><span class="s3">,</span>
        <span class="s4">'args_td'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'optargs_td'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'strarglens_td'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'args_nm'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'optargs_nm'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'strarglens_nm'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'noargs'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'setdims'</span><span class="s1">: </span><span class="s4">'/*setdims*/'</span><span class="s3">,</span>
        <span class="s4">'docstrsigns'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'latexdocstrsigns'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'docstrreq'</span><span class="s1">: </span><span class="s4">'    Required arguments:'</span><span class="s3">,</span>
        <span class="s4">'docstropt'</span><span class="s1">: </span><span class="s4">'    Optional arguments:'</span><span class="s3">,</span>
        <span class="s4">'docstrout'</span><span class="s1">: </span><span class="s4">'    Return objects:'</span><span class="s3">,</span>
        <span class="s4">'docstrcbs'</span><span class="s1">: </span><span class="s4">'    Call-back functions:'</span><span class="s3">,</span>
        <span class="s4">'docreturn'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'docsign'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'docsignopt'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
        <span class="s4">'latexdocstrreq'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Required arguments:'</span><span class="s3">,</span>
        <span class="s4">'latexdocstropt'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Optional arguments:'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrout'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Return objects:'</span><span class="s3">,</span>
        <span class="s4">'latexdocstrcbs'</span><span class="s1">: </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">noindent Call-back functions:'</span><span class="s3">,</span>
        <span class="s4">'routnote'</span><span class="s1">: {hasnote: </span><span class="s4">'--- #note#'</span><span class="s3">, </span><span class="s1">l_not(hasnote): </span><span class="s4">''</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># Function</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    #ctype# return_value;'</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    CFUNCSMESS(&quot;cb:Getting return_value-&gt;&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">'    if (capi_j&gt;capi_i)</span><span class="s3">\n        </span><span class="s4">GETSCALARFROMPYTUPLE(capi_return,capi_i++,&amp;return_value,#ctype#,&quot;#ctype#_from_pyobj failed in converting return_value of call-back function #name# to C #ctype#</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s3">,</span>
                      <span class="s1">{debugcapi:</span>
                       <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n&quot;,return_value);'</span><span class="s1">}</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#ctype#_from_pyobj'</span><span class="s3">, </span><span class="s1">{debugcapi: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}</span><span class="s3">, </span><span class="s4">'GETSCALARFROMPYTUPLE'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: </span><span class="s4">'    return return_value;'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isfunction</span><span class="s3">, </span><span class="s1">l_not(isstringfunction)</span><span class="s3">, </span><span class="s1">l_not(iscomplexfunction))</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># String function</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: {debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;debug-capi:cb:#name#:%d:</span><span class="s3">\\</span><span class="s4">n&quot;,return_value_len);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args'</span><span class="s1">: </span><span class="s4">'#ctype# return_value,int return_value_len'</span><span class="s3">,</span>
        <span class="s4">'args_nm'</span><span class="s1">: </span><span class="s4">'return_value,&amp;return_value_len'</span><span class="s3">,</span>
        <span class="s4">'args_td'</span><span class="s1">: </span><span class="s4">'#ctype# ,int'</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    CFUNCSMESS(&quot;cb:Getting return_value-&gt;</span><span class="s3">\\</span><span class="s4">&quot;&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot;    if (capi_j&gt;capi_i) 
        GETSTRFROMPYTUPLE(capi_return,capi_i++,return_value,return_value_len);&quot;&quot;&quot;</span><span class="s3">,</span>
                      <span class="s1">{debugcapi:</span>
                       <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#</span><span class="s3">\\</span><span class="s4">&quot;.</span><span class="s3">\\</span><span class="s4">n&quot;,return_value);'</span><span class="s1">}</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#ctype#_from_pyobj'</span><span class="s3">, </span><span class="s1">{debugcapi: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s4">'string.h'</span><span class="s3">, </span><span class="s4">'GETSTRFROMPYTUPLE'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: </span><span class="s4">'return;'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isstringfunction</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># Complex function</span>
        <span class="s4">'optargs'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#ifndef F2PY_CB_RETURNCOMPLEX 
#ctype# *return_value 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'optargs_nm'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#ifndef F2PY_CB_RETURNCOMPLEX 
return_value 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'optargs_td'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#ifndef F2PY_CB_RETURNCOMPLEX 
#ctype# * 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#ifdef F2PY_CB_RETURNCOMPLEX 
    #ctype# return_value; 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    CFUNCSMESS(&quot;cb:Getting return_value-&gt;&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (capi_j&gt;capi_i) 
#ifdef F2PY_CB_RETURNCOMPLEX 
        GETSCALARFROMPYTUPLE(capi_return,capi_i++,&amp;return_value,#ctype#,</span><span class="s3">\&quot;</span><span class="s4">#ctype#_from_pyobj failed in converting return_value of call-back function #name# to C #ctype#</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#else 
        GETSCALARFROMPYTUPLE(capi_return,capi_i++,return_value,#ctype#,</span><span class="s3">\&quot;</span><span class="s4">#ctype#_from_pyobj failed in converting return_value of call-back function #name# to C #ctype#</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
                      <span class="s1">{debugcapi: </span><span class="s4">&quot;&quot;&quot; 
#ifdef F2PY_CB_RETURNCOMPLEX 
    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">,(return_value).r,(return_value).i); 
#else 
    fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">,(*return_value).r,(*return_value).i); 
#endif 
 
&quot;&quot;&quot;</span><span class="s1">}</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'return'</span><span class="s1">: </span><span class="s4">&quot;&quot;&quot; 
#ifdef F2PY_CB_RETURNCOMPLEX 
    return return_value; 
#else 
    return; 
#endif 
&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#ctype#_from_pyobj'</span><span class="s3">, </span><span class="s1">{debugcapi: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s4">'string.h'</span><span class="s3">, </span><span class="s4">'GETSCALARFROMPYTUPLE'</span><span class="s3">, </span><span class="s4">'#ctype#'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: iscomplexfunction</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{</span><span class="s4">'docstrout'</span><span class="s1">: </span><span class="s4">'        #pydocsignout#'</span><span class="s3">,</span>
     <span class="s4">'latexdocstrout'</span><span class="s1">: [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsignout#@{}}'</span><span class="s3">,</span>
                        <span class="s1">{hasnote: </span><span class="s4">'--- #note#'</span><span class="s1">}]</span><span class="s3">,</span>
     <span class="s4">'docreturn'</span><span class="s1">: </span><span class="s4">'#rname#,'</span><span class="s3">,</span>
     <span class="s4">'_check'</span><span class="s1">: isfunction}</span><span class="s3">,</span>
    <span class="s1">{</span><span class="s4">'_check'</span><span class="s1">: issubroutine</span><span class="s3">, </span><span class="s4">'return'</span><span class="s1">: </span><span class="s4">'return;'</span><span class="s1">}</span>
<span class="s1">]</span>

<span class="s1">cb_arg_rules = [</span>
    <span class="s1">{  </span><span class="s0"># Doc</span>
        <span class="s4">'docstropt'</span><span class="s1">: {l_and(isoptional</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'        #pydocsign#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstrreq'</span><span class="s1">: {l_and(isrequired</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'        #pydocsign#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docstrout'</span><span class="s1">: {isintent_out: </span><span class="s4">'        #pydocsignout#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'latexdocstropt'</span><span class="s1">: {l_and(isoptional</span><span class="s3">, </span><span class="s1">isintent_nothide): [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsign#@{}}'</span><span class="s3">,</span>
                                                                 <span class="s1">{hasnote: </span><span class="s4">'--- #note#'</span><span class="s1">}]}</span><span class="s3">,</span>
        <span class="s4">'latexdocstrreq'</span><span class="s1">: {l_and(isrequired</span><span class="s3">, </span><span class="s1">isintent_nothide): [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsign#@{}}'</span><span class="s3">,</span>
                                                                 <span class="s1">{hasnote: </span><span class="s4">'--- #note#'</span><span class="s1">}]}</span><span class="s3">,</span>
        <span class="s4">'latexdocstrout'</span><span class="s1">: {isintent_out: [</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">item[]{{}</span><span class="s3">\\</span><span class="s4">verb@#pydocsignout#@{}}'</span><span class="s3">,</span>
                                          <span class="s1">{l_and(hasnote</span><span class="s3">, </span><span class="s1">isintent_hide): </span><span class="s4">'--- #note#'</span><span class="s3">,</span>
                                           <span class="s1">l_and(hasnote</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'--- See above.'</span><span class="s1">}]}</span><span class="s3">,</span>
        <span class="s4">'docsign'</span><span class="s1">: {l_and(isrequired</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'#varname#,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'docsignopt'</span><span class="s1">: {l_and(isoptional</span><span class="s3">, </span><span class="s1">isintent_nothide): </span><span class="s4">'#varname#,'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{</span>
        <span class="s4">'args'</span><span class="s1">: {</span>
            <span class="s1">l_and(isscalar</span><span class="s3">, </span><span class="s1">isintent_c): </span><span class="s4">'#ctype# #varname_i#'</span><span class="s3">,</span>
            <span class="s1">l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(isintent_c)): </span><span class="s4">'#ctype# *#varname_i#_cb_capi'</span><span class="s3">,</span>
            <span class="s1">isarray: </span><span class="s4">'#ctype# *#varname_i#'</span><span class="s3">,</span>
            <span class="s1">isstring: </span><span class="s4">'#ctype# #varname_i#'</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_nm'</span><span class="s1">: {</span>
            <span class="s1">l_and(isscalar</span><span class="s3">, </span><span class="s1">isintent_c): </span><span class="s4">'#varname_i#'</span><span class="s3">,</span>
            <span class="s1">l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(isintent_c)): </span><span class="s4">'#varname_i#_cb_capi'</span><span class="s3">,</span>
            <span class="s1">isarray: </span><span class="s4">'#varname_i#'</span><span class="s3">,</span>
            <span class="s1">isstring: </span><span class="s4">'#varname_i#'</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'args_td'</span><span class="s1">: {</span>
            <span class="s1">l_and(isscalar</span><span class="s3">, </span><span class="s1">isintent_c): </span><span class="s4">'#ctype#'</span><span class="s3">,</span>
            <span class="s1">l_and(isscalar</span><span class="s3">, </span><span class="s1">l_not(isintent_c)): </span><span class="s4">'#ctype# *'</span><span class="s3">,</span>
            <span class="s1">isarray: </span><span class="s4">'#ctype# *'</span><span class="s3">,</span>
            <span class="s1">isstring: </span><span class="s4">'#ctype#'</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: {l_or(isscalar</span><span class="s3">, </span><span class="s1">isarray</span><span class="s3">, </span><span class="s1">isstring): </span><span class="s4">'#ctype#'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s0"># untested with multiple args</span>
        <span class="s4">'strarglens'</span><span class="s1">: {isstring: </span><span class="s4">',int #varname_i#_cb_len'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'strarglens_td'</span><span class="s1">: {isstring: </span><span class="s4">',int'</span><span class="s1">}</span><span class="s3">,  </span><span class="s0"># untested with multiple args</span>
        <span class="s0"># untested with multiple args</span>
        <span class="s4">'strarglens_nm'</span><span class="s1">: {isstring: </span><span class="s4">',#varname_i#_cb_len'</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{  </span><span class="s0"># Scalars</span>
        <span class="s4">'decl'</span><span class="s1">: {l_not(isintent_c): </span><span class="s4">'    #ctype# #varname_i#=(*#varname_i#_cb_capi);'</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'error'</span><span class="s1">: {l_and(isintent_c</span><span class="s3">, </span><span class="s1">isintent_out</span><span class="s3">,</span>
                        <span class="s1">throw_error(</span><span class="s4">'intent(c,out) is forbidden for callback scalar arguments'</span><span class="s1">)):</span>
                  <span class="s4">''</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    CFUNCSMESS(&quot;cb:Getting #varname#-&gt;&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{isintent_out:</span>
                       <span class="s4">'    if (capi_j&gt;capi_i)</span><span class="s3">\n        </span><span class="s4">GETSCALARFROMPYTUPLE(capi_return,capi_i++,#varname_i#_cb_capi,#ctype#,&quot;#ctype#_from_pyobj failed in converting argument #varname# of call-back function #name# to C #ctype#</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">l_and(l_not(iscomplex)</span><span class="s3">, </span><span class="s1">isintent_c)):</span>
                          <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n&quot;,#varname_i#);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">l_and(l_not(iscomplex)</span><span class="s3">, </span><span class="s1">l_not( isintent_c))):</span>
                          <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n&quot;,*#varname_i#_cb_capi);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">l_and(iscomplex</span><span class="s3">, </span><span class="s1">isintent_c)):</span>
                          <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n&quot;,(#varname_i#).r,(#varname_i#).i);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{l_and(debugcapi</span><span class="s3">, </span><span class="s1">l_and(iscomplex</span><span class="s3">, </span><span class="s1">l_not( isintent_c))):</span>
                          <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#.</span><span class="s3">\\</span><span class="s4">n&quot;,(*#varname_i#_cb_capi).r,(*#varname_i#_cb_capi).i);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [{isintent_out: [</span><span class="s4">'#ctype#_from_pyobj'</span><span class="s3">, </span><span class="s4">'GETSCALARFROMPYTUPLE'</span><span class="s1">]}</span><span class="s3">,</span>
                 <span class="s1">{debugcapi: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isscalar</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: [{isintent_in: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (cb-&gt;nofargs&gt;capi_i) 
        if (CAPI_ARGLIST_SETITEM(capi_i++,pyobj_from_#ctype#1(#varname_i#))) 
            goto capi_fail;&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{isintent_inout: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (cb-&gt;nofargs&gt;capi_i) 
        if (CAPI_ARGLIST_SETITEM(capi_i++,pyarr_from_p_#ctype#1(#varname_i#_cb_capi))) 
            goto capi_fail;&quot;&quot;&quot;</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [{isintent_in: </span><span class="s4">'pyobj_from_#ctype#1'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{isintent_inout: </span><span class="s4">'pyarr_from_p_#ctype#1'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{iscomplex: </span><span class="s4">'#ctype#'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isscalar</span><span class="s3">, </span><span class="s1">isintent_nothide)</span><span class="s3">,</span>
        <span class="s4">'_optional'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{  </span><span class="s0"># String</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    CFUNCSMESS(&quot;cb:Getting #varname#-&gt;</span><span class="s3">\\</span><span class="s4">&quot;&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot;    if (capi_j&gt;capi_i) 
        GETSTRFROMPYTUPLE(capi_return,capi_i++,#varname_i#,#varname_i#_cb_len);&quot;&quot;&quot;</span><span class="s3">,</span>
                      <span class="s1">{debugcapi:</span>
                       <span class="s4">'    fprintf(stderr,&quot;#showvalueformat#</span><span class="s3">\\</span><span class="s4">&quot;:%d:.</span><span class="s3">\\</span><span class="s4">n&quot;,#varname_i#,#varname_i#_cb_len);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'#ctype#'</span><span class="s3">, </span><span class="s4">'GETSTRFROMPYTUPLE'</span><span class="s3">,</span>
                 <span class="s1">{debugcapi: </span><span class="s4">'CFUNCSMESS'</span><span class="s1">}</span><span class="s3">, </span><span class="s4">'string.h'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isstring</span><span class="s3">, </span><span class="s1">isintent_out)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;debug-capi:cb:#varname#=</span><span class="s3">\\</span><span class="s4">&quot;#showvalueformat#</span><span class="s3">\\</span><span class="s4">&quot;:%d:</span><span class="s3">\\</span><span class="s4">n&quot;,#varname_i#,#varname_i#_cb_len);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{isintent_in: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (cb-&gt;nofargs&gt;capi_i) 
        if (CAPI_ARGLIST_SETITEM(capi_i++,pyobj_from_#ctype#1size(#varname_i#,#varname_i#_cb_len))) 
            goto capi_fail;&quot;&quot;&quot;</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{isintent_inout: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (cb-&gt;nofargs&gt;capi_i) { 
        int #varname_i#_cb_dims[] = {#varname_i#_cb_len}; 
        if (CAPI_ARGLIST_SETITEM(capi_i++,pyarr_from_p_#ctype#1(#varname_i#,#varname_i#_cb_dims))) 
            goto capi_fail; 
    }&quot;&quot;&quot;</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [{isintent_in: </span><span class="s4">'pyobj_from_#ctype#1size'</span><span class="s1">}</span><span class="s3">,</span>
                 <span class="s1">{isintent_inout: </span><span class="s4">'pyarr_from_p_#ctype#1'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isstring</span><span class="s3">, </span><span class="s1">isintent_nothide)</span><span class="s3">,</span>
        <span class="s4">'_optional'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s0"># Array ...</span>
    <span class="s1">{</span>
        <span class="s4">'decl'</span><span class="s1">: </span><span class="s4">'    npy_intp #varname_i#_Dims[#rank#] = {#rank*[-1]#};'</span><span class="s3">,</span>
        <span class="s4">'setdims'</span><span class="s1">: </span><span class="s4">'    #cbsetdims#;'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isarray</span><span class="s3">,</span>
        <span class="s4">'_depend'</span><span class="s1">: </span><span class="s4">''</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">{</span>
        <span class="s4">'pyobjfrom'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;debug-capi:cb:#varname#</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">{isintent_c: </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (cb-&gt;nofargs&gt;capi_i) { 
        int itemsize_ = #atype# == NPY_STRING ? 1 : 0; 
        /*XXX: Hmm, what will destroy this array??? */ 
        PyArrayObject *tmp_arr = (PyArrayObject *)PyArray_New(&amp;PyArray_Type,#rank#,#varname_i#_Dims,#atype#,NULL,(char*)#varname_i#,itemsize_,NPY_ARRAY_CARRAY,NULL); 
&quot;&quot;&quot;</span><span class="s3">,</span>
                       <span class="s1">l_not(isintent_c): </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">if (cb-&gt;nofargs&gt;capi_i) { 
        int itemsize_ = #atype# == NPY_STRING ? 1 : 0; 
        /*XXX: Hmm, what will destroy this array??? */ 
        PyArrayObject *tmp_arr = (PyArrayObject *)PyArray_New(&amp;PyArray_Type,#rank#,#varname_i#_Dims,#atype#,NULL,(char*)#varname_i#,itemsize_,NPY_ARRAY_FARRAY,NULL); 
&quot;&quot;&quot;</span><span class="s3">,</span>
                       <span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot; 
        if (tmp_arr==NULL) 
            goto capi_fail; 
        if (CAPI_ARGLIST_SETITEM(capi_i++,(PyObject *)tmp_arr)) 
            goto capi_fail; 
}&quot;&quot;&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_nothide</span><span class="s3">, </span><span class="s1">l_or(isintent_in</span><span class="s3">, </span><span class="s1">isintent_inout))</span><span class="s3">,</span>
        <span class="s4">'_optional'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'frompyobj'</span><span class="s1">: [{debugcapi: </span><span class="s4">'    CFUNCSMESS(&quot;cb:Getting #varname#-&gt;&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot;    if (capi_j&gt;capi_i) { 
        PyArrayObject *rv_cb_arr = NULL; 
        if ((capi_tmp = PyTuple_GetItem(capi_return,capi_i++))==NULL) goto capi_fail; 
        rv_cb_arr =  array_from_pyobj(#atype#,#varname_i#_Dims,#rank#,F2PY_INTENT_IN&quot;&quot;&quot;</span><span class="s3">,</span>
                      <span class="s1">{isintent_c: </span><span class="s4">'|F2PY_INTENT_C'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s4">&quot;&quot;&quot;,capi_tmp); 
        if (rv_cb_arr == NULL) { 
            fprintf(stderr,</span><span class="s3">\&quot;</span><span class="s4">rv_cb_arr is NULL</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\&quot;</span><span class="s4">); 
            goto capi_fail; 
        } 
        MEMCOPY(#varname_i#,PyArray_DATA(rv_cb_arr),PyArray_NBYTES(rv_cb_arr)); 
        if (capi_tmp != (PyObject *)rv_cb_arr) { 
            Py_DECREF(rv_cb_arr); 
        } 
    }&quot;&quot;&quot;</span><span class="s3">,</span>
                      <span class="s1">{debugcapi: </span><span class="s4">'    fprintf(stderr,&quot;&lt;-.</span><span class="s3">\\</span><span class="s4">n&quot;);'</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'need'</span><span class="s1">: [</span><span class="s4">'MEMCOPY'</span><span class="s3">, </span><span class="s1">{iscomplexarray: </span><span class="s4">'#ctype#'</span><span class="s1">}]</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: l_and(isarray</span><span class="s3">, </span><span class="s1">isintent_out)</span>
    <span class="s1">}</span><span class="s3">, </span><span class="s1">{</span>
        <span class="s4">'docreturn'</span><span class="s1">: </span><span class="s4">'#varname#,'</span><span class="s3">,</span>
        <span class="s4">'_check'</span><span class="s1">: isintent_out</span>
    <span class="s1">}</span>
<span class="s1">]</span>

<span class="s0">################## Build call-back module #############</span>
<span class="s1">cb_map = {}</span>


<span class="s3">def </span><span class="s1">buildcallbacks(m):</span>
    <span class="s1">cb_map[m[</span><span class="s4">'name'</span><span class="s1">]] = []</span>
    <span class="s3">for </span><span class="s1">bi </span><span class="s3">in </span><span class="s1">m[</span><span class="s4">'body'</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">bi[</span><span class="s4">'block'</span><span class="s1">] == </span><span class="s4">'interface'</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">bi[</span><span class="s4">'body'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">b:</span>
                    <span class="s1">buildcallback(b</span><span class="s3">, </span><span class="s1">m[</span><span class="s4">'name'</span><span class="s1">])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">errmess(</span><span class="s4">'warning: empty body for %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (m[</span><span class="s4">'name'</span><span class="s1">]))</span>


<span class="s3">def </span><span class="s1">buildcallback(rout</span><span class="s3">, </span><span class="s1">um):</span>
    <span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">capi_maps</span>

    <span class="s1">outmess(</span><span class="s4">'    Constructing call-back function &quot;cb_%s_in_%s&quot;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
            <span class="s1">(rout[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">um))</span>
    <span class="s1">args</span><span class="s3">, </span><span class="s1">depargs = getargs(rout)</span>
    <span class="s1">capi_maps.depargs = depargs</span>
    <span class="s1">var = rout[</span><span class="s4">'vars'</span><span class="s1">]</span>
    <span class="s1">vrd = capi_maps.cb_routsign2map(rout</span><span class="s3">, </span><span class="s1">um)</span>
    <span class="s1">rd = dictappend({}</span><span class="s3">, </span><span class="s1">vrd)</span>
    <span class="s1">cb_map[um].append([rout[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rd[</span><span class="s4">'name'</span><span class="s1">]])</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">cb_rout_rules:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](rout)) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
            <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">rout)</span>
            <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
    <span class="s1">savevrd = {}</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a </span><span class="s3">in </span><span class="s1">enumerate(args):</span>
        <span class="s1">vrd = capi_maps.cb_sign2map(a</span><span class="s3">, </span><span class="s1">var[a]</span><span class="s3">, </span><span class="s1">index=i)</span>
        <span class="s1">savevrd[a] = vrd</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">cb_arg_rules:</span>
            <span class="s3">if </span><span class="s4">'_depend' </span><span class="s3">in </span><span class="s1">r:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s4">'_optional' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">isoptional(var[a]):</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](var[a])) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
                <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">var[a])</span>
                <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
                <span class="s3">if </span><span class="s4">'_break' </span><span class="s3">in </span><span class="s1">r:</span>
                    <span class="s3">break</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s1">vrd = savevrd[a]</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">cb_arg_rules:</span>
            <span class="s3">if </span><span class="s4">'_depend' </span><span class="s3">in </span><span class="s1">r:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'_optional' </span><span class="s3">not in </span><span class="s1">r) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_optional' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">isrequired(var[a])):</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](var[a])) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
                <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">var[a])</span>
                <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
                <span class="s3">if </span><span class="s4">'_break' </span><span class="s3">in </span><span class="s1">r:</span>
                    <span class="s3">break</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">depargs:</span>
        <span class="s1">vrd = savevrd[a]</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">cb_arg_rules:</span>
            <span class="s3">if </span><span class="s4">'_depend' </span><span class="s3">not in </span><span class="s1">r:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s4">'_optional' </span><span class="s3">in </span><span class="s1">r:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">in </span><span class="s1">r </span><span class="s3">and </span><span class="s1">r[</span><span class="s4">'_check'</span><span class="s1">](var[a])) </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'_check' </span><span class="s3">not in </span><span class="s1">r):</span>
                <span class="s1">ar = applyrules(r</span><span class="s3">, </span><span class="s1">vrd</span><span class="s3">, </span><span class="s1">var[a])</span>
                <span class="s1">rd = dictappend(rd</span><span class="s3">, </span><span class="s1">ar)</span>
                <span class="s3">if </span><span class="s4">'_break' </span><span class="s3">in </span><span class="s1">r:</span>
                    <span class="s3">break</span>
    <span class="s3">if </span><span class="s4">'args' </span><span class="s3">in </span><span class="s1">rd </span><span class="s3">and </span><span class="s4">'optargs' </span><span class="s3">in </span><span class="s1">rd:</span>
        <span class="s3">if </span><span class="s1">isinstance(rd[</span><span class="s4">'optargs'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">rd[</span><span class="s4">'optargs'</span><span class="s1">] = rd[</span><span class="s4">'optargs'</span><span class="s1">] + [</span><span class="s4">&quot;&quot;&quot; 
#ifndef F2PY_CB_RETURNCOMPLEX 
, 
#endif 
&quot;&quot;&quot;</span><span class="s1">]</span>
            <span class="s1">rd[</span><span class="s4">'optargs_nm'</span><span class="s1">] = rd[</span><span class="s4">'optargs_nm'</span><span class="s1">] + [</span><span class="s4">&quot;&quot;&quot; 
#ifndef F2PY_CB_RETURNCOMPLEX 
, 
#endif 
&quot;&quot;&quot;</span><span class="s1">]</span>
            <span class="s1">rd[</span><span class="s4">'optargs_td'</span><span class="s1">] = rd[</span><span class="s4">'optargs_td'</span><span class="s1">] + [</span><span class="s4">&quot;&quot;&quot; 
#ifndef F2PY_CB_RETURNCOMPLEX 
, 
#endif 
&quot;&quot;&quot;</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">isinstance(rd[</span><span class="s4">'docreturn'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">rd[</span><span class="s4">'docreturn'</span><span class="s1">] = stripcomma(</span>
            <span class="s1">replace(</span><span class="s4">'#docreturn#'</span><span class="s3">, </span><span class="s1">{</span><span class="s4">'docreturn'</span><span class="s1">: rd[</span><span class="s4">'docreturn'</span><span class="s1">]}))</span>
    <span class="s1">optargs = stripcomma(replace(</span><span class="s4">'#docsignopt#'</span><span class="s3">,</span>
                                 <span class="s1">{</span><span class="s4">'docsignopt'</span><span class="s1">: rd[</span><span class="s4">'docsignopt'</span><span class="s1">]}</span>
                                 <span class="s1">))</span>
    <span class="s3">if </span><span class="s1">optargs == </span><span class="s4">''</span><span class="s1">:</span>
        <span class="s1">rd[</span><span class="s4">'docsignature'</span><span class="s1">] = stripcomma(</span>
            <span class="s1">replace(</span><span class="s4">'#docsign#'</span><span class="s3">, </span><span class="s1">{</span><span class="s4">'docsign'</span><span class="s1">: rd[</span><span class="s4">'docsign'</span><span class="s1">]}))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">rd[</span><span class="s4">'docsignature'</span><span class="s1">] = replace(</span><span class="s4">'#docsign#[#docsignopt#]'</span><span class="s3">,</span>
                                     <span class="s1">{</span><span class="s4">'docsign'</span><span class="s1">: rd[</span><span class="s4">'docsign'</span><span class="s1">]</span><span class="s3">,</span>
                                      <span class="s4">'docsignopt'</span><span class="s1">: optargs</span><span class="s3">,</span>
                                      <span class="s1">})</span>
    <span class="s1">rd[</span><span class="s4">'latexdocsignature'</span><span class="s1">] = rd[</span><span class="s4">'docsignature'</span><span class="s1">].replace(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">_'</span><span class="s1">)</span>
    <span class="s1">rd[</span><span class="s4">'latexdocsignature'</span><span class="s1">] = rd[</span><span class="s4">'latexdocsignature'</span><span class="s1">].replace(</span><span class="s4">','</span><span class="s3">, </span><span class="s4">', '</span><span class="s1">)</span>
    <span class="s1">rd[</span><span class="s4">'docstrsigns'</span><span class="s1">] = []</span>
    <span class="s1">rd[</span><span class="s4">'latexdocstrsigns'</span><span class="s1">] = []</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'docstrreq'</span><span class="s3">, </span><span class="s4">'docstropt'</span><span class="s3">, </span><span class="s4">'docstrout'</span><span class="s3">, </span><span class="s4">'docstrcbs'</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">rd </span><span class="s3">and </span><span class="s1">isinstance(rd[k]</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">rd[</span><span class="s4">'docstrsigns'</span><span class="s1">] = rd[</span><span class="s4">'docstrsigns'</span><span class="s1">] + rd[k]</span>
        <span class="s1">k = </span><span class="s4">'latex' </span><span class="s1">+ k</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">rd </span><span class="s3">and </span><span class="s1">isinstance(rd[k]</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">rd[</span><span class="s4">'latexdocstrsigns'</span><span class="s1">] = rd[</span><span class="s4">'latexdocstrsigns'</span><span class="s1">] + rd[k][</span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">] +\</span>
                <span class="s1">[</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">begin{description}'</span><span class="s1">] + rd[k][</span><span class="s5">1</span><span class="s1">:] +\</span>
                <span class="s1">[</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">end{description}'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s4">'args' </span><span class="s3">not in </span><span class="s1">rd:</span>
        <span class="s1">rd[</span><span class="s4">'args'</span><span class="s1">] = </span><span class="s4">''</span>
        <span class="s1">rd[</span><span class="s4">'args_td'</span><span class="s1">] = </span><span class="s4">''</span>
        <span class="s1">rd[</span><span class="s4">'args_nm'</span><span class="s1">] = </span><span class="s4">''</span>
    <span class="s3">if not </span><span class="s1">(rd.get(</span><span class="s4">'args'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">rd.get(</span><span class="s4">'optargs'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">rd.get(</span><span class="s4">'strarglens'</span><span class="s1">)):</span>
        <span class="s1">rd[</span><span class="s4">'noargs'</span><span class="s1">] = </span><span class="s4">'void'</span>

    <span class="s1">ar = applyrules(cb_routine_rules</span><span class="s3">, </span><span class="s1">rd)</span>
    <span class="s1">cfuncs.callbacks[rd[</span><span class="s4">'name'</span><span class="s1">]] = ar[</span><span class="s4">'body'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">isinstance(ar[</span><span class="s4">'need'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">ar[</span><span class="s4">'need'</span><span class="s1">] = [ar[</span><span class="s4">'need'</span><span class="s1">]]</span>

    <span class="s3">if </span><span class="s4">'need' </span><span class="s3">in </span><span class="s1">rd:</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">cfuncs.typedefs.keys():</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">in </span><span class="s1">rd[</span><span class="s4">'need'</span><span class="s1">]:</span>
                <span class="s1">ar[</span><span class="s4">'need'</span><span class="s1">].append(t)</span>

    <span class="s1">cfuncs.typedefs_generated[rd[</span><span class="s4">'name'</span><span class="s1">] + </span><span class="s4">'_typedef'</span><span class="s1">] = ar[</span><span class="s4">'cbtypedefs'</span><span class="s1">]</span>
    <span class="s1">ar[</span><span class="s4">'need'</span><span class="s1">].append(rd[</span><span class="s4">'name'</span><span class="s1">] + </span><span class="s4">'_typedef'</span><span class="s1">)</span>
    <span class="s1">cfuncs.needs[rd[</span><span class="s4">'name'</span><span class="s1">]] = ar[</span><span class="s4">'need'</span><span class="s1">]</span>

    <span class="s1">capi_maps.lcb2_map[rd[</span><span class="s4">'name'</span><span class="s1">]] = {</span><span class="s4">'maxnofargs'</span><span class="s1">: ar[</span><span class="s4">'maxnofargs'</span><span class="s1">]</span><span class="s3">,</span>
                                      <span class="s4">'nofoptargs'</span><span class="s1">: ar[</span><span class="s4">'nofoptargs'</span><span class="s1">]</span><span class="s3">,</span>
                                      <span class="s4">'docstr'</span><span class="s1">: ar[</span><span class="s4">'docstr'</span><span class="s1">]</span><span class="s3">,</span>
                                      <span class="s4">'latexdocstr'</span><span class="s1">: ar[</span><span class="s4">'latexdocstr'</span><span class="s1">]</span><span class="s3">,</span>
                                      <span class="s4">'argname'</span><span class="s1">: rd[</span><span class="s4">'argname'</span><span class="s1">]</span>
                                      <span class="s1">}</span>
    <span class="s1">outmess(</span><span class="s4">'      %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (ar[</span><span class="s4">'docstrshort'</span><span class="s1">]))</span>
    <span class="s3">return</span>
<span class="s0">################## Build call-back function #############</span>
</pre>
</body>
</html>