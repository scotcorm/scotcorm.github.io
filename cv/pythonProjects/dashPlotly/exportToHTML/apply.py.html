<html>
<head>
<title>apply.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
apply.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">abc</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">DefaultDict</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">Iterator</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._config </span><span class="s0">import </span><span class="s1">option_context</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">lib</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">AggFuncType</span><span class="s0">,</span>
    <span class="s1">AggFuncTypeBase</span><span class="s0">,</span>
    <span class="s1">AggFuncTypeDict</span><span class="s0">,</span>
    <span class="s1">AggObjType</span><span class="s0">,</span>
    <span class="s1">Axis</span><span class="s0">,</span>
    <span class="s1">NDFrameT</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s0">import </span><span class="s1">is_nested_object</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_dict_like</span><span class="s0">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_sequence</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s0">,</span>
    <span class="s1">ABCNDFrame</span><span class="s0">,</span>
    <span class="s1">ABCSeries</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core.algorithms </span><span class="s0">import </span><span class="s1">safe_sort</span>
<span class="s0">from </span><span class="s1">pandas.core.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataError</span><span class="s0">,</span>
    <span class="s1">SelectionMixin</span><span class="s0">,</span>
    <span class="s1">SpecificationError</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.core.common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">create_series_with_explicit_dtype</span><span class="s0">,</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">DataFrame</span><span class="s0">,</span>
        <span class="s1">Index</span><span class="s0">,</span>
        <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">from </span><span class="s1">pandas.core.groupby </span><span class="s0">import </span><span class="s1">GroupBy</span>
    <span class="s0">from </span><span class="s1">pandas.core.resample </span><span class="s0">import </span><span class="s1">Resampler</span>
    <span class="s0">from </span><span class="s1">pandas.core.window.rolling </span><span class="s0">import </span><span class="s1">BaseWindow</span>


<span class="s1">ResType = Dict[int</span><span class="s0">, </span><span class="s1">Any]</span>


<span class="s0">def </span><span class="s1">frame_apply(</span>
    <span class="s1">obj: DataFrame</span><span class="s0">,</span>
    <span class="s1">func: AggFuncType</span><span class="s0">,</span>
    <span class="s1">axis: Axis = </span><span class="s2">0</span><span class="s0">,</span>
    <span class="s1">raw: bool = </span><span class="s0">False,</span>
    <span class="s1">result_type: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">args=</span><span class="s0">None,</span>
    <span class="s1">kwargs=</span><span class="s0">None,</span>
<span class="s1">) -&gt; FrameApply:</span>
    <span class="s3">&quot;&quot;&quot;construct and return a row or column based frame apply object&quot;&quot;&quot;</span>
    <span class="s1">axis = obj._get_axis_number(axis)</span>
    <span class="s1">klass: type[FrameApply]</span>
    <span class="s0">if </span><span class="s1">axis == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">klass = FrameRowApply</span>
    <span class="s0">elif </span><span class="s1">axis == </span><span class="s2">1</span><span class="s1">:</span>
        <span class="s1">klass = FrameColumnApply</span>

    <span class="s0">return </span><span class="s1">klass(</span>
        <span class="s1">obj</span><span class="s0">,</span>
        <span class="s1">func</span><span class="s0">,</span>
        <span class="s1">raw=raw</span><span class="s0">,</span>
        <span class="s1">result_type=result_type</span><span class="s0">,</span>
        <span class="s1">args=args</span><span class="s0">,</span>
        <span class="s1">kwargs=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">Apply(metaclass=abc.ABCMeta):</span>
    <span class="s1">axis: int</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj: AggObjType</span><span class="s0">,</span>
        <span class="s1">func</span><span class="s0">,</span>
        <span class="s1">raw: bool</span><span class="s0">,</span>
        <span class="s1">result_type: str | </span><span class="s0">None,</span>
        <span class="s1">args</span><span class="s0">,</span>
        <span class="s1">kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">self.obj = obj</span>
        <span class="s1">self.raw = raw</span>
        <span class="s1">self.args = args </span><span class="s0">or </span><span class="s1">()</span>
        <span class="s1">self.kwargs = kwargs </span><span class="s0">or </span><span class="s1">{}</span>

        <span class="s0">if </span><span class="s1">result_type </span><span class="s0">not in </span><span class="s1">[</span><span class="s0">None, </span><span class="s4">&quot;reduce&quot;</span><span class="s0">, </span><span class="s4">&quot;broadcast&quot;</span><span class="s0">, </span><span class="s4">&quot;expand&quot;</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;invalid value for result_type, must be one &quot;</span>
                <span class="s4">&quot;of {None, 'reduce', 'broadcast', 'expand'}&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.result_type = result_type</span>

        <span class="s5"># curry if needed</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">(kwargs </span><span class="s0">or </span><span class="s1">args)</span>
            <span class="s0">and not </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">(np.ufunc</span><span class="s0">, </span><span class="s1">str))</span>
            <span class="s0">and not </span><span class="s1">is_list_like(func)</span>
        <span class="s1">):</span>

            <span class="s0">def </span><span class="s1">f(x):</span>
                <span class="s0">return </span><span class="s1">func(x</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">f = func</span>

        <span class="s1">self.orig_f: AggFuncType = func</span>
        <span class="s1">self.f: AggFuncType = f</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">apply(self) -&gt; DataFrame | Series:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">agg(self) -&gt; DataFrame | Series | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Provide an implementation for the aggregators. 
 
        Returns 
        ------- 
        Result of aggregation, or None if agg cannot be performed by 
        this method. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self.obj</span>
        <span class="s1">arg = self.f</span>
        <span class="s1">args = self.args</span>
        <span class="s1">kwargs = self.kwargs</span>

        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">self.apply_str()</span>

        <span class="s0">if </span><span class="s1">is_dict_like(arg):</span>
            <span class="s0">return </span><span class="s1">self.agg_dict_like()</span>
        <span class="s0">elif </span><span class="s1">is_list_like(arg):</span>
            <span class="s5"># we require a list, but not a 'str'</span>
            <span class="s0">return </span><span class="s1">self.agg_list_like()</span>

        <span class="s0">if </span><span class="s1">callable(arg):</span>
            <span class="s1">f = com.get_cython_func(arg)</span>
            <span class="s0">if </span><span class="s1">f </span><span class="s0">and not </span><span class="s1">args </span><span class="s0">and not </span><span class="s1">kwargs:</span>
                <span class="s0">return </span><span class="s1">getattr(obj</span><span class="s0">, </span><span class="s1">f)()</span>

        <span class="s5"># caller can react</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">transform(self) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Transform a DataFrame or Series. 
 
        Returns 
        ------- 
        DataFrame or Series 
            Result of applying ``func`` along the given axis of the 
            Series or DataFrame. 
 
        Raises 
        ------ 
        ValueError 
            If the transform function fails or does not transform. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self.obj</span>
        <span class="s1">func = self.orig_f</span>
        <span class="s1">axis = self.axis</span>
        <span class="s1">args = self.args</span>
        <span class="s1">kwargs = self.kwargs</span>

        <span class="s1">is_series = obj.ndim == </span><span class="s2">1</span>

        <span class="s0">if </span><span class="s1">obj._get_axis_number(axis) == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">is_series</span>
            <span class="s0">return </span><span class="s1">obj.T.transform(func</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs).T</span>

        <span class="s0">if </span><span class="s1">is_list_like(func) </span><span class="s0">and not </span><span class="s1">is_dict_like(func):</span>
            <span class="s1">func = cast(List[AggFuncTypeBase]</span><span class="s0">, </span><span class="s1">func)</span>
            <span class="s5"># Convert func equivalent dict</span>
            <span class="s0">if </span><span class="s1">is_series:</span>
                <span class="s1">func = {com.get_callable_name(v) </span><span class="s0">or </span><span class="s1">v: v </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func}</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">func = {col: func </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">obj}</span>

        <span class="s0">if </span><span class="s1">is_dict_like(func):</span>
            <span class="s1">func = cast(AggFuncTypeDict</span><span class="s0">, </span><span class="s1">func)</span>
            <span class="s0">return </span><span class="s1">self.transform_dict_like(func)</span>

        <span class="s5"># func is either str or callable</span>
        <span class="s1">func = cast(AggFuncTypeBase</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = self.transform_str_or_callable(func)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">raise</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Transform function failed&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s5"># Functions that transform may return empty Series/DataFrame</span>
        <span class="s5"># when the dtype is not appropriate</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">(ABCSeries</span><span class="s0">, </span><span class="s1">ABCDataFrame))</span>
            <span class="s0">and </span><span class="s1">result.empty</span>
            <span class="s0">and not </span><span class="s1">obj.empty</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Transform function failed&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">(ABCSeries</span><span class="s0">, </span><span class="s1">ABCDataFrame)) </span><span class="s0">or not </span><span class="s1">result.index.equals(</span>
            <span class="s1">obj.index</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Function did not transform&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">transform_dict_like(self</span><span class="s0">, </span><span class="s1">func):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute transform in the case of a dict-like func 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>

        <span class="s1">obj = self.obj</span>
        <span class="s1">args = self.args</span>
        <span class="s1">kwargs = self.kwargs</span>

        <span class="s5"># transform is currently only for Series/DataFrame</span>
        <span class="s0">assert </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">ABCNDFrame)</span>

        <span class="s0">if </span><span class="s1">len(func) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No transform functions were provided&quot;</span><span class="s1">)</span>

        <span class="s1">func = self.normalize_dictlike_arg(</span><span class="s4">&quot;transform&quot;</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">func)</span>

        <span class="s1">results: dict[Hashable</span><span class="s0">, </span><span class="s1">DataFrame | Series] = {}</span>
        <span class="s1">failed_names = []</span>
        <span class="s1">all_type_errors = </span><span class="s0">True</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">func.items():</span>
            <span class="s1">colg = obj._gotitem(name</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">results[name] = colg.transform(how</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">if </span><span class="s1">str(err) </span><span class="s0">in </span><span class="s1">{</span>
                    <span class="s4">&quot;Function did not transform&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;No transform functions were provided&quot;</span><span class="s0">,</span>
                <span class="s1">}:</span>
                    <span class="s0">raise </span><span class="s1">err</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if not </span><span class="s1">isinstance(err</span><span class="s0">, </span><span class="s1">TypeError):</span>
                        <span class="s1">all_type_errors = </span><span class="s0">False</span>
                    <span class="s1">failed_names.append(name)</span>
        <span class="s5"># combine results</span>
        <span class="s0">if not </span><span class="s1">results:</span>
            <span class="s1">klass = TypeError </span><span class="s0">if </span><span class="s1">all_type_errors </span><span class="s0">else </span><span class="s1">ValueError</span>
            <span class="s0">raise </span><span class="s1">klass(</span><span class="s4">&quot;Transform function failed&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(failed_names) &gt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">failed_names</span><span class="s0">} </span><span class="s4">did not transform successfully. If any error is &quot;</span>
                <span class="s4">f&quot;raised, this will raise in a future version of pandas. &quot;</span>
                <span class="s4">f&quot;Drop these columns/ops to avoid this warning.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">concat(results</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">transform_str_or_callable(self</span><span class="s0">, </span><span class="s1">func) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute transform in the case of a string or callable func 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self.obj</span>
        <span class="s1">args = self.args</span>
        <span class="s1">kwargs = self.kwargs</span>

        <span class="s0">if </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">self._try_aggregate_string_function(obj</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">if not </span><span class="s1">args </span><span class="s0">and not </span><span class="s1">kwargs:</span>
            <span class="s1">f = com.get_cython_func(func)</span>
            <span class="s0">if </span><span class="s1">f:</span>
                <span class="s0">return </span><span class="s1">getattr(obj</span><span class="s0">, </span><span class="s1">f)()</span>

        <span class="s5"># Two possible ways to use a UDF - apply or call directly</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">obj.apply(func</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">return </span><span class="s1">func(obj</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">agg_list_like(self) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute aggregation in the case of a list-like argument. 
 
        Returns 
        ------- 
        Result of aggregation. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>

        <span class="s1">obj = self.obj</span>
        <span class="s1">arg = cast(List[AggFuncTypeBase]</span><span class="s0">, </span><span class="s1">self.f)</span>

        <span class="s0">if not </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">SelectionMixin):</span>
            <span class="s5"># i.e. obj is Series or DataFrame</span>
            <span class="s1">selected_obj = obj</span>
        <span class="s0">elif </span><span class="s1">obj._selected_obj.ndim == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s5"># For SeriesGroupBy this matches _obj_with_exclusions</span>
            <span class="s1">selected_obj = obj._selected_obj</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">selected_obj = obj._obj_with_exclusions</span>

        <span class="s1">results = []</span>
        <span class="s1">keys = []</span>
        <span class="s1">failed_names = []</span>

        <span class="s1">depr_nuisance_columns_msg = (</span>
            <span class="s4">&quot;{} did not aggregate successfully. If any error is &quot;</span>
            <span class="s4">&quot;raised this will raise in a future version of pandas. &quot;</span>
            <span class="s4">&quot;Drop these columns/ops to avoid this warning.&quot;</span>
        <span class="s1">)</span>

        <span class="s5"># degenerate case</span>
        <span class="s0">if </span><span class="s1">selected_obj.ndim == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arg:</span>
                <span class="s1">colg = obj._gotitem(selected_obj.name</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">subset=selected_obj)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">new_res = colg.aggregate(a)</span>

                <span class="s0">except </span><span class="s1">TypeError:</span>
                    <span class="s1">failed_names.append(com.get_callable_name(a) </span><span class="s0">or </span><span class="s1">a)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">results.append(new_res)</span>

                    <span class="s5"># make sure we find a good name</span>
                    <span class="s1">name = com.get_callable_name(a) </span><span class="s0">or </span><span class="s1">a</span>
                    <span class="s1">keys.append(name)</span>

        <span class="s5"># multiples</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">indices = []</span>
            <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate(selected_obj):</span>
                <span class="s1">colg = obj._gotitem(col</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">subset=selected_obj.iloc[:</span><span class="s0">, </span><span class="s1">index])</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s5"># Capture and suppress any warnings emitted by us in the call</span>
                    <span class="s5"># to agg below, but pass through any warnings that were</span>
                    <span class="s5"># generated otherwise.</span>
                    <span class="s5"># This is necessary because of https://bugs.python.org/issue29672</span>
                    <span class="s5"># See GH #43741 for more details</span>
                    <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">record:</span>
                        <span class="s1">new_res = colg.aggregate(arg)</span>
                    <span class="s0">if </span><span class="s1">len(record) &gt; </span><span class="s2">0</span><span class="s1">:</span>
                        <span class="s1">match = re.compile(depr_nuisance_columns_msg.format(</span><span class="s4">&quot;.*&quot;</span><span class="s1">))</span>
                        <span class="s0">for </span><span class="s1">warning </span><span class="s0">in </span><span class="s1">record:</span>
                            <span class="s0">if </span><span class="s1">re.match(match</span><span class="s0">, </span><span class="s1">str(warning.message)):</span>
                                <span class="s1">failed_names.append(col)</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">warnings.warn_explicit(</span>
                                    <span class="s1">message=warning.message</span><span class="s0">,</span>
                                    <span class="s1">category=warning.category</span><span class="s0">,</span>
                                    <span class="s1">filename=warning.filename</span><span class="s0">,</span>
                                    <span class="s1">lineno=warning.lineno</span><span class="s0">,</span>
                                <span class="s1">)</span>

                <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">DataError):</span>
                    <span class="s1">failed_names.append(col)</span>
                <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s5"># cannot aggregate</span>
                    <span class="s0">if </span><span class="s4">&quot;Must produce aggregated value&quot; </span><span class="s0">in </span><span class="s1">str(err):</span>
                        <span class="s5"># raised directly in _aggregate_named</span>
                        <span class="s1">failed_names.append(col)</span>
                    <span class="s0">elif </span><span class="s4">&quot;no results&quot; </span><span class="s0">in </span><span class="s1">str(err):</span>
                        <span class="s5"># reached in test_frame_apply.test_nuiscance_columns</span>
                        <span class="s5">#  where the colg.aggregate(arg) ends up going through</span>
                        <span class="s5">#  the selected_obj.ndim == 1 branch above with arg == [&quot;sum&quot;]</span>
                        <span class="s5">#  on a datetime64[ns] column</span>
                        <span class="s1">failed_names.append(col)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">raise</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">results.append(new_res)</span>
                    <span class="s1">indices.append(index)</span>

            <span class="s1">keys = selected_obj.columns.take(indices)</span>

        <span class="s5"># if we are empty</span>
        <span class="s0">if not </span><span class="s1">len(results):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;no results&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">len(failed_names) &gt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">depr_nuisance_columns_msg.format(failed_names)</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">concatenated = concat(results</span><span class="s0">, </span><span class="s1">keys=keys</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s5"># we are concatting non-NDFrame objects,</span>
            <span class="s5"># e.g. a list of scalars</span>
            <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

            <span class="s1">result = Series(results</span><span class="s0">, </span><span class="s1">index=keys</span><span class="s0">, </span><span class="s1">name=obj.name)</span>
            <span class="s0">if </span><span class="s1">is_nested_object(result):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;cannot combine transform and aggregation operations&quot;</span>
                <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Concat uses the first index to determine the final indexing order.</span>
            <span class="s5"># The union of a shorter first index with the other indices causes</span>
            <span class="s5"># the index sorting to be different from the order of the aggregating</span>
            <span class="s5"># functions. Reindex if this is the case.</span>
            <span class="s1">index_size = concatenated.index.size</span>
            <span class="s1">full_ordered_index = next(</span>
                <span class="s1">result.index </span><span class="s0">for </span><span class="s1">result </span><span class="s0">in </span><span class="s1">results </span><span class="s0">if </span><span class="s1">result.index.size == index_size</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">concatenated.reindex(full_ordered_index</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">agg_dict_like(self) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute aggregation in the case of a dict-like argument. 
 
        Returns 
        ------- 
        Result of aggregation. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Index</span>
        <span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>

        <span class="s1">obj = self.obj</span>
        <span class="s1">arg = cast(AggFuncTypeDict</span><span class="s0">, </span><span class="s1">self.f)</span>

        <span class="s0">if not </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">SelectionMixin):</span>
            <span class="s5"># i.e. obj is Series or DataFrame</span>
            <span class="s1">selected_obj = obj</span>
            <span class="s1">selection = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">selected_obj = obj._selected_obj</span>
            <span class="s1">selection = obj._selection</span>

        <span class="s1">arg = self.normalize_dictlike_arg(</span><span class="s4">&quot;agg&quot;</span><span class="s0">, </span><span class="s1">selected_obj</span><span class="s0">, </span><span class="s1">arg)</span>

        <span class="s0">if </span><span class="s1">selected_obj.ndim == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s5"># key only used for output</span>
            <span class="s1">colg = obj._gotitem(selection</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">results = {key: colg.agg(how) </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">arg.items()}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># key used for column selection and output</span>
            <span class="s1">results = {</span>
                <span class="s1">key: obj._gotitem(key</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s2">1</span><span class="s1">).agg(how) </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">arg.items()</span>
            <span class="s1">}</span>

        <span class="s5"># set the final keys</span>
        <span class="s1">keys = list(arg.keys())</span>

        <span class="s5"># Avoid making two isinstance calls in all and any below</span>
        <span class="s1">is_ndframe = [isinstance(r</span><span class="s0">, </span><span class="s1">ABCNDFrame) </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">results.values()]</span>

        <span class="s5"># combine results</span>
        <span class="s0">if </span><span class="s1">all(is_ndframe):</span>
            <span class="s1">keys_to_use: Iterable[Hashable]</span>
            <span class="s1">keys_to_use = [k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">keys </span><span class="s0">if not </span><span class="s1">results[k].empty]</span>
            <span class="s5"># Have to check, if at least one DataFrame is not empty.</span>
            <span class="s1">keys_to_use = keys_to_use </span><span class="s0">if </span><span class="s1">keys_to_use != [] </span><span class="s0">else </span><span class="s1">keys</span>
            <span class="s0">if </span><span class="s1">selected_obj.ndim == </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s5"># keys are columns, so we can preserve names</span>
                <span class="s1">ktu = Index(keys_to_use)</span>
                <span class="s1">ktu._set_names(selected_obj.columns.names)</span>
                <span class="s1">keys_to_use = ktu</span>

            <span class="s1">axis = </span><span class="s2">0 </span><span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">ABCSeries) </span><span class="s0">else </span><span class="s2">1</span>
            <span class="s1">result = concat(</span>
                <span class="s1">{k: results[k] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">keys_to_use}</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">keys=keys_to_use</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">any(is_ndframe):</span>
            <span class="s5"># There is a mix of NDFrames and scalars</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;cannot perform both aggregation &quot;</span>
                <span class="s4">&quot;and transformation operations &quot;</span>
                <span class="s4">&quot;simultaneously&quot;</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

            <span class="s5"># we have a dict of scalars</span>
            <span class="s5"># GH 36212 use name only if obj is a series</span>
            <span class="s0">if </span><span class="s1">obj.ndim == </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">obj = cast(</span><span class="s4">&quot;Series&quot;</span><span class="s0">, </span><span class="s1">obj)</span>
                <span class="s1">name = obj.name</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s0">None</span>

            <span class="s1">result = Series(results</span><span class="s0">, </span><span class="s1">name=name)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_str(self) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute apply in case of a string. 
 
        Returns 
        ------- 
        result: Series or DataFrame 
        &quot;&quot;&quot;</span>
        <span class="s5"># Caller is responsible for checking isinstance(self.f, str)</span>
        <span class="s1">f = cast(str</span><span class="s0">, </span><span class="s1">self.f)</span>

        <span class="s1">obj = self.obj</span>

        <span class="s5"># Support for `frame.transform('method')`</span>
        <span class="s5"># Some methods (shift, etc.) require the axis argument, others</span>
        <span class="s5"># don't, so inspect and insert if necessary.</span>
        <span class="s1">func = getattr(obj</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">callable(func):</span>
            <span class="s1">sig = inspect.getfullargspec(func)</span>
            <span class="s0">if </span><span class="s4">&quot;axis&quot; </span><span class="s0">in </span><span class="s1">sig.args:</span>
                <span class="s1">self.kwargs[</span><span class="s4">&quot;axis&quot;</span><span class="s1">] = self.axis</span>
            <span class="s0">elif </span><span class="s1">self.axis != </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Operation </span><span class="s0">{</span><span class="s1">f</span><span class="s0">} </span><span class="s4">does not support axis=1&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._try_aggregate_string_function(obj</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">*self.args</span><span class="s0">, </span><span class="s1">**self.kwargs)</span>

    <span class="s0">def </span><span class="s1">apply_multiple(self) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute apply in case of a list-like or dict-like. 
 
        Returns 
        ------- 
        result: Series, DataFrame, or None 
            Result when self.f is a list-like or dict-like, None otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.obj.aggregate(self.f</span><span class="s0">, </span><span class="s1">self.axis</span><span class="s0">, </span><span class="s1">*self.args</span><span class="s0">, </span><span class="s1">**self.kwargs)</span>

    <span class="s0">def </span><span class="s1">normalize_dictlike_arg(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">how: str</span><span class="s0">, </span><span class="s1">obj: DataFrame | Series</span><span class="s0">, </span><span class="s1">func: AggFuncTypeDict</span>
    <span class="s1">) -&gt; AggFuncTypeDict:</span>
        <span class="s3">&quot;&quot;&quot; 
        Handler for dict-like argument. 
 
        Ensures that necessary columns exist if obj is a DataFrame, and 
        that a nested renamer is not passed. Also normalizes to all lists 
        when values consists of a mix of list and non-lists. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">how </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;apply&quot;</span><span class="s0">, </span><span class="s4">&quot;agg&quot;</span><span class="s0">, </span><span class="s4">&quot;transform&quot;</span><span class="s1">)</span>

        <span class="s5"># Can't use func.values(); wouldn't work for a Series</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">how == </span><span class="s4">&quot;agg&quot;</span>
            <span class="s0">and </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">ABCSeries)</span>
            <span class="s0">and </span><span class="s1">any(is_list_like(v) </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func.items())</span>
        <span class="s1">) </span><span class="s0">or </span><span class="s1">(any(is_dict_like(v) </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func.items())):</span>
            <span class="s5"># GH 15931 - deprecation of renaming keys</span>
            <span class="s0">raise </span><span class="s1">SpecificationError(</span><span class="s4">&quot;nested renamer is not supported&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">obj.ndim != </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s5"># Check for missing columns on a frame</span>
            <span class="s1">cols = set(func.keys()) - set(obj.columns)</span>
            <span class="s0">if </span><span class="s1">len(cols) &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">cols_sorted = list(safe_sort(list(cols)))</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s4">f&quot;Column(s) </span><span class="s0">{</span><span class="s1">cols_sorted</span><span class="s0">} </span><span class="s4">do not exist&quot;</span><span class="s1">)</span>

        <span class="s1">is_aggregator = </span><span class="s0">lambda </span><span class="s1">x: isinstance(x</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">dict))</span>

        <span class="s5"># if we have a dict of any non-scalars</span>
        <span class="s5"># eg. {'A' : ['mean']}, normalize all to</span>
        <span class="s5"># be list-likes</span>
        <span class="s5"># Cannot use func.values() because arg may be a Series</span>
        <span class="s0">if </span><span class="s1">any(is_aggregator(x) </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">func.items()):</span>
            <span class="s1">new_func: AggFuncTypeDict = {}</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func.items():</span>
                <span class="s0">if not </span><span class="s1">is_aggregator(v):</span>
                    <span class="s5"># mypy can't realize v is not a list here</span>
                    <span class="s1">new_func[k] = [v]  </span><span class="s5"># type:ignore[list-item]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">new_func[k] = v</span>
            <span class="s1">func = new_func</span>
        <span class="s0">return </span><span class="s1">func</span>

    <span class="s0">def </span><span class="s1">_try_aggregate_string_function(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">arg: str</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        if arg is a string, then try to operate on it: 
        - try to find a function (or attribute) on ourselves 
        - try to find a numpy function 
        - raise 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str)</span>

        <span class="s1">f = getattr(obj</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">f </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">callable(f):</span>
                <span class="s0">return </span><span class="s1">f(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s5"># people may try to aggregate on a non-callable attribute</span>
            <span class="s5"># but don't let them think they can pass args to it</span>
            <span class="s0">assert </span><span class="s1">len(args) == </span><span class="s2">0</span>
            <span class="s0">assert </span><span class="s1">len([kwarg </span><span class="s0">for </span><span class="s1">kwarg </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">if </span><span class="s1">kwarg </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">&quot;axis&quot;</span><span class="s1">]]) == </span><span class="s2">0</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s1">f = getattr(np</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">f </span><span class="s0">is not None and </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s4">&quot;__array__&quot;</span><span class="s1">):</span>
            <span class="s5"># in particular exclude Window</span>
            <span class="s0">return </span><span class="s1">f(obj</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">raise </span><span class="s1">AttributeError(</span>
            <span class="s4">f&quot;'</span><span class="s0">{</span><span class="s1">arg</span><span class="s0">}</span><span class="s4">' is not a valid function for '</span><span class="s0">{</span><span class="s1">type(obj).__name__</span><span class="s0">}</span><span class="s4">' object&quot;</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">NDFrameApply(Apply):</span>
    <span class="s3">&quot;&quot;&quot; 
    Methods shared by FrameApply and SeriesApply but 
    not GroupByApply or ResamplerWindowApply 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">index(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.obj.index</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">agg_axis(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.obj._get_agg_axis(self.axis)</span>


<span class="s0">class </span><span class="s1">FrameApply(NDFrameApply):</span>
    <span class="s1">obj: DataFrame</span>

    <span class="s5"># ---------------------------------------------------------------</span>
    <span class="s5"># Abstract Methods</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">result_index(self) -&gt; Index:</span>
        <span class="s0">pass</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">result_columns(self) -&gt; Index:</span>
        <span class="s0">pass</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">series_generator(self) -&gt; Iterator[Series]:</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">wrap_results_for_axis(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">results: ResType</span><span class="s0">, </span><span class="s1">res_index: Index</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s0">pass</span>

    <span class="s5"># ---------------------------------------------------------------</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">res_columns(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.result_columns</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">columns(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.obj.columns</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s0">return </span><span class="s1">self.obj.values</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">dtypes(self) -&gt; Series:</span>
        <span class="s0">return </span><span class="s1">self.obj.dtypes</span>

    <span class="s0">def </span><span class="s1">apply(self) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot;compute the results&quot;&quot;&quot;</span>
        <span class="s5"># dispatch to agg</span>
        <span class="s0">if </span><span class="s1">is_list_like(self.f):</span>
            <span class="s0">return </span><span class="s1">self.apply_multiple()</span>

        <span class="s5"># all empty</span>
        <span class="s0">if </span><span class="s1">len(self.columns) == </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">len(self.index) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.apply_empty_result()</span>

        <span class="s5"># string dispatch</span>
        <span class="s0">if </span><span class="s1">isinstance(self.f</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">self.apply_str()</span>

        <span class="s5"># ufunc</span>
        <span class="s0">elif </span><span class="s1">isinstance(self.f</span><span class="s0">, </span><span class="s1">np.ufunc):</span>
            <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">results = self.obj._mgr.apply(</span><span class="s4">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">func=self.f)</span>
            <span class="s5"># _constructor will retain self.index and self.columns</span>
            <span class="s0">return </span><span class="s1">self.obj._constructor(data=results)</span>

        <span class="s5"># broadcasting</span>
        <span class="s0">if </span><span class="s1">self.result_type == </span><span class="s4">&quot;broadcast&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.apply_broadcast(self.obj)</span>

        <span class="s5"># one axis empty</span>
        <span class="s0">elif not </span><span class="s1">all(self.obj.shape):</span>
            <span class="s0">return </span><span class="s1">self.apply_empty_result()</span>

        <span class="s5"># raw</span>
        <span class="s0">elif </span><span class="s1">self.raw:</span>
            <span class="s0">return </span><span class="s1">self.apply_raw()</span>

        <span class="s0">return </span><span class="s1">self.apply_standard()</span>

    <span class="s0">def </span><span class="s1">agg(self):</span>
        <span class="s1">obj = self.obj</span>
        <span class="s1">axis = self.axis</span>

        <span class="s5"># TODO: Avoid having to change state</span>
        <span class="s1">self.obj = self.obj </span><span class="s0">if </span><span class="s1">self.axis == </span><span class="s2">0 </span><span class="s0">else </span><span class="s1">self.obj.T</span>
        <span class="s1">self.axis = </span><span class="s2">0</span>

        <span class="s1">result = </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = super().agg()</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s1">exc = TypeError(</span>
                <span class="s4">&quot;DataFrame constructor called with &quot;</span>
                <span class="s4">f&quot;incompatible data and dtype: </span><span class="s0">{</span><span class="s1">err</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">exc </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">self.obj = obj</span>
            <span class="s1">self.axis = axis</span>

        <span class="s0">if </span><span class="s1">axis == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">result = result.T </span><span class="s0">if </span><span class="s1">result </span><span class="s0">is not None else </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s1">result </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = self.obj.apply(self.orig_f</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">args=self.args</span><span class="s0">, </span><span class="s1">**self.kwargs)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_empty_result(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        we have an empty result; at least 1 axis is 0 
 
        we will try to apply the function to an empty 
        series in order to see if this is a reduction function 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">callable(self.f)</span>

        <span class="s5"># we are not asked to reduce or infer reduction</span>
        <span class="s5"># so just return a copy of the existing object</span>
        <span class="s0">if </span><span class="s1">self.result_type </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">&quot;reduce&quot;</span><span class="s0">, None</span><span class="s1">]:</span>
            <span class="s0">return </span><span class="s1">self.obj.copy()</span>

        <span class="s5"># we may need to infer</span>
        <span class="s1">should_reduce = self.result_type == </span><span class="s4">&quot;reduce&quot;</span>

        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s0">if not </span><span class="s1">should_reduce:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">r = self.f(Series([]</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">should_reduce = </span><span class="s0">not </span><span class="s1">isinstance(r</span><span class="s0">, </span><span class="s1">Series)</span>

        <span class="s0">if </span><span class="s1">should_reduce:</span>
            <span class="s0">if </span><span class="s1">len(self.agg_axis):</span>
                <span class="s1">r = self.f(Series([]</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">r = np.nan</span>

            <span class="s0">return </span><span class="s1">self.obj._constructor_sliced(r</span><span class="s0">, </span><span class="s1">index=self.agg_axis)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.obj.copy()</span>

    <span class="s0">def </span><span class="s1">apply_raw(self):</span>
        <span class="s3">&quot;&quot;&quot;apply to the values as a numpy array&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">wrap_function(func):</span>
            <span class="s3">&quot;&quot;&quot; 
            Wrap user supplied function to work around numpy issue. 
 
            see https://github.com/numpy/numpy/issues/8352 
            &quot;&quot;&quot;</span>

            <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s1">result = func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">str):</span>
                    <span class="s1">result = np.array(result</span><span class="s0">, </span><span class="s1">dtype=object)</span>
                <span class="s0">return </span><span class="s1">result</span>

            <span class="s0">return </span><span class="s1">wrapper</span>

        <span class="s1">result = np.apply_along_axis(wrap_function(self.f)</span><span class="s0">, </span><span class="s1">self.axis</span><span class="s0">, </span><span class="s1">self.values)</span>

        <span class="s5"># TODO: mixed type case</span>
        <span class="s0">if </span><span class="s1">result.ndim == </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.obj._constructor(result</span><span class="s0">, </span><span class="s1">index=self.index</span><span class="s0">, </span><span class="s1">columns=self.columns)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.obj._constructor_sliced(result</span><span class="s0">, </span><span class="s1">index=self.agg_axis)</span>

    <span class="s0">def </span><span class="s1">apply_broadcast(self</span><span class="s0">, </span><span class="s1">target: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">assert </span><span class="s1">callable(self.f)</span>

        <span class="s1">result_values = np.empty_like(target.values)</span>

        <span class="s5"># axis which we want to compare compliance</span>
        <span class="s1">result_compare = target.shape[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate(target.columns):</span>
            <span class="s1">res = self.f(target[col])</span>
            <span class="s1">ares = np.asarray(res).ndim</span>

            <span class="s5"># must be a scalar or 1d</span>
            <span class="s0">if </span><span class="s1">ares &gt; </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;too many dims to broadcast&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">ares == </span><span class="s2">1</span><span class="s1">:</span>

                <span class="s5"># must match return dim</span>
                <span class="s0">if </span><span class="s1">result_compare != len(res):</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cannot broadcast result&quot;</span><span class="s1">)</span>

            <span class="s1">result_values[:</span><span class="s0">, </span><span class="s1">i] = res</span>

        <span class="s5"># we *always* preserve the original index / columns</span>
        <span class="s1">result = self.obj._constructor(</span>
            <span class="s1">result_values</span><span class="s0">, </span><span class="s1">index=target.index</span><span class="s0">, </span><span class="s1">columns=target.columns</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_standard(self):</span>
        <span class="s1">results</span><span class="s0">, </span><span class="s1">res_index = self.apply_series_generator()</span>

        <span class="s5"># wrap results</span>
        <span class="s0">return </span><span class="s1">self.wrap_results(results</span><span class="s0">, </span><span class="s1">res_index)</span>

    <span class="s0">def </span><span class="s1">apply_series_generator(self) -&gt; tuple[ResType</span><span class="s0">, </span><span class="s1">Index]:</span>
        <span class="s0">assert </span><span class="s1">callable(self.f)</span>

        <span class="s1">series_gen = self.series_generator</span>
        <span class="s1">res_index = self.result_index</span>

        <span class="s1">results = {}</span>

        <span class="s0">with </span><span class="s1">option_context(</span><span class="s4">&quot;mode.chained_assignment&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate(series_gen):</span>
                <span class="s5"># ignore SettingWithCopy here in case the user mutates</span>
                <span class="s1">results[i] = self.f(v)</span>
                <span class="s0">if </span><span class="s1">isinstance(results[i]</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
                    <span class="s5"># If we have a view on v, we need to make a copy because</span>
                    <span class="s5">#  series_generator will swap out the underlying data</span>
                    <span class="s1">results[i] = results[i].copy(deep=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">results</span><span class="s0">, </span><span class="s1">res_index</span>

    <span class="s0">def </span><span class="s1">wrap_results(self</span><span class="s0">, </span><span class="s1">results: ResType</span><span class="s0">, </span><span class="s1">res_index: Index) -&gt; DataFrame | Series:</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s5"># see if we can infer the results</span>
        <span class="s0">if </span><span class="s1">len(results) &gt; </span><span class="s2">0 </span><span class="s0">and </span><span class="s2">0 </span><span class="s0">in </span><span class="s1">results </span><span class="s0">and </span><span class="s1">is_sequence(results[</span><span class="s2">0</span><span class="s1">]):</span>
            <span class="s0">return </span><span class="s1">self.wrap_results_for_axis(results</span><span class="s0">, </span><span class="s1">res_index)</span>

        <span class="s5"># dict of scalars</span>

        <span class="s5"># the default dtype of an empty Series will be `object`, but this</span>
        <span class="s5"># code can be hit by df.mean() where the result should have dtype</span>
        <span class="s5"># float64 even if it's an empty Series.</span>
        <span class="s1">constructor_sliced = self.obj._constructor_sliced</span>
        <span class="s0">if </span><span class="s1">constructor_sliced </span><span class="s0">is </span><span class="s1">Series:</span>
            <span class="s1">result = create_series_with_explicit_dtype(</span>
                <span class="s1">results</span><span class="s0">, </span><span class="s1">dtype_if_empty=np.float64</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = constructor_sliced(results)</span>
        <span class="s1">result.index = res_index</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_str(self) -&gt; DataFrame | Series:</span>
        <span class="s5"># Caller is responsible for checking isinstance(self.f, str)</span>
        <span class="s5"># TODO: GH#39993 - Avoid special-casing by replacing with lambda</span>
        <span class="s0">if </span><span class="s1">self.f == </span><span class="s4">&quot;size&quot;</span><span class="s1">:</span>
            <span class="s5"># Special-cased because DataFrame.size returns a single scalar</span>
            <span class="s1">obj = self.obj</span>
            <span class="s1">value = obj.shape[self.axis]</span>
            <span class="s0">return </span><span class="s1">obj._constructor_sliced(value</span><span class="s0">, </span><span class="s1">index=self.agg_axis)</span>
        <span class="s0">return </span><span class="s1">super().apply_str()</span>


<span class="s0">class </span><span class="s1">FrameRowApply(FrameApply):</span>
    <span class="s1">axis = </span><span class="s2">0</span>

    <span class="s0">def </span><span class="s1">apply_broadcast(self</span><span class="s0">, </span><span class="s1">target: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">return </span><span class="s1">super().apply_broadcast(target)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">series_generator(self):</span>
        <span class="s0">return </span><span class="s1">(self.obj._ixs(i</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self.columns)))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">result_index(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.columns</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">result_columns(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.index</span>

    <span class="s0">def </span><span class="s1">wrap_results_for_axis(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">results: ResType</span><span class="s0">, </span><span class="s1">res_index: Index</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot;return the results for the rows&quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self.result_type == </span><span class="s4">&quot;reduce&quot;</span><span class="s1">:</span>
            <span class="s5"># e.g. test_apply_dict GH#8735</span>
            <span class="s1">res = self.obj._constructor_sliced(results)</span>
            <span class="s1">res.index = res_index</span>
            <span class="s0">return </span><span class="s1">res</span>

        <span class="s0">elif </span><span class="s1">self.result_type </span><span class="s0">is None and </span><span class="s1">all(</span>
            <span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">results.values()</span>
        <span class="s1">):</span>
            <span class="s5"># Our operation was a to_dict op e.g.</span>
            <span class="s5">#  test_apply_dict GH#8735, test_apply_reduce_to_dict GH#25196 #37544</span>
            <span class="s1">res = self.obj._constructor_sliced(results)</span>
            <span class="s1">res.index = res_index</span>
            <span class="s0">return </span><span class="s1">res</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = self.obj._constructor(data=results)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s0">if </span><span class="s4">&quot;All arrays must be of the same length&quot; </span><span class="s0">in </span><span class="s1">str(err):</span>
                <span class="s5"># e.g. result = [[2, 3], [1.5], ['foo', 'bar']]</span>
                <span class="s5">#  see test_agg_listlike_result GH#29587</span>
                <span class="s1">res = self.obj._constructor_sliced(results)</span>
                <span class="s1">res.index = res_index</span>
                <span class="s0">return </span><span class="s1">res</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise</span>

        <span class="s0">if not </span><span class="s1">isinstance(results[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
            <span class="s0">if </span><span class="s1">len(result.index) == len(self.res_columns):</span>
                <span class="s1">result.index = self.res_columns</span>

        <span class="s0">if </span><span class="s1">len(result.columns) == len(res_index):</span>
            <span class="s1">result.columns = res_index</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">FrameColumnApply(FrameApply):</span>
    <span class="s1">axis = </span><span class="s2">1</span>

    <span class="s0">def </span><span class="s1">apply_broadcast(self</span><span class="s0">, </span><span class="s1">target: DataFrame) -&gt; DataFrame:</span>
        <span class="s1">result = super().apply_broadcast(target.T)</span>
        <span class="s0">return </span><span class="s1">result.T</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">series_generator(self):</span>
        <span class="s1">values = self.values</span>
        <span class="s1">values = ensure_wrapped_if_datetimelike(values)</span>
        <span class="s0">assert </span><span class="s1">len(values) &gt; </span><span class="s2">0</span>

        <span class="s5"># We create one Series object, and will swap out the data inside</span>
        <span class="s5">#  of it.  Kids: don't do this at home.</span>
        <span class="s1">ser = self.obj._ixs(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">mgr = ser._mgr</span>

        <span class="s0">if </span><span class="s1">is_extension_array_dtype(ser.dtype):</span>
            <span class="s5"># values will be incorrect for this block</span>
            <span class="s5"># TODO(EA2D): special case would be unnecessary with 2D EAs</span>
            <span class="s1">obj = self.obj</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(obj)):</span>
                <span class="s0">yield </span><span class="s1">obj._ixs(i</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">(arr</span><span class="s0">, </span><span class="s1">name) </span><span class="s0">in </span><span class="s1">zip(values</span><span class="s0">, </span><span class="s1">self.index):</span>
                <span class="s5"># GH#35462 re-pin mgr in case setitem changed it</span>
                <span class="s1">ser._mgr = mgr</span>
                <span class="s1">mgr.set_values(arr)</span>
                <span class="s1">ser.name = name</span>
                <span class="s0">yield </span><span class="s1">ser</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">result_index(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.index</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">result_columns(self) -&gt; Index:</span>
        <span class="s0">return </span><span class="s1">self.columns</span>

    <span class="s0">def </span><span class="s1">wrap_results_for_axis(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">results: ResType</span><span class="s0">, </span><span class="s1">res_index: Index</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s3">&quot;&quot;&quot;return the results for the columns&quot;&quot;&quot;</span>
        <span class="s1">result: DataFrame | Series</span>

        <span class="s5"># we have requested to expand</span>
        <span class="s0">if </span><span class="s1">self.result_type == </span><span class="s4">&quot;expand&quot;</span><span class="s1">:</span>
            <span class="s1">result = self.infer_to_same_shape(results</span><span class="s0">, </span><span class="s1">res_index)</span>

        <span class="s5"># we have a non-series and don't want inference</span>
        <span class="s0">elif not </span><span class="s1">isinstance(results[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
            <span class="s1">result = self.obj._constructor_sliced(results)</span>
            <span class="s1">result.index = res_index</span>

        <span class="s5"># we may want to infer results</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = self.infer_to_same_shape(results</span><span class="s0">, </span><span class="s1">res_index)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">infer_to_same_shape(self</span><span class="s0">, </span><span class="s1">results: ResType</span><span class="s0">, </span><span class="s1">res_index: Index) -&gt; DataFrame:</span>
        <span class="s3">&quot;&quot;&quot;infer the results to the same shape as the input object&quot;&quot;&quot;</span>
        <span class="s1">result = self.obj._constructor(data=results)</span>
        <span class="s1">result = result.T</span>

        <span class="s5"># set the index</span>
        <span class="s1">result.index = res_index</span>

        <span class="s5"># infer dtypes</span>
        <span class="s1">result = result.infer_objects()</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">SeriesApply(NDFrameApply):</span>
    <span class="s1">obj: Series</span>
    <span class="s1">axis = </span><span class="s2">0</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj: Series</span><span class="s0">,</span>
        <span class="s1">func: AggFuncType</span><span class="s0">,</span>
        <span class="s1">convert_dtype: bool</span><span class="s0">,</span>
        <span class="s1">args</span><span class="s0">,</span>
        <span class="s1">kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">self.convert_dtype = convert_dtype</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">obj</span><span class="s0">,</span>
            <span class="s1">func</span><span class="s0">,</span>
            <span class="s1">raw=</span><span class="s0">False,</span>
            <span class="s1">result_type=</span><span class="s0">None,</span>
            <span class="s1">args=args</span><span class="s0">,</span>
            <span class="s1">kwargs=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">apply(self) -&gt; DataFrame | Series:</span>
        <span class="s1">obj = self.obj</span>

        <span class="s0">if </span><span class="s1">len(obj) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.apply_empty_result()</span>

        <span class="s5"># dispatch to agg</span>
        <span class="s0">if </span><span class="s1">is_list_like(self.f):</span>
            <span class="s0">return </span><span class="s1">self.apply_multiple()</span>

        <span class="s0">if </span><span class="s1">isinstance(self.f</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s5"># if we are a string, try to dispatch</span>
            <span class="s0">return </span><span class="s1">self.apply_str()</span>

        <span class="s0">return </span><span class="s1">self.apply_standard()</span>

    <span class="s0">def </span><span class="s1">agg(self):</span>
        <span class="s1">result = super().agg()</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">f = self.f</span>
            <span class="s1">kwargs = self.kwargs</span>

            <span class="s5"># string, list-like, and dict-like are entirely handled in super</span>
            <span class="s0">assert </span><span class="s1">callable(f)</span>

            <span class="s5"># we can be called from an inner function which</span>
            <span class="s5"># passes this meta-data</span>
            <span class="s1">kwargs.pop(</span><span class="s4">&quot;_level&quot;</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s5"># try a regular apply, this evaluates lambdas</span>
            <span class="s5"># row-by-row; however if the lambda is expected a Series</span>
            <span class="s5"># expression, e.g.: lambda x: x-x.quantile(0.25)</span>
            <span class="s5"># this will fail, so we can try a vectorized evaluation</span>

            <span class="s5"># we cannot FIRST try the vectorized evaluation, because</span>
            <span class="s5"># then .agg and .apply would have different semantics if the</span>
            <span class="s5"># operation is actually defined on the Series, e.g. str</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result = self.obj.apply(f)</span>
            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">AttributeError</span><span class="s0">, </span><span class="s1">TypeError):</span>
                <span class="s1">result = f(self.obj)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_empty_result(self) -&gt; Series:</span>
        <span class="s1">obj = self.obj</span>
        <span class="s0">return </span><span class="s1">obj._constructor(dtype=obj.dtype</span><span class="s0">, </span><span class="s1">index=obj.index).__finalize__(</span>
            <span class="s1">obj</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">&quot;apply&quot;</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">apply_standard(self) -&gt; DataFrame | Series:</span>
        <span class="s1">f = self.f</span>
        <span class="s1">obj = self.obj</span>

        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">isinstance(f</span><span class="s0">, </span><span class="s1">np.ufunc):</span>
                <span class="s0">return </span><span class="s1">f(obj)</span>

            <span class="s5"># row-wise access</span>
            <span class="s0">if </span><span class="s1">is_extension_array_dtype(obj.dtype) </span><span class="s0">and </span><span class="s1">hasattr(obj._values</span><span class="s0">, </span><span class="s4">&quot;map&quot;</span><span class="s1">):</span>
                <span class="s5"># GH#23179 some EAs do not have `map`</span>
                <span class="s1">mapped = obj._values.map(f)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">values = obj.astype(object)._values</span>
                <span class="s5"># error: Argument 2 to &quot;map_infer&quot; has incompatible type</span>
                <span class="s5"># &quot;Union[Callable[..., Any], str, List[Union[Callable[..., Any], str]],</span>
                <span class="s5"># Dict[Hashable, Union[Union[Callable[..., Any], str],</span>
                <span class="s5"># List[Union[Callable[..., Any], str]]]]]&quot;; expected</span>
                <span class="s5"># &quot;Callable[[Any], Any]&quot;</span>
                <span class="s1">mapped = lib.map_infer(</span>
                    <span class="s1">values</span><span class="s0">,</span>
                    <span class="s1">f</span><span class="s0">,  </span><span class="s5"># type: ignore[arg-type]</span>
                    <span class="s1">convert=self.convert_dtype</span><span class="s0">,</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">len(mapped) </span><span class="s0">and </span><span class="s1">isinstance(mapped[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
            <span class="s5"># GH#43986 Need to do list(mapped) in order to get treated as nested</span>
            <span class="s5">#  See also GH#25959 regarding EA support</span>
            <span class="s0">return </span><span class="s1">obj._constructor_expanddim(list(mapped)</span><span class="s0">, </span><span class="s1">index=obj.index)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">obj._constructor(mapped</span><span class="s0">, </span><span class="s1">index=obj.index).__finalize__(</span>
                <span class="s1">obj</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">&quot;apply&quot;</span>
            <span class="s1">)</span>


<span class="s0">class </span><span class="s1">GroupByApply(Apply):</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj: GroupBy[NDFrameT]</span><span class="s0">,</span>
        <span class="s1">func: AggFuncType</span><span class="s0">,</span>
        <span class="s1">args</span><span class="s0">,</span>
        <span class="s1">kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s1">self.axis = obj.obj._get_axis_number(kwargs.get(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">obj</span><span class="s0">,</span>
            <span class="s1">func</span><span class="s0">,</span>
            <span class="s1">raw=</span><span class="s0">False,</span>
            <span class="s1">result_type=</span><span class="s0">None,</span>
            <span class="s1">args=args</span><span class="s0">,</span>
            <span class="s1">kwargs=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">apply(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">transform(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>


<span class="s0">class </span><span class="s1">ResamplerWindowApply(Apply):</span>
    <span class="s1">axis = </span><span class="s2">0</span>
    <span class="s1">obj: Resampler | BaseWindow</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj: Resampler | BaseWindow</span><span class="s0">,</span>
        <span class="s1">func: AggFuncType</span><span class="s0">,</span>
        <span class="s1">args</span><span class="s0">,</span>
        <span class="s1">kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">obj</span><span class="s0">,</span>
            <span class="s1">func</span><span class="s0">,</span>
            <span class="s1">raw=</span><span class="s0">False,</span>
            <span class="s1">result_type=</span><span class="s0">None,</span>
            <span class="s1">args=args</span><span class="s0">,</span>
            <span class="s1">kwargs=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">apply(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">transform(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>


<span class="s0">def </span><span class="s1">reconstruct_func(</span>
    <span class="s1">func: AggFuncType | </span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; tuple[bool</span><span class="s0">, </span><span class="s1">AggFuncType | </span><span class="s0">None, </span><span class="s1">list[str] | </span><span class="s0">None, </span><span class="s1">list[int] | </span><span class="s0">None</span><span class="s1">]:</span>
    <span class="s3">&quot;&quot;&quot; 
    This is the internal function to reconstruct func given if there is relabeling 
    or not and also normalize the keyword to get new order of columns. 
 
    If named aggregation is applied, `func` will be None, and kwargs contains the 
    column and aggregation function information to be parsed; 
    If named aggregation is not applied, `func` is either string (e.g. 'min') or 
    Callable, or list of them (e.g. ['min', np.max]), or the dictionary of column name 
    and str/Callable/list of them (e.g. {'A': 'min'}, or {'A': [np.min, lambda x: x]}) 
 
    If relabeling is True, will return relabeling, reconstructed func, column 
    names, and the reconstructed order of columns. 
    If relabeling is False, the columns and order will be None. 
 
    Parameters 
    ---------- 
    func: agg function (e.g. 'min' or Callable) or list of agg functions 
        (e.g. ['min', np.max]) or dictionary (e.g. {'A': ['min', np.max]}). 
    **kwargs: dict, kwargs used in is_multi_agg_with_relabel and 
        normalize_keyword_aggregation function for relabelling 
 
    Returns 
    ------- 
    relabelling: bool, if there is relabelling or not 
    func: normalized and mangled func 
    columns: list of column names 
    order: list of columns indices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; reconstruct_func(None, **{&quot;foo&quot;: (&quot;col&quot;, &quot;min&quot;)}) 
    (True, defaultdict(&lt;class 'list'&gt;, {'col': ['min']}), ('foo',), array([0])) 
 
    &gt;&gt;&gt; reconstruct_func(&quot;min&quot;) 
    (False, 'min', None, None) 
    &quot;&quot;&quot;</span>
    <span class="s1">relabeling = func </span><span class="s0">is None and </span><span class="s1">is_multi_agg_with_relabel(**kwargs)</span>
    <span class="s1">columns: list[str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">order: list[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

    <span class="s0">if not </span><span class="s1">relabeling:</span>
        <span class="s0">if </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">len(func) &gt; len(set(func)):</span>

            <span class="s5"># GH 28426 will raise error if duplicated function names are used and</span>
            <span class="s5"># there is no reassigned name</span>
            <span class="s0">raise </span><span class="s1">SpecificationError(</span>
                <span class="s4">&quot;Function names must be unique if there is no new column names &quot;</span>
                <span class="s4">&quot;assigned&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">func </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># nicer error message</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Must provide 'func' or tuples of '(column, aggfunc).&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">relabeling:</span>
        <span class="s1">func</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">order = normalize_keyword_aggregation(kwargs)</span>

    <span class="s0">return </span><span class="s1">relabeling</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">order</span>


<span class="s0">def </span><span class="s1">is_multi_agg_with_relabel(**kwargs) -&gt; bool:</span>
    <span class="s3">&quot;&quot;&quot; 
    Check whether kwargs passed to .agg look like multi-agg with relabeling. 
 
    Parameters 
    ---------- 
    **kwargs : dict 
 
    Returns 
    ------- 
    bool 
 
    Examples 
    -------- 
    &gt;&gt;&gt; is_multi_agg_with_relabel(a=&quot;max&quot;) 
    False 
    &gt;&gt;&gt; is_multi_agg_with_relabel(a_max=(&quot;a&quot;, &quot;max&quot;), a_min=(&quot;a&quot;, &quot;min&quot;)) 
    True 
    &gt;&gt;&gt; is_multi_agg_with_relabel() 
    False 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">all(isinstance(v</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">len(v) == </span><span class="s2">2 </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.values()) </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">len(kwargs) &gt; </span><span class="s2">0</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">normalize_keyword_aggregation(kwargs: dict) -&gt; tuple[dict</span><span class="s0">, </span><span class="s1">list[str]</span><span class="s0">, </span><span class="s1">list[int]]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Normalize user-provided &quot;named aggregation&quot; kwargs. 
    Transforms from the new ``Mapping[str, NamedAgg]`` style kwargs 
    to the old Dict[str, List[scalar]]]. 
 
    Parameters 
    ---------- 
    kwargs : dict 
 
    Returns 
    ------- 
    aggspec : dict 
        The transformed kwargs. 
    columns : List[str] 
        The user-provided keys. 
    col_idx_order : List[int] 
        List of columns indices. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; normalize_keyword_aggregation({&quot;output&quot;: (&quot;input&quot;, &quot;sum&quot;)}) 
    (defaultdict(&lt;class 'list'&gt;, {'input': ['sum']}), ('output',), array([0])) 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pandas.core.indexes.base </span><span class="s0">import </span><span class="s1">Index</span>

    <span class="s5"># Normalize the aggregation functions as Mapping[column, List[func]],</span>
    <span class="s5"># process normally, then fixup the names.</span>
    <span class="s5"># TODO: aggspec type: typing.Dict[str, List[AggScalar]]</span>
    <span class="s5"># May be hitting https://github.com/python/mypy/issues/5958</span>
    <span class="s5"># saying it doesn't have an attribute __name__</span>
    <span class="s1">aggspec: DefaultDict = defaultdict(list)</span>
    <span class="s1">order = []</span>
    <span class="s1">columns</span><span class="s0">, </span><span class="s1">pairs = list(zip(*kwargs.items()))</span>

    <span class="s0">for </span><span class="s1">column</span><span class="s0">, </span><span class="s1">aggfunc </span><span class="s0">in </span><span class="s1">pairs:</span>
        <span class="s1">aggspec[column].append(aggfunc)</span>
        <span class="s1">order.append((column</span><span class="s0">, </span><span class="s1">com.get_callable_name(aggfunc) </span><span class="s0">or </span><span class="s1">aggfunc))</span>

    <span class="s5"># uniquify aggfunc name if duplicated in order list</span>
    <span class="s1">uniquified_order = _make_unique_kwarg_list(order)</span>

    <span class="s5"># GH 25719, due to aggspec will change the order of assigned columns in aggregation</span>
    <span class="s5"># uniquified_aggspec will store uniquified order list and will compare it with order</span>
    <span class="s5"># based on index</span>
    <span class="s1">aggspec_order = [</span>
        <span class="s1">(column</span><span class="s0">, </span><span class="s1">com.get_callable_name(aggfunc) </span><span class="s0">or </span><span class="s1">aggfunc)</span>
        <span class="s0">for </span><span class="s1">column</span><span class="s0">, </span><span class="s1">aggfuncs </span><span class="s0">in </span><span class="s1">aggspec.items()</span>
        <span class="s0">for </span><span class="s1">aggfunc </span><span class="s0">in </span><span class="s1">aggfuncs</span>
    <span class="s1">]</span>
    <span class="s1">uniquified_aggspec = _make_unique_kwarg_list(aggspec_order)</span>

    <span class="s5"># get the new index of columns by comparison</span>
    <span class="s1">col_idx_order = Index(uniquified_aggspec).get_indexer(uniquified_order)</span>
    <span class="s5"># error: Incompatible return value type (got &quot;Tuple[defaultdict[Any, Any],</span>
    <span class="s5"># Any, ndarray]&quot;, expected &quot;Tuple[Dict[Any, Any], List[str], List[int]]&quot;)</span>
    <span class="s0">return </span><span class="s1">aggspec</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">col_idx_order  </span><span class="s5"># type: ignore[return-value]</span>


<span class="s0">def </span><span class="s1">_make_unique_kwarg_list(</span>
    <span class="s1">seq: Sequence[tuple[Any</span><span class="s0">, </span><span class="s1">Any]]</span>
<span class="s1">) -&gt; Sequence[tuple[Any</span><span class="s0">, </span><span class="s1">Any]]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Uniquify aggfunc name of the pairs in the order list 
 
    Examples: 
    -------- 
    &gt;&gt;&gt; kwarg_list = [('a', '&lt;lambda&gt;'), ('a', '&lt;lambda&gt;'), ('b', '&lt;lambda&gt;')] 
    &gt;&gt;&gt; _make_unique_kwarg_list(kwarg_list) 
    [('a', '&lt;lambda&gt;_0'), ('a', '&lt;lambda&gt;_1'), ('b', '&lt;lambda&gt;')] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">[</span>
        <span class="s1">(pair[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;_&quot;</span><span class="s1">.join([pair[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str(seq[:i].count(pair))]))</span>
        <span class="s0">if </span><span class="s1">seq.count(pair) &gt; </span><span class="s2">1</span>
        <span class="s0">else </span><span class="s1">pair</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">enumerate(seq)</span>
    <span class="s1">]</span>


<span class="s0">def </span><span class="s1">relabel_result(</span>
    <span class="s1">result: DataFrame | Series</span><span class="s0">,</span>
    <span class="s1">func: dict[str</span><span class="s0">, </span><span class="s1">list[Callable | str]]</span><span class="s0">,</span>
    <span class="s1">columns: Iterable[Hashable]</span><span class="s0">,</span>
    <span class="s1">order: Iterable[int]</span><span class="s0">,</span>
<span class="s1">) -&gt; dict[Hashable</span><span class="s0">, </span><span class="s1">Series]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Internal function to reorder result if relabelling is True for 
    dataframe.agg, and return the reordered result in dict. 
 
    Parameters: 
    ---------- 
    result: Result from aggregation 
    func: Dict of (column name, funcs) 
    columns: New columns name for relabelling 
    order: New order for relabelling 
 
    Examples: 
    --------- 
    &gt;&gt;&gt; result = DataFrame({&quot;A&quot;: [np.nan, 2, np.nan], 
    ...       &quot;C&quot;: [6, np.nan, np.nan], &quot;B&quot;: [np.nan, 4, 2.5]})  # doctest: +SKIP 
    &gt;&gt;&gt; funcs = {&quot;A&quot;: [&quot;max&quot;], &quot;C&quot;: [&quot;max&quot;], &quot;B&quot;: [&quot;mean&quot;, &quot;min&quot;]} 
    &gt;&gt;&gt; columns = (&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;) 
    &gt;&gt;&gt; order = [0, 1, 2, 3] 
    &gt;&gt;&gt; _relabel_result(result, func, columns, order)  # doctest: +SKIP 
    dict(A=Series([2.0, NaN, NaN, NaN], index=[&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;]), 
         C=Series([NaN, 6.0, NaN, NaN], index=[&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;]), 
         B=Series([NaN, NaN, 2.5, 4.0], index=[&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;])) 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pandas.core.indexes.base </span><span class="s0">import </span><span class="s1">Index</span>

    <span class="s1">reordered_indexes = [</span>
        <span class="s1">pair[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">sorted(zip(columns</span><span class="s0">, </span><span class="s1">order)</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">t: t[</span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">]</span>
    <span class="s1">reordered_result_in_dict: dict[Hashable</span><span class="s0">, </span><span class="s1">Series] = {}</span>
    <span class="s1">idx = </span><span class="s2">0</span>

    <span class="s1">reorder_mask = </span><span class="s0">not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">ABCSeries) </span><span class="s0">and </span><span class="s1">len(result.columns) &gt; </span><span class="s2">1</span>
    <span class="s0">for </span><span class="s1">col</span><span class="s0">, </span><span class="s1">fun </span><span class="s0">in </span><span class="s1">func.items():</span>
        <span class="s1">s = result[col].dropna()</span>

        <span class="s5"># In the `_aggregate`, the callable names are obtained and used in `result`, and</span>
        <span class="s5"># these names are ordered alphabetically. e.g.</span>
        <span class="s5">#           C2   C1</span>
        <span class="s5"># &lt;lambda&gt;   1  NaN</span>
        <span class="s5"># amax     NaN  4.0</span>
        <span class="s5"># max      NaN  4.0</span>
        <span class="s5"># sum     18.0  6.0</span>
        <span class="s5"># Therefore, the order of functions for each column could be shuffled</span>
        <span class="s5"># accordingly so need to get the callable name if it is not parsed names, and</span>
        <span class="s5"># reorder the aggregated result for each column.</span>
        <span class="s5"># e.g. if df.agg(c1=(&quot;C2&quot;, sum), c2=(&quot;C2&quot;, lambda x: min(x))), correct order is</span>
        <span class="s5"># [sum, &lt;lambda&gt;], but in `result`, it will be [&lt;lambda&gt;, sum], and we need to</span>
        <span class="s5"># reorder so that aggregated values map to their functions regarding the order.</span>

        <span class="s5"># However there is only one column being used for aggregation, not need to</span>
        <span class="s5"># reorder since the index is not sorted, and keep as is in `funcs`, e.g.</span>
        <span class="s5">#         A</span>
        <span class="s5"># min   1.0</span>
        <span class="s5"># mean  1.5</span>
        <span class="s5"># mean  1.5</span>
        <span class="s0">if </span><span class="s1">reorder_mask:</span>
            <span class="s1">fun = [</span>
                <span class="s1">com.get_callable_name(f) </span><span class="s0">if not </span><span class="s1">isinstance(f</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">else </span><span class="s1">f </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">fun</span>
            <span class="s1">]</span>
            <span class="s1">col_idx_order = Index(s.index).get_indexer(fun)</span>
            <span class="s1">s = s[col_idx_order]</span>

        <span class="s5"># assign the new user-provided &quot;named aggregation&quot; as index names, and reindex</span>
        <span class="s5"># it based on the whole user-provided names.</span>
        <span class="s1">s.index = reordered_indexes[idx : idx + len(fun)]</span>
        <span class="s1">reordered_result_in_dict[col] = s.reindex(columns</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">idx = idx + len(fun)</span>
    <span class="s0">return </span><span class="s1">reordered_result_in_dict</span>


<span class="s5"># TODO: Can't use, because mypy doesn't like us setting __name__</span>
<span class="s5">#   error: &quot;partial[Any]&quot; has no attribute &quot;__name__&quot;</span>
<span class="s5"># the type is:</span>
<span class="s5">#   typing.Sequence[Callable[..., ScalarResult]]</span>
<span class="s5">#     -&gt; typing.Sequence[Callable[..., ScalarResult]]:</span>


<span class="s0">def </span><span class="s1">_managle_lambda_list(aggfuncs: Sequence[Any]) -&gt; Sequence[Any]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Possibly mangle a list of aggfuncs. 
 
    Parameters 
    ---------- 
    aggfuncs : Sequence 
 
    Returns 
    ------- 
    mangled: list-like 
        A new AggSpec sequence, where lambdas have been converted 
        to have unique names. 
 
    Notes 
    ----- 
    If just one aggfunc is passed, the name will not be mangled. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(aggfuncs) &lt;= </span><span class="s2">1</span><span class="s1">:</span>
        <span class="s5"># don't mangle for .agg([lambda x: .])</span>
        <span class="s0">return </span><span class="s1">aggfuncs</span>
    <span class="s1">i = </span><span class="s2">0</span>
    <span class="s1">mangled_aggfuncs = []</span>
    <span class="s0">for </span><span class="s1">aggfunc </span><span class="s0">in </span><span class="s1">aggfuncs:</span>
        <span class="s0">if </span><span class="s1">com.get_callable_name(aggfunc) == </span><span class="s4">&quot;&lt;lambda&gt;&quot;</span><span class="s1">:</span>
            <span class="s1">aggfunc = partial(aggfunc)</span>
            <span class="s1">aggfunc.__name__ = </span><span class="s4">f&quot;&lt;lambda_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s4">&gt;&quot;</span>
            <span class="s1">i += </span><span class="s2">1</span>
        <span class="s1">mangled_aggfuncs.append(aggfunc)</span>

    <span class="s0">return </span><span class="s1">mangled_aggfuncs</span>


<span class="s0">def </span><span class="s1">maybe_mangle_lambdas(agg_spec: Any) -&gt; Any:</span>
    <span class="s3">&quot;&quot;&quot; 
    Make new lambdas with unique names. 
 
    Parameters 
    ---------- 
    agg_spec : Any 
        An argument to GroupBy.agg. 
        Non-dict-like `agg_spec` are pass through as is. 
        For dict-like `agg_spec` a new spec is returned 
        with name-mangled lambdas. 
 
    Returns 
    ------- 
    mangled : Any 
        Same type as the input. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; maybe_mangle_lambdas('sum') 
    'sum' 
    &gt;&gt;&gt; maybe_mangle_lambdas([lambda: 1, lambda: 2])  # doctest: +SKIP 
    [&lt;function __main__.&lt;lambda_0&gt;, 
     &lt;function pandas...._make_lambda.&lt;locals&gt;.f(*args, **kwargs)&gt;] 
    &quot;&quot;&quot;</span>
    <span class="s1">is_dict = is_dict_like(agg_spec)</span>
    <span class="s0">if not </span><span class="s1">(is_dict </span><span class="s0">or </span><span class="s1">is_list_like(agg_spec)):</span>
        <span class="s0">return </span><span class="s1">agg_spec</span>
    <span class="s1">mangled_aggspec = type(agg_spec)()  </span><span class="s5"># dict or OrderedDict</span>

    <span class="s0">if </span><span class="s1">is_dict:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">aggfuncs </span><span class="s0">in </span><span class="s1">agg_spec.items():</span>
            <span class="s0">if </span><span class="s1">is_list_like(aggfuncs) </span><span class="s0">and not </span><span class="s1">is_dict_like(aggfuncs):</span>
                <span class="s1">mangled_aggfuncs = _managle_lambda_list(aggfuncs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">mangled_aggfuncs = aggfuncs</span>

            <span class="s1">mangled_aggspec[key] = mangled_aggfuncs</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">mangled_aggspec = _managle_lambda_list(agg_spec)</span>

    <span class="s0">return </span><span class="s1">mangled_aggspec</span>


<span class="s0">def </span><span class="s1">validate_func_kwargs(</span>
    <span class="s1">kwargs: dict</span><span class="s0">,</span>
<span class="s1">) -&gt; tuple[list[str]</span><span class="s0">, </span><span class="s1">list[str | Callable[...</span><span class="s0">, </span><span class="s1">Any]]]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Validates types of user-provided &quot;named aggregation&quot; kwargs. 
    `TypeError` is raised if aggfunc is not `str` or callable. 
 
    Parameters 
    ---------- 
    kwargs : dict 
 
    Returns 
    ------- 
    columns : List[str] 
        List of user-provied keys. 
    func : List[Union[str, callable[...,Any]]] 
        List of user-provided aggfuncs 
 
    Examples 
    -------- 
    &gt;&gt;&gt; validate_func_kwargs({'one': 'min', 'two': 'max'}) 
    (['one', 'two'], ['min', 'max']) 
    &quot;&quot;&quot;</span>
    <span class="s1">tuple_given_message = </span><span class="s4">&quot;func is expected but received {} in **kwargs.&quot;</span>
    <span class="s1">columns = list(kwargs)</span>
    <span class="s1">func = []</span>
    <span class="s0">for </span><span class="s1">col_func </span><span class="s0">in </span><span class="s1">kwargs.values():</span>
        <span class="s0">if not </span><span class="s1">(isinstance(col_func</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or </span><span class="s1">callable(col_func)):</span>
            <span class="s0">raise </span><span class="s1">TypeError(tuple_given_message.format(type(col_func).__name__))</span>
        <span class="s1">func.append(col_func)</span>
    <span class="s0">if not </span><span class="s1">columns:</span>
        <span class="s1">no_arg_message = </span><span class="s4">&quot;Must provide 'func' or named aggregation **kwargs.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(no_arg_message)</span>
    <span class="s0">return </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">func</span>
</pre>
</body>
</html>