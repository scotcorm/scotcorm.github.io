<html>
<head>
<title>test_numpy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_numpy.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
 
Note: we do not bother with base.BaseIndexTests because PandasArray 
will never be held in an Index. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">can_hold_element</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
    <span class="s1">PandasDtype</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.numpy_ </span><span class="s2">import </span><span class="s1">PandasArray</span>
<span class="s2">from </span><span class="s1">pandas.core.internals </span><span class="s2">import </span><span class="s1">blocks</span>
<span class="s2">from </span><span class="s1">pandas.tests.extension </span><span class="s2">import </span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">_can_hold_element_patched(obj</span><span class="s2">, </span><span class="s1">element) -&gt; bool:</span>
    <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">PandasArray):</span>
        <span class="s1">element = element.to_numpy()</span>
    <span class="s2">return </span><span class="s1">can_hold_element(obj</span><span class="s2">, </span><span class="s1">element)</span>


<span class="s1">orig_assert_attr_equal = tm.assert_attr_equal</span>


<span class="s2">def </span><span class="s1">_assert_attr_equal(attr: str</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">obj: str = </span><span class="s3">&quot;Attributes&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    patch tm.assert_attr_equal so PandasDtype(&quot;object&quot;) is closed enough to 
    np.dtype(&quot;object&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attr == </span><span class="s3">&quot;dtype&quot;</span><span class="s1">:</span>
        <span class="s1">lattr = getattr(left</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">rattr = getattr(right</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(lattr</span><span class="s2">, </span><span class="s1">PandasDtype) </span><span class="s2">and not </span><span class="s1">isinstance(rattr</span><span class="s2">, </span><span class="s1">PandasDtype):</span>
            <span class="s1">left = left.astype(lattr.numpy_dtype)</span>
        <span class="s2">elif </span><span class="s1">isinstance(rattr</span><span class="s2">, </span><span class="s1">PandasDtype) </span><span class="s2">and not </span><span class="s1">isinstance(lattr</span><span class="s2">, </span><span class="s1">PandasDtype):</span>
            <span class="s1">right = right.astype(rattr.numpy_dtype)</span>

    <span class="s1">orig_assert_attr_equal(attr</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">obj)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;float&quot;</span><span class="s2">, </span><span class="s3">&quot;object&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">dtype(request):</span>
    <span class="s2">return </span><span class="s1">PandasDtype(np.dtype(request.param))</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">allow_in_pandas(monkeypatch):</span>
    <span class="s0">&quot;&quot;&quot; 
    A monkeypatch to tells pandas to let us in. 
 
    By default, passing a PandasArray to an index / series / frame 
    constructor will unbox that PandasArray to an ndarray, and treat 
    it as a non-EA column. We don't want people using EAs without 
    reason. 
 
    The mechanism for this is a check against ABCPandasArray 
    in each constructor. 
 
    But, for testing, we need to allow them in pandas. So we patch 
    the _typ of PandasArray, so that we evade the ABCPandasArray 
    check. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">monkeypatch.context() </span><span class="s2">as </span><span class="s1">m:</span>
        <span class="s1">m.setattr(PandasArray</span><span class="s2">, </span><span class="s3">&quot;_typ&quot;</span><span class="s2">, </span><span class="s3">&quot;extension&quot;</span><span class="s1">)</span>
        <span class="s1">m.setattr(blocks</span><span class="s2">, </span><span class="s3">&quot;can_hold_element&quot;</span><span class="s2">, </span><span class="s1">_can_hold_element_patched)</span>
        <span class="s1">m.setattr(tm.asserters</span><span class="s2">, </span><span class="s3">&quot;assert_attr_equal&quot;</span><span class="s2">, </span><span class="s1">_assert_attr_equal)</span>
        <span class="s2">yield</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data(allow_in_pandas</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.numpy_dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.Series([(i</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">100</span><span class="s1">)]).array</span>
    <span class="s2">return </span><span class="s1">PandasArray(np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">101</span><span class="s2">, </span><span class="s1">dtype=dtype._dtype))</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing(allow_in_pandas</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.numpy_dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">PandasArray(np.array([np.nan</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=object))</span>
    <span class="s2">return </span><span class="s1">PandasArray(np.array([np.nan</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]))</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_value():</span>
    <span class="s2">return </span><span class="s1">np.nan</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_cmp():</span>
    <span class="s2">def </span><span class="s1">cmp(a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s2">return </span><span class="s1">np.isnan(a) </span><span class="s2">and </span><span class="s1">np.isnan(b)</span>

    <span class="s2">return </span><span class="s1">cmp</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_sorting(allow_in_pandas</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s0">&quot;&quot;&quot;Length-3 array with a known sort order. 
 
    This should be three items [B, C, A] with 
    A &lt; B &lt; C 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.numpy_dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s5"># Use an empty tuple for first element, then remove,</span>
        <span class="s5"># to disable np.array's shape inference.</span>
        <span class="s2">return </span><span class="s1">PandasArray(np.array([()</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=object)[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s2">return </span><span class="s1">PandasArray(np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting(allow_in_pandas</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s0">&quot;&quot;&quot;Length-3 array with a known sort order. 
 
    This should be three items [B, NA, A] with 
    A &lt; B and NA missing. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.numpy_dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">PandasArray(np.array([(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=object))</span>
    <span class="s2">return </span><span class="s1">PandasArray(np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_grouping(allow_in_pandas</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s0">&quot;&quot;&quot;Data for factorization, grouping, and unique tests. 
 
    Expected to be like [B, B, NA, NA, A, A, B, C] 
 
    Where A &lt; B &lt; C and NA is missing 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.numpy_dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c = (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c = np.arange(</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">PandasArray(</span>
        <span class="s1">np.array([b</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c]</span><span class="s2">, </span><span class="s1">dtype=dtype.numpy_dtype)</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">skip_numpy_object(dtype</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for PandasArray with nested data. Users typically won't create 
    these objects via `pd.array`, but they can show up through `.array` 
    on a Series with nested data. Many of the base tests fail, as they aren't 
    appropriate for nested data. 
 
    This fixture allows these tests to be skipped when used as a usefixtures 
    marker to either an individual test or a test class. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
        <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s3">&quot;Fails for object dtype&quot;</span><span class="s1">)</span>
        <span class="s1">request.node.add_marker(mark)</span>


<span class="s1">skip_nested = pytest.mark.usefixtures(</span><span class="s3">&quot;skip_numpy_object&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">BaseNumPyTests:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">assert_series_equal(cls</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5"># base class tests hard-code expected values with numpy dtypes,</span>
        <span class="s5">#  whereas we generally want the corresponding PandasDtype</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(right</span><span class="s2">, </span><span class="s1">pd.Series)</span>
            <span class="s2">and not </span><span class="s1">isinstance(right.dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype)</span>
            <span class="s2">and </span><span class="s1">isinstance(left.dtype</span><span class="s2">, </span><span class="s1">PandasDtype)</span>
        <span class="s1">):</span>
            <span class="s1">right = right.astype(PandasDtype(right.dtype))</span>
        <span class="s2">return </span><span class="s1">tm.assert_series_equal(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">TestCasting(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseCastingTests):</span>
    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_astype_str(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># ValueError: setting an array element with a sequence</span>
        <span class="s1">super().test_astype_str(data)</span>


<span class="s2">class </span><span class="s1">TestConstructors(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseConstructorsTests):</span>
    <span class="s1">@pytest.mark.skip(reason=</span><span class="s3">&quot;We don't register our dtype&quot;</span><span class="s1">)</span>
    <span class="s5"># We don't want to register. This test should probably be split in two.</span>
    <span class="s2">def </span><span class="s1">test_from_dtype(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">pass</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_series_constructor_scalar_with_index(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s5"># ValueError: Length of passed values is 1, index implies 3.</span>
        <span class="s1">super().test_series_constructor_scalar_with_index(data</span><span class="s2">, </span><span class="s1">dtype)</span>


<span class="s2">class </span><span class="s1">TestDtype(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseDtypeTests):</span>
    <span class="s1">@pytest.mark.skip(reason=</span><span class="s3">&quot;Incorrect expected.&quot;</span><span class="s1">)</span>
    <span class="s5"># we unsurprisingly clash with a NumPy name.</span>
    <span class="s2">def </span><span class="s1">test_check_dtype(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestGetitem(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseGetitemTests):</span>
    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_getitem_scalar(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># AssertionError</span>
        <span class="s1">super().test_getitem_scalar(data)</span>


<span class="s2">class </span><span class="s1">TestGroupby(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseGroupbyTests):</span>
    <span class="s2">def </span><span class="s1">test_groupby_extension_apply(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data_for_grouping</span><span class="s2">, </span><span class="s1">groupby_apply_op</span><span class="s2">, </span><span class="s1">request</span>
    <span class="s1">):</span>
        <span class="s1">dummy = groupby_apply_op([</span><span class="s2">None</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(dummy</span><span class="s2">, </span><span class="s1">pd.Series)</span>
            <span class="s2">and </span><span class="s1">data_for_grouping.dtype.numpy_dtype == object</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s3">&quot;raises in MultiIndex construction&quot;</span><span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>
        <span class="s1">super().test_groupby_extension_apply(data_for_grouping</span><span class="s2">, </span><span class="s1">groupby_apply_op)</span>


<span class="s2">class </span><span class="s1">TestInterface(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseInterfaceTests):</span>
    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_array_interface(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># NumPy array shape inference</span>
        <span class="s1">super().test_array_interface(data)</span>


<span class="s2">class </span><span class="s1">TestMethods(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseMethodsTests):</span>
    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_shift_fill_value(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># np.array shape inference. Shift implementation fails.</span>
        <span class="s1">super().test_shift_fill_value(data)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_copy_frame(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s5"># The &quot;scalar&quot; for this array isn't a scalar.</span>
        <span class="s1">super().test_fillna_copy_frame(data_missing)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_copy_series(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s5"># The &quot;scalar&quot; for this array isn't a scalar.</span>
        <span class="s1">super().test_fillna_copy_series(data_missing)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_searchsorted(self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">as_series):</span>
        <span class="s5"># Test setup fails.</span>
        <span class="s1">super().test_searchsorted(data_for_sorting</span><span class="s2">, </span><span class="s1">as_series)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s3">&quot;PandasArray.diff may fail on dtype&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_diff(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">periods):</span>
        <span class="s2">return </span><span class="s1">super().test_diff(data</span><span class="s2">, </span><span class="s1">periods)</span>

    <span class="s2">def </span><span class="s1">test_insert(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">data.dtype.numpy_dtype == object:</span>
            <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s3">&quot;Dimension mismatch in np.concatenate&quot;</span><span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s1">super().test_insert(data)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_insert_invalid(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">invalid_scalar):</span>
        <span class="s5"># PandasArray[object] can hold anything, so skip</span>
        <span class="s1">super().test_insert_invalid(data</span><span class="s2">, </span><span class="s1">invalid_scalar)</span>


<span class="s2">class </span><span class="s1">TestArithmetics(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseArithmeticOpsTests):</span>
    <span class="s1">divmod_exc = </span><span class="s2">None</span>
    <span class="s1">series_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">frame_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">series_array_exc = </span><span class="s2">None</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_divmod(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_divmod(data)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_divmod_series_array(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">ser = pd.Series(data)</span>
        <span class="s1">self._check_divmod_op(ser</span><span class="s2">, </span><span class="s1">divmod</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_arith_series_with_scalar(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators):</span>
        <span class="s1">super().test_arith_series_with_scalar(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">opname = all_arithmetic_operators</span>
        <span class="s2">if </span><span class="s1">data.dtype.numpy_dtype == object </span><span class="s2">and </span><span class="s1">opname </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;__add__&quot;</span><span class="s2">, </span><span class="s3">&quot;__radd__&quot;</span><span class="s1">]:</span>
            <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s3">&quot;Fails for object dtype&quot;</span><span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>
        <span class="s1">super().test_arith_series_with_array(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_arith_frame_with_scalar(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators):</span>
        <span class="s1">super().test_arith_frame_with_scalar(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>


<span class="s2">class </span><span class="s1">TestPrinting(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BasePrintingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestNumericReduce(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseNumericReduceTests):</span>
    <span class="s2">def </span><span class="s1">check_reduce(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna):</span>
        <span class="s1">result = getattr(s</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
        <span class="s5"># avoid coercing int -&gt; float. Just cast to the actual numpy type.</span>
        <span class="s1">expected = getattr(s.astype(s.dtype._dtype)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_reduce_series(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_boolean_reductions</span><span class="s2">, </span><span class="s1">skipna):</span>
        <span class="s1">super().test_reduce_series(data</span><span class="s2">, </span><span class="s1">all_boolean_reductions</span><span class="s2">, </span><span class="s1">skipna)</span>


<span class="s1">@skip_nested</span>
<span class="s2">class </span><span class="s1">TestBooleanReduce(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseBooleanReduceTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestMissing(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseMissingTests):</span>
    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_series(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s5"># Non-scalar &quot;scalar&quot; values.</span>
        <span class="s1">super().test_fillna_series(data_missing)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_frame(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s5"># Non-scalar &quot;scalar&quot; values.</span>
        <span class="s1">super().test_fillna_frame(data_missing)</span>


<span class="s2">class </span><span class="s1">TestReshaping(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseReshapingTests):</span>
    <span class="s1">@pytest.mark.skip(reason=</span><span class="s3">&quot;Incorrect expected.&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_merge(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s5"># Fails creating expected (key column becomes a PandasDtype because)</span>
        <span class="s1">super().test_merge(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;in_frame&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s2">True,</span>
            <span class="s1">pytest.param(</span>
                <span class="s2">False,</span>
                <span class="s1">marks=pytest.mark.xfail(reason=</span><span class="s3">&quot;PandasArray inconsistently extracted&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_concat(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">in_frame):</span>
        <span class="s1">super().test_concat(data</span><span class="s2">, </span><span class="s1">in_frame)</span>


<span class="s2">class </span><span class="s1">TestSetitem(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseSetitemTests):</span>
    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_invalid(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">invalid_scalar):</span>
        <span class="s5"># object dtype can hold anything, so doesn't raise</span>
        <span class="s1">super().test_setitem_invalid(data</span><span class="s2">, </span><span class="s1">invalid_scalar)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_sequence_broadcasts(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series):</span>
        <span class="s5"># ValueError: cannot set using a list-like indexer with a different</span>
        <span class="s5"># length than the value</span>
        <span class="s1">super().test_setitem_sequence_broadcasts(data</span><span class="s2">, </span><span class="s1">box_in_series)</span>

    <span class="s1">@skip_nested</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;setter&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;loc&quot;</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_setitem_mask_broadcast(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">setter):</span>
        <span class="s5"># ValueError: cannot set using a list-like indexer with a different</span>
        <span class="s5"># length than the value</span>
        <span class="s1">super().test_setitem_mask_broadcast(data</span><span class="s2">, </span><span class="s1">setter)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_scalar_key_sequence_raise(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</span>
        <span class="s1">super().test_setitem_scalar_key_sequence_raise(data)</span>

    <span class="s5"># TODO: there is some issue with PandasArray, therefore,</span>
    <span class="s5">#   skip the setitem test for now, and fix it later (GH 31446)</span>

    <span class="s1">@skip_nested</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;mask&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">np.array([</span><span class="s2">True, True, True, False, False</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">pd.array([</span><span class="s2">True, True, True, False, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s3">&quot;numpy-array&quot;</span><span class="s2">, </span><span class="s3">&quot;boolean-array&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_mask(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">box_in_series):</span>
        <span class="s1">super().test_setitem_mask(data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">box_in_series)</span>

    <span class="s2">def </span><span class="s1">test_setitem_mask_raises(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series):</span>
        <span class="s1">super().test_setitem_mask_raises(data</span><span class="s2">, </span><span class="s1">box_in_series)</span>

    <span class="s1">@skip_nested</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;idx&quot;</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pd.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s3">&quot;list&quot;</span><span class="s2">, </span><span class="s3">&quot;integer-array&quot;</span><span class="s2">, </span><span class="s3">&quot;numpy-array&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_integer_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series):</span>
        <span class="s1">super().test_setitem_integer_array(data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;idx, box_in_series&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, True, </span><span class="s1">marks=pytest.mark.xfail)</span><span class="s2">,</span>
            <span class="s1">(pd.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(pd.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s3">&quot;list-False&quot;</span><span class="s2">, </span><span class="s3">&quot;list-True&quot;</span><span class="s2">, </span><span class="s3">&quot;integer-array-False&quot;</span><span class="s2">, </span><span class="s3">&quot;integer-array-True&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_integer_with_missing_raises(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series):</span>
        <span class="s1">super().test_setitem_integer_with_missing_raises(data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_slice(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series):</span>
        <span class="s1">super().test_setitem_slice(data</span><span class="s2">, </span><span class="s1">box_in_series)</span>

    <span class="s1">@skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_loc_iloc_slice(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_setitem_loc_iloc_slice(data)</span>

    <span class="s2">def </span><span class="s1">test_setitem_with_expansion_dataframe_column(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">full_indexer):</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/32395</span>
        <span class="s1">df = expected = pd.DataFrame({</span><span class="s3">&quot;data&quot;</span><span class="s1">: pd.Series(data)})</span>
        <span class="s1">result = pd.DataFrame(index=df.index)</span>

        <span class="s5"># because result has object dtype, the attempt to do setting inplace</span>
        <span class="s5">#  is successful, and object dtype is retained</span>
        <span class="s1">key = full_indexer(df)</span>
        <span class="s1">result.loc[key</span><span class="s2">, </span><span class="s3">&quot;data&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;data&quot;</span><span class="s1">]</span>

        <span class="s5"># base class method has expected = df; PandasArray behaves oddly because</span>
        <span class="s5">#  we patch _typ for these tests.</span>
        <span class="s2">if </span><span class="s1">data.dtype.numpy_dtype != object:</span>
            <span class="s2">if not </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">slice) </span><span class="s2">or </span><span class="s1">key != slice(</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s1">expected = pd.DataFrame({</span><span class="s3">&quot;data&quot;</span><span class="s1">: data.to_numpy()})</span>
        <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@skip_nested</span>
<span class="s2">class </span><span class="s1">TestParsing(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.BaseParsingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">Test2DCompat(BaseNumPyTests</span><span class="s2">, </span><span class="s1">base.NDArrayBacked2DTests):</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>