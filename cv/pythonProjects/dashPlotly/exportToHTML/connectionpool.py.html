<html>
<head>
<title>connectionpool.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
connectionpool.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">errno</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">socket</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">socket </span><span class="s0">import </span><span class="s1">error </span><span class="s0">as </span><span class="s1">SocketError</span>
<span class="s0">from </span><span class="s1">socket </span><span class="s0">import </span><span class="s1">timeout </span><span class="s0">as </span><span class="s1">SocketTimeout</span>

<span class="s0">from </span><span class="s1">.connection </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseSSLError</span><span class="s0">,</span>
    <span class="s1">BrokenPipeError</span><span class="s0">,</span>
    <span class="s1">DummyConnection</span><span class="s0">,</span>
    <span class="s1">HTTPConnection</span><span class="s0">,</span>
    <span class="s1">HTTPException</span><span class="s0">,</span>
    <span class="s1">HTTPSConnection</span><span class="s0">,</span>
    <span class="s1">VerifiedHTTPSConnection</span><span class="s0">,</span>
    <span class="s1">port_by_scheme</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ClosedPoolError</span><span class="s0">,</span>
    <span class="s1">EmptyPoolError</span><span class="s0">,</span>
    <span class="s1">HeaderParsingError</span><span class="s0">,</span>
    <span class="s1">HostChangedError</span><span class="s0">,</span>
    <span class="s1">InsecureRequestWarning</span><span class="s0">,</span>
    <span class="s1">LocationValueError</span><span class="s0">,</span>
    <span class="s1">MaxRetryError</span><span class="s0">,</span>
    <span class="s1">NewConnectionError</span><span class="s0">,</span>
    <span class="s1">ProtocolError</span><span class="s0">,</span>
    <span class="s1">ProxyError</span><span class="s0">,</span>
    <span class="s1">ReadTimeoutError</span><span class="s0">,</span>
    <span class="s1">SSLError</span><span class="s0">,</span>
    <span class="s1">TimeoutError</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.packages </span><span class="s0">import </span><span class="s1">six</span>
<span class="s0">from </span><span class="s1">.packages.six.moves </span><span class="s0">import </span><span class="s1">queue</span>
<span class="s0">from </span><span class="s1">.request </span><span class="s0">import </span><span class="s1">RequestMethods</span>
<span class="s0">from </span><span class="s1">.response </span><span class="s0">import </span><span class="s1">HTTPResponse</span>
<span class="s0">from </span><span class="s1">.util.connection </span><span class="s0">import </span><span class="s1">is_connection_dropped</span>
<span class="s0">from </span><span class="s1">.util.proxy </span><span class="s0">import </span><span class="s1">connection_requires_http_tunnel</span>
<span class="s0">from </span><span class="s1">.util.queue </span><span class="s0">import </span><span class="s1">LifoQueue</span>
<span class="s0">from </span><span class="s1">.util.request </span><span class="s0">import </span><span class="s1">set_file_position</span>
<span class="s0">from </span><span class="s1">.util.response </span><span class="s0">import </span><span class="s1">assert_header_parsing</span>
<span class="s0">from </span><span class="s1">.util.retry </span><span class="s0">import </span><span class="s1">Retry</span>
<span class="s0">from </span><span class="s1">.util.ssl_match_hostname </span><span class="s0">import </span><span class="s1">CertificateError</span>
<span class="s0">from </span><span class="s1">.util.timeout </span><span class="s0">import </span><span class="s1">Timeout</span>
<span class="s0">from </span><span class="s1">.util.url </span><span class="s0">import </span><span class="s1">Url</span><span class="s0">, </span><span class="s1">_encode_target</span>
<span class="s0">from </span><span class="s1">.util.url </span><span class="s0">import </span><span class="s1">_normalize_host </span><span class="s0">as </span><span class="s1">normalize_host</span>
<span class="s0">from </span><span class="s1">.util.url </span><span class="s0">import </span><span class="s1">get_host</span><span class="s0">, </span><span class="s1">parse_url</span>

<span class="s1">xrange = six.moves.xrange</span>

<span class="s1">log = logging.getLogger(__name__)</span>

<span class="s1">_Default = object()</span>


<span class="s2"># Pool objects</span>
<span class="s0">class </span><span class="s1">ConnectionPool(object):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for all connection pools, such as 
    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`. 
 
    .. note:: 
       ConnectionPool.urlopen() does not normalize or percent-encode target URIs 
       which is useful if your target server doesn't support percent-encoded 
       target URIs. 
    &quot;&quot;&quot;</span>

    <span class="s1">scheme = </span><span class="s0">None</span>
    <span class="s1">QueueCls = LifoQueue</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">host:</span>
            <span class="s0">raise </span><span class="s1">LocationValueError(</span><span class="s4">&quot;No host specified.&quot;</span><span class="s1">)</span>

        <span class="s1">self.host = _normalize_host(host</span><span class="s0">, </span><span class="s1">scheme=self.scheme)</span>
        <span class="s1">self._proxy_host = host.lower()</span>
        <span class="s1">self.port = port</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s4">&quot;%s(host=%r, port=%r)&quot; </span><span class="s1">% (type(self).__name__</span><span class="s0">, </span><span class="s1">self.host</span><span class="s0">, </span><span class="s1">self.port)</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_val</span><span class="s0">, </span><span class="s1">exc_tb):</span>
        <span class="s1">self.close()</span>
        <span class="s2"># Return False to re-raise any potential exceptions</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Close all pooled connections and disable the pool. 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>


<span class="s2"># This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252</span>
<span class="s1">_blocking_errnos = {errno.EAGAIN</span><span class="s0">, </span><span class="s1">errno.EWOULDBLOCK}</span>


<span class="s0">class </span><span class="s1">HTTPConnectionPool(ConnectionPool</span><span class="s0">, </span><span class="s1">RequestMethods):</span>
    <span class="s3">&quot;&quot;&quot; 
    Thread-safe connection pool for one host. 
 
    :param host: 
        Host used for this HTTP Connection (e.g. &quot;localhost&quot;), passed into 
        :class:`http.client.HTTPConnection`. 
 
    :param port: 
        Port used for this HTTP Connection (None is equivalent to 80), passed 
        into :class:`http.client.HTTPConnection`. 
 
    :param strict: 
        Causes BadStatusLine to be raised if the status line can't be parsed 
        as a valid HTTP/1.0 or 1.1 status line, passed into 
        :class:`http.client.HTTPConnection`. 
 
        .. note:: 
           Only works in Python 2. This parameter is ignored in Python 3. 
 
    :param timeout: 
        Socket timeout in seconds for each individual connection. This can 
        be a float or integer, which sets the timeout for the HTTP request, 
        or an instance of :class:`urllib3.util.Timeout` which gives you more 
        fine-grained control over request timeouts. After the constructor has 
        been parsed, this is always a `urllib3.util.Timeout` object. 
 
    :param maxsize: 
        Number of connections to save that can be reused. More than 1 is useful 
        in multithreaded situations. If ``block`` is set to False, more 
        connections will be created but they will not be saved once they've 
        been used. 
 
    :param block: 
        If set to True, no more than ``maxsize`` connections will be used at 
        a time. When no free connections are available, the call will block 
        until a connection has been released. This is a useful side effect for 
        particular multithreaded situations where one does not want to use more 
        than maxsize connections per host to prevent flooding. 
 
    :param headers: 
        Headers to include with all requests, unless other headers are given 
        explicitly. 
 
    :param retries: 
        Retry configuration to use by default with requests in this pool. 
 
    :param _proxy: 
        Parsed proxy URL, should not be used directly, instead, see 
        :class:`urllib3.ProxyManager` 
 
    :param _proxy_headers: 
        A dictionary with proxy headers, should not be used directly, 
        instead, see :class:`urllib3.ProxyManager` 
 
    :param \\**conn_kw: 
        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`, 
        :class:`urllib3.connection.HTTPSConnection` instances. 
    &quot;&quot;&quot;</span>

    <span class="s1">scheme = </span><span class="s4">&quot;http&quot;</span>
    <span class="s1">ConnectionCls = HTTPConnection</span>
    <span class="s1">ResponseCls = HTTPResponse</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">host</span><span class="s0">,</span>
        <span class="s1">port=</span><span class="s0">None,</span>
        <span class="s1">strict=</span><span class="s0">False,</span>
        <span class="s1">timeout=Timeout.DEFAULT_TIMEOUT</span><span class="s0">,</span>
        <span class="s1">maxsize=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">block=</span><span class="s0">False,</span>
        <span class="s1">headers=</span><span class="s0">None,</span>
        <span class="s1">retries=</span><span class="s0">None,</span>
        <span class="s1">_proxy=</span><span class="s0">None,</span>
        <span class="s1">_proxy_headers=</span><span class="s0">None,</span>
        <span class="s1">_proxy_config=</span><span class="s0">None,</span>
        <span class="s1">**conn_kw</span>
    <span class="s1">):</span>
        <span class="s1">ConnectionPool.__init__(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port)</span>
        <span class="s1">RequestMethods.__init__(self</span><span class="s0">, </span><span class="s1">headers)</span>

        <span class="s1">self.strict = strict</span>

        <span class="s0">if not </span><span class="s1">isinstance(timeout</span><span class="s0">, </span><span class="s1">Timeout):</span>
            <span class="s1">timeout = Timeout.from_float(timeout)</span>

        <span class="s0">if </span><span class="s1">retries </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">retries = Retry.DEFAULT</span>

        <span class="s1">self.timeout = timeout</span>
        <span class="s1">self.retries = retries</span>

        <span class="s1">self.pool = self.QueueCls(maxsize)</span>
        <span class="s1">self.block = block</span>

        <span class="s1">self.proxy = _proxy</span>
        <span class="s1">self.proxy_headers = _proxy_headers </span><span class="s0">or </span><span class="s1">{}</span>
        <span class="s1">self.proxy_config = _proxy_config</span>

        <span class="s2"># Fill the queue up so that doing get() on it will block properly</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">xrange(maxsize):</span>
            <span class="s1">self.pool.put(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># These are mostly for testing and debugging purposes.</span>
        <span class="s1">self.num_connections = </span><span class="s5">0</span>
        <span class="s1">self.num_requests = </span><span class="s5">0</span>
        <span class="s1">self.conn_kw = conn_kw</span>

        <span class="s0">if </span><span class="s1">self.proxy:</span>
            <span class="s2"># Enable Nagle's algorithm for proxies, to avoid packet fragmentation.</span>
            <span class="s2"># We cannot know if the user has added default socket options, so we cannot replace the</span>
            <span class="s2"># list.</span>
            <span class="s1">self.conn_kw.setdefault(</span><span class="s4">&quot;socket_options&quot;</span><span class="s0">, </span><span class="s1">[])</span>

            <span class="s1">self.conn_kw[</span><span class="s4">&quot;proxy&quot;</span><span class="s1">] = self.proxy</span>
            <span class="s1">self.conn_kw[</span><span class="s4">&quot;proxy_config&quot;</span><span class="s1">] = self.proxy_config</span>

    <span class="s0">def </span><span class="s1">_new_conn(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a fresh :class:`HTTPConnection`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.num_connections += </span><span class="s5">1</span>
        <span class="s1">log.debug(</span>
            <span class="s4">&quot;Starting new HTTP connection (%d): %s:%s&quot;</span><span class="s0">,</span>
            <span class="s1">self.num_connections</span><span class="s0">,</span>
            <span class="s1">self.host</span><span class="s0">,</span>
            <span class="s1">self.port </span><span class="s0">or </span><span class="s4">&quot;80&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">conn = self.ConnectionCls(</span>
            <span class="s1">host=self.host</span><span class="s0">,</span>
            <span class="s1">port=self.port</span><span class="s0">,</span>
            <span class="s1">timeout=self.timeout.connect_timeout</span><span class="s0">,</span>
            <span class="s1">strict=self.strict</span><span class="s0">,</span>
            <span class="s1">**self.conn_kw</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">conn</span>

    <span class="s0">def </span><span class="s1">_get_conn(self</span><span class="s0">, </span><span class="s1">timeout=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get a connection. Will return a pooled connection if one is available. 
 
        If no connections are available and :prop:`.block` is ``False``, then a 
        fresh connection is returned. 
 
        :param timeout: 
            Seconds to wait before giving up and raising 
            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and 
            :prop:`.block` is ``True``. 
        &quot;&quot;&quot;</span>
        <span class="s1">conn = </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">conn = self.pool.get(block=self.block</span><span class="s0">, </span><span class="s1">timeout=timeout)</span>

        <span class="s0">except </span><span class="s1">AttributeError:  </span><span class="s2"># self.pool is None</span>
            <span class="s0">raise </span><span class="s1">ClosedPoolError(self</span><span class="s0">, </span><span class="s4">&quot;Pool is closed.&quot;</span><span class="s1">)</span>

        <span class="s0">except </span><span class="s1">queue.Empty:</span>
            <span class="s0">if </span><span class="s1">self.block:</span>
                <span class="s0">raise </span><span class="s1">EmptyPoolError(</span>
                    <span class="s1">self</span><span class="s0">,</span>
                    <span class="s4">&quot;Pool reached maximum size and no more connections are allowed.&quot;</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">pass  </span><span class="s2"># Oh well, we'll create a new connection then</span>

        <span class="s2"># If this is a persistent connection, check if it got disconnected</span>
        <span class="s0">if </span><span class="s1">conn </span><span class="s0">and </span><span class="s1">is_connection_dropped(conn):</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;Resetting dropped connection: %s&quot;</span><span class="s0">, </span><span class="s1">self.host)</span>
            <span class="s1">conn.close()</span>
            <span class="s0">if </span><span class="s1">getattr(conn</span><span class="s0">, </span><span class="s4">&quot;auto_open&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2"># This is a proxied connection that has been mutated by</span>
                <span class="s2"># http.client._tunnel() and cannot be reused (since it would</span>
                <span class="s2"># attempt to bypass the proxy)</span>
                <span class="s1">conn = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">conn </span><span class="s0">or </span><span class="s1">self._new_conn()</span>

    <span class="s0">def </span><span class="s1">_put_conn(self</span><span class="s0">, </span><span class="s1">conn):</span>
        <span class="s3">&quot;&quot;&quot; 
        Put a connection back into the pool. 
 
        :param conn: 
            Connection object for the current host and port as returned by 
            :meth:`._new_conn` or :meth:`._get_conn`. 
 
        If the pool is already full, the connection is closed and discarded 
        because we exceeded maxsize. If connections are discarded frequently, 
        then maxsize should be increased. 
 
        If the pool is closed, then the connection will be closed and discarded. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.pool.put(conn</span><span class="s0">, </span><span class="s1">block=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">return  </span><span class="s2"># Everything is dandy, done.</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># self.pool is None.</span>
            <span class="s0">pass</span>
        <span class="s0">except </span><span class="s1">queue.Full:</span>
            <span class="s2"># This should never happen if self.block == True</span>
            <span class="s1">log.warning(</span>
                <span class="s4">&quot;Connection pool is full, discarding connection: %s. Connection pool size: %s&quot;</span><span class="s0">,</span>
                <span class="s1">self.host</span><span class="s0">,</span>
                <span class="s1">self.pool.qsize()</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s2"># Connection never got put back into the pool, close it.</span>
        <span class="s0">if </span><span class="s1">conn:</span>
            <span class="s1">conn.close()</span>

    <span class="s0">def </span><span class="s1">_validate_conn(self</span><span class="s0">, </span><span class="s1">conn):</span>
        <span class="s3">&quot;&quot;&quot; 
        Called right before a request is made, after the socket is created. 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_prepare_proxy(self</span><span class="s0">, </span><span class="s1">conn):</span>
        <span class="s2"># Nothing to do for HTTP connections.</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_get_timeout(self</span><span class="s0">, </span><span class="s1">timeout):</span>
        <span class="s3">&quot;&quot;&quot;Helper that always returns a :class:`urllib3.util.Timeout`&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">timeout </span><span class="s0">is </span><span class="s1">_Default:</span>
            <span class="s0">return </span><span class="s1">self.timeout.clone()</span>

        <span class="s0">if </span><span class="s1">isinstance(timeout</span><span class="s0">, </span><span class="s1">Timeout):</span>
            <span class="s0">return </span><span class="s1">timeout.clone()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># User passed us an int/float. This is for backwards compatibility,</span>
            <span class="s2"># can be removed later</span>
            <span class="s0">return </span><span class="s1">Timeout.from_float(timeout)</span>

    <span class="s0">def </span><span class="s1">_raise_timeout(self</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">timeout_value):</span>
        <span class="s3">&quot;&quot;&quot;Is the error actually a timeout? Will raise a ReadTimeout or pass&quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(err</span><span class="s0">, </span><span class="s1">SocketTimeout):</span>
            <span class="s0">raise </span><span class="s1">ReadTimeoutError(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s4">&quot;Read timed out. (read timeout=%s)&quot; </span><span class="s1">% timeout_value</span>
            <span class="s1">)</span>

        <span class="s2"># See the above comment about EAGAIN in Python 3. In Python 2 we have</span>
        <span class="s2"># to specifically catch it and throw the timeout error</span>
        <span class="s0">if </span><span class="s1">hasattr(err</span><span class="s0">, </span><span class="s4">&quot;errno&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">err.errno </span><span class="s0">in </span><span class="s1">_blocking_errnos:</span>
            <span class="s0">raise </span><span class="s1">ReadTimeoutError(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s4">&quot;Read timed out. (read timeout=%s)&quot; </span><span class="s1">% timeout_value</span>
            <span class="s1">)</span>

        <span class="s2"># Catch possible read timeouts thrown as SSL errors. If not the</span>
        <span class="s2"># case, rethrow the original. We need to do this because of:</span>
        <span class="s2"># http://bugs.python.org/issue10272</span>
        <span class="s0">if </span><span class="s4">&quot;timed out&quot; </span><span class="s0">in </span><span class="s1">str(err) </span><span class="s0">or </span><span class="s4">&quot;did not complete (read)&quot; </span><span class="s0">in </span><span class="s1">str(</span>
            <span class="s1">err</span>
        <span class="s1">):  </span><span class="s2"># Python &lt; 2.7.4</span>
            <span class="s0">raise </span><span class="s1">ReadTimeoutError(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s4">&quot;Read timed out. (read timeout=%s)&quot; </span><span class="s1">% timeout_value</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_make_request(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">conn</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">timeout=_Default</span><span class="s0">, </span><span class="s1">chunked=</span><span class="s0">False, </span><span class="s1">**httplib_request_kw</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform a request on a given urllib connection object taken from our 
        pool. 
 
        :param conn: 
            a connection from one of our connection pools 
 
        :param timeout: 
            Socket timeout in seconds for the request. This can be a 
            float or integer, which will set the same timeout value for 
            the socket connect and the socket read, or an instance of 
            :class:`urllib3.util.Timeout`, which gives you more fine-grained 
            control over your timeouts. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.num_requests += </span><span class="s5">1</span>

        <span class="s1">timeout_obj = self._get_timeout(timeout)</span>
        <span class="s1">timeout_obj.start_connect()</span>
        <span class="s1">conn.timeout = timeout_obj.connect_timeout</span>

        <span class="s2"># Trigger any extra validation we need to do.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._validate_conn(conn)</span>
        <span class="s0">except </span><span class="s1">(SocketTimeout</span><span class="s0">, </span><span class="s1">BaseSSLError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s2"># Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.</span>
            <span class="s1">self._raise_timeout(err=e</span><span class="s0">, </span><span class="s1">url=url</span><span class="s0">, </span><span class="s1">timeout_value=conn.timeout)</span>
            <span class="s0">raise</span>

        <span class="s2"># conn.request() calls http.client.*.request, not the method in</span>
        <span class="s2"># urllib3.request. It also calls makefile (recv) on the socket.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">chunked:</span>
                <span class="s1">conn.request_chunked(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">**httplib_request_kw)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">conn.request(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">**httplib_request_kw)</span>

        <span class="s2"># We are swallowing BrokenPipeError (errno.EPIPE) since the server is</span>
        <span class="s2"># legitimately able to close the connection after sending a valid response.</span>
        <span class="s2"># With this behaviour, the received response is still readable.</span>
        <span class="s0">except </span><span class="s1">BrokenPipeError:</span>
            <span class="s2"># Python 3</span>
            <span class="s0">pass</span>
        <span class="s0">except </span><span class="s1">IOError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s2"># Python 2 and macOS/Linux</span>
            <span class="s2"># EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS</span>
            <span class="s2"># https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/</span>
            <span class="s0">if </span><span class="s1">e.errno </span><span class="s0">not in </span><span class="s1">{</span>
                <span class="s1">errno.EPIPE</span><span class="s0">,</span>
                <span class="s1">errno.ESHUTDOWN</span><span class="s0">,</span>
                <span class="s1">errno.EPROTOTYPE</span><span class="s0">,</span>
            <span class="s1">}:</span>
                <span class="s0">raise</span>

        <span class="s2"># Reset the timeout for the recv() on the socket</span>
        <span class="s1">read_timeout = timeout_obj.read_timeout</span>

        <span class="s2"># App Engine doesn't have a sock attr</span>
        <span class="s0">if </span><span class="s1">getattr(conn</span><span class="s0">, </span><span class="s4">&quot;sock&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s2"># In Python 3 socket.py will catch EAGAIN and return None when you</span>
            <span class="s2"># try and read into the file pointer created by http.client, which</span>
            <span class="s2"># instead raises a BadStatusLine exception. Instead of catching</span>
            <span class="s2"># the exception and assuming all BadStatusLine exceptions are read</span>
            <span class="s2"># timeouts, check for a zero timeout before making the request.</span>
            <span class="s0">if </span><span class="s1">read_timeout == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ReadTimeoutError(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s4">&quot;Read timed out. (read timeout=%s)&quot; </span><span class="s1">% read_timeout</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">read_timeout </span><span class="s0">is </span><span class="s1">Timeout.DEFAULT_TIMEOUT:</span>
                <span class="s1">conn.sock.settimeout(socket.getdefaulttimeout())</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s2"># None or a value</span>
                <span class="s1">conn.sock.settimeout(read_timeout)</span>

        <span class="s2"># Receive the response from the server</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s2"># Python 2.7, use buffering of HTTP responses</span>
                <span class="s1">httplib_response = conn.getresponse(buffering=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">TypeError:</span>
                <span class="s2"># Python 3</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">httplib_response = conn.getresponse()</span>
                <span class="s0">except </span><span class="s1">BaseException </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s2"># Remove the TypeError from the exception chain in</span>
                    <span class="s2"># Python 3 (including for exceptions like SystemExit).</span>
                    <span class="s2"># Otherwise it looks like a bug in the code.</span>
                    <span class="s1">six.raise_from(e</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(SocketTimeout</span><span class="s0">, </span><span class="s1">BaseSSLError</span><span class="s0">, </span><span class="s1">SocketError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">self._raise_timeout(err=e</span><span class="s0">, </span><span class="s1">url=url</span><span class="s0">, </span><span class="s1">timeout_value=read_timeout)</span>
            <span class="s0">raise</span>

        <span class="s2"># AppEngine doesn't have a version attr.</span>
        <span class="s1">http_version = getattr(conn</span><span class="s0">, </span><span class="s4">&quot;_http_vsn_str&quot;</span><span class="s0">, </span><span class="s4">&quot;HTTP/?&quot;</span><span class="s1">)</span>
        <span class="s1">log.debug(</span>
            <span class="s4">'%s://%s:%s &quot;%s %s %s&quot; %s %s'</span><span class="s0">,</span>
            <span class="s1">self.scheme</span><span class="s0">,</span>
            <span class="s1">self.host</span><span class="s0">,</span>
            <span class="s1">self.port</span><span class="s0">,</span>
            <span class="s1">method</span><span class="s0">,</span>
            <span class="s1">url</span><span class="s0">,</span>
            <span class="s1">http_version</span><span class="s0">,</span>
            <span class="s1">httplib_response.status</span><span class="s0">,</span>
            <span class="s1">httplib_response.length</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">assert_header_parsing(httplib_response.msg)</span>
        <span class="s0">except </span><span class="s1">(HeaderParsingError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">hpe:  </span><span class="s2"># Platform-specific: Python 3</span>
            <span class="s1">log.warning(</span>
                <span class="s4">&quot;Failed to parse headers (url=%s): %s&quot;</span><span class="s0">,</span>
                <span class="s1">self._absolute_url(url)</span><span class="s0">,</span>
                <span class="s1">hpe</span><span class="s0">,</span>
                <span class="s1">exc_info=</span><span class="s0">True,</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">httplib_response</span>

    <span class="s0">def </span><span class="s1">_absolute_url(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s0">return </span><span class="s1">Url(scheme=self.scheme</span><span class="s0">, </span><span class="s1">host=self.host</span><span class="s0">, </span><span class="s1">port=self.port</span><span class="s0">, </span><span class="s1">path=path).url</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Close all pooled connections and disable the pool. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.pool </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s2"># Disable access to the pool</span>
        <span class="s1">old_pool</span><span class="s0">, </span><span class="s1">self.pool = self.pool</span><span class="s0">, None</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s1">conn = old_pool.get(block=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">conn:</span>
                    <span class="s1">conn.close()</span>

        <span class="s0">except </span><span class="s1">queue.Empty:</span>
            <span class="s0">pass  </span><span class="s2"># Done.</span>

    <span class="s0">def </span><span class="s1">is_same_host(self</span><span class="s0">, </span><span class="s1">url):</span>
        <span class="s3">&quot;&quot;&quot; 
        Check if the given ``url`` is a member of the same host as this 
        connection pool. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">url.startswith(</span><span class="s4">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s0">return True</span>

        <span class="s2"># TODO: Add optional support for socket.gethostbyname checking.</span>
        <span class="s1">scheme</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port = get_host(url)</span>
        <span class="s0">if </span><span class="s1">host </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">host = _normalize_host(host</span><span class="s0">, </span><span class="s1">scheme=scheme)</span>

        <span class="s2"># Use explicit default port for comparison when none is given</span>
        <span class="s0">if </span><span class="s1">self.port </span><span class="s0">and not </span><span class="s1">port:</span>
            <span class="s1">port = port_by_scheme.get(scheme)</span>
        <span class="s0">elif not </span><span class="s1">self.port </span><span class="s0">and </span><span class="s1">port == port_by_scheme.get(scheme):</span>
            <span class="s1">port = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">(scheme</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port) == (self.scheme</span><span class="s0">, </span><span class="s1">self.host</span><span class="s0">, </span><span class="s1">self.port)</span>

    <span class="s0">def </span><span class="s1">urlopen(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">method</span><span class="s0">,</span>
        <span class="s1">url</span><span class="s0">,</span>
        <span class="s1">body=</span><span class="s0">None,</span>
        <span class="s1">headers=</span><span class="s0">None,</span>
        <span class="s1">retries=</span><span class="s0">None,</span>
        <span class="s1">redirect=</span><span class="s0">True,</span>
        <span class="s1">assert_same_host=</span><span class="s0">True,</span>
        <span class="s1">timeout=_Default</span><span class="s0">,</span>
        <span class="s1">pool_timeout=</span><span class="s0">None,</span>
        <span class="s1">release_conn=</span><span class="s0">None,</span>
        <span class="s1">chunked=</span><span class="s0">False,</span>
        <span class="s1">body_pos=</span><span class="s0">None,</span>
        <span class="s1">**response_kw</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get a connection from the pool and perform an HTTP request. This is the 
        lowest level call for making a request, so you'll need to specify all 
        the raw details. 
 
        .. note:: 
 
           More commonly, it's appropriate to use a convenience method provided 
           by :class:`.RequestMethods`, such as :meth:`request`. 
 
        .. note:: 
 
           `release_conn` will only behave as expected if 
           `preload_content=False` because we want to make 
           `preload_content=False` the default behaviour someday soon without 
           breaking backwards compatibility. 
 
        :param method: 
            HTTP request method (such as GET, POST, PUT, etc.) 
 
        :param url: 
            The URL to perform the request on. 
 
        :param body: 
            Data to send in the request body, either :class:`str`, :class:`bytes`, 
            an iterable of :class:`str`/:class:`bytes`, or a file-like object. 
 
        :param headers: 
            Dictionary of custom headers to send, such as User-Agent, 
            If-None-Match, etc. If None, pool headers are used. If provided, 
            these headers completely replace any pool-specific headers. 
 
        :param retries: 
            Configure the number of retries to allow before raising a 
            :class:`~urllib3.exceptions.MaxRetryError` exception. 
 
            Pass ``None`` to retry until you receive a response. Pass a 
            :class:`~urllib3.util.retry.Retry` object for fine-grained control 
            over different types of retries. 
            Pass an integer number to retry connection errors that many times, 
            but no other types of errors. Pass zero to never retry. 
 
            If ``False``, then retries are disabled and any exception is raised 
            immediately. Also, instead of raising a MaxRetryError on redirects, 
            the redirect response will be returned. 
 
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int. 
 
        :param redirect: 
            If True, automatically handle redirects (status codes 301, 302, 
            303, 307, 308). Each redirect counts as a retry. Disabling retries 
            will disable redirect, too. 
 
        :param assert_same_host: 
            If ``True``, will make sure that the host of the pool requests is 
            consistent else will raise HostChangedError. When ``False``, you can 
            use the pool on an HTTP proxy and request foreign hosts. 
 
        :param timeout: 
            If specified, overrides the default timeout for this one 
            request. It may be a float (in seconds) or an instance of 
            :class:`urllib3.util.Timeout`. 
 
        :param pool_timeout: 
            If set and the pool is set to block=True, then this method will 
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no 
            connection is available within the time period. 
 
        :param release_conn: 
            If False, then the urlopen call will not release the connection 
            back into the pool once a response is received (but will release if 
            you read the entire contents of the response such as when 
            `preload_content=True`). This is useful if you're not preloading 
            the response's content immediately. You will need to call 
            ``r.release_conn()`` on the response ``r`` to return the connection 
            back into the pool. If None, it takes the value of 
            ``response_kw.get('preload_content', True)``. 
 
        :param chunked: 
            If True, urllib3 will send the body using chunked transfer 
            encoding. Otherwise, urllib3 will send the body using the standard 
            content-length form. Defaults to False. 
 
        :param int body_pos: 
            Position to seek to in file-like body in the event of a retry or 
            redirect. Typically this won't need to be set because urllib3 will 
            auto-populate the value when needed. 
 
        :param \\**response_kw: 
            Additional parameters are passed to 
            :meth:`urllib3.response.HTTPResponse.from_httplib` 
        &quot;&quot;&quot;</span>

        <span class="s1">parsed_url = parse_url(url)</span>
        <span class="s1">destination_scheme = parsed_url.scheme</span>

        <span class="s0">if </span><span class="s1">headers </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">headers = self.headers</span>

        <span class="s0">if not </span><span class="s1">isinstance(retries</span><span class="s0">, </span><span class="s1">Retry):</span>
            <span class="s1">retries = Retry.from_int(retries</span><span class="s0">, </span><span class="s1">redirect=redirect</span><span class="s0">, </span><span class="s1">default=self.retries)</span>

        <span class="s0">if </span><span class="s1">release_conn </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">release_conn = response_kw.get(</span><span class="s4">&quot;preload_content&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s2"># Check host</span>
        <span class="s0">if </span><span class="s1">assert_same_host </span><span class="s0">and not </span><span class="s1">self.is_same_host(url):</span>
            <span class="s0">raise </span><span class="s1">HostChangedError(self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">retries)</span>

        <span class="s2"># Ensure that the URL we're connecting to is properly encoded</span>
        <span class="s0">if </span><span class="s1">url.startswith(</span><span class="s4">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s1">url = six.ensure_str(_encode_target(url))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">url = six.ensure_str(parsed_url.url)</span>

        <span class="s1">conn = </span><span class="s0">None</span>

        <span class="s2"># Track whether `conn` needs to be released before</span>
        <span class="s2"># returning/raising/recursing. Update this variable if necessary, and</span>
        <span class="s2"># leave `release_conn` constant throughout the function. That way, if</span>
        <span class="s2"># the function recurses, the original value of `release_conn` will be</span>
        <span class="s2"># passed down into the recursive call, and its value will be respected.</span>
        <span class="s2">#</span>
        <span class="s2"># See issue #651 [1] for details.</span>
        <span class="s2">#</span>
        <span class="s2"># [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;</span>
        <span class="s1">release_this_conn = release_conn</span>

        <span class="s1">http_tunnel_required = connection_requires_http_tunnel(</span>
            <span class="s1">self.proxy</span><span class="s0">, </span><span class="s1">self.proxy_config</span><span class="s0">, </span><span class="s1">destination_scheme</span>
        <span class="s1">)</span>

        <span class="s2"># Merge the proxy headers. Only done when not using HTTP CONNECT. We</span>
        <span class="s2"># have to copy the headers dict so we can safely change it without those</span>
        <span class="s2"># changes being reflected in anyone else's copy.</span>
        <span class="s0">if not </span><span class="s1">http_tunnel_required:</span>
            <span class="s1">headers = headers.copy()</span>
            <span class="s1">headers.update(self.proxy_headers)</span>

        <span class="s2"># Must keep the exception bound to a separate variable or else Python 3</span>
        <span class="s2"># complains about UnboundLocalError.</span>
        <span class="s1">err = </span><span class="s0">None</span>

        <span class="s2"># Keep track of whether we cleanly exited the except block. This</span>
        <span class="s2"># ensures we do proper cleanup in finally.</span>
        <span class="s1">clean_exit = </span><span class="s0">False</span>

        <span class="s2"># Rewind body position, if needed. Record current position</span>
        <span class="s2"># for future rewinds in the event of a redirect/retry.</span>
        <span class="s1">body_pos = set_file_position(body</span><span class="s0">, </span><span class="s1">body_pos)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Request a connection from the queue.</span>
            <span class="s1">timeout_obj = self._get_timeout(timeout)</span>
            <span class="s1">conn = self._get_conn(timeout=pool_timeout)</span>

            <span class="s1">conn.timeout = timeout_obj.connect_timeout</span>

            <span class="s1">is_new_proxy_conn = self.proxy </span><span class="s0">is not None and not </span><span class="s1">getattr(</span>
                <span class="s1">conn</span><span class="s0">, </span><span class="s4">&quot;sock&quot;</span><span class="s0">, None</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">is_new_proxy_conn </span><span class="s0">and </span><span class="s1">http_tunnel_required:</span>
                <span class="s1">self._prepare_proxy(conn)</span>

            <span class="s2"># Make the request on the httplib connection object.</span>
            <span class="s1">httplib_response = self._make_request(</span>
                <span class="s1">conn</span><span class="s0">,</span>
                <span class="s1">method</span><span class="s0">,</span>
                <span class="s1">url</span><span class="s0">,</span>
                <span class="s1">timeout=timeout_obj</span><span class="s0">,</span>
                <span class="s1">body=body</span><span class="s0">,</span>
                <span class="s1">headers=headers</span><span class="s0">,</span>
                <span class="s1">chunked=chunked</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s2"># If we're going to release the connection in ``finally:``, then</span>
            <span class="s2"># the response doesn't need to know about the connection. Otherwise</span>
            <span class="s2"># it will also try to release it and we'll have a double-release</span>
            <span class="s2"># mess.</span>
            <span class="s1">response_conn = conn </span><span class="s0">if not </span><span class="s1">release_conn </span><span class="s0">else None</span>

            <span class="s2"># Pass method to Response for length checking</span>
            <span class="s1">response_kw[</span><span class="s4">&quot;request_method&quot;</span><span class="s1">] = method</span>

            <span class="s2"># Import httplib's response into our own wrapper object</span>
            <span class="s1">response = self.ResponseCls.from_httplib(</span>
                <span class="s1">httplib_response</span><span class="s0">,</span>
                <span class="s1">pool=self</span><span class="s0">,</span>
                <span class="s1">connection=response_conn</span><span class="s0">,</span>
                <span class="s1">retries=retries</span><span class="s0">,</span>
                <span class="s1">**response_kw</span>
            <span class="s1">)</span>

            <span class="s2"># Everything went great!</span>
            <span class="s1">clean_exit = </span><span class="s0">True</span>

        <span class="s0">except </span><span class="s1">EmptyPoolError:</span>
            <span class="s2"># Didn't get a connection from the pool, no need to clean up</span>
            <span class="s1">clean_exit = </span><span class="s0">True</span>
            <span class="s1">release_this_conn = </span><span class="s0">False</span>
            <span class="s0">raise</span>

        <span class="s0">except </span><span class="s1">(</span>
            <span class="s1">TimeoutError</span><span class="s0">,</span>
            <span class="s1">HTTPException</span><span class="s0">,</span>
            <span class="s1">SocketError</span><span class="s0">,</span>
            <span class="s1">ProtocolError</span><span class="s0">,</span>
            <span class="s1">BaseSSLError</span><span class="s0">,</span>
            <span class="s1">SSLError</span><span class="s0">,</span>
            <span class="s1">CertificateError</span><span class="s0">,</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s2"># Discard the connection for these exceptions. It will be</span>
            <span class="s2"># replaced during the next _get_conn() call.</span>
            <span class="s1">clean_exit = </span><span class="s0">False</span>

            <span class="s0">def </span><span class="s1">_is_ssl_error_message_from_http_proxy(ssl_error):</span>
                <span class="s2"># We're trying to detect the message 'WRONG_VERSION_NUMBER' but</span>
                <span class="s2"># SSLErrors are kinda all over the place when it comes to the message,</span>
                <span class="s2"># so we try to cover our bases here!</span>
                <span class="s1">message = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(re.split(</span><span class="s4">&quot;[^a-z]&quot;</span><span class="s0">, </span><span class="s1">str(ssl_error).lower()))</span>
                <span class="s0">return </span><span class="s1">(</span>
                    <span class="s4">&quot;wrong version number&quot; </span><span class="s0">in </span><span class="s1">message </span><span class="s0">or </span><span class="s4">&quot;unknown protocol&quot; </span><span class="s0">in </span><span class="s1">message</span>
                <span class="s1">)</span>

            <span class="s2"># Try to detect a common user error with proxies which is to</span>
            <span class="s2"># set an HTTP proxy to be HTTPS when it should be 'http://'</span>
            <span class="s2"># (ie {'http': 'http://proxy', 'https': 'https://proxy'})</span>
            <span class="s2"># Instead we add a nice error message and point to a URL.</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">BaseSSLError)</span>
                <span class="s0">and </span><span class="s1">self.proxy</span>
                <span class="s0">and </span><span class="s1">_is_ssl_error_message_from_http_proxy(e)</span>
            <span class="s1">):</span>
                <span class="s1">e = ProxyError(</span>
                    <span class="s4">&quot;Your proxy appears to only use HTTP and not HTTPS, &quot;</span>
                    <span class="s4">&quot;try changing your proxy URL to be HTTP. See: &quot;</span>
                    <span class="s4">&quot;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&quot;</span>
                    <span class="s4">&quot;#https-proxy-error-http-proxy&quot;</span><span class="s0">,</span>
                    <span class="s1">SSLError(e)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">(BaseSSLError</span><span class="s0">, </span><span class="s1">CertificateError)):</span>
                <span class="s1">e = SSLError(e)</span>
            <span class="s0">elif </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">(SocketError</span><span class="s0">, </span><span class="s1">NewConnectionError)) </span><span class="s0">and </span><span class="s1">self.proxy:</span>
                <span class="s1">e = ProxyError(</span><span class="s4">&quot;Cannot connect to proxy.&quot;</span><span class="s0">, </span><span class="s1">e)</span>
            <span class="s0">elif </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">(SocketError</span><span class="s0">, </span><span class="s1">HTTPException)):</span>
                <span class="s1">e = ProtocolError(</span><span class="s4">&quot;Connection aborted.&quot;</span><span class="s0">, </span><span class="s1">e)</span>

            <span class="s1">retries = retries.increment(</span>
                <span class="s1">method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">error=e</span><span class="s0">, </span><span class="s1">_pool=self</span><span class="s0">, </span><span class="s1">_stacktrace=sys.exc_info()[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">retries.sleep()</span>

            <span class="s2"># Keep track of the error for the retry warning.</span>
            <span class="s1">err = e</span>

        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">clean_exit:</span>
                <span class="s2"># We hit some kind of exception, handled or otherwise. We need</span>
                <span class="s2"># to throw the connection away unless explicitly told not to.</span>
                <span class="s2"># Close the connection, set the variable to None, and make sure</span>
                <span class="s2"># we put the None back in the pool to avoid leaking it.</span>
                <span class="s1">conn = conn </span><span class="s0">and </span><span class="s1">conn.close()</span>
                <span class="s1">release_this_conn = </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">release_this_conn:</span>
                <span class="s2"># Put the connection back to be reused. If the connection is</span>
                <span class="s2"># expired then it will be None, which will get replaced with a</span>
                <span class="s2"># fresh connection during _get_conn.</span>
                <span class="s1">self._put_conn(conn)</span>

        <span class="s0">if not </span><span class="s1">conn:</span>
            <span class="s2"># Try again</span>
            <span class="s1">log.warning(</span>
                <span class="s4">&quot;Retrying (%r) after connection broken by '%r': %s&quot;</span><span class="s0">, </span><span class="s1">retries</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">url</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self.urlopen(</span>
                <span class="s1">method</span><span class="s0">,</span>
                <span class="s1">url</span><span class="s0">,</span>
                <span class="s1">body</span><span class="s0">,</span>
                <span class="s1">headers</span><span class="s0">,</span>
                <span class="s1">retries</span><span class="s0">,</span>
                <span class="s1">redirect</span><span class="s0">,</span>
                <span class="s1">assert_same_host</span><span class="s0">,</span>
                <span class="s1">timeout=timeout</span><span class="s0">,</span>
                <span class="s1">pool_timeout=pool_timeout</span><span class="s0">,</span>
                <span class="s1">release_conn=release_conn</span><span class="s0">,</span>
                <span class="s1">chunked=chunked</span><span class="s0">,</span>
                <span class="s1">body_pos=body_pos</span><span class="s0">,</span>
                <span class="s1">**response_kw</span>
            <span class="s1">)</span>

        <span class="s2"># Handle redirect?</span>
        <span class="s1">redirect_location = redirect </span><span class="s0">and </span><span class="s1">response.get_redirect_location()</span>
        <span class="s0">if </span><span class="s1">redirect_location:</span>
            <span class="s0">if </span><span class="s1">response.status == </span><span class="s5">303</span><span class="s1">:</span>
                <span class="s1">method = </span><span class="s4">&quot;GET&quot;</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">retries = retries.increment(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">response=response</span><span class="s0">, </span><span class="s1">_pool=self)</span>
            <span class="s0">except </span><span class="s1">MaxRetryError:</span>
                <span class="s0">if </span><span class="s1">retries.raise_on_redirect:</span>
                    <span class="s1">response.drain_conn()</span>
                    <span class="s0">raise</span>
                <span class="s0">return </span><span class="s1">response</span>

            <span class="s1">response.drain_conn()</span>
            <span class="s1">retries.sleep_for_retry(response)</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;Redirecting %s -&gt; %s&quot;</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect_location)</span>
            <span class="s0">return </span><span class="s1">self.urlopen(</span>
                <span class="s1">method</span><span class="s0">,</span>
                <span class="s1">redirect_location</span><span class="s0">,</span>
                <span class="s1">body</span><span class="s0">,</span>
                <span class="s1">headers</span><span class="s0">,</span>
                <span class="s1">retries=retries</span><span class="s0">,</span>
                <span class="s1">redirect=redirect</span><span class="s0">,</span>
                <span class="s1">assert_same_host=assert_same_host</span><span class="s0">,</span>
                <span class="s1">timeout=timeout</span><span class="s0">,</span>
                <span class="s1">pool_timeout=pool_timeout</span><span class="s0">,</span>
                <span class="s1">release_conn=release_conn</span><span class="s0">,</span>
                <span class="s1">chunked=chunked</span><span class="s0">,</span>
                <span class="s1">body_pos=body_pos</span><span class="s0">,</span>
                <span class="s1">**response_kw</span>
            <span class="s1">)</span>

        <span class="s2"># Check if we should retry the HTTP response.</span>
        <span class="s1">has_retry_after = bool(response.getheader(</span><span class="s4">&quot;Retry-After&quot;</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">retries.is_retry(method</span><span class="s0">, </span><span class="s1">response.status</span><span class="s0">, </span><span class="s1">has_retry_after):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">retries = retries.increment(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">response=response</span><span class="s0">, </span><span class="s1">_pool=self)</span>
            <span class="s0">except </span><span class="s1">MaxRetryError:</span>
                <span class="s0">if </span><span class="s1">retries.raise_on_status:</span>
                    <span class="s1">response.drain_conn()</span>
                    <span class="s0">raise</span>
                <span class="s0">return </span><span class="s1">response</span>

            <span class="s1">response.drain_conn()</span>
            <span class="s1">retries.sleep(response)</span>
            <span class="s1">log.debug(</span><span class="s4">&quot;Retry: %s&quot;</span><span class="s0">, </span><span class="s1">url)</span>
            <span class="s0">return </span><span class="s1">self.urlopen(</span>
                <span class="s1">method</span><span class="s0">,</span>
                <span class="s1">url</span><span class="s0">,</span>
                <span class="s1">body</span><span class="s0">,</span>
                <span class="s1">headers</span><span class="s0">,</span>
                <span class="s1">retries=retries</span><span class="s0">,</span>
                <span class="s1">redirect=redirect</span><span class="s0">,</span>
                <span class="s1">assert_same_host=assert_same_host</span><span class="s0">,</span>
                <span class="s1">timeout=timeout</span><span class="s0">,</span>
                <span class="s1">pool_timeout=pool_timeout</span><span class="s0">,</span>
                <span class="s1">release_conn=release_conn</span><span class="s0">,</span>
                <span class="s1">chunked=chunked</span><span class="s0">,</span>
                <span class="s1">body_pos=body_pos</span><span class="s0">,</span>
                <span class="s1">**response_kw</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">response</span>


<span class="s0">class </span><span class="s1">HTTPSConnectionPool(HTTPConnectionPool):</span>
    <span class="s3">&quot;&quot;&quot; 
    Same as :class:`.HTTPConnectionPool`, but HTTPS. 
 
    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``, 
    ``assert_hostname`` and ``host`` in this order to verify connections. 
    If ``assert_hostname`` is False, no verification is done. 
 
    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``, 
    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl` 
    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade 
    the connection socket into an SSL socket. 
    &quot;&quot;&quot;</span>

    <span class="s1">scheme = </span><span class="s4">&quot;https&quot;</span>
    <span class="s1">ConnectionCls = HTTPSConnection</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">host</span><span class="s0">,</span>
        <span class="s1">port=</span><span class="s0">None,</span>
        <span class="s1">strict=</span><span class="s0">False,</span>
        <span class="s1">timeout=Timeout.DEFAULT_TIMEOUT</span><span class="s0">,</span>
        <span class="s1">maxsize=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">block=</span><span class="s0">False,</span>
        <span class="s1">headers=</span><span class="s0">None,</span>
        <span class="s1">retries=</span><span class="s0">None,</span>
        <span class="s1">_proxy=</span><span class="s0">None,</span>
        <span class="s1">_proxy_headers=</span><span class="s0">None,</span>
        <span class="s1">key_file=</span><span class="s0">None,</span>
        <span class="s1">cert_file=</span><span class="s0">None,</span>
        <span class="s1">cert_reqs=</span><span class="s0">None,</span>
        <span class="s1">key_password=</span><span class="s0">None,</span>
        <span class="s1">ca_certs=</span><span class="s0">None,</span>
        <span class="s1">ssl_version=</span><span class="s0">None,</span>
        <span class="s1">assert_hostname=</span><span class="s0">None,</span>
        <span class="s1">assert_fingerprint=</span><span class="s0">None,</span>
        <span class="s1">ca_cert_dir=</span><span class="s0">None,</span>
        <span class="s1">**conn_kw</span>
    <span class="s1">):</span>

        <span class="s1">HTTPConnectionPool.__init__(</span>
            <span class="s1">self</span><span class="s0">,</span>
            <span class="s1">host</span><span class="s0">,</span>
            <span class="s1">port</span><span class="s0">,</span>
            <span class="s1">strict</span><span class="s0">,</span>
            <span class="s1">timeout</span><span class="s0">,</span>
            <span class="s1">maxsize</span><span class="s0">,</span>
            <span class="s1">block</span><span class="s0">,</span>
            <span class="s1">headers</span><span class="s0">,</span>
            <span class="s1">retries</span><span class="s0">,</span>
            <span class="s1">_proxy</span><span class="s0">,</span>
            <span class="s1">_proxy_headers</span><span class="s0">,</span>
            <span class="s1">**conn_kw</span>
        <span class="s1">)</span>

        <span class="s1">self.key_file = key_file</span>
        <span class="s1">self.cert_file = cert_file</span>
        <span class="s1">self.cert_reqs = cert_reqs</span>
        <span class="s1">self.key_password = key_password</span>
        <span class="s1">self.ca_certs = ca_certs</span>
        <span class="s1">self.ca_cert_dir = ca_cert_dir</span>
        <span class="s1">self.ssl_version = ssl_version</span>
        <span class="s1">self.assert_hostname = assert_hostname</span>
        <span class="s1">self.assert_fingerprint = assert_fingerprint</span>

    <span class="s0">def </span><span class="s1">_prepare_conn(self</span><span class="s0">, </span><span class="s1">conn):</span>
        <span class="s3">&quot;&quot;&quot; 
        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket` 
        and establish the tunnel if proxy is used. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(conn</span><span class="s0">, </span><span class="s1">VerifiedHTTPSConnection):</span>
            <span class="s1">conn.set_cert(</span>
                <span class="s1">key_file=self.key_file</span><span class="s0">,</span>
                <span class="s1">key_password=self.key_password</span><span class="s0">,</span>
                <span class="s1">cert_file=self.cert_file</span><span class="s0">,</span>
                <span class="s1">cert_reqs=self.cert_reqs</span><span class="s0">,</span>
                <span class="s1">ca_certs=self.ca_certs</span><span class="s0">,</span>
                <span class="s1">ca_cert_dir=self.ca_cert_dir</span><span class="s0">,</span>
                <span class="s1">assert_hostname=self.assert_hostname</span><span class="s0">,</span>
                <span class="s1">assert_fingerprint=self.assert_fingerprint</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">conn.ssl_version = self.ssl_version</span>
        <span class="s0">return </span><span class="s1">conn</span>

    <span class="s0">def </span><span class="s1">_prepare_proxy(self</span><span class="s0">, </span><span class="s1">conn):</span>
        <span class="s3">&quot;&quot;&quot; 
        Establishes a tunnel connection through HTTP CONNECT. 
 
        Tunnel connection is established early because otherwise httplib would 
        improperly set Host: header to proxy's IP:port. 
        &quot;&quot;&quot;</span>

        <span class="s1">conn.set_tunnel(self._proxy_host</span><span class="s0">, </span><span class="s1">self.port</span><span class="s0">, </span><span class="s1">self.proxy_headers)</span>

        <span class="s0">if </span><span class="s1">self.proxy.scheme == </span><span class="s4">&quot;https&quot;</span><span class="s1">:</span>
            <span class="s1">conn.tls_in_tls_required = </span><span class="s0">True</span>

        <span class="s1">conn.connect()</span>

    <span class="s0">def </span><span class="s1">_new_conn(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a fresh :class:`http.client.HTTPSConnection`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.num_connections += </span><span class="s5">1</span>
        <span class="s1">log.debug(</span>
            <span class="s4">&quot;Starting new HTTPS connection (%d): %s:%s&quot;</span><span class="s0">,</span>
            <span class="s1">self.num_connections</span><span class="s0">,</span>
            <span class="s1">self.host</span><span class="s0">,</span>
            <span class="s1">self.port </span><span class="s0">or </span><span class="s4">&quot;443&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">self.ConnectionCls </span><span class="s0">or </span><span class="s1">self.ConnectionCls </span><span class="s0">is </span><span class="s1">DummyConnection:</span>
            <span class="s0">raise </span><span class="s1">SSLError(</span>
                <span class="s4">&quot;Can't connect to HTTPS URL because the SSL module is not available.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">actual_host = self.host</span>
        <span class="s1">actual_port = self.port</span>
        <span class="s0">if </span><span class="s1">self.proxy </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">actual_host = self.proxy.host</span>
            <span class="s1">actual_port = self.proxy.port</span>

        <span class="s1">conn = self.ConnectionCls(</span>
            <span class="s1">host=actual_host</span><span class="s0">,</span>
            <span class="s1">port=actual_port</span><span class="s0">,</span>
            <span class="s1">timeout=self.timeout.connect_timeout</span><span class="s0">,</span>
            <span class="s1">strict=self.strict</span><span class="s0">,</span>
            <span class="s1">cert_file=self.cert_file</span><span class="s0">,</span>
            <span class="s1">key_file=self.key_file</span><span class="s0">,</span>
            <span class="s1">key_password=self.key_password</span><span class="s0">,</span>
            <span class="s1">**self.conn_kw</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self._prepare_conn(conn)</span>

    <span class="s0">def </span><span class="s1">_validate_conn(self</span><span class="s0">, </span><span class="s1">conn):</span>
        <span class="s3">&quot;&quot;&quot; 
        Called right before a request is made, after the socket is created. 
        &quot;&quot;&quot;</span>
        <span class="s1">super(HTTPSConnectionPool</span><span class="s0">, </span><span class="s1">self)._validate_conn(conn)</span>

        <span class="s2"># Force connect early to allow us to validate the connection.</span>
        <span class="s0">if not </span><span class="s1">getattr(conn</span><span class="s0">, </span><span class="s4">&quot;sock&quot;</span><span class="s0">, None</span><span class="s1">):  </span><span class="s2"># AppEngine might not have  `.sock`</span>
            <span class="s1">conn.connect()</span>

        <span class="s0">if not </span><span class="s1">conn.is_verified:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;Unverified HTTPS request is being made to host '%s'. &quot;</span>
                    <span class="s4">&quot;Adding certificate verification is strongly advised. See: &quot;</span>
                    <span class="s4">&quot;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&quot;</span>
                    <span class="s4">&quot;#ssl-warnings&quot; </span><span class="s1">% conn.host</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">InsecureRequestWarning</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">getattr(conn</span><span class="s0">, </span><span class="s4">&quot;proxy_is_verified&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;Unverified HTTPS connection done to an HTTPS proxy. &quot;</span>
                    <span class="s4">&quot;Adding certificate verification is strongly advised. See: &quot;</span>
                    <span class="s4">&quot;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&quot;</span>
                    <span class="s4">&quot;#ssl-warnings&quot;</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">InsecureRequestWarning</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">connection_from_url(url</span><span class="s0">, </span><span class="s1">**kw):</span>
    <span class="s3">&quot;&quot;&quot; 
    Given a url, return an :class:`.ConnectionPool` instance of its host. 
 
    This is a shortcut for not having to parse out the scheme, host, and port 
    of the url before creating an :class:`.ConnectionPool` instance. 
 
    :param url: 
        Absolute URL string that must include the scheme. Port is optional. 
 
    :param \\**kw: 
        Passes additional parameters to the constructor of the appropriate 
        :class:`.ConnectionPool`. Useful for specifying things like 
        timeout, maxsize, headers, etc. 
 
    Example:: 
 
        &gt;&gt;&gt; conn = connection_from_url('http://google.com/') 
        &gt;&gt;&gt; r = conn.request('GET', '/') 
    &quot;&quot;&quot;</span>
    <span class="s1">scheme</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port = get_host(url)</span>
    <span class="s1">port = port </span><span class="s0">or </span><span class="s1">port_by_scheme.get(scheme</span><span class="s0">, </span><span class="s5">80</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">scheme == </span><span class="s4">&quot;https&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">HTTPSConnectionPool(host</span><span class="s0">, </span><span class="s1">port=port</span><span class="s0">, </span><span class="s1">**kw)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">HTTPConnectionPool(host</span><span class="s0">, </span><span class="s1">port=port</span><span class="s0">, </span><span class="s1">**kw)</span>


<span class="s0">def </span><span class="s1">_normalize_host(host</span><span class="s0">, </span><span class="s1">scheme):</span>
    <span class="s3">&quot;&quot;&quot; 
    Normalize hosts for comparisons and use with sockets. 
    &quot;&quot;&quot;</span>

    <span class="s1">host = normalize_host(host</span><span class="s0">, </span><span class="s1">scheme)</span>

    <span class="s2"># httplib doesn't like it when we include brackets in IPv6 addresses</span>
    <span class="s2"># Specifically, if we include brackets but also pass the port then</span>
    <span class="s2"># httplib crazily doubles up the square brackets on the Host header.</span>
    <span class="s2"># Instead, we need to make sure we never pass ``None`` as the port.</span>
    <span class="s2"># However, for backward compatibility reasons we can't actually</span>
    <span class="s2"># *assert* that.  See http://bugs.python.org/issue28539</span>
    <span class="s0">if </span><span class="s1">host.startswith(</span><span class="s4">&quot;[&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">host.endswith(</span><span class="s4">&quot;]&quot;</span><span class="s1">):</span>
        <span class="s1">host = host[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">host</span>
</pre>
</body>
</html>