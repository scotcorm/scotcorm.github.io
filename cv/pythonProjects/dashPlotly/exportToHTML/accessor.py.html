<html>
<head>
<title>accessor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
accessor.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">codecs</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">pandas._libs.lib </span><span class="s0">as </span><span class="s1">lib</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">F</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">Appender</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_object</span><span class="s0">,</span>
    <span class="s1">is_bool_dtype</span><span class="s0">,</span>
    <span class="s1">is_categorical_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_re</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s0">,</span>
    <span class="s1">ABCIndex</span><span class="s0">,</span>
    <span class="s1">ABCMultiIndex</span><span class="s0">,</span>
    <span class="s1">ABCSeries</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">isna</span>

<span class="s0">from </span><span class="s1">pandas.core.base </span><span class="s0">import </span><span class="s1">NoNewAttributesMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">extract_array</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">DataFrame</span><span class="s0">,</span>
        <span class="s1">Index</span><span class="s0">,</span>
        <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">)</span>

<span class="s1">_shared_docs: dict[str</span><span class="s0">, </span><span class="s1">str] = {}</span>
<span class="s1">_cpython_optimized_encoders = (</span>
    <span class="s2">&quot;utf-8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;utf8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;latin-1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;latin1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iso-8859-1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mbcs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ascii&quot;</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">_cpython_optimized_decoders = _cpython_optimized_encoders + (</span><span class="s2">&quot;utf-16&quot;</span><span class="s0">, </span><span class="s2">&quot;utf-32&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">forbid_nonstring_types(</span>
    <span class="s1">forbidden: list[str] | </span><span class="s0">None, </span><span class="s1">name: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
<span class="s1">) -&gt; Callable[[F]</span><span class="s0">, </span><span class="s1">F]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Decorator to forbid specific types for a method of StringMethods. 
 
    For calling `.str.{method}` on a Series or Index, it is necessary to first 
    initialize the :class:`StringMethods` object, and then call the method. 
    However, different methods allow different input types, and so this can not 
    be checked during :meth:`StringMethods.__init__`, but must be done on a 
    per-method basis. This decorator exists to facilitate this process, and 
    make it explicit which (inferred) types are disallowed by the method. 
 
    :meth:`StringMethods.__init__` allows the *union* of types its different 
    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`), 
    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer']. 
 
    The default string types ['string', 'empty'] are allowed for all methods. 
    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method 
    then needs to forbid the types it is not intended for. 
 
    Parameters 
    ---------- 
    forbidden : list-of-str or None 
        List of forbidden non-string types, may be one or more of 
        `['bytes', 'mixed', 'mixed-integer']`. 
    name : str, default None 
        Name of the method to use in the error message. By default, this is 
        None, in which case the name from the method being wrapped will be 
        copied. However, for working with further wrappers (like _pat_wrapper 
        and _noarg_wrapper), it is necessary to specify the name. 
 
    Returns 
    ------- 
    func : wrapper 
        The method to which the decorator is applied, with an added check that 
        enforces the inferred type to not be in the list of forbidden types. 
 
    Raises 
    ------ 
    TypeError 
        If the inferred type of the underlying data is in `forbidden`. 
    &quot;&quot;&quot;</span>
    <span class="s4"># deal with None</span>
    <span class="s1">forbidden = [] </span><span class="s0">if </span><span class="s1">forbidden </span><span class="s0">is None else </span><span class="s1">forbidden</span>

    <span class="s1">allowed_types = {</span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;empty&quot;</span><span class="s0">, </span><span class="s2">&quot;bytes&quot;</span><span class="s0">, </span><span class="s2">&quot;mixed&quot;</span><span class="s0">, </span><span class="s2">&quot;mixed-integer&quot;</span><span class="s1">} - set(</span>
        <span class="s1">forbidden</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_forbid_nonstring_types(func: F) -&gt; F:</span>
        <span class="s1">func_name = func.__name__ </span><span class="s0">if </span><span class="s1">name </span><span class="s0">is None else </span><span class="s1">name</span>

        <span class="s1">@wraps(func)</span>
        <span class="s0">def </span><span class="s1">wrapper(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s1">self._inferred_dtype </span><span class="s0">not in </span><span class="s1">allowed_types:</span>
                <span class="s1">msg = (</span>
                    <span class="s2">f&quot;Cannot use .str.</span><span class="s0">{</span><span class="s1">func_name</span><span class="s0">} </span><span class="s2">with values of &quot;</span>
                    <span class="s2">f&quot;inferred dtype '</span><span class="s0">{</span><span class="s1">self._inferred_dtype</span><span class="s0">}</span><span class="s2">'.&quot;</span>
                <span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">TypeError(msg)</span>
            <span class="s0">return </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">wrapper.__name__ = func_name</span>
        <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">wrapper)</span>

    <span class="s0">return </span><span class="s1">_forbid_nonstring_types</span>


<span class="s0">def </span><span class="s1">_map_and_wrap(name</span><span class="s0">, </span><span class="s1">docstring):</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=name)</span>
    <span class="s0">def </span><span class="s1">wrapper(self):</span>
        <span class="s1">result = getattr(self._data.array</span><span class="s0">, </span><span class="s2">f&quot;_str_</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">wrapper.__doc__ = docstring</span>
    <span class="s0">return </span><span class="s1">wrapper</span>


<span class="s0">class </span><span class="s1">StringMethods(NoNewAttributesMixin):</span>
    <span class="s3">&quot;&quot;&quot; 
    Vectorized string functions for Series and Index. 
 
    NAs stay NA unless handled otherwise by a particular method. 
    Patterned after Python's string methods, with some inspiration from 
    R's stringr package. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series([&quot;A_Str_Series&quot;]) 
    &gt;&gt;&gt; s 
    0    A_Str_Series 
    dtype: object 
 
    &gt;&gt;&gt; s.str.split(&quot;_&quot;) 
    0    [A, Str, Series] 
    dtype: object 
 
    &gt;&gt;&gt; s.str.replace(&quot;_&quot;, &quot;&quot;) 
    0    AStrSeries 
    dtype: object 
    &quot;&quot;&quot;</span>

    <span class="s4"># Note: see the docstring in pandas.core.strings.__init__</span>
    <span class="s4"># for an explanation of the implementation.</span>
    <span class="s4"># TODO: Dispatch all the methods</span>
    <span class="s4"># Currently the following are not dispatched to the array</span>
    <span class="s4"># * cat</span>
    <span class="s4"># * extractall</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s0">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s0">import </span><span class="s1">StringDtype</span>

        <span class="s1">self._inferred_dtype = self._validate(data)</span>
        <span class="s1">self._is_categorical = is_categorical_dtype(data.dtype)</span>
        <span class="s1">self._is_string = isinstance(data.dtype</span><span class="s0">, </span><span class="s1">StringDtype)</span>
        <span class="s1">self._data = data</span>

        <span class="s1">self._index = self._name = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
            <span class="s1">self._index = data.index</span>
            <span class="s1">self._name = data.name</span>

        <span class="s4"># ._values.categories works for both Series/Index</span>
        <span class="s1">self._parent = data._values.categories </span><span class="s0">if </span><span class="s1">self._is_categorical </span><span class="s0">else </span><span class="s1">data</span>
        <span class="s4"># save orig to blow up categoricals to the right type</span>
        <span class="s1">self._orig = data</span>
        <span class="s1">self._freeze()</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_validate(data):</span>
        <span class="s3">&quot;&quot;&quot; 
        Auxiliary function for StringMethods, infers and checks dtype of data. 
 
        This is a &quot;first line of defence&quot; at the creation of the StringMethods- 
        object, and just checks that the dtype is in the 
        *union* of the allowed types over all string methods below; this 
        restriction is then refined on a per-method basis using the decorator 
        @forbid_nonstring_types (more info in the corresponding docstring). 
 
        This really should exclude all series/index with any non-string values, 
        but that isn't practical for performance reasons until we have a str 
        dtype (GH 9343 / 13877) 
 
        Parameters 
        ---------- 
        data : The content of the Series 
 
        Returns 
        ------- 
        dtype : inferred dtype of data 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">ABCMultiIndex):</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span>
                <span class="s2">&quot;Can only use .str accessor with Index, not MultiIndex&quot;</span>
            <span class="s1">)</span>

        <span class="s4"># see _libs/lib.pyx for list of inferred types</span>
        <span class="s1">allowed_types = [</span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;empty&quot;</span><span class="s0">, </span><span class="s2">&quot;bytes&quot;</span><span class="s0">, </span><span class="s2">&quot;mixed&quot;</span><span class="s0">, </span><span class="s2">&quot;mixed-integer&quot;</span><span class="s1">]</span>

        <span class="s1">data = extract_array(data)</span>

        <span class="s1">values = getattr(data</span><span class="s0">, </span><span class="s2">&quot;categories&quot;</span><span class="s0">, </span><span class="s1">data)  </span><span class="s4"># categorical / normal</span>

        <span class="s1">inferred_dtype = lib.infer_dtype(values</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">inferred_dtype </span><span class="s0">not in </span><span class="s1">allowed_types:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">&quot;Can only use .str accessor with string values!&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">inferred_dtype</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">result = self._data.array._str_getitem(key)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;Columnar iteration over characters will be deprecated in future releases.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">i = </span><span class="s5">0</span>
        <span class="s1">g = self.get(i)</span>
        <span class="s0">while </span><span class="s1">g.notna().any():</span>
            <span class="s0">yield </span><span class="s1">g</span>
            <span class="s1">i += </span><span class="s5">1</span>
            <span class="s1">g = self.get(i)</span>

    <span class="s0">def </span><span class="s1">_wrap_result(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">result</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s0">None,</span>
        <span class="s1">expand: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">fill_value=np.nan</span><span class="s0">,</span>
        <span class="s1">returns_string=</span><span class="s0">True,</span>
        <span class="s1">returns_bool: bool = </span><span class="s0">False,</span>
    <span class="s1">):</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">Index</span><span class="s0">,</span>
            <span class="s1">MultiIndex</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">hasattr(result</span><span class="s0">, </span><span class="s2">&quot;ndim&quot;</span><span class="s1">) </span><span class="s0">or not </span><span class="s1">hasattr(result</span><span class="s0">, </span><span class="s2">&quot;dtype&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">ABCDataFrame):</span>
                <span class="s1">result = result.__finalize__(self._orig</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;str&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">assert </span><span class="s1">result.ndim &lt; </span><span class="s5">3</span>

        <span class="s4"># We can be wrapping a string / object / categorical result, in which</span>
        <span class="s4"># case we'll want to return the same dtype as the input.</span>
        <span class="s4"># Or we can be wrapping a numeric output, in which case we don't want</span>
        <span class="s4"># to return a StringArray.</span>
        <span class="s4"># Ideally the array method returns the right array type.</span>
        <span class="s0">if </span><span class="s1">expand </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># infer from ndim if expand is not specified</span>
            <span class="s1">expand = result.ndim != </span><span class="s5">1</span>

        <span class="s0">elif </span><span class="s1">(</span>
            <span class="s1">expand </span><span class="s0">is True</span>
            <span class="s0">and </span><span class="s1">is_object_dtype(result)</span>
            <span class="s0">and not </span><span class="s1">isinstance(self._orig</span><span class="s0">, </span><span class="s1">ABCIndex)</span>
        <span class="s1">):</span>
            <span class="s4"># required when expand=True is explicitly specified</span>
            <span class="s4"># not needed when inferred</span>

            <span class="s0">def </span><span class="s1">cons_row(x):</span>
                <span class="s0">if </span><span class="s1">is_list_like(x):</span>
                    <span class="s0">return </span><span class="s1">x</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">[x]</span>

            <span class="s1">result = [cons_row(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">result]</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">and not </span><span class="s1">self._is_string:</span>
                <span class="s4"># propagate nan values to match longest sequence (GH 18450)</span>
                <span class="s1">max_len = max(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">result)</span>
                <span class="s1">result = [</span>
                    <span class="s1">x * max_len </span><span class="s0">if </span><span class="s1">len(x) == </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">x[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is </span><span class="s1">np.nan </span><span class="s0">else </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">result</span>
                <span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">isinstance(expand</span><span class="s0">, </span><span class="s1">bool):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;expand must be True or False&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">expand </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s4"># if expand is False, result should have the same name</span>
            <span class="s4"># as the original otherwise specified</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">name = getattr(result</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s4"># do not use logical or, _orig may be a DataFrame</span>
                <span class="s4"># which has &quot;name&quot; column</span>
                <span class="s1">name = self._orig.name</span>

        <span class="s4"># Wait until we are sure result is a Series or Index before</span>
        <span class="s4"># checking attributes (GH 12180)</span>
        <span class="s0">if </span><span class="s1">isinstance(self._orig</span><span class="s0">, </span><span class="s1">ABCIndex):</span>
            <span class="s4"># if result is a boolean np.array, return the np.array</span>
            <span class="s4"># instead of wrapping it into a boolean Index (GH 8875)</span>
            <span class="s0">if </span><span class="s1">is_bool_dtype(result):</span>
                <span class="s0">return </span><span class="s1">result</span>

            <span class="s0">if </span><span class="s1">expand:</span>
                <span class="s1">result = list(result)</span>
                <span class="s1">out = MultiIndex.from_tuples(result</span><span class="s0">, </span><span class="s1">names=name)</span>
                <span class="s0">if </span><span class="s1">out.nlevels == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4"># We had all tuples of length-one, which are</span>
                    <span class="s4"># better represented as a regular Index.</span>
                    <span class="s1">out = out.get_level_values(</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">out</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">Index._with_infer(result</span><span class="s0">, </span><span class="s1">name=name)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">index = self._orig.index</span>
            <span class="s4"># This is a mess.</span>
            <span class="s1">dtype: DtypeObj | str | </span><span class="s0">None</span>
            <span class="s1">vdtype = getattr(result</span><span class="s0">, </span><span class="s2">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self._is_string:</span>
                <span class="s0">if </span><span class="s1">is_bool_dtype(vdtype):</span>
                    <span class="s1">dtype = result.dtype</span>
                <span class="s0">elif </span><span class="s1">returns_string:</span>
                    <span class="s1">dtype = self._orig.dtype</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">dtype = vdtype</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">dtype = vdtype</span>

            <span class="s0">if </span><span class="s1">expand:</span>
                <span class="s1">cons = self._orig._constructor_expanddim</span>
                <span class="s1">result = cons(result</span><span class="s0">, </span><span class="s1">columns=name</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># Must be a Series</span>
                <span class="s1">cons = self._orig._constructor</span>
                <span class="s1">result = cons(result</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">result = result.__finalize__(self._orig</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;str&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None and </span><span class="s1">result.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># __finalize__ might copy over the original name, but we may</span>
                <span class="s4"># want the new name (e.g. str.extract).</span>
                <span class="s1">result.name = name</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_get_series_list(self</span><span class="s0">, </span><span class="s1">others):</span>
        <span class="s3">&quot;&quot;&quot; 
        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input 
        into a list of Series (elements without an index must match the length 
        of the calling Series/Index). 
 
        Parameters 
        ---------- 
        others : Series, DataFrame, np.ndarray, list-like or list-like of 
            Objects that are either Series, Index or np.ndarray (1-dim). 
 
        Returns 
        ------- 
        list of Series 
            Others transformed into list of Series. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">DataFrame</span><span class="s0">,</span>
            <span class="s1">Series</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># self._orig is either Series or Index</span>
        <span class="s1">idx = self._orig </span><span class="s0">if </span><span class="s1">isinstance(self._orig</span><span class="s0">, </span><span class="s1">ABCIndex) </span><span class="s0">else </span><span class="s1">self._orig.index</span>

        <span class="s4"># Generally speaking, all objects without an index inherit the index</span>
        <span class="s4"># `idx` of the calling Series/Index - i.e. must have matching length.</span>
        <span class="s4"># Objects with an index (i.e. Series/Index/DataFrame) keep their own.</span>
        <span class="s0">if </span><span class="s1">isinstance(others</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
            <span class="s0">return </span><span class="s1">[others]</span>
        <span class="s0">elif </span><span class="s1">isinstance(others</span><span class="s0">, </span><span class="s1">ABCIndex):</span>
            <span class="s0">return </span><span class="s1">[Series(others._values</span><span class="s0">, </span><span class="s1">index=idx</span><span class="s0">, </span><span class="s1">dtype=others.dtype)]</span>
        <span class="s0">elif </span><span class="s1">isinstance(others</span><span class="s0">, </span><span class="s1">ABCDataFrame):</span>
            <span class="s0">return </span><span class="s1">[others[x] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">others]</span>
        <span class="s0">elif </span><span class="s1">isinstance(others</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">others.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">others = DataFrame(others</span><span class="s0">, </span><span class="s1">index=idx)</span>
            <span class="s0">return </span><span class="s1">[others[x] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">others]</span>
        <span class="s0">elif </span><span class="s1">is_list_like(others</span><span class="s0">, </span><span class="s1">allow_sets=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">others = list(others)  </span><span class="s4"># ensure iterators do not get read twice etc</span>

            <span class="s4"># in case of list-like `others`, all elements must be</span>
            <span class="s4"># either Series/Index/np.ndarray (1-dim)...</span>
            <span class="s0">if </span><span class="s1">all(</span>
                <span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">(ABCSeries</span><span class="s0">, </span><span class="s1">ABCIndex))</span>
                <span class="s0">or </span><span class="s1">(isinstance(x</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">others</span>
            <span class="s1">):</span>
                <span class="s1">los: list[Series] = []</span>
                <span class="s0">while </span><span class="s1">others:  </span><span class="s4"># iterate through list and append each element</span>
                    <span class="s1">los = los + self._get_series_list(others.pop(</span><span class="s5">0</span><span class="s1">))</span>
                <span class="s0">return </span><span class="s1">los</span>
            <span class="s4"># ... or just strings</span>
            <span class="s0">elif </span><span class="s1">all(</span><span class="s0">not </span><span class="s1">is_list_like(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">others):</span>
                <span class="s0">return </span><span class="s1">[Series(others</span><span class="s0">, </span><span class="s1">index=idx)]</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s2">&quot;others must be Series, Index, DataFrame, np.ndarray &quot;</span>
            <span class="s2">&quot;or list-like (either containing only strings or &quot;</span>
            <span class="s2">&quot;containing only objects of type Series/Index/&quot;</span>
            <span class="s2">&quot;np.ndarray[1-dim])&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s0">, </span><span class="s2">&quot;mixed&quot;</span><span class="s0">, </span><span class="s2">&quot;mixed-integer&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">cat(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">others=</span><span class="s0">None, </span><span class="s1">sep=</span><span class="s0">None, </span><span class="s1">na_rep=</span><span class="s0">None, </span><span class="s1">join=</span><span class="s2">&quot;left&quot;</span>
    <span class="s1">) -&gt; str | Series | Index:</span>
        <span class="s3">&quot;&quot;&quot; 
        Concatenate strings in the Series/Index with given separator. 
 
        If `others` is specified, this function concatenates the Series/Index 
        and elements of `others` element-wise. 
        If `others` is not passed, then all values in the Series/Index are 
        concatenated into a single string with a given `sep`. 
 
        Parameters 
        ---------- 
        others : Series, Index, DataFrame, np.ndarray or list-like 
            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and 
            other list-likes of strings must have the same length as the 
            calling Series/Index, with the exception of indexed objects (i.e. 
            Series/Index/DataFrame) if `join` is not None. 
 
            If others is a list-like that contains a combination of Series, 
            Index or np.ndarray (1-dim), then all elements will be unpacked and 
            must satisfy the above criteria individually. 
 
            If others is None, the method returns the concatenation of all 
            strings in the calling Series/Index. 
        sep : str, default '' 
            The separator between the different elements/columns. By default 
            the empty string `''` is used. 
        na_rep : str or None, default None 
            Representation that is inserted for all missing values: 
 
            - If `na_rep` is None, and `others` is None, missing values in the 
              Series/Index are omitted from the result. 
            - If `na_rep` is None, and `others` is not None, a row containing a 
              missing value in any of the columns (before concatenation) will 
              have a missing value in the result. 
        join : {'left', 'right', 'outer', 'inner'}, default 'left' 
            Determines the join-style between the calling Series/Index and any 
            Series/Index/DataFrame in `others` (objects without an index need 
            to match the length of the calling Series/Index). To disable 
            alignment, use `.values` on any Series/Index/DataFrame in `others`. 
 
            .. versionadded:: 0.23.0 
            .. versionchanged:: 1.0.0 
                Changed default of `join` from None to `'left'`. 
 
        Returns 
        ------- 
        str, Series or Index 
            If `others` is None, `str` is returned, otherwise a `Series/Index` 
            (same type as caller) of objects is returned. 
 
        See Also 
        -------- 
        split : Split each string in the Series/Index. 
        join : Join lists contained as elements in the Series/Index. 
 
        Examples 
        -------- 
        When not passing `others`, all values are concatenated into a single 
        string: 
 
        &gt;&gt;&gt; s = pd.Series(['a', 'b', np.nan, 'd']) 
        &gt;&gt;&gt; s.str.cat(sep=' ') 
        'a b d' 
 
        By default, NA values in the Series are ignored. Using `na_rep`, they 
        can be given a representation: 
 
        &gt;&gt;&gt; s.str.cat(sep=' ', na_rep='?') 
        'a b ? d' 
 
        If `others` is specified, corresponding values are concatenated with 
        the separator. Result will be a Series of strings. 
 
        &gt;&gt;&gt; s.str.cat(['A', 'B', 'C', 'D'], sep=',') 
        0    a,A 
        1    b,B 
        2    NaN 
        3    d,D 
        dtype: object 
 
        Missing values will remain missing in the result, but can again be 
        represented using `na_rep` 
 
        &gt;&gt;&gt; s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-') 
        0    a,A 
        1    b,B 
        2    -,C 
        3    d,D 
        dtype: object 
 
        If `sep` is not specified, the values are concatenated without 
        separation. 
 
        &gt;&gt;&gt; s.str.cat(['A', 'B', 'C', 'D'], na_rep='-') 
        0    aA 
        1    bB 
        2    -C 
        3    dD 
        dtype: object 
 
        Series with different indexes can be aligned before concatenation. The 
        `join`-keyword works as in other methods. 
 
        &gt;&gt;&gt; t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2]) 
        &gt;&gt;&gt; s.str.cat(t, join='left', na_rep='-') 
        0    aa 
        1    b- 
        2    -c 
        3    dd 
        dtype: object 
        &gt;&gt;&gt; 
        &gt;&gt;&gt; s.str.cat(t, join='outer', na_rep='-') 
        0    aa 
        1    b- 
        2    -c 
        3    dd 
        4    -e 
        dtype: object 
        &gt;&gt;&gt; 
        &gt;&gt;&gt; s.str.cat(t, join='inner', na_rep='-') 
        0    aa 
        2    -c 
        3    dd 
        dtype: object 
        &gt;&gt;&gt; 
        &gt;&gt;&gt; s.str.cat(t, join='right', na_rep='-') 
        3    dd 
        0    aa 
        4    -e 
        2    -c 
        dtype: object 
 
        For more examples, see :ref:`here &lt;text.concatenate&gt;`. 
        &quot;&quot;&quot;</span>
        <span class="s4"># TODO: dispatch</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">Index</span><span class="s0">,</span>
            <span class="s1">Series</span><span class="s0">,</span>
            <span class="s1">concat</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(others</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Did you mean to supply a `sep` keyword?&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sep </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sep = </span><span class="s2">&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(self._orig</span><span class="s0">, </span><span class="s1">ABCIndex):</span>
            <span class="s1">data = Series(self._orig</span><span class="s0">, </span><span class="s1">index=self._orig</span><span class="s0">, </span><span class="s1">dtype=self._orig.dtype)</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s4"># Series</span>
            <span class="s1">data = self._orig</span>

        <span class="s4"># concatenate Series/Index with itself if no &quot;others&quot;</span>
        <span class="s0">if </span><span class="s1">others </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># error: Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;ndarray&quot;, variable has type &quot;Series&quot;)</span>
            <span class="s1">data = ensure_object(data)  </span><span class="s4"># type: ignore[assignment]</span>
            <span class="s1">na_mask = isna(data)</span>
            <span class="s0">if </span><span class="s1">na_rep </span><span class="s0">is None and </span><span class="s1">na_mask.any():</span>
                <span class="s0">return </span><span class="s1">sep.join(data[~na_mask])</span>
            <span class="s0">elif </span><span class="s1">na_rep </span><span class="s0">is not None and </span><span class="s1">na_mask.any():</span>
                <span class="s0">return </span><span class="s1">sep.join(np.where(na_mask</span><span class="s0">, </span><span class="s1">na_rep</span><span class="s0">, </span><span class="s1">data))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">sep.join(data)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s4"># turn anything in &quot;others&quot; into lists of Series</span>
            <span class="s1">others = self._get_series_list(others)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:  </span><span class="s4"># do not catch TypeError raised by _get_series_list</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;If `others` contains arrays or lists (or other &quot;</span>
                <span class="s2">&quot;list-likes without an index), these must all be &quot;</span>
                <span class="s2">&quot;of the same length as the calling Series/Index.&quot;</span>
            <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s4"># align if required</span>
        <span class="s0">if </span><span class="s1">any(</span><span class="s0">not </span><span class="s1">data.index.equals(x.index) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">others):</span>
            <span class="s4"># Need to add keys for uniqueness in case of duplicate columns</span>
            <span class="s1">others = concat(</span>
                <span class="s1">others</span><span class="s0">,</span>
                <span class="s1">axis=</span><span class="s5">1</span><span class="s0">,</span>
                <span class="s1">join=(join </span><span class="s0">if </span><span class="s1">join == </span><span class="s2">&quot;inner&quot; </span><span class="s0">else </span><span class="s2">&quot;outer&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">keys=range(len(others))</span><span class="s0">,</span>
                <span class="s1">sort=</span><span class="s0">False,</span>
                <span class="s1">copy=</span><span class="s0">False,</span>
            <span class="s1">)</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">others = data.align(others</span><span class="s0">, </span><span class="s1">join=join)</span>
            <span class="s1">others = [others[x] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">others]  </span><span class="s4"># again list of Series</span>

        <span class="s1">all_cols = [ensure_object(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[data] + others]</span>
        <span class="s1">na_masks = np.array([isna(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">all_cols])</span>
        <span class="s1">union_mask = np.logical_or.reduce(na_masks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">na_rep </span><span class="s0">is None and </span><span class="s1">union_mask.any():</span>
            <span class="s4"># no na_rep means NaNs for all rows where any column has a NaN</span>
            <span class="s4"># only necessary if there are actually any NaNs</span>
            <span class="s1">result = np.empty(len(data)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">np.putmask(result</span><span class="s0">, </span><span class="s1">union_mask</span><span class="s0">, </span><span class="s1">np.nan)</span>

            <span class="s1">not_masked = ~union_mask</span>
            <span class="s1">result[not_masked] = cat_safe([x[not_masked] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">all_cols]</span><span class="s0">, </span><span class="s1">sep)</span>
        <span class="s0">elif </span><span class="s1">na_rep </span><span class="s0">is not None and </span><span class="s1">union_mask.any():</span>
            <span class="s4"># fill NaNs with na_rep in case there are actually any NaNs</span>
            <span class="s1">all_cols = [</span>
                <span class="s1">np.where(nm</span><span class="s0">, </span><span class="s1">na_rep</span><span class="s0">, </span><span class="s1">col) </span><span class="s0">for </span><span class="s1">nm</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">zip(na_masks</span><span class="s0">, </span><span class="s1">all_cols)</span>
            <span class="s1">]</span>
            <span class="s1">result = cat_safe(all_cols</span><span class="s0">, </span><span class="s1">sep)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># no NaNs - can just concatenate</span>
            <span class="s1">result = cat_safe(all_cols</span><span class="s0">, </span><span class="s1">sep)</span>

        <span class="s1">out: Index | Series</span>
        <span class="s0">if </span><span class="s1">isinstance(self._orig</span><span class="s0">, </span><span class="s1">ABCIndex):</span>
            <span class="s4"># add dtype for case that result is all-NA</span>

            <span class="s1">out = Index(result</span><span class="s0">, </span><span class="s1">dtype=object</span><span class="s0">, </span><span class="s1">name=self._orig.name)</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s4"># Series</span>
            <span class="s0">if </span><span class="s1">is_categorical_dtype(self._orig.dtype):</span>
                <span class="s4"># We need to infer the new categories.</span>
                <span class="s1">dtype = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">dtype = self._orig.dtype</span>
            <span class="s1">res_ser = Series(</span>
                <span class="s1">result</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">index=data.index</span><span class="s0">, </span><span class="s1">name=self._orig.name</span>
            <span class="s1">)</span>
            <span class="s1">out = res_ser.__finalize__(self._orig</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;str_cat&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;str_split&quot;</span>
    <span class="s1">] = </span><span class="s2">r&quot;&quot;&quot; 
    Split strings around given separator/delimiter. 
 
    Splits the string in the Series/Index from the %(side)s, 
    at the specified delimiter string. 
 
    Parameters 
    ---------- 
    pat : str or compiled regex, optional 
        String or regular expression to split on. 
        If not specified, split on whitespace. 
    n : int, default -1 (all) 
        Limit number of splits in output. 
        ``None``, 0 and -1 will be interpreted as return all splits. 
    expand : bool, default False 
        Expand the split strings into separate columns. 
 
        - If ``True``, return DataFrame/MultiIndex expanding dimensionality. 
        - If ``False``, return Series/Index, containing lists of strings. 
 
    regex : bool, default None 
        Determines if the passed-in pattern is a regular expression: 
 
        - If ``True``, assumes the passed-in pattern is a regular expression 
        - If ``False``, treats the pattern as a literal string. 
        - If ``None`` and `pat` length is 1, treats `pat` as a literal string. 
        - If ``None`` and `pat` length is not 1, treats `pat` as a regular expression. 
        - Cannot be set to False if `pat` is a compiled regex 
 
        .. versionadded:: 1.4.0 
 
    Returns 
    ------- 
    Series, Index, DataFrame or MultiIndex 
        Type matches caller unless ``expand=True`` (see Notes). 
 
    Raises 
    ------ 
    ValueError 
        * if `regex` is False and `pat` is a compiled regex 
 
    See Also 
    -------- 
    Series.str.split : Split strings around given separator/delimiter. 
    Series.str.rsplit : Splits string around given separator/delimiter, 
        starting from the right. 
    Series.str.join : Join lists contained as elements in the Series/Index 
        with passed delimiter. 
    str.split : Standard library version for split. 
    str.rsplit : Standard library version for rsplit. 
 
    Notes 
    ----- 
    The handling of the `n` keyword depends on the number of found splits: 
 
    - If found splits &gt; `n`,  make first `n` splits only 
    - If found splits &lt;= `n`, make all splits 
    - If for a certain row the number of found splits &lt; `n`, 
      append `None` for padding up to `n` if ``expand=True`` 
 
    If using ``expand=True``, Series and Index callers return DataFrame and 
    MultiIndex objects, respectively. 
 
    Use of `regex=False` with a `pat` as a compiled regex will raise 
    an error. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series( 
    ...     [ 
    ...         &quot;this is a regular sentence&quot;, 
    ...         &quot;https://docs.python.org/3/tutorial/index.html&quot;, 
    ...         np.nan 
    ...     ] 
    ... ) 
    &gt;&gt;&gt; s 
    0                       this is a regular sentence 
    1    https://docs.python.org/3/tutorial/index.html 
    2                                              NaN 
    dtype: object 
 
    In the default setting, the string is split by whitespace. 
 
    &gt;&gt;&gt; s.str.split() 
    0                   [this, is, a, regular, sentence] 
    1    [https://docs.python.org/3/tutorial/index.html] 
    2                                                NaN 
    dtype: object 
 
    Without the `n` parameter, the outputs of `rsplit` and `split` 
    are identical. 
 
    &gt;&gt;&gt; s.str.rsplit() 
    0                   [this, is, a, regular, sentence] 
    1    [https://docs.python.org/3/tutorial/index.html] 
    2                                                NaN 
    dtype: object 
 
    The `n` parameter can be used to limit the number of splits on the 
    delimiter. The outputs of `split` and `rsplit` are different. 
 
    &gt;&gt;&gt; s.str.split(n=2) 
    0                     [this, is, a regular sentence] 
    1    [https://docs.python.org/3/tutorial/index.html] 
    2                                                NaN 
    dtype: object 
 
    &gt;&gt;&gt; s.str.rsplit(n=2) 
    0                     [this is a, regular, sentence] 
    1    [https://docs.python.org/3/tutorial/index.html] 
    2                                                NaN 
    dtype: object 
 
    The `pat` parameter can be used to split by other characters. 
 
    &gt;&gt;&gt; s.str.split(pat=&quot;/&quot;) 
    0                         [this is a regular sentence] 
    1    [https:, , docs.python.org, 3, tutorial, index... 
    2                                                  NaN 
    dtype: object 
 
    When using ``expand=True``, the split elements will expand out into 
    separate columns. If NaN is present, it is propagated throughout 
    the columns during the split. 
 
    &gt;&gt;&gt; s.str.split(expand=True) 
                                                   0     1     2        3         4 
    0                                           this    is     a  regular  sentence 
    1  https://docs.python.org/3/tutorial/index.html  None  None     None      None 
    2                                            NaN   NaN   NaN      NaN       NaN 
 
    For slightly more complex use cases like splitting the html document name 
    from a url, a combination of parameter settings can be used. 
 
    &gt;&gt;&gt; s.str.rsplit(&quot;/&quot;, n=1, expand=True) 
                                        0           1 
    0          this is a regular sentence        None 
    1  https://docs.python.org/3/tutorial  index.html 
    2                                 NaN         NaN 
 
    Remember to escape special characters when explicitly using regular expressions. 
 
    &gt;&gt;&gt; s = pd.Series([&quot;foo and bar plus baz&quot;]) 
    &gt;&gt;&gt; s.str.split(r&quot;and|plus&quot;, expand=True) 
        0   1   2 
    0 foo bar baz 
 
    Regular expressions can be used to handle urls or file names. 
    When `pat` is a string and ``regex=None`` (the default), the given `pat` is compiled 
    as a regex only if ``len(pat) != 1``. 
 
    &gt;&gt;&gt; s = pd.Series(['foojpgbar.jpg']) 
    &gt;&gt;&gt; s.str.split(r&quot;.&quot;, expand=True) 
               0    1 
    0  foojpgbar  jpg 
 
    &gt;&gt;&gt; s.str.split(r&quot;\.jpg&quot;, expand=True) 
               0 1 
    0  foojpgbar 
 
    When ``regex=True``, `pat` is interpreted as a regex 
 
    &gt;&gt;&gt; s.str.split(r&quot;\.jpg&quot;, regex=True, expand=True) 
               0 1 
    0  foojpgbar 
 
    A compiled regex can be passed as `pat` 
 
    &gt;&gt;&gt; import re 
    &gt;&gt;&gt; s.str.split(re.compile(r&quot;\.jpg&quot;), expand=True) 
               0 1 
    0  foojpgbar 
 
    When ``regex=False``, `pat` is interpreted as the string itself 
 
    &gt;&gt;&gt; s.str.split(r&quot;\.jpg&quot;, regex=False, expand=True) 
                   0 
    0  foojpgbar.jpg 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;str_split&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;beginning&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;split&quot;</span><span class="s1">})</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">split(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">n=-</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">expand=</span><span class="s0">False,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">regex: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">regex </span><span class="s0">is False and </span><span class="s1">is_re(pat):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Cannot use a compiled regex as replacement pattern with regex=False&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_re(pat):</span>
            <span class="s1">regex = </span><span class="s0">True</span>
        <span class="s1">result = self._data.array._str_split(pat</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">expand</span><span class="s0">, </span><span class="s1">regex)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=expand</span><span class="s0">, </span><span class="s1">expand=expand)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;str_split&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;end&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;rsplit&quot;</span><span class="s1">})</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">rsplit(self</span><span class="s0">, </span><span class="s1">pat=</span><span class="s0">None, </span><span class="s1">n=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">result = self._data.array._str_rsplit(pat</span><span class="s0">, </span><span class="s1">n=n)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">expand=expand</span><span class="s0">, </span><span class="s1">returns_string=expand)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;str_partition&quot;</span>
    <span class="s1">] = </span><span class="s2">&quot;&quot;&quot; 
    Split the string at the %(side)s occurrence of `sep`. 
 
    This method splits the string at the %(side)s occurrence of `sep`, 
    and returns 3 elements containing the part before the separator, 
    the separator itself, and the part after the separator. 
    If the separator is not found, return %(return)s. 
 
    Parameters 
    ---------- 
    sep : str, default whitespace 
        String to split on. 
    expand : bool, default True 
        If True, return DataFrame/MultiIndex expanding dimensionality. 
        If False, return Series/Index. 
 
    Returns 
    ------- 
    DataFrame/MultiIndex or Series/Index of objects 
 
    See Also 
    -------- 
    %(also)s 
    Series.str.split : Split strings around given separators. 
    str.partition : Standard library version. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers']) 
    &gt;&gt;&gt; s 
    0    Linda van der Berg 
    1    George Pitt-Rivers 
    dtype: object 
 
    &gt;&gt;&gt; s.str.partition() 
            0  1             2 
    0   Linda     van der Berg 
    1  George      Pitt-Rivers 
 
    To partition by the last space instead of the first one: 
 
    &gt;&gt;&gt; s.str.rpartition() 
                   0  1            2 
    0  Linda van der            Berg 
    1         George     Pitt-Rivers 
 
    To partition by something different than a space: 
 
    &gt;&gt;&gt; s.str.partition('-') 
                        0  1       2 
    0  Linda van der Berg 
    1         George Pitt  -  Rivers 
 
    To return a Series containing tuples instead of a DataFrame: 
 
    &gt;&gt;&gt; s.str.partition('-', expand=False) 
    0    (Linda van der Berg, , ) 
    1    (George Pitt, -, Rivers) 
    dtype: object 
 
    Also available on indices: 
 
    &gt;&gt;&gt; idx = pd.Index(['X 123', 'Y 999']) 
    &gt;&gt;&gt; idx 
    Index(['X 123', 'Y 999'], dtype='object') 
 
    Which will create a MultiIndex: 
 
    &gt;&gt;&gt; idx.str.partition() 
    MultiIndex([('X', ' ', '123'), 
                ('Y', ' ', '999')], 
               ) 
 
    Or an index with tuples with ``expand=False``: 
 
    &gt;&gt;&gt; idx.str.partition(expand=False) 
    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object') 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_partition&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;first&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;return&quot;</span><span class="s1">: </span><span class="s2">&quot;3 elements containing the string itself, followed by two &quot;</span>
            <span class="s2">&quot;empty strings&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;also&quot;</span><span class="s1">: </span><span class="s2">&quot;rpartition : Split the string at the last occurrence of `sep`.&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">partition(self</span><span class="s0">, </span><span class="s1">sep=</span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">result = self._data.array._str_partition(sep</span><span class="s0">, </span><span class="s1">expand)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">expand=expand</span><span class="s0">, </span><span class="s1">returns_string=expand)</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_partition&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;last&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;return&quot;</span><span class="s1">: </span><span class="s2">&quot;3 elements containing two empty strings, followed by the &quot;</span>
            <span class="s2">&quot;string itself&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;also&quot;</span><span class="s1">: </span><span class="s2">&quot;partition : Split the string at the first occurrence of `sep`.&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">rpartition(self</span><span class="s0">, </span><span class="s1">sep=</span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s1">expand=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">result = self._data.array._str_rpartition(sep</span><span class="s0">, </span><span class="s1">expand)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">expand=expand</span><span class="s0">, </span><span class="s1">returns_string=expand)</span>

    <span class="s0">def </span><span class="s1">get(self</span><span class="s0">, </span><span class="s1">i):</span>
        <span class="s3">&quot;&quot;&quot; 
        Extract element from each component at specified position. 
 
        Extract element from lists, tuples, or strings in each element in the 
        Series/Index. 
 
        Parameters 
        ---------- 
        i : int 
            Position of element to extract. 
 
        Returns 
        ------- 
        Series or Index 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([&quot;String&quot;, 
        ...               (1, 2, 3), 
        ...               [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 
        ...               123, 
        ...               -456, 
        ...               {1: &quot;Hello&quot;, &quot;2&quot;: &quot;World&quot;}]) 
        &gt;&gt;&gt; s 
        0                        String 
        1                     (1, 2, 3) 
        2                     [a, b, c] 
        3                           123 
        4                          -456 
        5    {1: 'Hello', '2': 'World'} 
        dtype: object 
 
        &gt;&gt;&gt; s.str.get(1) 
        0        t 
        1        2 
        2        b 
        3      NaN 
        4      NaN 
        5    Hello 
        dtype: object 
 
        &gt;&gt;&gt; s.str.get(-1) 
        0      g 
        1      3 
        2      c 
        3    NaN 
        4    NaN 
        5    None 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_get(i)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">join(self</span><span class="s0">, </span><span class="s1">sep):</span>
        <span class="s3">&quot;&quot;&quot; 
        Join lists contained as elements in the Series/Index with passed delimiter. 
 
        If the elements of a Series are lists themselves, join the content of these 
        lists using the delimiter passed to the function. 
        This function is an equivalent to :meth:`str.join`. 
 
        Parameters 
        ---------- 
        sep : str 
            Delimiter to use between list entries. 
 
        Returns 
        ------- 
        Series/Index: object 
            The list entries concatenated by intervening occurrences of the 
            delimiter. 
 
        Raises 
        ------ 
        AttributeError 
            If the supplied Series contains neither strings nor lists. 
 
        See Also 
        -------- 
        str.join : Standard library version of this method. 
        Series.str.split : Split strings around given separator/delimiter. 
 
        Notes 
        ----- 
        If any of the list items is not a string object, the result of the join 
        will be `NaN`. 
 
        Examples 
        -------- 
        Example with a list that contains non-string elements. 
 
        &gt;&gt;&gt; s = pd.Series([['lion', 'elephant', 'zebra'], 
        ...                [1.1, 2.2, 3.3], 
        ...                ['cat', np.nan, 'dog'], 
        ...                ['cow', 4.5, 'goat'], 
        ...                ['duck', ['swan', 'fish'], 'guppy']]) 
        &gt;&gt;&gt; s 
        0        [lion, elephant, zebra] 
        1                [1.1, 2.2, 3.3] 
        2                [cat, nan, dog] 
        3               [cow, 4.5, goat] 
        4    [duck, [swan, fish], guppy] 
        dtype: object 
 
        Join all lists using a '-'. The lists containing object(s) of types other 
        than str will produce a NaN. 
 
        &gt;&gt;&gt; s.str.join('-') 
        0    lion-elephant-zebra 
        1                    NaN 
        2                    NaN 
        3                    NaN 
        4                    NaN 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_join(sep)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">contains(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case=</span><span class="s0">True, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None, </span><span class="s1">regex=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Test if pattern or regex is contained within a string of a Series or Index. 
 
        Return boolean Series or Index based on whether a given pattern or regex is 
        contained within a string of a Series or Index. 
 
        Parameters 
        ---------- 
        pat : str 
            Character sequence or regular expression. 
        case : bool, default True 
            If True, case sensitive. 
        flags : int, default 0 (no flags) 
            Flags to pass through to the re module, e.g. re.IGNORECASE. 
        na : scalar, optional 
            Fill value for missing values. The default depends on dtype of the 
            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``, 
            ``pandas.NA`` is used. 
        regex : bool, default True 
            If True, assumes the pat is a regular expression. 
 
            If False, treats the pat as a literal string. 
 
        Returns 
        ------- 
        Series or Index of boolean values 
            A Series or Index of boolean values indicating whether the 
            given pattern is contained within the string of each element 
            of the Series or Index. 
 
        See Also 
        -------- 
        match : Analogous, but stricter, relying on re.match instead of re.search. 
        Series.str.startswith : Test if the start of each string element matches a 
            pattern. 
        Series.str.endswith : Same as startswith, but tests the end of string. 
 
        Examples 
        -------- 
        Returning a Series of booleans using only a literal pattern. 
 
        &gt;&gt;&gt; s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN]) 
        &gt;&gt;&gt; s1.str.contains('og', regex=False) 
        0    False 
        1     True 
        2    False 
        3    False 
        4      NaN 
        dtype: object 
 
        Returning an Index of booleans using only a literal pattern. 
 
        &gt;&gt;&gt; ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN]) 
        &gt;&gt;&gt; ind.str.contains('23', regex=False) 
        Index([False, False, False, True, nan], dtype='object') 
 
        Specifying case sensitivity using `case`. 
 
        &gt;&gt;&gt; s1.str.contains('oG', case=True, regex=True) 
        0    False 
        1    False 
        2    False 
        3    False 
        4      NaN 
        dtype: object 
 
        Specifying `na` to be `False` instead of `NaN` replaces NaN values 
        with `False`. If Series or Index does not contain NaN values 
        the resultant dtype will be `bool`, otherwise, an `object` dtype. 
 
        &gt;&gt;&gt; s1.str.contains('og', na=False, regex=True) 
        0    False 
        1     True 
        2    False 
        3    False 
        4    False 
        dtype: bool 
 
        Returning 'house' or 'dog' when either expression occurs in a string. 
 
        &gt;&gt;&gt; s1.str.contains('house|dog', regex=True) 
        0    False 
        1     True 
        2     True 
        3    False 
        4      NaN 
        dtype: object 
 
        Ignoring case sensitivity using `flags` with regex. 
 
        &gt;&gt;&gt; import re 
        &gt;&gt;&gt; s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True) 
        0    False 
        1    False 
        2     True 
        3    False 
        4      NaN 
        dtype: object 
 
        Returning any digit using regular expression. 
 
        &gt;&gt;&gt; s1.str.contains('\\d', regex=True) 
        0    False 
        1    False 
        2    False 
        3     True 
        4      NaN 
        dtype: object 
 
        Ensure `pat` is a not a literal pattern when `regex` is set to True. 
        Note in the following example one might expect only `s2[1]` and `s2[3]` to 
        return `True`. However, '.0' as a regex matches any character 
        followed by a 0. 
 
        &gt;&gt;&gt; s2 = pd.Series(['40', '40.0', '41', '41.0', '35']) 
        &gt;&gt;&gt; s2.str.contains('.0', regex=True) 
        0     True 
        1     True 
        2    False 
        3     True 
        4    False 
        dtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">regex </span><span class="s0">and </span><span class="s1">re.compile(pat).groups:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;This pattern is interpreted as a regular expression, and has &quot;</span>
                <span class="s2">&quot;match groups. To actually get the groups, use str.extract.&quot;</span><span class="s0">,</span>
                <span class="s1">UserWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">result = self._data.array._str_contains(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">regex)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">fill_value=na</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">match(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case=</span><span class="s0">True, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Determine if each string starts with a match of a regular expression. 
 
        Parameters 
        ---------- 
        pat : str 
            Character sequence or regular expression. 
        case : bool, default True 
            If True, case sensitive. 
        flags : int, default 0 (no flags) 
            Regex module flags, e.g. re.IGNORECASE. 
        na : scalar, optional 
            Fill value for missing values. The default depends on dtype of the 
            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``, 
            ``pandas.NA`` is used. 
 
        Returns 
        ------- 
        Series/Index/array of boolean values 
 
        See Also 
        -------- 
        fullmatch : Stricter matching that requires the entire string to match. 
        contains : Analogous, but less strict, relying on re.search instead of 
            re.match. 
        extract : Extract matched groups. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_match(pat</span><span class="s0">, </span><span class="s1">case=case</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">na=na)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">fill_value=na</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">fullmatch(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case=</span><span class="s0">True, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Determine if each string entirely matches a regular expression. 
 
        .. versionadded:: 1.1.0 
 
        Parameters 
        ---------- 
        pat : str 
            Character sequence or regular expression. 
        case : bool, default True 
            If True, case sensitive. 
        flags : int, default 0 (no flags) 
            Regex module flags, e.g. re.IGNORECASE. 
        na : scalar, optional 
            Fill value for missing values. The default depends on dtype of the 
            array. For object-dtype, ``numpy.nan`` is used. For ``StringDtype``, 
            ``pandas.NA`` is used. 
 
        Returns 
        ------- 
        Series/Index/array of boolean values 
 
        See Also 
        -------- 
        match : Similar, but also returns `True` when only a *prefix* of the string 
            matches the regular expression. 
        extract : Extract matched groups. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_fullmatch(pat</span><span class="s0">, </span><span class="s1">case=case</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">na=na)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">fill_value=na</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">replace(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern</span><span class="s0">,</span>
        <span class="s1">repl: str | Callable</span><span class="s0">,</span>
        <span class="s1">n: int = -</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">case: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">regex: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Replace each occurrence of pattern/regex in the Series/Index. 
 
        Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on 
        the regex value. 
 
        Parameters 
        ---------- 
        pat : str or compiled regex 
            String can be a character sequence or regular expression. 
        repl : str or callable 
            Replacement string or a callable. The callable is passed the regex 
            match object and must return a replacement string to be used. 
            See :func:`re.sub`. 
        n : int, default -1 (all) 
            Number of replacements to make from start. 
        case : bool, default None 
            Determines if replace is case sensitive: 
 
            - If True, case sensitive (the default if `pat` is a string) 
            - Set to False for case insensitive 
            - Cannot be set if `pat` is a compiled regex. 
 
        flags : int, default 0 (no flags) 
            Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled 
            regex. 
        regex : bool, default True 
            Determines if the passed-in pattern is a regular expression: 
 
            - If True, assumes the passed-in pattern is a regular expression. 
            - If False, treats the pattern as a literal string 
            - Cannot be set to False if `pat` is a compiled regex or `repl` is 
              a callable. 
 
            .. versionadded:: 0.23.0 
 
        Returns 
        ------- 
        Series or Index of object 
            A copy of the object with all matching occurrences of `pat` replaced by 
            `repl`. 
 
        Raises 
        ------ 
        ValueError 
            * if `regex` is False and `repl` is a callable or `pat` is a compiled 
              regex 
            * if `pat` is a compiled regex and `case` or `flags` is set 
 
        Notes 
        ----- 
        When `pat` is a compiled regex, all flags should be included in the 
        compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled 
        regex will raise an error. 
 
        Examples 
        -------- 
        When `pat` is a string and `regex` is True (the default), the given `pat` 
        is compiled as a regex. When `repl` is a string, it replaces matching 
        regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are 
        left as is: 
 
        &gt;&gt;&gt; pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True) 
        0    bao 
        1    baz 
        2    NaN 
        dtype: object 
 
        When `pat` is a string and `regex` is False, every `pat` is replaced with 
        `repl` as with :meth:`str.replace`: 
 
        &gt;&gt;&gt; pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False) 
        0    bao 
        1    fuz 
        2    NaN 
        dtype: object 
 
        When `repl` is a callable, it is called on every `pat` using 
        :func:`re.sub`. The callable should expect one positional argument 
        (a regex object) and return a string. 
 
        To get the idea: 
 
        &gt;&gt;&gt; pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr, regex=True) 
        0    &lt;re.Match object; span=(0, 1), match='f'&gt;oo 
        1    &lt;re.Match object; span=(0, 1), match='f'&gt;uz 
        2                                            NaN 
        dtype: object 
 
        Reverse every lowercase alphabetic word: 
 
        &gt;&gt;&gt; repl = lambda m: m.group(0)[::-1] 
        &gt;&gt;&gt; ser = pd.Series(['foo 123', 'bar baz', np.nan]) 
        &gt;&gt;&gt; ser.str.replace(r'[a-z]+', repl, regex=True) 
        0    oof 123 
        1    rab zab 
        2        NaN 
        dtype: object 
 
        Using regex groups (extract second group and swap case): 
 
        &gt;&gt;&gt; pat = r&quot;(?P&lt;one&gt;\w+) (?P&lt;two&gt;\w+) (?P&lt;three&gt;\w+)&quot; 
        &gt;&gt;&gt; repl = lambda m: m.group('two').swapcase() 
        &gt;&gt;&gt; ser = pd.Series(['One Two Three', 'Foo Bar Baz']) 
        &gt;&gt;&gt; ser.str.replace(pat, repl, regex=True) 
        0    tWO 
        1    bAR 
        dtype: object 
 
        Using a compiled regex with flags 
 
        &gt;&gt;&gt; import re 
        &gt;&gt;&gt; regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE) 
        &gt;&gt;&gt; pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar', regex=True) 
        0    foo 
        1    bar 
        2    NaN 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">regex </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(pat</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">any(c </span><span class="s0">in </span><span class="s1">pat </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s2">&quot;.+*|^$?[](){}</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s1">):</span>
                <span class="s4"># warn only in cases where regex behavior would differ from literal</span>
                <span class="s1">msg = (</span>
                    <span class="s2">&quot;The default value of regex will change from True to False &quot;</span>
                    <span class="s2">&quot;in a future version.&quot;</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(pat) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">msg += (</span>
                        <span class="s2">&quot; In addition, single character regular expressions will &quot;</span>
                        <span class="s2">&quot;*not* be treated as literal strings when regex=True.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=find_stack_level())</span>

        <span class="s4"># Check whether repl is valid (GH 13438, GH 15055)</span>
        <span class="s0">if not </span><span class="s1">(isinstance(repl</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or </span><span class="s1">callable(repl)):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;repl must be a string or callable&quot;</span><span class="s1">)</span>

        <span class="s1">is_compiled_re = is_re(pat)</span>
        <span class="s0">if </span><span class="s1">regex </span><span class="s0">or </span><span class="s1">regex </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">is_compiled_re </span><span class="s0">and </span><span class="s1">(case </span><span class="s0">is not None or </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;case and flags cannot be set when pat is a compiled regex&quot;</span>
                <span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">is_compiled_re:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Cannot use a compiled regex as replacement pattern with regex=False&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">callable(repl):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot use a callable replacement when regex=False&quot;</span><span class="s1">)</span>

        <span class="s4"># The current behavior is to treat single character patterns as literal strings,</span>
        <span class="s4"># even when ``regex`` is set to ``True``.</span>
        <span class="s0">if </span><span class="s1">isinstance(pat</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">len(pat) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">regex = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">regex </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">regex = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">case </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">case = </span><span class="s0">True</span>

        <span class="s1">result = self._data.array._str_replace(</span>
            <span class="s1">pat</span><span class="s0">, </span><span class="s1">repl</span><span class="s0">, </span><span class="s1">n=n</span><span class="s0">, </span><span class="s1">case=case</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">regex=regex</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">repeat(self</span><span class="s0">, </span><span class="s1">repeats):</span>
        <span class="s3">&quot;&quot;&quot; 
        Duplicate each string in the Series or Index. 
 
        Parameters 
        ---------- 
        repeats : int or sequence of int 
            Same value for all (int) or different value per (sequence). 
 
        Returns 
        ------- 
        Series or Index of object 
            Series or Index of repeated string objects specified by 
            input parameter repeats. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['a', 'b', 'c']) 
        &gt;&gt;&gt; s 
        0    a 
        1    b 
        2    c 
        dtype: object 
 
        Single int repeats string in Series 
 
        &gt;&gt;&gt; s.str.repeat(repeats=2) 
        0    aa 
        1    bb 
        2    cc 
        dtype: object 
 
        Sequence of int repeats corresponding string in Series 
 
        &gt;&gt;&gt; s.str.repeat(repeats=[1, 2, 3]) 
        0      a 
        1     bb 
        2    ccc 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_repeat(repeats)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">pad(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">fillchar=</span><span class="s2">&quot; &quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Pad strings in the Series/Index up to width. 
 
        Parameters 
        ---------- 
        width : int 
            Minimum width of resulting string; additional characters will be filled 
            with character defined in `fillchar`. 
        side : {'left', 'right', 'both'}, default 'left' 
            Side from which to fill resulting string. 
        fillchar : str, default ' ' 
            Additional character for filling, default is whitespace. 
 
        Returns 
        ------- 
        Series or Index of object 
            Returns Series or Index with minimum number of char in object. 
 
        See Also 
        -------- 
        Series.str.rjust : Fills the left side of strings with an arbitrary 
            character. Equivalent to ``Series.str.pad(side='left')``. 
        Series.str.ljust : Fills the right side of strings with an arbitrary 
            character. Equivalent to ``Series.str.pad(side='right')``. 
        Series.str.center : Fills both sides of strings with an arbitrary 
            character. Equivalent to ``Series.str.pad(side='both')``. 
        Series.str.zfill : Pad strings in the Series/Index by prepending '0' 
            character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([&quot;caribou&quot;, &quot;tiger&quot;]) 
        &gt;&gt;&gt; s 
        0    caribou 
        1      tiger 
        dtype: object 
 
        &gt;&gt;&gt; s.str.pad(width=10) 
        0       caribou 
        1         tiger 
        dtype: object 
 
        &gt;&gt;&gt; s.str.pad(width=10, side='right', fillchar='-') 
        0    caribou--- 
        1    tiger----- 
        dtype: object 
 
        &gt;&gt;&gt; s.str.pad(width=10, side='both', fillchar='-') 
        0    -caribou-- 
        1    --tiger--- 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(fillchar</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;fillchar must be a character, not </span><span class="s0">{</span><span class="s1">type(fillchar).__name__</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s0">if </span><span class="s1">len(fillchar) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;fillchar must be a character, not str&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">is_integer(width):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;width must be of integer type, not </span><span class="s0">{</span><span class="s1">type(width).__name__</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">result = self._data.array._str_pad(width</span><span class="s0">, </span><span class="s1">side=side</span><span class="s0">, </span><span class="s1">fillchar=fillchar)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;str_pad&quot;</span>
    <span class="s1">] = </span><span class="s2">&quot;&quot;&quot; 
    Pad %(side)s side of strings in the Series/Index. 
 
    Equivalent to :meth:`str.%(method)s`. 
 
    Parameters 
    ---------- 
    width : int 
        Minimum width of resulting string; additional characters will be filled 
        with ``fillchar``. 
    fillchar : str 
        Additional character for filling, default is whitespace. 
 
    Returns 
    ------- 
    filled : Series/Index of objects. 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;str_pad&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;left and right&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;center&quot;</span><span class="s1">})</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">center(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">fillchar=</span><span class="s2">&quot; &quot;</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self.pad(width</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s1">fillchar=fillchar)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;str_pad&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;right&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;ljust&quot;</span><span class="s1">})</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">ljust(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">fillchar=</span><span class="s2">&quot; &quot;</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self.pad(width</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;right&quot;</span><span class="s0">, </span><span class="s1">fillchar=fillchar)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;str_pad&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;rjust&quot;</span><span class="s1">})</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">rjust(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">fillchar=</span><span class="s2">&quot; &quot;</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self.pad(width</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">fillchar=fillchar)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">zfill(self</span><span class="s0">, </span><span class="s1">width):</span>
        <span class="s3">&quot;&quot;&quot; 
        Pad strings in the Series/Index by prepending '0' characters. 
 
        Strings in the Series/Index are padded with '0' characters on the 
        left of the string to reach a total string length  `width`. Strings 
        in the Series/Index with length greater or equal to `width` are 
        unchanged. 
 
        Parameters 
        ---------- 
        width : int 
            Minimum length of resulting string; strings with length less 
            than `width` be prepended with '0' characters. 
 
        Returns 
        ------- 
        Series/Index of objects. 
 
        See Also 
        -------- 
        Series.str.rjust : Fills the left side of strings with an arbitrary 
            character. 
        Series.str.ljust : Fills the right side of strings with an arbitrary 
            character. 
        Series.str.pad : Fills the specified sides of strings with an arbitrary 
            character. 
        Series.str.center : Fills both sides of strings with an arbitrary 
            character. 
 
        Notes 
        ----- 
        Differs from :meth:`str.zfill` which has special handling 
        for '+'/'-' in the string. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['-1', '1', '1000', 10, np.nan]) 
        &gt;&gt;&gt; s 
        0      -1 
        1       1 
        2    1000 
        3      10 
        4     NaN 
        dtype: object 
 
        Note that ``10`` and ``NaN`` are not strings, therefore they are 
        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a 
        regular character and the zero is added to the left of it 
        (:meth:`str.zfill` would have moved it to the left). ``1000`` 
        remains unchanged as it is longer than `width`. 
 
        &gt;&gt;&gt; s.str.zfill(3) 
        0     0-1 
        1     001 
        2    1000 
        3     NaN 
        4     NaN 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self.pad(width</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">fillchar=</span><span class="s2">&quot;0&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s0">def </span><span class="s1">slice(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">stop=</span><span class="s0">None, </span><span class="s1">step=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Slice substrings from each element in the Series or Index. 
 
        Parameters 
        ---------- 
        start : int, optional 
            Start position for slice operation. 
        stop : int, optional 
            Stop position for slice operation. 
        step : int, optional 
            Step size for slice operation. 
 
        Returns 
        ------- 
        Series or Index of object 
            Series or Index from sliced substring from original string object. 
 
        See Also 
        -------- 
        Series.str.slice_replace : Replace a slice with a string. 
        Series.str.get : Return element at position. 
            Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i` 
            being the position. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([&quot;koala&quot;, &quot;dog&quot;, &quot;chameleon&quot;]) 
        &gt;&gt;&gt; s 
        0        koala 
        1          dog 
        2    chameleon 
        dtype: object 
 
        &gt;&gt;&gt; s.str.slice(start=1) 
        0        oala 
        1          og 
        2    hameleon 
        dtype: object 
 
        &gt;&gt;&gt; s.str.slice(start=-1) 
        0           a 
        1           g 
        2           n 
        dtype: object 
 
        &gt;&gt;&gt; s.str.slice(stop=2) 
        0    ko 
        1    do 
        2    ch 
        dtype: object 
 
        &gt;&gt;&gt; s.str.slice(step=2) 
        0      kaa 
        1       dg 
        2    caeen 
        dtype: object 
 
        &gt;&gt;&gt; s.str.slice(start=0, stop=5, step=3) 
        0    kl 
        1     d 
        2    cm 
        dtype: object 
 
        Equivalent behaviour to: 
 
        &gt;&gt;&gt; s.str[0:5:3] 
        0    kl 
        1     d 
        2    cm 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">slice_replace(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">stop=</span><span class="s0">None, </span><span class="s1">repl=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Replace a positional slice of a string with another value. 
 
        Parameters 
        ---------- 
        start : int, optional 
            Left index position to use for the slice. If not specified (None), 
            the slice is unbounded on the left, i.e. slice from the start 
            of the string. 
        stop : int, optional 
            Right index position to use for the slice. If not specified (None), 
            the slice is unbounded on the right, i.e. slice until the 
            end of the string. 
        repl : str, optional 
            String for replacement. If not specified (None), the sliced region 
            is replaced with an empty string. 
 
        Returns 
        ------- 
        Series or Index 
            Same type as the original object. 
 
        See Also 
        -------- 
        Series.str.slice : Just slicing without replacement. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde']) 
        &gt;&gt;&gt; s 
        0        a 
        1       ab 
        2      abc 
        3     abdc 
        4    abcde 
        dtype: object 
 
        Specify just `start`, meaning replace `start` until the end of the 
        string with `repl`. 
 
        &gt;&gt;&gt; s.str.slice_replace(1, repl='X') 
        0    aX 
        1    aX 
        2    aX 
        3    aX 
        4    aX 
        dtype: object 
 
        Specify just `stop`, meaning the start of the string to `stop` is replaced 
        with `repl`, and the rest of the string is included. 
 
        &gt;&gt;&gt; s.str.slice_replace(stop=2, repl='X') 
        0       X 
        1       X 
        2      Xc 
        3     Xdc 
        4    Xcde 
        dtype: object 
 
        Specify `start` and `stop`, meaning the slice from `start` to `stop` is 
        replaced with `repl`. Everything before or after `start` and `stop` is 
        included as is. 
 
        &gt;&gt;&gt; s.str.slice_replace(start=1, stop=3, repl='X') 
        0      aX 
        1      aX 
        2      aX 
        3     aXc 
        4    aXde 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_slice_replace(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">repl)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoding</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;strict&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Decode character string in the Series/Index using indicated encoding. 
 
        Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in 
        python3. 
 
        Parameters 
        ---------- 
        encoding : str 
        errors : str, optional 
 
        Returns 
        ------- 
        Series or Index 
        &quot;&quot;&quot;</span>
        <span class="s4"># TODO: Add a similar _bytes interface.</span>
        <span class="s0">if </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">_cpython_optimized_decoders:</span>
            <span class="s4"># CPython optimized implementation</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x.decode(encoding</span><span class="s0">, </span><span class="s1">errors)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">decoder = codecs.getdecoder(encoding)</span>
            <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: decoder(x</span><span class="s0">, </span><span class="s1">errors)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">arr = self._data.array</span>
        <span class="s4"># assert isinstance(arr, (StringArray,))</span>
        <span class="s1">result = arr._str_map(f)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">encoding</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;strict&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Encode character string in the Series/Index using indicated encoding. 
 
        Equivalent to :meth:`str.encode`. 
 
        Parameters 
        ---------- 
        encoding : str 
        errors : str, optional 
 
        Returns 
        ------- 
        encoded : Series/Index of objects 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_encode(encoding</span><span class="s0">, </span><span class="s1">errors)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;str_strip&quot;</span>
    <span class="s1">] = </span><span class="s2">r&quot;&quot;&quot; 
    Remove %(position)s characters. 
 
    Strip whitespaces (including newlines) or a set of specified characters 
    from each string in the Series/Index from %(side)s. 
    Equivalent to :meth:`str.%(method)s`. 
 
    Parameters 
    ---------- 
    to_strip : str or None, default None 
        Specifying the set of characters to be removed. 
        All combinations of this set of characters will be stripped. 
        If None then whitespaces are removed. 
 
    Returns 
    ------- 
    Series or Index of object 
 
    See Also 
    -------- 
    Series.str.strip : Remove leading and trailing characters in Series/Index. 
    Series.str.lstrip : Remove leading characters in Series/Index. 
    Series.str.rstrip : Remove trailing characters in Series/Index. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series(['1. Ant.  ', '2. Bee!\n', '3. Cat?\t', np.nan]) 
    &gt;&gt;&gt; s 
    0    1. Ant. 
    1    2. Bee!\n 
    2    3. Cat?\t 
    3          NaN 
    dtype: object 
 
    &gt;&gt;&gt; s.str.strip() 
    0    1. Ant. 
    1    2. Bee! 
    2    3. Cat? 
    3        NaN 
    dtype: object 
 
    &gt;&gt;&gt; s.str.lstrip('123.') 
    0    Ant. 
    1    Bee!\n 
    2    Cat?\t 
    3       NaN 
    dtype: object 
 
    &gt;&gt;&gt; s.str.rstrip('.!? \n\t') 
    0    1. Ant 
    1    2. Bee 
    2    3. Cat 
    3       NaN 
    dtype: object 
 
    &gt;&gt;&gt; s.str.strip('123.!? \n\t') 
    0    Ant 
    1    Bee 
    2    Cat 
    3    NaN 
    dtype: object 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_strip&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;left and right sides&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;strip&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;position&quot;</span><span class="s1">: </span><span class="s2">&quot;leading and trailing&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">strip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">result = self._data.array._str_strip(to_strip)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_strip&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;left side&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;lstrip&quot;</span><span class="s0">, </span><span class="s2">&quot;position&quot;</span><span class="s1">: </span><span class="s2">&quot;leading&quot;</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">lstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">result = self._data.array._str_lstrip(to_strip)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_strip&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;right side&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;rstrip&quot;</span><span class="s0">, </span><span class="s2">&quot;position&quot;</span><span class="s1">: </span><span class="s2">&quot;trailing&quot;</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">rstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">result = self._data.array._str_rstrip(to_strip)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;str_removefix&quot;</span>
    <span class="s1">] = </span><span class="s2">r&quot;&quot;&quot; 
    Remove a %(side)s from an object series. If the %(side)s is not present, 
    the original string will be returned. 
 
    Parameters 
    ---------- 
    %(side)s : str 
        Remove the %(side)s of the string. 
 
    Returns 
    ------- 
    Series/Index: object 
        The Series or Index with given %(side)s removed. 
 
    See Also 
    -------- 
    Series.str.remove%(other_side)s : Remove a %(other_side)s from an object series. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series([&quot;str_foo&quot;, &quot;str_bar&quot;, &quot;no_prefix&quot;]) 
    &gt;&gt;&gt; s 
    0    str_foo 
    1    str_bar 
    2    no_prefix 
    dtype: object 
    &gt;&gt;&gt; s.str.removeprefix(&quot;str_&quot;) 
    0    foo 
    1    bar 
    2    no_prefix 
    dtype: object 
 
    &gt;&gt;&gt; s = pd.Series([&quot;foo_str&quot;, &quot;bar_str&quot;, &quot;no_suffix&quot;]) 
    &gt;&gt;&gt; s 
    0    foo_str 
    1    bar_str 
    2    no_suffix 
    dtype: object 
    &gt;&gt;&gt; s.str.removesuffix(&quot;_str&quot;) 
    0    foo 
    1    bar 
    2    no_suffix 
    dtype: object 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_removefix&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;prefix&quot;</span><span class="s0">, </span><span class="s2">&quot;other_side&quot;</span><span class="s1">: </span><span class="s2">&quot;suffix&quot;</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">removeprefix(self</span><span class="s0">, </span><span class="s1">prefix):</span>
        <span class="s1">result = self._data.array._str_removeprefix(prefix)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;str_removefix&quot;</span><span class="s1">] % {</span><span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;suffix&quot;</span><span class="s0">, </span><span class="s2">&quot;other_side&quot;</span><span class="s1">: </span><span class="s2">&quot;prefix&quot;</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">removesuffix(self</span><span class="s0">, </span><span class="s1">suffix):</span>
        <span class="s1">result = self._data.array._str_removesuffix(suffix)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">wrap(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Wrap strings in Series/Index at specified line width. 
 
        This method has the same keyword parameters and defaults as 
        :class:`textwrap.TextWrapper`. 
 
        Parameters 
        ---------- 
        width : int 
            Maximum line width. 
        expand_tabs : bool, optional 
            If True, tab characters will be expanded to spaces (default: True). 
        replace_whitespace : bool, optional 
            If True, each whitespace character (as defined by string.whitespace) 
            remaining after tab expansion will be replaced by a single space 
            (default: True). 
        drop_whitespace : bool, optional 
            If True, whitespace that, after wrapping, happens to end up at the 
            beginning or end of a line is dropped (default: True). 
        break_long_words : bool, optional 
            If True, then words longer than width will be broken in order to ensure 
            that no lines are longer than width. If it is false, long words will 
            not be broken, and some lines may be longer than width (default: True). 
        break_on_hyphens : bool, optional 
            If True, wrapping will occur preferably on whitespace and right after 
            hyphens in compound words, as it is customary in English. If false, 
            only whitespaces will be considered as potentially good places for line 
            breaks, but you need to set break_long_words to false if you want truly 
            insecable words (default: True). 
 
        Returns 
        ------- 
        Series or Index 
 
        Notes 
        ----- 
        Internally, this method uses a :class:`textwrap.TextWrapper` instance with 
        default settings. To achieve behavior matching R's stringr library str_wrap 
        function, use the arguments: 
 
        - expand_tabs = False 
        - replace_whitespace = True 
        - drop_whitespace = True 
        - break_long_words = False 
        - break_on_hyphens = False 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['line to be wrapped', 'another line to be wrapped']) 
        &gt;&gt;&gt; s.str.wrap(12) 
        0             line to be\nwrapped 
        1    another line\nto be\nwrapped 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_wrap(width</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">get_dummies(self</span><span class="s0">, </span><span class="s1">sep=</span><span class="s2">&quot;|&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return DataFrame of dummy/indicator variables for Series. 
 
        Each string in Series is split by sep and returned as a DataFrame 
        of dummy/indicator variables. 
 
        Parameters 
        ---------- 
        sep : str, default &quot;|&quot; 
            String to split on. 
 
        Returns 
        ------- 
        DataFrame 
            Dummy variables corresponding to values of the Series. 
 
        See Also 
        -------- 
        get_dummies : Convert categorical variable into dummy/indicator 
            variables. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; pd.Series(['a|b', 'a', 'a|c']).str.get_dummies() 
           a  b  c 
        0  1  1  0 
        1  1  0  0 
        2  1  0  1 
 
        &gt;&gt;&gt; pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies() 
           a  b  c 
        0  1  1  0 
        1  0  0  0 
        2  1  0  1 
        &quot;&quot;&quot;</span>
        <span class="s4"># we need to cast to Series of strings as only that has all</span>
        <span class="s4"># methods available for making the dummies...</span>
        <span class="s1">result</span><span class="s0">, </span><span class="s1">name = self._data.array._str_get_dummies(sep)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(</span>
            <span class="s1">result</span><span class="s0">,</span>
            <span class="s1">name=name</span><span class="s0">,</span>
            <span class="s1">expand=</span><span class="s0">True,</span>
            <span class="s1">returns_string=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">translate(self</span><span class="s0">, </span><span class="s1">table):</span>
        <span class="s3">&quot;&quot;&quot; 
        Map all characters in the string through the given mapping table. 
 
        Equivalent to standard :meth:`str.translate`. 
 
        Parameters 
        ---------- 
        table : dict 
            Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or 
            None. Unmapped characters are left untouched. 
            Characters mapped to None are deleted. :meth:`str.maketrans` is a 
            helper function for making translation tables. 
 
        Returns 
        ------- 
        Series or Index 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_translate(table)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">count(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Count occurrences of pattern in each string of the Series/Index. 
 
        This function is used to count the number of times a particular regex 
        pattern is repeated in each of the string elements of the 
        :class:`~pandas.Series`. 
 
        Parameters 
        ---------- 
        pat : str 
            Valid regular expression. 
        flags : int, default 0, meaning no flags 
            Flags for the `re` module. For a complete list, `see here 
            &lt;https://docs.python.org/3/howto/regex.html#compilation-flags&gt;`_. 
        **kwargs 
            For compatibility with other string methods. Not used. 
 
        Returns 
        ------- 
        Series or Index 
            Same type as the calling object containing the integer counts. 
 
        See Also 
        -------- 
        re : Standard library module for regular expressions. 
        str.count : Standard library version, without regular expression support. 
 
        Notes 
        ----- 
        Some characters need to be escaped when passing in `pat`. 
        eg. ``'$'`` has a special meaning in regex and must be escaped when 
        finding this literal character. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat']) 
        &gt;&gt;&gt; s.str.count('a') 
        0    0.0 
        1    0.0 
        2    2.0 
        3    2.0 
        4    NaN 
        5    0.0 
        6    1.0 
        dtype: float64 
 
        Escape ``'$'`` to find the literal dollar sign. 
 
        &gt;&gt;&gt; s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat']) 
        &gt;&gt;&gt; s.str.count('\\$') 
        0    1 
        1    0 
        2    1 
        3    2 
        4    2 
        5    0 
        dtype: int64 
 
        This is also available on Index 
 
        &gt;&gt;&gt; pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a') 
        Int64Index([0, 0, 2, 1], dtype='int64') 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_count(pat</span><span class="s0">, </span><span class="s1">flags)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">startswith(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test if the start of each string element matches a pattern. 
 
        Equivalent to :meth:`str.startswith`. 
 
        Parameters 
        ---------- 
        pat : str 
            Character sequence. Regular expressions are not accepted. 
        na : object, default NaN 
            Object shown if element tested is not a string. The default depends 
            on dtype of the array. For object-dtype, ``numpy.nan`` is used. 
            For ``StringDtype``, ``pandas.NA`` is used. 
 
        Returns 
        ------- 
        Series or Index of bool 
            A Series of booleans indicating whether the given pattern matches 
            the start of each string element. 
 
        See Also 
        -------- 
        str.startswith : Python standard library string method. 
        Series.str.endswith : Same as startswith, but tests the end of string. 
        Series.str.contains : Tests if string element contains a pattern. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['bat', 'Bear', 'cat', np.nan]) 
        &gt;&gt;&gt; s 
        0     bat 
        1    Bear 
        2     cat 
        3     NaN 
        dtype: object 
 
        &gt;&gt;&gt; s.str.startswith('b') 
        0     True 
        1    False 
        2    False 
        3      NaN 
        dtype: object 
 
        Specifying `na` to be `False` instead of `NaN`. 
 
        &gt;&gt;&gt; s.str.startswith('b', na=False) 
        0     True 
        1    False 
        2    False 
        3    False 
        dtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_startswith(pat</span><span class="s0">, </span><span class="s1">na=na)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">endswith(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test if the end of each string element matches a pattern. 
 
        Equivalent to :meth:`str.endswith`. 
 
        Parameters 
        ---------- 
        pat : str 
            Character sequence. Regular expressions are not accepted. 
        na : object, default NaN 
            Object shown if element tested is not a string. The default depends 
            on dtype of the array. For object-dtype, ``numpy.nan`` is used. 
            For ``StringDtype``, ``pandas.NA`` is used. 
 
        Returns 
        ------- 
        Series or Index of bool 
            A Series of booleans indicating whether the given pattern matches 
            the end of each string element. 
 
        See Also 
        -------- 
        str.endswith : Python standard library string method. 
        Series.str.startswith : Same as endswith, but tests the start of string. 
        Series.str.contains : Tests if string element contains a pattern. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['bat', 'bear', 'caT', np.nan]) 
        &gt;&gt;&gt; s 
        0     bat 
        1    bear 
        2     caT 
        3     NaN 
        dtype: object 
 
        &gt;&gt;&gt; s.str.endswith('t') 
        0     True 
        1    False 
        2    False 
        3      NaN 
        dtype: object 
 
        Specifying `na` to be `False` instead of `NaN`. 
 
        &gt;&gt;&gt; s.str.endswith('t', na=False) 
        0     True 
        1    False 
        2    False 
        3    False 
        dtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_endswith(pat</span><span class="s0">, </span><span class="s1">na=na)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">findall(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Find all occurrences of pattern or regular expression in the Series/Index. 
 
        Equivalent to applying :func:`re.findall` to all the elements in the 
        Series/Index. 
 
        Parameters 
        ---------- 
        pat : str 
            Pattern or regular expression. 
        flags : int, default 0 
            Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which 
            means no flags). 
 
        Returns 
        ------- 
        Series/Index of lists of strings 
            All non-overlapping matches of pattern or regular expression in each 
            string of this Series/Index. 
 
        See Also 
        -------- 
        count : Count occurrences of pattern or regular expression in each string 
            of the Series/Index. 
        extractall : For each string in the Series, extract groups from all matches 
            of regular expression and return a DataFrame with one row for each 
            match and one column for each group. 
        re.findall : The equivalent ``re`` function to all non-overlapping matches 
            of pattern or regular expression in string, as a list of strings. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['Lion', 'Monkey', 'Rabbit']) 
 
        The search for the pattern 'Monkey' returns one match: 
 
        &gt;&gt;&gt; s.str.findall('Monkey') 
        0          [] 
        1    [Monkey] 
        2          [] 
        dtype: object 
 
        On the other hand, the search for the pattern 'MONKEY' doesn't return any 
        match: 
 
        &gt;&gt;&gt; s.str.findall('MONKEY') 
        0    [] 
        1    [] 
        2    [] 
        dtype: object 
 
        Flags can be added to the pattern or regular expression. For instance, 
        to find the pattern 'MONKEY' ignoring the case: 
 
        &gt;&gt;&gt; import re 
        &gt;&gt;&gt; s.str.findall('MONKEY', flags=re.IGNORECASE) 
        0          [] 
        1    [Monkey] 
        2          [] 
        dtype: object 
 
        When the pattern matches more than one string in the Series, all matches 
        are returned: 
 
        &gt;&gt;&gt; s.str.findall('on') 
        0    [on] 
        1    [on] 
        2      [] 
        dtype: object 
 
        Regular expressions are supported too. For instance, the search for all the 
        strings ending with the word 'on' is shown next: 
 
        &gt;&gt;&gt; s.str.findall('on$') 
        0    [on] 
        1      [] 
        2      [] 
        dtype: object 
 
        If the pattern is found more than once in the same string, then a list of 
        multiple strings is returned: 
 
        &gt;&gt;&gt; s.str.findall('b') 
        0        [] 
        1        [] 
        2    [b, b] 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_findall(pat</span><span class="s0">, </span><span class="s1">flags)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">extract(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">expand: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; DataFrame | Series | Index:</span>
        <span class="s3">r&quot;&quot;&quot; 
        Extract capture groups in the regex `pat` as columns in a DataFrame. 
 
        For each subject string in the Series, extract groups from the 
        first match of regular expression `pat`. 
 
        Parameters 
        ---------- 
        pat : str 
            Regular expression pattern with capturing groups. 
        flags : int, default 0 (no flags) 
            Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that 
            modify regular expression matching for things like case, 
            spaces, etc. For more details, see :mod:`re`. 
        expand : bool, default True 
            If True, return DataFrame with one column per capture group. 
            If False, return a Series/Index if there is one capture group 
            or DataFrame if there are multiple capture groups. 
 
        Returns 
        ------- 
        DataFrame or Series or Index 
            A DataFrame with one row for each subject string, and one 
            column for each group. Any capture group names in regular 
            expression pat will be used for column names; otherwise 
            capture group numbers will be used. The dtype of each result 
            column is always object, even when no match is found. If 
            ``expand=False`` and pat has only one capture group, then 
            return a Series (if subject is a Series) or Index (if subject 
            is an Index). 
 
        See Also 
        -------- 
        extractall : Returns all matches (not just the first match). 
 
        Examples 
        -------- 
        A pattern with two groups will return a DataFrame with two columns. 
        Non-matches will be NaN. 
 
        &gt;&gt;&gt; s = pd.Series(['a1', 'b2', 'c3']) 
        &gt;&gt;&gt; s.str.extract(r'([ab])(\d)') 
            0    1 
        0    a    1 
        1    b    2 
        2  NaN  NaN 
 
        A pattern may contain optional groups. 
 
        &gt;&gt;&gt; s.str.extract(r'([ab])?(\d)') 
            0  1 
        0    a  1 
        1    b  2 
        2  NaN  3 
 
        Named groups will become column names in the result. 
 
        &gt;&gt;&gt; s.str.extract(r'(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)') 
        letter digit 
        0      a     1 
        1      b     2 
        2    NaN   NaN 
 
        A pattern with one group will return a DataFrame with one column 
        if expand=True. 
 
        &gt;&gt;&gt; s.str.extract(r'[ab](\d)', expand=True) 
            0 
        0    1 
        1    2 
        2  NaN 
 
        A pattern with one group will return a Series if expand=False. 
 
        &gt;&gt;&gt; s.str.extract(r'[ab](\d)', expand=False) 
        0      1 
        1      2 
        2    NaN 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span>

        <span class="s0">if not </span><span class="s1">isinstance(expand</span><span class="s0">, </span><span class="s1">bool):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;expand must be True or False&quot;</span><span class="s1">)</span>

        <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>
        <span class="s0">if </span><span class="s1">regex.groups == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;pattern contains no capture groups&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">expand </span><span class="s0">and </span><span class="s1">regex.groups &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">isinstance(self._data</span><span class="s0">, </span><span class="s1">ABCIndex):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;only one regex group is supported with Index&quot;</span><span class="s1">)</span>

        <span class="s1">obj = self._data</span>
        <span class="s1">result_dtype = _result_dtype(obj)</span>

        <span class="s1">returns_df = regex.groups &gt; </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">expand</span>

        <span class="s0">if </span><span class="s1">returns_df:</span>
            <span class="s1">name = </span><span class="s0">None</span>
            <span class="s1">columns = _get_group_names(regex)</span>

            <span class="s0">if </span><span class="s1">obj.array.size == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">result = DataFrame(columns=columns</span><span class="s0">, </span><span class="s1">dtype=result_dtype)</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result_list = self._data.array._str_extract(</span>
                    <span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">expand=returns_df</span>
                <span class="s1">)</span>

                <span class="s1">result_index: Index | </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">ABCSeries):</span>
                    <span class="s1">result_index = obj.index</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">result_index = </span><span class="s0">None</span>

                <span class="s1">result = DataFrame(</span>
                    <span class="s1">result_list</span><span class="s0">, </span><span class="s1">columns=columns</span><span class="s0">, </span><span class="s1">index=result_index</span><span class="s0">, </span><span class="s1">dtype=result_dtype</span>
                <span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">name = _get_single_group_name(regex)</span>
            <span class="s1">result = self._data.array._str_extract(pat</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">expand=returns_df)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">extractall(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Extract capture groups in the regex `pat` as columns in DataFrame. 
 
        For each subject string in the Series, extract groups from all 
        matches of regular expression pat. When each subject string in the 
        Series has exactly one match, extractall(pat).xs(0, level='match') 
        is the same as extract(pat). 
 
        Parameters 
        ---------- 
        pat : str 
            Regular expression pattern with capturing groups. 
        flags : int, default 0 (no flags) 
            A ``re`` module flag, for example ``re.IGNORECASE``. These allow 
            to modify regular expression matching for things like case, spaces, 
            etc. Multiple flags can be combined with the bitwise OR operator, 
            for example ``re.IGNORECASE | re.MULTILINE``. 
 
        Returns 
        ------- 
        DataFrame 
            A ``DataFrame`` with one row for each match, and one column for each 
            group. Its rows have a ``MultiIndex`` with first levels that come from 
            the subject ``Series``. The last level is named 'match' and indexes the 
            matches in each item of the ``Series``. Any capture group names in 
            regular expression pat will be used for column names; otherwise capture 
            group numbers will be used. 
 
        See Also 
        -------- 
        extract : Returns first match only (not all matches). 
 
        Examples 
        -------- 
        A pattern with one group will return a DataFrame with one column. 
        Indices with no matches will not appear in the result. 
 
        &gt;&gt;&gt; s = pd.Series([&quot;a1a2&quot;, &quot;b1&quot;, &quot;c1&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]) 
        &gt;&gt;&gt; s.str.extractall(r&quot;[ab](\d)&quot;) 
                0 
        match 
        A 0      1 
          1      2 
        B 0      1 
 
        Capture group names are used for column names of the result. 
 
        &gt;&gt;&gt; s.str.extractall(r&quot;[ab](?P&lt;digit&gt;\d)&quot;) 
                digit 
        match 
        A 0         1 
          1         2 
        B 0         1 
 
        A pattern with two groups will return a DataFrame with two columns. 
 
        &gt;&gt;&gt; s.str.extractall(r&quot;(?P&lt;letter&gt;[ab])(?P&lt;digit&gt;\d)&quot;) 
                letter digit 
        match 
        A 0          a     1 
          1          a     2 
        B 0          b     1 
 
        Optional groups that do not match are NaN in the result. 
 
        &gt;&gt;&gt; s.str.extractall(r&quot;(?P&lt;letter&gt;[ab])?(?P&lt;digit&gt;\d)&quot;) 
                letter digit 
        match 
        A 0          a     1 
          1          a     2 
        B 0          b     1 
        C 0        NaN     1 
        &quot;&quot;&quot;</span>
        <span class="s4"># TODO: dispatch</span>
        <span class="s0">return </span><span class="s1">str_extractall(self._orig</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;find&quot;</span>
    <span class="s1">] = </span><span class="s2">&quot;&quot;&quot; 
    Return %(side)s indexes in each strings in the Series/Index. 
 
    Each of returned indexes corresponds to the position where the 
    substring is fully contained between [start:end]. Return -1 on 
    failure. Equivalent to standard :meth:`str.%(method)s`. 
 
    Parameters 
    ---------- 
    sub : str 
        Substring being searched. 
    start : int 
        Left edge index. 
    end : int 
        Right edge index. 
 
    Returns 
    ------- 
    Series or Index of int. 
 
    See Also 
    -------- 
    %(also)s 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;find&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;lowest&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;find&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;also&quot;</span><span class="s1">: </span><span class="s2">&quot;rfind : Return highest indexes in each strings.&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">find(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(sub</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;expected a string object, not </span><span class="s0">{</span><span class="s1">type(sub).__name__</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">result = self._data.array._str_find(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;find&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;highest&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;rfind&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;also&quot;</span><span class="s1">: </span><span class="s2">&quot;find : Return lowest indexes in each strings.&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">rfind(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(sub</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;expected a string object, not </span><span class="s0">{</span><span class="s1">type(sub).__name__</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">result = self._data.array._str_rfind(sub</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">normalize(self</span><span class="s0">, </span><span class="s1">form):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the Unicode normal form for the strings in the Series/Index. 
 
        For more information on the forms, see the 
        :func:`unicodedata.normalize`. 
 
        Parameters 
        ---------- 
        form : {'NFC', 'NFKC', 'NFD', 'NFKD'} 
            Unicode form. 
 
        Returns 
        ------- 
        normalized : Series/Index of objects 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_normalize(form)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;index&quot;</span>
    <span class="s1">] = </span><span class="s2">&quot;&quot;&quot; 
    Return %(side)s indexes in each string in Series/Index. 
 
    Each of the returned indexes corresponds to the position where the 
    substring is fully contained between [start:end]. This is the same 
    as ``str.%(similar)s`` except instead of returning -1, it raises a 
    ValueError when the substring is not found. Equivalent to standard 
    ``str.%(method)s``. 
 
    Parameters 
    ---------- 
    sub : str 
        Substring being searched. 
    start : int 
        Left edge index. 
    end : int 
        Right edge index. 
 
    Returns 
    ------- 
    Series or Index of object 
 
    See Also 
    -------- 
    %(also)s 
    &quot;&quot;&quot;</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;index&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;lowest&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;similar&quot;</span><span class="s1">: </span><span class="s2">&quot;find&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;index&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;also&quot;</span><span class="s1">: </span><span class="s2">&quot;rindex : Return highest indexes in each strings.&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">index(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(sub</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;expected a string object, not </span><span class="s0">{</span><span class="s1">type(sub).__name__</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">result = self._data.array._str_index(sub</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@Appender(</span>
        <span class="s1">_shared_docs[</span><span class="s2">&quot;index&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s2">&quot;side&quot;</span><span class="s1">: </span><span class="s2">&quot;highest&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;similar&quot;</span><span class="s1">: </span><span class="s2">&quot;rfind&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;rindex&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;also&quot;</span><span class="s1">: </span><span class="s2">&quot;index : Return lowest indexes in each strings.&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">rindex(self</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(sub</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;expected a string object, not </span><span class="s0">{</span><span class="s1">type(sub).__name__</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">result = self._data.array._str_rindex(sub</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">len(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute the length of each element in the Series/Index. 
 
        The element may be a sequence (such as a string, tuple or list) or a collection 
        (such as a dictionary). 
 
        Returns 
        ------- 
        Series or Index of int 
            A Series or Index of integer values indicating the length of each 
            element in the Series or Index. 
 
        See Also 
        -------- 
        str.len : Python built-in function returning the length of an object. 
        Series.size : Returns the length of the Series. 
 
        Examples 
        -------- 
        Returns the length (number of characters) in a string. Returns the 
        number of entries for dictionaries, lists or tuples. 
 
        &gt;&gt;&gt; s = pd.Series(['dog', 
        ...                 '', 
        ...                 5, 
        ...                 {'foo' : 'bar'}, 
        ...                 [2, 3, 5, 7], 
        ...                 ('one', 'two', 'three')]) 
        &gt;&gt;&gt; s 
        0                  dog 
        1 
        2                    5 
        3       {'foo': 'bar'} 
        4         [2, 3, 5, 7] 
        5    (one, two, three) 
        dtype: object 
        &gt;&gt;&gt; s.str.len() 
        0    3.0 
        1    0.0 
        2    NaN 
        3    1.0 
        4    4.0 
        5    3.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self._data.array._str_len()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result</span><span class="s0">, </span><span class="s1">returns_string=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;casemethods&quot;</span>
    <span class="s1">] = </span><span class="s2">&quot;&quot;&quot; 
    Convert strings in the Series/Index to %(type)s. 
    %(version)s 
    Equivalent to :meth:`str.%(method)s`. 
 
    Returns 
    ------- 
    Series or Index of object 
 
    See Also 
    -------- 
    Series.str.lower : Converts all characters to lowercase. 
    Series.str.upper : Converts all characters to uppercase. 
    Series.str.title : Converts first character of each word to uppercase and 
        remaining to lowercase. 
    Series.str.capitalize : Converts first character to uppercase and 
        remaining to lowercase. 
    Series.str.swapcase : Converts uppercase to lowercase and lowercase to 
        uppercase. 
    Series.str.casefold: Removes all case distinctions in the string. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe']) 
    &gt;&gt;&gt; s 
    0                 lower 
    1              CAPITALS 
    2    this is a sentence 
    3              SwApCaSe 
    dtype: object 
 
    &gt;&gt;&gt; s.str.lower() 
    0                 lower 
    1              capitals 
    2    this is a sentence 
    3              swapcase 
    dtype: object 
 
    &gt;&gt;&gt; s.str.upper() 
    0                 LOWER 
    1              CAPITALS 
    2    THIS IS A SENTENCE 
    3              SWAPCASE 
    dtype: object 
 
    &gt;&gt;&gt; s.str.title() 
    0                 Lower 
    1              Capitals 
    2    This Is A Sentence 
    3              Swapcase 
    dtype: object 
 
    &gt;&gt;&gt; s.str.capitalize() 
    0                 Lower 
    1              Capitals 
    2    This is a sentence 
    3              Swapcase 
    dtype: object 
 
    &gt;&gt;&gt; s.str.swapcase() 
    0                 LOWER 
    1              capitals 
    2    THIS IS A SENTENCE 
    3              sWaPcAsE 
    dtype: object 
    &quot;&quot;&quot;</span>
    <span class="s4"># Types:</span>
    <span class="s4">#   cases:</span>
    <span class="s4">#       upper, lower, title, capitalize, swapcase, casefold</span>
    <span class="s4">#   boolean:</span>
    <span class="s4">#     isalpha, isnumeric isalnum isdigit isdecimal isspace islower isupper istitle</span>
    <span class="s4"># _doc_args holds dict of strings to use in substituting casemethod docs</span>
    <span class="s1">_doc_args: dict[str</span><span class="s0">, </span><span class="s1">dict[str</span><span class="s0">, </span><span class="s1">str]] = {}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;lower&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;lowercase&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;lower&quot;</span><span class="s0">, </span><span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;upper&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;uppercase&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;upper&quot;</span><span class="s0">, </span><span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;title&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;titlecase&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;title&quot;</span><span class="s0">, </span><span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;capitalize&quot;</span><span class="s1">] = {</span>
        <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;be capitalized&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;capitalize&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;swapcase&quot;</span><span class="s1">] = {</span>
        <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;be swapcased&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;swapcase&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;casefold&quot;</span><span class="s1">] = {</span>
        <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;be casefolded&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;casefold&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;</span><span class="s0">\n    </span><span class="s2">.. versionadded:: 0.25.0</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;casemethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;lower&quot;</span><span class="s1">])</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">lower(self):</span>
        <span class="s1">result = self._data.array._str_lower()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;casemethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;upper&quot;</span><span class="s1">])</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">upper(self):</span>
        <span class="s1">result = self._data.array._str_upper()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;casemethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;title&quot;</span><span class="s1">])</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">title(self):</span>
        <span class="s1">result = self._data.array._str_title()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;casemethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;capitalize&quot;</span><span class="s1">])</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">capitalize(self):</span>
        <span class="s1">result = self._data.array._str_capitalize()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;casemethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;swapcase&quot;</span><span class="s1">])</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">swapcase(self):</span>
        <span class="s1">result = self._data.array._str_swapcase()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">@Appender(_shared_docs[</span><span class="s2">&quot;casemethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;casefold&quot;</span><span class="s1">])</span>
    <span class="s1">@forbid_nonstring_types([</span><span class="s2">&quot;bytes&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">casefold(self):</span>
        <span class="s1">result = self._data.array._str_casefold()</span>
        <span class="s0">return </span><span class="s1">self._wrap_result(result)</span>

    <span class="s1">_shared_docs[</span>
        <span class="s2">&quot;ismethods&quot;</span>
    <span class="s1">] = </span><span class="s2">&quot;&quot;&quot; 
    Check whether all characters in each string are %(type)s. 
 
    This is equivalent to running the Python string method 
    :meth:`str.%(method)s` for each element of the Series/Index. If a string 
    has zero characters, ``False`` is returned for that check. 
 
    Returns 
    ------- 
    Series or Index of bool 
        Series or Index of boolean values with the same length as the original 
        Series/Index. 
 
    See Also 
    -------- 
    Series.str.isalpha : Check whether all characters are alphabetic. 
    Series.str.isnumeric : Check whether all characters are numeric. 
    Series.str.isalnum : Check whether all characters are alphanumeric. 
    Series.str.isdigit : Check whether all characters are digits. 
    Series.str.isdecimal : Check whether all characters are decimal. 
    Series.str.isspace : Check whether all characters are whitespace. 
    Series.str.islower : Check whether all characters are lowercase. 
    Series.str.isupper : Check whether all characters are uppercase. 
    Series.str.istitle : Check whether all characters are titlecase. 
 
    Examples 
    -------- 
    **Checks for Alphabetic and Numeric Characters** 
 
    &gt;&gt;&gt; s1 = pd.Series(['one', 'one1', '1', '']) 
 
    &gt;&gt;&gt; s1.str.isalpha() 
    0     True 
    1    False 
    2    False 
    3    False 
    dtype: bool 
 
    &gt;&gt;&gt; s1.str.isnumeric() 
    0    False 
    1    False 
    2     True 
    3    False 
    dtype: bool 
 
    &gt;&gt;&gt; s1.str.isalnum() 
    0     True 
    1     True 
    2     True 
    3    False 
    dtype: bool 
 
    Note that checks against characters mixed with any additional punctuation 
    or whitespace will evaluate to false for an alphanumeric check. 
 
    &gt;&gt;&gt; s2 = pd.Series(['A B', '1.5', '3,000']) 
    &gt;&gt;&gt; s2.str.isalnum() 
    0    False 
    1    False 
    2    False 
    dtype: bool 
 
    **More Detailed Checks for Numeric Characters** 
 
    There are several different but overlapping sets of numeric characters that 
    can be checked for. 
 
    &gt;&gt;&gt; s3 = pd.Series(['23', '', '', '']) 
 
    The ``s3.str.isdecimal`` method checks for characters used to form numbers 
    in base 10. 
 
    &gt;&gt;&gt; s3.str.isdecimal() 
    0     True 
    1    False 
    2    False 
    3    False 
    dtype: bool 
 
    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also 
    includes special digits, like superscripted and subscripted digits in 
    unicode. 
 
    &gt;&gt;&gt; s3.str.isdigit() 
    0     True 
    1     True 
    2    False 
    3    False 
    dtype: bool 
 
    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also 
    includes other characters that can represent quantities such as unicode 
    fractions. 
 
    &gt;&gt;&gt; s3.str.isnumeric() 
    0     True 
    1     True 
    2     True 
    3    False 
    dtype: bool 
 
    **Checks for Whitespace** 
 
    &gt;&gt;&gt; s4 = pd.Series([' ', '</span><span class="s0">\\</span><span class="s2">t</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">n ', '']) 
    &gt;&gt;&gt; s4.str.isspace() 
    0     True 
    1     True 
    2    False 
    dtype: bool 
 
    **Checks for Character Case** 
 
    &gt;&gt;&gt; s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', '']) 
 
    &gt;&gt;&gt; s5.str.islower() 
    0     True 
    1    False 
    2    False 
    3    False 
    dtype: bool 
 
    &gt;&gt;&gt; s5.str.isupper() 
    0    False 
    1    False 
    2     True 
    3    False 
    dtype: bool 
 
    The ``s5.str.istitle`` method checks for whether all words are in title 
    case (whether only the first letter of each word is capitalized). Words are 
    assumed to be as any sequence of non-numeric characters separated by 
    whitespace characters. 
 
    &gt;&gt;&gt; s5.str.istitle() 
    0    False 
    1     True 
    2    False 
    3    False 
    dtype: bool 
    &quot;&quot;&quot;</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isalnum&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;alphanumeric&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isalnum&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isalpha&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;alphabetic&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isalpha&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isdigit&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;digits&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isdigit&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isspace&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;whitespace&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isspace&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;islower&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;lowercase&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;islower&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isupper&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;uppercase&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isupper&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;istitle&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;titlecase&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;istitle&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isnumeric&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;numeric&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isnumeric&quot;</span><span class="s1">}</span>
    <span class="s1">_doc_args[</span><span class="s2">&quot;isdecimal&quot;</span><span class="s1">] = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;decimal&quot;</span><span class="s0">, </span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;isdecimal&quot;</span><span class="s1">}</span>
    <span class="s4"># force _noarg_wrapper return type with dtype=np.dtype(bool) (GH 29624)</span>

    <span class="s1">isalnum = _map_and_wrap(</span>
        <span class="s2">&quot;isalnum&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isalnum&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">isalpha = _map_and_wrap(</span>
        <span class="s2">&quot;isalpha&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isalpha&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">isdigit = _map_and_wrap(</span>
        <span class="s2">&quot;isdigit&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isdigit&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">isspace = _map_and_wrap(</span>
        <span class="s2">&quot;isspace&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isspace&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">islower = _map_and_wrap(</span>
        <span class="s2">&quot;islower&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;islower&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">isupper = _map_and_wrap(</span>
        <span class="s2">&quot;isupper&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isupper&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">istitle = _map_and_wrap(</span>
        <span class="s2">&quot;istitle&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;istitle&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">isnumeric = _map_and_wrap(</span>
        <span class="s2">&quot;isnumeric&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isnumeric&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">isdecimal = _map_and_wrap(</span>
        <span class="s2">&quot;isdecimal&quot;</span><span class="s0">, </span><span class="s1">docstring=_shared_docs[</span><span class="s2">&quot;ismethods&quot;</span><span class="s1">] % _doc_args[</span><span class="s2">&quot;isdecimal&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">cat_safe(list_of_columns: list</span><span class="s0">, </span><span class="s1">sep: str):</span>
    <span class="s3">&quot;&quot;&quot; 
    Auxiliary function for :meth:`str.cat`. 
 
    Same signature as cat_core, but handles TypeErrors in concatenation, which 
    happen if the arrays in list_of columns have the wrong dtypes or content. 
 
    Parameters 
    ---------- 
    list_of_columns : list of numpy arrays 
        List of arrays to be concatenated with sep; 
        these arrays may not contain NaNs! 
    sep : string 
        The separator string for concatenating the columns. 
 
    Returns 
    ------- 
    nd.array 
        The concatenation of list_of_columns with sep. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">result = cat_core(list_of_columns</span><span class="s0">, </span><span class="s1">sep)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s4"># if there are any non-string values (wrong dtype or hidden behind</span>
        <span class="s4"># object dtype), np.sum will fail; catch and return with better message</span>
        <span class="s0">for </span><span class="s1">column </span><span class="s0">in </span><span class="s1">list_of_columns:</span>
            <span class="s1">dtype = lib.infer_dtype(column</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;empty&quot;</span><span class="s1">]:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;Concatenation requires list-likes containing only &quot;</span>
                    <span class="s2">&quot;strings (or missing values). Offending values found in &quot;</span>
                    <span class="s2">f&quot;column </span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">) </span><span class="s0">from None</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">cat_core(list_of_columns: list</span><span class="s0">, </span><span class="s1">sep: str):</span>
    <span class="s3">&quot;&quot;&quot; 
    Auxiliary function for :meth:`str.cat` 
 
    Parameters 
    ---------- 
    list_of_columns : list of numpy arrays 
        List of arrays to be concatenated with sep; 
        these arrays may not contain NaNs! 
    sep : string 
        The separator string for concatenating the columns. 
 
    Returns 
    ------- 
    nd.array 
        The concatenation of list_of_columns with sep. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">sep == </span><span class="s2">&quot;&quot;</span><span class="s1">:</span>
        <span class="s4"># no need to interleave sep if it is empty</span>
        <span class="s1">arr_of_cols = np.asarray(list_of_columns</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s0">return </span><span class="s1">np.sum(arr_of_cols</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">list_with_sep = [sep] * (</span><span class="s5">2 </span><span class="s1">* len(list_of_columns) - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">list_with_sep[::</span><span class="s5">2</span><span class="s1">] = list_of_columns</span>
    <span class="s1">arr_with_sep = np.asarray(list_with_sep</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s0">return </span><span class="s1">np.sum(arr_with_sep</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_result_dtype(arr):</span>
    <span class="s4"># workaround #27953</span>
    <span class="s4"># ideally we just pass `dtype=arr.dtype` unconditionally, but this fails</span>
    <span class="s4"># when the list of values is empty.</span>
    <span class="s0">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s0">import </span><span class="s1">StringDtype</span>

    <span class="s0">if </span><span class="s1">isinstance(arr.dtype</span><span class="s0">, </span><span class="s1">StringDtype):</span>
        <span class="s0">return </span><span class="s1">arr.dtype</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">object</span>


<span class="s0">def </span><span class="s1">_get_single_group_name(regex: re.Pattern) -&gt; Hashable:</span>
    <span class="s0">if </span><span class="s1">regex.groupindex:</span>
        <span class="s0">return </span><span class="s1">next(iter(regex.groupindex))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">_get_group_names(regex: re.Pattern) -&gt; list[Hashable]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Get named groups from compiled regex. 
 
    Unnamed groups are numbered. 
 
    Parameters 
    ---------- 
    regex : compiled regex 
 
    Returns 
    ------- 
    list of column labels 
    &quot;&quot;&quot;</span>
    <span class="s1">names = {v: k </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">regex.groupindex.items()}</span>
    <span class="s0">return </span><span class="s1">[names.get(</span><span class="s5">1 </span><span class="s1">+ i</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(regex.groups)]</span>


<span class="s0">def </span><span class="s1">str_extractall(arr</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s1">regex = re.compile(pat</span><span class="s0">, </span><span class="s1">flags=flags)</span>
    <span class="s4"># the regex must contain capture groups.</span>
    <span class="s0">if </span><span class="s1">regex.groups == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;pattern contains no capture groups&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(arr</span><span class="s0">, </span><span class="s1">ABCIndex):</span>
        <span class="s1">arr = arr.to_series().reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">columns = _get_group_names(regex)</span>
    <span class="s1">match_list = []</span>
    <span class="s1">index_list = []</span>
    <span class="s1">is_mi = arr.index.nlevels &gt; </span><span class="s5">1</span>

    <span class="s0">for </span><span class="s1">subject_key</span><span class="s0">, </span><span class="s1">subject </span><span class="s0">in </span><span class="s1">arr.items():</span>
        <span class="s0">if </span><span class="s1">isinstance(subject</span><span class="s0">, </span><span class="s1">str):</span>

            <span class="s0">if not </span><span class="s1">is_mi:</span>
                <span class="s1">subject_key = (subject_key</span><span class="s0">,</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">match_i</span><span class="s0">, </span><span class="s1">match_tuple </span><span class="s0">in </span><span class="s1">enumerate(regex.findall(subject)):</span>
                <span class="s0">if </span><span class="s1">isinstance(match_tuple</span><span class="s0">, </span><span class="s1">str):</span>
                    <span class="s1">match_tuple = (match_tuple</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s1">na_tuple = [np.NaN </span><span class="s0">if </span><span class="s1">group == </span><span class="s2">&quot;&quot; </span><span class="s0">else </span><span class="s1">group </span><span class="s0">for </span><span class="s1">group </span><span class="s0">in </span><span class="s1">match_tuple]</span>
                <span class="s1">match_list.append(na_tuple)</span>
                <span class="s1">result_key = tuple(subject_key + (match_i</span><span class="s0">,</span><span class="s1">))</span>
                <span class="s1">index_list.append(result_key)</span>

    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">MultiIndex</span>

    <span class="s1">index = MultiIndex.from_tuples(index_list</span><span class="s0">, </span><span class="s1">names=arr.index.names + [</span><span class="s2">&quot;match&quot;</span><span class="s1">])</span>
    <span class="s1">dtype = _result_dtype(arr)</span>

    <span class="s1">result = arr._constructor_expanddim(</span>
        <span class="s1">match_list</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=columns</span><span class="s0">, </span><span class="s1">dtype=dtype</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>
</pre>
</body>
</html>