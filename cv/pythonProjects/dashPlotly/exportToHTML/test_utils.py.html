<html>
<head>
<title>test_utils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_utils.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">weakref</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_less</span><span class="s0">, </span><span class="s1">build_err_msg</span><span class="s0">, </span><span class="s1">raises</span><span class="s0">,</span>
    <span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_warns</span><span class="s0">, </span><span class="s1">assert_no_warnings</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">,</span>
    <span class="s1">assert_approx_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">, </span><span class="s1">assert_array_max_ulp</span><span class="s0">,</span>
    <span class="s1">clear_and_catch_warnings</span><span class="s0">, </span><span class="s1">suppress_warnings</span><span class="s0">, </span><span class="s1">assert_string_equal</span><span class="s0">, </span><span class="s1">assert_</span><span class="s0">,</span>
    <span class="s1">tempdir</span><span class="s0">, </span><span class="s1">temppath</span><span class="s0">, </span><span class="s1">assert_no_gc_cycles</span><span class="s0">, </span><span class="s1">HAS_REFCOUNT</span>
    <span class="s1">)</span>
<span class="s0">from </span><span class="s1">numpy.core.overrides </span><span class="s0">import </span><span class="s1">ARRAY_FUNCTION_ENABLED</span>


<span class="s0">class </span><span class="s1">_GenericTest:</span>

    <span class="s0">def </span><span class="s1">_test_equal(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">_test_not_equal(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s0">with </span><span class="s1">assert_raises(AssertionError):</span>
            <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_array_rank1_eq(self):</span>
        <span class="s2">&quot;&quot;&quot;Test two equal array of rank 1 are found equal.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_array_rank1_noteq(self):</span>
        <span class="s2">&quot;&quot;&quot;Test two different array of rank 1 are found not equal.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

        <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_array_rank2_eq(self):</span>
        <span class="s2">&quot;&quot;&quot;Test two equal array of rank 2 are found equal.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]])</span>
        <span class="s1">b = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]])</span>

        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_array_diffshape(self):</span>
        <span class="s2">&quot;&quot;&quot;Test two arrays with different shapes are found not equal.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">b = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>

        <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_objarray(self):</span>
        <span class="s2">&quot;&quot;&quot;Test object arrays.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_array_likes(self):</span>
        <span class="s1">self._test_equal([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestArrayEqual(_GenericTest):</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self._assert_func = assert_array_equal</span>

    <span class="s0">def </span><span class="s1">test_generic_rank1(self):</span>
        <span class="s2">&quot;&quot;&quot;Test rank 1 array for all dtypes.&quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">foo(t):</span>
            <span class="s1">a = np.empty(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">t)</span>
            <span class="s1">a.fill(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">b = a.copy()</span>
            <span class="s1">c = a.copy()</span>
            <span class="s1">c.fill(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">self._test_not_equal(c</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s4"># Test numeric types and object</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s5">'?bhilqpBHILQPfdgFDG'</span><span class="s1">:</span>
            <span class="s1">foo(t)</span>

        <span class="s4"># Test strings</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[</span><span class="s5">'S1'</span><span class="s0">, </span><span class="s5">'U1'</span><span class="s1">]:</span>
            <span class="s1">foo(t)</span>

    <span class="s0">def </span><span class="s1">test_0_ndim_array(self):</span>
        <span class="s1">x = np.array(</span><span class="s3">473963742225900817127911193656584771</span><span class="s1">)</span>
        <span class="s1">y = np.array(</span><span class="s3">18535119325151578301457182298393896</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">self._assert_func</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">y = x</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">x = np.array(</span><span class="s3">43</span><span class="s1">)</span>
        <span class="s1">y = np.array(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">self._assert_func</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">y = x</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_generic_rank3(self):</span>
        <span class="s2">&quot;&quot;&quot;Test rank 3 array for all dtypes.&quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">foo(t):</span>
            <span class="s1">a = np.empty((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">t)</span>
            <span class="s1">a.fill(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">b = a.copy()</span>
            <span class="s1">c = a.copy()</span>
            <span class="s1">c.fill(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">self._test_not_equal(c</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s4"># Test numeric types and object</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s5">'?bhilqpBHILQPfdgFDG'</span><span class="s1">:</span>
            <span class="s1">foo(t)</span>

        <span class="s4"># Test strings</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[</span><span class="s5">'S1'</span><span class="s0">, </span><span class="s5">'U1'</span><span class="s1">]:</span>
            <span class="s1">foo(t)</span>

    <span class="s0">def </span><span class="s1">test_nan_array(self):</span>
        <span class="s2">&quot;&quot;&quot;Test arrays with nan values in them.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">b = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">c = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">self._test_not_equal(c</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_string_arrays(self):</span>
        <span class="s2">&quot;&quot;&quot;Test two arrays with different shapes are found not equal.&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s5">'floupi'</span><span class="s0">, </span><span class="s5">'floupa'</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s5">'floupi'</span><span class="s0">, </span><span class="s5">'floupa'</span><span class="s1">])</span>

        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">c = np.array([</span><span class="s5">'floupipi'</span><span class="s0">, </span><span class="s5">'floupa'</span><span class="s1">])</span>

        <span class="s1">self._test_not_equal(c</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_recarrays(self):</span>
        <span class="s2">&quot;&quot;&quot;Test record arrays.&quot;&quot;&quot;</span>
        <span class="s1">a = np.empty(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">'floupi'</span><span class="s0">, </span><span class="s1">float)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">'floupa'</span><span class="s0">, </span><span class="s1">float)])</span>
        <span class="s1">a[</span><span class="s5">'floupi'</span><span class="s1">] = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">a[</span><span class="s5">'floupa'</span><span class="s1">] = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">b = a.copy()</span>

        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">c = np.empty(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">'floupipi'</span><span class="s0">, </span><span class="s1">float)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">'floupa'</span><span class="s0">, </span><span class="s1">float)])</span>
        <span class="s1">c[</span><span class="s5">'floupipi'</span><span class="s1">] = a[</span><span class="s5">'floupi'</span><span class="s1">].copy()</span>
        <span class="s1">c[</span><span class="s5">'floupa'</span><span class="s1">] = a[</span><span class="s5">'floupa'</span><span class="s1">].copy()</span>

        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">l = sup.record(FutureWarning</span><span class="s0">, </span><span class="s1">message=</span><span class="s5">&quot;elementwise == &quot;</span><span class="s1">)</span>
            <span class="s1">self._test_not_equal(c</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_equal(len(l)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_masked_nan_inf(self):</span>
        <span class="s4"># Regression test for gh-11121</span>
        <span class="s1">a = np.ma.MaskedArray([</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s0">False, True, False</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s3">3.</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">])</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_equal(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">a = np.ma.MaskedArray([</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s0">True, False, False</span><span class="s1">])</span>
        <span class="s1">b = np.array([np.inf</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">])</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_equal(b</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_subclass_that_overrides_eq(self):</span>
        <span class="s4"># While we cannot guarantee testing functions will always work for</span>
        <span class="s4"># subclasses, the tests should ideally rely only on subclasses having</span>
        <span class="s4"># comparison operators, not on them being able to store booleans</span>
        <span class="s4"># (which, e.g., astropy Quantity cannot usefully do). See gh-8452.</span>
        <span class="s0">class </span><span class="s1">MyArray(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">bool(np.equal(self</span><span class="s0">, </span><span class="s1">other).all())</span>

            <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return not </span><span class="s1">self == other</span>

        <span class="s1">a = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]).view(MyArray)</span>
        <span class="s1">b = np.array([</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]).view(MyArray)</span>
        <span class="s1">assert_(type(a == a)</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s1">assert_(a == a)</span>
        <span class="s1">assert_(a != b)</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_not_equal(b</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s1">@pytest.mark.skipif(</span>
        <span class="s0">not </span><span class="s1">ARRAY_FUNCTION_ENABLED</span><span class="s0">, </span><span class="s1">reason=</span><span class="s5">'requires __array_function__'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_subclass_that_does_not_implement_npall(self):</span>
        <span class="s0">class </span><span class="s1">MyArray(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_function__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s1">a = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]).view(MyArray)</span>
        <span class="s1">b = np.array([</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]).view(MyArray)</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.all(a)</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_not_equal(b</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">class </span><span class="s1">TestBuildErrorMessage:</span>

    <span class="s0">def </span><span class="s1">test_build_err_msg_defaults(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.00001</span><span class="s0">, </span><span class="s3">2.00002</span><span class="s0">, </span><span class="s3">3.00003</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1.00002</span><span class="s0">, </span><span class="s3">2.00003</span><span class="s0">, </span><span class="s3">3.00004</span><span class="s1">])</span>
        <span class="s1">err_msg = </span><span class="s5">'There is a mismatch'</span>

        <span class="s1">a = build_err_msg([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">err_msg)</span>
        <span class="s1">b = (</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">Items are not equal: There is a mismatch</span><span class="s0">\n </span><span class="s5">ACTUAL: array(['</span>
             <span class="s5">'1.00001, 2.00002, 3.00003])</span><span class="s0">\n </span><span class="s5">DESIRED: array([1.00002, '</span>
             <span class="s5">'2.00003, 3.00004])'</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_build_err_msg_no_verbose(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.00001</span><span class="s0">, </span><span class="s3">2.00002</span><span class="s0">, </span><span class="s3">3.00003</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1.00002</span><span class="s0">, </span><span class="s3">2.00003</span><span class="s0">, </span><span class="s3">3.00004</span><span class="s1">])</span>
        <span class="s1">err_msg = </span><span class="s5">'There is a mismatch'</span>

        <span class="s1">a = build_err_msg([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">err_msg</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">b = </span><span class="s5">'</span><span class="s0">\n</span><span class="s5">Items are not equal: There is a mismatch'</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_build_err_msg_custom_names(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.00001</span><span class="s0">, </span><span class="s3">2.00002</span><span class="s0">, </span><span class="s3">3.00003</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1.00002</span><span class="s0">, </span><span class="s3">2.00003</span><span class="s0">, </span><span class="s3">3.00004</span><span class="s1">])</span>
        <span class="s1">err_msg = </span><span class="s5">'There is a mismatch'</span>

        <span class="s1">a = build_err_msg([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">err_msg</span><span class="s0">, </span><span class="s1">names=(</span><span class="s5">'FOO'</span><span class="s0">, </span><span class="s5">'BAR'</span><span class="s1">))</span>
        <span class="s1">b = (</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">Items are not equal: There is a mismatch</span><span class="s0">\n </span><span class="s5">FOO: array(['</span>
             <span class="s5">'1.00001, 2.00002, 3.00003])</span><span class="s0">\n </span><span class="s5">BAR: array([1.00002, 2.00003, '</span>
             <span class="s5">'3.00004])'</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_build_err_msg_custom_precision(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.000000001</span><span class="s0">, </span><span class="s3">2.00002</span><span class="s0">, </span><span class="s3">3.00003</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1.000000002</span><span class="s0">, </span><span class="s3">2.00003</span><span class="s0">, </span><span class="s3">3.00004</span><span class="s1">])</span>
        <span class="s1">err_msg = </span><span class="s5">'There is a mismatch'</span>

        <span class="s1">a = build_err_msg([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">err_msg</span><span class="s0">, </span><span class="s1">precision=</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">b = (</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">Items are not equal: There is a mismatch</span><span class="s0">\n </span><span class="s5">ACTUAL: array(['</span>
             <span class="s5">'1.000000001, 2.00002    , 3.00003    ])</span><span class="s0">\n </span><span class="s5">DESIRED: array(['</span>
             <span class="s5">'1.000000002, 2.00003    , 3.00004    ])'</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s0">class </span><span class="s1">TestEqual(TestArrayEqual):</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self._assert_func = assert_equal</span>

    <span class="s0">def </span><span class="s1">test_nan_items(self):</span>
        <span class="s1">self._assert_func(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">self._assert_func([np.nan]</span><span class="s0">, </span><span class="s1">[np.nan])</span>
        <span class="s1">self._test_not_equal(np.nan</span><span class="s0">, </span><span class="s1">[np.nan])</span>
        <span class="s1">self._test_not_equal(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_inf_items(self):</span>
        <span class="s1">self._assert_func(np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">self._assert_func([np.inf]</span><span class="s0">, </span><span class="s1">[np.inf])</span>
        <span class="s1">self._test_not_equal(np.inf</span><span class="s0">, </span><span class="s1">[np.inf])</span>

    <span class="s0">def </span><span class="s1">test_datetime(self):</span>
        <span class="s1">self._test_equal(</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self._test_equal(</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;m&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s4"># gh-10081</span>
        <span class="s1">self._test_not_equal(</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-02&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self._test_not_equal(</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-02&quot;</span><span class="s0">, </span><span class="s5">&quot;m&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_nat_items(self):</span>
        <span class="s4"># not a datetime</span>
        <span class="s1">nadt_no_unit = np.datetime64(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">nadt_s = np.datetime64(</span><span class="s5">&quot;NaT&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">nadt_d = np.datetime64(</span><span class="s5">&quot;NaT&quot;</span><span class="s0">, </span><span class="s5">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s4"># not a timedelta</span>
        <span class="s1">natd_no_unit = np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">natd_s = np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">natd_d = np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s0">, </span><span class="s5">&quot;ns&quot;</span><span class="s1">)</span>

        <span class="s1">dts = [nadt_no_unit</span><span class="s0">, </span><span class="s1">nadt_s</span><span class="s0">, </span><span class="s1">nadt_d]</span>
        <span class="s1">tds = [natd_no_unit</span><span class="s0">, </span><span class="s1">natd_s</span><span class="s0">, </span><span class="s1">natd_d]</span>
        <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">itertools.product(dts</span><span class="s0">, </span><span class="s1">dts):</span>
            <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">self._assert_func([a]</span><span class="s0">, </span><span class="s1">[b])</span>
            <span class="s1">self._test_not_equal([a]</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">itertools.product(tds</span><span class="s0">, </span><span class="s1">tds):</span>
            <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">self._assert_func([a]</span><span class="s0">, </span><span class="s1">[b])</span>
            <span class="s1">self._test_not_equal([a]</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">itertools.product(tds</span><span class="s0">, </span><span class="s1">dts):</span>
            <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">[b])</span>
            <span class="s1">self._test_not_equal([a]</span><span class="s0">, </span><span class="s1">[b])</span>
            <span class="s1">self._test_not_equal([a]</span><span class="s0">, </span><span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">))</span>
            <span class="s1">self._test_not_equal([b]</span><span class="s0">, </span><span class="s1">np.datetime64(</span><span class="s5">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">))</span>
            <span class="s1">self._test_not_equal([a]</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">123</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">))</span>
            <span class="s1">self._test_not_equal([b]</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">123</span><span class="s0">, </span><span class="s5">&quot;s&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_non_numeric(self):</span>
        <span class="s1">self._assert_func(</span><span class="s5">'ab'</span><span class="s0">, </span><span class="s5">'ab'</span><span class="s1">)</span>
        <span class="s1">self._test_not_equal(</span><span class="s5">'ab'</span><span class="s0">, </span><span class="s5">'abb'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex_item(self):</span>
        <span class="s1">self._assert_func(complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">self._assert_func(complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan))</span>
        <span class="s1">self._test_not_equal(complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">self._test_not_equal(complex(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan))</span>
        <span class="s1">self._test_not_equal(complex(np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_negative_zero(self):</span>
        <span class="s1">self._test_not_equal(np.PZERO</span><span class="s0">, </span><span class="s1">np.NZERO)</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s1">x = np.array([complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan)])</span>
        <span class="s1">y = np.array([complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)])</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">self._test_not_equal(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_object(self):</span>
        <span class="s4">#gh-12942</span>
        <span class="s0">import </span><span class="s1">datetime</span>
        <span class="s1">a = np.array([datetime.datetime(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">datetime.datetime(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)])</span>
        <span class="s1">self._test_not_equal(a</span><span class="s0">, </span><span class="s1">a[::-</span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestArrayAlmostEqual(_GenericTest):</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self._assert_func = assert_array_almost_equal</span>

    <span class="s0">def </span><span class="s1">test_closeness(self):</span>
        <span class="s4"># Note that in the course of time we ended up with</span>
        <span class="s4">#     `abs(x - y) &lt; 1.5 * 10**(-decimal)`</span>
        <span class="s4"># instead of the previously documented</span>
        <span class="s4">#     `abs(x - y) &lt; 0.5 * 10**(-decimal)`</span>
        <span class="s4"># so this check serves to preserve the wrongness.</span>

        <span class="s4"># test scalars</span>
        <span class="s1">self._assert_func(</span><span class="s3">1.499999</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: self._assert_func(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">))</span>

        <span class="s4"># test arrays</span>
        <span class="s1">self._assert_func([</span><span class="s3">1.499999</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: self._assert_func([</span><span class="s3">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1234.2222</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1234.2223</span><span class="s1">])</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                <span class="s0">lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_nan(self):</span>
        <span class="s1">anan = np.array([np.nan])</span>
        <span class="s1">aone = np.array([</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">ainf = np.array([np.inf])</span>
        <span class="s1">self._assert_func(anan</span><span class="s0">, </span><span class="s1">anan)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                <span class="s0">lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">aone))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                <span class="s0">lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                <span class="s0">lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">anan))</span>

    <span class="s0">def </span><span class="s1">test_inf(self):</span>
        <span class="s1">a = np.array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]])</span>
        <span class="s1">b = a.copy()</span>
        <span class="s1">a[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = np.inf</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                <span class="s0">lambda</span><span class="s1">: self._assert_func(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s1">b[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = -np.inf</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                <span class="s0">lambda</span><span class="s1">: self._assert_func(a</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s0">def </span><span class="s1">test_subclass(self):</span>
        <span class="s1">a = np.array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]])</span>
        <span class="s1">b = np.ma.masked_array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]]</span><span class="s0">,</span>
                               <span class="s1">[[</span><span class="s0">False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]])</span>
        <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._assert_func(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">self._assert_func(b</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s4"># Test fully masked as well (see gh-11123).</span>
        <span class="s1">a = np.ma.MaskedArray(</span><span class="s3">3.5</span><span class="s0">, </span><span class="s1">mask=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">])</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_equal(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">a = np.ma.masked</span>
        <span class="s1">b = np.array([</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">])</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_equal(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">a = np.ma.MaskedArray([</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s0">True, True, True</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">])</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_equal(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">a = np.ma.MaskedArray([</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">6.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s0">True, True, True</span><span class="s1">])</span>
        <span class="s1">b = np.array(</span><span class="s3">1.</span><span class="s1">)</span>
        <span class="s1">self._test_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">self._test_equal(b</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_subclass_that_cannot_be_bool(self):</span>
        <span class="s4"># While we cannot guarantee testing functions will always work for</span>
        <span class="s4"># subclasses, the tests should ideally rely only on subclasses having</span>
        <span class="s4"># comparison operators, not on them being able to store booleans</span>
        <span class="s4"># (which, e.g., astropy Quantity cannot usefully do). See gh-8452.</span>
        <span class="s0">class </span><span class="s1">MyArray(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">super().__eq__(other).view(np.ndarray)</span>

            <span class="s0">def </span><span class="s1">__lt__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">super().__lt__(other).view(np.ndarray)</span>

            <span class="s0">def </span><span class="s1">all(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span>

        <span class="s1">a = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]).view(MyArray)</span>
        <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">class </span><span class="s1">TestAlmostEqual(_GenericTest):</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self._assert_func = assert_almost_equal</span>

    <span class="s0">def </span><span class="s1">test_closeness(self):</span>
        <span class="s4"># Note that in the course of time we ended up with</span>
        <span class="s4">#     `abs(x - y) &lt; 1.5 * 10**(-decimal)`</span>
        <span class="s4"># instead of the previously documented</span>
        <span class="s4">#     `abs(x - y) &lt; 0.5 * 10**(-decimal)`</span>
        <span class="s4"># so this check serves to preserve the wrongness.</span>

        <span class="s4"># test scalars</span>
        <span class="s1">self._assert_func(</span><span class="s3">1.499999</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">))</span>

        <span class="s4"># test arrays</span>
        <span class="s1">self._assert_func([</span><span class="s3">1.499999</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func([</span><span class="s3">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_nan_item(self):</span>
        <span class="s1">self._assert_func(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(np.nan</span><span class="s0">, </span><span class="s1">np.inf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(np.inf</span><span class="s0">, </span><span class="s1">np.nan))</span>

    <span class="s0">def </span><span class="s1">test_inf_item(self):</span>
        <span class="s1">self._assert_func(np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">self._assert_func(-np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(np.inf</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(-np.inf</span><span class="s0">, </span><span class="s1">np.inf))</span>

    <span class="s0">def </span><span class="s1">test_simple_item(self):</span>
        <span class="s1">self._test_not_equal(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex_item(self):</span>
        <span class="s1">self._assert_func(complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">self._assert_func(complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan))</span>
        <span class="s1">self._assert_func(complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan))</span>
        <span class="s1">self._test_not_equal(complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">self._test_not_equal(complex(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan))</span>
        <span class="s1">self._test_not_equal(complex(np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s1">x = np.array([complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan)])</span>
        <span class="s1">z = np.array([complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)])</span>
        <span class="s1">y = np.array([complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)])</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">self._test_not_equal(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">self._test_not_equal(x</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s0">def </span><span class="s1">test_error_message(self):</span>
        <span class="s2">&quot;&quot;&quot;Check the message is formatted correctly for the decimal value. 
           Also check the message when input includes inf or nan (gh12200)&quot;&quot;&quot;</span>
        <span class="s1">x = np.array([</span><span class="s3">1.00000000001</span><span class="s0">, </span><span class="s3">2.00000000002</span><span class="s0">, </span><span class="s3">3.00003</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1.00000000002</span><span class="s0">, </span><span class="s3">2.00000000003</span><span class="s0">, </span><span class="s3">3.00004</span><span class="s1">])</span>

        <span class="s4"># Test with a different amount of decimal digits</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">12</span><span class="s1">)</span>
        <span class="s1">msgs = str(exc_info.value).split(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Mismatched elements: 3 / 3 (100%)'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max absolute difference: 1.e-05'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max relative difference: 3.33328889e-06'</span><span class="s1">)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">msgs[</span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s5">' x: array([1.00000000001, 2.00000000002, 3.00003      ])'</span><span class="s1">)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">msgs[</span><span class="s3">7</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s5">' y: array([1.00000000002, 2.00000000003, 3.00004      ])'</span><span class="s1">)</span>

        <span class="s4"># With the default value of decimal digits, only the 3rd element</span>
        <span class="s4"># differs. Note that we only check for the formatting of the arrays</span>
        <span class="s4"># themselves.</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">msgs = str(exc_info.value).split(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Mismatched elements: 1 / 3 (33.3%)'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max absolute difference: 1.e-05'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max relative difference: 3.33328889e-06'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s5">' x: array([1.     , 2.     , 3.00003])'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s5">' y: array([1.     , 2.     , 3.00004])'</span><span class="s1">)</span>

        <span class="s4"># Check the error message when input includes inf</span>
        <span class="s1">x = np.array([np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">y = np.array([np.inf</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">msgs = str(exc_info.value).split(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Mismatched elements: 1 / 2 (50%)'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max absolute difference: 1.'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max relative difference: 1.'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s5">' x: array([inf,  0.])'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s5">' y: array([inf,  1.])'</span><span class="s1">)</span>

        <span class="s4"># Check the error message when dividing by zero</span>
        <span class="s1">x = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">msgs = str(exc_info.value).split(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Mismatched elements: 2 / 2 (100%)'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max absolute difference: 2'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max relative difference: inf'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_error_message_2(self):</span>
        <span class="s2">&quot;&quot;&quot;Check the message is formatted correctly when either x or y is a scalar.&quot;&quot;&quot;</span>
        <span class="s1">x = </span><span class="s3">2</span>
        <span class="s1">y = np.ones(</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">msgs = str(exc_info.value).split(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Mismatched elements: 20 / 20 (100%)'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max absolute difference: 1.'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max relative difference: 1.'</span><span class="s1">)</span>

        <span class="s1">y = </span><span class="s3">2</span>
        <span class="s1">x = np.ones(</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">msgs = str(exc_info.value).split(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Mismatched elements: 20 / 20 (100%)'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max absolute difference: 1.'</span><span class="s1">)</span>
        <span class="s1">assert_equal(msgs[</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Max relative difference: 0.5'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_subclass_that_cannot_be_bool(self):</span>
        <span class="s4"># While we cannot guarantee testing functions will always work for</span>
        <span class="s4"># subclasses, the tests should ideally rely only on subclasses having</span>
        <span class="s4"># comparison operators, not on them being able to store booleans</span>
        <span class="s4"># (which, e.g., astropy Quantity cannot usefully do). See gh-8452.</span>
        <span class="s0">class </span><span class="s1">MyArray(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">super().__eq__(other).view(np.ndarray)</span>

            <span class="s0">def </span><span class="s1">__lt__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">super().__lt__(other).view(np.ndarray)</span>

            <span class="s0">def </span><span class="s1">all(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span>

        <span class="s1">a = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]).view(MyArray)</span>
        <span class="s1">self._assert_func(a</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">class </span><span class="s1">TestApproxEqual:</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self._assert_func = assert_approx_equal</span>

    <span class="s0">def </span><span class="s1">test_simple_0d_arrays(self):</span>
        <span class="s1">x = np.array(</span><span class="s3">1234.22</span><span class="s1">)</span>
        <span class="s1">y = np.array(</span><span class="s3">1234.23</span><span class="s1">)</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">7</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_simple_items(self):</span>
        <span class="s1">x = </span><span class="s3">1234.22</span>
        <span class="s1">y = </span><span class="s3">1234.23</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">significant=</span><span class="s3">7</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_nan_array(self):</span>
        <span class="s1">anan = np.array(np.nan)</span>
        <span class="s1">aone = np.array(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">ainf = np.array(np.inf)</span>
        <span class="s1">self._assert_func(anan</span><span class="s0">, </span><span class="s1">anan)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">aone))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">anan))</span>

    <span class="s0">def </span><span class="s1">test_nan_items(self):</span>
        <span class="s1">anan = np.array(np.nan)</span>
        <span class="s1">aone = np.array(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">ainf = np.array(np.inf)</span>
        <span class="s1">self._assert_func(anan</span><span class="s0">, </span><span class="s1">anan)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">aone))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">anan))</span>


<span class="s0">class </span><span class="s1">TestArrayAssertLess:</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self._assert_func = assert_array_less</span>

    <span class="s0">def </span><span class="s1">test_simple_arrays(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2.2</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">2.3</span><span class="s1">])</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y = np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.3</span><span class="s1">])</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

    <span class="s0">def </span><span class="s1">test_rank2(self):</span>
        <span class="s1">x = np.array([[</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.3</span><span class="s0">, </span><span class="s3">4.4</span><span class="s1">]])</span>
        <span class="s1">y = np.array([[</span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">2.3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.4</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">]])</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y = np.array([[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.4</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">]])</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

    <span class="s0">def </span><span class="s1">test_rank3(self):</span>
        <span class="s1">x = np.ones(shape=(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">y = np.ones(shape=(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))+</span><span class="s3">1</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

    <span class="s0">def </span><span class="s1">test_simple_items(self):</span>
        <span class="s1">x = </span><span class="s3">1.1</span>
        <span class="s1">y = </span><span class="s3">2.2</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y = np.array([</span><span class="s3">2.2</span><span class="s0">, </span><span class="s3">3.3</span><span class="s1">])</span>

        <span class="s1">self._assert_func(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(y</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y = np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">3.3</span><span class="s1">])</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">test_nan_noncompare(self):</span>
        <span class="s1">anan = np.array(np.nan)</span>
        <span class="s1">aone = np.array(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">ainf = np.array(np.inf)</span>
        <span class="s1">self._assert_func(anan</span><span class="s0">, </span><span class="s1">anan)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(aone</span><span class="s0">, </span><span class="s1">anan))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">aone))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">anan))</span>

    <span class="s0">def </span><span class="s1">test_nan_noncompare_array(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2.2</span><span class="s0">, </span><span class="s3">3.3</span><span class="s1">])</span>
        <span class="s1">anan = np.array(np.nan)</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">anan))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">x = np.array([</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2.2</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">anan))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(anan</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y = np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">self._assert_func(y</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s0">def </span><span class="s1">test_inf_compare(self):</span>
        <span class="s1">aone = np.array(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">ainf = np.array(np.inf)</span>

        <span class="s1">self._assert_func(aone</span><span class="s0">, </span><span class="s1">ainf)</span>
        <span class="s1">self._assert_func(-ainf</span><span class="s0">, </span><span class="s1">aone)</span>
        <span class="s1">self._assert_func(-ainf</span><span class="s0">, </span><span class="s1">ainf)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">aone))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(aone</span><span class="s0">, </span><span class="s1">-ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">-ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(-ainf</span><span class="s0">, </span><span class="s1">-ainf))</span>

    <span class="s0">def </span><span class="s1">test_inf_compare_array(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2.2</span><span class="s0">, </span><span class="s1">np.inf])</span>
        <span class="s1">ainf = np.array(np.inf)</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(ainf</span><span class="s0">, </span><span class="s1">x))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(x</span><span class="s0">, </span><span class="s1">-ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(-x</span><span class="s0">, </span><span class="s1">-ainf))</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, lambda</span><span class="s1">: self._assert_func(-ainf</span><span class="s0">, </span><span class="s1">-x))</span>
        <span class="s1">self._assert_func(-ainf</span><span class="s0">, </span><span class="s1">x)</span>


<span class="s1">@pytest.mark.skip(reason=</span><span class="s5">&quot;The raises decorator depends on Nose&quot;</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestRaises:</span>

    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s0">class </span><span class="s1">MyException(Exception):</span>
            <span class="s0">pass</span>

        <span class="s1">self.e = MyException</span>

    <span class="s0">def </span><span class="s1">raises_exception(self</span><span class="s0">, </span><span class="s1">e):</span>
        <span class="s0">raise </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">does_not_raise_exception(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_correct_catch(self):</span>
        <span class="s1">raises(self.e)(self.raises_exception)(self.e)  </span><span class="s4"># raises?</span>

    <span class="s0">def </span><span class="s1">test_wrong_exception(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">raises(self.e)(self.raises_exception)(RuntimeError)  </span><span class="s4"># raises?</span>
        <span class="s0">except </span><span class="s1">RuntimeError:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s5">&quot;should have caught RuntimeError&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_catch_no_raise(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">raises(self.e)(self.does_not_raise_exception)()  </span><span class="s4"># raises?</span>
        <span class="s0">except </span><span class="s1">AssertionError:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s5">&quot;should have raised an AssertionError&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestWarns:</span>

    <span class="s0">def </span><span class="s1">test_warn(self):</span>
        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;yo&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s3">3</span>

        <span class="s1">before_filters = sys.modules[</span><span class="s5">'warnings'</span><span class="s1">].filters[:]</span>
        <span class="s1">assert_equal(assert_warns(UserWarning</span><span class="s0">, </span><span class="s1">f)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">after_filters = sys.modules[</span><span class="s5">'warnings'</span><span class="s1">].filters</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_no_warnings</span><span class="s0">, </span><span class="s1">f)</span>
        <span class="s1">assert_equal(assert_no_warnings(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s4"># Check that the warnings state is unchanged</span>
        <span class="s1">assert_equal(before_filters</span><span class="s0">, </span><span class="s1">after_filters</span><span class="s0">,</span>
                     <span class="s5">&quot;assert_warns does not preserver warnings state&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_context_manager(self):</span>

        <span class="s1">before_filters = sys.modules[</span><span class="s5">'warnings'</span><span class="s1">].filters[:]</span>
        <span class="s0">with </span><span class="s1">assert_warns(UserWarning):</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;yo&quot;</span><span class="s1">)</span>
        <span class="s1">after_filters = sys.modules[</span><span class="s5">'warnings'</span><span class="s1">].filters</span>

        <span class="s0">def </span><span class="s1">no_warnings():</span>
            <span class="s0">with </span><span class="s1">assert_no_warnings():</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;yo&quot;</span><span class="s1">)</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">no_warnings)</span>
        <span class="s1">assert_equal(before_filters</span><span class="s0">, </span><span class="s1">after_filters</span><span class="s0">,</span>
                     <span class="s5">&quot;assert_warns does not preserver warnings state&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_warn_wrong_warning(self):</span>
        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;yo&quot;</span><span class="s0">, </span><span class="s1">DeprecationWarning)</span>

        <span class="s1">failed = </span><span class="s0">False</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s0">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s4"># Should raise a DeprecationWarning</span>
                <span class="s1">assert_warns(UserWarning</span><span class="s0">, </span><span class="s1">f)</span>
                <span class="s1">failed = </span><span class="s0">True</span>
            <span class="s0">except </span><span class="s1">DeprecationWarning:</span>
                <span class="s0">pass</span>

        <span class="s0">if </span><span class="s1">failed:</span>
            <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s5">&quot;wrong warning caught by assert_warn&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestAssertAllclose:</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">x = </span><span class="s3">1e-3</span>
        <span class="s1">y = </span><span class="s3">1e-9</span>

        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">a = np.array([x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y])</span>
        <span class="s1">b = np.array([x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x])</span>

        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">b[-</span><span class="s3">1</span><span class="s1">] = y * (</span><span class="s3">1 </span><span class="s1">+ </span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-9</span><span class="s1">)</span>

        <span class="s1">assert_allclose(</span><span class="s3">6</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">0.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_min_int(self):</span>
        <span class="s1">a = np.array([np.iinfo(np.int_).min]</span><span class="s0">, </span><span class="s1">dtype=np.int_)</span>
        <span class="s4"># Should not raise:</span>
        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_report_fail_percentage(self):</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">msg = str(exc_info.value)</span>
        <span class="s1">assert_(</span><span class="s5">'Mismatched elements: 1 / 4 (25%)</span><span class="s0">\n</span><span class="s5">'</span>
                <span class="s5">'Max absolute difference: 1</span><span class="s0">\n</span><span class="s5">'</span>
                <span class="s5">'Max relative difference: 0.5' </span><span class="s0">in </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_equal_nan(self):</span>
        <span class="s1">a = np.array([np.nan])</span>
        <span class="s1">b = np.array([np.nan])</span>
        <span class="s4"># Should not raise:</span>
        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">equal_nan=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_not_equal_nan(self):</span>
        <span class="s1">a = np.array([np.nan])</span>
        <span class="s1">b = np.array([np.nan])</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">equal_nan=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_equal_nan_default(self):</span>
        <span class="s4"># Make sure equal_nan default behavior remains unchanged. (All</span>
        <span class="s4"># of these functions use assert_array_compare under the hood.)</span>
        <span class="s4"># None of these should raise.</span>
        <span class="s1">a = np.array([np.nan])</span>
        <span class="s1">b = np.array([np.nan])</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_almost_equal(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_less(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_report_max_relative_error(self):</span>
        <span class="s1">a = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">msg = str(exc_info.value)</span>
        <span class="s1">assert_(</span><span class="s5">'Max relative difference: 0.5' </span><span class="s0">in </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_timedelta(self):</span>
        <span class="s4"># see gh-18286</span>
        <span class="s1">a = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s5">&quot;NaT&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">class </span><span class="s1">TestArrayAlmostEqualNulp:</span>

    <span class="s0">def </span><span class="s1">test_float64_pass(self):</span>
        <span class="s4"># The number of units of least precision</span>
        <span class="s4"># In this case, use a few places above the lowest level (ie nulp=1)</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>

        <span class="s4"># Addition</span>
        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s4"># Subtraction</span>
        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_float64_fail(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_float64_ignore_nan(self):</span>
        <span class="s4"># Ignore ULP differences between various NAN's</span>
        <span class="s4"># Note that MIPS may reverse quiet and signaling nans</span>
        <span class="s4"># so we use the builtin version as a base.</span>
        <span class="s1">offset = np.uint64(</span><span class="s3">0xffffffff</span><span class="s1">)</span>
        <span class="s1">nan1_i64 = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=np.float64).view(np.uint64)</span>
        <span class="s1">nan2_i64 = nan1_i64 ^ offset  </span><span class="s4"># nan payload on MIPS is all ones.</span>
        <span class="s1">nan1_f64 = nan1_i64.view(np.float64)</span>
        <span class="s1">nan2_f64 = nan2_i64.view(np.float64)</span>
        <span class="s1">assert_array_max_ulp(nan1_f64</span><span class="s0">, </span><span class="s1">nan2_f64</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_float32_pass(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_float32_fail(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_float32_ignore_nan(self):</span>
        <span class="s4"># Ignore ULP differences between various NAN's</span>
        <span class="s4"># Note that MIPS may reverse quiet and signaling nans</span>
        <span class="s4"># so we use the builtin version as a base.</span>
        <span class="s1">offset = np.uint32(</span><span class="s3">0xffff</span><span class="s1">)</span>
        <span class="s1">nan1_i32 = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=np.float32).view(np.uint32)</span>
        <span class="s1">nan2_i32 = nan1_i32 ^ offset  </span><span class="s4"># nan payload on MIPS is all ones.</span>
        <span class="s1">nan1_f32 = nan1_i32.view(np.float32)</span>
        <span class="s1">nan2_f32 = nan2_i32.view(np.float32)</span>
        <span class="s1">assert_array_max_ulp(nan1_f32</span><span class="s0">, </span><span class="s1">nan2_f32</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_float16_pass(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=np.float16)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_float16_fail(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=np.float16)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_float16_ignore_nan(self):</span>
        <span class="s4"># Ignore ULP differences between various NAN's</span>
        <span class="s4"># Note that MIPS may reverse quiet and signaling nans</span>
        <span class="s4"># so we use the builtin version as a base.</span>
        <span class="s1">offset = np.uint16(</span><span class="s3">0xff</span><span class="s1">)</span>
        <span class="s1">nan1_i16 = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=np.float16).view(np.uint16)</span>
        <span class="s1">nan2_i16 = nan1_i16 ^ offset  </span><span class="s4"># nan payload on MIPS is all ones.</span>
        <span class="s1">nan1_f16 = nan1_i16.view(np.float16)</span>
        <span class="s1">nan2_f16 = nan2_i16.view(np.float16)</span>
        <span class="s1">assert_array_max_ulp(nan1_f16</span><span class="s0">, </span><span class="s1">nan2_f16</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex128_pass(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">xi = x + x*</span><span class="s3">1j</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s4"># The test condition needs to be at least a factor of sqrt(2) smaller</span>
        <span class="s4"># because the real and imaginary parts both change</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">4.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">4.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_complex128_fail(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">xi = x + x*</span><span class="s3">1j</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s4"># The test condition needs to be at least a factor of sqrt(2) smaller</span>
        <span class="s4"># because the real and imaginary parts both change</span>
        <span class="s1">y = x + x*eps*nulp</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">y = x - x*epsneg*nulp</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_complex64_pass(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">xi = x + x*</span><span class="s3">1j</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">y = x + x*eps*nulp/</span><span class="s3">4.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">2.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">y = x - x*epsneg*nulp/</span><span class="s3">4.</span>
        <span class="s1">assert_array_almost_equal_nulp(xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

    <span class="s0">def </span><span class="s1">test_complex64_fail(self):</span>
        <span class="s1">nulp = </span><span class="s3">5</span>
        <span class="s1">x = np.linspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">x = </span><span class="s3">10</span><span class="s1">**x</span>
        <span class="s1">x = np.r_[-x</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">xi = x + x*</span><span class="s3">1j</span>

        <span class="s1">eps = np.finfo(x.dtype).eps</span>
        <span class="s1">y = x + x*eps*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">y = x + x*eps*nulp</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>

        <span class="s1">epsneg = np.finfo(x.dtype).epsneg</span>
        <span class="s1">y = x - x*epsneg*nulp*</span><span class="s3">2.</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">x + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + x*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>
        <span class="s1">y = x - x*epsneg*nulp</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span><span class="s0">,</span>
                      <span class="s1">xi</span><span class="s0">, </span><span class="s1">y + y*</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">nulp)</span>


<span class="s0">class </span><span class="s1">TestULP:</span>

    <span class="s0">def </span><span class="s1">test_equal(self):</span>
        <span class="s1">x = np.random.randn(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">assert_array_max_ulp(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_single(self):</span>
        <span class="s4"># Generate 1 + small deviation, check that adding eps gives a few UNL</span>
        <span class="s1">x = np.ones(</span><span class="s3">10</span><span class="s1">).astype(np.float32)</span>
        <span class="s1">x += </span><span class="s3">0.01 </span><span class="s1">* np.random.randn(</span><span class="s3">10</span><span class="s1">).astype(np.float32)</span>
        <span class="s1">eps = np.finfo(np.float32).eps</span>
        <span class="s1">assert_array_max_ulp(x</span><span class="s0">, </span><span class="s1">x+eps</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">20</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_double(self):</span>
        <span class="s4"># Generate 1 + small deviation, check that adding eps gives a few UNL</span>
        <span class="s1">x = np.ones(</span><span class="s3">10</span><span class="s1">).astype(np.float64)</span>
        <span class="s1">x += </span><span class="s3">0.01 </span><span class="s1">* np.random.randn(</span><span class="s3">10</span><span class="s1">).astype(np.float64)</span>
        <span class="s1">eps = np.finfo(np.float64).eps</span>
        <span class="s1">assert_array_max_ulp(x</span><span class="s0">, </span><span class="s1">x+eps</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">200</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_inf(self):</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64]:</span>
            <span class="s1">inf = np.array([np.inf]).astype(dt)</span>
            <span class="s1">big = np.array([np.finfo(dt).max])</span>
            <span class="s1">assert_array_max_ulp(inf</span><span class="s0">, </span><span class="s1">big</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">200</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_nan(self):</span>
        <span class="s4"># Test that nan is 'far' from small, tiny, inf, max and min</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64]:</span>
            <span class="s0">if </span><span class="s1">dt == np.float32:</span>
                <span class="s1">maxulp = </span><span class="s3">1e6</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">maxulp = </span><span class="s3">1e12</span>
            <span class="s1">inf = np.array([np.inf]).astype(dt)</span>
            <span class="s1">nan = np.array([np.nan]).astype(dt)</span>
            <span class="s1">big = np.array([np.finfo(dt).max])</span>
            <span class="s1">tiny = np.array([np.finfo(dt).tiny])</span>
            <span class="s1">zero = np.array([np.PZERO]).astype(dt)</span>
            <span class="s1">nzero = np.array([np.NZERO]).astype(dt)</span>
            <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: assert_array_max_ulp(nan</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">,</span>
                          <span class="s1">maxulp=maxulp))</span>
            <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: assert_array_max_ulp(nan</span><span class="s0">, </span><span class="s1">big</span><span class="s0">,</span>
                          <span class="s1">maxulp=maxulp))</span>
            <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: assert_array_max_ulp(nan</span><span class="s0">, </span><span class="s1">tiny</span><span class="s0">,</span>
                          <span class="s1">maxulp=maxulp))</span>
            <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: assert_array_max_ulp(nan</span><span class="s0">, </span><span class="s1">zero</span><span class="s0">,</span>
                          <span class="s1">maxulp=maxulp))</span>
            <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                          <span class="s0">lambda</span><span class="s1">: assert_array_max_ulp(nan</span><span class="s0">, </span><span class="s1">nzero</span><span class="s0">,</span>
                          <span class="s1">maxulp=maxulp))</span>


<span class="s0">class </span><span class="s1">TestStringEqual:</span>
    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">assert_string_equal(</span><span class="s5">&quot;hello&quot;</span><span class="s0">, </span><span class="s5">&quot;hello&quot;</span><span class="s1">)</span>
        <span class="s1">assert_string_equal(</span><span class="s5">&quot;hello</span><span class="s0">\n</span><span class="s5">multiline&quot;</span><span class="s0">, </span><span class="s5">&quot;hello</span><span class="s0">\n</span><span class="s5">multiline&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s1">assert_string_equal(</span><span class="s5">&quot;foo</span><span class="s0">\n</span><span class="s5">bar&quot;</span><span class="s0">, </span><span class="s5">&quot;hello</span><span class="s0">\n</span><span class="s5">bar&quot;</span><span class="s1">)</span>
        <span class="s1">msg = str(exc_info.value)</span>
        <span class="s1">assert_equal(msg</span><span class="s0">, </span><span class="s5">&quot;Differences in strings:</span><span class="s0">\n</span><span class="s5">- foo</span><span class="s0">\n</span><span class="s5">+ hello&quot;</span><span class="s1">)</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: assert_string_equal(</span><span class="s5">&quot;foo&quot;</span><span class="s0">, </span><span class="s5">&quot;hello&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_regex(self):</span>
        <span class="s1">assert_string_equal(</span><span class="s5">&quot;a+*b&quot;</span><span class="s0">, </span><span class="s5">&quot;a+*b&quot;</span><span class="s1">)</span>

        <span class="s1">assert_raises(AssertionError</span><span class="s0">,</span>
                      <span class="s0">lambda</span><span class="s1">: assert_string_equal(</span><span class="s5">&quot;aaa&quot;</span><span class="s0">, </span><span class="s5">&quot;a+b&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">assert_warn_len_equal(mod</span><span class="s0">, </span><span class="s1">n_in_context</span><span class="s0">, </span><span class="s1">py34=</span><span class="s0">None, </span><span class="s1">py37=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">mod_warns = mod.__warningregistry__</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s4"># the lack of a __warningregistry__</span>
        <span class="s4"># attribute means that no warning has</span>
        <span class="s4"># occurred; this can be triggered in</span>
        <span class="s4"># a parallel test scenario, while in</span>
        <span class="s4"># a serial test scenario an initial</span>
        <span class="s4"># warning (and therefore the attribute)</span>
        <span class="s4"># are always created first</span>
        <span class="s1">mod_warns = {}</span>

    <span class="s1">num_warns = len(mod_warns)</span>
    <span class="s4"># Python 3.4 appears to clear any pre-existing warnings of the same type,</span>
    <span class="s4"># when raising warnings inside a catch_warnings block. So, there is a</span>
    <span class="s4"># warning generated by the tests within the context manager, but no</span>
    <span class="s4"># previous warnings.</span>
    <span class="s0">if </span><span class="s5">'version' </span><span class="s0">in </span><span class="s1">mod_warns:</span>
        <span class="s4"># Python 3 adds a 'version' entry to the registry,</span>
        <span class="s4"># do not count it.</span>
        <span class="s1">num_warns -= </span><span class="s3">1</span>

        <span class="s4"># Behavior of warnings is Python version dependent. Adjust the</span>
        <span class="s4"># expected result to compensate. In particular, Python 3.7 does</span>
        <span class="s4"># not make an entry for ignored warnings.</span>
        <span class="s0">if </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">py37 </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">n_in_context = py37</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">py34 </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">n_in_context = py34</span>
    <span class="s1">assert_equal(num_warns</span><span class="s0">, </span><span class="s1">n_in_context)</span>

<span class="s0">def </span><span class="s1">test_warn_len_equal_call_scenarios():</span>
    <span class="s4"># assert_warn_len_equal is called under</span>
    <span class="s4"># varying circumstances depending on serial</span>
    <span class="s4"># vs. parallel test scenarios; this test</span>
    <span class="s4"># simply aims to probe both code paths and</span>
    <span class="s4"># check that no assertion is uncaught</span>

    <span class="s4"># parallel scenario -- no warning issued yet</span>
    <span class="s0">class </span><span class="s1">mod:</span>
        <span class="s0">pass</span>

    <span class="s1">mod_inst = mod()</span>

    <span class="s1">assert_warn_len_equal(mod=mod_inst</span><span class="s0">,</span>
                          <span class="s1">n_in_context=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s4"># serial test scenario -- the __warningregistry__</span>
    <span class="s4"># attribute should be present</span>
    <span class="s0">class </span><span class="s1">mod:</span>
        <span class="s0">def </span><span class="s1">__init__(self):</span>
            <span class="s1">self.__warningregistry__ = {</span><span class="s5">'warning1'</span><span class="s1">:</span><span class="s3">1</span><span class="s0">,</span>
                                        <span class="s5">'warning2'</span><span class="s1">:</span><span class="s3">2</span><span class="s1">}</span>

    <span class="s1">mod_inst = mod()</span>
    <span class="s1">assert_warn_len_equal(mod=mod_inst</span><span class="s0">,</span>
                          <span class="s1">n_in_context=</span><span class="s3">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get_fresh_mod():</span>
    <span class="s4"># Get this module, with warning registry empty</span>
    <span class="s1">my_mod = sys.modules[__name__]</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">my_mod.__warningregistry__.clear()</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s4"># will not have a __warningregistry__ unless warning has been</span>
        <span class="s4"># raised in the module at some point</span>
        <span class="s0">pass</span>
    <span class="s0">return </span><span class="s1">my_mod</span>


<span class="s0">def </span><span class="s1">test_clear_and_catch_warnings():</span>
    <span class="s4"># Initial state of module, no warnings</span>
    <span class="s1">my_mod = _get_fresh_mod()</span>
    <span class="s1">assert_equal(getattr(my_mod</span><span class="s0">, </span><span class="s5">'__warningregistry__'</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">{})</span>
    <span class="s0">with </span><span class="s1">clear_and_catch_warnings(modules=[my_mod]):</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_equal(my_mod.__warningregistry__</span><span class="s0">, </span><span class="s1">{})</span>
    <span class="s4"># Without specified modules, don't clear warnings during context</span>
    <span class="s4"># Python 3.7 catch_warnings doesn't make an entry for 'ignore'.</span>
    <span class="s0">with </span><span class="s1">clear_and_catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">py37=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s4"># Confirm that specifying module keeps old warning, does not add new</span>
    <span class="s0">with </span><span class="s1">clear_and_catch_warnings(modules=[my_mod]):</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Another warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">py37=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s4"># Another warning, no module spec does add to warnings dict, except on</span>
    <span class="s4"># Python 3.4 (see comments in `assert_warn_len_equal`)</span>
    <span class="s4"># Python 3.7 catch_warnings doesn't make an entry for 'ignore'.</span>
    <span class="s0">with </span><span class="s1">clear_and_catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Another warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">py34=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">py37=</span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_suppress_warnings_module():</span>
    <span class="s4"># Initial state of module, no warnings</span>
    <span class="s1">my_mod = _get_fresh_mod()</span>
    <span class="s1">assert_equal(getattr(my_mod</span><span class="s0">, </span><span class="s5">'__warningregistry__'</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">{})</span>

    <span class="s0">def </span><span class="s1">warn_other_module():</span>
        <span class="s4"># Apply along axis is implemented in python; stacklevel=2 means</span>
        <span class="s4"># we end up inside its module, not ours.</span>
        <span class="s0">def </span><span class="s1">warn(arr):</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning 2&quot;</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">arr</span>
        <span class="s1">np.apply_along_axis(warn</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s4"># Test module based warning suppression:</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.record(UserWarning)</span>
        <span class="s4"># suppress warning from other module (may have .pyc ending),</span>
        <span class="s4"># if apply_along_axis is moved, had to be changed.</span>
        <span class="s1">sup.filter(module=np.lib.shape_base)</span>
        <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>
        <span class="s1">warn_other_module()</span>
    <span class="s4"># Check that the suppression did test the file correctly (this module</span>
    <span class="s4"># got filtered)</span>
    <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(sup.log[</span><span class="s3">0</span><span class="s1">].message.args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">py37=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">sup = suppress_warnings()</span>
    <span class="s4"># Will have to be changed if apply_along_axis is moved:</span>
    <span class="s1">sup.filter(module=my_mod)</span>
    <span class="s0">with </span><span class="s1">sup:</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s4"># And test repeat works:</span>
    <span class="s1">sup.filter(module=my_mod)</span>
    <span class="s0">with </span><span class="s1">sup:</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s4"># Without specified modules, don't clear warnings during context</span>
    <span class="s4"># Python 3.7 does not add ignored warnings.</span>
    <span class="s0">with </span><span class="s1">suppress_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">py37=</span><span class="s3">0</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">test_suppress_warnings_type():</span>
    <span class="s4"># Initial state of module, no warnings</span>
    <span class="s1">my_mod = _get_fresh_mod()</span>
    <span class="s1">assert_equal(getattr(my_mod</span><span class="s0">, </span><span class="s5">'__warningregistry__'</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">{})</span>

    <span class="s4"># Test module based warning suppression:</span>
    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(UserWarning)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">sup = suppress_warnings()</span>
    <span class="s1">sup.filter(UserWarning)</span>
    <span class="s0">with </span><span class="s1">sup:</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s4"># And test repeat works:</span>
    <span class="s1">sup.filter(module=my_mod)</span>
    <span class="s0">with </span><span class="s1">sup:</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s4"># Without specified modules, don't clear warnings during context</span>
    <span class="s4"># Python 3.7 does not add ignored warnings.</span>
    <span class="s0">with </span><span class="s1">suppress_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_warn_len_equal(my_mod</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">py37=</span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_suppress_warnings_decorate_no_record():</span>
    <span class="s1">sup = suppress_warnings()</span>
    <span class="s1">sup.filter(UserWarning)</span>

    <span class="s1">@sup</span>
    <span class="s0">def </span><span class="s1">warn(category):</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s0">, </span><span class="s1">category)</span>

    <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>
        <span class="s1">warn(UserWarning)  </span><span class="s4"># should be supppressed</span>
        <span class="s1">warn(RuntimeWarning)</span>
        <span class="s1">assert_equal(len(w)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_suppress_warnings_record():</span>
    <span class="s1">sup = suppress_warnings()</span>
    <span class="s1">log1 = sup.record()</span>

    <span class="s0">with </span><span class="s1">sup:</span>
        <span class="s1">log2 = sup.record(message=</span><span class="s5">'Some other warning 2'</span><span class="s1">)</span>
        <span class="s1">sup.filter(message=</span><span class="s5">'Some warning'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some other warning'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some other warning 2'</span><span class="s1">)</span>

        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(log1)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(log2)</span><span class="s0">,</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(log2[</span><span class="s3">0</span><span class="s1">].message.args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Some other warning 2'</span><span class="s1">)</span>

    <span class="s4"># Do it again, with the same context to see if some warnings survived:</span>
    <span class="s0">with </span><span class="s1">sup:</span>
        <span class="s1">log2 = sup.record(message=</span><span class="s5">'Some other warning 2'</span><span class="s1">)</span>
        <span class="s1">sup.filter(message=</span><span class="s5">'Some warning'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some other warning'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some other warning 2'</span><span class="s1">)</span>

        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(log1)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(log2)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(log2[</span><span class="s3">0</span><span class="s1">].message.args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">'Some other warning 2'</span><span class="s1">)</span>

    <span class="s4"># Test nested:</span>
    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.record()</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup2:</span>
            <span class="s1">sup2.record(message=</span><span class="s5">'Some warning'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(</span><span class="s5">'Some other warning'</span><span class="s1">)</span>
            <span class="s1">assert_equal(len(sup2.log)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_suppress_warnings_forwarding():</span>
    <span class="s0">def </span><span class="s1">warn_other_module():</span>
        <span class="s4"># Apply along axis is implemented in python; stacklevel=2 means</span>
        <span class="s4"># we end up inside its module, not ours.</span>
        <span class="s0">def </span><span class="s1">warn(arr):</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">arr</span>
        <span class="s1">np.apply_along_axis(warn</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.record()</span>
        <span class="s0">with </span><span class="s1">suppress_warnings(</span><span class="s5">&quot;always&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">):</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>

        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.record()</span>
        <span class="s0">with </span><span class="s1">suppress_warnings(</span><span class="s5">&quot;location&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">):</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>

        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.record()</span>
        <span class="s0">with </span><span class="s1">suppress_warnings(</span><span class="s5">&quot;module&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">):</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>
                <span class="s1">warn_other_module()</span>

        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.record()</span>
        <span class="s0">with </span><span class="s1">suppress_warnings(</span><span class="s5">&quot;once&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">):</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some warning&quot;</span><span class="s1">)</span>
                <span class="s1">warnings.warn(</span><span class="s5">&quot;Some other warning&quot;</span><span class="s1">)</span>
                <span class="s1">warn_other_module()</span>

        <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_tempdir():</span>
    <span class="s0">with </span><span class="s1">tempdir() </span><span class="s0">as </span><span class="s1">tdir:</span>
        <span class="s1">fpath = os.path.join(tdir</span><span class="s0">, </span><span class="s5">'tmp'</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">open(fpath</span><span class="s0">, </span><span class="s5">'w'</span><span class="s1">):</span>
            <span class="s0">pass</span>
    <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">os.path.isdir(tdir))</span>

    <span class="s1">raised = </span><span class="s0">False</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">tempdir() </span><span class="s0">as </span><span class="s1">tdir:</span>
            <span class="s0">raise </span><span class="s1">ValueError()</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s1">raised = </span><span class="s0">True</span>
    <span class="s1">assert_(raised)</span>
    <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">os.path.isdir(tdir))</span>


<span class="s0">def </span><span class="s1">test_temppath():</span>
    <span class="s0">with </span><span class="s1">temppath() </span><span class="s0">as </span><span class="s1">fpath:</span>
        <span class="s0">with </span><span class="s1">open(fpath</span><span class="s0">, </span><span class="s5">'w'</span><span class="s1">):</span>
            <span class="s0">pass</span>
    <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">os.path.isfile(fpath))</span>

    <span class="s1">raised = </span><span class="s0">False</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">temppath() </span><span class="s0">as </span><span class="s1">fpath:</span>
            <span class="s0">raise </span><span class="s1">ValueError()</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s1">raised = </span><span class="s0">True</span>
    <span class="s1">assert_(raised)</span>
    <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">os.path.isfile(fpath))</span>


<span class="s0">class </span><span class="s1">my_cacw(clear_and_catch_warnings):</span>

    <span class="s1">class_modules = (sys.modules[__name__]</span><span class="s0">,</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_clear_and_catch_warnings_inherit():</span>
    <span class="s4"># Test can subclass and add default modules</span>
    <span class="s1">my_mod = _get_fresh_mod()</span>
    <span class="s0">with </span><span class="s1">my_cacw():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(</span><span class="s5">'Some warning'</span><span class="s1">)</span>
    <span class="s1">assert_equal(my_mod.__warningregistry__</span><span class="s0">, </span><span class="s1">{})</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">HAS_REFCOUNT</span><span class="s0">, </span><span class="s1">reason=</span><span class="s5">&quot;Python lacks refcounts&quot;</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestAssertNoGcCycles:</span>
    <span class="s2">&quot;&quot;&quot; Test assert_no_gc_cycles &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_passes(self):</span>
        <span class="s0">def </span><span class="s1">no_cycle():</span>
            <span class="s1">b = []</span>
            <span class="s1">b.append([])</span>
            <span class="s0">return </span><span class="s1">b</span>

        <span class="s0">with </span><span class="s1">assert_no_gc_cycles():</span>
            <span class="s1">no_cycle()</span>

        <span class="s1">assert_no_gc_cycles(no_cycle)</span>

    <span class="s0">def </span><span class="s1">test_asserts(self):</span>
        <span class="s0">def </span><span class="s1">make_cycle():</span>
            <span class="s1">a = []</span>
            <span class="s1">a.append(a)</span>
            <span class="s1">a.append(a)</span>
            <span class="s0">return </span><span class="s1">a</span>

        <span class="s0">with </span><span class="s1">assert_raises(AssertionError):</span>
            <span class="s0">with </span><span class="s1">assert_no_gc_cycles():</span>
                <span class="s1">make_cycle()</span>

        <span class="s0">with </span><span class="s1">assert_raises(AssertionError):</span>
            <span class="s1">assert_no_gc_cycles(make_cycle)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_fails(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Test that in cases where the garbage cannot be collected, we raise an 
        error, instead of hanging forever trying to clear it. 
        &quot;&quot;&quot;</span>

        <span class="s0">class </span><span class="s1">ReferenceCycleInDel:</span>
            <span class="s2">&quot;&quot;&quot; 
            An object that not only contains a reference cycle, but creates new 
            cycles whenever it's garbage-collected and its __del__ runs 
            &quot;&quot;&quot;</span>
            <span class="s1">make_cycle = </span><span class="s0">True</span>

            <span class="s0">def </span><span class="s1">__init__(self):</span>
                <span class="s1">self.cycle = self</span>

            <span class="s0">def </span><span class="s1">__del__(self):</span>
                <span class="s4"># break the current cycle so that `self` can be freed</span>
                <span class="s1">self.cycle = </span><span class="s0">None</span>

                <span class="s0">if </span><span class="s1">ReferenceCycleInDel.make_cycle:</span>
                    <span class="s4"># but create a new one so that the garbage collector has more</span>
                    <span class="s4"># work to do.</span>
                    <span class="s1">ReferenceCycleInDel()</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">w = weakref.ref(ReferenceCycleInDel())</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">assert_raises(RuntimeError):</span>
                    <span class="s4"># this will be unable to get a baseline empty garbage</span>
                    <span class="s1">assert_no_gc_cycles(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">AssertionError:</span>
                <span class="s4"># the above test is only necessary if the GC actually tried to free</span>
                <span class="s4"># our object anyway, which python 2.7 does not.</span>
                <span class="s0">if </span><span class="s1">w() </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">pytest.skip(</span><span class="s5">&quot;GC does not call __del__ on cyclic objects&quot;</span><span class="s1">)</span>
                    <span class="s0">raise</span>

        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s4"># make sure that we stop creating reference cycles</span>
            <span class="s1">ReferenceCycleInDel.make_cycle = </span><span class="s0">False</span>
</pre>
</body>
</html>