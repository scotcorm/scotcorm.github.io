<html>
<head>
<title>missing.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
missing.pyx</font>
</center></td></tr></table>
<pre><span class="s0">from decimal import Decimal</span>
<span class="s0">import numbers</span>
<span class="s0">from sys import maxsize</span>

<span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>
<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from pandas._libs cimport util</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">c_NaT as NaT,</span>
    <span class="s0">checknull_with_nat,</span>
    <span class="s0">is_dt64nat,</span>
    <span class="s0">is_td64nat,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">get_datetime64_unit,</span>
    <span class="s0">get_datetime64_value,</span>
    <span class="s0">get_timedelta64_value,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.ops_dispatch import maybe_dispatch_ufunc_to_dunder_op</span>

<span class="s0">cdef:</span>
    <span class="s0">float64_t INF = &lt;float64_t&gt;np.inf</span>
    <span class="s0">float64_t NEGINF = -INF</span>

    <span class="s0">int64_t NPY_NAT = util.get_nat()</span>

    <span class="s0">bint is_32bit = maxsize &lt;= 2 ** 32</span>

    <span class="s0">type cDecimal = Decimal  # for faster isinstance checks</span>


<span class="s0">cpdef bint is_matching_na(object left, object right, bint nan_matches_none=False):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check if two scalars are both NA of matching types.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">left : Any</span>
    <span class="s0">right : Any</span>
    <span class="s0">nan_matches_none : bool, default False</span>
        <span class="s0">For backwards compatibility, consider NaN as matching None.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if left is None:</span>
        <span class="s0">if nan_matches_none and util.is_nan(right):</span>
            <span class="s0">return True</span>
        <span class="s0">return right is None</span>
    <span class="s0">elif left is C_NA:</span>
        <span class="s0">return right is C_NA</span>
    <span class="s0">elif left is NaT:</span>
        <span class="s0">return right is NaT</span>
    <span class="s0">elif util.is_float_object(left):</span>
        <span class="s0">if nan_matches_none and right is None and util.is_nan(left):</span>
            <span class="s0">return True</span>
        <span class="s0">return (</span>
            <span class="s0">util.is_nan(left)</span>
            <span class="s0">and util.is_float_object(right)</span>
            <span class="s0">and util.is_nan(right)</span>
        <span class="s0">)</span>
    <span class="s0">elif util.is_complex_object(left):</span>
        <span class="s0">return (</span>
            <span class="s0">util.is_nan(left)</span>
            <span class="s0">and util.is_complex_object(right)</span>
            <span class="s0">and util.is_nan(right)</span>
        <span class="s0">)</span>
    <span class="s0">elif util.is_datetime64_object(left):</span>
        <span class="s0">return (</span>
            <span class="s0">get_datetime64_value(left) == NPY_NAT</span>
            <span class="s0">and util.is_datetime64_object(right)</span>
            <span class="s0">and get_datetime64_value(right) == NPY_NAT</span>
            <span class="s0">and get_datetime64_unit(left) == get_datetime64_unit(right)</span>
        <span class="s0">)</span>
    <span class="s0">elif util.is_timedelta64_object(left):</span>
        <span class="s0">return (</span>
            <span class="s0">get_timedelta64_value(left) == NPY_NAT</span>
            <span class="s0">and util.is_timedelta64_object(right)</span>
            <span class="s0">and get_timedelta64_value(right) == NPY_NAT</span>
            <span class="s0">and get_datetime64_unit(left) == get_datetime64_unit(right)</span>
        <span class="s0">)</span>
    <span class="s0">elif is_decimal_na(left):</span>
        <span class="s0">return is_decimal_na(right)</span>
    <span class="s0">return False</span>


<span class="s0">cpdef bint checknull(object val, bint inf_as_na=False):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return boolean describing of the input is NA-like, defined here as any</span>
    <span class="s0">of:</span>
     <span class="s0">- None</span>
     <span class="s0">- nan</span>
     <span class="s0">- NaT</span>
     <span class="s0">- np.datetime64 representation of NaT</span>
     <span class="s0">- np.timedelta64 representation of NaT</span>
     <span class="s0">- NA</span>
     <span class="s0">- Decimal(&quot;NaN&quot;)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">val : object</span>
    <span class="s0">inf_as_na : bool, default False</span>
        <span class="s0">Whether to treat INF and -INF as NA values.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if val is None or val is NaT or val is C_NA:</span>
        <span class="s0">return True</span>
    <span class="s0">elif util.is_float_object(val) or util.is_complex_object(val):</span>
        <span class="s0">if val != val:</span>
            <span class="s0">return True</span>
        <span class="s0">elif inf_as_na:</span>
            <span class="s0">return val == INF or val == NEGINF</span>
        <span class="s0">return False</span>
    <span class="s0">elif util.is_timedelta64_object(val):</span>
        <span class="s0">return get_timedelta64_value(val) == NPY_NAT</span>
    <span class="s0">elif util.is_datetime64_object(val):</span>
        <span class="s0">return get_datetime64_value(val) == NPY_NAT</span>
    <span class="s0">else:</span>
        <span class="s0">return is_decimal_na(val)</span>


<span class="s0">cdef inline bint is_decimal_na(object val):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Is this a decimal.Decimal object Decimal(&quot;NAN&quot;).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return isinstance(val, cDecimal) and val != val</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cpdef ndarray[uint8_t] isnaobj(ndarray arr, bint inf_as_na=False):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return boolean mask denoting which elements of a 1-D array are na-like,</span>
    <span class="s0">according to the criteria defined in `checknull`:</span>
     <span class="s0">- None</span>
     <span class="s0">- nan</span>
     <span class="s0">- NaT</span>
     <span class="s0">- np.datetime64 representation of NaT</span>
     <span class="s0">- np.timedelta64 representation of NaT</span>
     <span class="s0">- NA</span>
     <span class="s0">- Decimal(&quot;NaN&quot;)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">result : ndarray (dtype=np.bool_)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">object val</span>
        <span class="s0">ndarray[uint8_t] result</span>

    <span class="s0">assert arr.ndim == 1, &quot;'arr' must be 1-D.&quot;</span>

    <span class="s0">n = len(arr)</span>
    <span class="s0">result = np.empty(n, dtype=np.uint8)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = arr[i]</span>
        <span class="s0">result[i] = checknull(val, inf_as_na=inf_as_na)</span>
    <span class="s0">return result.view(np.bool_)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def isnaobj2d(arr: ndarray, inf_as_na: bool = False) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return boolean mask denoting which elements of a 2-D array are na-like,</span>
    <span class="s0">according to the criteria defined in `checknull`:</span>
     <span class="s0">- None</span>
     <span class="s0">- nan</span>
     <span class="s0">- NaT</span>
     <span class="s0">- np.datetime64 representation of NaT</span>
     <span class="s0">- np.timedelta64 representation of NaT</span>
     <span class="s0">- NA</span>
     <span class="s0">- Decimal(&quot;NaN&quot;)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">result : ndarray (dtype=np.bool_)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, n, m</span>
        <span class="s0">object val</span>
        <span class="s0">ndarray[uint8_t, ndim=2] result</span>

    <span class="s0">assert arr.ndim == 2, &quot;'arr' must be 2-D.&quot;</span>

    <span class="s0">n, m = (&lt;object&gt;arr).shape</span>
    <span class="s0">result = np.zeros((n, m), dtype=np.uint8)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">for j in range(m):</span>
            <span class="s0">val = arr[i, j]</span>
            <span class="s0">if checknull(val, inf_as_na=inf_as_na):</span>
                <span class="s0">result[i, j] = 1</span>
    <span class="s0">return result.view(np.bool_)</span>


<span class="s0">def isposinf_scalar(val: object) -&gt; bool:</span>
    <span class="s0">return util.is_float_object(val) and val == INF</span>


<span class="s0">def isneginf_scalar(val: object) -&gt; bool:</span>
    <span class="s0">return util.is_float_object(val) and val == NEGINF</span>


<span class="s0">cdef inline bint is_null_datetime64(v):</span>
    <span class="s0"># determine if we have a null for a datetime (or integer versions),</span>
    <span class="s0"># excluding np.timedelta64('nat')</span>
    <span class="s0">if checknull_with_nat(v) or is_dt64nat(v):</span>
        <span class="s0">return True</span>
    <span class="s0">return False</span>


<span class="s0">cdef inline bint is_null_timedelta64(v):</span>
    <span class="s0"># determine if we have a null for a timedelta (or integer versions),</span>
    <span class="s0"># excluding np.datetime64('nat')</span>
    <span class="s0">if checknull_with_nat(v) or is_td64nat(v):</span>
        <span class="s0">return True</span>
    <span class="s0">return False</span>


<span class="s0">cdef bint checknull_with_nat_and_na(object obj):</span>
    <span class="s0"># See GH#32214</span>
    <span class="s0">return checknull_with_nat(obj) or obj is C_NA</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def is_float_nan(values: ndarray) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">True for elements which correspond to a float nan</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ndarray[bool]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">ndarray[uint8_t] result</span>
        <span class="s0">Py_ssize_t i, N</span>
        <span class="s0">object val</span>

    <span class="s0">N = len(values)</span>
    <span class="s0">result = np.zeros(N, dtype=np.uint8)</span>

    <span class="s0">for i in range(N):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if util.is_nan(val):</span>
            <span class="s0">result[i] = True</span>
    <span class="s0">return result.view(bool)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def is_numeric_na(values: ndarray) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check for NA values consistent with IntegerArray/FloatingArray.</span>

    <span class="s0">Similar to a vectorized is_valid_na_for_dtype restricted to numeric dtypes.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ndarray[bool]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">ndarray[uint8_t] result</span>
        <span class="s0">Py_ssize_t i, N</span>
        <span class="s0">object val</span>

    <span class="s0">N = len(values)</span>
    <span class="s0">result = np.zeros(N, dtype=np.uint8)</span>

    <span class="s0">for i in range(N):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if checknull(val):</span>
            <span class="s0">if val is None or val is C_NA or util.is_nan(val) or is_decimal_na(val):</span>
                <span class="s0">result[i] = True</span>
            <span class="s0">else:</span>
                <span class="s0">raise TypeError(f&quot;'values' contains non-numeric NA {val}&quot;)</span>
    <span class="s0">return result.view(bool)</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># Implementation of NA singleton</span>


<span class="s0">def _create_binary_propagating_op(name, is_divmod=False):</span>

    <span class="s0">def method(self, other):</span>
        <span class="s0">if (other is C_NA or isinstance(other, str)</span>
                <span class="s0">or isinstance(other, (numbers.Number, np.bool_))</span>
                <span class="s0">or isinstance(other, np.ndarray) and not other.shape):</span>
            <span class="s0"># Need the other.shape clause to handle NumPy scalars,</span>
            <span class="s0"># since we do a setitem on `out` below, which</span>
            <span class="s0"># won't work for NumPy scalars.</span>
            <span class="s0">if is_divmod:</span>
                <span class="s0">return NA, NA</span>
            <span class="s0">else:</span>
                <span class="s0">return NA</span>

        <span class="s0">elif isinstance(other, np.ndarray):</span>
            <span class="s0">out = np.empty(other.shape, dtype=object)</span>
            <span class="s0">out[:] = NA</span>

            <span class="s0">if is_divmod:</span>
                <span class="s0">return out, out.copy()</span>
            <span class="s0">else:</span>
                <span class="s0">return out</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">method.__name__ = name</span>
    <span class="s0">return method</span>


<span class="s0">def _create_unary_propagating_op(name: str):</span>
    <span class="s0">def method(self):</span>
        <span class="s0">return NA</span>

    <span class="s0">method.__name__ = name</span>
    <span class="s0">return method</span>


<span class="s0">cdef class C_NAType:</span>
    <span class="s0">pass</span>


<span class="s0">class NAType(C_NAType):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">NA (&quot;not available&quot;) missing value indicator.</span>

    <span class="s0">.. warning::</span>

       <span class="s0">Experimental: the behaviour of NA can still change without warning.</span>

    <span class="s0">.. versionadded:: 1.0.0</span>

    <span class="s0">The NA singleton is a missing value indicator defined by pandas. It is</span>
    <span class="s0">used in certain new extension dtypes (currently the &quot;string&quot; dtype).</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_instance = None</span>

    <span class="s0">def __new__(cls, *args, **kwargs):</span>
        <span class="s0">if NAType._instance is None:</span>
            <span class="s0">NAType._instance = C_NAType.__new__(cls, *args, **kwargs)</span>
        <span class="s0">return NAType._instance</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">return &quot;&lt;NA&gt;&quot;</span>

    <span class="s0">def __format__(self, format_spec) -&gt; str:</span>
        <span class="s0">try:</span>
            <span class="s0">return self.__repr__().__format__(format_spec)</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">return self.__repr__()</span>

    <span class="s0">def __bool__(self):</span>
        <span class="s0">raise TypeError(&quot;boolean value of NA is ambiguous&quot;)</span>

    <span class="s0">def __hash__(self):</span>
        <span class="s0"># GH 30013: Ensure hash is large enough to avoid hash collisions with integers</span>
        <span class="s0">exponent = 31 if is_32bit else 61</span>
        <span class="s0">return 2 ** exponent - 1</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">return &quot;NA&quot;</span>

    <span class="s0"># Binary arithmetic and comparison ops -&gt; propagate</span>

    <span class="s0">__add__ = _create_binary_propagating_op(&quot;__add__&quot;)</span>
    <span class="s0">__radd__ = _create_binary_propagating_op(&quot;__radd__&quot;)</span>
    <span class="s0">__sub__ = _create_binary_propagating_op(&quot;__sub__&quot;)</span>
    <span class="s0">__rsub__ = _create_binary_propagating_op(&quot;__rsub__&quot;)</span>
    <span class="s0">__mul__ = _create_binary_propagating_op(&quot;__mul__&quot;)</span>
    <span class="s0">__rmul__ = _create_binary_propagating_op(&quot;__rmul__&quot;)</span>
    <span class="s0">__matmul__ = _create_binary_propagating_op(&quot;__matmul__&quot;)</span>
    <span class="s0">__rmatmul__ = _create_binary_propagating_op(&quot;__rmatmul__&quot;)</span>
    <span class="s0">__truediv__ = _create_binary_propagating_op(&quot;__truediv__&quot;)</span>
    <span class="s0">__rtruediv__ = _create_binary_propagating_op(&quot;__rtruediv__&quot;)</span>
    <span class="s0">__floordiv__ = _create_binary_propagating_op(&quot;__floordiv__&quot;)</span>
    <span class="s0">__rfloordiv__ = _create_binary_propagating_op(&quot;__rfloordiv__&quot;)</span>
    <span class="s0">__mod__ = _create_binary_propagating_op(&quot;__mod__&quot;)</span>
    <span class="s0">__rmod__ = _create_binary_propagating_op(&quot;__rmod__&quot;)</span>
    <span class="s0">__divmod__ = _create_binary_propagating_op(&quot;__divmod__&quot;, is_divmod=True)</span>
    <span class="s0">__rdivmod__ = _create_binary_propagating_op(&quot;__rdivmod__&quot;, is_divmod=True)</span>
    <span class="s0"># __lshift__ and __rshift__ are not implemented</span>

    <span class="s0">__eq__ = _create_binary_propagating_op(&quot;__eq__&quot;)</span>
    <span class="s0">__ne__ = _create_binary_propagating_op(&quot;__ne__&quot;)</span>
    <span class="s0">__le__ = _create_binary_propagating_op(&quot;__le__&quot;)</span>
    <span class="s0">__lt__ = _create_binary_propagating_op(&quot;__lt__&quot;)</span>
    <span class="s0">__gt__ = _create_binary_propagating_op(&quot;__gt__&quot;)</span>
    <span class="s0">__ge__ = _create_binary_propagating_op(&quot;__ge__&quot;)</span>

    <span class="s0"># Unary ops</span>

    <span class="s0">__neg__ = _create_unary_propagating_op(&quot;__neg__&quot;)</span>
    <span class="s0">__pos__ = _create_unary_propagating_op(&quot;__pos__&quot;)</span>
    <span class="s0">__abs__ = _create_unary_propagating_op(&quot;__abs__&quot;)</span>
    <span class="s0">__invert__ = _create_unary_propagating_op(&quot;__invert__&quot;)</span>

    <span class="s0"># pow has special</span>
    <span class="s0">def __pow__(self, other):</span>
        <span class="s0">if other is C_NA:</span>
            <span class="s0">return NA</span>
        <span class="s0">elif isinstance(other, (numbers.Number, np.bool_)):</span>
            <span class="s0">if other == 0:</span>
                <span class="s0"># returning positive is correct for +/- 0.</span>
                <span class="s0">return type(other)(1)</span>
            <span class="s0">else:</span>
                <span class="s0">return NA</span>
        <span class="s0">elif isinstance(other, np.ndarray):</span>
            <span class="s0">return np.where(other == 0, other.dtype.type(1), NA)</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __rpow__(self, other):</span>
        <span class="s0">if other is C_NA:</span>
            <span class="s0">return NA</span>
        <span class="s0">elif isinstance(other, (numbers.Number, np.bool_)):</span>
            <span class="s0">if other == 1:</span>
                <span class="s0">return other</span>
            <span class="s0">else:</span>
                <span class="s0">return NA</span>
        <span class="s0">elif isinstance(other, np.ndarray):</span>
            <span class="s0">return np.where(other == 1, other, NA)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0"># Logical ops using Kleene logic</span>

    <span class="s0">def __and__(self, other):</span>
        <span class="s0">if other is False:</span>
            <span class="s0">return False</span>
        <span class="s0">elif other is True or other is C_NA:</span>
            <span class="s0">return NA</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">__rand__ = __and__</span>

    <span class="s0">def __or__(self, other):</span>
        <span class="s0">if other is True:</span>
            <span class="s0">return True</span>
        <span class="s0">elif other is False or other is C_NA:</span>
            <span class="s0">return NA</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">__ror__ = __or__</span>

    <span class="s0">def __xor__(self, other):</span>
        <span class="s0">if other is False or other is True or other is C_NA:</span>
            <span class="s0">return NA</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">__rxor__ = __xor__</span>

    <span class="s0">__array_priority__ = 1000</span>
    <span class="s0">_HANDLED_TYPES = (np.ndarray, numbers.Number, str, np.bool_)</span>

    <span class="s0">def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):</span>
        <span class="s0">types = self._HANDLED_TYPES + (NAType,)</span>
        <span class="s0">for x in inputs:</span>
            <span class="s0">if not isinstance(x, types):</span>
                <span class="s0">return NotImplemented</span>

        <span class="s0">if method != &quot;__call__&quot;:</span>
            <span class="s0">raise ValueError(f&quot;ufunc method '{method}' not supported for NA&quot;)</span>
        <span class="s0">result = maybe_dispatch_ufunc_to_dunder_op(</span>
            <span class="s0">self, ufunc, method, *inputs, **kwargs</span>
        <span class="s0">)</span>
        <span class="s0">if result is NotImplemented:</span>
            <span class="s0"># For a NumPy ufunc that's not a binop, like np.logaddexp</span>
            <span class="s0">index = [i for i, x in enumerate(inputs) if x is NA][0]</span>
            <span class="s0">result = np.broadcast_arrays(*inputs)[index]</span>
            <span class="s0">if result.ndim == 0:</span>
                <span class="s0">result = result.item()</span>
            <span class="s0">if ufunc.nout &gt; 1:</span>
                <span class="s0">result = (NA,) * ufunc.nout</span>

        <span class="s0">return result</span>


<span class="s0">C_NA = NAType()   # C-visible</span>
<span class="s0">NA = C_NA         # Python-visible</span>
</pre>
</body>
</html>