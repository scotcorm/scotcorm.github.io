<html>
<head>
<title>test_stata.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_stata.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">bz2</span>
<span class="s0">import </span><span class="s1">datetime </span><span class="s0">as </span><span class="s1">dt</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">gzip</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">zipfile</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">is_categorical_dtype</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.core.frame </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">ensure_index</span>

<span class="s0">import </span><span class="s1">pandas.io.common </span><span class="s0">as </span><span class="s1">icom</span>
<span class="s0">from </span><span class="s1">pandas.io.parsers </span><span class="s0">import </span><span class="s1">read_csv</span>
<span class="s0">from </span><span class="s1">pandas.io.stata </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CategoricalConversionWarning</span><span class="s0">,</span>
    <span class="s1">InvalidColumnName</span><span class="s0">,</span>
    <span class="s1">PossiblePrecisionLoss</span><span class="s0">,</span>
    <span class="s1">StataMissingValue</span><span class="s0">,</span>
    <span class="s1">StataReader</span><span class="s0">,</span>
    <span class="s1">StataWriter</span><span class="s0">,</span>
    <span class="s1">StataWriterUTF8</span><span class="s0">,</span>
    <span class="s1">ValueLabelTypeMismatch</span><span class="s0">,</span>
    <span class="s1">read_stata</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">@pytest.fixture()</span>
<span class="s0">def </span><span class="s1">mixed_frame():</span>
    <span class="s0">return </span><span class="s1">DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">27.0</span><span class="s0">, </span><span class="s3">81.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s2">&quot;Atlanta&quot;</span><span class="s0">, </span><span class="s2">&quot;Birmingham&quot;</span><span class="s0">, </span><span class="s2">&quot;Cincinnati&quot;</span><span class="s0">, </span><span class="s2">&quot;Detroit&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">dirpath(datapath):</span>
    <span class="s0">return </span><span class="s1">datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;stata&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">parsed_114(dirpath):</span>
    <span class="s1">dta14_114 = os.path.join(dirpath</span><span class="s0">, </span><span class="s2">&quot;stata5_114.dta&quot;</span><span class="s1">)</span>
    <span class="s1">parsed_114 = read_stata(dta14_114</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">parsed_114.index.name = </span><span class="s2">&quot;index&quot;</span>
    <span class="s0">return </span><span class="s1">parsed_114</span>


<span class="s0">class </span><span class="s1">TestStata:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">setup_method(self</span><span class="s0">, </span><span class="s1">datapath):</span>
        <span class="s1">self.dirpath = datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;stata&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta1_114 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata1_114.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta1_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata1_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta2_113 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata2_113.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta2_114 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata2_114.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta2_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata2_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta2_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata2_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta3_113 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata3_113.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta3_114 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata3_114.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta3_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata3_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta3_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata3_117.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.csv3 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata3.csv&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta4_113 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata4_113.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta4_114 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata4_114.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta4_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata4_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta4_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata4_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta_encoding = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata1_encoding.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta_encoding_118 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata1_encoding_118.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.csv14 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata5.csv&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta14_113 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata5_113.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta14_114 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata5_114.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta14_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata5_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta14_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata5_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.csv15 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata6.csv&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta15_113 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata6_113.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta15_114 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata6_114.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta15_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata6_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta15_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata6_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta16_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata7_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta16_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata7_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta17_113 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata8_113.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta17_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata8_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta17_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata8_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta18_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata9_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta18_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata9_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta19_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata10_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta19_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata10_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta20_115 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata11_115.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta20_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata11_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta21_117 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata12_117.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta22_118 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata14_118.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta23 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata15.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta24_111 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata7_111.dta&quot;</span><span class="s1">)</span>
        <span class="s1">self.dta25_118 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata16_118.dta&quot;</span><span class="s1">)</span>

        <span class="s1">self.dta26_119 = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata1_119.dta.gz&quot;</span><span class="s1">)</span>

        <span class="s1">self.stata_dates = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;stata13_dates.dta&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">read_dta(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s4"># Legacy default reader configuration</span>
        <span class="s0">return </span><span class="s1">read_stata(file</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">read_csv(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s0">return </span><span class="s1">read_csv(file</span><span class="s0">, </span><span class="s1">parse_dates=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_empty_dta(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">empty_ds = DataFrame(columns=[</span><span class="s2">&quot;unit&quot;</span><span class="s1">])</span>
        <span class="s4"># GH 7369, make sure can read a 0-obs dta file</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">empty_ds.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">version=version)</span>
            <span class="s1">empty_ds2 = read_stata(path)</span>
            <span class="s1">tm.assert_frame_equal(empty_ds</span><span class="s0">, </span><span class="s1">empty_ds2)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta1_114&quot;</span><span class="s0">, </span><span class="s2">&quot;dta1_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_dta1(self</span><span class="s0">, </span><span class="s1">file):</span>

        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = self.read_dta(file)</span>

        <span class="s4"># Pandas uses np.nan as missing value.</span>
        <span class="s4"># Thus, all columns will be of type float, regardless of their name.</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[(np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;float_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;double_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;byte_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;int_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;long_miss&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># this is an oddity as really the nan should be float64, but</span>
        <span class="s4"># the casting doesn't fail so need to match stata here</span>
        <span class="s1">expected[</span><span class="s2">&quot;float_miss&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;float_miss&quot;</span><span class="s1">].astype(np.float32)</span>

        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_dta2(self):</span>

        <span class="s1">expected = DataFrame.from_records(</span>
            <span class="s1">[</span>
                <span class="s1">(</span>
                    <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">19</span><span class="s0">, </span><span class="s3">23</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s3">1479596223000</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">2010</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">2010</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">2010</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">1974</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">2010</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">2010</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span>
                    <span class="s1">datetime(</span><span class="s3">1959</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">31</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">1479590</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">1953</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">1948</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">1955</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">1955</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">1955</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT)</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;datetime_c&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetime_big_c&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;date&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;weekly_date&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;monthly_date&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;quarterly_date&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;half_yearly_date&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;yearly_date&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;yearly_date&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;yearly_date&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">parsed_114 = self.read_dta(self.dta2_114)</span>
            <span class="s1">parsed_115 = self.read_dta(self.dta2_115)</span>
            <span class="s1">parsed_117 = self.read_dta(self.dta2_117)</span>
            <span class="s4"># 113 is buggy due to limits of date format support in Stata</span>
            <span class="s4"># parsed_113 = self.read_dta(self.dta2_113)</span>

            <span class="s4"># Remove resource warnings</span>
            <span class="s1">w = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">w </span><span class="s0">if </span><span class="s1">x.category </span><span class="s0">is </span><span class="s1">UserWarning]</span>

            <span class="s4"># should get warning for each call to read_dta</span>
            <span class="s0">assert </span><span class="s1">len(w) == </span><span class="s3">3</span>

        <span class="s4"># buggy test because of the NaT comparison on certain platforms</span>
        <span class="s4"># Format 113 test fails since it does not support tc and tC formats</span>
        <span class="s4"># tm.assert_frame_equal(parsed_113, expected)</span>
        <span class="s1">tm.assert_frame_equal(parsed_114</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed_115</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed_117</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta3_113&quot;</span><span class="s0">, </span><span class="s2">&quot;dta3_114&quot;</span><span class="s0">, </span><span class="s2">&quot;dta3_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta3_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_dta3(self</span><span class="s0">, </span><span class="s1">file):</span>

        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = self.read_dta(file)</span>

        <span class="s4"># match stata here</span>
        <span class="s1">expected = self.read_csv(self.csv3)</span>
        <span class="s1">expected = expected.astype(np.float32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;year&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;year&quot;</span><span class="s1">].astype(np.int16)</span>
        <span class="s1">expected[</span><span class="s2">&quot;quarter&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;quarter&quot;</span><span class="s1">].astype(np.int8)</span>

        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta4_113&quot;</span><span class="s0">, </span><span class="s2">&quot;dta4_114&quot;</span><span class="s0">, </span><span class="s2">&quot;dta4_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta4_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_dta4(self</span><span class="s0">, </span><span class="s1">file):</span>

        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = self.read_dta(file)</span>

        <span class="s1">expected = DataFrame.from_records(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;nine&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s2">&quot;seven&quot;</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s2">&quot;four&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;five&quot;</span><span class="s0">, </span><span class="s2">&quot;six&quot;</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;five&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;six&quot;</span><span class="s0">, </span><span class="s2">&quot;five&quot;</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;six&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;seven&quot;</span><span class="s0">, </span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;seven&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;eight&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;nine&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;nine&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;ten&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;fully_labeled&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;fully_labeled2&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;incompletely_labeled&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;labeled_with_missings&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float_labelled&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># these are all categoricals</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">expected:</span>
            <span class="s1">orig = expected[col].copy()</span>

            <span class="s1">categories = np.asarray(expected[</span><span class="s2">&quot;fully_labeled&quot;</span><span class="s1">][orig.notna()])</span>
            <span class="s0">if </span><span class="s1">col == </span><span class="s2">&quot;incompletely_labeled&quot;</span><span class="s1">:</span>
                <span class="s1">categories = orig</span>

            <span class="s1">cat = orig.astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)._values</span>
            <span class="s1">cat = cat.set_categories(categories</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">cat.categories.rename(</span><span class="s0">None, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">expected[col] = cat</span>

        <span class="s4"># stata doesn't save .category metadata</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s4"># File containing strls</span>
    <span class="s0">def </span><span class="s1">test_read_dta12(self):</span>
        <span class="s1">parsed_117 = self.read_dta(self.dta21_117)</span>
        <span class="s1">expected = DataFrame.from_records(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;abc&quot;</span><span class="s0">, </span><span class="s2">&quot;abcdefghi&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s2">&quot;cba&quot;</span><span class="s0">, </span><span class="s2">&quot;qwertywertyqwerty&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">93</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;strl&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(parsed_117</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_read_dta18(self):</span>
        <span class="s1">parsed_118 = self.read_dta(self.dta22_118)</span>
        <span class="s1">parsed_118[</span><span class="s2">&quot;Bytes&quot;</span><span class="s1">] = parsed_118[</span><span class="s2">&quot;Bytes&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame.from_records(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">&quot;Cat&quot;</span><span class="s0">, </span><span class="s2">&quot;Bogota&quot;</span><span class="s0">, </span><span class="s2">&quot;Bogotá&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s2">&quot;option b Ünicode&quot;</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;Dog&quot;</span><span class="s0">, </span><span class="s2">&quot;Boston&quot;</span><span class="s0">, </span><span class="s2">&quot;Uzunköprü&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;Plane&quot;</span><span class="s0">, </span><span class="s2">&quot;Rome&quot;</span><span class="s0">, </span><span class="s2">&quot;Tromsø&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s2">&quot;option a&quot;</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;Potato&quot;</span><span class="s0">, </span><span class="s2">&quot;Tokyo&quot;</span><span class="s0">, </span><span class="s2">&quot;Elâzığ&quot;</span><span class="s0">, </span><span class="s1">-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.3332999</span><span class="s0">, </span><span class="s2">&quot;option a&quot;</span><span class="s0">, </span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;Things&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Cities&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Unicode_Cities_Strl&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Ints&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Floats&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Bytes&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Longs&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;Floats&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;Floats&quot;</span><span class="s1">].astype(np.float32)</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">parsed_118.columns:</span>
            <span class="s1">tm.assert_almost_equal(parsed_118[col]</span><span class="s0">, </span><span class="s1">expected[col])</span>

        <span class="s0">with </span><span class="s1">StataReader(self.dta22_118) </span><span class="s0">as </span><span class="s1">rdr:</span>
            <span class="s1">vl = rdr.variable_labels()</span>
            <span class="s1">vl_expected = {</span>
                <span class="s2">&quot;Unicode_Cities_Strl&quot;</span><span class="s1">: </span><span class="s2">&quot;Here are some strls with Ünicode chars&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Longs&quot;</span><span class="s1">: </span><span class="s2">&quot;long data&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Things&quot;</span><span class="s1">: </span><span class="s2">&quot;Here are some things&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Bytes&quot;</span><span class="s1">: </span><span class="s2">&quot;byte data&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Ints&quot;</span><span class="s1">: </span><span class="s2">&quot;int data&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Cities&quot;</span><span class="s1">: </span><span class="s2">&quot;Here are some cities&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Floats&quot;</span><span class="s1">: </span><span class="s2">&quot;float data&quot;</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s1">tm.assert_dict_equal(vl</span><span class="s0">, </span><span class="s1">vl_expected)</span>

            <span class="s0">assert </span><span class="s1">rdr.data_label == </span><span class="s2">&quot;This is a  Ünicode data label&quot;</span>

    <span class="s0">def </span><span class="s1">test_read_write_dta5(self):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">[(np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;float_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;double_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;byte_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;int_miss&quot;</span><span class="s0">, </span><span class="s2">&quot;long_miss&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">original)</span>

    <span class="s0">def </span><span class="s1">test_write_dta6(self):</span>
        <span class="s1">original = self.read_csv(self.csv3)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">original.index = original.index.astype(np.int32)</span>
        <span class="s1">original[</span><span class="s2">&quot;year&quot;</span><span class="s1">] = original[</span><span class="s2">&quot;year&quot;</span><span class="s1">].astype(np.int32)</span>
        <span class="s1">original[</span><span class="s2">&quot;quarter&quot;</span><span class="s1">] = original[</span><span class="s2">&quot;quarter&quot;</span><span class="s1">].astype(np.int32)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(</span>
                <span class="s1">written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">original</span><span class="s0">,</span>
                <span class="s1">check_index_type=</span><span class="s0">False,</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_write_dta10(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">data=[[</span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;object&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.1</span><span class="s0">, </span><span class="s1">np.datetime64(</span><span class="s2">&quot;2003-12-25&quot;</span><span class="s1">)]]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;object&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;floating&quot;</span><span class="s0">, </span><span class="s2">&quot;datetime&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">original[</span><span class="s2">&quot;object&quot;</span><span class="s1">] = Series(original[</span><span class="s2">&quot;object&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">original.index = original.index.astype(np.int32)</span>
        <span class="s1">original[</span><span class="s2">&quot;integer&quot;</span><span class="s1">] = original[</span><span class="s2">&quot;integer&quot;</span><span class="s1">].astype(np.int32)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;datetime&quot;</span><span class="s1">: </span><span class="s2">&quot;tc&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s4"># original.index is np.int32, read index is np.int64</span>
            <span class="s1">tm.assert_frame_equal(</span>
                <span class="s1">written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">original</span><span class="s0">,</span>
                <span class="s1">check_index_type=</span><span class="s0">False,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_stata_doc_examples(self):</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;AB&quot;</span><span class="s1">))</span>
            <span class="s1">df.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_write_preserves_original(self):</span>
        <span class="s4"># 9795</span>
        <span class="s1">np.random.seed(</span><span class="s3">423</span><span class="s1">)</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">df.loc[</span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">:</span><span class="s2">&quot;c&quot;</span><span class="s1">] = np.nan</span>
        <span class="s1">df_copy = df.copy()</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df_copy)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_encoding(self</span><span class="s0">, </span><span class="s1">version):</span>

        <span class="s4"># GH 4626, proper encoding handling</span>
        <span class="s1">raw = read_stata(self.dta_encoding)</span>
        <span class="s1">encoded = read_stata(self.dta_encoding)</span>
        <span class="s1">result = encoded.kreis1849[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">expected = raw.kreis1849[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>
        <span class="s0">assert </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">str)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">encoded.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">version=version)</span>
            <span class="s1">reread_encoded = read_stata(path)</span>
            <span class="s1">tm.assert_frame_equal(encoded</span><span class="s0">, </span><span class="s1">reread_encoded)</span>

    <span class="s0">def </span><span class="s1">test_read_write_dta11(self):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;good&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;b</span><span class="s0">\u00E4</span><span class="s2">d&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;8number&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;astringwithmorethan32characters______&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">formatted = DataFrame(</span>
            <span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;good&quot;</span><span class="s0">, </span><span class="s2">&quot;b_d&quot;</span><span class="s0">, </span><span class="s2">&quot;_8number&quot;</span><span class="s0">, </span><span class="s2">&quot;astringwithmorethan32characters_&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">formatted.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">formatted = formatted.astype(np.int32)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(InvalidColumnName):</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">formatted)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_write_dta12(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;astringwithmorethan32characters_1&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;astringwithmorethan32characters_2&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;-&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;short&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;delete&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">formatted = DataFrame(</span>
            <span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;astringwithmorethan32characters_&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;_0astringwithmorethan32character&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;_&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;_1_&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;_short&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;_delete&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">formatted.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">formatted = formatted.astype(np.int32)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
                <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">InvalidColumnName)</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, None, </span><span class="s1">version=version)</span>
                <span class="s4"># should get a warning for that format.</span>
                <span class="s0">assert </span><span class="s1">len(w) == </span><span class="s3">1</span>

            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">formatted)</span>

    <span class="s0">def </span><span class="s1">test_read_write_dta13(self):</span>
        <span class="s1">s1 = Series(</span><span class="s3">2 </span><span class="s1">** </span><span class="s3">9</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">s2 = Series(</span><span class="s3">2 </span><span class="s1">** </span><span class="s3">17</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">s3 = Series(</span><span class="s3">2 </span><span class="s1">** </span><span class="s3">33</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">original = DataFrame({</span><span class="s2">&quot;int16&quot;</span><span class="s1">: s1</span><span class="s0">, </span><span class="s2">&quot;int32&quot;</span><span class="s1">: s2</span><span class="s0">, </span><span class="s2">&quot;int64&quot;</span><span class="s1">: s3})</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>

        <span class="s1">formatted = original</span>
        <span class="s1">formatted[</span><span class="s2">&quot;int64&quot;</span><span class="s1">] = formatted[</span><span class="s2">&quot;int64&quot;</span><span class="s1">].astype(np.float64)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">formatted)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta14_113&quot;</span><span class="s0">, </span><span class="s2">&quot;dta14_114&quot;</span><span class="s0">, </span><span class="s2">&quot;dta14_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta14_117&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_read_write_reread_dta14(self</span><span class="s0">, </span><span class="s1">file</span><span class="s0">, </span><span class="s1">parsed_114</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = self.read_dta(file)</span>
        <span class="s1">parsed.index.name = </span><span class="s2">&quot;index&quot;</span>

        <span class="s1">expected = self.read_csv(self.csv14)</span>
        <span class="s1">cols = [</span><span class="s2">&quot;byte_&quot;</span><span class="s0">, </span><span class="s2">&quot;int_&quot;</span><span class="s0">, </span><span class="s2">&quot;long_&quot;</span><span class="s0">, </span><span class="s2">&quot;float_&quot;</span><span class="s0">, </span><span class="s2">&quot;double_&quot;</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">cols:</span>
            <span class="s1">expected[col] = expected[col]._convert(datetime=</span><span class="s0">True, </span><span class="s1">numeric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">].astype(np.float32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">] = pd.to_datetime(expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;coerce&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(parsed_114</span><span class="s0">, </span><span class="s1">parsed)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">parsed_114.to_stata(path</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;date_td&quot;</span><span class="s1">: </span><span class="s2">&quot;td&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">parsed_114)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta15_113&quot;</span><span class="s0">, </span><span class="s2">&quot;dta15_114&quot;</span><span class="s0">, </span><span class="s2">&quot;dta15_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta15_117&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_read_write_reread_dta15(self</span><span class="s0">, </span><span class="s1">file):</span>

        <span class="s1">expected = self.read_csv(self.csv15)</span>
        <span class="s1">expected[</span><span class="s2">&quot;byte_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;byte_&quot;</span><span class="s1">].astype(np.int8)</span>
        <span class="s1">expected[</span><span class="s2">&quot;int_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;int_&quot;</span><span class="s1">].astype(np.int16)</span>
        <span class="s1">expected[</span><span class="s2">&quot;long_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;long_&quot;</span><span class="s1">].astype(np.int32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">].astype(np.float32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;double_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;double_&quot;</span><span class="s1">].astype(np.float64)</span>
        <span class="s1">expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">].apply(</span>
            <span class="s1">datetime.strptime</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = self.read_dta(file)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">parsed)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_timestamp_and_label(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">original = DataFrame([(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;variable&quot;</span><span class="s1">])</span>
        <span class="s1">time_stamp = datetime(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">29</span><span class="s0">, </span><span class="s3">14</span><span class="s0">, </span><span class="s3">21</span><span class="s1">)</span>
        <span class="s1">data_label = </span><span class="s2">&quot;This is a data file.&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(</span>
                <span class="s1">path</span><span class="s0">, </span><span class="s1">time_stamp=time_stamp</span><span class="s0">, </span><span class="s1">data_label=data_label</span><span class="s0">, </span><span class="s1">version=version</span>
            <span class="s1">)</span>

            <span class="s0">with </span><span class="s1">StataReader(path) </span><span class="s0">as </span><span class="s1">reader:</span>
                <span class="s0">assert </span><span class="s1">reader.time_stamp == </span><span class="s2">&quot;29 Feb 2000 14:21&quot;</span>
                <span class="s0">assert </span><span class="s1">reader.data_label == data_label</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_invalid_timestamp(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">original = DataFrame([(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;variable&quot;</span><span class="s1">])</span>
        <span class="s1">time_stamp = </span><span class="s2">&quot;01 Jan 2000, 00:00:00&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">msg = </span><span class="s2">&quot;time_stamp should be datetime type&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">time_stamp=time_stamp</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s0">assert not </span><span class="s1">os.path.isfile(path)</span>

    <span class="s0">def </span><span class="s1">test_numeric_column_names(self):</span>
        <span class="s1">original = DataFrame(np.reshape(np.arange(</span><span class="s3">25.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)))</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s4"># should get a warning for that format.</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(InvalidColumnName):</span>
                <span class="s1">original.to_stata(path)</span>

            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">written_and_read_again = written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
            <span class="s1">columns = list(written_and_read_again.columns)</span>
            <span class="s1">convert_col_name = </span><span class="s0">lambda </span><span class="s1">x: int(x[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">written_and_read_again.columns = map(convert_col_name</span><span class="s0">, </span><span class="s1">columns)</span>
            <span class="s1">tm.assert_frame_equal(original</span><span class="s0">, </span><span class="s1">written_and_read_again)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_nan_to_missing_value(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">s1 = Series(np.arange(</span><span class="s3">4.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">s2 = Series(np.arange(</span><span class="s3">4.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">s1[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
        <span class="s1">s2[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
        <span class="s1">original = DataFrame({</span><span class="s2">&quot;s1&quot;</span><span class="s1">: s1</span><span class="s0">, </span><span class="s2">&quot;s2&quot;</span><span class="s1">: s2})</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">written_and_read_again = written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again</span><span class="s0">, </span><span class="s1">original)</span>

    <span class="s0">def </span><span class="s1">test_no_index(self):</span>
        <span class="s1">columns = [</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
        <span class="s1">original = DataFrame(np.reshape(np.arange(</span><span class="s3">10.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index_not_written&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(KeyError</span><span class="s0">, </span><span class="s1">match=original.index.name):</span>
                <span class="s1">written_and_read_again[</span><span class="s2">&quot;index_not_written&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_string_no_dates(self):</span>
        <span class="s1">s1 = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;A longer string&quot;</span><span class="s1">])</span>
        <span class="s1">s2 = Series([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">original = DataFrame({</span><span class="s2">&quot;s1&quot;</span><span class="s1">: s1</span><span class="s0">, </span><span class="s2">&quot;s2&quot;</span><span class="s1">: s2})</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">original)</span>

    <span class="s0">def </span><span class="s1">test_large_value_conversion(self):</span>
        <span class="s1">s0 = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">99</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span>
        <span class="s1">s1 = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">127</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span>
        <span class="s1">s2 = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">15 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">s3 = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">original = DataFrame({</span><span class="s2">&quot;s0&quot;</span><span class="s1">: s0</span><span class="s0">, </span><span class="s2">&quot;s1&quot;</span><span class="s1">: s1</span><span class="s0">, </span><span class="s2">&quot;s2&quot;</span><span class="s1">: s2</span><span class="s0">, </span><span class="s2">&quot;s3&quot;</span><span class="s1">: s3})</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(PossiblePrecisionLoss):</span>
                <span class="s1">original.to_stata(path)</span>

            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">modified = original.copy()</span>
            <span class="s1">modified[</span><span class="s2">&quot;s1&quot;</span><span class="s1">] = Series(modified[</span><span class="s2">&quot;s1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
            <span class="s1">modified[</span><span class="s2">&quot;s2&quot;</span><span class="s1">] = Series(modified[</span><span class="s2">&quot;s2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
            <span class="s1">modified[</span><span class="s2">&quot;s3&quot;</span><span class="s1">] = Series(modified[</span><span class="s2">&quot;s3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">modified)</span>

    <span class="s0">def </span><span class="s1">test_dates_invalid_column(self):</span>
        <span class="s1">original = DataFrame([datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">19</span><span class="s0">, </span><span class="s3">23</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)])</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(InvalidColumnName):</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">{</span><span class="s3">0</span><span class="s1">: </span><span class="s2">&quot;tc&quot;</span><span class="s1">})</span>

            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">modified = original.copy()</span>
            <span class="s1">modified.columns = [</span><span class="s2">&quot;_0&quot;</span><span class="s1">]</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">modified)</span>

    <span class="s0">def </span><span class="s1">test_105(self):</span>
        <span class="s4"># Data obtained from:</span>
        <span class="s4"># http://go.worldbank.org/ZXY29PVJ21</span>
        <span class="s1">dpath = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;S4_EDUC1.dta&quot;</span><span class="s1">)</span>
        <span class="s1">df = read_stata(dpath)</span>
        <span class="s1">df0 = [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">]]</span>
        <span class="s1">df0 = DataFrame(df0)</span>
        <span class="s1">df0.columns = [</span><span class="s2">&quot;clustnum&quot;</span><span class="s0">, </span><span class="s2">&quot;pri_schl&quot;</span><span class="s0">, </span><span class="s2">&quot;psch_num&quot;</span><span class="s0">, </span><span class="s2">&quot;psch_dis&quot;</span><span class="s1">]</span>
        <span class="s1">df0[</span><span class="s2">&quot;clustnum&quot;</span><span class="s1">] = df0[</span><span class="s2">&quot;clustnum&quot;</span><span class="s1">].astype(np.int16)</span>
        <span class="s1">df0[</span><span class="s2">&quot;pri_schl&quot;</span><span class="s1">] = df0[</span><span class="s2">&quot;pri_schl&quot;</span><span class="s1">].astype(np.int8)</span>
        <span class="s1">df0[</span><span class="s2">&quot;psch_num&quot;</span><span class="s1">] = df0[</span><span class="s2">&quot;psch_num&quot;</span><span class="s1">].astype(np.int8)</span>
        <span class="s1">df0[</span><span class="s2">&quot;psch_dis&quot;</span><span class="s1">] = df0[</span><span class="s2">&quot;psch_dis&quot;</span><span class="s1">].astype(np.float32)</span>
        <span class="s1">tm.assert_frame_equal(df.head(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">df0)</span>

    <span class="s0">def </span><span class="s1">test_value_labels_old_format(self):</span>
        <span class="s4"># GH 19417</span>
        <span class="s4">#</span>
        <span class="s4"># Test that value_labels() returns an empty dict if the file format</span>
        <span class="s4"># predates supporting value labels.</span>
        <span class="s1">dpath = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s2">&quot;S4_EDUC1.dta&quot;</span><span class="s1">)</span>
        <span class="s1">reader = StataReader(dpath)</span>
        <span class="s0">assert </span><span class="s1">reader.value_labels() == {}</span>
        <span class="s1">reader.close()</span>

    <span class="s0">def </span><span class="s1">test_date_export_formats(self):</span>
        <span class="s1">columns = [</span><span class="s2">&quot;tc&quot;</span><span class="s0">, </span><span class="s2">&quot;td&quot;</span><span class="s0">, </span><span class="s2">&quot;tw&quot;</span><span class="s0">, </span><span class="s2">&quot;tm&quot;</span><span class="s0">, </span><span class="s2">&quot;tq&quot;</span><span class="s0">, </span><span class="s2">&quot;th&quot;</span><span class="s0">, </span><span class="s2">&quot;ty&quot;</span><span class="s1">]</span>
        <span class="s1">conversions = {c: c </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">columns}</span>
        <span class="s1">data = [datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">23</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)] * len(columns)</span>
        <span class="s1">original = DataFrame([data]</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">expected_values = [</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">23</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Time</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Day</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">19</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Week</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Month</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Quarter year</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Half year</span>
            <span class="s1">datetime(</span><span class="s3">2006</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]  </span><span class="s4"># Year</span>

        <span class="s1">expected = DataFrame([expected_values]</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">expected.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">conversions)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_write_missing_strings(self):</span>
        <span class="s1">original = DataFrame([[</span><span class="s2">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;foo&quot;</span><span class="s1">])</span>
        <span class="s1">expected = DataFrame([[</span><span class="s2">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;foo&quot;</span><span class="s1">])</span>
        <span class="s1">expected.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;byteorder&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_bool_uint(self</span><span class="s0">, </span><span class="s1">byteorder</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">s0 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">s1 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span>
        <span class="s1">s2 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">255</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span>
        <span class="s1">s3 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">15 </span><span class="s1">- </span><span class="s3">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint16)</span>
        <span class="s1">s4 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">16 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint16)</span>
        <span class="s1">s5 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">31 </span><span class="s1">- </span><span class="s3">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint32)</span>
        <span class="s1">s6 = Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">32 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint32)</span>

        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span><span class="s2">&quot;s0&quot;</span><span class="s1">: s0</span><span class="s0">, </span><span class="s2">&quot;s1&quot;</span><span class="s1">: s1</span><span class="s0">, </span><span class="s2">&quot;s2&quot;</span><span class="s1">: s2</span><span class="s0">, </span><span class="s2">&quot;s3&quot;</span><span class="s1">: s3</span><span class="s0">, </span><span class="s2">&quot;s4&quot;</span><span class="s1">: s4</span><span class="s0">, </span><span class="s2">&quot;s5&quot;</span><span class="s1">: s5</span><span class="s0">, </span><span class="s2">&quot;s6&quot;</span><span class="s1">: s6}</span>
        <span class="s1">)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">expected = original.copy()</span>
        <span class="s1">expected_types = (</span>
            <span class="s1">np.int8</span><span class="s0">,</span>
            <span class="s1">np.int8</span><span class="s0">,</span>
            <span class="s1">np.int16</span><span class="s0">,</span>
            <span class="s1">np.int16</span><span class="s0">,</span>
            <span class="s1">np.int32</span><span class="s0">,</span>
            <span class="s1">np.int32</span><span class="s0">,</span>
            <span class="s1">np.float64</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">for </span><span class="s1">c</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">zip(expected.columns</span><span class="s0">, </span><span class="s1">expected_types):</span>
            <span class="s1">expected[c] = expected[c].astype(t)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">byteorder=byteorder</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">written_and_read_again = written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(written_and_read_again</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_variable_labels(self):</span>
        <span class="s0">with </span><span class="s1">StataReader(self.dta16_115) </span><span class="s0">as </span><span class="s1">rdr:</span>
            <span class="s1">sr_115 = rdr.variable_labels()</span>
        <span class="s0">with </span><span class="s1">StataReader(self.dta16_117) </span><span class="s0">as </span><span class="s1">rdr:</span>
            <span class="s1">sr_117 = rdr.variable_labels()</span>
        <span class="s1">keys = (</span><span class="s2">&quot;var1&quot;</span><span class="s0">, </span><span class="s2">&quot;var2&quot;</span><span class="s0">, </span><span class="s2">&quot;var3&quot;</span><span class="s1">)</span>
        <span class="s1">labels = (</span><span class="s2">&quot;label1&quot;</span><span class="s0">, </span><span class="s2">&quot;label2&quot;</span><span class="s0">, </span><span class="s2">&quot;label3&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sr_115.items():</span>
            <span class="s0">assert </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sr_117</span>
            <span class="s0">assert </span><span class="s1">v == sr_117[k]</span>
            <span class="s0">assert </span><span class="s1">k </span><span class="s0">in </span><span class="s1">keys</span>
            <span class="s0">assert </span><span class="s1">v </span><span class="s0">in </span><span class="s1">labels</span>

    <span class="s0">def </span><span class="s1">test_minimal_size_col(self):</span>
        <span class="s1">str_lens = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">244</span><span class="s1">)</span>
        <span class="s1">s = {}</span>
        <span class="s0">for </span><span class="s1">str_len </span><span class="s0">in </span><span class="s1">str_lens:</span>
            <span class="s1">s[</span><span class="s2">&quot;s&quot; </span><span class="s1">+ str(str_len)] = Series(</span>
                <span class="s1">[</span><span class="s2">&quot;a&quot; </span><span class="s1">* str_len</span><span class="s0">, </span><span class="s2">&quot;b&quot; </span><span class="s1">* str_len</span><span class="s0">, </span><span class="s2">&quot;c&quot; </span><span class="s1">* str_len]</span>
            <span class="s1">)</span>
        <span class="s1">original = DataFrame(s)</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s0">with </span><span class="s1">StataReader(path) </span><span class="s0">as </span><span class="s1">sr:</span>
                <span class="s1">typlist = sr.typlist</span>
                <span class="s1">variables = sr.varlist</span>
                <span class="s1">formats = sr.fmtlist</span>
                <span class="s0">for </span><span class="s1">variable</span><span class="s0">, </span><span class="s1">fmt</span><span class="s0">, </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">zip(variables</span><span class="s0">, </span><span class="s1">formats</span><span class="s0">, </span><span class="s1">typlist):</span>
                    <span class="s0">assert </span><span class="s1">int(variable[</span><span class="s3">1</span><span class="s1">:]) == int(fmt[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">])</span>
                    <span class="s0">assert </span><span class="s1">int(variable[</span><span class="s3">1</span><span class="s1">:]) == typ</span>

    <span class="s0">def </span><span class="s1">test_excessively_long_string(self):</span>
        <span class="s1">str_lens = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">244</span><span class="s0">, </span><span class="s3">500</span><span class="s1">)</span>
        <span class="s1">s = {}</span>
        <span class="s0">for </span><span class="s1">str_len </span><span class="s0">in </span><span class="s1">str_lens:</span>
            <span class="s1">s[</span><span class="s2">&quot;s&quot; </span><span class="s1">+ str(str_len)] = Series(</span>
                <span class="s1">[</span><span class="s2">&quot;a&quot; </span><span class="s1">* str_len</span><span class="s0">, </span><span class="s2">&quot;b&quot; </span><span class="s1">* str_len</span><span class="s0">, </span><span class="s2">&quot;c&quot; </span><span class="s1">* str_len]</span>
            <span class="s1">)</span>
        <span class="s1">original = DataFrame(s)</span>
        <span class="s1">msg = (</span>
            <span class="s2">r&quot;Fixed width strings in Stata \.dta files are limited to 244 &quot;</span>
            <span class="s2">r&quot;\(or fewer\)\ncharacters\.  Column 's500' does not satisfy &quot;</span>
            <span class="s2">r&quot;this restriction\. Use the\n'version=117' parameter to write &quot;</span>
            <span class="s2">r&quot;the newer \(Stata 13 and later\) format\.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">original.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_missing_value_generator(self):</span>
        <span class="s1">types = (</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;h&quot;</span><span class="s0">, </span><span class="s2">&quot;l&quot;</span><span class="s1">)</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">0.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;float_&quot;</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">df.to_stata(path)</span>
            <span class="s0">with </span><span class="s1">StataReader(path) </span><span class="s0">as </span><span class="s1">rdr:</span>
                <span class="s1">valid_range = rdr.VALID_RANGE</span>
        <span class="s1">expected_values = [</span><span class="s2">&quot;.&quot; </span><span class="s1">+ chr(</span><span class="s3">97 </span><span class="s1">+ i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">26</span><span class="s1">)]</span>
        <span class="s1">expected_values.insert(</span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types:</span>
            <span class="s1">offset = valid_range[t][</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">27</span><span class="s1">):</span>
                <span class="s1">val = StataMissingValue(offset + </span><span class="s3">1 </span><span class="s1">+ i)</span>
                <span class="s0">assert </span><span class="s1">val.string == expected_values[i]</span>

        <span class="s4"># Test extremes for floats</span>
        <span class="s1">val = StataMissingValue(struct.unpack(</span><span class="s2">&quot;&lt;f&quot;</span><span class="s0">, </span><span class="s5">b&quot;</span><span class="s0">\x00\x00\x00\x7f</span><span class="s5">&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">val.string == </span><span class="s2">&quot;.&quot;</span>
        <span class="s1">val = StataMissingValue(struct.unpack(</span><span class="s2">&quot;&lt;f&quot;</span><span class="s0">, </span><span class="s5">b&quot;</span><span class="s0">\x00\xd0\x00\x7f</span><span class="s5">&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">val.string == </span><span class="s2">&quot;.z&quot;</span>

        <span class="s4"># Test extremes for floats</span>
        <span class="s1">val = StataMissingValue(</span>
            <span class="s1">struct.unpack(</span><span class="s2">&quot;&lt;d&quot;</span><span class="s0">, </span><span class="s5">b&quot;</span><span class="s0">\x00\x00\x00\x00\x00\x00\xe0\x7f</span><span class="s5">&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">val.string == </span><span class="s2">&quot;.&quot;</span>
        <span class="s1">val = StataMissingValue(</span>
            <span class="s1">struct.unpack(</span><span class="s2">&quot;&lt;d&quot;</span><span class="s0">, </span><span class="s5">b&quot;</span><span class="s0">\x00\x00\x00\x00\x00\x1a\xe0\x7f</span><span class="s5">&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">val.string == </span><span class="s2">&quot;.z&quot;</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta17_113&quot;</span><span class="s0">, </span><span class="s2">&quot;dta17_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta17_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_missing_value_conversion(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s1">columns = [</span><span class="s2">&quot;int8_&quot;</span><span class="s0">, </span><span class="s2">&quot;int16_&quot;</span><span class="s0">, </span><span class="s2">&quot;int32_&quot;</span><span class="s0">, </span><span class="s2">&quot;float32_&quot;</span><span class="s0">, </span><span class="s2">&quot;float64_&quot;</span><span class="s1">]</span>
        <span class="s1">smv = StataMissingValue(</span><span class="s3">101</span><span class="s1">)</span>
        <span class="s1">keys = sorted(smv.MISSING_VALUES.keys())</span>
        <span class="s1">data = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">27</span><span class="s1">):</span>
            <span class="s1">row = [StataMissingValue(keys[i + (j * </span><span class="s3">27</span><span class="s1">)]) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)]</span>
            <span class="s1">data.append(row)</span>
        <span class="s1">expected = DataFrame(data</span><span class="s0">, </span><span class="s1">columns=columns)</span>

        <span class="s1">parsed = read_stata(getattr(self</span><span class="s0">, </span><span class="s1">file)</span><span class="s0">, </span><span class="s1">convert_missing=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_big_dates(self):</span>
        <span class="s1">yr = [</span><span class="s3">1960</span><span class="s0">, </span><span class="s3">2000</span><span class="s0">, </span><span class="s3">9999</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">2262</span><span class="s0">, </span><span class="s3">1677</span><span class="s1">]</span>
        <span class="s1">mo = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span>
        <span class="s1">dd = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">31</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">22</span><span class="s0">, </span><span class="s3">23</span><span class="s1">]</span>
        <span class="s1">hr = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">23</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">mm = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">59</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">ss = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">59</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">expected = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(yr)):</span>
            <span class="s1">row = []</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">7</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">j == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">row.append(datetime(yr[i]</span><span class="s0">, </span><span class="s1">mo[i]</span><span class="s0">, </span><span class="s1">dd[i]</span><span class="s0">, </span><span class="s1">hr[i]</span><span class="s0">, </span><span class="s1">mm[i]</span><span class="s0">, </span><span class="s1">ss[i]))</span>
                <span class="s0">elif </span><span class="s1">j == </span><span class="s3">6</span><span class="s1">:</span>
                    <span class="s1">row.append(datetime(yr[i]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">row.append(datetime(yr[i]</span><span class="s0">, </span><span class="s1">mo[i]</span><span class="s0">, </span><span class="s1">dd[i]))</span>
            <span class="s1">expected.append(row)</span>
        <span class="s1">expected.append([pd.NaT] * </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">columns = [</span>
            <span class="s2">&quot;date_tc&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date_td&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date_tw&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date_tm&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date_tq&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date_th&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date_ty&quot;</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s4"># Fixes for weekly, quarterly,half,year</span>
        <span class="s1">expected[</span><span class="s3">2</span><span class="s1">][</span><span class="s3">2</span><span class="s1">] = datetime(</span><span class="s3">9999</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">2</span><span class="s1">][</span><span class="s3">3</span><span class="s1">] = datetime(</span><span class="s3">9999</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">2</span><span class="s1">][</span><span class="s3">4</span><span class="s1">] = datetime(</span><span class="s3">9999</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">2</span><span class="s1">][</span><span class="s3">5</span><span class="s1">] = datetime(</span><span class="s3">9999</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">4</span><span class="s1">][</span><span class="s3">2</span><span class="s1">] = datetime(</span><span class="s3">2262</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">4</span><span class="s1">][</span><span class="s3">3</span><span class="s1">] = expected[</span><span class="s3">4</span><span class="s1">][</span><span class="s3">4</span><span class="s1">] = datetime(</span><span class="s3">2262</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">4</span><span class="s1">][</span><span class="s3">5</span><span class="s1">] = expected[</span><span class="s3">4</span><span class="s1">][</span><span class="s3">6</span><span class="s1">] = datetime(</span><span class="s3">2262</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">5</span><span class="s1">][</span><span class="s3">2</span><span class="s1">] = expected[</span><span class="s3">5</span><span class="s1">][</span><span class="s3">3</span><span class="s1">] = expected[</span><span class="s3">5</span><span class="s1">][</span><span class="s3">4</span><span class="s1">] = datetime(</span><span class="s3">1677</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s3">5</span><span class="s1">][</span><span class="s3">5</span><span class="s1">] = expected[</span><span class="s3">5</span><span class="s1">][</span><span class="s3">6</span><span class="s1">] = datetime(</span><span class="s3">1678</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">expected = DataFrame(expected</span><span class="s0">, </span><span class="s1">columns=columns</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">parsed_115 = read_stata(self.dta18_115)</span>
        <span class="s1">parsed_117 = read_stata(self.dta18_117)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">parsed_115</span><span class="s0">, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">parsed_117</span><span class="s0">, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">date_conversion = {c: c[-</span><span class="s3">2</span><span class="s1">:] </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">columns}</span>
        <span class="s4"># {c : c[-2:] for c in columns}</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">expected.index.name = </span><span class="s2">&quot;index&quot;</span>
            <span class="s1">expected.to_stata(path</span><span class="s0">, </span><span class="s1">date_conversion)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">tm.assert_frame_equal(</span>
                <span class="s1">written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">expected</span><span class="s0">,</span>
                <span class="s1">check_datetimelike_compat=</span><span class="s0">True,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_dtype_conversion(self):</span>
        <span class="s1">expected = self.read_csv(self.csv15)</span>
        <span class="s1">expected[</span><span class="s2">&quot;byte_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;byte_&quot;</span><span class="s1">].astype(np.int8)</span>
        <span class="s1">expected[</span><span class="s2">&quot;int_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;int_&quot;</span><span class="s1">].astype(np.int16)</span>
        <span class="s1">expected[</span><span class="s2">&quot;long_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;long_&quot;</span><span class="s1">].astype(np.int32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">].astype(np.float32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;double_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;double_&quot;</span><span class="s1">].astype(np.float64)</span>
        <span class="s1">expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">].apply(</span>
            <span class="s1">datetime.strptime</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">no_conversion = read_stata(self.dta15_117</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">no_conversion)</span>

        <span class="s1">conversion = read_stata(</span>
            <span class="s1">self.dta15_117</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True, </span><span class="s1">preserve_dtypes=</span><span class="s0">False</span>
        <span class="s1">)</span>

        <span class="s4"># read_csv types are the same</span>
        <span class="s1">expected = self.read_csv(self.csv15)</span>
        <span class="s1">expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">].apply(</span>
            <span class="s1">datetime.strptime</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">conversion)</span>

    <span class="s0">def </span><span class="s1">test_drop_column(self):</span>
        <span class="s1">expected = self.read_csv(self.csv15)</span>
        <span class="s1">expected[</span><span class="s2">&quot;byte_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;byte_&quot;</span><span class="s1">].astype(np.int8)</span>
        <span class="s1">expected[</span><span class="s2">&quot;int_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;int_&quot;</span><span class="s1">].astype(np.int16)</span>
        <span class="s1">expected[</span><span class="s2">&quot;long_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;long_&quot;</span><span class="s1">].astype(np.int32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;float_&quot;</span><span class="s1">].astype(np.float32)</span>
        <span class="s1">expected[</span><span class="s2">&quot;double_&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;double_&quot;</span><span class="s1">].astype(np.float64)</span>
        <span class="s1">expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;date_td&quot;</span><span class="s1">].apply(</span>
            <span class="s1">datetime.strptime</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">columns = [</span><span class="s2">&quot;byte_&quot;</span><span class="s0">, </span><span class="s2">&quot;int_&quot;</span><span class="s0">, </span><span class="s2">&quot;long_&quot;</span><span class="s1">]</span>
        <span class="s1">expected = expected[columns]</span>
        <span class="s1">dropped = read_stata(self.dta15_117</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True, </span><span class="s1">columns=columns)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">dropped)</span>

        <span class="s4"># See PR 10757</span>
        <span class="s1">columns = [</span><span class="s2">&quot;int_&quot;</span><span class="s0">, </span><span class="s2">&quot;long_&quot;</span><span class="s0">, </span><span class="s2">&quot;byte_&quot;</span><span class="s1">]</span>
        <span class="s1">expected = expected[columns]</span>
        <span class="s1">reordered = read_stata(self.dta15_117</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True, </span><span class="s1">columns=columns)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">reordered)</span>

        <span class="s1">msg = </span><span class="s2">&quot;columns contains duplicate entries&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">columns = [</span><span class="s2">&quot;byte_&quot;</span><span class="s0">, </span><span class="s2">&quot;byte_&quot;</span><span class="s1">]</span>
            <span class="s1">read_stata(self.dta15_117</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True, </span><span class="s1">columns=columns)</span>

        <span class="s1">msg = </span><span class="s2">&quot;The following columns were not found in the Stata data set: not_found&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">columns = [</span><span class="s2">&quot;byte_&quot;</span><span class="s0">, </span><span class="s2">&quot;int_&quot;</span><span class="s0">, </span><span class="s2">&quot;long_&quot;</span><span class="s0">, </span><span class="s2">&quot;not_found&quot;</span><span class="s1">]</span>
            <span class="s1">read_stata(self.dta15_117</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True, </span><span class="s1">columns=columns)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.filterwarnings(</span>
        <span class="s2">&quot;ignore:</span><span class="s0">\\</span><span class="s2">nStata value:pandas.io.stata.ValueLabelTypeMismatch&quot;</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_categorical_writing(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">original = DataFrame.from_records(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;nine&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s2">&quot;seven&quot;</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;five&quot;</span><span class="s0">, </span><span class="s2">&quot;six&quot;</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;five&quot;</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;six&quot;</span><span class="s0">, </span><span class="s2">&quot;five&quot;</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;six&quot;</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;seven&quot;</span><span class="s0">, </span><span class="s2">&quot;four&quot;</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;seven&quot;</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;nine&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;nine&quot;</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;ten&quot;</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;fully_labeled&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;fully_labeled2&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;incompletely_labeled&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;labeled_with_missings&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float_labelled&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;unlabeled&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = original.copy()</span>

        <span class="s4"># these are all categoricals</span>
        <span class="s1">original = pd.concat(</span>
            <span class="s1">[original[col].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">original]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span>
        <span class="s1">)</span>
        <span class="s1">expected.index.name = </span><span class="s2">&quot;index&quot;</span>

        <span class="s1">expected[</span><span class="s2">&quot;incompletely_labeled&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;incompletely_labeled&quot;</span><span class="s1">].apply(str)</span>
        <span class="s1">expected[</span><span class="s2">&quot;unlabeled&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;unlabeled&quot;</span><span class="s1">].apply(str)</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">expected:</span>
            <span class="s1">orig = expected[col].copy()</span>

            <span class="s1">cat = orig.astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)._values</span>
            <span class="s1">cat = cat.as_ordered()</span>
            <span class="s0">if </span><span class="s1">col == </span><span class="s2">&quot;unlabeled&quot;</span><span class="s1">:</span>
                <span class="s1">cat = cat.set_categories(orig</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">cat.categories.rename(</span><span class="s0">None, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">expected[col] = cat</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">res = written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_categorical_warnings_and_errors(self):</span>
        <span class="s4"># Warning for non-string labels</span>
        <span class="s4"># Error for labels too long</span>
        <span class="s1">original = DataFrame.from_records(</span>
            <span class="s1">[[</span><span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s3">10000</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot; </span><span class="s1">* </span><span class="s3">10000</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot; </span><span class="s1">* </span><span class="s3">10000</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;d&quot; </span><span class="s1">* </span><span class="s3">10000</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;Too_long&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">original = pd.concat(</span>
            <span class="s1">[original[col].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">original]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;Stata value labels for a single variable must have &quot;</span>
                <span class="s2">r&quot;a combined length less than 32,000 characters\.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">original.to_stata(path)</span>

        <span class="s1">original = DataFrame.from_records(</span>
            <span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Too_long&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">original = pd.concat(</span>
            <span class="s1">[original[col].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">original]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(ValueLabelTypeMismatch):</span>
            <span class="s1">original.to_stata(path)</span>
            <span class="s4"># should get a warning for mixed content</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_categorical_with_stata_missing_values(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">values = [[</span><span class="s2">&quot;a&quot; </span><span class="s1">+ str(i)] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">120</span><span class="s1">)]</span>
        <span class="s1">values.append([np.nan])</span>
        <span class="s1">original = DataFrame.from_records(values</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;many_labels&quot;</span><span class="s1">])</span>
        <span class="s1">original = pd.concat(</span>
            <span class="s1">[original[col].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">original]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span>
        <span class="s1">)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s1">res = written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>

            <span class="s1">expected = original.copy()</span>
            <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">expected:</span>
                <span class="s1">cat = expected[col]._values</span>
                <span class="s1">new_cats = cat.remove_unused_categories().categories</span>
                <span class="s1">cat = cat.set_categories(new_cats</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">expected[col] = cat</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta19_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta19_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_categorical_order(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s4"># Directly construct using expected codes</span>
        <span class="s4"># Format is is_cat, col_name, labels (in order), underlying data</span>
        <span class="s1">expected = [</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;ordered&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;reverse&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">5</span><span class="s1">)[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;noorder&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;floating&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;float_missing&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">False, </span><span class="s2">&quot;nolabel&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;int32_mixed&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">cols = []</span>
        <span class="s0">for </span><span class="s1">is_cat</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">codes </span><span class="s0">in </span><span class="s1">expected:</span>
            <span class="s0">if </span><span class="s1">is_cat:</span>
                <span class="s1">cols.append(</span>
                    <span class="s1">(col</span><span class="s0">, </span><span class="s1">pd.Categorical.from_codes(codes</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">))</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">cols.append((col</span><span class="s0">, </span><span class="s1">Series(labels</span><span class="s0">, </span><span class="s1">dtype=np.float32)))</span>
        <span class="s1">expected = DataFrame.from_dict(dict(cols))</span>

        <span class="s4"># Read with and with out categoricals, ensure order is identical</span>
        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = read_stata(file)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">parsed)</span>

        <span class="s4"># Check identity of codes</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">expected:</span>
            <span class="s0">if </span><span class="s1">is_categorical_dtype(expected[col].dtype):</span>
                <span class="s1">tm.assert_series_equal(expected[col].cat.codes</span><span class="s0">, </span><span class="s1">parsed[col].cat.codes)</span>
                <span class="s1">tm.assert_index_equal(</span>
                    <span class="s1">expected[col].cat.categories</span><span class="s0">, </span><span class="s1">parsed[col].cat.categories</span>
                <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta20_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta20_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_categorical_sorting(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s1">parsed = read_stata(getattr(self</span><span class="s0">, </span><span class="s1">file))</span>

        <span class="s4"># Sort based on codes, not strings</span>
        <span class="s1">parsed = parsed.sort_values(</span><span class="s2">&quot;srh&quot;</span><span class="s0">, </span><span class="s1">na_position=</span><span class="s2">&quot;first&quot;</span><span class="s1">)</span>

        <span class="s4"># Don't sort index</span>
        <span class="s1">parsed.index = np.arange(parsed.shape[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">codes = [-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">categories = [</span><span class="s2">&quot;Poor&quot;</span><span class="s0">, </span><span class="s2">&quot;Fair&quot;</span><span class="s0">, </span><span class="s2">&quot;Good&quot;</span><span class="s0">, </span><span class="s2">&quot;Very good&quot;</span><span class="s0">, </span><span class="s2">&quot;Excellent&quot;</span><span class="s1">]</span>
        <span class="s1">cat = pd.Categorical.from_codes(</span>
            <span class="s1">codes=codes</span><span class="s0">, </span><span class="s1">categories=categories</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">expected = Series(cat</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;srh&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(expected</span><span class="s0">, </span><span class="s1">parsed[</span><span class="s2">&quot;srh&quot;</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;dta19_115&quot;</span><span class="s0">, </span><span class="s2">&quot;dta19_117&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_categorical_ordering(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s1">file = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s1">parsed = read_stata(file)</span>

        <span class="s1">parsed_unordered = read_stata(file</span><span class="s0">, </span><span class="s1">order_categoricals=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">parsed:</span>
            <span class="s0">if not </span><span class="s1">is_categorical_dtype(parsed[col].dtype):</span>
                <span class="s0">continue</span>
            <span class="s0">assert </span><span class="s1">parsed[col].cat.ordered</span>
            <span class="s0">assert not </span><span class="s1">parsed_unordered[col].cat.ordered</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;file&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s2">&quot;dta1_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta2_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta3_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta4_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta14_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta15_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta16_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta17_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta18_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta19_117&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta20_117&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;chunksize&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_categoricals&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_dates&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_chunks_117(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">file</span><span class="s0">, </span><span class="s1">chunksize</span><span class="s0">, </span><span class="s1">convert_categoricals</span><span class="s0">, </span><span class="s1">convert_dates</span>
    <span class="s1">):</span>
        <span class="s1">fname = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">parsed = read_stata(</span>
                <span class="s1">fname</span><span class="s0">,</span>
                <span class="s1">convert_categoricals=convert_categoricals</span><span class="s0">,</span>
                <span class="s1">convert_dates=convert_dates</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">itr = read_stata(</span>
            <span class="s1">fname</span><span class="s0">,</span>
            <span class="s1">iterator=</span><span class="s0">True,</span>
            <span class="s1">convert_categoricals=convert_categoricals</span><span class="s0">,</span>
            <span class="s1">convert_dates=convert_dates</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">pos = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">chunk = itr.read(chunksize)</span>
                <span class="s0">except </span><span class="s1">StopIteration:</span>
                    <span class="s0">break</span>
            <span class="s1">from_frame = parsed.iloc[pos : pos + chunksize</span><span class="s0">, </span><span class="s1">:].copy()</span>
            <span class="s1">from_frame = self._convert_categorical(from_frame)</span>
            <span class="s1">tm.assert_frame_equal(</span>
                <span class="s1">from_frame</span><span class="s0">, </span><span class="s1">chunk</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span>
            <span class="s1">)</span>

            <span class="s1">pos += chunksize</span>
        <span class="s1">itr.close()</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_convert_categorical(from_frame: DataFrame) -&gt; DataFrame:</span>
        <span class="s6">&quot;&quot;&quot; 
        Emulate the categorical casting behavior we expect from roundtripping. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">from_frame:</span>
            <span class="s1">ser = from_frame[col]</span>
            <span class="s0">if </span><span class="s1">is_categorical_dtype(ser.dtype):</span>
                <span class="s1">cat = ser._values.remove_unused_categories()</span>
                <span class="s0">if </span><span class="s1">cat.categories.dtype == object:</span>
                    <span class="s1">categories = ensure_index(cat.categories._values)</span>
                    <span class="s1">cat = cat.set_categories(categories)</span>
                <span class="s1">from_frame[col] = cat</span>
        <span class="s0">return </span><span class="s1">from_frame</span>

    <span class="s0">def </span><span class="s1">test_iterator(self):</span>

        <span class="s1">fname = self.dta3_117</span>

        <span class="s1">parsed = read_stata(fname)</span>

        <span class="s0">with </span><span class="s1">read_stata(fname</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">itr:</span>
            <span class="s1">chunk = itr.read(</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(parsed.iloc[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">5</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">chunk)</span>

        <span class="s0">with </span><span class="s1">read_stata(fname</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">5</span><span class="s1">) </span><span class="s0">as </span><span class="s1">itr:</span>
            <span class="s1">chunk = list(itr)</span>
            <span class="s1">tm.assert_frame_equal(parsed.iloc[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">5</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">chunk[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">read_stata(fname</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">itr:</span>
            <span class="s1">chunk = itr.get_chunk(</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(parsed.iloc[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">5</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">chunk)</span>

        <span class="s0">with </span><span class="s1">read_stata(fname</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">5</span><span class="s1">) </span><span class="s0">as </span><span class="s1">itr:</span>
            <span class="s1">chunk = itr.get_chunk()</span>
            <span class="s1">tm.assert_frame_equal(parsed.iloc[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">5</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">chunk)</span>

        <span class="s4"># GH12153</span>
        <span class="s0">with </span><span class="s1">read_stata(fname</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">4</span><span class="s1">) </span><span class="s0">as </span><span class="s1">itr:</span>
            <span class="s1">from_chunks = pd.concat(itr)</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">from_chunks)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;file&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s2">&quot;dta2_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta3_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta4_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta14_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta15_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta16_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta17_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta18_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta19_115&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dta20_115&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;chunksize&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_categoricals&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_dates&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_chunks_115(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">file</span><span class="s0">, </span><span class="s1">chunksize</span><span class="s0">, </span><span class="s1">convert_categoricals</span><span class="s0">, </span><span class="s1">convert_dates</span>
    <span class="s1">):</span>
        <span class="s1">fname = getattr(self</span><span class="s0">, </span><span class="s1">file)</span>

        <span class="s4"># Read the whole file</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">parsed = read_stata(</span>
                <span class="s1">fname</span><span class="s0">,</span>
                <span class="s1">convert_categoricals=convert_categoricals</span><span class="s0">,</span>
                <span class="s1">convert_dates=convert_dates</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s4"># Compare to what we get when reading by chunk</span>
        <span class="s1">itr = read_stata(</span>
            <span class="s1">fname</span><span class="s0">,</span>
            <span class="s1">iterator=</span><span class="s0">True,</span>
            <span class="s1">convert_dates=convert_dates</span><span class="s0">,</span>
            <span class="s1">convert_categoricals=convert_categoricals</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">pos = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">chunk = itr.read(chunksize)</span>
                <span class="s0">except </span><span class="s1">StopIteration:</span>
                    <span class="s0">break</span>
            <span class="s1">from_frame = parsed.iloc[pos : pos + chunksize</span><span class="s0">, </span><span class="s1">:].copy()</span>
            <span class="s1">from_frame = self._convert_categorical(from_frame)</span>
            <span class="s1">tm.assert_frame_equal(</span>
                <span class="s1">from_frame</span><span class="s0">, </span><span class="s1">chunk</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False, </span><span class="s1">check_datetimelike_compat=</span><span class="s0">True</span>
            <span class="s1">)</span>

            <span class="s1">pos += chunksize</span>
        <span class="s1">itr.close()</span>

    <span class="s0">def </span><span class="s1">test_read_chunks_columns(self):</span>
        <span class="s1">fname = self.dta3_117</span>
        <span class="s1">columns = [</span><span class="s2">&quot;quarter&quot;</span><span class="s0">, </span><span class="s2">&quot;cpi&quot;</span><span class="s0">, </span><span class="s2">&quot;m1&quot;</span><span class="s1">]</span>
        <span class="s1">chunksize = </span><span class="s3">2</span>

        <span class="s1">parsed = read_stata(fname</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s0">with </span><span class="s1">read_stata(fname</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">itr:</span>
            <span class="s1">pos = </span><span class="s3">0</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">):</span>
                <span class="s1">chunk = itr.read(chunksize</span><span class="s0">, </span><span class="s1">columns=columns)</span>
                <span class="s0">if </span><span class="s1">chunk </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">break</span>
                <span class="s1">from_frame = parsed.iloc[pos : pos + chunksize</span><span class="s0">, </span><span class="s1">:]</span>
                <span class="s1">tm.assert_frame_equal(from_frame</span><span class="s0">, </span><span class="s1">chunk</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">pos += chunksize</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_write_variable_labels(self</span><span class="s0">, </span><span class="s1">version</span><span class="s0">, </span><span class="s1">mixed_frame):</span>
        <span class="s4"># GH 13631, add support for writing variable labels</span>
        <span class="s1">mixed_frame.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">variable_labels = {</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;City Rank&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;City Exponent&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;City&quot;</span><span class="s1">}</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">mixed_frame.to_stata(path</span><span class="s0">, </span><span class="s1">variable_labels=variable_labels</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s0">with </span><span class="s1">StataReader(path) </span><span class="s0">as </span><span class="s1">sr:</span>
                <span class="s1">read_labels = sr.variable_labels()</span>
            <span class="s1">expected_labels = {</span>
                <span class="s2">&quot;index&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;City Rank&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;City Exponent&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;City&quot;</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s0">assert </span><span class="s1">read_labels == expected_labels</span>

        <span class="s1">variable_labels[</span><span class="s2">&quot;index&quot;</span><span class="s1">] = </span><span class="s2">&quot;The Index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">mixed_frame.to_stata(path</span><span class="s0">, </span><span class="s1">variable_labels=variable_labels</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s0">with </span><span class="s1">StataReader(path) </span><span class="s0">as </span><span class="s1">sr:</span>
                <span class="s1">read_labels = sr.variable_labels()</span>
            <span class="s0">assert </span><span class="s1">read_labels == variable_labels</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_invalid_variable_labels(self</span><span class="s0">, </span><span class="s1">version</span><span class="s0">, </span><span class="s1">mixed_frame):</span>
        <span class="s1">mixed_frame.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">variable_labels = {</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;very long&quot; </span><span class="s1">* </span><span class="s3">10</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;City Exponent&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;City&quot;</span><span class="s1">}</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">msg = </span><span class="s2">&quot;Variable labels must be 80 characters or fewer&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">mixed_frame.to_stata(</span>
                    <span class="s1">path</span><span class="s0">, </span><span class="s1">variable_labels=variable_labels</span><span class="s0">, </span><span class="s1">version=version</span>
                <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_invalid_variable_label_encoding(self</span><span class="s0">, </span><span class="s1">version</span><span class="s0">, </span><span class="s1">mixed_frame):</span>
        <span class="s1">mixed_frame.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">variable_labels = {</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;very long&quot; </span><span class="s1">* </span><span class="s3">10</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;City Exponent&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;City&quot;</span><span class="s1">}</span>
        <span class="s1">variable_labels[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = </span><span class="s2">&quot;invalid character Œ&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(</span>
                <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Variable labels must contain only characters&quot;</span>
            <span class="s1">):</span>
                <span class="s1">mixed_frame.to_stata(</span>
                    <span class="s1">path</span><span class="s0">, </span><span class="s1">variable_labels=variable_labels</span><span class="s0">, </span><span class="s1">version=version</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_write_variable_label_errors(self</span><span class="s0">, </span><span class="s1">mixed_frame):</span>
        <span class="s1">values = [</span><span class="s2">&quot;</span><span class="s0">\u03A1</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\u0391</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\u039D</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\u0394</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\u0391</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\u03A3</span><span class="s2">&quot;</span><span class="s1">]</span>

        <span class="s1">variable_labels_utf8 = {</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;City Rank&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;City Exponent&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">.join(values)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">msg = (</span>
            <span class="s2">&quot;Variable labels must contain only characters that can be &quot;</span>
            <span class="s2">&quot;encoded in Latin-1&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">mixed_frame.to_stata(path</span><span class="s0">, </span><span class="s1">variable_labels=variable_labels_utf8)</span>

        <span class="s1">variable_labels_long = {</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;City Rank&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;City Exponent&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;A very, very, very long variable label &quot;</span>
            <span class="s2">&quot;that is too long for Stata which means &quot;</span>
            <span class="s2">&quot;that it has more than 80 characters&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">msg = </span><span class="s2">&quot;Variable labels must be 80 characters or fewer&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">mixed_frame.to_stata(path</span><span class="s0">, </span><span class="s1">variable_labels=variable_labels_long)</span>

    <span class="s0">def </span><span class="s1">test_default_date_conversion(self):</span>
        <span class="s4"># GH 12259</span>
        <span class="s1">dates = [</span>
            <span class="s1">dt.datetime(</span><span class="s3">1999</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">31</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">dt.datetime(</span><span class="s3">2012</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">dt.datetime(</span><span class="s3">1776</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4000</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;nums&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;strs&quot;</span><span class="s1">: [</span><span class="s2">&quot;apple&quot;</span><span class="s0">, </span><span class="s2">&quot;banana&quot;</span><span class="s0">, </span><span class="s2">&quot;cherry&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;dates&quot;</span><span class="s1">: dates</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">reread = read_stata(path</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(original</span><span class="s0">, </span><span class="s1">reread)</span>

            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">convert_dates={</span><span class="s2">&quot;dates&quot;</span><span class="s1">: </span><span class="s2">&quot;tc&quot;</span><span class="s1">})</span>
            <span class="s1">direct = read_stata(path</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">direct)</span>

            <span class="s1">dates_idx = original.columns.tolist().index(</span><span class="s2">&quot;dates&quot;</span><span class="s1">)</span>
            <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">convert_dates={dates_idx: </span><span class="s2">&quot;tc&quot;</span><span class="s1">})</span>
            <span class="s1">direct = read_stata(path</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">direct)</span>

    <span class="s0">def </span><span class="s1">test_unsupported_type(self):</span>
        <span class="s1">original = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1 </span><span class="s1">+ </span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">4j</span><span class="s1">]})</span>

        <span class="s1">msg = </span><span class="s2">&quot;Data type complex128 not supported&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">original.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_unsupported_datetype(self):</span>
        <span class="s1">dates = [</span>
            <span class="s1">dt.datetime(</span><span class="s3">1999</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">31</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">dt.datetime(</span><span class="s3">2012</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">dt.datetime(</span><span class="s3">1776</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4000</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;nums&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;strs&quot;</span><span class="s1">: [</span><span class="s2">&quot;apple&quot;</span><span class="s0">, </span><span class="s2">&quot;banana&quot;</span><span class="s0">, </span><span class="s2">&quot;cherry&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;dates&quot;</span><span class="s1">: dates</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Format %tC not implemented&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">convert_dates={</span><span class="s2">&quot;dates&quot;</span><span class="s1">: </span><span class="s2">&quot;tC&quot;</span><span class="s1">})</span>

        <span class="s1">dates = pd.date_range(</span><span class="s2">&quot;1-1-1990&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;Asia/Hong_Kong&quot;</span><span class="s1">)</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;nums&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;strs&quot;</span><span class="s1">: [</span><span class="s2">&quot;apple&quot;</span><span class="s0">, </span><span class="s2">&quot;banana&quot;</span><span class="s0">, </span><span class="s2">&quot;cherry&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;dates&quot;</span><span class="s1">: dates</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Data type datetime64&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">original.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_repeated_column_labels(self):</span>
        <span class="s4"># GH 13923, 25772</span>
        <span class="s1">msg = </span><span class="s2">&quot;&quot;&quot; 
Value labels for column ethnicsn are not unique. These cannot be converted to 
pandas categoricals. 
 
Either read the file with `convert_categoricals` set to False or use the 
low level interface in `StataReader` to separately read the values and the 
value_labels. 
 
The repeated labels are:</span><span class="s0">\n</span><span class="s2">-+</span><span class="s0">\n</span><span class="s2">wolof 
&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_stata(self.dta23</span><span class="s0">, </span><span class="s1">convert_categoricals=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_stata_111(self):</span>
        <span class="s4"># 111 is an old version but still used by current versions of</span>
        <span class="s4"># SAS when exporting to Stata format. We do not know of any</span>
        <span class="s4"># on-line documentation for this version.</span>
        <span class="s1">df = read_stata(self.dta24_111)</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.NaN</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.NaN</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;w&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.NaN</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;z&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;g&quot;</span><span class="s0">, </span><span class="s2">&quot;h&quot;</span><span class="s0">, </span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s2">&quot;j&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">original = original[[</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;w&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">]]</span>
        <span class="s1">tm.assert_frame_equal(original</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_out_of_range_double(self):</span>
        <span class="s4"># GH 14618</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;ColumnOk&quot;</span><span class="s1">: [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.finfo(np.double).eps</span><span class="s0">, </span><span class="s3">4.49423283715579e307</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;ColumnTooBig&quot;</span><span class="s1">: [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.finfo(np.double).eps</span><span class="s0">, </span><span class="s1">np.finfo(np.double).max]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">msg = (</span>
            <span class="s2">r&quot;Column ColumnTooBig has a maximum value \(.+\) outside the range &quot;</span>
            <span class="s2">r&quot;supported by Stata \(.+\)&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">df.to_stata(path)</span>

        <span class="s1">df.loc[</span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;ColumnTooBig&quot;</span><span class="s1">] = np.inf</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;Column ColumnTooBig has a maximum value of infinity which is outside &quot;</span>
            <span class="s2">&quot;the range supported by Stata&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">df.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_out_of_range_float(self):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;ColumnOk&quot;</span><span class="s1">: [</span>
                    <span class="s3">0.0</span><span class="s0">,</span>
                    <span class="s1">np.finfo(np.float32).eps</span><span class="s0">,</span>
                    <span class="s1">np.finfo(np.float32).max / </span><span class="s3">10.0</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;ColumnTooBig&quot;</span><span class="s1">: [</span>
                    <span class="s3">0.0</span><span class="s0">,</span>
                    <span class="s1">np.finfo(np.float32).eps</span><span class="s0">,</span>
                    <span class="s1">np.finfo(np.float32).max</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">original:</span>
            <span class="s1">original[col] = original[col].astype(np.float32)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(path)</span>
            <span class="s1">reread = read_stata(path)</span>
            <span class="s1">original[</span><span class="s2">&quot;ColumnTooBig&quot;</span><span class="s1">] = original[</span><span class="s2">&quot;ColumnTooBig&quot;</span><span class="s1">].astype(np.float64)</span>
            <span class="s1">tm.assert_frame_equal(original</span><span class="s0">, </span><span class="s1">reread.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">))</span>

        <span class="s1">original.loc[</span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;ColumnTooBig&quot;</span><span class="s1">] = np.inf</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;Column ColumnTooBig has a maximum value of infinity which &quot;</span>
            <span class="s2">&quot;is outside the range supported by Stata&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">original.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_path_pathlib(self):</span>
        <span class="s1">df = tm.makeDataFrame()</span>
        <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">reader = </span><span class="s0">lambda </span><span class="s1">x: read_stata(x).set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">result = tm.round_trip_pathlib(df.to_stata</span><span class="s0">, </span><span class="s1">reader)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_pickle_path_localpath(self):</span>
        <span class="s1">df = tm.makeDataFrame()</span>
        <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">reader = </span><span class="s0">lambda </span><span class="s1">x: read_stata(x).set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">result = tm.round_trip_localpath(df.to_stata</span><span class="s0">, </span><span class="s1">reader)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;write_index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_value_labels_iterator(self</span><span class="s0">, </span><span class="s1">write_index):</span>
        <span class="s4"># GH 16923</span>
        <span class="s1">d = {</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;E&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;E&quot;</span><span class="s1">]}</span>
        <span class="s1">df = DataFrame(data=d)</span>
        <span class="s1">df[</span><span class="s2">&quot;A&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;A&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=write_index)</span>

            <span class="s0">with </span><span class="s1">read_stata(path</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">dta_iter:</span>
                <span class="s1">value_labels = dta_iter.value_labels()</span>
        <span class="s0">assert </span><span class="s1">value_labels == {</span><span class="s2">&quot;A&quot;</span><span class="s1">: {</span><span class="s3">0</span><span class="s1">: </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;E&quot;</span><span class="s1">}}</span>

    <span class="s0">def </span><span class="s1">test_set_index(self):</span>
        <span class="s4"># GH 17328</span>
        <span class="s1">df = tm.makeDataFrame()</span>
        <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">df.to_stata(path)</span>
            <span class="s1">reread = read_stata(path</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">reread)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;column&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;ms&quot;</span><span class="s0">, </span><span class="s2">&quot;day&quot;</span><span class="s0">, </span><span class="s2">&quot;week&quot;</span><span class="s0">, </span><span class="s2">&quot;month&quot;</span><span class="s0">, </span><span class="s2">&quot;qtr&quot;</span><span class="s0">, </span><span class="s2">&quot;half&quot;</span><span class="s0">, </span><span class="s2">&quot;yr&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_date_parsing_ignores_format_details(self</span><span class="s0">, </span><span class="s1">column):</span>
        <span class="s4"># GH 17797</span>
        <span class="s4">#</span>
        <span class="s4"># Test that display formats are ignored when determining if a numeric</span>
        <span class="s4"># column is a date value.</span>
        <span class="s4">#</span>
        <span class="s4"># All date types are stored as numbers and format associated with the</span>
        <span class="s4"># column denotes both the type of the date and the display format.</span>
        <span class="s4">#</span>
        <span class="s4"># STATA supports 9 date types which each have distinct units. We test 7</span>
        <span class="s4"># of the 9 types, ignoring %tC and %tb. %tC is a variant of %tc that</span>
        <span class="s4"># accounts for leap seconds and %tb relies on STATAs business calendar.</span>
        <span class="s1">df = read_stata(self.stata_dates)</span>
        <span class="s1">unformatted = df.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">column]</span>
        <span class="s1">formatted = df.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">column + </span><span class="s2">&quot;_fmt&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">unformatted == formatted</span>

    <span class="s0">def </span><span class="s1">test_writer_117(self):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">data=[</span>
                <span class="s1">[</span>
                    <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;object&quot;</span><span class="s0">,</span>
                    <span class="s3">1</span><span class="s0">,</span>
                    <span class="s3">1</span><span class="s0">,</span>
                    <span class="s3">1</span><span class="s0">,</span>
                    <span class="s3">1.1</span><span class="s0">,</span>
                    <span class="s3">1.1</span><span class="s0">,</span>
                    <span class="s1">np.datetime64(</span><span class="s2">&quot;2003-12-25&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s2">&quot;a&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s3">2045</span><span class="s0">,</span>
                    <span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s3">5000</span><span class="s0">,</span>
                    <span class="s2">&quot;a&quot;</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span>
                    <span class="s2">&quot;string-1&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;object-1&quot;</span><span class="s0">,</span>
                    <span class="s3">1</span><span class="s0">,</span>
                    <span class="s3">1</span><span class="s0">,</span>
                    <span class="s3">1</span><span class="s0">,</span>
                    <span class="s3">1.1</span><span class="s0">,</span>
                    <span class="s3">1.1</span><span class="s0">,</span>
                    <span class="s1">np.datetime64(</span><span class="s2">&quot;2003-12-26&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s2">&quot;b&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;b&quot; </span><span class="s1">* </span><span class="s3">2045</span><span class="s0">,</span>
                    <span class="s2">&quot;&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;&quot;</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;object&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;int8&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;int16&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;int32&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float32&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float64&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetime&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;s1&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;s2045&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;srtl&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;forced_strl&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">original[</span><span class="s2">&quot;object&quot;</span><span class="s1">] = Series(original[</span><span class="s2">&quot;object&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">original[</span><span class="s2">&quot;int8&quot;</span><span class="s1">] = Series(original[</span><span class="s2">&quot;int8&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span>
        <span class="s1">original[</span><span class="s2">&quot;int16&quot;</span><span class="s1">] = Series(original[</span><span class="s2">&quot;int16&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">original[</span><span class="s2">&quot;int32&quot;</span><span class="s1">] = original[</span><span class="s2">&quot;int32&quot;</span><span class="s1">].astype(np.int32)</span>
        <span class="s1">original[</span><span class="s2">&quot;float32&quot;</span><span class="s1">] = Series(original[</span><span class="s2">&quot;float32&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s1">original.index = original.index.astype(np.int32)</span>
        <span class="s1">copy = original.copy()</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">original.to_stata(</span>
                <span class="s1">path</span><span class="s0">,</span>
                <span class="s1">convert_dates={</span><span class="s2">&quot;datetime&quot;</span><span class="s1">: </span><span class="s2">&quot;tc&quot;</span><span class="s1">}</span><span class="s0">,</span>
                <span class="s1">convert_strl=[</span><span class="s2">&quot;forced_strl&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">version=</span><span class="s3">117</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">written_and_read_again = self.read_dta(path)</span>
            <span class="s4"># original.index is np.int32, read index is np.int64</span>
            <span class="s1">tm.assert_frame_equal(</span>
                <span class="s1">written_and_read_again.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">original</span><span class="s0">,</span>
                <span class="s1">check_index_type=</span><span class="s0">False,</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(original</span><span class="s0">, </span><span class="s1">copy)</span>

    <span class="s0">def </span><span class="s1">test_convert_strl_name_swap(self):</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">[[</span><span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s3">3000</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot; </span><span class="s1">* </span><span class="s3">1000</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;banana&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;long1&quot; </span><span class="s1">* </span><span class="s3">10</span><span class="s0">, </span><span class="s2">&quot;long&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">original.index.name = </span><span class="s2">&quot;index&quot;</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(InvalidColumnName):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">convert_strl=[</span><span class="s2">&quot;long&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">version=</span><span class="s3">117</span><span class="s1">)</span>
                <span class="s1">reread = self.read_dta(path)</span>
                <span class="s1">reread = reread.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
                <span class="s1">reread.columns = original.columns</span>
                <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">original</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_invalid_date_conversion(self):</span>
        <span class="s4"># GH 12259</span>
        <span class="s1">dates = [</span>
            <span class="s1">dt.datetime(</span><span class="s3">1999</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">31</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">dt.datetime(</span><span class="s3">2012</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">dt.datetime(</span><span class="s3">1776</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">4000</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">original = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;nums&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;strs&quot;</span><span class="s1">: [</span><span class="s2">&quot;apple&quot;</span><span class="s0">, </span><span class="s2">&quot;banana&quot;</span><span class="s0">, </span><span class="s2">&quot;cherry&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;dates&quot;</span><span class="s1">: dates</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">msg = </span><span class="s2">&quot;convert_dates key must be a column or an integer&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">original.to_stata(path</span><span class="s0">, </span><span class="s1">convert_dates={</span><span class="s2">&quot;wrong_name&quot;</span><span class="s1">: </span><span class="s2">&quot;tc&quot;</span><span class="s1">})</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_nonfile_writing(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s4"># GH 21041</span>
        <span class="s1">bio = io.BytesIO()</span>
        <span class="s1">df = tm.makeDataFrame()</span>
        <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">df.to_stata(bio</span><span class="s0">, </span><span class="s1">version=version)</span>
            <span class="s1">bio.seek(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">open(path</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">dta:</span>
                <span class="s1">dta.write(bio.read())</span>
            <span class="s1">reread = read_stata(path</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">reread)</span>

    <span class="s0">def </span><span class="s1">test_gzip_writing(self):</span>
        <span class="s4"># writing version 117 requires seek and cannot be used with gzip</span>
        <span class="s1">df = tm.makeDataFrame()</span>
        <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">gzip.GzipFile(path</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">gz:</span>
                <span class="s1">df.to_stata(gz</span><span class="s0">, </span><span class="s1">version=</span><span class="s3">114</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">gzip.GzipFile(path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">gz:</span>
                <span class="s1">reread = read_stata(gz</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">reread)</span>

    <span class="s0">def </span><span class="s1">test_unicode_dta_118(self):</span>
        <span class="s1">unicode_df = self.read_dta(self.dta25_118)</span>

        <span class="s1">columns = [</span><span class="s2">&quot;utf8&quot;</span><span class="s0">, </span><span class="s2">&quot;latin1&quot;</span><span class="s0">, </span><span class="s2">&quot;ascii&quot;</span><span class="s0">, </span><span class="s2">&quot;utf8_strl&quot;</span><span class="s0">, </span><span class="s2">&quot;ascii_strl&quot;</span><span class="s1">]</span>
        <span class="s1">values = [</span>
            <span class="s1">[</span><span class="s2">&quot;ραηδας&quot;</span><span class="s0">, </span><span class="s2">&quot;PÄNDÄS&quot;</span><span class="s0">, </span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s2">&quot;ραηδας&quot;</span><span class="s0">, </span><span class="s2">&quot;p&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;ƤĀńĐąŜ&quot;</span><span class="s0">, </span><span class="s2">&quot;Ö&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;ƤĀńĐąŜ&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;ᴘᴀᴎᴅᴀS&quot;</span><span class="s0">, </span><span class="s2">&quot;Ü&quot;</span><span class="s0">, </span><span class="s2">&quot;n&quot;</span><span class="s0">, </span><span class="s2">&quot;ᴘᴀᴎᴅᴀS&quot;</span><span class="s0">, </span><span class="s2">&quot;n&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;      &quot;</span><span class="s0">, </span><span class="s2">&quot;      &quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;      &quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot; &quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">expected = DataFrame(values</span><span class="s0">, </span><span class="s1">columns=columns)</span>

        <span class="s1">tm.assert_frame_equal(unicode_df</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_mixed_string_strl(self):</span>
        <span class="s4"># GH 23633</span>
        <span class="s1">output = [{</span><span class="s2">&quot;mixed&quot;</span><span class="s1">: </span><span class="s2">&quot;string&quot; </span><span class="s1">* </span><span class="s3">500</span><span class="s0">, </span><span class="s2">&quot;number&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;mixed&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">&quot;number&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}]</span>
        <span class="s1">output = DataFrame(output)</span>
        <span class="s1">output.number = output.number.astype(</span><span class="s2">&quot;int32&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">output.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">version=</span><span class="s3">117</span><span class="s1">)</span>
            <span class="s1">reread = read_stata(path)</span>
            <span class="s1">expected = output.fillna(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">expected)</span>

            <span class="s4"># Check strl supports all None (null)</span>
            <span class="s1">output.loc[:</span><span class="s0">, </span><span class="s2">&quot;mixed&quot;</span><span class="s1">] = </span><span class="s0">None</span>
            <span class="s1">output.to_stata(</span>
                <span class="s1">path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">convert_strl=[</span><span class="s2">&quot;mixed&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">version=</span><span class="s3">117</span>
            <span class="s1">)</span>
            <span class="s1">reread = read_stata(path)</span>
            <span class="s1">expected = output.fillna(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_all_none_exception(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">output = [{</span><span class="s2">&quot;none&quot;</span><span class="s1">: </span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;number&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;none&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">&quot;number&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}]</span>
        <span class="s1">output = DataFrame(output)</span>
        <span class="s1">output.loc[:</span><span class="s0">, </span><span class="s2">&quot;none&quot;</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Column `none` cannot be exported&quot;</span><span class="s1">):</span>
                <span class="s1">output.to_stata(path</span><span class="s0">, </span><span class="s1">version=version)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_invalid_file_not_written(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">content = </span><span class="s2">&quot;Here is one __�__ Another one __·__ Another one __½__&quot;</span>
        <span class="s1">df = DataFrame([content]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;invalid&quot;</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">msg1 = (</span>
                <span class="s2">r&quot;'latin-1' codec can't encode character '\\ufffd' &quot;</span>
                <span class="s2">r&quot;in position 14: ordinal not in range\(256\)&quot;</span>
            <span class="s1">)</span>
            <span class="s1">msg2 = (</span>
                <span class="s2">&quot;'ascii' codec can't decode byte 0xef in position 14: &quot;</span>
                <span class="s2">r&quot;ordinal not in range\(128\)&quot;</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(UnicodeEncodeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">msg1</span><span class="s0">}</span><span class="s2">|</span><span class="s0">{</span><span class="s1">msg2</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(ResourceWarning):</span>
                    <span class="s1">df.to_stata(path)</span>

    <span class="s0">def </span><span class="s1">test_strl_latin1(self):</span>
        <span class="s4"># GH 23573, correct GSO data to reflect correct size</span>
        <span class="s1">output = DataFrame(</span>
            <span class="s1">[[</span><span class="s2">&quot;pandas&quot;</span><span class="s1">] * </span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;þâÑÐÅ§&quot;</span><span class="s1">] * </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;var_str&quot;</span><span class="s0">, </span><span class="s2">&quot;var_strl&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">output.to_stata(path</span><span class="s0">, </span><span class="s1">version=</span><span class="s3">117</span><span class="s0">, </span><span class="s1">convert_strl=[</span><span class="s2">&quot;var_strl&quot;</span><span class="s1">])</span>
            <span class="s0">with </span><span class="s1">open(path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">reread:</span>
                <span class="s1">content = reread.read()</span>
                <span class="s1">expected = </span><span class="s2">&quot;þâÑÐÅ§&quot;</span>
                <span class="s0">assert </span><span class="s1">expected.encode(</span><span class="s2">&quot;latin-1&quot;</span><span class="s1">) </span><span class="s0">in </span><span class="s1">content</span>
                <span class="s0">assert </span><span class="s1">expected.encode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">in </span><span class="s1">content</span>
                <span class="s1">gsos = content.split(</span><span class="s5">b&quot;strls&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">2</span><span class="s1">]</span>
                <span class="s0">for </span><span class="s1">gso </span><span class="s0">in </span><span class="s1">gsos.split(</span><span class="s5">b&quot;GSO&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">:]:</span>
                    <span class="s1">val = gso.split(</span><span class="s5">b&quot;</span><span class="s0">\x00</span><span class="s5">&quot;</span><span class="s1">)[-</span><span class="s3">2</span><span class="s1">]</span>
                    <span class="s1">size = gso[gso.find(</span><span class="s5">b&quot;</span><span class="s0">\x82</span><span class="s5">&quot;</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s0">assert </span><span class="s1">len(val) == size - </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">test_encoding_latin1_118(self):</span>
        <span class="s4"># GH 25960</span>
        <span class="s1">msg = </span><span class="s2">&quot;&quot;&quot; 
One or more strings in the dta file could not be decoded using utf-8, and 
so the fallback encoding of latin-1 is being used.  This can happen when a file 
has been incorrectly encoded by Stata or some other software. You should verify 
the string values returned are correct.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(UnicodeWarning) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">encoded = read_stata(self.dta_encoding_118)</span>
            <span class="s0">assert </span><span class="s1">len(w) == </span><span class="s3">151</span>
            <span class="s0">assert </span><span class="s1">w[</span><span class="s3">0</span><span class="s1">].message.args[</span><span class="s3">0</span><span class="s1">] == msg</span>

        <span class="s1">expected = DataFrame([[</span><span class="s2">&quot;Düsseldorf&quot;</span><span class="s1">]] * </span><span class="s3">151</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;kreis1849&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(encoded</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_stata_119(self):</span>
        <span class="s4"># Gzipped since contains 32,999 variables and uncompressed is 20MiB</span>
        <span class="s0">with </span><span class="s1">gzip.open(self.dta26_119</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">gz:</span>
            <span class="s1">df = read_stata(gz)</span>
        <span class="s0">assert </span><span class="s1">df.shape == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">32999</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">df.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">6</span><span class="s1">] == </span><span class="s2">&quot;A&quot; </span><span class="s1">* </span><span class="s3">3000</span>
        <span class="s0">assert </span><span class="s1">df.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">7</span><span class="s1">] == </span><span class="s3">3.14</span>
        <span class="s0">assert </span><span class="s1">df.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">df.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] == pd.Timestamp(datetime(</span><span class="s3">2012</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">21</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_utf8_writer(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s1">cat = pd.Categorical([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;β&quot;</span><span class="s0">, </span><span class="s2">&quot;ĉ&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">data = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;ᴬ&quot;</span><span class="s0">, </span><span class="s2">&quot;ᴀ relatively long ŝtring&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;ᴮ&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s2">&quot;ᴰ&quot;</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;β&quot;</span><span class="s0">, </span><span class="s2">&quot;ĉ&quot;</span><span class="s0">, </span><span class="s2">&quot;strls&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">data[</span><span class="s2">&quot;ᴐᴬᵀ&quot;</span><span class="s1">] = cat</span>
        <span class="s1">variable_labels = {</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;apple&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;β&quot;</span><span class="s1">: </span><span class="s2">&quot;ᵈᵉᵊ&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;ĉ&quot;</span><span class="s1">: </span><span class="s2">&quot;ᴎტჄႲႳႴႶႺ&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;strls&quot;</span><span class="s1">: </span><span class="s2">&quot;Long Strings&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;ᴐᴬᵀ&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">data_label = </span><span class="s2">&quot;ᴅaᵀa-label&quot;</span>
        <span class="s1">data[</span><span class="s2">&quot;β&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;β&quot;</span><span class="s1">].astype(np.int32)</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s1">writer = StataWriterUTF8(</span>
                <span class="s1">path</span><span class="s0">,</span>
                <span class="s1">data</span><span class="s0">,</span>
                <span class="s1">data_label=data_label</span><span class="s0">,</span>
                <span class="s1">convert_strl=[</span><span class="s2">&quot;strls&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">variable_labels=variable_labels</span><span class="s0">,</span>
                <span class="s1">write_index=</span><span class="s0">False,</span>
                <span class="s1">version=version</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">writer.write_file()</span>
            <span class="s1">reread_encoded = read_stata(path)</span>
            <span class="s4"># Missing is intentionally converted to empty strl</span>
            <span class="s1">data[</span><span class="s2">&quot;strls&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;strls&quot;</span><span class="s1">].fillna(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(data</span><span class="s0">, </span><span class="s1">reread_encoded)</span>
            <span class="s1">reader = StataReader(path)</span>
            <span class="s0">assert </span><span class="s1">reader.data_label == data_label</span>
            <span class="s0">assert </span><span class="s1">reader.variable_labels() == variable_labels</span>

            <span class="s1">data.to_stata(path</span><span class="s0">, </span><span class="s1">version=version</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">reread_to_stata = read_stata(path)</span>
            <span class="s1">tm.assert_frame_equal(data</span><span class="s0">, </span><span class="s1">reread_to_stata)</span>

    <span class="s0">def </span><span class="s1">test_writer_118_exceptions(self):</span>
        <span class="s1">df = DataFrame(np.zeros((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">33000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int8))</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;version must be either 118 or 119.&quot;</span><span class="s1">):</span>
                <span class="s1">StataWriterUTF8(path</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">version=</span><span class="s3">117</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;You must use version 119&quot;</span><span class="s1">):</span>
                <span class="s1">StataWriterUTF8(path</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">version=</span><span class="s3">118</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">105</span><span class="s0">, </span><span class="s3">108</span><span class="s0">, </span><span class="s3">111</span><span class="s0">, </span><span class="s3">113</span><span class="s0">, </span><span class="s3">114</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_backward_compat(version</span><span class="s0">, </span><span class="s1">datapath):</span>
    <span class="s1">data_base = datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;stata&quot;</span><span class="s1">)</span>
    <span class="s1">ref = os.path.join(data_base</span><span class="s0">, </span><span class="s2">&quot;stata-compat-118.dta&quot;</span><span class="s1">)</span>
    <span class="s1">old = os.path.join(data_base</span><span class="s0">, </span><span class="s2">f&quot;stata-compat-</span><span class="s0">{</span><span class="s1">version</span><span class="s0">}</span><span class="s2">.dta&quot;</span><span class="s1">)</span>
    <span class="s1">expected = read_stata(ref)</span>
    <span class="s1">old_dta = read_stata(old)</span>
    <span class="s1">tm.assert_frame_equal(old_dta</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;use_dict&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;infer&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_compression(compression</span><span class="s0">, </span><span class="s1">version</span><span class="s0">, </span><span class="s1">use_dict</span><span class="s0">, </span><span class="s1">infer):</span>
    <span class="s1">file_name = </span><span class="s2">&quot;dta_inferred_compression.dta&quot;</span>
    <span class="s0">if </span><span class="s1">compression:</span>
        <span class="s0">if </span><span class="s1">use_dict:</span>
            <span class="s1">file_ext = compression</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">file_ext = icom._compression_to_extension[compression]</span>
        <span class="s1">file_name += </span><span class="s2">f&quot;.</span><span class="s0">{</span><span class="s1">file_ext</span><span class="s0">}</span><span class="s2">&quot;</span>
    <span class="s1">compression_arg = compression</span>
    <span class="s0">if </span><span class="s1">infer:</span>
        <span class="s1">compression_arg = </span><span class="s2">&quot;infer&quot;</span>
    <span class="s0">if </span><span class="s1">use_dict:</span>
        <span class="s1">compression_arg = {</span><span class="s2">&quot;method&quot;</span><span class="s1">: compression}</span>

    <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;AB&quot;</span><span class="s1">))</span>
    <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
    <span class="s0">with </span><span class="s1">tm.ensure_clean(file_name) </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">version=version</span><span class="s0">, </span><span class="s1">compression=compression_arg)</span>
        <span class="s0">if </span><span class="s1">compression == </span><span class="s2">&quot;gzip&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">gzip.open(path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">comp:</span>
                <span class="s1">fp = io.BytesIO(comp.read())</span>
        <span class="s0">elif </span><span class="s1">compression == </span><span class="s2">&quot;zip&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">zipfile.ZipFile(path</span><span class="s0">, </span><span class="s2">&quot;r&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">comp:</span>
                <span class="s1">fp = io.BytesIO(comp.read(comp.filelist[</span><span class="s3">0</span><span class="s1">]))</span>
        <span class="s0">elif </span><span class="s1">compression == </span><span class="s2">&quot;bz2&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">bz2.open(path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">comp:</span>
                <span class="s1">fp = io.BytesIO(comp.read())</span>
        <span class="s0">elif </span><span class="s1">compression == </span><span class="s2">&quot;zstd&quot;</span><span class="s1">:</span>
            <span class="s1">zstd = pytest.importorskip(</span><span class="s2">&quot;zstandard&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">zstd.open(path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">comp:</span>
                <span class="s1">fp = io.BytesIO(comp.read())</span>
        <span class="s0">elif </span><span class="s1">compression == </span><span class="s2">&quot;xz&quot;</span><span class="s1">:</span>
            <span class="s1">lzma = pytest.importorskip(</span><span class="s2">&quot;lzma&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">lzma.open(path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">comp:</span>
                <span class="s1">fp = io.BytesIO(comp.read())</span>
        <span class="s0">elif </span><span class="s1">compression </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fp = path</span>
        <span class="s1">reread = read_stata(fp</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">df)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;zip&quot;</span><span class="s0">, </span><span class="s2">&quot;infer&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;file_ext&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;dta&quot;</span><span class="s0">, </span><span class="s2">&quot;zip&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_compression_dict(method</span><span class="s0">, </span><span class="s1">file_ext):</span>
    <span class="s1">file_name = </span><span class="s2">f&quot;test.</span><span class="s0">{</span><span class="s1">file_ext</span><span class="s0">}</span><span class="s2">&quot;</span>
    <span class="s1">archive_name = </span><span class="s2">&quot;test.dta&quot;</span>
    <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;AB&quot;</span><span class="s1">))</span>
    <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
    <span class="s0">with </span><span class="s1">tm.ensure_clean(file_name) </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">compression = {</span><span class="s2">&quot;method&quot;</span><span class="s1">: method</span><span class="s0">, </span><span class="s2">&quot;archive_name&quot;</span><span class="s1">: archive_name}</span>
        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">compression=compression)</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;zip&quot; </span><span class="s0">or </span><span class="s1">file_ext == </span><span class="s2">&quot;zip&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">zipfile.ZipFile(path</span><span class="s0">, </span><span class="s2">&quot;r&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">zp:</span>
                <span class="s0">assert </span><span class="s1">len(zp.filelist) == </span><span class="s3">1</span>
                <span class="s0">assert </span><span class="s1">zp.filelist[</span><span class="s3">0</span><span class="s1">].filename == archive_name</span>
                <span class="s1">fp = io.BytesIO(zp.read(zp.filelist[</span><span class="s3">0</span><span class="s1">]))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fp = path</span>
        <span class="s1">reread = read_stata(fp</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(reread</span><span class="s0">, </span><span class="s1">df)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_chunked_categorical(version):</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;cats&quot;</span><span class="s1">: Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)})</span>
    <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>
    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">version=version)</span>
        <span class="s1">reader = StataReader(path</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">order_categoricals=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">enumerate(reader):</span>
            <span class="s1">block = block.set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s2">&quot;cats&quot; </span><span class="s0">in </span><span class="s1">block</span>
            <span class="s1">tm.assert_series_equal(block.cats</span><span class="s0">, </span><span class="s1">df.cats.iloc[</span><span class="s3">2 </span><span class="s1">* i : </span><span class="s3">2 </span><span class="s1">* (i + </span><span class="s3">1</span><span class="s1">)])</span>


<span class="s0">def </span><span class="s1">test_chunked_categorical_partial(dirpath):</span>
    <span class="s1">dta_file = os.path.join(dirpath</span><span class="s0">, </span><span class="s2">&quot;stata-dta-partially-labeled.dta&quot;</span><span class="s1">)</span>
    <span class="s1">values = [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]</span>
    <span class="s0">with </span><span class="s1">StataReader(dta_file</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">2</span><span class="s1">) </span><span class="s0">as </span><span class="s1">reader:</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(CategoricalConversionWarning):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">enumerate(reader):</span>
                <span class="s0">assert </span><span class="s1">list(block.cats) == values[</span><span class="s3">2 </span><span class="s1">* i : </span><span class="s3">2 </span><span class="s1">* (i + </span><span class="s3">1</span><span class="s1">)]</span>
                <span class="s0">if </span><span class="s1">i &lt; </span><span class="s3">2</span><span class="s1">:</span>
                    <span class="s1">idx = pd.Index([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">idx = pd.Index([</span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;float64&quot;</span><span class="s1">)</span>
                <span class="s1">tm.assert_index_equal(block.cats.cat.categories</span><span class="s0">, </span><span class="s1">idx)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(CategoricalConversionWarning):</span>
        <span class="s0">with </span><span class="s1">StataReader(dta_file</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">5</span><span class="s1">) </span><span class="s0">as </span><span class="s1">reader:</span>
            <span class="s1">large_chunk = reader.__next__()</span>
    <span class="s1">direct = read_stata(dta_file)</span>
    <span class="s1">tm.assert_frame_equal(direct</span><span class="s0">, </span><span class="s1">large_chunk)</span>


<span class="s0">def </span><span class="s1">test_iterator_errors(dirpath):</span>
    <span class="s1">dta_file = os.path.join(dirpath</span><span class="s0">, </span><span class="s2">&quot;stata-dta-partially-labeled.dta&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;chunksize must be a positive&quot;</span><span class="s1">):</span>
        <span class="s1">StataReader(dta_file</span><span class="s0">, </span><span class="s1">chunksize=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;chunksize must be a positive&quot;</span><span class="s1">):</span>
        <span class="s1">StataReader(dta_file</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;chunksize must be a positive&quot;</span><span class="s1">):</span>
        <span class="s1">StataReader(dta_file</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s2">&quot;apple&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_iterator_value_labels():</span>
    <span class="s4"># GH 31544</span>
    <span class="s1">values = [</span><span class="s2">&quot;c_label&quot;</span><span class="s0">, </span><span class="s2">&quot;b_label&quot;</span><span class="s1">] + [</span><span class="s2">&quot;a_label&quot;</span><span class="s1">] * </span><span class="s3">500</span>
    <span class="s1">df = DataFrame({</span><span class="s2">f&quot;col</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">)})</span>
    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = pd.Index([</span><span class="s2">&quot;a_label&quot;</span><span class="s0">, </span><span class="s2">&quot;b_label&quot;</span><span class="s0">, </span><span class="s2">&quot;c_label&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">read_stata(path</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s3">100</span><span class="s1">) </span><span class="s0">as </span><span class="s1">reader:</span>
            <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">enumerate(reader):</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">):</span>
                    <span class="s1">tm.assert_index_equal(chunk.dtypes[i].categories</span><span class="s0">, </span><span class="s1">expected)</span>
                <span class="s1">tm.assert_frame_equal(chunk</span><span class="s0">, </span><span class="s1">df.iloc[j * </span><span class="s3">100 </span><span class="s1">: (j + </span><span class="s3">1</span><span class="s1">) * </span><span class="s3">100</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_precision_loss():</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">[[sum(</span><span class="s3">2 </span><span class="s1">** i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">60</span><span class="s1">))</span><span class="s0">, </span><span class="s1">sum(</span><span class="s3">2 </span><span class="s1">** i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">52</span><span class="s1">))]]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;big&quot;</span><span class="s0">, </span><span class="s2">&quot;little&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">PossiblePrecisionLoss</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Column converted from int64 to float64&quot;</span>
        <span class="s1">):</span>
            <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">reread = read_stata(path)</span>
        <span class="s1">expected_dt = Series([np.float64</span><span class="s0">, </span><span class="s1">np.float64]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;big&quot;</span><span class="s0">, </span><span class="s2">&quot;little&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(reread.dtypes</span><span class="s0">, </span><span class="s1">expected_dt)</span>
        <span class="s0">assert </span><span class="s1">reread.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;little&quot;</span><span class="s1">] == df.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;little&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">reread.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;big&quot;</span><span class="s1">] == float(df.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;big&quot;</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_compression_roundtrip(compression):</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">0.123456</span><span class="s0">, </span><span class="s3">0.234567</span><span class="s0">, </span><span class="s3">0.567567</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">12.32112</span><span class="s0">, </span><span class="s3">123123.2</span><span class="s0">, </span><span class="s3">321321.2</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;X&quot;</span><span class="s0">, </span><span class="s2">&quot;Y&quot;</span><span class="s0">, </span><span class="s2">&quot;Z&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>

    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>

        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">compression=compression)</span>
        <span class="s1">reread = read_stata(path</span><span class="s0">, </span><span class="s1">compression=compression</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">reread)</span>

        <span class="s4"># explicitly ensure file was compressed.</span>
        <span class="s0">with </span><span class="s1">tm.decompress_file(path</span><span class="s0">, </span><span class="s1">compression) </span><span class="s0">as </span><span class="s1">fh:</span>
            <span class="s1">contents = io.BytesIO(fh.read())</span>
        <span class="s1">reread = read_stata(contents</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">reread)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;to_infer&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;read_infer&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_stata_compression(compression_only</span><span class="s0">, </span><span class="s1">read_infer</span><span class="s0">, </span><span class="s1">to_infer):</span>
    <span class="s1">compression = compression_only</span>

    <span class="s1">ext = icom._compression_to_extension[compression]</span>
    <span class="s1">filename = </span><span class="s2">f&quot;test.</span><span class="s0">{</span><span class="s1">ext</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s1">df = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">0.123456</span><span class="s0">, </span><span class="s3">0.234567</span><span class="s0">, </span><span class="s3">0.567567</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">12.32112</span><span class="s0">, </span><span class="s3">123123.2</span><span class="s0">, </span><span class="s3">321321.2</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;X&quot;</span><span class="s0">, </span><span class="s2">&quot;Y&quot;</span><span class="s0">, </span><span class="s2">&quot;Z&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">df.index.name = </span><span class="s2">&quot;index&quot;</span>

    <span class="s1">to_compression = </span><span class="s2">&quot;infer&quot; </span><span class="s0">if </span><span class="s1">to_infer </span><span class="s0">else </span><span class="s1">compression</span>
    <span class="s1">read_compression = </span><span class="s2">&quot;infer&quot; </span><span class="s0">if </span><span class="s1">read_infer </span><span class="s0">else </span><span class="s1">compression</span>

    <span class="s0">with </span><span class="s1">tm.ensure_clean(filename) </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">compression=to_compression)</span>
        <span class="s1">result = read_stata(path</span><span class="s0">, </span><span class="s1">compression=read_compression</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>


<span class="s0">def </span><span class="s1">test_non_categorical_value_labels():</span>
    <span class="s1">data = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;fully_labelled&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;partially_labelled&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">9.0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s2">&quot;Y&quot;</span><span class="s1">: [</span><span class="s3">7</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;Z&quot;</span><span class="s1">: pd.Categorical([</span><span class="s2">&quot;j&quot;</span><span class="s0">, </span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s2">&quot;l&quot;</span><span class="s0">, </span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s2">&quot;j&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">value_labels = {</span>
            <span class="s2">&quot;fully_labelled&quot;</span><span class="s1">: {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;three&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s2">&quot;partially_labelled&quot;</span><span class="s1">: {</span><span class="s3">1.0</span><span class="s1">: </span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">: </span><span class="s2">&quot;two&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">expected = {**value_labels</span><span class="s0">, </span><span class="s2">&quot;Z&quot;</span><span class="s1">: {</span><span class="s3">0</span><span class="s1">: </span><span class="s2">&quot;j&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;l&quot;</span><span class="s1">}}</span>

        <span class="s1">writer = StataWriter(path</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">value_labels=value_labels)</span>
        <span class="s1">writer.write_file()</span>

        <span class="s1">reader = StataReader(path)</span>
        <span class="s1">reader_value_labels = reader.value_labels()</span>
        <span class="s0">assert </span><span class="s1">reader_value_labels == expected</span>

        <span class="s1">msg = </span><span class="s2">&quot;Can't create value labels for notY, it wasn't found in the dataset.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">value_labels = {</span><span class="s2">&quot;notY&quot;</span><span class="s1">: {</span><span class="s3">7</span><span class="s1">: </span><span class="s2">&quot;label1&quot;</span><span class="s0">, </span><span class="s3">8</span><span class="s1">: </span><span class="s2">&quot;label2&quot;</span><span class="s1">}}</span>
            <span class="s1">writer = StataWriter(path</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">value_labels=value_labels)</span>

        <span class="s1">msg = (</span>
            <span class="s2">&quot;Can't create value labels for Z, value labels &quot;</span>
            <span class="s2">&quot;can only be applied to numeric columns.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">value_labels = {</span><span class="s2">&quot;Z&quot;</span><span class="s1">: {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;j&quot;</span><span class="s0">, </span><span class="s3">4</span><span class="s1">: </span><span class="s2">&quot;i&quot;</span><span class="s1">}}</span>
            <span class="s1">writer = StataWriter(path</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">value_labels=value_labels)</span>


<span class="s0">def </span><span class="s1">test_non_categorical_value_label_name_conversion():</span>
    <span class="s4"># Check conversion of invalid variable names</span>
    <span class="s1">data = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;invalid~!&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,  </span><span class="s4"># Only alphanumeric and _</span>
            <span class="s2">&quot;6_invalid&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,  </span><span class="s4"># Must start with letter or _</span>
            <span class="s2">&quot;invalid_name_longer_than_32_characters&quot;</span><span class="s1">: [</span><span class="s3">8</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,  </span><span class="s4"># Too long</span>
            <span class="s2">&quot;aggregate&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">,  </span><span class="s4"># Reserved words</span>
            <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,  </span><span class="s4"># Hashable non-string</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s1">value_labels = {</span>
        <span class="s2">&quot;invalid~!&quot;</span><span class="s1">: {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;label1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;label2&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;6_invalid&quot;</span><span class="s1">: {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;label1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;label2&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;invalid_name_longer_than_32_characters&quot;</span><span class="s1">: {</span><span class="s3">8</span><span class="s1">: </span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s3">9</span><span class="s1">: </span><span class="s2">&quot;nine&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;aggregate&quot;</span><span class="s1">: {</span><span class="s3">5</span><span class="s1">: </span><span class="s2">&quot;five&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): {</span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;three&quot;</span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">expected = {</span>
        <span class="s2">&quot;invalid__&quot;</span><span class="s1">: {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;label1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;label2&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;_6_invalid&quot;</span><span class="s1">: {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;label1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;label2&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;invalid_name_longer_than_32_char&quot;</span><span class="s1">: {</span><span class="s3">8</span><span class="s1">: </span><span class="s2">&quot;eight&quot;</span><span class="s0">, </span><span class="s3">9</span><span class="s1">: </span><span class="s2">&quot;nine&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;_aggregate&quot;</span><span class="s1">: {</span><span class="s3">5</span><span class="s1">: </span><span class="s2">&quot;five&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;_1__2_&quot;</span><span class="s1">: {</span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;three&quot;</span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(InvalidColumnName):</span>
            <span class="s1">data.to_stata(path</span><span class="s0">, </span><span class="s1">value_labels=value_labels)</span>

        <span class="s1">reader = StataReader(path)</span>
        <span class="s1">reader_value_labels = reader.value_labels()</span>
        <span class="s0">assert </span><span class="s1">reader_value_labels == expected</span>


<span class="s0">def </span><span class="s1">test_non_categorical_value_label_convert_categoricals_error():</span>
    <span class="s4"># Mapping more than one value to the same label is valid for Stata</span>
    <span class="s4"># labels, but can't be read with convert_categoricals=True</span>
    <span class="s1">value_labels = {</span>
        <span class="s2">&quot;repeated_labels&quot;</span><span class="s1">: {</span><span class="s3">10</span><span class="s1">: </span><span class="s2">&quot;Ten&quot;</span><span class="s0">, </span><span class="s3">20</span><span class="s1">: </span><span class="s2">&quot;More than ten&quot;</span><span class="s0">, </span><span class="s3">40</span><span class="s1">: </span><span class="s2">&quot;More than ten&quot;</span><span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">data = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;repeated_labels&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">40</span><span class="s0">, </span><span class="s3">40</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">data.to_stata(path</span><span class="s0">, </span><span class="s1">value_labels=value_labels)</span>

        <span class="s1">reader = StataReader(path</span><span class="s0">, </span><span class="s1">convert_categoricals=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">reader_value_labels = reader.value_labels()</span>
        <span class="s0">assert </span><span class="s1">reader_value_labels == value_labels</span>

        <span class="s1">col = </span><span class="s2">&quot;repeated_labels&quot;</span>
        <span class="s1">repeats = </span><span class="s2">&quot;-&quot; </span><span class="s1">* </span><span class="s3">80 </span><span class="s1">+ </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.join([</span><span class="s2">&quot;More than ten&quot;</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">f&quot;&quot;&quot;</span>
<span class="s2">Value labels for column </span><span class="s0">{</span><span class="s1">col</span><span class="s0">} </span><span class="s2">are not unique. These cannot be converted to</span>
<span class="s2">pandas categoricals.</span>

<span class="s2">Either read the file with `convert_categoricals` set to False or use the</span>
<span class="s2">low level interface in `StataReader` to separately read the values and the</span>
<span class="s2">value_labels.</span>

<span class="s2">The repeated labels are:</span>
<span class="s0">{</span><span class="s1">repeats</span><span class="s0">}</span>
<span class="s2">&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_stata(path</span><span class="s0">, </span><span class="s1">convert_categoricals=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">114</span><span class="s0">, </span><span class="s3">117</span><span class="s0">, </span><span class="s3">118</span><span class="s0">, </span><span class="s3">119</span><span class="s0">, None</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dtype&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">pd.BooleanDtype</span><span class="s0">,</span>
        <span class="s1">pd.Int8Dtype</span><span class="s0">,</span>
        <span class="s1">pd.Int16Dtype</span><span class="s0">,</span>
        <span class="s1">pd.Int32Dtype</span><span class="s0">,</span>
        <span class="s1">pd.Int64Dtype</span><span class="s0">,</span>
        <span class="s1">pd.UInt8Dtype</span><span class="s0">,</span>
        <span class="s1">pd.UInt16Dtype</span><span class="s0">,</span>
        <span class="s1">pd.UInt32Dtype</span><span class="s0">,</span>
        <span class="s1">pd.UInt64Dtype</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_nullable_support(dtype</span><span class="s0">, </span><span class="s1">version):</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: Series([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pd.NA</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s1">dtype=dtype.name)</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, None</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">dtype_name = df.b.dtype.numpy_dtype.name</span>
    <span class="s4"># Only use supported names: no uint, bool or int64</span>
    <span class="s1">dtype_name = dtype_name.replace(</span><span class="s2">&quot;u&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">dtype_name == </span><span class="s2">&quot;int64&quot;</span><span class="s1">:</span>
        <span class="s1">dtype_name = </span><span class="s2">&quot;int32&quot;</span>
    <span class="s0">elif </span><span class="s1">dtype_name == </span><span class="s2">&quot;bool&quot;</span><span class="s1">:</span>
        <span class="s1">dtype_name = </span><span class="s2">&quot;int8&quot;</span>
    <span class="s1">value = StataMissingValue.BASE_MISSING_VALUES[dtype_name]</span>
    <span class="s1">smv = StataMissingValue(value)</span>
    <span class="s1">expected_b = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">smv</span><span class="s0">, </span><span class="s1">smv]</span><span class="s0">, </span><span class="s1">dtype=object</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">expected_c = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.ensure_clean() </span><span class="s0">as </span><span class="s1">path:</span>
        <span class="s1">df.to_stata(path</span><span class="s0">, </span><span class="s1">write_index=</span><span class="s0">False, </span><span class="s1">version=version)</span>
        <span class="s1">reread = read_stata(path</span><span class="s0">, </span><span class="s1">convert_missing=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(df.a</span><span class="s0">, </span><span class="s1">reread.a)</span>
        <span class="s1">tm.assert_series_equal(reread.b</span><span class="s0">, </span><span class="s1">expected_b)</span>
        <span class="s1">tm.assert_series_equal(reread.c</span><span class="s0">, </span><span class="s1">expected_c)</span>
</pre>
</body>
</html>