<html>
<head>
<title>_doc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_doc.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">TextWrapper</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s1">getfullargspec = inspect.getfullargspec</span>
<span class="s0">except </span><span class="s1">AttributeError:  </span><span class="s2"># python 2</span>
    <span class="s1">getfullargspec = inspect.getargspec</span>


<span class="s1">colref_type = </span><span class="s3">&quot;str or int or Series or array-like&quot;</span>
<span class="s1">colref_desc = </span><span class="s3">&quot;Either a name of a column in `data_frame`, or a pandas Series or array_like object.&quot;</span>
<span class="s1">colref_list_type = </span><span class="s3">&quot;list of str or int, or Series or array-like&quot;</span>
<span class="s1">colref_list_desc = (</span>
    <span class="s3">&quot;Either names of columns in `data_frame`, or pandas Series, or array_like objects&quot;</span>
<span class="s1">)</span>

<span class="s1">docs = dict(</span>
    <span class="s1">data_frame=[</span>
        <span class="s3">&quot;DataFrame or array-like or dict&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;This argument needs to be passed for column names (and not keyword names) to be used.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Array-like and dict are tranformed internally to a pandas DataFrame.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">x=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the x axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">y=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the y axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">z=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the z axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">x_start=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;(required)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the x axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">x_end=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;(required)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the x axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">a=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the a axis in ternary coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">b=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the b axis in ternary coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">c=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the c axis in ternary coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">r=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the radial axis in polar coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">theta=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks along the angular axis in polar coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">values=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to set values associated to sectors.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">parents=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used as parents in sunburst and treemap charts.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ids=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to set ids of sectors&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">path=[</span>
        <span class="s1">colref_list_type</span><span class="s0">,</span>
        <span class="s1">colref_list_desc</span><span class="s0">,</span>
        <span class="s3">&quot;List of columns names or columns of a rectangular dataframe defining the hierarchy of sectors, from root to leaves.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;An error is raised if path AND ids or parents is passed&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">lat=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks according to latitude on a map.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">lon=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position marks according to longitude on a map.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">locations=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are to be interpreted according to `locationmode` and mapped to longitude/latitude.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">base=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to position the base of the bar.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">dimensions=[</span>
        <span class="s1">colref_list_type</span><span class="s0">,</span>
        <span class="s1">colref_list_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from these columns are used for multidimensional visualization.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">dimensions_max_cardinality=[</span>
        <span class="s3">&quot;int (default 50)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;When `dimensions` is `None` and `data_frame` is provided, &quot;</span>
        <span class="s3">&quot;columns with more than this number of unique values are excluded from the output.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Not used when `dimensions` is passed.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">error_x=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to size x-axis error bars.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `error_x_minus` is `None`, error bars will be symmetrical, otherwise `error_x` is used for the positive direction only.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">error_x_minus=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to size x-axis error bars in the negative direction.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Ignored if `error_x` is `None`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">error_y=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to size y-axis error bars.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `error_y_minus` is `None`, error bars will be symmetrical, otherwise `error_y` is used for the positive direction only.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">error_y_minus=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to size y-axis error bars in the negative direction.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Ignored if `error_y` is `None`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">error_z=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to size z-axis error bars.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `error_z_minus` is `None`, error bars will be symmetrical, otherwise `error_z` is used for the positive direction only.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">error_z_minus=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to size z-axis error bars in the negative direction.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Ignored if `error_z` is `None`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">color=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign color to marks.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">opacity=[</span><span class="s3">&quot;float&quot;</span><span class="s0">, </span><span class="s3">&quot;Value between 0 and 1. Sets the opacity for markers.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">line_dash=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign dash-patterns to lines.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">line_group=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to group rows of `data_frame` into lines.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">symbol=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign symbols to marks.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">pattern_shape=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign pattern shapes to marks.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">size=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign mark sizes.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">radius=[</span><span class="s3">&quot;int (default is 30)&quot;</span><span class="s0">, </span><span class="s3">&quot;Sets the radius of influence of each point.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">hover_name=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like appear in bold in the hover tooltip.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">hover_data=[</span>
        <span class="s3">&quot;list of str or int, or Series or array-like, or dict&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Either a list of names of columns in `data_frame`, or pandas Series,&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;or array_like objects&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;or a dict with column names as keys, with values True (for default formatting)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;False (in order to remove this column from hover information),&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;or a formatting string, for example ':.3f' or '|%a'&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;or list-like data to appear in the hover tooltip&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;or tuples with a bool or formatting string as first element,&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;and list-like data to appear in hover as second element&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Values from these columns appear as extra data in the hover tooltip.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">custom_data=[</span>
        <span class="s1">colref_list_type</span><span class="s0">,</span>
        <span class="s1">colref_list_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from these columns are extra data, to be used in widgets or Dash callbacks for example. This data is not user-visible but is included in events emitted by the figure (lasso selection etc.)&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">text=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like appear in the figure as text labels.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">names=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used as labels for sectors.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">locationmode=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of 'ISO-3', 'USA-states', or 'country names'&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Determines the set of locations used to match entries in `locations` to regions on the map.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">facet_row=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign marks to facetted subplots in the vertical direction.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">facet_col=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign marks to facetted subplots in the horizontal direction.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">facet_col_wrap=[</span>
        <span class="s3">&quot;int&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Maximum number of facet columns.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Wraps the column variable at this width, so that the column facets span multiple rows.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Ignored if 0, and forced to 0 if `facet_row` or a `marginal` is set.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">facet_row_spacing=[</span>
        <span class="s3">&quot;float between 0 and 1&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7 when facet_col_wrap is used.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">facet_col_spacing=[</span>
        <span class="s3">&quot;float between 0 and 1&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Spacing between facet columns, in paper units Default is 0.02.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">animation_frame=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to assign marks to animation frames.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">animation_group=[</span>
        <span class="s1">colref_type</span><span class="s0">,</span>
        <span class="s1">colref_desc</span><span class="s0">,</span>
        <span class="s3">&quot;Values from this column or array_like are used to provide object-constancy across animation frames: rows with matching `animation_group`s will be treated as if they describe the same object in each frame.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">symbol_sequence=[</span>
        <span class="s3">&quot;list of str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings should define valid plotly.js symbols.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;When `symbol` is set, values in that column are assigned symbols by cycling through `symbol_sequence` in the order described in `category_orders`, unless the value of `symbol` is a key in `symbol_map`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">symbol_map=[</span>
        <span class="s3">&quot;dict with str keys and str values (default `{}`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;String values should define plotly.js symbols&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Used to override `symbol_sequence` to assign a specific symbols to marks corresponding with specific values.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Keys in `symbol_map` should be values in the column denoted by `symbol`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Alternatively, if the values of `symbol` are valid symbol names, the string `'identity'` may be passed to cause them to be used directly.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">line_dash_map=[</span>
        <span class="s3">&quot;dict with str keys and str values (default `{}`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings values define plotly.js dash-patterns.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Used to override `line_dash_sequences` to assign a specific dash-patterns to lines corresponding with specific values.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Keys in `line_dash_map` should be values in the column denoted by `line_dash`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Alternatively, if the values of `line_dash` are valid line-dash names, the string `'identity'` may be passed to cause them to be used directly.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">line_dash_sequence=[</span>
        <span class="s3">&quot;list of str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings should define valid plotly.js dash-patterns.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;When `line_dash` is set, values in that column are assigned dash-patterns by cycling through `line_dash_sequence` in the order described in `category_orders`, unless the value of `line_dash` is a key in `line_dash_map`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">pattern_shape_map=[</span>
        <span class="s3">&quot;dict with str keys and str values (default `{}`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings values define plotly.js patterns-shapes.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Used to override `pattern_shape_sequences` to assign a specific patterns-shapes to lines corresponding with specific values.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Keys in `pattern_shape_map` should be values in the column denoted by `pattern_shape`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Alternatively, if the values of `pattern_shape` are valid patterns-shapes names, the string `'identity'` may be passed to cause them to be used directly.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">pattern_shape_sequence=[</span>
        <span class="s3">&quot;list of str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings should define valid plotly.js patterns-shapes.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;When `pattern_shape` is set, values in that column are assigned patterns-shapes by cycling through `pattern_shape_sequence` in the order described in `category_orders`, unless the value of `pattern_shape` is a key in `pattern_shape_map`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">color_discrete_sequence=[</span>
        <span class="s3">&quot;list of str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings should define valid CSS-colors.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;When `color` is set and the values in the corresponding column are not numeric, values in that column are assigned colors by cycling through `color_discrete_sequence` in the order described in `category_orders`, unless the value of `color` is a key in `color_discrete_map`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Various useful color sequences are available in the `plotly.express.colors` submodules, specifically `plotly.express.colors.qualitative`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">color_discrete_map=[</span>
        <span class="s3">&quot;dict with str keys and str values (default `{}`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;String values should define valid CSS-colors&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Used to override `color_discrete_sequence` to assign a specific colors to marks corresponding with specific values.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Keys in `color_discrete_map` should be values in the column denoted by `color`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Alternatively, if the values of `color` are valid colors, the string `'identity'` may be passed to cause them to be used directly.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">color_continuous_scale=[</span>
        <span class="s3">&quot;list of str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Strings should define valid CSS-colors&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;This list is used to build a continuous color scale when the column denoted by `color` contains numeric data.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Various useful color scales are available in the `plotly.express.colors` submodules, specifically `plotly.express.colors.sequential`, `plotly.express.colors.diverging` and `plotly.express.colors.cyclical`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">color_continuous_midpoint=[</span>
        <span class="s3">&quot;number (default `None`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If set, computes the bounds of the continuous color scale to have the desired midpoint.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Setting this value is recommended when using `plotly.express.colors.diverging` color scales as the inputs to `color_continuous_scale`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">size_max=[</span><span class="s3">&quot;int (default `20`)&quot;</span><span class="s0">, </span><span class="s3">&quot;Set the maximum mark size when using `size`.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">markers=[</span><span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">, </span><span class="s3">&quot;If `True`, markers are shown on lines.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">lines=[</span>
        <span class="s3">&quot;boolean (default `True`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `False`, lines are not drawn (forced to `True` if `markers` is `False`).&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">log_x=[</span>
        <span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True`, the x-axis is log-scaled in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">log_y=[</span>
        <span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True`, the y-axis is log-scaled in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">log_z=[</span>
        <span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True`, the z-axis is log-scaled in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">log_r=[</span>
        <span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True`, the radial axis is log-scaled in polar coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">range_x=[</span>
        <span class="s3">&quot;list of two numbers&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, overrides auto-scaling on the x-axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">range_y=[</span>
        <span class="s3">&quot;list of two numbers&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, overrides auto-scaling on the y-axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">range_z=[</span>
        <span class="s3">&quot;list of two numbers&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, overrides auto-scaling on the z-axis in cartesian coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">range_color=[</span>
        <span class="s3">&quot;list of two numbers&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, overrides auto-scaling on the continuous color scale.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">range_r=[</span>
        <span class="s3">&quot;list of two numbers&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, overrides auto-scaling on the radial axis in polar coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">range_theta=[</span>
        <span class="s3">&quot;list of two numbers&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, overrides auto-scaling on the angular axis in polar coordinates.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">title=[</span><span class="s3">&quot;str&quot;</span><span class="s0">, </span><span class="s3">&quot;The figure title.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">template=[</span>
        <span class="s3">&quot;str or dict or plotly.graph_objects.layout.Template instance&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;The figure template name (must be a key in plotly.io.templates) or definition.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">width=[</span><span class="s3">&quot;int (default `None`)&quot;</span><span class="s0">, </span><span class="s3">&quot;The figure width in pixels.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">height=[</span><span class="s3">&quot;int (default `None`)&quot;</span><span class="s0">, </span><span class="s3">&quot;The figure height in pixels.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">labels=[</span>
        <span class="s3">&quot;dict with str keys and str values (default `{}`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;By default, column names are used in the figure for axis titles, legend entries and hovers.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;This parameter allows this to be overridden.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;The keys of this dict should correspond to column names, and the values should correspond to the desired label to be displayed.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">category_orders=[</span>
        <span class="s3">&quot;dict with str keys and list of str values (default `{}`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;By default, in Python 3.6+, the order of categorical values in axes, legends and facets depends on the order in which these values are first encountered in `data_frame` (and no order is guaranteed by default in Python below 3.6).&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;This parameter is used to force a specific ordering of values per column.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;The keys of this dict should correspond to column names, and the values should be lists of strings corresponding to the specific display order desired.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">marginal=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'rug'`, `'box'`, `'violin'`, or `'histogram'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If set, a subplot is drawn alongside the main plot, visualizing the distribution.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">marginal_x=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'rug'`, `'box'`, `'violin'`, or `'histogram'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If set, a horizontal subplot is drawn above the main plot, visualizing the x-distribution.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">marginal_y=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'rug'`, `'box'`, `'violin'`, or `'histogram'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If set, a vertical subplot is drawn to the right of the main plot, visualizing the y-distribution.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">trendline=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'ols'`, `'lowess'`, `'rolling'`, `'expanding'` or `'ewm'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'ols'`, an Ordinary Least Squares regression line will be drawn for each discrete-color/symbol group.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'lowess`', a Locally Weighted Scatterplot Smoothing line will be drawn for each discrete-color/symbol group.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'rolling`', a Rolling (e.g. rolling average, rolling median) line will be drawn for each discrete-color/symbol group.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'expanding`', an Expanding (e.g. expanding average, expanding sum) line will be drawn for each discrete-color/symbol group.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'ewm`', an Exponentially Weighted Moment (e.g. exponentially-weighted moving average) line will be drawn for each discrete-color/symbol group.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;See the docstrings for the functions in `plotly.express.trendline_functions` for more details on these functions and how&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;to configure them with the `trendline_options` argument.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">trendline_options=[</span>
        <span class="s3">&quot;dict&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Options passed as the first argument to the function from `plotly.express.trendline_functions` &quot;</span><span class="s0">,</span>
        <span class="s3">&quot;named in the `trendline` argument.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">trendline_color_override=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Valid CSS color.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If provided, and if `trendline` is set, all trendlines will be drawn in this color rather than in the same color as the traces from which they draw their inputs.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">trendline_scope=[</span>
        <span class="s3">&quot;str (one of `'trace'` or `'overall'`, default `'trace'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'trace'`, then one trendline is drawn per trace (i.e. per color, symbol, facet, animation frame etc) and if `'overall'` then one trendline is computed for the entire dataset, and replicated across all facets.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">render_mode=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'auto'`, `'svg'` or `'webgl'`, default `'auto'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Controls the browser API used to draw marks.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`'svg`' is appropriate for figures of less than 1000 data points, and will allow for fully-vectorized output.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`'webgl'` is likely necessary for acceptable performance above 1000 points but rasterizes part of the output. &quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`'auto'` uses heuristics to choose the mode.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">direction=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of '`counterclockwise'` or `'clockwise'`. Default is `'clockwise'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Sets the direction in which increasing values of the angular axis are drawn.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">start_angle=[</span>
        <span class="s3">&quot;int (default `90`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Sets start angle for the angular axis, with 0 being due east and 90 being due north.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">histfunc=[</span>
        <span class="s3">&quot;str (default `'count'` if no arguments are provided, else `'sum'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'count'`, `'sum'`, `'avg'`, `'min'`, or `'max'`.&quot;</span>
        <span class="s3">&quot;Function used to aggregate values for summarization (note: can be normalized with `histnorm`).&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">histnorm=[</span>
        <span class="s3">&quot;str (default `None`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'percent'`, `'probability'`, `'density'`, or `'probability density'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `None`, the output of `histfunc` is used as is.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'probability'`, the output of `histfunc` for a given bin is divided by the sum of the output of `histfunc` for all bins.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'percent'`, the output of `histfunc` for a given bin is divided by the sum of the output of `histfunc` for all bins and multiplied by 100.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'density'`, the output of `histfunc` for a given bin is divided by the size of the bin.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'probability density'`, the output of `histfunc` for a given bin is normalized such that it corresponds to the probability that a random event whose distribution is described by the output of `histfunc` will fall into that bin.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">barnorm=[</span>
        <span class="s3">&quot;str (default `None`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'fraction'` or `'percent'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'fraction'`, the value of each bar is divided by the sum of all values at that location coordinate.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`'percent'` is the same but multiplied by 100 to show percentages.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`None` will stack up all values at each location coordinate.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">groupnorm=[</span>
        <span class="s3">&quot;str (default `None`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'fraction'` or `'percent'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'fraction'`, the value of each point is divided by the sum of all values at that location coordinate.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`'percent'` is the same but multiplied by 100 to show percentages.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;`None` will stack up all values at each location coordinate.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">barmode=[</span>
        <span class="s3">&quot;str (default `'relative'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'group'`, `'overlay'` or `'relative'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'relative'` mode, bars are stacked above zero for positive values and below zero for negative values.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'overlay'` mode, bars are drawn on top of one another.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'group'` mode, bars are placed beside each other.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">boxmode=[</span>
        <span class="s3">&quot;str (default `'group'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'group'` or `'overlay'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'overlay'` mode, boxes are on drawn top of one another.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'group'` mode, boxes are placed beside each other.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">violinmode=[</span>
        <span class="s3">&quot;str (default `'group'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'group'` or `'overlay'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'overlay'` mode, violins are on drawn top of one another.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'group'` mode, violins are placed beside each other.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">stripmode=[</span>
        <span class="s3">&quot;str (default `'group'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'group'` or `'overlay'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'overlay'` mode, strips are on drawn top of one another.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;In `'group'` mode, strips are placed beside each other.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">zoom=[</span><span class="s3">&quot;int (default `8`)&quot;</span><span class="s0">, </span><span class="s3">&quot;Between 0 and 20.&quot;</span><span class="s0">, </span><span class="s3">&quot;Sets map zoom level.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">orientation=[</span>
        <span class="s3">&quot;str, one of `'h'` for horizontal or `'v'` for vertical. &quot;</span><span class="s0">,</span>
        <span class="s3">&quot;(default `'v'` if `x` and `y` are provided and both continous or both categorical, &quot;</span><span class="s0">,</span>
        <span class="s3">&quot;otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and `y`(`x`) is continuous, &quot;</span><span class="s0">,</span>
        <span class="s3">&quot;otherwise `'v'`(`'h'`) if only `x`(`y`) is provided) &quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">line_close=[</span>
        <span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True`, an extra line segment is drawn between the first and last point.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">line_shape=[</span><span class="s3">&quot;str (default `'linear'`)&quot;</span><span class="s0">, </span><span class="s3">&quot;One of `'linear'` or `'spline'`.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">fitbounds=[</span><span class="s3">&quot;str (default `False`).&quot;</span><span class="s0">, </span><span class="s3">&quot;One of `False`, `locations` or `geojson`.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">basemap_visible=[</span><span class="s3">&quot;bool&quot;</span><span class="s0">, </span><span class="s3">&quot;Force the basemap visibility.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">scope=[</span>
        <span class="s3">&quot;str (default `'world'`).&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'world'`, `'usa'`, `'europe'`, `'asia'`, `'africa'`, `'north america'`, or `'south america'`&quot;</span>
        <span class="s3">&quot;Default is `'world'` unless `projection` is set to `'albers usa'`, which forces `'usa'`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">projection=[</span>
        <span class="s3">&quot;str &quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'equirectangular'`, `'mercator'`, `'orthographic'`, `'natural earth'`, `'kavrayskiy7'`, `'miller'`, `'robinson'`, `'eckert4'`, `'azimuthal equal area'`, `'azimuthal equidistant'`, `'conic equal area'`, `'conic conformal'`, `'conic equidistant'`, `'gnomonic'`, `'stereographic'`, `'mollweide'`, `'hammer'`, `'transverse mercator'`, `'albers usa'`, `'winkel tripel'`, `'aitoff'`, or `'sinusoidal'`&quot;</span>
        <span class="s3">&quot;Default depends on `scope`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">center=[</span>
        <span class="s3">&quot;dict&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Dict keys are `'lat'` and `'lon'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Sets the center point of the map.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">mapbox_style=[</span>
        <span class="s3">&quot;str (default `'basic'`, needs Mapbox API token)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Identifier of base map style, some of which require a Mapbox API token to be set using `plotly.express.set_mapbox_access_token()`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Allowed values which do not require a Mapbox API token are `'open-street-map'`, `'white-bg'`, `'carto-positron'`, `'carto-darkmatter'`, `'stamen-terrain'`, `'stamen-toner'`, `'stamen-watercolor'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Allowed values which do require a Mapbox API token are `'basic'`, `'streets'`, `'outdoors'`, `'light'`, `'dark'`, `'satellite'`, `'satellite-streets'`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">points=[</span>
        <span class="s3">&quot;str or boolean (default `'outliers'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'outliers'`, `'suspectedoutliers'`, `'all'`, or `False`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'outliers'`, only the sample points lying outside the whiskers are shown.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'suspectedoutliers'`, all outlier points are shown and those less than 4*Q1-3*Q3 or greater than 4*Q3-3*Q1 are highlighted with the marker's `'outliercolor'`.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'outliers'`, only the sample points lying outside the whiskers are shown.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'all'`, all sample points are shown.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `False`, no sample points are shown and the whiskers extend to the full range of the sample.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">box=[</span><span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">, </span><span class="s3">&quot;If `True`, boxes are drawn inside the violins.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">notched=[</span><span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">, </span><span class="s3">&quot;If `True`, boxes are drawn with notches.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">geojson=[</span>
        <span class="s3">&quot;GeoJSON-formatted dict&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Must contain a Polygon feature collection, with IDs, which are references from `locations`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">featureidkey=[</span>
        <span class="s3">&quot;str (default: `'id'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Path to field in GeoJSON feature object with which to match the values passed in to `locations`.&quot;</span>
        <span class="s3">&quot;The most common alternative to the default is of the form `'properties.&lt;key&gt;`.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">cumulative=[</span>
        <span class="s3">&quot;boolean (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True`, histogram values are cumulative.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">nbins=[</span><span class="s3">&quot;int&quot;</span><span class="s0">, </span><span class="s3">&quot;Positive integer.&quot;</span><span class="s0">, </span><span class="s3">&quot;Sets the number of bins.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">nbinsx=[</span><span class="s3">&quot;int&quot;</span><span class="s0">, </span><span class="s3">&quot;Positive integer.&quot;</span><span class="s0">, </span><span class="s3">&quot;Sets the number of bins along the x axis.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">nbinsy=[</span><span class="s3">&quot;int&quot;</span><span class="s0">, </span><span class="s3">&quot;Positive integer.&quot;</span><span class="s0">, </span><span class="s3">&quot;Sets the number of bins along the y axis.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">branchvalues=[</span>
        <span class="s3">&quot;str&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;'total' or 'remainder'&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Determines how the items in `values` are summed. When&quot;</span>
        <span class="s3">&quot;set to 'total', items in `values` are taken to be value&quot;</span>
        <span class="s3">&quot;of all its descendants. When set to 'remainder', items&quot;</span>
        <span class="s3">&quot;in `values` corresponding to the root and the branches&quot;</span>
        <span class="s3">&quot;:sectors are taken to be the extra part not part of the&quot;</span>
        <span class="s3">&quot;sum of the values at their leaves.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">maxdepth=[</span>
        <span class="s3">&quot;int&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Positive integer&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;Sets the number of rendered sectors from any given `level`. Set `maxdepth` to -1 to render all the&quot;</span>
        <span class="s3">&quot;levels in the hierarchy.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ecdfnorm=[</span>
        <span class="s3">&quot;string or `None` (default `'probability'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'probability'` or `'percent'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `None`, values will be raw counts or sums.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'probability', values will be probabilities normalized from 0 to 1.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'percent', values will be percentages normalized from 0 to 100.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ecdfmode=[</span>
        <span class="s3">&quot;string (default `'standard'`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;One of `'standard'`, `'complementary'` or `'reversed'`&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'standard'`, the ECDF is plotted such that values represent data at or below the point.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'complementary'`, the CCDF is plotted such that values represent data above the point.&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `'reversed'`, a variant of the CCDF is plotted such that values represent data at or above the point.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">text_auto=[</span>
        <span class="s3">&quot;bool or string (default `False`)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;If `True` or a string, the x or y or z values will be displayed as text, depending on the orientation&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">make_docstring(fn</span><span class="s0">, </span><span class="s1">override_dict=</span><span class="s0">None, </span><span class="s1">append_dict=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">override_dict = {} </span><span class="s0">if </span><span class="s1">override_dict </span><span class="s0">is None else </span><span class="s1">override_dict</span>
    <span class="s1">append_dict = {} </span><span class="s0">if </span><span class="s1">append_dict </span><span class="s0">is None else </span><span class="s1">append_dict</span>
    <span class="s1">tw = TextWrapper(width=</span><span class="s4">75</span><span class="s0">, </span><span class="s1">initial_indent=</span><span class="s3">&quot;    &quot;</span><span class="s0">, </span><span class="s1">subsequent_indent=</span><span class="s3">&quot;    &quot;</span><span class="s1">)</span>
    <span class="s1">result = (fn.__doc__ </span><span class="s0">or </span><span class="s3">&quot;&quot;</span><span class="s1">) + </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">Parameters</span><span class="s0">\n</span><span class="s3">----------</span><span class="s0">\n</span><span class="s3">&quot;</span>
    <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">getfullargspec(fn)[</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">override_dict.get(param):</span>
            <span class="s1">param_doc = list(override_dict[param])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">param_doc = list(docs[param])</span>
            <span class="s0">if </span><span class="s1">append_dict.get(param):</span>
                <span class="s1">param_doc += append_dict[param]</span>
        <span class="s1">param_desc_list = param_doc[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">param_desc = (</span>
            <span class="s1">tw.fill(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(param_desc_list </span><span class="s0">or </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">param </span><span class="s0">in </span><span class="s1">docs </span><span class="s0">or </span><span class="s1">param </span><span class="s0">in </span><span class="s1">override_dict</span>
            <span class="s0">else </span><span class="s3">&quot;(documentation missing from map)&quot;</span>
        <span class="s1">)</span>

        <span class="s1">param_type = param_doc[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result += </span><span class="s3">&quot;%s: %s</span><span class="s0">\n</span><span class="s3">%s</span><span class="s0">\n</span><span class="s3">&quot; </span><span class="s1">% (param</span><span class="s0">, </span><span class="s1">param_type</span><span class="s0">, </span><span class="s1">param_desc)</span>
    <span class="s1">result += </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">Returns</span><span class="s0">\n</span><span class="s3">-------</span><span class="s0">\n</span><span class="s3">&quot;</span>
    <span class="s1">result += </span><span class="s3">&quot;    plotly.graph_objects.Figure&quot;</span>
    <span class="s0">return </span><span class="s1">result</span>
</pre>
</body>
</html>