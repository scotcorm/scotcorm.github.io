<html>
<head>
<title>egg_info.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
egg_info.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;setuptools.command.egg_info 
 
Create a distribution's .egg-info directory and contents&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">distutils.filelist </span><span class="s2">import </span><span class="s1">FileList </span><span class="s2">as </span><span class="s1">_FileList</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsInternalError</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">convert_path</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">import </span><span class="s1">distutils.errors</span>
<span class="s2">import </span><span class="s1">distutils.filelist</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">collections</span>

<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Command</span>
<span class="s2">from </span><span class="s1">setuptools.command.sdist </span><span class="s2">import </span><span class="s1">sdist</span>
<span class="s2">from </span><span class="s1">setuptools.command.sdist </span><span class="s2">import </span><span class="s1">walk_revctrl</span>
<span class="s2">from </span><span class="s1">setuptools.command.setopt </span><span class="s2">import </span><span class="s1">edit_config</span>
<span class="s2">from </span><span class="s1">setuptools.command </span><span class="s2">import </span><span class="s1">bdist_egg</span>
<span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">parse_requirements</span><span class="s2">, </span><span class="s1">safe_name</span><span class="s2">, </span><span class="s1">parse_version</span><span class="s2">,</span>
    <span class="s1">safe_version</span><span class="s2">, </span><span class="s1">yield_lines</span><span class="s2">, </span><span class="s1">EntryPoint</span><span class="s2">, </span><span class="s1">iter_entry_points</span><span class="s2">, </span><span class="s1">to_filename)</span>
<span class="s2">import </span><span class="s1">setuptools.unicode_utils </span><span class="s2">as </span><span class="s1">unicode_utils</span>
<span class="s2">from </span><span class="s1">setuptools.glob </span><span class="s2">import </span><span class="s1">glob</span>

<span class="s2">from </span><span class="s1">setuptools.extern </span><span class="s2">import </span><span class="s1">packaging</span>
<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">SetuptoolsDeprecationWarning</span>


<span class="s2">def </span><span class="s1">translate_pattern(glob):  </span><span class="s3"># noqa: C901  # is too complex (14)  # FIXME</span>
    <span class="s0">&quot;&quot;&quot; 
    Translate a file path glob like '*.txt' in to a regular expression. 
    This differs from fnmatch.translate which allows wildcards to match 
    directory separators. It also knows about '**/' which matches any number of 
    directories. 
    &quot;&quot;&quot;</span>
    <span class="s1">pat = </span><span class="s4">''</span>

    <span class="s3"># This will split on '/' within [character classes]. This is deliberate.</span>
    <span class="s1">chunks = glob.split(os.path.sep)</span>

    <span class="s1">sep = re.escape(os.sep)</span>
    <span class="s1">valid_char = </span><span class="s4">'[^%s]' </span><span class="s1">% (sep</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">chunk </span><span class="s2">in </span><span class="s1">enumerate(chunks):</span>
        <span class="s1">last_chunk = c == len(chunks) - </span><span class="s5">1</span>

        <span class="s3"># Chunks that are a literal ** are globstars. They match anything.</span>
        <span class="s2">if </span><span class="s1">chunk == </span><span class="s4">'**'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">last_chunk:</span>
                <span class="s3"># Match anything if this is the last component</span>
                <span class="s1">pat += </span><span class="s4">'.*'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># Match '(name/)*'</span>
                <span class="s1">pat += </span><span class="s4">'(?:%s+%s)*' </span><span class="s1">% (valid_char</span><span class="s2">, </span><span class="s1">sep)</span>
            <span class="s2">continue  </span><span class="s3"># Break here as the whole path component has been handled</span>

        <span class="s3"># Find any special characters in the remainder</span>
        <span class="s1">i = </span><span class="s5">0</span>
        <span class="s1">chunk_len = len(chunk)</span>
        <span class="s2">while </span><span class="s1">i &lt; chunk_len:</span>
            <span class="s1">char = chunk[i]</span>
            <span class="s2">if </span><span class="s1">char == </span><span class="s4">'*'</span><span class="s1">:</span>
                <span class="s3"># Match any number of name characters</span>
                <span class="s1">pat += valid_char + </span><span class="s4">'*'</span>
            <span class="s2">elif </span><span class="s1">char == </span><span class="s4">'?'</span><span class="s1">:</span>
                <span class="s3"># Match a name character</span>
                <span class="s1">pat += valid_char</span>
            <span class="s2">elif </span><span class="s1">char == </span><span class="s4">'['</span><span class="s1">:</span>
                <span class="s3"># Character class</span>
                <span class="s1">inner_i = i + </span><span class="s5">1</span>
                <span class="s3"># Skip initial !/] chars</span>
                <span class="s2">if </span><span class="s1">inner_i &lt; chunk_len </span><span class="s2">and </span><span class="s1">chunk[inner_i] == </span><span class="s4">'!'</span><span class="s1">:</span>
                    <span class="s1">inner_i = inner_i + </span><span class="s5">1</span>
                <span class="s2">if </span><span class="s1">inner_i &lt; chunk_len </span><span class="s2">and </span><span class="s1">chunk[inner_i] == </span><span class="s4">']'</span><span class="s1">:</span>
                    <span class="s1">inner_i = inner_i + </span><span class="s5">1</span>

                <span class="s3"># Loop till the closing ] is found</span>
                <span class="s2">while </span><span class="s1">inner_i &lt; chunk_len </span><span class="s2">and </span><span class="s1">chunk[inner_i] != </span><span class="s4">']'</span><span class="s1">:</span>
                    <span class="s1">inner_i = inner_i + </span><span class="s5">1</span>

                <span class="s2">if </span><span class="s1">inner_i &gt;= chunk_len:</span>
                    <span class="s3"># Got to the end of the string without finding a closing ]</span>
                    <span class="s3"># Do not treat this as a matching group, but as a literal [</span>
                    <span class="s1">pat += re.escape(char)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># Grab the insides of the [brackets]</span>
                    <span class="s1">inner = chunk[i + </span><span class="s5">1</span><span class="s1">:inner_i]</span>
                    <span class="s1">char_class = </span><span class="s4">''</span>

                    <span class="s3"># Class negation</span>
                    <span class="s2">if </span><span class="s1">inner[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'!'</span><span class="s1">:</span>
                        <span class="s1">char_class = </span><span class="s4">'^'</span>
                        <span class="s1">inner = inner[</span><span class="s5">1</span><span class="s1">:]</span>

                    <span class="s1">char_class += re.escape(inner)</span>
                    <span class="s1">pat += </span><span class="s4">'[%s]' </span><span class="s1">% (char_class</span><span class="s2">,</span><span class="s1">)</span>

                    <span class="s3"># Skip to the end ]</span>
                    <span class="s1">i = inner_i</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">pat += re.escape(char)</span>
            <span class="s1">i += </span><span class="s5">1</span>

        <span class="s3"># Join each chunk with the dir separator</span>
        <span class="s2">if not </span><span class="s1">last_chunk:</span>
            <span class="s1">pat += sep</span>

    <span class="s1">pat += </span><span class="s4">r'\Z'</span>
    <span class="s2">return </span><span class="s1">re.compile(pat</span><span class="s2">, </span><span class="s1">flags=re.MULTILINE | re.DOTALL)</span>


<span class="s2">class </span><span class="s1">InfoCommon:</span>
    <span class="s1">tag_build = </span><span class="s2">None</span>
    <span class="s1">tag_date = </span><span class="s2">None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self):</span>
        <span class="s2">return </span><span class="s1">safe_name(self.distribution.get_name())</span>

    <span class="s2">def </span><span class="s1">tagged_version(self):</span>
        <span class="s2">return </span><span class="s1">safe_version(self._maybe_tag(self.distribution.get_version()))</span>

    <span class="s2">def </span><span class="s1">_maybe_tag(self</span><span class="s2">, </span><span class="s1">version):</span>
        <span class="s0">&quot;&quot;&quot; 
        egg_info may be called more than once for a distribution, 
        in which case the version string already contains all tags. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">version </span><span class="s2">if </span><span class="s1">self.vtags </span><span class="s2">and </span><span class="s1">version.endswith(self.vtags)</span>
            <span class="s2">else </span><span class="s1">version + self.vtags</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">tags(self):</span>
        <span class="s1">version = </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">self.tag_build:</span>
            <span class="s1">version += self.tag_build</span>
        <span class="s2">if </span><span class="s1">self.tag_date:</span>
            <span class="s1">version += time.strftime(</span><span class="s4">&quot;-%Y%m%d&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">version</span>
    <span class="s1">vtags = property(tags)</span>


<span class="s2">class </span><span class="s1">egg_info(InfoCommon</span><span class="s2">, </span><span class="s1">Command):</span>
    <span class="s1">description = </span><span class="s4">&quot;create a distribution's .egg-info directory&quot;</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s4">'egg-base='</span><span class="s2">, </span><span class="s4">'e'</span><span class="s2">, </span><span class="s4">&quot;directory containing .egg-info directories&quot;</span>
                           <span class="s4">&quot; (default: top of the source tree)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'tag-date'</span><span class="s2">, </span><span class="s4">'d'</span><span class="s2">, </span><span class="s4">&quot;Add date stamp (e.g. 20050528) to version number&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'tag-build='</span><span class="s2">, </span><span class="s4">'b'</span><span class="s2">, </span><span class="s4">&quot;Specify explicit tag to add to version number&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'no-date'</span><span class="s2">, </span><span class="s4">'D'</span><span class="s2">, </span><span class="s4">&quot;Don't include date stamp [default]&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s1">boolean_options = [</span><span class="s4">'tag-date'</span><span class="s1">]</span>
    <span class="s1">negative_opt = {</span>
        <span class="s4">'no-date'</span><span class="s1">: </span><span class="s4">'tag-date'</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s1">self.egg_base = </span><span class="s2">None</span>
        <span class="s1">self.egg_name = </span><span class="s2">None</span>
        <span class="s1">self.egg_info = </span><span class="s2">None</span>
        <span class="s1">self.egg_version = </span><span class="s2">None</span>
        <span class="s1">self.broken_egg_info = </span><span class="s2">False</span>

    <span class="s3">####################################</span>
    <span class="s3"># allow the 'tag_svn_revision' to be detected and</span>
    <span class="s3"># set, supporting sdists built on older Setuptools.</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">tag_svn_revision(self):</span>
        <span class="s2">pass</span>

    <span class="s1">@tag_svn_revision.setter</span>
    <span class="s2">def </span><span class="s1">tag_svn_revision(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">pass</span>
    <span class="s3">####################################</span>

    <span class="s2">def </span><span class="s1">save_version_info(self</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s0">&quot;&quot;&quot; 
        Materialize the value of date into the 
        build tag. Install build keys in a deterministic order 
        to avoid arbitrary reordering on subsequent builds. 
        &quot;&quot;&quot;</span>
        <span class="s1">egg_info = collections.OrderedDict()</span>
        <span class="s3"># follow the order these keys would have been added</span>
        <span class="s3"># when PYTHONHASHSEED=0</span>
        <span class="s1">egg_info[</span><span class="s4">'tag_build'</span><span class="s1">] = self.tags()</span>
        <span class="s1">egg_info[</span><span class="s4">'tag_date'</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s1">edit_config(filename</span><span class="s2">, </span><span class="s1">dict(egg_info=egg_info))</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s3"># Note: we need to capture the current value returned</span>
        <span class="s3"># by `self.tagged_version()`, so we can later update</span>
        <span class="s3"># `self.distribution.metadata.version` without</span>
        <span class="s3"># repercussions.</span>
        <span class="s1">self.egg_name = self.name</span>
        <span class="s1">self.egg_version = self.tagged_version()</span>
        <span class="s1">parsed_version = parse_version(self.egg_version)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">is_version = isinstance(parsed_version</span><span class="s2">, </span><span class="s1">packaging.version.Version)</span>
            <span class="s1">spec = (</span>
                <span class="s4">&quot;%s==%s&quot; </span><span class="s2">if </span><span class="s1">is_version </span><span class="s2">else </span><span class="s4">&quot;%s===%s&quot;</span>
            <span class="s1">)</span>
            <span class="s1">list(</span>
                <span class="s1">parse_requirements(spec % (self.egg_name</span><span class="s2">, </span><span class="s1">self.egg_version))</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">distutils.errors.DistutilsOptionError(</span>
                <span class="s4">&quot;Invalid distribution name or version syntax: %s-%s&quot; </span><span class="s1">%</span>
                <span class="s1">(self.egg_name</span><span class="s2">, </span><span class="s1">self.egg_version)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">if </span><span class="s1">self.egg_base </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dirs = self.distribution.package_dir</span>
            <span class="s1">self.egg_base = (dirs </span><span class="s2">or </span><span class="s1">{}).get(</span><span class="s4">''</span><span class="s2">, </span><span class="s1">os.curdir)</span>

        <span class="s1">self.ensure_dirname(</span><span class="s4">'egg_base'</span><span class="s1">)</span>
        <span class="s1">self.egg_info = to_filename(self.egg_name) + </span><span class="s4">'.egg-info'</span>
        <span class="s2">if </span><span class="s1">self.egg_base != os.curdir:</span>
            <span class="s1">self.egg_info = os.path.join(self.egg_base</span><span class="s2">, </span><span class="s1">self.egg_info)</span>
        <span class="s2">if </span><span class="s4">'-' </span><span class="s2">in </span><span class="s1">self.egg_name:</span>
            <span class="s1">self.check_broken_egg_info()</span>

        <span class="s3"># Set package version for the benefit of dumber commands</span>
        <span class="s3"># (e.g. sdist, bdist_wininst, etc.)</span>
        <span class="s3">#</span>
        <span class="s1">self.distribution.metadata.version = self.egg_version</span>

        <span class="s3"># If we bootstrapped around the lack of a PKG-INFO, as might be the</span>
        <span class="s3"># case in a fresh checkout, make sure that any special tags get added</span>
        <span class="s3"># to the version info</span>
        <span class="s3">#</span>
        <span class="s1">pd = self.distribution._patched_dist</span>
        <span class="s2">if </span><span class="s1">pd </span><span class="s2">is not None and </span><span class="s1">pd.key == self.egg_name.lower():</span>
            <span class="s1">pd._version = self.egg_version</span>
            <span class="s1">pd._parsed_version = parse_version(self.egg_version)</span>
            <span class="s1">self.distribution._patched_dist = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">write_or_delete_file(self</span><span class="s2">, </span><span class="s1">what</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">force=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Write `data` to `filename` or delete if empty 
 
        If `data` is non-empty, this routine is the same as ``write_file()``. 
        If `data` is empty but not ``None``, this is the same as calling 
        ``delete_file(filename)`.  If `data` is ``None``, then this is a no-op 
        unless `filename` exists, in which case a warning is issued about the 
        orphaned file (if `force` is false), or deleted (if `force` is true). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">data:</span>
            <span class="s1">self.write_file(what</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s2">elif </span><span class="s1">os.path.exists(filename):</span>
            <span class="s2">if </span><span class="s1">data </span><span class="s2">is None and not </span><span class="s1">force:</span>
                <span class="s1">log.warn(</span>
                    <span class="s4">&quot;%s not set in setup(), but %s exists&quot;</span><span class="s2">, </span><span class="s1">what</span><span class="s2">, </span><span class="s1">filename</span>
                <span class="s1">)</span>
                <span class="s2">return</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.delete_file(filename)</span>

    <span class="s2">def </span><span class="s1">write_file(self</span><span class="s2">, </span><span class="s1">what</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot;Write `data` to `filename` (if not a dry run) after announcing it 
 
        `what` is used in a log message to identify what is being written 
        to the file. 
        &quot;&quot;&quot;</span>
        <span class="s1">log.info(</span><span class="s4">&quot;writing %s to %s&quot;</span><span class="s2">, </span><span class="s1">what</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">data = data.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s1">f = open(filename</span><span class="s2">, </span><span class="s4">'wb'</span><span class="s1">)</span>
            <span class="s1">f.write(data)</span>
            <span class="s1">f.close()</span>

    <span class="s2">def </span><span class="s1">delete_file(self</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s0">&quot;&quot;&quot;Delete `filename` (if not a dry run) after announcing it&quot;&quot;&quot;</span>
        <span class="s1">log.info(</span><span class="s4">&quot;deleting %s&quot;</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s1">os.unlink(filename)</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s1">self.mkpath(self.egg_info)</span>
        <span class="s1">os.utime(self.egg_info</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">installer = self.distribution.fetch_build_egg</span>
        <span class="s2">for </span><span class="s1">ep </span><span class="s2">in </span><span class="s1">iter_entry_points(</span><span class="s4">'egg_info.writers'</span><span class="s1">):</span>
            <span class="s1">ep.require(installer=installer)</span>
            <span class="s1">writer = ep.resolve()</span>
            <span class="s1">writer(self</span><span class="s2">, </span><span class="s1">ep.name</span><span class="s2">, </span><span class="s1">os.path.join(self.egg_info</span><span class="s2">, </span><span class="s1">ep.name))</span>

        <span class="s3"># Get rid of native_libs.txt if it was put there by older bdist_egg</span>
        <span class="s1">nl = os.path.join(self.egg_info</span><span class="s2">, </span><span class="s4">&quot;native_libs.txt&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(nl):</span>
            <span class="s1">self.delete_file(nl)</span>

        <span class="s1">self.find_sources()</span>

    <span class="s2">def </span><span class="s1">find_sources(self):</span>
        <span class="s0">&quot;&quot;&quot;Generate SOURCES.txt manifest file&quot;&quot;&quot;</span>
        <span class="s1">manifest_filename = os.path.join(self.egg_info</span><span class="s2">, </span><span class="s4">&quot;SOURCES.txt&quot;</span><span class="s1">)</span>
        <span class="s1">mm = manifest_maker(self.distribution)</span>
        <span class="s1">mm.manifest = manifest_filename</span>
        <span class="s1">mm.run()</span>
        <span class="s1">self.filelist = mm.filelist</span>

    <span class="s2">def </span><span class="s1">check_broken_egg_info(self):</span>
        <span class="s1">bei = self.egg_name + </span><span class="s4">'.egg-info'</span>
        <span class="s2">if </span><span class="s1">self.egg_base != os.curdir:</span>
            <span class="s1">bei = os.path.join(self.egg_base</span><span class="s2">, </span><span class="s1">bei)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(bei):</span>
            <span class="s1">log.warn(</span>
                <span class="s4">&quot;-&quot; </span><span class="s1">* </span><span class="s5">78 </span><span class="s1">+ </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">&quot;Note: Your current .egg-info directory has a '-' in its name;&quot;</span>
                <span class="s4">'</span><span class="s2">\n</span><span class="s4">this will not work correctly with &quot;setup.py develop&quot;.</span><span class="s2">\n\n</span><span class="s4">'</span>
                <span class="s4">'Please rename %s to %s to correct this problem.</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ </span><span class="s4">'-' </span><span class="s1">* </span><span class="s5">78</span><span class="s2">,</span>
                <span class="s1">bei</span><span class="s2">, </span><span class="s1">self.egg_info</span>
            <span class="s1">)</span>
            <span class="s1">self.broken_egg_info = self.egg_info</span>
            <span class="s1">self.egg_info = bei  </span><span class="s3"># make it work for now</span>


<span class="s2">class </span><span class="s1">FileList(_FileList):</span>
    <span class="s3"># Implementations of the various MANIFEST.in commands</span>

    <span class="s2">def </span><span class="s1">process_template_line(self</span><span class="s2">, </span><span class="s1">line):</span>
        <span class="s3"># Parse the line: split it up, make sure the right number of words</span>
        <span class="s3"># is there, and return the relevant words.  'action' is always</span>
        <span class="s3"># defined: it's the first word of the line.  Which of the other</span>
        <span class="s3"># three are defined depends on the action; it'll be either</span>
        <span class="s3"># patterns, (dir and patterns), or (dir_pattern).</span>
        <span class="s1">(action</span><span class="s2">, </span><span class="s1">patterns</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">dir_pattern) = self._parse_template_line(line)</span>

        <span class="s1">action_map = {</span>
            <span class="s4">'include'</span><span class="s1">: self.include</span><span class="s2">,</span>
            <span class="s4">'exclude'</span><span class="s1">: self.exclude</span><span class="s2">,</span>
            <span class="s4">'global-include'</span><span class="s1">: self.global_include</span><span class="s2">,</span>
            <span class="s4">'global-exclude'</span><span class="s1">: self.global_exclude</span><span class="s2">,</span>
            <span class="s4">'recursive-include'</span><span class="s1">: functools.partial(</span>
                <span class="s1">self.recursive_include</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'recursive-exclude'</span><span class="s1">: functools.partial(</span>
                <span class="s1">self.recursive_exclude</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'graft'</span><span class="s1">: self.graft</span><span class="s2">,</span>
            <span class="s4">'prune'</span><span class="s1">: self.prune</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">log_map = {</span>
            <span class="s4">'include'</span><span class="s1">: </span><span class="s4">&quot;warning: no files found matching '%s'&quot;</span><span class="s2">,</span>
            <span class="s4">'exclude'</span><span class="s1">: (</span>
                <span class="s4">&quot;warning: no previously-included files found &quot;</span>
                <span class="s4">&quot;matching '%s'&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'global-include'</span><span class="s1">: (</span>
                <span class="s4">&quot;warning: no files found matching '%s' &quot;</span>
                <span class="s4">&quot;anywhere in distribution&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'global-exclude'</span><span class="s1">: (</span>
                <span class="s4">&quot;warning: no previously-included files matching &quot;</span>
                <span class="s4">&quot;'%s' found anywhere in distribution&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'recursive-include'</span><span class="s1">: (</span>
                <span class="s4">&quot;warning: no files found matching '%s' &quot;</span>
                <span class="s4">&quot;under directory '%s'&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'recursive-exclude'</span><span class="s1">: (</span>
                <span class="s4">&quot;warning: no previously-included files matching &quot;</span>
                <span class="s4">&quot;'%s' found under directory '%s'&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'graft'</span><span class="s1">: </span><span class="s4">&quot;warning: no directories found matching '%s'&quot;</span><span class="s2">,</span>
            <span class="s4">'prune'</span><span class="s1">: </span><span class="s4">&quot;no previously-included directories found matching '%s'&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">process_action = action_map[action]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">DistutilsInternalError(</span>
                <span class="s4">&quot;this cannot happen: invalid action '{action!s}'&quot;</span><span class="s1">.</span>
                <span class="s1">format(action=action)</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s3"># OK, now we know that the action is valid and we have the</span>
        <span class="s3"># right number of words on the line for that action -- so we</span>
        <span class="s3"># can proceed with minimal error-checking.</span>

        <span class="s1">action_is_recursive = action.startswith(</span><span class="s4">'recursive-'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">action </span><span class="s2">in </span><span class="s1">{</span><span class="s4">'graft'</span><span class="s2">, </span><span class="s4">'prune'</span><span class="s1">}:</span>
            <span class="s1">patterns = [dir_pattern]</span>
        <span class="s1">extra_log_args = (dir</span><span class="s2">, </span><span class="s1">) </span><span class="s2">if </span><span class="s1">action_is_recursive </span><span class="s2">else </span><span class="s1">()</span>
        <span class="s1">log_tmpl = log_map[action]</span>

        <span class="s1">self.debug_print(</span>
            <span class="s4">' '</span><span class="s1">.join(</span>
                <span class="s1">[action] +</span>
                <span class="s1">([dir] </span><span class="s2">if </span><span class="s1">action_is_recursive </span><span class="s2">else </span><span class="s1">[]) +</span>
                <span class="s1">patterns</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">patterns:</span>
            <span class="s2">if not </span><span class="s1">process_action(pattern):</span>
                <span class="s1">log.warn(log_tmpl</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">*extra_log_args)</span>

    <span class="s2">def </span><span class="s1">_remove_files(self</span><span class="s2">, </span><span class="s1">predicate):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove all files from the file list that match the predicate. 
        Return True if any matching files were removed 
        &quot;&quot;&quot;</span>
        <span class="s1">found = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(self.files) - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">predicate(self.files[i]):</span>
                <span class="s1">self.debug_print(</span><span class="s4">&quot; removing &quot; </span><span class="s1">+ self.files[i])</span>
                <span class="s2">del </span><span class="s1">self.files[i]</span>
                <span class="s1">found = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">found</span>

    <span class="s2">def </span><span class="s1">include(self</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot;Include files that match 'pattern'.&quot;&quot;&quot;</span>
        <span class="s1">found = [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">glob(pattern) </span><span class="s2">if not </span><span class="s1">os.path.isdir(f)]</span>
        <span class="s1">self.extend(found)</span>
        <span class="s2">return </span><span class="s1">bool(found)</span>

    <span class="s2">def </span><span class="s1">exclude(self</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot;Exclude files that match 'pattern'.&quot;&quot;&quot;</span>
        <span class="s1">match = translate_pattern(pattern)</span>
        <span class="s2">return </span><span class="s1">self._remove_files(match.match)</span>

    <span class="s2">def </span><span class="s1">recursive_include(self</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot; 
        Include all files anywhere in 'dir/' that match the pattern. 
        &quot;&quot;&quot;</span>
        <span class="s1">full_pattern = os.path.join(dir</span><span class="s2">, </span><span class="s4">'**'</span><span class="s2">, </span><span class="s1">pattern)</span>
        <span class="s1">found = [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">glob(full_pattern</span><span class="s2">, </span><span class="s1">recursive=</span><span class="s2">True</span><span class="s1">)</span>
                 <span class="s2">if not </span><span class="s1">os.path.isdir(f)]</span>
        <span class="s1">self.extend(found)</span>
        <span class="s2">return </span><span class="s1">bool(found)</span>

    <span class="s2">def </span><span class="s1">recursive_exclude(self</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot; 
        Exclude any file anywhere in 'dir/' that match the pattern. 
        &quot;&quot;&quot;</span>
        <span class="s1">match = translate_pattern(os.path.join(dir</span><span class="s2">, </span><span class="s4">'**'</span><span class="s2">, </span><span class="s1">pattern))</span>
        <span class="s2">return </span><span class="s1">self._remove_files(match.match)</span>

    <span class="s2">def </span><span class="s1">graft(self</span><span class="s2">, </span><span class="s1">dir):</span>
        <span class="s0">&quot;&quot;&quot;Include all files from 'dir/'.&quot;&quot;&quot;</span>
        <span class="s1">found = [</span>
            <span class="s1">item</span>
            <span class="s2">for </span><span class="s1">match_dir </span><span class="s2">in </span><span class="s1">glob(dir)</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">distutils.filelist.findall(match_dir)</span>
        <span class="s1">]</span>
        <span class="s1">self.extend(found)</span>
        <span class="s2">return </span><span class="s1">bool(found)</span>

    <span class="s2">def </span><span class="s1">prune(self</span><span class="s2">, </span><span class="s1">dir):</span>
        <span class="s0">&quot;&quot;&quot;Filter out files from 'dir/'.&quot;&quot;&quot;</span>
        <span class="s1">match = translate_pattern(os.path.join(dir</span><span class="s2">, </span><span class="s4">'**'</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">self._remove_files(match.match)</span>

    <span class="s2">def </span><span class="s1">global_include(self</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot; 
        Include all files anywhere in the current directory that match the 
        pattern. This is very inefficient on large file trees. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.allfiles </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.findall()</span>
        <span class="s1">match = translate_pattern(os.path.join(</span><span class="s4">'**'</span><span class="s2">, </span><span class="s1">pattern))</span>
        <span class="s1">found = [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.allfiles </span><span class="s2">if </span><span class="s1">match.match(f)]</span>
        <span class="s1">self.extend(found)</span>
        <span class="s2">return </span><span class="s1">bool(found)</span>

    <span class="s2">def </span><span class="s1">global_exclude(self</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot; 
        Exclude all files anywhere that match the pattern. 
        &quot;&quot;&quot;</span>
        <span class="s1">match = translate_pattern(os.path.join(</span><span class="s4">'**'</span><span class="s2">, </span><span class="s1">pattern))</span>
        <span class="s2">return </span><span class="s1">self._remove_files(match.match)</span>

    <span class="s2">def </span><span class="s1">append(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s2">if </span><span class="s1">item.endswith(</span><span class="s4">'</span><span class="s2">\r</span><span class="s4">'</span><span class="s1">):  </span><span class="s3"># Fix older sdists built on Windows</span>
            <span class="s1">item = item[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">path = convert_path(item)</span>

        <span class="s2">if </span><span class="s1">self._safe_path(path):</span>
            <span class="s1">self.files.append(path)</span>

    <span class="s2">def </span><span class="s1">extend(self</span><span class="s2">, </span><span class="s1">paths):</span>
        <span class="s1">self.files.extend(filter(self._safe_path</span><span class="s2">, </span><span class="s1">paths))</span>

    <span class="s2">def </span><span class="s1">_repair(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Replace self.files with only safe paths 
 
        Because some owners of FileList manipulate the underlying 
        ``files`` attribute directly, this method must be called to 
        repair those paths. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.files = list(filter(self._safe_path</span><span class="s2">, </span><span class="s1">self.files))</span>

    <span class="s2">def </span><span class="s1">_safe_path(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">enc_warn = </span><span class="s4">&quot;'%s' not %s encodable -- skipping&quot;</span>

        <span class="s3"># To avoid accidental trans-codings errors, first to unicode</span>
        <span class="s1">u_path = unicode_utils.filesys_decode(path)</span>
        <span class="s2">if </span><span class="s1">u_path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">log.warn(</span><span class="s4">&quot;'%s' in unexpected encoding -- skipping&quot; </span><span class="s1">% path)</span>
            <span class="s2">return False</span>

        <span class="s3"># Must ensure utf-8 encodability</span>
        <span class="s1">utf8_path = unicode_utils.try_encode(u_path</span><span class="s2">, </span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">utf8_path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">log.warn(enc_warn</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s2">return False</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># accept is either way checks out</span>
            <span class="s2">if </span><span class="s1">os.path.exists(u_path) </span><span class="s2">or </span><span class="s1">os.path.exists(utf8_path):</span>
                <span class="s2">return True</span>
        <span class="s3"># this will catch any encode errors decoding u_path</span>
        <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
            <span class="s1">log.warn(enc_warn</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">sys.getfilesystemencoding())</span>


<span class="s2">class </span><span class="s1">manifest_maker(sdist):</span>
    <span class="s1">template = </span><span class="s4">&quot;MANIFEST.in&quot;</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s1">self.use_defaults = </span><span class="s5">1</span>
        <span class="s1">self.prune = </span><span class="s5">1</span>
        <span class="s1">self.manifest_only = </span><span class="s5">1</span>
        <span class="s1">self.force_manifest = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s1">self.filelist = FileList()</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(self.manifest):</span>
            <span class="s1">self.write_manifest()  </span><span class="s3"># it must exist so it'll get in the list</span>
        <span class="s1">self.add_defaults()</span>
        <span class="s2">if </span><span class="s1">os.path.exists(self.template):</span>
            <span class="s1">self.read_template()</span>
        <span class="s1">self.add_license_files()</span>
        <span class="s1">self.prune_file_list()</span>
        <span class="s1">self.filelist.sort()</span>
        <span class="s1">self.filelist.remove_duplicates()</span>
        <span class="s1">self.write_manifest()</span>

    <span class="s2">def </span><span class="s1">_manifest_normalize(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">path = unicode_utils.filesys_decode(path)</span>
        <span class="s2">return </span><span class="s1">path.replace(os.sep</span><span class="s2">, </span><span class="s4">'/'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">write_manifest(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Write the file list in 'self.filelist' to the manifest file 
        named by 'self.manifest'. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.filelist._repair()</span>

        <span class="s3"># Now _repairs should encodability, but not unicode</span>
        <span class="s1">files = [self._manifest_normalize(f) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.filelist.files]</span>
        <span class="s1">msg = </span><span class="s4">&quot;writing manifest file '%s'&quot; </span><span class="s1">% self.manifest</span>
        <span class="s1">self.execute(write_file</span><span class="s2">, </span><span class="s1">(self.manifest</span><span class="s2">, </span><span class="s1">files)</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">warn(self</span><span class="s2">, </span><span class="s1">msg):</span>
        <span class="s2">if not </span><span class="s1">self._should_suppress_warning(msg):</span>
            <span class="s1">sdist.warn(self</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_should_suppress_warning(msg):</span>
        <span class="s0">&quot;&quot;&quot; 
        suppress missing-file warnings from sdist 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">re.match(</span><span class="s4">r&quot;standard file .*not found&quot;</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">add_defaults(self):</span>
        <span class="s1">sdist.add_defaults(self)</span>
        <span class="s1">self.filelist.append(self.template)</span>
        <span class="s1">self.filelist.append(self.manifest)</span>
        <span class="s1">rcfiles = list(walk_revctrl())</span>
        <span class="s2">if </span><span class="s1">rcfiles:</span>
            <span class="s1">self.filelist.extend(rcfiles)</span>
        <span class="s2">elif </span><span class="s1">os.path.exists(self.manifest):</span>
            <span class="s1">self.read_manifest()</span>

        <span class="s2">if </span><span class="s1">os.path.exists(</span><span class="s4">&quot;setup.py&quot;</span><span class="s1">):</span>
            <span class="s3"># setup.py should be included by default, even if it's not</span>
            <span class="s3"># the script called to create the sdist</span>
            <span class="s1">self.filelist.append(</span><span class="s4">&quot;setup.py&quot;</span><span class="s1">)</span>

        <span class="s1">ei_cmd = self.get_finalized_command(</span><span class="s4">'egg_info'</span><span class="s1">)</span>
        <span class="s1">self.filelist.graft(ei_cmd.egg_info)</span>

    <span class="s2">def </span><span class="s1">add_license_files(self):</span>
        <span class="s1">license_files = self.distribution.metadata.license_files </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s2">for </span><span class="s1">lf </span><span class="s2">in </span><span class="s1">license_files:</span>
            <span class="s1">log.info(</span><span class="s4">&quot;adding license file '%s'&quot;</span><span class="s2">, </span><span class="s1">lf)</span>
            <span class="s2">pass</span>
        <span class="s1">self.filelist.extend(license_files)</span>

    <span class="s2">def </span><span class="s1">prune_file_list(self):</span>
        <span class="s1">build = self.get_finalized_command(</span><span class="s4">'build'</span><span class="s1">)</span>
        <span class="s1">base_dir = self.distribution.get_fullname()</span>
        <span class="s1">self.filelist.prune(build.build_base)</span>
        <span class="s1">self.filelist.prune(base_dir)</span>
        <span class="s1">sep = re.escape(os.sep)</span>
        <span class="s1">self.filelist.exclude_pattern(</span><span class="s4">r'(^|' </span><span class="s1">+ sep + </span><span class="s4">r')(RCS|CVS|\.svn)' </span><span class="s1">+ sep</span><span class="s2">,</span>
                                      <span class="s1">is_regex=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">write_file(filename</span><span class="s2">, </span><span class="s1">contents):</span>
    <span class="s0">&quot;&quot;&quot;Create a file with the specified name and write 'contents' (a 
    sequence of strings without line terminators) to it. 
    &quot;&quot;&quot;</span>
    <span class="s1">contents = </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(contents)</span>

    <span class="s3"># assuming the contents has been vetted for utf-8 encoding</span>
    <span class="s1">contents = contents.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s4">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:  </span><span class="s3"># always write POSIX-style manifest</span>
        <span class="s1">f.write(contents)</span>


<span class="s2">def </span><span class="s1">write_pkg_info(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">log.info(</span><span class="s4">&quot;writing %s&quot;</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s2">if not </span><span class="s1">cmd.dry_run:</span>
        <span class="s1">metadata = cmd.distribution.metadata</span>
        <span class="s1">metadata.version</span><span class="s2">, </span><span class="s1">oldver = cmd.egg_version</span><span class="s2">, </span><span class="s1">metadata.version</span>
        <span class="s1">metadata.name</span><span class="s2">, </span><span class="s1">oldname = cmd.egg_name</span><span class="s2">, </span><span class="s1">metadata.name</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># write unescaped data to PKG-INFO, so older pkg_resources</span>
            <span class="s3"># can still parse it</span>
            <span class="s1">metadata.write_pkg_info(cmd.egg_info)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">metadata.name</span><span class="s2">, </span><span class="s1">metadata.version = oldname</span><span class="s2">, </span><span class="s1">oldver</span>

        <span class="s1">safe = getattr(cmd.distribution</span><span class="s2">, </span><span class="s4">'zip_safe'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">bdist_egg.write_safety_flag(cmd.egg_info</span><span class="s2">, </span><span class="s1">safe)</span>


<span class="s2">def </span><span class="s1">warn_depends_obsolete(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s2">if </span><span class="s1">os.path.exists(filename):</span>
        <span class="s1">log.warn(</span>
            <span class="s4">&quot;WARNING: 'depends.txt' is not used by setuptools 0.6!</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;Use the install_requires/extras_require setup() args instead.&quot;</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_write_requirements(stream</span><span class="s2">, </span><span class="s1">reqs):</span>
    <span class="s1">lines = yield_lines(reqs </span><span class="s2">or </span><span class="s1">())</span>

    <span class="s2">def </span><span class="s1">append_cr(line):</span>
        <span class="s2">return </span><span class="s1">line + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>
    <span class="s1">lines = map(append_cr</span><span class="s2">, </span><span class="s1">lines)</span>
    <span class="s1">stream.writelines(lines)</span>


<span class="s2">def </span><span class="s1">write_requirements(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">dist = cmd.distribution</span>
    <span class="s1">data = io.StringIO()</span>
    <span class="s1">_write_requirements(data</span><span class="s2">, </span><span class="s1">dist.install_requires)</span>
    <span class="s1">extras_require = dist.extras_require </span><span class="s2">or </span><span class="s1">{}</span>
    <span class="s2">for </span><span class="s1">extra </span><span class="s2">in </span><span class="s1">sorted(extras_require):</span>
        <span class="s1">data.write(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">[{extra}]</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.format(**vars()))</span>
        <span class="s1">_write_requirements(data</span><span class="s2">, </span><span class="s1">extras_require[extra])</span>
    <span class="s1">cmd.write_or_delete_file(</span><span class="s4">&quot;requirements&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">data.getvalue())</span>


<span class="s2">def </span><span class="s1">write_setup_requirements(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">data = io.StringIO()</span>
    <span class="s1">_write_requirements(data</span><span class="s2">, </span><span class="s1">cmd.distribution.setup_requires)</span>
    <span class="s1">cmd.write_or_delete_file(</span><span class="s4">&quot;setup-requirements&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">data.getvalue())</span>


<span class="s2">def </span><span class="s1">write_toplevel_names(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">pkgs = dict.fromkeys(</span>
        <span class="s1">[</span>
            <span class="s1">k.split(</span><span class="s4">'.'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">cmd.distribution.iter_distribution_names()</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">cmd.write_file(</span><span class="s4">&quot;top-level names&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(sorted(pkgs)) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">overwrite_arg(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">write_arg(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">write_arg(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">force=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">argname = os.path.splitext(basename)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">value = getattr(cmd.distribution</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">value = </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(value) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>
    <span class="s1">cmd.write_or_delete_file(argname</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">force)</span>


<span class="s2">def </span><span class="s1">write_entries(cmd</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">ep = cmd.distribution.entry_points</span>

    <span class="s2">if </span><span class="s1">isinstance(ep</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">ep </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">data = ep</span>
    <span class="s2">elif </span><span class="s1">ep </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">data = []</span>
        <span class="s2">for </span><span class="s1">section</span><span class="s2">, </span><span class="s1">contents </span><span class="s2">in </span><span class="s1">sorted(ep.items()):</span>
            <span class="s2">if not </span><span class="s1">isinstance(contents</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">contents = EntryPoint.parse_group(section</span><span class="s2">, </span><span class="s1">contents)</span>
                <span class="s1">contents = </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(sorted(map(str</span><span class="s2">, </span><span class="s1">contents.values())))</span>
            <span class="s1">data.append(</span><span class="s4">'[%s]</span><span class="s2">\n</span><span class="s4">%s</span><span class="s2">\n\n</span><span class="s4">' </span><span class="s1">% (section</span><span class="s2">, </span><span class="s1">contents))</span>
        <span class="s1">data = </span><span class="s4">''</span><span class="s1">.join(data)</span>

    <span class="s1">cmd.write_or_delete_file(</span><span class="s4">'entry points'</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_pkg_info_revision():</span>
    <span class="s0">&quot;&quot;&quot; 
    Get a -r### off of PKG-INFO Version in case this is an sdist of 
    a subversion revision. 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;get_pkg_info_revision is deprecated.&quot;</span><span class="s2">, </span><span class="s1">EggInfoDeprecationWarning)</span>
    <span class="s2">if </span><span class="s1">os.path.exists(</span><span class="s4">'PKG-INFO'</span><span class="s1">):</span>
        <span class="s2">with </span><span class="s1">io.open(</span><span class="s4">'PKG-INFO'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">f:</span>
                <span class="s1">match = re.match(</span><span class="s4">r&quot;Version:.*-r(\d+)\s*$&quot;</span><span class="s2">, </span><span class="s1">line)</span>
                <span class="s2">if </span><span class="s1">match:</span>
                    <span class="s2">return </span><span class="s1">int(match.group(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s5">0</span>


<span class="s2">class </span><span class="s1">EggInfoDeprecationWarning(SetuptoolsDeprecationWarning):</span>
    <span class="s0">&quot;&quot;&quot;Deprecated behavior warning for EggInfo, bypassing suppression.&quot;&quot;&quot;</span>
</pre>
</body>
</html>