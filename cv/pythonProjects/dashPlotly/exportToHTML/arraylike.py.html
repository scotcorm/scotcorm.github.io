<html>
<head>
<title>arraylike.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arraylike.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Methods that can be shared by many array-like classes or subclasses: 
    Series 
    Index 
    ExtensionArray 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.ops_dispatch </span><span class="s2">import </span><span class="s1">maybe_dispatch_ufunc_to_dunder_op</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">ABCNDFrame</span>

<span class="s2">from </span><span class="s1">pandas.core </span><span class="s2">import </span><span class="s1">roperator</span>
<span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">extract_array</span>
<span class="s2">from </span><span class="s1">pandas.core.ops.common </span><span class="s2">import </span><span class="s1">unpack_zerodim_and_defer</span>

<span class="s1">REDUCTION_ALIASES = {</span>
    <span class="s3">&quot;maximum&quot;</span><span class="s1">: </span><span class="s3">&quot;max&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;minimum&quot;</span><span class="s1">: </span><span class="s3">&quot;min&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;add&quot;</span><span class="s1">: </span><span class="s3">&quot;sum&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;multiply&quot;</span><span class="s1">: </span><span class="s3">&quot;prod&quot;</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">OpsMixin:</span>
    <span class="s4"># -------------------------------------------------------------</span>
    <span class="s4"># Comparisons</span>

    <span class="s2">def </span><span class="s1">_cmp_method(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__eq__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._cmp_method(other</span><span class="s2">, </span><span class="s1">operator.eq)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__ne__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._cmp_method(other</span><span class="s2">, </span><span class="s1">operator.ne)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__lt__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._cmp_method(other</span><span class="s2">, </span><span class="s1">operator.lt)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__le__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__le__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._cmp_method(other</span><span class="s2">, </span><span class="s1">operator.le)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__gt__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__gt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._cmp_method(other</span><span class="s2">, </span><span class="s1">operator.gt)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__ge__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__ge__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._cmp_method(other</span><span class="s2">, </span><span class="s1">operator.ge)</span>

    <span class="s4"># -------------------------------------------------------------</span>
    <span class="s4"># Logical Methods</span>

    <span class="s2">def </span><span class="s1">_logical_method(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__and__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__and__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._logical_method(other</span><span class="s2">, </span><span class="s1">operator.and_)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rand__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rand__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._logical_method(other</span><span class="s2">, </span><span class="s1">roperator.rand_)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__or__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__or__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._logical_method(other</span><span class="s2">, </span><span class="s1">operator.or_)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__ror__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__ror__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._logical_method(other</span><span class="s2">, </span><span class="s1">roperator.ror_)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__xor__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__xor__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._logical_method(other</span><span class="s2">, </span><span class="s1">operator.xor)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rxor__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rxor__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._logical_method(other</span><span class="s2">, </span><span class="s1">roperator.rxor)</span>

    <span class="s4"># -------------------------------------------------------------</span>
    <span class="s4"># Arithmetic Methods</span>

    <span class="s2">def </span><span class="s1">_arith_method(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__add__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.add)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__radd__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__radd__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.radd)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__sub__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.sub)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rsub__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rsub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rsub)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__mul__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.mul)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rmul__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rmul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rmul)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__truediv__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__truediv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.truediv)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rtruediv__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rtruediv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rtruediv)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__floordiv__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__floordiv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.floordiv)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rfloordiv&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rfloordiv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rfloordiv)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__mod__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__mod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.mod)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rmod__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rmod)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__divmod__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__divmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">divmod)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rdivmod__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rdivmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rdivmod)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__pow__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__pow__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">operator.pow)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s3">&quot;__rpow__&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__rpow__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._arith_method(other</span><span class="s2">, </span><span class="s1">roperator.rpow)</span>


<span class="s4"># -----------------------------------------------------------------------------</span>
<span class="s4"># Helpers to implement __array_ufunc__</span>


<span class="s2">def </span><span class="s1">_is_aligned(frame</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper to check if a DataFrame is aligned with another DataFrame or Series. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DataFrame</span>

    <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">DataFrame):</span>
        <span class="s2">return </span><span class="s1">frame._indexed_same(other)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># Series -&gt; match index</span>
        <span class="s2">return </span><span class="s1">frame.columns.equals(other.index)</span>


<span class="s2">def </span><span class="s1">_maybe_fallback(ufunc: np.ufunc</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*inputs: Any</span><span class="s2">, </span><span class="s1">**kwargs: Any):</span>
    <span class="s0">&quot;&quot;&quot; 
    In the future DataFrame, inputs to ufuncs will be aligned before applying 
    the ufunc, but for now we ignore the index but raise a warning if behaviour 
    would change in the future. 
    This helper detects the case where a warning is needed and then fallbacks 
    to applying the ufunc on arrays to avoid alignment. 
 
    See https://github.com/pandas-dev/pandas/pull/39239 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DataFrame</span>
    <span class="s2">from </span><span class="s1">pandas.core.generic </span><span class="s2">import </span><span class="s1">NDFrame</span>

    <span class="s1">n_alignable = sum(isinstance(x</span><span class="s2">, </span><span class="s1">NDFrame) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs)</span>
    <span class="s1">n_frames = sum(isinstance(x</span><span class="s2">, </span><span class="s1">DataFrame) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs)</span>

    <span class="s2">if </span><span class="s1">n_alignable &gt;= </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">n_frames &gt;= </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4"># if there are 2 alignable inputs (Series or DataFrame), of which at least 1</span>
        <span class="s4"># is a DataFrame -&gt; we would have had no alignment before -&gt; warn that this</span>
        <span class="s4"># will align in the future</span>

        <span class="s4"># the first frame is what determines the output index/columns in pandas &lt; 1.2</span>
        <span class="s1">first_frame = next(x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">DataFrame))</span>

        <span class="s4"># check if the objects are aligned or not</span>
        <span class="s1">non_aligned = sum(</span>
            <span class="s2">not </span><span class="s1">_is_aligned(first_frame</span><span class="s2">, </span><span class="s1">x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">NDFrame)</span>
        <span class="s1">)</span>

        <span class="s4"># if at least one is not aligned -&gt; warn and fallback to array behaviour</span>
        <span class="s2">if </span><span class="s1">non_aligned:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Calling a ufunc on non-aligned DataFrames (or DataFrame/Series &quot;</span>
                <span class="s3">&quot;combination). Currently, the indices are ignored and the result &quot;</span>
                <span class="s3">&quot;takes the index/columns of the first DataFrame. In the future , &quot;</span>
                <span class="s3">&quot;the DataFrames/Series will be aligned before applying the ufunc.</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Convert one of the arguments to a NumPy array &quot;</span>
                <span class="s3">&quot;(eg 'ufunc(df1, np.asarray(df2)') to keep the current behaviour, &quot;</span>
                <span class="s3">&quot;or align manually (eg 'df1, df2 = df1.align(df2)') before passing to &quot;</span>
                <span class="s3">&quot;the ufunc to obtain the future behaviour and silence this warning.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s4"># keep the first dataframe of the inputs, other DataFrame/Series is</span>
            <span class="s4"># converted to array for fallback behaviour</span>
            <span class="s1">new_inputs = []</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs:</span>
                <span class="s2">if </span><span class="s1">x </span><span class="s2">is </span><span class="s1">first_frame:</span>
                    <span class="s1">new_inputs.append(x)</span>
                <span class="s2">elif </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">NDFrame):</span>
                    <span class="s1">new_inputs.append(np.asarray(x))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">new_inputs.append(x)</span>

            <span class="s4"># call the ufunc on those transformed inputs</span>
            <span class="s2">return </span><span class="s1">getattr(ufunc</span><span class="s2">, </span><span class="s1">method)(*new_inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s4"># signal that we didn't fallback / execute the ufunc yet</span>
    <span class="s2">return </span><span class="s1">NotImplemented</span>


<span class="s2">def </span><span class="s1">array_ufunc(self</span><span class="s2">, </span><span class="s1">ufunc: np.ufunc</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*inputs: Any</span><span class="s2">, </span><span class="s1">**kwargs: Any):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compatibility with numpy ufuncs. 
 
    See also 
    -------- 
    numpy.org/doc/stable/reference/arrays.classes.html#numpy.class.__array_ufunc__ 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas.core.generic </span><span class="s2">import </span><span class="s1">NDFrame</span>
    <span class="s2">from </span><span class="s1">pandas.core.internals </span><span class="s2">import </span><span class="s1">BlockManager</span>

    <span class="s1">cls = type(self)</span>

    <span class="s1">kwargs = _standardize_out_kwarg(**kwargs)</span>

    <span class="s4"># for backwards compatibility check and potentially fallback for non-aligned frames</span>
    <span class="s1">result = _maybe_fallback(ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">if </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">NotImplemented:</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s4"># for binary ops, use our custom dunder methods</span>
    <span class="s1">result = maybe_dispatch_ufunc_to_dunder_op(self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">if </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">NotImplemented:</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s4"># Determine if we should defer.</span>
    <span class="s1">no_defer = (np.ndarray.__array_ufunc__</span><span class="s2">, </span><span class="s1">cls.__array_ufunc__)</span>

    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">inputs:</span>
        <span class="s1">higher_priority = (</span>
            <span class="s1">hasattr(item</span><span class="s2">, </span><span class="s3">&quot;__array_priority__&quot;</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">item.__array_priority__ &gt; self.__array_priority__</span>
        <span class="s1">)</span>
        <span class="s1">has_array_ufunc = (</span>
            <span class="s1">hasattr(item</span><span class="s2">, </span><span class="s3">&quot;__array_ufunc__&quot;</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">type(item).__array_ufunc__ </span><span class="s2">not in </span><span class="s1">no_defer</span>
            <span class="s2">and not </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">self._HANDLED_TYPES)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">higher_priority </span><span class="s2">or </span><span class="s1">has_array_ufunc:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s4"># align all the inputs.</span>
    <span class="s1">types = tuple(type(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs)</span>
    <span class="s1">alignable = [x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(inputs</span><span class="s2">, </span><span class="s1">types) </span><span class="s2">if </span><span class="s1">issubclass(t</span><span class="s2">, </span><span class="s1">NDFrame)]</span>

    <span class="s2">if </span><span class="s1">len(alignable) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4"># This triggers alignment.</span>
        <span class="s4"># At the moment, there aren't any ufuncs with more than two inputs</span>
        <span class="s4"># so this ends up just being x1.index | x2.index, but we write</span>
        <span class="s4"># it to handle *args.</span>

        <span class="s2">if </span><span class="s1">len(set(types)) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># We currently don't handle ufunc(DataFrame, Series)</span>
            <span class="s4"># well. Previously this raised an internal ValueError. We might</span>
            <span class="s4"># support it someday, so raise a NotImplementedError.</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">&quot;Cannot apply ufunc {} to mixed DataFrame and Series &quot;</span>
                <span class="s3">&quot;inputs.&quot;</span><span class="s1">.format(ufunc)</span>
            <span class="s1">)</span>
        <span class="s1">axes = self.axes</span>
        <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">alignable[</span><span class="s5">1</span><span class="s1">:]:</span>
            <span class="s4"># this relies on the fact that we aren't handling mixed</span>
            <span class="s4"># series / frame ufuncs.</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(ax1</span><span class="s2">, </span><span class="s1">ax2) </span><span class="s2">in </span><span class="s1">enumerate(zip(axes</span><span class="s2">, </span><span class="s1">obj.axes)):</span>
                <span class="s1">axes[i] = ax1.union(ax2)</span>

        <span class="s1">reconstruct_axes = dict(zip(self._AXIS_ORDERS</span><span class="s2">, </span><span class="s1">axes))</span>
        <span class="s1">inputs = tuple(</span>
            <span class="s1">x.reindex(**reconstruct_axes) </span><span class="s2">if </span><span class="s1">issubclass(t</span><span class="s2">, </span><span class="s1">NDFrame) </span><span class="s2">else </span><span class="s1">x</span>
            <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(inputs</span><span class="s2">, </span><span class="s1">types)</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">reconstruct_axes = dict(zip(self._AXIS_ORDERS</span><span class="s2">, </span><span class="s1">self.axes))</span>

    <span class="s2">if </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">names = [getattr(x</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs </span><span class="s2">if </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">)]</span>
        <span class="s1">name = names[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(set(names)) == </span><span class="s5">1 </span><span class="s2">else None</span>
        <span class="s1">reconstruct_kwargs = {</span><span class="s3">&quot;name&quot;</span><span class="s1">: name}</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">reconstruct_kwargs = {}</span>

    <span class="s2">def </span><span class="s1">reconstruct(result):</span>
        <span class="s2">if </span><span class="s1">ufunc.nout &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># np.modf, np.frexp, np.divmod</span>
            <span class="s2">return </span><span class="s1">tuple(_reconstruct(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">result)</span>

        <span class="s2">return </span><span class="s1">_reconstruct(result)</span>

    <span class="s2">def </span><span class="s1">_reconstruct(result):</span>
        <span class="s2">if </span><span class="s1">lib.is_scalar(result):</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">if </span><span class="s1">result.ndim != self.ndim:</span>
            <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;outer&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s4"># we already deprecated for Series</span>
                    <span class="s1">msg = (</span>
                        <span class="s3">&quot;outer method for ufunc {} is not implemented on &quot;</span>
                        <span class="s3">&quot;pandas objects. Returning an ndarray, but in the &quot;</span>
                        <span class="s3">&quot;future this will raise a 'NotImplementedError'. &quot;</span>
                        <span class="s3">&quot;Consider explicitly converting the DataFrame &quot;</span>
                        <span class="s3">&quot;to an array with '.to_numpy()' first.&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s1">msg.format(ufunc)</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel=find_stack_level()</span>
                    <span class="s1">)</span>
                    <span class="s2">return </span><span class="s1">result</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">BlockManager):</span>
            <span class="s4"># we went through BlockManager.apply e.g. np.sqrt</span>
            <span class="s1">result = self._constructor(result</span><span class="s2">, </span><span class="s1">**reconstruct_kwargs</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># we converted an array, lost our axes</span>
            <span class="s1">result = self._constructor(</span>
                <span class="s1">result</span><span class="s2">, </span><span class="s1">**reconstruct_axes</span><span class="s2">, </span><span class="s1">**reconstruct_kwargs</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span>
            <span class="s1">)</span>
        <span class="s4"># TODO: When we support multiple values in __finalize__, this</span>
        <span class="s4"># should pass alignable to `__finalize__` instead of self.</span>
        <span class="s4"># Then `np.add(a, b)` would consider attrs from both a and b</span>
        <span class="s4"># when a and b are NDFrames.</span>
        <span class="s2">if </span><span class="s1">len(alignable) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">result = result.__finalize__(self)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">if </span><span class="s3">&quot;out&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s4"># e.g. test_multiindex_get_loc</span>
        <span class="s1">result = dispatch_ufunc_with_out(self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">reconstruct(result)</span>

    <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;reduce&quot;</span><span class="s1">:</span>
        <span class="s4"># e.g. test.series.test_ufunc.test_reduce</span>
        <span class="s1">result = dispatch_reduction_ufunc(self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s4"># We still get here with kwargs `axis` for e.g. np.maximum.accumulate</span>
    <span class="s4">#  and `dtype` and `keepdims` for np.ptp</span>

    <span class="s2">if </span><span class="s1">self.ndim &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">(len(inputs) &gt; </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">ufunc.nout &gt; </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s4"># Just give up on preserving types in the complex case.</span>
        <span class="s4"># In theory we could preserve them for them.</span>
        <span class="s4"># * nout&gt;1 is doable if BlockManager.apply took nout and</span>
        <span class="s4">#   returned a Tuple[BlockManager].</span>
        <span class="s4"># * len(inputs) &gt; 1 is doable when we know that we have</span>
        <span class="s4">#   aligned blocks / dtypes.</span>

        <span class="s4"># e.g. my_ufunc, modf, logaddexp, heaviside, subtract, add</span>
        <span class="s1">inputs = tuple(np.asarray(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs)</span>
        <span class="s4"># Note: we can't use default_array_ufunc here bc reindexing means</span>
        <span class="s4">#  that `self` may not be among `inputs`</span>
        <span class="s1">result = getattr(ufunc</span><span class="s2">, </span><span class="s1">method)(*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">elif </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4"># ufunc(series, ...)</span>
        <span class="s1">inputs = tuple(extract_array(x</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs)</span>
        <span class="s1">result = getattr(ufunc</span><span class="s2">, </span><span class="s1">method)(*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># ufunc(dataframe)</span>
        <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;__call__&quot; </span><span class="s2">and not </span><span class="s1">kwargs:</span>
            <span class="s4"># for np.&lt;ufunc&gt;(..) calls</span>
            <span class="s4"># kwargs cannot necessarily be handled block-by-block, so only</span>
            <span class="s4"># take this path if there are no kwargs</span>
            <span class="s1">mgr = inputs[</span><span class="s5">0</span><span class="s1">]._mgr</span>
            <span class="s1">result = mgr.apply(getattr(ufunc</span><span class="s2">, </span><span class="s1">method))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># otherwise specific ufunc methods (eg np.&lt;ufunc&gt;.accumulate(..))</span>
            <span class="s4"># Those can have an axis keyword and thus can't be called block-by-block</span>
            <span class="s1">result = default_array_ufunc(inputs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s4"># e.g. np.negative (only one reached), with &quot;where&quot; and &quot;out&quot; in kwargs</span>

    <span class="s1">result = reconstruct(result)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_standardize_out_kwarg(**kwargs) -&gt; dict:</span>
    <span class="s0">&quot;&quot;&quot; 
    If kwargs contain &quot;out1&quot; and &quot;out2&quot;, replace that with a tuple &quot;out&quot; 
 
    np.divmod, np.modf, np.frexp can have either `out=(out1, out2)` or 
    `out1=out1, out2=out2)` 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">&quot;out&quot; </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s3">&quot;out1&quot; </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s3">&quot;out2&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s1">out1 = kwargs.pop(</span><span class="s3">&quot;out1&quot;</span><span class="s1">)</span>
        <span class="s1">out2 = kwargs.pop(</span><span class="s3">&quot;out2&quot;</span><span class="s1">)</span>
        <span class="s1">out = (out1</span><span class="s2">, </span><span class="s1">out2)</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;out&quot;</span><span class="s1">] = out</span>
    <span class="s2">return </span><span class="s1">kwargs</span>


<span class="s2">def </span><span class="s1">dispatch_ufunc_with_out(self</span><span class="s2">, </span><span class="s1">ufunc: np.ufunc</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    If we have an `out` keyword, then call the ufunc without `out` and then 
    set the result into the given `out`. 
    &quot;&quot;&quot;</span>

    <span class="s4"># Note: we assume _standardize_out_kwarg has already been called.</span>
    <span class="s1">out = kwargs.pop(</span><span class="s3">&quot;out&quot;</span><span class="s1">)</span>
    <span class="s1">where = kwargs.pop(</span><span class="s3">&quot;where&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s1">result = getattr(ufunc</span><span class="s2">, </span><span class="s1">method)(*inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s4"># i.e. np.divmod, np.modf, np.frexp</span>
        <span class="s2">if not </span><span class="s1">isinstance(out</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">or </span><span class="s1">len(out) != len(result):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span>

        <span class="s2">for </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">res </span><span class="s2">in </span><span class="s1">zip(out</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s1">_assign_where(arr</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">where)</span>

        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">if </span><span class="s1">isinstance(out</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s2">if </span><span class="s1">len(out) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">out = out[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">_assign_where(out</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">where)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_assign_where(out</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">where) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Set a ufunc result into 'out', masking with a 'where' argument if necessary. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">where </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s4"># no 'where' arg passed to ufunc</span>
        <span class="s1">out[:] = result</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">np.putmask(out</span><span class="s2">, </span><span class="s1">where</span><span class="s2">, </span><span class="s1">result)</span>


<span class="s2">def </span><span class="s1">default_array_ufunc(self</span><span class="s2">, </span><span class="s1">ufunc: np.ufunc</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fallback to the behavior we would get if we did not define __array_ufunc__. 
 
    Notes 
    ----- 
    We are assuming that `self` is among `inputs`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">any(x </span><span class="s2">is </span><span class="s1">self </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">new_inputs = [x </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not </span><span class="s1">self </span><span class="s2">else </span><span class="s1">np.asarray(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">inputs]</span>

    <span class="s2">return </span><span class="s1">getattr(ufunc</span><span class="s2">, </span><span class="s1">method)(*new_inputs</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">dispatch_reduction_ufunc(self</span><span class="s2">, </span><span class="s1">ufunc: np.ufunc</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*inputs</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Dispatch ufunc reductions to self's reduction methods. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">method == </span><span class="s3">&quot;reduce&quot;</span>

    <span class="s2">if </span><span class="s1">len(inputs) != </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">inputs[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is not </span><span class="s1">self:</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">if </span><span class="s1">ufunc.__name__ </span><span class="s2">not in </span><span class="s1">REDUCTION_ALIASES:</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s1">method_name = REDUCTION_ALIASES[ufunc.__name__]</span>

    <span class="s4"># NB: we are assuming that min/max represent minimum/maximum methods,</span>
    <span class="s4">#  which would not be accurate for e.g. Timestamp.min</span>
    <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s1">method_name):</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">if </span><span class="s1">self.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">ABCNDFrame):</span>
            <span class="s4"># TODO: test cases where this doesn't hold, i.e. 2D DTA/TDA</span>
            <span class="s1">kwargs[</span><span class="s3">&quot;numeric_only&quot;</span><span class="s1">] = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s3">&quot;axis&quot; </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s4"># For DataFrame reductions we don't want the default axis=0</span>
            <span class="s4"># Note: np.min is not a ufunc, but uses array_function_dispatch,</span>
            <span class="s4">#  so calls DataFrame.min (without ever getting here) with the np.min</span>
            <span class="s4">#  default of axis=None, which DataFrame.min catches and changes to axis=0.</span>
            <span class="s4"># np.minimum.reduce(df) gets here bc axis is not in kwargs,</span>
            <span class="s4">#  so we set axis=0 to match the behaviorof np.minimum.reduce(df.values)</span>
            <span class="s1">kwargs[</span><span class="s3">&quot;axis&quot;</span><span class="s1">] = </span><span class="s5">0</span>

    <span class="s4"># By default, numpy's reductions do not skip NaNs, so we have to</span>
    <span class="s4">#  pass skipna=False</span>
    <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">method_name)(skipna=</span><span class="s2">False, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>