<html>
<head>
<title>req_file.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
req_file.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Requirements file parsing 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">optparse</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">shlex</span>
<span class="s2">import </span><span class="s1">urllib.parse</span>
<span class="s2">from </span><span class="s1">optparse </span><span class="s2">import </span><span class="s1">Values</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pip._internal.cli </span><span class="s2">import </span><span class="s1">cmdoptions</span>
<span class="s2">from </span><span class="s1">pip._internal.exceptions </span><span class="s2">import </span><span class="s1">InstallationError</span><span class="s2">, </span><span class="s1">RequirementsFileParseError</span>
<span class="s2">from </span><span class="s1">pip._internal.models.search_scope </span><span class="s2">import </span><span class="s1">SearchScope</span>
<span class="s2">from </span><span class="s1">pip._internal.network.session </span><span class="s2">import </span><span class="s1">PipSession</span>
<span class="s2">from </span><span class="s1">pip._internal.network.utils </span><span class="s2">import </span><span class="s1">raise_for_status</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.encoding </span><span class="s2">import </span><span class="s1">auto_decode</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.urls </span><span class="s2">import </span><span class="s1">get_url_scheme</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s3"># NoReturn introduced in 3.6.2; imported only for type checking to maintain</span>
    <span class="s3"># pip compatibility with older patch versions of Python 3.6</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">NoReturn</span>

    <span class="s2">from </span><span class="s1">pip._internal.index.package_finder </span><span class="s2">import </span><span class="s1">PackageFinder</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;parse_requirements&quot;</span><span class="s1">]</span>

<span class="s1">ReqFileLines = Iterable[Tuple[int</span><span class="s2">, </span><span class="s1">str]]</span>

<span class="s1">LineParser = Callable[[str]</span><span class="s2">, </span><span class="s1">Tuple[str</span><span class="s2">, </span><span class="s1">Values]]</span>

<span class="s1">SCHEME_RE = re.compile(</span><span class="s4">r&quot;^(http|https|file):&quot;</span><span class="s2">, </span><span class="s1">re.I)</span>
<span class="s1">COMMENT_RE = re.compile(</span><span class="s4">r&quot;(^|\s+)#.*$&quot;</span><span class="s1">)</span>

<span class="s3"># Matches environment variable-style values in '${MY_VARIABLE_1}' with the</span>
<span class="s3"># variable name consisting of only uppercase letters, digits or the '_'</span>
<span class="s3"># (underscore). This follows the POSIX standard defined in IEEE Std 1003.1,</span>
<span class="s3"># 2013 Edition.</span>
<span class="s1">ENV_VAR_RE = re.compile(</span><span class="s4">r&quot;(?P&lt;var&gt;\$\{(?P&lt;name&gt;[A-Z0-9_]+)\})&quot;</span><span class="s1">)</span>

<span class="s1">SUPPORTED_OPTIONS: List[Callable[...</span><span class="s2">, </span><span class="s1">optparse.Option]] = [</span>
    <span class="s1">cmdoptions.index_url</span><span class="s2">,</span>
    <span class="s1">cmdoptions.extra_index_url</span><span class="s2">,</span>
    <span class="s1">cmdoptions.no_index</span><span class="s2">,</span>
    <span class="s1">cmdoptions.constraints</span><span class="s2">,</span>
    <span class="s1">cmdoptions.requirements</span><span class="s2">,</span>
    <span class="s1">cmdoptions.editable</span><span class="s2">,</span>
    <span class="s1">cmdoptions.find_links</span><span class="s2">,</span>
    <span class="s1">cmdoptions.no_binary</span><span class="s2">,</span>
    <span class="s1">cmdoptions.only_binary</span><span class="s2">,</span>
    <span class="s1">cmdoptions.prefer_binary</span><span class="s2">,</span>
    <span class="s1">cmdoptions.require_hashes</span><span class="s2">,</span>
    <span class="s1">cmdoptions.pre</span><span class="s2">,</span>
    <span class="s1">cmdoptions.trusted_host</span><span class="s2">,</span>
    <span class="s1">cmdoptions.use_new_feature</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s3"># options to be passed to requirements</span>
<span class="s1">SUPPORTED_OPTIONS_REQ: List[Callable[...</span><span class="s2">, </span><span class="s1">optparse.Option]] = [</span>
    <span class="s1">cmdoptions.install_options</span><span class="s2">,</span>
    <span class="s1">cmdoptions.global_options</span><span class="s2">,</span>
    <span class="s1">cmdoptions.hash</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s3"># the 'dest' string values</span>
<span class="s1">SUPPORTED_OPTIONS_REQ_DEST = [str(o().dest) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">SUPPORTED_OPTIONS_REQ]</span>


<span class="s2">class </span><span class="s1">ParsedRequirement:</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">requirement: str</span><span class="s2">,</span>
        <span class="s1">is_editable: bool</span><span class="s2">,</span>
        <span class="s1">comes_from: str</span><span class="s2">,</span>
        <span class="s1">constraint: bool</span><span class="s2">,</span>
        <span class="s1">options: Optional[Dict[str</span><span class="s2">, </span><span class="s1">Any]] = </span><span class="s2">None,</span>
        <span class="s1">line_source: Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.requirement = requirement</span>
        <span class="s1">self.is_editable = is_editable</span>
        <span class="s1">self.comes_from = comes_from</span>
        <span class="s1">self.options = options</span>
        <span class="s1">self.constraint = constraint</span>
        <span class="s1">self.line_source = line_source</span>


<span class="s2">class </span><span class="s1">ParsedLine:</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">filename: str</span><span class="s2">,</span>
        <span class="s1">lineno: int</span><span class="s2">,</span>
        <span class="s1">args: str</span><span class="s2">,</span>
        <span class="s1">opts: Values</span><span class="s2">,</span>
        <span class="s1">constraint: bool</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.filename = filename</span>
        <span class="s1">self.lineno = lineno</span>
        <span class="s1">self.opts = opts</span>
        <span class="s1">self.constraint = constraint</span>

        <span class="s2">if </span><span class="s1">args:</span>
            <span class="s1">self.is_requirement = </span><span class="s2">True</span>
            <span class="s1">self.is_editable = </span><span class="s2">False</span>
            <span class="s1">self.requirement = args</span>
        <span class="s2">elif </span><span class="s1">opts.editables:</span>
            <span class="s1">self.is_requirement = </span><span class="s2">True</span>
            <span class="s1">self.is_editable = </span><span class="s2">True</span>
            <span class="s3"># We don't support multiple -e on one line</span>
            <span class="s1">self.requirement = opts.editables[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.is_requirement = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">parse_requirements(</span>
    <span class="s1">filename: str</span><span class="s2">,</span>
    <span class="s1">session: PipSession</span><span class="s2">,</span>
    <span class="s1">finder: Optional[</span><span class="s4">&quot;PackageFinder&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">options: Optional[optparse.Values] = </span><span class="s2">None,</span>
    <span class="s1">constraint: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; Iterator[ParsedRequirement]:</span>
    <span class="s0">&quot;&quot;&quot;Parse a requirements file and yield ParsedRequirement instances. 
 
    :param filename:    Path or url of requirements file. 
    :param session:     PipSession instance. 
    :param finder:      Instance of pip.index.PackageFinder. 
    :param options:     cli options. 
    :param constraint:  If true, parsing a constraint file rather than 
        requirements file. 
    &quot;&quot;&quot;</span>
    <span class="s1">line_parser = get_line_parser(finder)</span>
    <span class="s1">parser = RequirementsFileParser(session</span><span class="s2">, </span><span class="s1">line_parser)</span>

    <span class="s2">for </span><span class="s1">parsed_line </span><span class="s2">in </span><span class="s1">parser.parse(filename</span><span class="s2">, </span><span class="s1">constraint):</span>
        <span class="s1">parsed_req = handle_line(</span>
            <span class="s1">parsed_line</span><span class="s2">, </span><span class="s1">options=options</span><span class="s2">, </span><span class="s1">finder=finder</span><span class="s2">, </span><span class="s1">session=session</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">parsed_req </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">parsed_req</span>


<span class="s2">def </span><span class="s1">preprocess(content: str) -&gt; ReqFileLines:</span>
    <span class="s0">&quot;&quot;&quot;Split, filter, and join lines, and return a line iterator 
 
    :param content: the content of the requirements file 
    &quot;&quot;&quot;</span>
    <span class="s1">lines_enum: ReqFileLines = enumerate(content.splitlines()</span><span class="s2">, </span><span class="s1">start=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">lines_enum = join_lines(lines_enum)</span>
    <span class="s1">lines_enum = ignore_comments(lines_enum)</span>
    <span class="s1">lines_enum = expand_env_variables(lines_enum)</span>
    <span class="s2">return </span><span class="s1">lines_enum</span>


<span class="s2">def </span><span class="s1">handle_requirement_line(</span>
    <span class="s1">line: ParsedLine</span><span class="s2">,</span>
    <span class="s1">options: Optional[optparse.Values] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; ParsedRequirement:</span>

    <span class="s3"># preserve for the nested code path</span>
    <span class="s1">line_comes_from = </span><span class="s4">&quot;{} {} (line {})&quot;</span><span class="s1">.format(</span>
        <span class="s4">&quot;-c&quot; </span><span class="s2">if </span><span class="s1">line.constraint </span><span class="s2">else </span><span class="s4">&quot;-r&quot;</span><span class="s2">,</span>
        <span class="s1">line.filename</span><span class="s2">,</span>
        <span class="s1">line.lineno</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">line.is_requirement</span>

    <span class="s2">if </span><span class="s1">line.is_editable:</span>
        <span class="s3"># For editable requirements, we don't support per-requirement</span>
        <span class="s3"># options, so just return the parsed requirement.</span>
        <span class="s2">return </span><span class="s1">ParsedRequirement(</span>
            <span class="s1">requirement=line.requirement</span><span class="s2">,</span>
            <span class="s1">is_editable=line.is_editable</span><span class="s2">,</span>
            <span class="s1">comes_from=line_comes_from</span><span class="s2">,</span>
            <span class="s1">constraint=line.constraint</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">options:</span>
            <span class="s3"># Disable wheels if the user has specified build options</span>
            <span class="s1">cmdoptions.check_install_build_global(options</span><span class="s2">, </span><span class="s1">line.opts)</span>

        <span class="s3"># get the options that apply to requirements</span>
        <span class="s1">req_options = {}</span>
        <span class="s2">for </span><span class="s1">dest </span><span class="s2">in </span><span class="s1">SUPPORTED_OPTIONS_REQ_DEST:</span>
            <span class="s2">if </span><span class="s1">dest </span><span class="s2">in </span><span class="s1">line.opts.__dict__ </span><span class="s2">and </span><span class="s1">line.opts.__dict__[dest]:</span>
                <span class="s1">req_options[dest] = line.opts.__dict__[dest]</span>

        <span class="s1">line_source = </span><span class="s4">f&quot;line </span><span class="s2">{</span><span class="s1">line.lineno</span><span class="s2">} </span><span class="s4">of </span><span class="s2">{</span><span class="s1">line.filename</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s2">return </span><span class="s1">ParsedRequirement(</span>
            <span class="s1">requirement=line.requirement</span><span class="s2">,</span>
            <span class="s1">is_editable=line.is_editable</span><span class="s2">,</span>
            <span class="s1">comes_from=line_comes_from</span><span class="s2">,</span>
            <span class="s1">constraint=line.constraint</span><span class="s2">,</span>
            <span class="s1">options=req_options</span><span class="s2">,</span>
            <span class="s1">line_source=line_source</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">handle_option_line(</span>
    <span class="s1">opts: Values</span><span class="s2">,</span>
    <span class="s1">filename: str</span><span class="s2">,</span>
    <span class="s1">lineno: int</span><span class="s2">,</span>
    <span class="s1">finder: Optional[</span><span class="s4">&quot;PackageFinder&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">options: Optional[optparse.Values] = </span><span class="s2">None,</span>
    <span class="s1">session: Optional[PipSession] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>

    <span class="s2">if </span><span class="s1">options:</span>
        <span class="s3"># percolate options upward</span>
        <span class="s2">if </span><span class="s1">opts.require_hashes:</span>
            <span class="s1">options.require_hashes = opts.require_hashes</span>
        <span class="s2">if </span><span class="s1">opts.features_enabled:</span>
            <span class="s1">options.features_enabled.extend(</span>
                <span class="s1">f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">opts.features_enabled </span><span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">options.features_enabled</span>
            <span class="s1">)</span>

    <span class="s3"># set finder options</span>
    <span class="s2">if </span><span class="s1">finder:</span>
        <span class="s1">find_links = finder.find_links</span>
        <span class="s1">index_urls = finder.index_urls</span>
        <span class="s2">if </span><span class="s1">opts.index_url:</span>
            <span class="s1">index_urls = [opts.index_url]</span>
        <span class="s2">if </span><span class="s1">opts.no_index </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">index_urls = []</span>
        <span class="s2">if </span><span class="s1">opts.extra_index_urls:</span>
            <span class="s1">index_urls.extend(opts.extra_index_urls)</span>
        <span class="s2">if </span><span class="s1">opts.find_links:</span>
            <span class="s3"># FIXME: it would be nice to keep track of the source</span>
            <span class="s3"># of the find_links: support a find-links local path</span>
            <span class="s3"># relative to a requirements file.</span>
            <span class="s1">value = opts.find_links[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">req_dir = os.path.dirname(os.path.abspath(filename))</span>
            <span class="s1">relative_to_reqs_file = os.path.join(req_dir</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">if </span><span class="s1">os.path.exists(relative_to_reqs_file):</span>
                <span class="s1">value = relative_to_reqs_file</span>
            <span class="s1">find_links.append(value)</span>

        <span class="s2">if </span><span class="s1">session:</span>
            <span class="s3"># We need to update the auth urls in session</span>
            <span class="s1">session.update_index_urls(index_urls)</span>

        <span class="s1">search_scope = SearchScope(</span>
            <span class="s1">find_links=find_links</span><span class="s2">,</span>
            <span class="s1">index_urls=index_urls</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">finder.search_scope = search_scope</span>

        <span class="s2">if </span><span class="s1">opts.pre:</span>
            <span class="s1">finder.set_allow_all_prereleases()</span>

        <span class="s2">if </span><span class="s1">opts.prefer_binary:</span>
            <span class="s1">finder.set_prefer_binary()</span>

        <span class="s2">if </span><span class="s1">session:</span>
            <span class="s2">for </span><span class="s1">host </span><span class="s2">in </span><span class="s1">opts.trusted_hosts </span><span class="s2">or </span><span class="s1">[]:</span>
                <span class="s1">source = </span><span class="s4">f&quot;line </span><span class="s2">{</span><span class="s1">lineno</span><span class="s2">} </span><span class="s4">of </span><span class="s2">{</span><span class="s1">filename</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">session.add_trusted_host(host</span><span class="s2">, </span><span class="s1">source=source)</span>


<span class="s2">def </span><span class="s1">handle_line(</span>
    <span class="s1">line: ParsedLine</span><span class="s2">,</span>
    <span class="s1">options: Optional[optparse.Values] = </span><span class="s2">None,</span>
    <span class="s1">finder: Optional[</span><span class="s4">&quot;PackageFinder&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">session: Optional[PipSession] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; Optional[ParsedRequirement]:</span>
    <span class="s0">&quot;&quot;&quot;Handle a single parsed requirements line; This can result in 
    creating/yielding requirements, or updating the finder. 
 
    :param line:        The parsed line to be processed. 
    :param options:     CLI options. 
    :param finder:      The finder - updated by non-requirement lines. 
    :param session:     The session - updated by non-requirement lines. 
 
    Returns a ParsedRequirement object if the line is a requirement line, 
    otherwise returns None. 
 
    For lines that contain requirements, the only options that have an effect 
    are from SUPPORTED_OPTIONS_REQ, and they are scoped to the 
    requirement. Other options from SUPPORTED_OPTIONS may be present, but are 
    ignored. 
 
    For lines that do not contain requirements, the only options that have an 
    effect are from SUPPORTED_OPTIONS. Options from SUPPORTED_OPTIONS_REQ may 
    be present, but are ignored. These lines may contain multiple options 
    (although our docs imply only one is supported), and all our parsed and 
    affect the finder. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">line.is_requirement:</span>
        <span class="s1">parsed_req = handle_requirement_line(line</span><span class="s2">, </span><span class="s1">options)</span>
        <span class="s2">return </span><span class="s1">parsed_req</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">handle_option_line(</span>
            <span class="s1">line.opts</span><span class="s2">,</span>
            <span class="s1">line.filename</span><span class="s2">,</span>
            <span class="s1">line.lineno</span><span class="s2">,</span>
            <span class="s1">finder</span><span class="s2">,</span>
            <span class="s1">options</span><span class="s2">,</span>
            <span class="s1">session</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">RequirementsFileParser:</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">session: PipSession</span><span class="s2">,</span>
        <span class="s1">line_parser: LineParser</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._session = session</span>
        <span class="s1">self._line_parser = line_parser</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">filename: str</span><span class="s2">, </span><span class="s1">constraint: bool) -&gt; Iterator[ParsedLine]:</span>
        <span class="s0">&quot;&quot;&quot;Parse a given file, yielding parsed lines.&quot;&quot;&quot;</span>
        <span class="s2">yield from </span><span class="s1">self._parse_and_recurse(filename</span><span class="s2">, </span><span class="s1">constraint)</span>

    <span class="s2">def </span><span class="s1">_parse_and_recurse(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">filename: str</span><span class="s2">, </span><span class="s1">constraint: bool</span>
    <span class="s1">) -&gt; Iterator[ParsedLine]:</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">self._parse_file(filename</span><span class="s2">, </span><span class="s1">constraint):</span>
            <span class="s2">if not </span><span class="s1">line.is_requirement </span><span class="s2">and </span><span class="s1">(</span>
                <span class="s1">line.opts.requirements </span><span class="s2">or </span><span class="s1">line.opts.constraints</span>
            <span class="s1">):</span>
                <span class="s3"># parse a nested requirements file</span>
                <span class="s2">if </span><span class="s1">line.opts.requirements:</span>
                    <span class="s1">req_path = line.opts.requirements[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">nested_constraint = </span><span class="s2">False</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">req_path = line.opts.constraints[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">nested_constraint = </span><span class="s2">True</span>

                <span class="s3"># original file is over http</span>
                <span class="s2">if </span><span class="s1">SCHEME_RE.search(filename):</span>
                    <span class="s3"># do a url join so relative paths work</span>
                    <span class="s1">req_path = urllib.parse.urljoin(filename</span><span class="s2">, </span><span class="s1">req_path)</span>
                <span class="s3"># original file and nested file are paths</span>
                <span class="s2">elif not </span><span class="s1">SCHEME_RE.search(req_path):</span>
                    <span class="s3"># do a join so relative paths work</span>
                    <span class="s1">req_path = os.path.join(</span>
                        <span class="s1">os.path.dirname(filename)</span><span class="s2">,</span>
                        <span class="s1">req_path</span><span class="s2">,</span>
                    <span class="s1">)</span>

                <span class="s2">yield from </span><span class="s1">self._parse_and_recurse(req_path</span><span class="s2">, </span><span class="s1">nested_constraint)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">line</span>

    <span class="s2">def </span><span class="s1">_parse_file(self</span><span class="s2">, </span><span class="s1">filename: str</span><span class="s2">, </span><span class="s1">constraint: bool) -&gt; Iterator[ParsedLine]:</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">content = get_file_content(filename</span><span class="s2">, </span><span class="s1">self._session)</span>

        <span class="s1">lines_enum = preprocess(content)</span>

        <span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">args_str</span><span class="s2">, </span><span class="s1">opts = self._line_parser(line)</span>
            <span class="s2">except </span><span class="s1">OptionParsingError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s3"># add offending line</span>
                <span class="s1">msg = </span><span class="s4">f&quot;Invalid requirement: </span><span class="s2">{</span><span class="s1">line</span><span class="s2">}\n{</span><span class="s1">e.msg</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s2">raise </span><span class="s1">RequirementsFileParseError(msg)</span>

            <span class="s2">yield </span><span class="s1">ParsedLine(</span>
                <span class="s1">filename</span><span class="s2">,</span>
                <span class="s1">line_number</span><span class="s2">,</span>
                <span class="s1">args_str</span><span class="s2">,</span>
                <span class="s1">opts</span><span class="s2">,</span>
                <span class="s1">constraint</span><span class="s2">,</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_line_parser(finder: Optional[</span><span class="s4">&quot;PackageFinder&quot;</span><span class="s1">]) -&gt; LineParser:</span>
    <span class="s2">def </span><span class="s1">parse_line(line: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">Values]:</span>
        <span class="s3"># Build new parser for each line since it accumulates appendable</span>
        <span class="s3"># options.</span>
        <span class="s1">parser = build_parser()</span>
        <span class="s1">defaults = parser.get_default_values()</span>
        <span class="s1">defaults.index_url = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">finder:</span>
            <span class="s1">defaults.format_control = finder.format_control</span>

        <span class="s1">args_str</span><span class="s2">, </span><span class="s1">options_str = break_args_options(line)</span>

        <span class="s1">opts</span><span class="s2">, </span><span class="s1">_ = parser.parse_args(shlex.split(options_str)</span><span class="s2">, </span><span class="s1">defaults)</span>

        <span class="s2">return </span><span class="s1">args_str</span><span class="s2">, </span><span class="s1">opts</span>

    <span class="s2">return </span><span class="s1">parse_line</span>


<span class="s2">def </span><span class="s1">break_args_options(line: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot;Break up the line into an args and options string.  We only want to shlex 
    (and then optparse) the options, not the args.  args can contain markers 
    which are corrupted by shlex. 
    &quot;&quot;&quot;</span>
    <span class="s1">tokens = line.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span>
    <span class="s1">args = []</span>
    <span class="s1">options = tokens[:]</span>
    <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">tokens:</span>
        <span class="s2">if </span><span class="s1">token.startswith(</span><span class="s4">&quot;-&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">token.startswith(</span><span class="s4">&quot;--&quot;</span><span class="s1">):</span>
            <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">args.append(token)</span>
            <span class="s1">options.pop(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s4">&quot; &quot;</span><span class="s1">.join(args)</span><span class="s2">, </span><span class="s4">&quot; &quot;</span><span class="s1">.join(options)</span>


<span class="s2">class </span><span class="s1">OptionParsingError(Exception):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">msg: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.msg = msg</span>


<span class="s2">def </span><span class="s1">build_parser() -&gt; optparse.OptionParser:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a parser for parsing requirement lines 
    &quot;&quot;&quot;</span>
    <span class="s1">parser = optparse.OptionParser(add_help_option=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">option_factories = SUPPORTED_OPTIONS + SUPPORTED_OPTIONS_REQ</span>
    <span class="s2">for </span><span class="s1">option_factory </span><span class="s2">in </span><span class="s1">option_factories:</span>
        <span class="s1">option = option_factory()</span>
        <span class="s1">parser.add_option(option)</span>

    <span class="s3"># By default optparse sys.exits on parsing errors. We want to wrap</span>
    <span class="s3"># that in our own exception.</span>
    <span class="s2">def </span><span class="s1">parser_exit(self: Any</span><span class="s2">, </span><span class="s1">msg: str) -&gt; </span><span class="s4">&quot;NoReturn&quot;</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">OptionParsingError(msg)</span>

    <span class="s3"># NOTE: mypy disallows assigning to a method</span>
    <span class="s3">#       https://github.com/python/mypy/issues/2427</span>
    <span class="s1">parser.exit = parser_exit  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s1">parser</span>


<span class="s2">def </span><span class="s1">join_lines(lines_enum: ReqFileLines) -&gt; ReqFileLines:</span>
    <span class="s0">&quot;&quot;&quot;Joins a line ending in '\' with the previous line (except when following 
    comments).  The joined line takes on the index of the first line. 
    &quot;&quot;&quot;</span>
    <span class="s1">primary_line_number = </span><span class="s2">None</span>
    <span class="s1">new_line: List[str] = []</span>
    <span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum:</span>
        <span class="s2">if not </span><span class="s1">line.endswith(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">COMMENT_RE.match(line):</span>
            <span class="s2">if </span><span class="s1">COMMENT_RE.match(line):</span>
                <span class="s3"># this ensures comments are always matched later</span>
                <span class="s1">line = </span><span class="s4">&quot; &quot; </span><span class="s1">+ line</span>
            <span class="s2">if </span><span class="s1">new_line:</span>
                <span class="s1">new_line.append(line)</span>
                <span class="s2">assert </span><span class="s1">primary_line_number </span><span class="s2">is not None</span>
                <span class="s2">yield </span><span class="s1">primary_line_number</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">.join(new_line)</span>
                <span class="s1">new_line = []</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">new_line:</span>
                <span class="s1">primary_line_number = line_number</span>
            <span class="s1">new_line.append(line.strip(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s1">))</span>

    <span class="s3"># last line contains \</span>
    <span class="s2">if </span><span class="s1">new_line:</span>
        <span class="s2">assert </span><span class="s1">primary_line_number </span><span class="s2">is not None</span>
        <span class="s2">yield </span><span class="s1">primary_line_number</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">.join(new_line)</span>

    <span class="s3"># TODO: handle space after '\'.</span>


<span class="s2">def </span><span class="s1">ignore_comments(lines_enum: ReqFileLines) -&gt; ReqFileLines:</span>
    <span class="s0">&quot;&quot;&quot; 
    Strips comments and filter empty lines. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum:</span>
        <span class="s1">line = COMMENT_RE.sub(</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">line)</span>
        <span class="s1">line = line.strip()</span>
        <span class="s2">if </span><span class="s1">line:</span>
            <span class="s2">yield </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line</span>


<span class="s2">def </span><span class="s1">expand_env_variables(lines_enum: ReqFileLines) -&gt; ReqFileLines:</span>
    <span class="s0">&quot;&quot;&quot;Replace all environment variables that can be retrieved via `os.getenv`. 
 
    The only allowed format for environment variables defined in the 
    requirement file is `${MY_VARIABLE_1}` to ensure two things: 
 
    1. Strings that contain a `$` aren't accidentally (partially) expanded. 
    2. Ensure consistency across platforms for requirement files. 
 
    These points are the result of a discussion on the `github pull 
    request #3514 &lt;https://github.com/pypa/pip/pull/3514&gt;`_. 
 
    Valid characters in variable names follow the `POSIX standard 
    &lt;http://pubs.opengroup.org/onlinepubs/9699919799/&gt;`_ and are limited 
    to uppercase letter, digits and the `_` (underscore). 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum:</span>
        <span class="s2">for </span><span class="s1">env_var</span><span class="s2">, </span><span class="s1">var_name </span><span class="s2">in </span><span class="s1">ENV_VAR_RE.findall(line):</span>
            <span class="s1">value = os.getenv(var_name)</span>
            <span class="s2">if not </span><span class="s1">value:</span>
                <span class="s2">continue</span>

            <span class="s1">line = line.replace(env_var</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s2">yield </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line</span>


<span class="s2">def </span><span class="s1">get_file_content(url: str</span><span class="s2">, </span><span class="s1">session: PipSession) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot;Gets the content of a file; it may be a filename, file: URL, or 
    http: URL.  Returns (location, content).  Content is unicode. 
    Respects # -*- coding: declarations on the retrieved files. 
 
    :param url:         File path or url. 
    :param session:     PipSession instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">scheme = get_url_scheme(url)</span>

    <span class="s3"># Pip has special support for file:// URLs (LocalFSAdapter).</span>
    <span class="s2">if </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;http&quot;</span><span class="s2">, </span><span class="s4">&quot;https&quot;</span><span class="s2">, </span><span class="s4">&quot;file&quot;</span><span class="s1">]:</span>
        <span class="s1">resp = session.get(url)</span>
        <span class="s1">raise_for_status(resp)</span>
        <span class="s2">return </span><span class="s1">resp.url</span><span class="s2">, </span><span class="s1">resp.text</span>

    <span class="s3"># Assume this is a bare path.</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">with </span><span class="s1">open(url</span><span class="s2">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">content = auto_decode(f.read())</span>
    <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">exc:</span>
        <span class="s2">raise </span><span class="s1">InstallationError(</span><span class="s4">f&quot;Could not open requirements file: </span><span class="s2">{</span><span class="s1">exc</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">url</span><span class="s2">, </span><span class="s1">content</span>
</pre>
</body>
</html>