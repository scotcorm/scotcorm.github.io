<html>
<head>
<title>mpltools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mpltools.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tools 
 
A module for converting from mpl language to plotly language. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">datetime</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">matplotlib.dates</span>


<span class="s2">def </span><span class="s1">check_bar_match(old_bar</span><span class="s2">, </span><span class="s1">new_bar):</span>
    <span class="s0">&quot;&quot;&quot;Check if two bars belong in the same collection (bar chart). 
 
    Positional arguments: 
    old_bar -- a previously sorted bar dictionary. 
    new_bar -- a new bar dictionary that needs to be sorted. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tests = []</span>
    <span class="s1">tests += (new_bar[</span><span class="s3">&quot;orientation&quot;</span><span class="s1">] == old_bar[</span><span class="s3">&quot;orientation&quot;</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">tests += (new_bar[</span><span class="s3">&quot;facecolor&quot;</span><span class="s1">] == old_bar[</span><span class="s3">&quot;facecolor&quot;</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">new_bar[</span><span class="s3">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s3">&quot;v&quot;</span><span class="s1">:</span>
        <span class="s1">new_width = new_bar[</span><span class="s3">&quot;x1&quot;</span><span class="s1">] - new_bar[</span><span class="s3">&quot;x0&quot;</span><span class="s1">]</span>
        <span class="s1">old_width = old_bar[</span><span class="s3">&quot;x1&quot;</span><span class="s1">] - old_bar[</span><span class="s3">&quot;x0&quot;</span><span class="s1">]</span>
        <span class="s1">tests += (new_width - old_width &lt; </span><span class="s4">0.000001</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">tests += (new_bar[</span><span class="s3">&quot;y0&quot;</span><span class="s1">] == old_bar[</span><span class="s3">&quot;y0&quot;</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">new_bar[</span><span class="s3">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s3">&quot;h&quot;</span><span class="s1">:</span>
        <span class="s1">new_height = new_bar[</span><span class="s3">&quot;y1&quot;</span><span class="s1">] - new_bar[</span><span class="s3">&quot;y0&quot;</span><span class="s1">]</span>
        <span class="s1">old_height = old_bar[</span><span class="s3">&quot;y1&quot;</span><span class="s1">] - old_bar[</span><span class="s3">&quot;y0&quot;</span><span class="s1">]</span>
        <span class="s1">tests += (new_height - old_height &lt; </span><span class="s4">0.000001</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">tests += (new_bar[</span><span class="s3">&quot;x0&quot;</span><span class="s1">] == old_bar[</span><span class="s3">&quot;x0&quot;</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">all(tests):</span>
        <span class="s2">return True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">check_corners(inner_obj</span><span class="s2">, </span><span class="s1">outer_obj):</span>
    <span class="s1">inner_corners = inner_obj.get_window_extent().corners()</span>
    <span class="s1">outer_corners = outer_obj.get_window_extent().corners()</span>
    <span class="s2">if </span><span class="s1">inner_corners[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] &lt; outer_corners[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s2">return False</span>
    <span class="s2">elif </span><span class="s1">inner_corners[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] &lt; outer_corners[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">return False</span>
    <span class="s2">elif </span><span class="s1">inner_corners[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] &gt; outer_corners[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s2">return False</span>
    <span class="s2">elif </span><span class="s1">inner_corners[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] &gt; outer_corners[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">convert_dash(mpl_dash):</span>
    <span class="s0">&quot;&quot;&quot;Convert mpl line symbol to plotly line symbol and return symbol.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mpl_dash </span><span class="s2">in </span><span class="s1">DASH_MAP:</span>
        <span class="s2">return </span><span class="s1">DASH_MAP[mpl_dash]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dash_array = mpl_dash.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">len(dash_array) &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;solid&quot;</span>

        <span class="s5"># Catch the exception where the off length is zero, in case</span>
        <span class="s5"># matplotlib 'solid' changes from '10,0' to 'N,0'</span>
        <span class="s2">if </span><span class="s1">math.isclose(float(dash_array[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s3">&quot;solid&quot;</span>

        <span class="s5"># If we can't find the dash pattern in the map, convert it</span>
        <span class="s5"># into custom values in px, e.g. '7,5' -&gt; '7px,5px'</span>
        <span class="s1">dashpx = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join([x + </span><span class="s3">&quot;px&quot; </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dash_array])</span>

        <span class="s5"># TODO: rewrite the convert_dash code</span>
        <span class="s5"># only strings 'solid', 'dashed', etc allowed</span>
        <span class="s2">if </span><span class="s1">dashpx == </span><span class="s3">&quot;7.4px,3.2px&quot;</span><span class="s1">:</span>
            <span class="s1">dashpx = </span><span class="s3">&quot;dashed&quot;</span>
        <span class="s2">elif </span><span class="s1">dashpx == </span><span class="s3">&quot;12.8px,3.2px,2.0px,3.2px&quot;</span><span class="s1">:</span>
            <span class="s1">dashpx = </span><span class="s3">&quot;dashdot&quot;</span>
        <span class="s2">elif </span><span class="s1">dashpx == </span><span class="s3">&quot;2.0px,3.3px&quot;</span><span class="s1">:</span>
            <span class="s1">dashpx = </span><span class="s3">&quot;dotted&quot;</span>
        <span class="s2">return </span><span class="s1">dashpx</span>


<span class="s2">def </span><span class="s1">convert_path(path):</span>
    <span class="s1">verts = path[</span><span class="s4">0</span><span class="s1">]  </span><span class="s5"># may use this later</span>
    <span class="s1">code = tuple(path[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">code </span><span class="s2">in </span><span class="s1">PATH_MAP:</span>
        <span class="s2">return </span><span class="s1">PATH_MAP[code]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">convert_symbol(mpl_symbol):</span>
    <span class="s0">&quot;&quot;&quot;Convert mpl marker symbol to plotly symbol and return symbol.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(mpl_symbol</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s1">symbol = list()</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">mpl_symbol:</span>
            <span class="s1">symbol += [convert_symbol(s)]</span>
        <span class="s2">return </span><span class="s1">symbol</span>
    <span class="s2">elif </span><span class="s1">mpl_symbol </span><span class="s2">in </span><span class="s1">SYMBOL_MAP:</span>
        <span class="s2">return </span><span class="s1">SYMBOL_MAP[mpl_symbol]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">&quot;circle&quot;  </span><span class="s5"># default</span>


<span class="s2">def </span><span class="s1">hex_to_rgb(value):</span>
    <span class="s0">&quot;&quot;&quot; 
    Change a hex color to an rgb tuple 
 
    :param (str|unicode) value: The hex string we want to convert. 
    :return: (int, int, int) The red, green, blue int-tuple. 
 
    Example: 
 
        '#FFFFFF' --&gt; (255, 255, 255) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">value = value.lstrip(</span><span class="s3">&quot;#&quot;</span><span class="s1">)</span>
    <span class="s1">lv = len(value)</span>
    <span class="s2">return </span><span class="s1">tuple(int(value[i : i + lv // </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">16</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">lv</span><span class="s2">, </span><span class="s1">lv // </span><span class="s4">3</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">merge_color_and_opacity(color</span><span class="s2">, </span><span class="s1">opacity):</span>
    <span class="s0">&quot;&quot;&quot; 
    Merge hex color with an alpha (opacity) to get an rgba tuple. 
 
    :param (str|unicode) color: A hex color string. 
    :param (float|int) opacity: A value [0, 1] for the 'a' in 'rgba'. 
    :return: (int, int, int, float) The rgba color and alpha tuple. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:  </span><span class="s5"># None can be used as a placeholder, just bail.</span>
        <span class="s2">return None</span>

    <span class="s1">rgb_tup = hex_to_rgb(color)</span>
    <span class="s2">if </span><span class="s1">opacity </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">&quot;rgb {}&quot;</span><span class="s1">.format(rgb_tup)</span>

    <span class="s1">rgba_tup = rgb_tup + (opacity</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s3">&quot;rgba {}&quot;</span><span class="s1">.format(rgba_tup)</span>


<span class="s2">def </span><span class="s1">convert_va(mpl_va):</span>
    <span class="s0">&quot;&quot;&quot;Convert mpl vertical alignment word to equivalent HTML word. 
 
    Text alignment specifiers from mpl differ very slightly from those used 
    in HTML. See the VA_MAP for more details. 
 
    Positional arguments: 
    mpl_va -- vertical mpl text alignment spec. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mpl_va </span><span class="s2">in </span><span class="s1">VA_MAP:</span>
        <span class="s2">return </span><span class="s1">VA_MAP[mpl_va]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return None  </span><span class="s5"># let plotly figure it out!</span>


<span class="s2">def </span><span class="s1">convert_x_domain(mpl_plot_bounds</span><span class="s2">, </span><span class="s1">mpl_max_x_bounds):</span>
    <span class="s0">&quot;&quot;&quot;Map x dimension of current plot to plotly's domain space. 
 
    The bbox used to locate an axes object in mpl differs from the 
    method used to locate axes in plotly. The mpl version locates each 
    axes in the figure so that axes in a single-plot figure might have 
    the bounds, [0.125, 0.125, 0.775, 0.775] (x0, y0, width, height), 
    in mpl's figure coordinates. However, the axes all share one space in 
    plotly such that the domain will always be [0, 0, 1, 1] 
    (x0, y0, x1, y1). To convert between the two, the mpl figure bounds 
    need to be mapped to a [0, 1] domain for x and y. The margins set 
    upon opening a new figure will appropriately match the mpl margins. 
 
    Optionally, setting margins=0 and simply copying the domains from 
    mpl to plotly would place axes appropriately. However, 
    this would throw off axis and title labeling. 
 
    Positional arguments: 
    mpl_plot_bounds -- the (x0, y0, width, height) params for current ax ** 
    mpl_max_x_bounds -- overall (x0, x1) bounds for all axes ** 
 
    ** these are all specified in mpl figure coordinates 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mpl_x_dom = [mpl_plot_bounds[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mpl_plot_bounds[</span><span class="s4">0</span><span class="s1">] + mpl_plot_bounds[</span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s1">plotting_width = mpl_max_x_bounds[</span><span class="s4">1</span><span class="s1">] - mpl_max_x_bounds[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">x0 = (mpl_x_dom[</span><span class="s4">0</span><span class="s1">] - mpl_max_x_bounds[</span><span class="s4">0</span><span class="s1">]) / plotting_width</span>
    <span class="s1">x1 = (mpl_x_dom[</span><span class="s4">1</span><span class="s1">] - mpl_max_x_bounds[</span><span class="s4">0</span><span class="s1">]) / plotting_width</span>
    <span class="s2">return </span><span class="s1">[x0</span><span class="s2">, </span><span class="s1">x1]</span>


<span class="s2">def </span><span class="s1">convert_y_domain(mpl_plot_bounds</span><span class="s2">, </span><span class="s1">mpl_max_y_bounds):</span>
    <span class="s0">&quot;&quot;&quot;Map y dimension of current plot to plotly's domain space. 
 
    The bbox used to locate an axes object in mpl differs from the 
    method used to locate axes in plotly. The mpl version locates each 
    axes in the figure so that axes in a single-plot figure might have 
    the bounds, [0.125, 0.125, 0.775, 0.775] (x0, y0, width, height), 
    in mpl's figure coordinates. However, the axes all share one space in 
    plotly such that the domain will always be [0, 0, 1, 1] 
    (x0, y0, x1, y1). To convert between the two, the mpl figure bounds 
    need to be mapped to a [0, 1] domain for x and y. The margins set 
    upon opening a new figure will appropriately match the mpl margins. 
 
    Optionally, setting margins=0 and simply copying the domains from 
    mpl to plotly would place axes appropriately. However, 
    this would throw off axis and title labeling. 
 
    Positional arguments: 
    mpl_plot_bounds -- the (x0, y0, width, height) params for current ax ** 
    mpl_max_y_bounds -- overall (y0, y1) bounds for all axes ** 
 
    ** these are all specified in mpl figure coordinates 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mpl_y_dom = [mpl_plot_bounds[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mpl_plot_bounds[</span><span class="s4">1</span><span class="s1">] + mpl_plot_bounds[</span><span class="s4">3</span><span class="s1">]]</span>
    <span class="s1">plotting_height = mpl_max_y_bounds[</span><span class="s4">1</span><span class="s1">] - mpl_max_y_bounds[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">y0 = (mpl_y_dom[</span><span class="s4">0</span><span class="s1">] - mpl_max_y_bounds[</span><span class="s4">0</span><span class="s1">]) / plotting_height</span>
    <span class="s1">y1 = (mpl_y_dom[</span><span class="s4">1</span><span class="s1">] - mpl_max_y_bounds[</span><span class="s4">0</span><span class="s1">]) / plotting_height</span>
    <span class="s2">return </span><span class="s1">[y0</span><span class="s2">, </span><span class="s1">y1]</span>


<span class="s2">def </span><span class="s1">display_to_paper(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">layout):</span>
    <span class="s0">&quot;&quot;&quot;Convert mpl display coordinates to plotly paper coordinates. 
 
    Plotly references object positions with an (x, y) coordinate pair in either 
    'data' or 'paper' coordinates which reference actual data in a plot or 
    the entire plotly axes space where the bottom-left of the bottom-left 
    plot has the location (x, y) = (0, 0) and the top-right of the top-right 
    plot has the location (x, y) = (1, 1). Display coordinates in mpl reference 
    objects with an (x, y) pair in pixel coordinates, where the bottom-left 
    corner is at the location (x, y) = (0, 0) and the top-right corner is at 
    the location (x, y) = (figwidth*dpi, figheight*dpi). Here, figwidth and 
    figheight are in inches and dpi are the dots per inch resolution. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">num_x = x - layout[</span><span class="s3">&quot;margin&quot;</span><span class="s1">][</span><span class="s3">&quot;l&quot;</span><span class="s1">]</span>
    <span class="s1">den_x = layout[</span><span class="s3">&quot;width&quot;</span><span class="s1">] - (layout[</span><span class="s3">&quot;margin&quot;</span><span class="s1">][</span><span class="s3">&quot;l&quot;</span><span class="s1">] + layout[</span><span class="s3">&quot;margin&quot;</span><span class="s1">][</span><span class="s3">&quot;r&quot;</span><span class="s1">])</span>
    <span class="s1">num_y = y - layout[</span><span class="s3">&quot;margin&quot;</span><span class="s1">][</span><span class="s3">&quot;b&quot;</span><span class="s1">]</span>
    <span class="s1">den_y = layout[</span><span class="s3">&quot;height&quot;</span><span class="s1">] - (layout[</span><span class="s3">&quot;margin&quot;</span><span class="s1">][</span><span class="s3">&quot;b&quot;</span><span class="s1">] + layout[</span><span class="s3">&quot;margin&quot;</span><span class="s1">][</span><span class="s3">&quot;t&quot;</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">num_x / den_x</span><span class="s2">, </span><span class="s1">num_y / den_y</span>


<span class="s2">def </span><span class="s1">get_axes_bounds(fig):</span>
    <span class="s0">&quot;&quot;&quot;Return the entire axes space for figure. 
 
    An axes object in mpl is specified by its relation to the figure where 
    (0,0) corresponds to the bottom-left part of the figure and (1,1) 
    corresponds to the top-right. Margins exist in matplotlib because axes 
    objects normally don't go to the edges of the figure. 
 
    In plotly, the axes area (where all subplots go) is always specified with 
    the domain [0,1] for both x and y. This function finds the smallest box, 
    specified by two points, that all of the mpl axes objects fit into. This 
    box is then used to map mpl axes domains to plotly axes domains. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x_min</span><span class="s2">, </span><span class="s1">x_max</span><span class="s2">, </span><span class="s1">y_min</span><span class="s2">, </span><span class="s1">y_max = []</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>
    <span class="s2">for </span><span class="s1">axes_obj </span><span class="s2">in </span><span class="s1">fig.get_axes():</span>
        <span class="s1">bounds = axes_obj.get_position().bounds</span>
        <span class="s1">x_min.append(bounds[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">x_max.append(bounds[</span><span class="s4">0</span><span class="s1">] + bounds[</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">y_min.append(bounds[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">y_max.append(bounds[</span><span class="s4">1</span><span class="s1">] + bounds[</span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">x_min</span><span class="s2">, </span><span class="s1">y_min</span><span class="s2">, </span><span class="s1">x_max</span><span class="s2">, </span><span class="s1">y_max = min(x_min)</span><span class="s2">, </span><span class="s1">min(y_min)</span><span class="s2">, </span><span class="s1">max(x_max)</span><span class="s2">, </span><span class="s1">max(y_max)</span>
    <span class="s2">return </span><span class="s1">(x_min</span><span class="s2">, </span><span class="s1">x_max)</span><span class="s2">, </span><span class="s1">(y_min</span><span class="s2">, </span><span class="s1">y_max)</span>


<span class="s2">def </span><span class="s1">get_axis_mirror(main_spine</span><span class="s2">, </span><span class="s1">mirror_spine):</span>
    <span class="s2">if </span><span class="s1">main_spine </span><span class="s2">and </span><span class="s1">mirror_spine:</span>
        <span class="s2">return </span><span class="s3">&quot;ticks&quot;</span>
    <span class="s2">elif </span><span class="s1">main_spine </span><span class="s2">and not </span><span class="s1">mirror_spine:</span>
        <span class="s2">return False</span>
    <span class="s2">elif not </span><span class="s1">main_spine </span><span class="s2">and </span><span class="s1">mirror_spine:</span>
        <span class="s2">return False  </span><span class="s5"># can't handle this case yet!</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return False  </span><span class="s5"># nuttin'!</span>


<span class="s2">def </span><span class="s1">get_bar_gap(bar_starts</span><span class="s2">, </span><span class="s1">bar_ends</span><span class="s2">, </span><span class="s1">tol=</span><span class="s4">1e-10</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">len(bar_starts) == len(bar_ends) </span><span class="s2">and </span><span class="s1">len(bar_starts) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">sides1 = bar_starts[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">sides2 = bar_ends[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">gaps = [s2 - s1 </span><span class="s2">for </span><span class="s1">s2</span><span class="s2">, </span><span class="s1">s1 </span><span class="s2">in </span><span class="s1">zip(sides1</span><span class="s2">, </span><span class="s1">sides2)]</span>
        <span class="s1">gap0 = gaps[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">uniform = all([abs(gap0 - gap) &lt; tol </span><span class="s2">for </span><span class="s1">gap </span><span class="s2">in </span><span class="s1">gaps])</span>
        <span class="s2">if </span><span class="s1">uniform:</span>
            <span class="s2">return </span><span class="s1">gap0</span>


<span class="s2">def </span><span class="s1">convert_rgba_array(color_list):</span>
    <span class="s1">clean_color_list = list()</span>
    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">color_list:</span>
        <span class="s1">clean_color_list += [</span>
            <span class="s1">(dict(r=int(c[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">255</span><span class="s1">)</span><span class="s2">, </span><span class="s1">g=int(c[</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">255</span><span class="s1">)</span><span class="s2">, </span><span class="s1">b=int(c[</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">255</span><span class="s1">)</span><span class="s2">, </span><span class="s1">a=c[</span><span class="s4">3</span><span class="s1">]))</span>
        <span class="s1">]</span>
    <span class="s1">plotly_colors = list()</span>
    <span class="s2">for </span><span class="s1">rgba </span><span class="s2">in </span><span class="s1">clean_color_list:</span>
        <span class="s1">plotly_colors += [</span><span class="s3">&quot;rgba({r},{g},{b},{a})&quot;</span><span class="s1">.format(**rgba)]</span>
    <span class="s2">if </span><span class="s1">len(plotly_colors) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">plotly_colors[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">plotly_colors</span>


<span class="s2">def </span><span class="s1">convert_path_array(path_array):</span>
    <span class="s1">symbols = list()</span>
    <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">path_array:</span>
        <span class="s1">symbols += [convert_path(path)]</span>
    <span class="s2">if </span><span class="s1">len(symbols) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">symbols[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">symbols</span>


<span class="s2">def </span><span class="s1">convert_linewidth_array(width_array):</span>
    <span class="s2">if </span><span class="s1">len(width_array) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">width_array[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">width_array</span>


<span class="s2">def </span><span class="s1">convert_size_array(size_array):</span>
    <span class="s1">size = [math.sqrt(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">size_array]</span>
    <span class="s2">if </span><span class="s1">len(size) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">size[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">size</span>


<span class="s2">def </span><span class="s1">get_markerstyle_from_collection(props):</span>
    <span class="s1">markerstyle = dict(</span>
        <span class="s1">alpha=</span><span class="s2">None,</span>
        <span class="s1">facecolor=convert_rgba_array(props[</span><span class="s3">&quot;styles&quot;</span><span class="s1">][</span><span class="s3">&quot;facecolor&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">marker=convert_path_array(props[</span><span class="s3">&quot;paths&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">edgewidth=convert_linewidth_array(props[</span><span class="s3">&quot;styles&quot;</span><span class="s1">][</span><span class="s3">&quot;linewidth&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s5"># markersize=convert_size_array(props['styles']['size']),  # TODO!</span>
        <span class="s1">markersize=convert_size_array(props[</span><span class="s3">&quot;mplobj&quot;</span><span class="s1">].get_sizes())</span><span class="s2">,</span>
        <span class="s1">edgecolor=convert_rgba_array(props[</span><span class="s3">&quot;styles&quot;</span><span class="s1">][</span><span class="s3">&quot;edgecolor&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">markerstyle</span>


<span class="s2">def </span><span class="s1">get_rect_xmin(data):</span>
    <span class="s0">&quot;&quot;&quot;Find minimum x value from four (x,y) vertices.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">min(data[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_rect_xmax(data):</span>
    <span class="s0">&quot;&quot;&quot;Find maximum x value from four (x,y) vertices.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">max(data[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_rect_ymin(data):</span>
    <span class="s0">&quot;&quot;&quot;Find minimum y value from four (x,y) vertices.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">min(data[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_rect_ymax(data):</span>
    <span class="s0">&quot;&quot;&quot;Find maximum y value from four (x,y) vertices.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">max(data[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_spine_visible(ax</span><span class="s2">, </span><span class="s1">spine_key):</span>
    <span class="s0">&quot;&quot;&quot;Return some spine parameters for the spine, `spine_key`.&quot;&quot;&quot;</span>
    <span class="s1">spine = ax.spines[spine_key]</span>
    <span class="s1">ax_frame_on = ax.get_frame_on()</span>
    <span class="s1">position = spine._position </span><span class="s2">or </span><span class="s1">(</span><span class="s3">&quot;outward&quot;</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">isinstance(position</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">position == </span><span class="s3">&quot;center&quot;</span><span class="s1">:</span>
            <span class="s1">position = (</span><span class="s3">&quot;axes&quot;</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s3">&quot;zero&quot;</span><span class="s1">:</span>
            <span class="s1">position = (</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">position_type</span><span class="s2">, </span><span class="s1">amount = position</span>
    <span class="s2">if </span><span class="s1">position_type == </span><span class="s3">&quot;outward&quot; </span><span class="s2">and </span><span class="s1">amount == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">spine_frame_like = </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">spine_frame_like = </span><span class="s2">False</span>
    <span class="s2">if not </span><span class="s1">spine.get_visible():</span>
        <span class="s2">return False</span>
    <span class="s2">elif not </span><span class="s1">spine._edgecolor[-</span><span class="s4">1</span><span class="s1">]:  </span><span class="s5"># user's may have set edgecolor alpha==0</span>
        <span class="s2">return False</span>
    <span class="s2">elif not </span><span class="s1">ax_frame_on </span><span class="s2">and </span><span class="s1">spine_frame_like:</span>
        <span class="s2">return False</span>
    <span class="s2">elif </span><span class="s1">ax_frame_on </span><span class="s2">and </span><span class="s1">spine_frame_like:</span>
        <span class="s2">return True</span>
    <span class="s2">elif not </span><span class="s1">ax_frame_on </span><span class="s2">and not </span><span class="s1">spine_frame_like:</span>
        <span class="s2">return True  </span><span class="s5"># we've already checked for that it's visible.</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return False  </span><span class="s5"># oh man, and i thought we exhausted the options...</span>


<span class="s2">def </span><span class="s1">is_bar(bar_containers</span><span class="s2">, </span><span class="s1">**props):</span>
    <span class="s0">&quot;&quot;&quot;A test to decide whether a path is a bar from a vertical bar chart.&quot;&quot;&quot;</span>

    <span class="s5"># is this patch in a bar container?</span>
    <span class="s2">for </span><span class="s1">container </span><span class="s2">in </span><span class="s1">bar_containers:</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s3">&quot;mplobj&quot;</span><span class="s1">] </span><span class="s2">in </span><span class="s1">container:</span>
            <span class="s2">return True</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">make_bar(**props):</span>
    <span class="s0">&quot;&quot;&quot;Make an intermediate bar dictionary. 
 
    This creates a bar dictionary which aids in the comparison of new bars to 
    old bars from other bar chart (patch) collections. This is not the 
    dictionary that needs to get passed to plotly as a data dictionary. That 
    happens in PlotlyRenderer in that class's draw_bar method. In other 
    words, this dictionary describes a SINGLE bar, whereas, plotly will 
    require a set of bars to be passed in a data dictionary. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s3">&quot;bar&quot;</span><span class="s1">: props[</span><span class="s3">&quot;mplobj&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;x0&quot;</span><span class="s1">: get_rect_xmin(props[</span><span class="s3">&quot;data&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s3">&quot;y0&quot;</span><span class="s1">: get_rect_ymin(props[</span><span class="s3">&quot;data&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s3">&quot;x1&quot;</span><span class="s1">: get_rect_xmax(props[</span><span class="s3">&quot;data&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s3">&quot;y1&quot;</span><span class="s1">: get_rect_ymax(props[</span><span class="s3">&quot;data&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s3">&quot;alpha&quot;</span><span class="s1">: props[</span><span class="s3">&quot;style&quot;</span><span class="s1">][</span><span class="s3">&quot;alpha&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;edgecolor&quot;</span><span class="s1">: props[</span><span class="s3">&quot;style&quot;</span><span class="s1">][</span><span class="s3">&quot;edgecolor&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;facecolor&quot;</span><span class="s1">: props[</span><span class="s3">&quot;style&quot;</span><span class="s1">][</span><span class="s3">&quot;facecolor&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;edgewidth&quot;</span><span class="s1">: props[</span><span class="s3">&quot;style&quot;</span><span class="s1">][</span><span class="s3">&quot;edgewidth&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;dasharray&quot;</span><span class="s1">: props[</span><span class="s3">&quot;style&quot;</span><span class="s1">][</span><span class="s3">&quot;dasharray&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;zorder&quot;</span><span class="s1">: props[</span><span class="s3">&quot;style&quot;</span><span class="s1">][</span><span class="s3">&quot;zorder&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">prep_ticks(ax</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">ax_type</span><span class="s2">, </span><span class="s1">props):</span>
    <span class="s0">&quot;&quot;&quot;Prepare axis obj belonging to axes obj. 
 
    positional arguments: 
    ax - the mpl axes instance 
    index - the index of the axis in `props` 
    ax_type - 'x' or 'y' (for now) 
    props - an mplexporter poperties dictionary 
 
    &quot;&quot;&quot;</span>
    <span class="s1">axis_dict = dict()</span>
    <span class="s2">if </span><span class="s1">ax_type == </span><span class="s3">&quot;x&quot;</span><span class="s1">:</span>
        <span class="s1">axis = ax.get_xaxis()</span>
    <span class="s2">elif </span><span class="s1">ax_type == </span><span class="s3">&quot;y&quot;</span><span class="s1">:</span>
        <span class="s1">axis = ax.get_yaxis()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">dict()  </span><span class="s5"># whoops!</span>

    <span class="s1">scale = props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;scale&quot;</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">scale == </span><span class="s3">&quot;linear&quot;</span><span class="s1">:</span>
        <span class="s5"># get tick location information</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">tickvalues = props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;tickvalues&quot;</span><span class="s1">]</span>
            <span class="s1">tick0 = tickvalues[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">dticks = [</span>
                <span class="s1">round(tickvalues[i] - tickvalues[i - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(tickvalues) - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s2">if </span><span class="s1">all([dticks[i] == dticks[i - </span><span class="s4">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(dticks) - </span><span class="s4">1</span><span class="s1">)]):</span>
                <span class="s1">dtick = tickvalues[</span><span class="s4">1</span><span class="s1">] - tickvalues[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s3">&quot;'linear' {0}-axis tick spacing not even, &quot;</span>
                    <span class="s3">&quot;ignoring mpl tick formatting.&quot;</span><span class="s1">.format(ax_type)</span>
                <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">TypeError</span>
        <span class="s2">except </span><span class="s1">(IndexError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;nticks&quot;</span><span class="s1">] = props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;nticks&quot;</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;tick0&quot;</span><span class="s1">] = tick0</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;dtick&quot;</span><span class="s1">] = dtick</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;tickmode&quot;</span><span class="s1">] = </span><span class="s2">None</span>
    <span class="s2">elif </span><span class="s1">scale == </span><span class="s3">&quot;log&quot;</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;tick0&quot;</span><span class="s1">] = props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;tickvalues&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;dtick&quot;</span><span class="s1">] = (</span>
                <span class="s1">props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;tickvalues&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">- props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;tickvalues&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;tickmode&quot;</span><span class="s1">] = </span><span class="s2">None</span>
        <span class="s2">except </span><span class="s1">(IndexError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s1">axis_dict = dict(nticks=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][index][</span><span class="s3">&quot;nticks&quot;</span><span class="s1">])</span>
        <span class="s1">base = axis.get_transform().base</span>
        <span class="s2">if </span><span class="s1">base == </span><span class="s4">10</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ax_type == </span><span class="s3">&quot;x&quot;</span><span class="s1">:</span>
                <span class="s1">axis_dict[</span><span class="s3">&quot;range&quot;</span><span class="s1">] = [</span>
                    <span class="s1">math.log10(props[</span><span class="s3">&quot;xlim&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">math.log10(props[</span><span class="s3">&quot;xlim&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">ax_type == </span><span class="s3">&quot;y&quot;</span><span class="s1">:</span>
                <span class="s1">axis_dict[</span><span class="s3">&quot;range&quot;</span><span class="s1">] = [</span>
                    <span class="s1">math.log10(props[</span><span class="s3">&quot;ylim&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">math.log10(props[</span><span class="s3">&quot;ylim&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">axis_dict = dict(range=</span><span class="s2">None, </span><span class="s1">type=</span><span class="s3">&quot;linear&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Converted non-base10 {0}-axis log scale to 'linear'&quot; &quot;&quot;</span><span class="s1">.format(ax_type)</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">dict()</span>
    <span class="s5"># get tick label formatting information</span>
    <span class="s1">formatter = axis.get_major_formatter().__class__.__name__</span>
    <span class="s2">if </span><span class="s1">ax_type == </span><span class="s3">&quot;x&quot; </span><span class="s2">and </span><span class="s3">&quot;DateFormatter&quot; </span><span class="s2">in </span><span class="s1">formatter:</span>
        <span class="s1">axis_dict[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = </span><span class="s3">&quot;date&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;tick0&quot;</span><span class="s1">] = mpl_dates_to_datestrings(axis_dict[</span><span class="s3">&quot;tick0&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">formatter)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">pass</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">axis_dict.pop(</span><span class="s3">&quot;dtick&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">axis_dict.pop(</span><span class="s3">&quot;tickmode&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">axis_dict[</span><span class="s3">&quot;range&quot;</span><span class="s1">] = mpl_dates_to_datestrings(props[</span><span class="s3">&quot;xlim&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">formatter)</span>

    <span class="s2">if </span><span class="s1">formatter == </span><span class="s3">&quot;LogFormatterMathtext&quot;</span><span class="s1">:</span>
        <span class="s1">axis_dict[</span><span class="s3">&quot;exponentformat&quot;</span><span class="s1">] = </span><span class="s3">&quot;e&quot;</span>
    <span class="s2">return </span><span class="s1">axis_dict</span>


<span class="s2">def </span><span class="s1">prep_xy_axis(ax</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">x_bounds</span><span class="s2">, </span><span class="s1">y_bounds):</span>
    <span class="s1">xaxis = dict(</span>
        <span class="s1">type=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;scale&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">range=list(props[</span><span class="s3">&quot;xlim&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">showgrid=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;grid&quot;</span><span class="s1">][</span><span class="s3">&quot;gridOn&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">domain=convert_x_domain(props[</span><span class="s3">&quot;bounds&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x_bounds)</span><span class="s2">,</span>
        <span class="s1">side=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;position&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">tickfont=dict(size=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;fontsize&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">xaxis.update(prep_ticks(ax</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">props))</span>
    <span class="s1">yaxis = dict(</span>
        <span class="s1">type=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;scale&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">range=list(props[</span><span class="s3">&quot;ylim&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">showgrid=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;grid&quot;</span><span class="s1">][</span><span class="s3">&quot;gridOn&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">domain=convert_y_domain(props[</span><span class="s3">&quot;bounds&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y_bounds)</span><span class="s2">,</span>
        <span class="s1">side=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;position&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">tickfont=dict(size=props[</span><span class="s3">&quot;axes&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;fontsize&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">yaxis.update(prep_ticks(ax</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s1">props))</span>
    <span class="s2">return </span><span class="s1">xaxis</span><span class="s2">, </span><span class="s1">yaxis</span>


<span class="s2">def </span><span class="s1">mpl_dates_to_datestrings(dates</span><span class="s2">, </span><span class="s1">mpl_formatter):</span>
    <span class="s0">&quot;&quot;&quot;Convert matplotlib dates to iso-formatted-like time strings. 
 
    Plotly's accepted format: &quot;YYYY-MM-DD HH:MM:SS&quot; (e.g., 2001-01-01 00:00:00) 
 
    Info on mpl dates: http://matplotlib.org/api/dates_api.html 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_dates = dates</span>

    <span class="s5"># this is a pandas datetime formatter, times show up in floating point days</span>
    <span class="s5"># since the epoch (1970-01-01T00:00:00+00:00)</span>
    <span class="s2">if </span><span class="s1">mpl_formatter == </span><span class="s3">&quot;TimeSeries_DateFormatter&quot;</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dates = matplotlib.dates.epoch2num([date * </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">60 </span><span class="s1">* </span><span class="s4">60 </span><span class="s2">for </span><span class="s1">date </span><span class="s2">in </span><span class="s1">dates])</span>
            <span class="s1">dates = matplotlib.dates.num2date(dates)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_dates</span>

    <span class="s5"># the rest of mpl dates are in floating point days since</span>
    <span class="s5"># (0001-01-01T00:00:00+00:00) + 1. I.e., (0001-01-01T00:00:00+00:00) == 1.0</span>
    <span class="s5"># according to mpl --&gt; try num2date(1)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dates = matplotlib.dates.num2date(dates)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_dates</span>

    <span class="s1">time_stings = [</span>
        <span class="s3">&quot; &quot;</span><span class="s1">.join(date.isoformat().split(</span><span class="s3">&quot;+&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].split(</span><span class="s3">&quot;T&quot;</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">date </span><span class="s2">in </span><span class="s1">dates</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">time_stings</span>


<span class="s5"># dashed is dash in matplotlib</span>
<span class="s1">DASH_MAP = {</span>
    <span class="s3">&quot;10,0&quot;</span><span class="s1">: </span><span class="s3">&quot;solid&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;6,6&quot;</span><span class="s1">: </span><span class="s3">&quot;dash&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;2,2&quot;</span><span class="s1">: </span><span class="s3">&quot;circle&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;4,4,2,4&quot;</span><span class="s1">: </span><span class="s3">&quot;dashdot&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;none&quot;</span><span class="s1">: </span><span class="s3">&quot;solid&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;7.4,3.2&quot;</span><span class="s1">: </span><span class="s3">&quot;dash&quot;</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">PATH_MAP = {</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;o&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;*&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;8&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;h&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;p&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s1">): </span><span class="s3">&quot;1&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;s&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s1">): </span><span class="s3">&quot;+&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">): </span><span class="s3">&quot;^&quot;</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s1">): </span><span class="s3">&quot;|&quot;</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">SYMBOL_MAP = {</span>
    <span class="s3">&quot;o&quot;</span><span class="s1">: </span><span class="s3">&quot;circle&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;v&quot;</span><span class="s1">: </span><span class="s3">&quot;triangle-down&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;^&quot;</span><span class="s1">: </span><span class="s3">&quot;triangle-up&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;&lt;&quot;</span><span class="s1">: </span><span class="s3">&quot;triangle-left&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;&gt;&quot;</span><span class="s1">: </span><span class="s3">&quot;triangle-right&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;s&quot;</span><span class="s1">: </span><span class="s3">&quot;square&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: </span><span class="s3">&quot;cross&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;x&quot;</span><span class="s1">: </span><span class="s3">&quot;x&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;*&quot;</span><span class="s1">: </span><span class="s3">&quot;star&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;D&quot;</span><span class="s1">: </span><span class="s3">&quot;diamond&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;d&quot;</span><span class="s1">: </span><span class="s3">&quot;diamond&quot;</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">VA_MAP = {</span><span class="s3">&quot;center&quot;</span><span class="s1">: </span><span class="s3">&quot;middle&quot;</span><span class="s2">, </span><span class="s3">&quot;baseline&quot;</span><span class="s1">: </span><span class="s3">&quot;bottom&quot;</span><span class="s2">, </span><span class="s3">&quot;top&quot;</span><span class="s1">: </span><span class="s3">&quot;top&quot;</span><span class="s1">}</span>
</pre>
</body>
</html>