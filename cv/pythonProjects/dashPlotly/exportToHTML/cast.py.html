<html>
<head>
<title>cast.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cast.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Routines for casting. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s2">,</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Sized</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsDatetime</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsTimedelta</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">conversion</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.timedeltas </span><span class="s2">import </span><span class="s1">array_to_timedelta64</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">Dtype</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">Scalar</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">IntCastingNaNError</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>
<span class="s2">from </span><span class="s1">pandas.util._validators </span><span class="s2">import </span><span class="s1">validate_bool_kwarg</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DT64NS_DTYPE</span><span class="s2">,</span>
    <span class="s1">TD64NS_DTYPE</span><span class="s2">,</span>
    <span class="s1">ensure_int8</span><span class="s2">,</span>
    <span class="s1">ensure_int16</span><span class="s2">,</span>
    <span class="s1">ensure_int32</span><span class="s2">,</span>
    <span class="s1">ensure_int64</span><span class="s2">,</span>
    <span class="s1">ensure_object</span><span class="s2">,</span>
    <span class="s1">ensure_str</span><span class="s2">,</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_bool_dtype</span><span class="s2">,</span>
    <span class="s1">is_complex</span><span class="s2">,</span>
    <span class="s1">is_complex_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s2">,</span>
    <span class="s1">is_dtype_equal</span><span class="s2">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s2">,</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_float_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
    <span class="s1">is_timedelta64_dtype</span><span class="s2">,</span>
    <span class="s1">is_unsigned_integer_dtype</span><span class="s2">,</span>
    <span class="s1">pandas_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CategoricalDtype</span><span class="s2">,</span>
    <span class="s1">DatetimeTZDtype</span><span class="s2">,</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
    <span class="s1">IntervalDtype</span><span class="s2">,</span>
    <span class="s1">PandasDtype</span><span class="s2">,</span>
    <span class="s1">PeriodDtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCExtensionArray</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.inference </span><span class="s2">import </span><span class="s1">is_list_like</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_valid_na_for_dtype</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s2">,</span>
    <span class="s1">notna</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>

    <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">DatetimeArray</span><span class="s2">,</span>
        <span class="s1">ExtensionArray</span><span class="s2">,</span>
        <span class="s1">IntervalArray</span><span class="s2">,</span>
        <span class="s1">PeriodArray</span><span class="s2">,</span>
        <span class="s1">TimedeltaArray</span><span class="s2">,</span>
    <span class="s1">)</span>

<span class="s1">_int8_max = np.iinfo(np.int8).max</span>
<span class="s1">_int16_max = np.iinfo(np.int16).max</span>
<span class="s1">_int32_max = np.iinfo(np.int32).max</span>
<span class="s1">_int64_max = np.iinfo(np.int64).max</span>

<span class="s1">_dtype_obj = np.dtype(object)</span>

<span class="s1">NumpyArrayT = TypeVar(</span><span class="s3">&quot;NumpyArrayT&quot;</span><span class="s2">, </span><span class="s1">bound=np.ndarray)</span>


<span class="s2">def </span><span class="s1">maybe_convert_platform(</span>
    <span class="s1">values: list | tuple | range | np.ndarray | ExtensionArray</span><span class="s2">,</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot;try to do platform conversion, allow ndarray or list here&quot;&quot;&quot;</span>
    <span class="s1">arr: ArrayLike</span>

    <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">range)):</span>
        <span class="s1">arr = construct_1d_object_array_from_listlike(values)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># The caller is responsible for ensuring that we have np.ndarray</span>
        <span class="s4">#  or ExtensionArray here.</span>
        <span class="s1">arr = values</span>

    <span class="s2">if </span><span class="s1">arr.dtype == _dtype_obj:</span>
        <span class="s1">arr = cast(np.ndarray</span><span class="s2">, </span><span class="s1">arr)</span>
        <span class="s1">arr = lib.maybe_convert_objects(arr)</span>

    <span class="s2">return </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">is_nested_object(obj) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    return a boolean if we have a nested object, e.g. a Series with 1 or 
    more Series elements 
 
    This may not be necessarily be performant. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">bool(</span>
        <span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ABCSeries)</span>
        <span class="s2">and </span><span class="s1">is_object_dtype(obj.dtype)</span>
        <span class="s2">and </span><span class="s1">any(isinstance(v</span><span class="s2">, </span><span class="s1">ABCSeries) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">obj._values)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">maybe_box_datetimelike(value: Scalar</span><span class="s2">, </span><span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; Scalar:</span>
    <span class="s0">&quot;&quot;&quot; 
    Cast scalar to Timestamp or Timedelta if scalar is datetime-like 
    and dtype is not object. 
 
    Parameters 
    ---------- 
    value : scalar 
    dtype : Dtype, optional 
 
    Returns 
    ------- 
    scalar 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">pass</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">datetime)):</span>
        <span class="s1">value = Timestamp(value)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.timedelta64</span><span class="s2">, </span><span class="s1">timedelta)):</span>
        <span class="s1">value = Timedelta(value)</span>

    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">maybe_box_native(value: Scalar) -&gt; Scalar:</span>
    <span class="s0">&quot;&quot;&quot; 
    If passed a scalar cast the scalar to a python native type. 
 
    Parameters 
    ---------- 
    value : scalar or Series 
 
    Returns 
    ------- 
    scalar or Series 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_float(value):</span>
        <span class="s4"># error: Argument 1 to &quot;float&quot; has incompatible type</span>
        <span class="s4"># &quot;Union[Union[str, int, float, bool], Union[Any, Timestamp, Timedelta, Any]]&quot;;</span>
        <span class="s4"># expected &quot;Union[SupportsFloat, _SupportsIndex, str]&quot;</span>
        <span class="s1">value = float(value)  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s2">elif </span><span class="s1">is_integer(value):</span>
        <span class="s4"># error: Argument 1 to &quot;int&quot; has incompatible type</span>
        <span class="s4"># &quot;Union[Union[str, int, float, bool], Union[Any, Timestamp, Timedelta, Any]]&quot;;</span>
        <span class="s4"># expected &quot;Union[str, SupportsInt, _SupportsIndex, _SupportsTrunc]&quot;</span>
        <span class="s1">value = int(value)  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s2">elif </span><span class="s1">is_bool(value):</span>
        <span class="s1">value = bool(value)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">np.timedelta64)):</span>
        <span class="s1">value = maybe_box_datetimelike(value)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">maybe_unbox_datetimelike(value: Scalar</span><span class="s2">, </span><span class="s1">dtype: DtypeObj) -&gt; Scalar:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a Timedelta or Timestamp to timedelta64 or datetime64 for setting 
    into a numpy array.  Failing to unbox would risk dropping nanoseconds. 
 
    Notes 
    ----- 
    Caller is responsible for checking dtype.kind in [&quot;m&quot;, &quot;M&quot;] 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_valid_na_for_dtype(value</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH#36541: can't fill array directly with pd.NaT</span>
        <span class="s4"># &gt; np.empty(10, dtype=&quot;datetime64[64]&quot;).fill(pd.NaT)</span>
        <span class="s4"># ValueError: cannot convert float NaN to integer</span>
        <span class="s1">value = dtype.type(</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Timestamp):</span>
        <span class="s2">if </span><span class="s1">value.tz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = value.to_datetime64()</span>
        <span class="s2">elif not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot unbox tzaware Timestamp to tznaive dtype&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Timedelta):</span>
        <span class="s1">value = value.to_timedelta64()</span>

    <span class="s1">_disallow_mismatched_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_disallow_mismatched_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype: DtypeObj):</span>
    <span class="s0">&quot;&quot;&quot; 
    numpy allows np.array(dt64values, dtype=&quot;timedelta64[ns]&quot;) and 
    vice-versa, but we do not want to allow this, so we need to 
    check explicitly 
    &quot;&quot;&quot;</span>
    <span class="s1">vdtype = getattr(value</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">vdtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return</span>
    <span class="s2">elif </span><span class="s1">(vdtype.kind == </span><span class="s3">&quot;m&quot; </span><span class="s2">and </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
        <span class="s1">vdtype.kind == </span><span class="s3">&quot;M&quot; </span><span class="s2">and </span><span class="s1">dtype.kind == </span><span class="s3">&quot;m&quot;</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot cast </span><span class="s2">{</span><span class="s1">repr(value)</span><span class="s2">} </span><span class="s3">to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">maybe_downcast_to_dtype(result: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: str | np.dtype) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    try to cast to the specified dtype (e.g. convert back to bool/int 
    or could be an astype of float64-&gt;float32 
    &quot;&quot;&quot;</span>
    <span class="s1">do_round = </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">dtype == </span><span class="s3">&quot;infer&quot;</span><span class="s1">:</span>
            <span class="s1">inferred_type = lib.infer_dtype(result</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">inferred_type == </span><span class="s3">&quot;boolean&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;bool&quot;</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;integer&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;int64&quot;</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;datetime64&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;datetime64[ns]&quot;</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;timedelta64&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;timedelta64[ns]&quot;</span>

            <span class="s4"># try to upcast here</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;floating&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;int64&quot;</span>
                <span class="s2">if </span><span class="s1">issubclass(result.dtype.type</span><span class="s2">, </span><span class="s1">np.number):</span>
                    <span class="s1">do_round = </span><span class="s2">True</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># TODO: complex?  what if result is already non-object?</span>
                <span class="s1">dtype = </span><span class="s3">&quot;object&quot;</span>

        <span class="s1">dtype = np.dtype(dtype)</span>

    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s4"># enforce our signature annotation</span>
        <span class="s2">raise </span><span class="s1">TypeError(dtype)  </span><span class="s4"># pragma: no cover</span>

    <span class="s1">converted = maybe_downcast_numeric(result</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">do_round)</span>
    <span class="s2">if </span><span class="s1">converted </span><span class="s2">is not </span><span class="s1">result:</span>
        <span class="s2">return </span><span class="s1">converted</span>

    <span class="s4"># a datetimelike</span>
    <span class="s4"># GH12821, iNaT is cast to float</span>
    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">result.dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;f&quot;</span><span class="s1">]:</span>
        <span class="s1">result = result.astype(dtype)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">maybe_downcast_numeric(</span>
    <span class="s1">result: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span><span class="s2">, </span><span class="s1">do_round: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Subset of maybe_downcast_to_dtype restricted to numeric dtypes. 
 
    Parameters 
    ---------- 
    result : ndarray or ExtensionArray 
    dtype : np.dtype or ExtensionDtype 
    do_round : bool 
 
    Returns 
    ------- 
    ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">or not </span><span class="s1">isinstance(result.dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s4"># e.g. SparseDtype has no itemsize attr</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">trans(x):</span>
        <span class="s2">if </span><span class="s1">do_round:</span>
            <span class="s2">return </span><span class="s1">x.round()</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">if </span><span class="s1">dtype.kind == result.dtype.kind:</span>
        <span class="s4"># don't allow upcasts here (except if empty)</span>
        <span class="s2">if </span><span class="s1">result.dtype.itemsize &lt;= dtype.itemsize </span><span class="s2">and </span><span class="s1">result.size:</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">if </span><span class="s1">is_bool_dtype(dtype) </span><span class="s2">or </span><span class="s1">is_integer_dtype(dtype):</span>

        <span class="s2">if not </span><span class="s1">result.size:</span>
            <span class="s4"># if we don't have any elements, just astype it</span>
            <span class="s2">return </span><span class="s1">trans(result).astype(dtype)</span>

        <span class="s4"># do a test on the first element, if it fails then we are done</span>
        <span class="s1">r = result.ravel()</span>
        <span class="s1">arr = np.array([r[</span><span class="s5">0</span><span class="s1">]])</span>

        <span class="s2">if </span><span class="s1">isna(arr).any():</span>
            <span class="s4"># if we have any nulls, then we are done</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">elif not </span><span class="s1">isinstance(r[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(np.integer</span><span class="s2">, </span><span class="s1">np.floating</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool)):</span>
            <span class="s4"># a comparable, e.g. a Decimal may slip in here</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">issubclass(result.dtype.type</span><span class="s2">, </span><span class="s1">(np.object_</span><span class="s2">, </span><span class="s1">np.number))</span>
            <span class="s2">and </span><span class="s1">notna(result).all()</span>
        <span class="s1">):</span>
            <span class="s1">new_result = trans(result).astype(dtype)</span>
            <span class="s2">if </span><span class="s1">new_result.dtype.kind == </span><span class="s3">&quot;O&quot; </span><span class="s2">or </span><span class="s1">result.dtype.kind == </span><span class="s3">&quot;O&quot;</span><span class="s1">:</span>
                <span class="s4"># np.allclose may raise TypeError on object-dtype</span>
                <span class="s2">if </span><span class="s1">(new_result == result).all():</span>
                    <span class="s2">return </span><span class="s1">new_result</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">np.allclose(new_result</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s1">):</span>
                    <span class="s2">return </span><span class="s1">new_result</span>

    <span class="s2">elif </span><span class="s1">(</span>
        <span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>
        <span class="s2">and not </span><span class="s1">is_bool_dtype(result.dtype)</span>
        <span class="s2">and not </span><span class="s1">is_string_dtype(result.dtype)</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">result.astype(dtype)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">maybe_cast_pointwise_result(</span>
    <span class="s1">result: ArrayLike</span><span class="s2">,</span>
    <span class="s1">dtype: DtypeObj</span><span class="s2">,</span>
    <span class="s1">numeric_only: bool = </span><span class="s2">False,</span>
    <span class="s1">same_dtype: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Try casting result of a pointwise operation back to the original dtype if 
    appropriate. 
 
    Parameters 
    ---------- 
    result : array-like 
        Result to cast. 
    dtype : np.dtype or ExtensionDtype 
        Input Series from which result was calculated. 
    numeric_only : bool, default False 
        Whether to cast only numerics or datetimes as well. 
    same_dtype : bool, default True 
        Specify dtype when calling _from_sequence 
 
    Returns 
    ------- 
    result : array-like 
        result maybe casted to the dtype. 
    &quot;&quot;&quot;</span>

    <span class="s2">assert not </span><span class="s1">is_scalar(result)</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">(CategoricalDtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)):</span>
            <span class="s4"># TODO: avoid this special-casing</span>
            <span class="s4"># We have to special case categorical so as not to upcast</span>
            <span class="s4"># things like counts back to categorical</span>

            <span class="s1">cls = dtype.construct_array_type()</span>
            <span class="s2">if </span><span class="s1">same_dtype:</span>
                <span class="s1">result = maybe_cast_to_extension_array(cls</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result = maybe_cast_to_extension_array(cls</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">elif </span><span class="s1">(numeric_only </span><span class="s2">and </span><span class="s1">is_numeric_dtype(dtype)) </span><span class="s2">or not </span><span class="s1">numeric_only:</span>
        <span class="s1">result = maybe_downcast_to_dtype(result</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">maybe_cast_to_extension_array(</span>
    <span class="s1">cls: type[ExtensionArray]</span><span class="s2">, </span><span class="s1">obj: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: ExtensionDtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Call to `_from_sequence` that returns the object unchanged on Exception. 
 
    Parameters 
    ---------- 
    cls : class, subclass of ExtensionArray 
    obj : arraylike 
        Values to pass to cls._from_sequence 
    dtype : ExtensionDtype, optional 
 
    Returns 
    ------- 
    ExtensionArray or obj 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s2">import </span><span class="s1">BaseStringArray</span>

    <span class="s2">assert </span><span class="s1">isinstance(cls</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">, </span><span class="s3">f&quot;must pass a type: </span><span class="s2">{</span><span class="s1">cls</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s1">assertion_msg = </span><span class="s3">f&quot;must pass a subclass of ExtensionArray: </span><span class="s2">{</span><span class="s1">cls</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s2">assert </span><span class="s1">issubclass(cls</span><span class="s2">, </span><span class="s1">ABCExtensionArray)</span><span class="s2">, </span><span class="s1">assertion_msg</span>

    <span class="s4"># Everything can be converted to StringArrays, but we may not want to convert</span>
    <span class="s2">if </span><span class="s1">issubclass(cls</span><span class="s2">, </span><span class="s1">BaseStringArray) </span><span class="s2">and </span><span class="s1">lib.infer_dtype(obj) != </span><span class="s3">&quot;string&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">result = cls._from_sequence(obj</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s4"># We can't predict what downstream EA constructors may raise</span>
        <span class="s1">result = obj</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">ensure_dtype_can_hold_na(dtype: np.dtype) -&gt; np.dtype:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">ensure_dtype_can_hold_na(dtype: ExtensionDtype) -&gt; ExtensionDtype:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">ensure_dtype_can_hold_na(dtype: DtypeObj) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    If we have a dtype that cannot hold NA values, find the best match that can. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s4"># TODO: ExtensionDtype.can_hold_na?</span>
        <span class="s2">return </span><span class="s1">dtype</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_dtype_obj</span>
    <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">np.dtype(np.float64)</span>
    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">maybe_promote(dtype: np.dtype</span><span class="s2">, </span><span class="s1">fill_value=np.nan):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the minimal dtype that can hold both the given dtype and fill_value. 
 
    Parameters 
    ---------- 
    dtype : np.dtype 
    fill_value : scalar, default np.nan 
 
    Returns 
    ------- 
    dtype 
        Upcasted from dtype argument if necessary. 
    fill_value 
        Upcasted from fill_value argument if necessary. 
 
    Raises 
    ------ 
    ValueError 
        If fill_value is a non-scalar and dtype is not object. 
    &quot;&quot;&quot;</span>
    <span class="s4"># TODO(2.0): need to directly use the non-cached version as long as we</span>
    <span class="s4"># possibly raise a deprecation warning for datetime dtype</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_maybe_promote(dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>
    <span class="s4"># for performance, we are using a cached version of the actual implementation</span>
    <span class="s4"># of the function in _maybe_promote. However, this doesn't always work (in case</span>
    <span class="s4"># of non-hashable arguments), so we fallback to the actual implementation if needed</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s4"># error: Argument 3 to &quot;__call__&quot; of &quot;_lru_cache_wrapper&quot; has incompatible type</span>
        <span class="s4"># &quot;Type[Any]&quot;; expected &quot;Hashable&quot;  [arg-type]</span>
        <span class="s2">return </span><span class="s1">_maybe_promote_cached(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">type(fill_value)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s4"># if fill_value is not hashable (required for caching)</span>
        <span class="s2">return </span><span class="s1">_maybe_promote(dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s5">128</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_maybe_promote_cached(dtype</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">fill_value_type):</span>
    <span class="s4"># The cached version of _maybe_promote below</span>
    <span class="s4"># This also use fill_value_type as (unused) argument to use this in the</span>
    <span class="s4"># cache lookup -&gt; to differentiate 1 and True</span>
    <span class="s2">return </span><span class="s1">_maybe_promote(dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>


<span class="s2">def </span><span class="s1">_maybe_promote(dtype: np.dtype</span><span class="s2">, </span><span class="s1">fill_value=np.nan):</span>
    <span class="s4"># The actual implementation of the function, use `maybe_promote` above for</span>
    <span class="s4"># a cached version.</span>
    <span class="s2">if not </span><span class="s1">is_scalar(fill_value):</span>
        <span class="s4"># with object dtype there is nothing to promote, and the user can</span>
        <span class="s4">#  pass pretty much any weird fill_value they like</span>
        <span class="s2">if not </span><span class="s1">is_object_dtype(dtype):</span>
            <span class="s4"># with object dtype there is nothing to promote, and the user can</span>
            <span class="s4">#  pass pretty much any weird fill_value they like</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;fill_value must be a scalar&quot;</span><span class="s1">)</span>
        <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s1">kinds = [</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s2">, </span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">is_valid_na_for_dtype(fill_value</span><span class="s2">, </span><span class="s1">dtype) </span><span class="s2">and </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">kinds:</span>
        <span class="s1">dtype = ensure_dtype_can_hold_na(dtype)</span>
        <span class="s1">fv = na_value_for_dtype(dtype)</span>
        <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>

    <span class="s2">elif </span><span class="s1">isna(fill_value):</span>
        <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># but we retain e.g. pd.NA</span>
            <span class="s1">fill_value = np.nan</span>
        <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s4"># returns tuple of (dtype, fill_value)</span>
    <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64):</span>
        <span class="s1">inferred</span><span class="s2">, </span><span class="s1">fv = infer_dtype_from_scalar(fill_value</span><span class="s2">, </span><span class="s1">pandas_dtype=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">inferred == dtype:</span>
            <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>

        <span class="s4"># TODO(2.0): once this deprecation is enforced, this whole case</span>
        <span class="s4"># becomes equivalent to:</span>
        <span class="s4">#  dta = DatetimeArray._from_sequence([], dtype=&quot;M8[ns]&quot;)</span>
        <span class="s4">#  try:</span>
        <span class="s4">#      fv = dta._validate_setitem_value(fill_value)</span>
        <span class="s4">#      return dta.dtype, fv</span>
        <span class="s4">#  except (ValueError, TypeError):</span>
        <span class="s4">#      return _dtype_obj, fill_value</span>
        <span class="s2">if </span><span class="s1">isinstance(fill_value</span><span class="s2">, </span><span class="s1">date) </span><span class="s2">and not </span><span class="s1">isinstance(fill_value</span><span class="s2">, </span><span class="s1">datetime):</span>
            <span class="s4"># deprecate casting of date object to match infer_dtype_from_scalar</span>
            <span class="s4">#  and DatetimeArray._validate_setitem_value</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">fv = Timestamp(fill_value).to_datetime64()</span>
            <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s3">&quot;Using a `date` object for fill_value with `datetime64[ns]` &quot;</span>
                    <span class="s3">&quot;dtype is deprecated. In a future version, this will be cast &quot;</span>
                    <span class="s3">&quot;to object dtype. Pass `fill_value=Timestamp(date_obj)` instead.&quot;</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>
        <span class="s2">elif </span><span class="s1">isinstance(fill_value</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># explicitly wrap in str to convert np.str_</span>
                <span class="s1">fv = Timestamp(str(fill_value))</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isna(fv) </span><span class="s2">or </span><span class="s1">fv.tz </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv.asm8</span>

        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.timedelta64):</span>
        <span class="s1">inferred</span><span class="s2">, </span><span class="s1">fv = infer_dtype_from_scalar(fill_value</span><span class="s2">, </span><span class="s1">pandas_dtype=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">inferred == dtype:</span>
            <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>

        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s2">elif </span><span class="s1">is_float(fill_value):</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

        <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s1">dtype = np.dtype(np.float64)</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s2">if </span><span class="s1">mst &gt; dtype:</span>
                <span class="s4"># e.g. mst is np.float64 and dtype is np.float32</span>
                <span class="s1">dtype = mst</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">mst)</span>

    <span class="s2">elif </span><span class="s1">is_bool(fill_value):</span>
        <span class="s2">if not </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s2">elif </span><span class="s1">is_integer(fill_value):</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

        <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s2">if not </span><span class="s1">np.can_cast(fill_value</span><span class="s2">, </span><span class="s1">dtype):</span>
                <span class="s4"># upcast to prevent overflow</span>
                <span class="s1">mst = np.min_scalar_type(fill_value)</span>
                <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">mst)</span>
                <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
                    <span class="s4"># Case where we disagree with numpy</span>
                    <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s2">elif </span><span class="s1">is_complex(fill_value):</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

        <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">(np.integer</span><span class="s2">, </span><span class="s1">np.floating)):</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">mst)</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s2">if </span><span class="s1">mst &gt; dtype:</span>
                <span class="s4"># e.g. mst is np.complex128 and dtype is np.complex64</span>
                <span class="s1">dtype = mst</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s4"># in case we have a string that looked like a number</span>
    <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">(bytes</span><span class="s2">, </span><span class="s1">str)):</span>
        <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s1">fill_value = _ensure_dtype_type(fill_value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>


<span class="s2">def </span><span class="s1">_ensure_dtype_type(value</span><span class="s2">, </span><span class="s1">dtype: np.dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Ensure that the given value is an instance of the given dtype. 
 
    e.g. if out dtype is np.complex64_, we should have an instance of that 
    as opposed to a python complex object. 
 
    Parameters 
    ---------- 
    value : object 
    dtype : np.dtype 
 
    Returns 
    ------- 
    object 
    &quot;&quot;&quot;</span>
    <span class="s4"># Start with exceptions in which we do _not_ cast to numpy types</span>

    <span class="s2">if </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s4"># Note: before we get here we have already excluded isna(value)</span>
    <span class="s2">return </span><span class="s1">dtype.type(value)</span>


<span class="s2">def </span><span class="s1">infer_dtype_from(val</span><span class="s2">, </span><span class="s1">pandas_dtype: bool = </span><span class="s2">False</span><span class="s1">) -&gt; tuple[DtypeObj</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Interpret the dtype from a scalar or array. 
 
    Parameters 
    ---------- 
    val : object 
    pandas_dtype : bool, default False 
        whether to infer dtype including pandas extension types. 
        If False, scalar/array belongs to pandas extension types is inferred as 
        object 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">is_list_like(val):</span>
        <span class="s2">return </span><span class="s1">infer_dtype_from_scalar(val</span><span class="s2">, </span><span class="s1">pandas_dtype=pandas_dtype)</span>
    <span class="s2">return </span><span class="s1">infer_dtype_from_array(val</span><span class="s2">, </span><span class="s1">pandas_dtype=pandas_dtype)</span>


<span class="s2">def </span><span class="s1">infer_dtype_from_scalar(val</span><span class="s2">, </span><span class="s1">pandas_dtype: bool = </span><span class="s2">False</span><span class="s1">) -&gt; tuple[DtypeObj</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Interpret the dtype from a scalar. 
 
    Parameters 
    ---------- 
    pandas_dtype : bool, default False 
        whether to infer dtype including pandas extension types. 
        If False, scalar belongs to pandas extension types is inferred as 
        object 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype: DtypeObj = _dtype_obj</span>

    <span class="s4"># a 1-element ndarray</span>
    <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">val.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;invalid ndarray passed to infer_dtype_from_scalar&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">dtype = val.dtype</span>
        <span class="s1">val = lib.item_from_zerodim(val)</span>

    <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">str):</span>

        <span class="s4"># If we create an empty array using a string to infer</span>
        <span class="s4"># the dtype, NumPy will only allocate one character per entry</span>
        <span class="s4"># so this is kind of bad. Alternately we could use np.repeat</span>
        <span class="s4"># instead of np.empty (but then you still don't want things</span>
        <span class="s4"># coming out as np.str_!</span>

        <span class="s1">dtype = _dtype_obj</span>

    <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">datetime)):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">val = Timestamp(val)</span>
        <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
            <span class="s2">return </span><span class="s1">_dtype_obj</span><span class="s2">, </span><span class="s1">val</span>

        <span class="s4"># error: Non-overlapping identity check (left operand type: &quot;Timestamp&quot;,</span>
        <span class="s4"># right operand type: &quot;NaTType&quot;)</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is </span><span class="s1">NaT </span><span class="s2">or </span><span class="s1">val.tz </span><span class="s2">is None</span><span class="s1">:  </span><span class="s4"># type: ignore[comparison-overlap]</span>
            <span class="s1">dtype = np.dtype(</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
            <span class="s1">val = val.to_datetime64()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pandas_dtype:</span>
                <span class="s1">dtype = DatetimeTZDtype(unit=</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=val.tz)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># return datetimetz as object</span>
                <span class="s2">return </span><span class="s1">_dtype_obj</span><span class="s2">, </span><span class="s1">val</span>

    <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">(np.timedelta64</span><span class="s2">, </span><span class="s1">timedelta)):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">val = Timedelta(val)</span>
        <span class="s2">except </span><span class="s1">(OutOfBoundsTimedelta</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(</span><span class="s3">&quot;m8[ns]&quot;</span><span class="s1">)</span>
            <span class="s1">val = np.timedelta64(val.value</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">is_bool(val):</span>
        <span class="s1">dtype = np.dtype(np.bool_)</span>

    <span class="s2">elif </span><span class="s1">is_integer(val):</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s1">dtype = np.dtype(type(val))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(np.int64)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">np.array(val</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">except </span><span class="s1">OverflowError:</span>
            <span class="s1">dtype = np.array(val).dtype</span>

    <span class="s2">elif </span><span class="s1">is_float(val):</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.floating):</span>
            <span class="s1">dtype = np.dtype(type(val))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(np.float64)</span>

    <span class="s2">elif </span><span class="s1">is_complex(val):</span>
        <span class="s1">dtype = np.dtype(np.complex_)</span>

    <span class="s2">elif </span><span class="s1">pandas_dtype:</span>
        <span class="s2">if </span><span class="s1">lib.is_period(val):</span>
            <span class="s1">dtype = PeriodDtype(freq=val.freq)</span>
        <span class="s2">elif </span><span class="s1">lib.is_interval(val):</span>
            <span class="s1">subtype = infer_dtype_from_scalar(val.left</span><span class="s2">, </span><span class="s1">pandas_dtype=</span><span class="s2">True</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">dtype = IntervalDtype(subtype=subtype</span><span class="s2">, </span><span class="s1">closed=val.closed)</span>

    <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">dict_compat(d: dict[Scalar</span><span class="s2">, </span><span class="s1">Scalar]) -&gt; dict[Scalar</span><span class="s2">, </span><span class="s1">Scalar]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert datetimelike-keyed dicts to a Timestamp-keyed dict. 
 
    Parameters 
    ---------- 
    d: dict-like object 
 
    Returns 
    ------- 
    dict 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">{maybe_box_datetimelike(key): value </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">d.items()}</span>


<span class="s2">def </span><span class="s1">infer_dtype_from_array(</span>
    <span class="s1">arr</span><span class="s2">, </span><span class="s1">pandas_dtype: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; tuple[DtypeObj</span><span class="s2">, </span><span class="s1">ArrayLike]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Infer the dtype from an array. 
 
    Parameters 
    ---------- 
    arr : array 
    pandas_dtype : bool, default False 
        whether to infer dtype including pandas extension types. 
        If False, array belongs to pandas extension types 
        is inferred as object 
 
    Returns 
    ------- 
    tuple (numpy-compat/pandas-compat dtype, array) 
 
    Notes 
    ----- 
    if pandas_dtype=False. these infer to numpy dtypes 
    exactly with the exception that mixed / object dtypes 
    are not coerced by stringifying or conversion 
 
    if pandas_dtype=True. datetime64tz-aware/categorical 
    types will retain there character. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.asarray([1, '1']) 
    array(['1', '1'], dtype='&lt;U21') 
 
    &gt;&gt;&gt; infer_dtype_from_array([1, '1']) 
    (dtype('O'), [1, '1']) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">arr</span>

    <span class="s2">if not </span><span class="s1">is_list_like(arr):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;'arr' must be list-like&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">pandas_dtype </span><span class="s2">and </span><span class="s1">is_extension_array_dtype(arr):</span>
        <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">arr</span>

    <span class="s2">elif </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
        <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">np.asarray(arr)</span>

    <span class="s4"># don't force numpy coerce with nan's</span>
    <span class="s1">inferred = lib.infer_dtype(arr</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;string&quot;</span><span class="s2">, </span><span class="s3">&quot;bytes&quot;</span><span class="s2">, </span><span class="s3">&quot;mixed&quot;</span><span class="s2">, </span><span class="s3">&quot;mixed-integer&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">(np.dtype(np.object_)</span><span class="s2">, </span><span class="s1">arr)</span>

    <span class="s1">arr = np.asarray(arr)</span>
    <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">maybe_infer_dtype_type(element):</span>
    <span class="s0">&quot;&quot;&quot; 
    Try to infer an object's dtype, for use in arithmetic ops. 
 
    Uses `element.dtype` if that's available. 
    Objects implementing the iterator protocol are cast to a NumPy array, 
    and from there the array's type is used. 
 
    Parameters 
    ---------- 
    element : object 
        Possibly has a `.dtype` attribute, and possibly the iterator 
        protocol. 
 
    Returns 
    ------- 
    tipo : type 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from collections import namedtuple 
    &gt;&gt;&gt; Foo = namedtuple(&quot;Foo&quot;, &quot;dtype&quot;) 
    &gt;&gt;&gt; maybe_infer_dtype_type(Foo(np.dtype(&quot;i8&quot;))) 
    dtype('int64') 
    &quot;&quot;&quot;</span>
    <span class="s1">tipo = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s1">):</span>
        <span class="s1">tipo = element.dtype</span>
    <span class="s2">elif </span><span class="s1">is_list_like(element):</span>
        <span class="s1">element = np.asarray(element)</span>
        <span class="s1">tipo = element.dtype</span>
    <span class="s2">return </span><span class="s1">tipo</span>


<span class="s2">def </span><span class="s1">maybe_upcast(</span>
    <span class="s1">values: NumpyArrayT</span><span class="s2">,</span>
    <span class="s1">fill_value: Scalar = np.nan</span><span class="s2">,</span>
    <span class="s1">copy: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; tuple[NumpyArrayT</span><span class="s2">, </span><span class="s1">Scalar]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Provide explicit type promotion and coercion. 
 
    Parameters 
    ---------- 
    values : np.ndarray 
        The array that we may want to upcast. 
    fill_value : what we want to fill with 
    copy : bool, default True 
        If True always make a copy even if no upcast is required. 
 
    Returns 
    ------- 
    values: np.ndarray 
        the original array, possibly upcast 
    fill_value: 
        the fill value, possibly upcast 
    &quot;&quot;&quot;</span>
    <span class="s1">new_dtype</span><span class="s2">, </span><span class="s1">fill_value = maybe_promote(values.dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>
    <span class="s4"># We get a copy in all cases _except_ (values.dtype == new_dtype and not copy)</span>
    <span class="s1">upcast_values = values.astype(new_dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s4"># error: Incompatible return value type (got &quot;Tuple[ndarray[Any, dtype[Any]],</span>
    <span class="s4"># Union[Union[str, int, float, bool] Union[Period, Timestamp, Timedelta, Any]]]&quot;,</span>
    <span class="s4"># expected &quot;Tuple[NumpyArrayT, Union[Union[str, int, float, bool], Union[Period,</span>
    <span class="s4"># Timestamp, Timedelta, Any]]]&quot;)</span>
    <span class="s2">return </span><span class="s1">upcast_values</span><span class="s2">, </span><span class="s1">fill_value  </span><span class="s4"># type: ignore[return-value]</span>


<span class="s2">def </span><span class="s1">invalidate_string_dtypes(dtype_set: set[DtypeObj]):</span>
    <span class="s0">&quot;&quot;&quot; 
    Change string like dtypes to object for 
    ``DataFrame.select_dtypes()``. 
    &quot;&quot;&quot;</span>
    <span class="s4"># error: Argument 1 to &lt;set&gt; has incompatible type &quot;Type[generic]&quot;; expected</span>
    <span class="s4"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;</span>
    <span class="s4"># error: Argument 2 to &lt;set&gt; has incompatible type &quot;Type[generic]&quot;; expected</span>
    <span class="s4"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;</span>
    <span class="s1">non_string_dtypes = dtype_set - {</span>
        <span class="s1">np.dtype(</span><span class="s3">&quot;S&quot;</span><span class="s1">).type</span><span class="s2">,  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">np.dtype(</span><span class="s3">&quot;&lt;U&quot;</span><span class="s1">).type</span><span class="s2">,  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">non_string_dtypes != dtype_set:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;string dtypes are not allowed, use 'object' instead&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">coerce_indexer_dtype(indexer</span><span class="s2">, </span><span class="s1">categories):</span>
    <span class="s0">&quot;&quot;&quot;coerce the indexer input array to the smallest dtype possible&quot;&quot;&quot;</span>
    <span class="s1">length = len(categories)</span>
    <span class="s2">if </span><span class="s1">length &lt; _int8_max:</span>
        <span class="s2">return </span><span class="s1">ensure_int8(indexer)</span>
    <span class="s2">elif </span><span class="s1">length &lt; _int16_max:</span>
        <span class="s2">return </span><span class="s1">ensure_int16(indexer)</span>
    <span class="s2">elif </span><span class="s1">length &lt; _int32_max:</span>
        <span class="s2">return </span><span class="s1">ensure_int32(indexer)</span>
    <span class="s2">return </span><span class="s1">ensure_int64(indexer)</span>


<span class="s2">def </span><span class="s1">astype_dt64_to_dt64tz(</span>
    <span class="s1">values: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span><span class="s2">, </span><span class="s1">copy: bool</span><span class="s2">, </span><span class="s1">via_utc: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; DatetimeArray:</span>
    <span class="s4"># GH#33401 we have inconsistent behaviors between</span>
    <span class="s4">#  Datetimeindex[naive].astype(tzaware)</span>
    <span class="s4">#  Series[dt64].astype(tzaware)</span>
    <span class="s4"># This collects them in one place to prevent further fragmentation.</span>

    <span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">ensure_wrapped_if_datetimelike</span>

    <span class="s1">values = ensure_wrapped_if_datetimelike(values)</span>
    <span class="s1">values = cast(</span><span class="s3">&quot;DatetimeArray&quot;</span><span class="s2">, </span><span class="s1">values)</span>
    <span class="s1">aware = isinstance(dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)</span>

    <span class="s2">if </span><span class="s1">via_utc:</span>
        <span class="s4"># Series.astype behavior</span>

        <span class="s4"># caller is responsible for checking this</span>
        <span class="s2">assert </span><span class="s1">values.tz </span><span class="s2">is None and </span><span class="s1">aware</span>
        <span class="s1">dtype = cast(DatetimeTZDtype</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s4"># this should be the only copy</span>
            <span class="s1">values = values.copy()</span>

        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Using .astype to convert from timezone-naive dtype to &quot;</span>
            <span class="s3">&quot;timezone-aware dtype is deprecated and will raise in a &quot;</span>
            <span class="s3">&quot;future version.  Use ser.dt.tz_localize instead.&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s4"># GH#33401 this doesn't match DatetimeArray.astype, which</span>
        <span class="s4">#  goes through the `not via_utc` path</span>
        <span class="s2">return </span><span class="s1">values.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz_convert(dtype.tz)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># DatetimeArray/DatetimeIndex.astype behavior</span>
        <span class="s2">if </span><span class="s1">values.tz </span><span class="s2">is None and </span><span class="s1">aware:</span>
            <span class="s1">dtype = cast(DatetimeTZDtype</span><span class="s2">, </span><span class="s1">dtype)</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Using .astype to convert from timezone-naive dtype to &quot;</span>
                <span class="s3">&quot;timezone-aware dtype is deprecated and will raise in a &quot;</span>
                <span class="s3">&quot;future version.  Use obj.tz_localize instead.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s2">return </span><span class="s1">values.tz_localize(dtype.tz)</span>

        <span class="s2">elif </span><span class="s1">aware:</span>
            <span class="s4"># GH#18951: datetime64_tz dtype but not equal means different tz</span>
            <span class="s1">dtype = cast(DatetimeTZDtype</span><span class="s2">, </span><span class="s1">dtype)</span>
            <span class="s1">result = values.tz_convert(dtype.tz)</span>
            <span class="s2">if </span><span class="s1">copy:</span>
                <span class="s1">result = result.copy()</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">elif </span><span class="s1">values.tz </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Using .astype to convert from timezone-aware dtype to &quot;</span>
                <span class="s3">&quot;timezone-naive dtype is deprecated and will raise in a &quot;</span>
                <span class="s3">&quot;future version.  Use obj.tz_localize(None) or &quot;</span>
                <span class="s3">&quot;obj.tz_convert('UTC').tz_localize(None) instead&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s1">result = values.tz_convert(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz_localize(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">copy:</span>
                <span class="s1">result = result.copy()</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;dtype_equal case should be handled elsewhere&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">astype_td64_unit_conversion(</span>
    <span class="s1">values: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">copy: bool</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    By pandas convention, converting to non-nano timedelta64 
    returns an int64-dtyped array with ints representing multiples 
    of the desired timedelta unit.  This is essentially division. 
 
    Parameters 
    ---------- 
    values : np.ndarray[timedelta64[ns]] 
    dtype : np.dtype 
        timedelta64 with unit not-necessarily nano 
    copy : bool 
 
    Returns 
    ------- 
    np.ndarray 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_dtype_equal(values.dtype</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s2">return </span><span class="s1">values.copy()</span>
        <span class="s2">return </span><span class="s1">values</span>

    <span class="s4"># otherwise we are converting to non-nano</span>
    <span class="s1">result = values.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)  </span><span class="s4"># avoid double-copying</span>
    <span class="s1">result = result.astype(np.float64)</span>

    <span class="s1">mask = isna(values)</span>
    <span class="s1">np.putmask(result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">np.nan)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">astype_nansafe(</span>
    <span class="s1">arr: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">copy: bool = ...</span><span class="s2">, </span><span class="s1">skipna: bool = ...</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">astype_nansafe(</span>
    <span class="s1">arr: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: ExtensionDtype</span><span class="s2">, </span><span class="s1">copy: bool = ...</span><span class="s2">, </span><span class="s1">skipna: bool = ...</span>
<span class="s1">) -&gt; ExtensionArray:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">astype_nansafe(</span>
    <span class="s1">arr: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">True, </span><span class="s1">skipna: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Cast the elements of an array to a given dtype a nan-safe manner. 
 
    Parameters 
    ---------- 
    arr : ndarray 
    dtype : np.dtype or ExtensionDtype 
    copy : bool, default True 
        If False, a view will be attempted but may fail, if 
        e.g. the item sizes don't align. 
    skipna: bool, default False 
        Whether or not we should skip NaN when casting as a string-type. 
 
    Raises 
    ------ 
    ValueError 
        The dtype was a datetime64/timedelta64 dtype, but it had no unit. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">flat = arr.ravel()</span>
        <span class="s1">result = astype_nansafe(flat</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">skipna=skipna)</span>
        <span class="s4"># error: Item &quot;ExtensionArray&quot; of &quot;Union[ExtensionArray, ndarray]&quot; has no</span>
        <span class="s4"># attribute &quot;reshape&quot;</span>
        <span class="s2">return </span><span class="s1">result.reshape(arr.shape)  </span><span class="s4"># type: ignore[union-attr]</span>

    <span class="s4"># We get here with 0-dim from sparse</span>
    <span class="s1">arr = np.atleast_1d(arr)</span>

    <span class="s4"># dispatch on extension dtype if needed</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s2">return </span><span class="s1">dtype.construct_array_type()._from_sequence(arr</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s2">elif not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):  </span><span class="s4"># pragma: no cover</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;dtype must be np.dtype or ExtensionDtype&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">arr.dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">(</span>
        <span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">dtype == _dtype_obj</span>
    <span class="s1">):</span>
        <span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">ensure_wrapped_if_datetimelike</span>

        <span class="s1">arr = ensure_wrapped_if_datetimelike(arr)</span>
        <span class="s2">return </span><span class="s1">arr.astype(dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">lib.ensure_string_array(arr</span><span class="s2">, </span><span class="s1">skipna=skipna</span><span class="s2">, </span><span class="s1">convert_na_value=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">is_datetime64_dtype(arr.dtype):</span>
        <span class="s2">if </span><span class="s1">dtype == np.int64:</span>
            <span class="s2">if </span><span class="s1">isna(arr).any():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot convert NaT values to integer&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">arr.view(dtype)</span>

        <span class="s4"># allow frequency conversions</span>
        <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">arr.astype(dtype)</span>

        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;cannot astype a datetimelike from [</span><span class="s2">{</span><span class="s1">arr.dtype</span><span class="s2">}</span><span class="s3">] to [</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">is_timedelta64_dtype(arr.dtype):</span>
        <span class="s2">if </span><span class="s1">dtype == np.int64:</span>
            <span class="s2">if </span><span class="s1">isna(arr).any():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot convert NaT values to integer&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">arr.view(dtype)</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;m&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">astype_td64_unit_conversion(arr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;cannot astype a timedelta from [</span><span class="s2">{</span><span class="s1">arr.dtype</span><span class="s2">}</span><span class="s3">] to [</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">np.issubdtype(arr.dtype</span><span class="s2">, </span><span class="s1">np.floating) </span><span class="s2">and </span><span class="s1">np.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.integer):</span>
        <span class="s2">return </span><span class="s1">astype_float_to_int_nansafe(arr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy)</span>

    <span class="s2">elif </span><span class="s1">is_object_dtype(arr.dtype):</span>

        <span class="s4"># work around NumPy brokenness, #1987</span>
        <span class="s2">if </span><span class="s1">np.issubdtype(dtype.type</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s2">return </span><span class="s1">lib.astype_intsafe(arr</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s4"># if we have a datetime/timedelta array of objects</span>
        <span class="s4"># then coerce to a proper dtype and recall astype_nansafe</span>

        <span class="s2">elif </span><span class="s1">is_datetime64_dtype(dtype):</span>
            <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">to_datetime</span>

            <span class="s2">return </span><span class="s1">astype_nansafe(</span>
                <span class="s1">to_datetime(arr).values</span><span class="s2">,</span>
                <span class="s1">dtype</span><span class="s2">,</span>
                <span class="s1">copy=copy</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">is_timedelta64_dtype(dtype):</span>
            <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">to_timedelta</span>

            <span class="s2">return </span><span class="s1">astype_nansafe(to_timedelta(arr)._values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s2">if </span><span class="s1">dtype.name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;timedelta64&quot;</span><span class="s1">):</span>
        <span class="s1">msg = (</span>
            <span class="s3">f&quot;The '</span><span class="s2">{</span><span class="s1">dtype.name</span><span class="s2">}</span><span class="s3">' dtype has no unit. Please pass in &quot;</span>
            <span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">dtype.name</span><span class="s2">}</span><span class="s3">[ns]' instead.&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">if </span><span class="s1">copy </span><span class="s2">or </span><span class="s1">is_object_dtype(arr.dtype) </span><span class="s2">or </span><span class="s1">is_object_dtype(dtype):</span>
        <span class="s4"># Explicit copy, or required since NumPy can't view from / to object.</span>
        <span class="s2">return </span><span class="s1">arr.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">arr.astype(dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>


<span class="s2">def </span><span class="s1">astype_float_to_int_nansafe(</span>
    <span class="s1">values: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">copy: bool</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    astype with a check preventing converting NaN to an meaningless integer value. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">np.isfinite(values).all():</span>
        <span class="s2">raise </span><span class="s1">IntCastingNaNError(</span>
            <span class="s3">&quot;Cannot convert non-finite values (NA or inf) to integer&quot;</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">values.astype(dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>


<span class="s2">def </span><span class="s1">astype_array(values: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">False</span><span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Cast array (ndarray or ExtensionArray) to the new dtype. 
 
    Parameters 
    ---------- 
    values : ndarray or ExtensionArray 
    dtype : dtype object 
    copy : bool, default False 
        copy if indicated 
 
    Returns 
    ------- 
    ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">values.dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]</span>
        <span class="s2">and </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]</span>
        <span class="s2">and </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype)</span>
        <span class="s2">and </span><span class="s1">dtype.itemsize != </span><span class="s5">8</span>
    <span class="s1">):</span>
        <span class="s4"># TODO(2.0) remove special case once deprecation on DTA/TDA is enforced</span>
        <span class="s1">msg = </span><span class="s3">rf&quot;cannot astype a datetimelike from [</span><span class="s2">{</span><span class="s1">values.dtype</span><span class="s2">}</span><span class="s3">] to [</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">]&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s2">if </span><span class="s1">is_datetime64tz_dtype(dtype) </span><span class="s2">and </span><span class="s1">is_datetime64_dtype(values.dtype):</span>
        <span class="s2">return </span><span class="s1">astype_dt64_to_dt64tz(values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">, </span><span class="s1">via_utc=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">is_dtype_equal(values.dtype</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s2">return </span><span class="s1">values.copy()</span>
        <span class="s2">return </span><span class="s1">values</span>

    <span class="s2">if not </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s4"># i.e. ExtensionArray</span>
        <span class="s1">values = values.astype(dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">values = astype_nansafe(values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s4"># in pandas we don't store numpy str dtypes, so convert to object</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">and </span><span class="s1">issubclass(values.dtype.type</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">values = np.array(values</span><span class="s2">, </span><span class="s1">dtype=object)</span>

    <span class="s2">return </span><span class="s1">values</span>


<span class="s2">def </span><span class="s1">astype_array_safe(</span>
    <span class="s1">values: ArrayLike</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">False, </span><span class="s1">errors: str = </span><span class="s3">&quot;raise&quot;</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Cast array (ndarray or ExtensionArray) to the new dtype. 
 
    This basically is the implementation for DataFrame/Series.astype and 
    includes all custom logic for pandas (NaN-safety, converting str to object, 
    not allowing ) 
 
    Parameters 
    ---------- 
    values : ndarray or ExtensionArray 
    dtype : str, dtype convertible 
    copy : bool, default False 
        copy if indicated 
    errors : str, {'raise', 'ignore'}, default 'raise' 
        - ``raise`` : allow exceptions to be raised 
        - ``ignore`` : suppress exceptions. On error return original object 
 
    Returns 
    ------- 
    ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s1">errors_legal_values = (</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">errors </span><span class="s2">not in </span><span class="s1">errors_legal_values:</span>
        <span class="s1">invalid_arg = (</span>
            <span class="s3">&quot;Expected value of kwarg 'errors' to be one of &quot;</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">list(errors_legal_values)</span><span class="s2">}</span><span class="s3">. Supplied value is '</span><span class="s2">{</span><span class="s1">errors</span><span class="s2">}</span><span class="s3">'&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">ValueError(invalid_arg)</span>

    <span class="s2">if </span><span class="s1">inspect.isclass(dtype) </span><span class="s2">and </span><span class="s1">issubclass(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s1">msg = (</span>
            <span class="s3">f&quot;Expected an instance of </span><span class="s2">{</span><span class="s1">dtype.__name__</span><span class="s2">}</span><span class="s3">, &quot;</span>
            <span class="s3">&quot;but got the class instead. Try instantiating 'dtype'.&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s1">dtype = pandas_dtype(dtype)</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">PandasDtype):</span>
        <span class="s4"># Ensure we don't end up with a PandasArray</span>
        <span class="s1">dtype = dtype.numpy_dtype</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">new_values = astype_array(values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>
    <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
        <span class="s4"># e.g. astype_nansafe can fail on object-dtype of strings</span>
        <span class="s4">#  trying to convert to float</span>
        <span class="s2">if </span><span class="s1">errors == </span><span class="s3">&quot;ignore&quot;</span><span class="s1">:</span>
            <span class="s1">new_values = values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise</span>

    <span class="s2">return </span><span class="s1">new_values</span>


<span class="s2">def </span><span class="s1">soft_convert_objects(</span>
    <span class="s1">values: np.ndarray</span><span class="s2">,</span>
    <span class="s1">datetime: bool = </span><span class="s2">True,</span>
    <span class="s1">numeric: bool = </span><span class="s2">True,</span>
    <span class="s1">timedelta: bool = </span><span class="s2">True,</span>
    <span class="s1">period: bool = </span><span class="s2">True,</span>
    <span class="s1">copy: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Try to coerce datetime, timedelta, and numeric object-dtype columns 
    to inferred dtype. 
 
    Parameters 
    ---------- 
    values : np.ndarray[object] 
    datetime : bool, default True 
    numeric: bool, default True 
    timedelta : bool, default True 
    period : bool, default True 
    copy : bool, default True 
 
    Returns 
    ------- 
    np.ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s1">validate_bool_kwarg(datetime</span><span class="s2">, </span><span class="s3">&quot;datetime&quot;</span><span class="s1">)</span>
    <span class="s1">validate_bool_kwarg(numeric</span><span class="s2">, </span><span class="s3">&quot;numeric&quot;</span><span class="s1">)</span>
    <span class="s1">validate_bool_kwarg(timedelta</span><span class="s2">, </span><span class="s3">&quot;timedelta&quot;</span><span class="s1">)</span>
    <span class="s1">validate_bool_kwarg(copy</span><span class="s2">, </span><span class="s3">&quot;copy&quot;</span><span class="s1">)</span>

    <span class="s1">conversion_count = sum((datetime</span><span class="s2">, </span><span class="s1">numeric</span><span class="s2">, </span><span class="s1">timedelta))</span>
    <span class="s2">if </span><span class="s1">conversion_count == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;At least one of datetime, numeric or timedelta must be True.&quot;</span><span class="s1">)</span>

    <span class="s4"># Soft conversions</span>
    <span class="s2">if </span><span class="s1">datetime </span><span class="s2">or </span><span class="s1">timedelta:</span>
        <span class="s4"># GH 20380, when datetime is beyond year 2262, hence outside</span>
        <span class="s4"># bound of nanosecond-resolution 64-bit integers.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">converted = lib.maybe_convert_objects(</span>
                <span class="s1">values</span><span class="s2">,</span>
                <span class="s1">convert_datetime=datetime</span><span class="s2">,</span>
                <span class="s1">convert_timedelta=timedelta</span><span class="s2">,</span>
                <span class="s1">convert_period=period</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s2">return </span><span class="s1">values</span>
        <span class="s2">if </span><span class="s1">converted </span><span class="s2">is not </span><span class="s1">values:</span>
            <span class="s2">return </span><span class="s1">converted</span>

    <span class="s2">if </span><span class="s1">numeric </span><span class="s2">and </span><span class="s1">is_object_dtype(values.dtype):</span>
        <span class="s1">converted</span><span class="s2">, </span><span class="s1">_ = lib.maybe_convert_numeric(values</span><span class="s2">, </span><span class="s1">set()</span><span class="s2">, </span><span class="s1">coerce_numeric=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s4"># If all NaNs, then do not-alter</span>
        <span class="s1">values = converted </span><span class="s2">if not </span><span class="s1">isna(converted).all() </span><span class="s2">else </span><span class="s1">values</span>
        <span class="s1">values = values.copy() </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">values</span>

    <span class="s2">return </span><span class="s1">values</span>


<span class="s2">def </span><span class="s1">convert_dtypes(</span>
    <span class="s1">input_array: ArrayLike</span><span class="s2">,</span>
    <span class="s1">convert_string: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_integer: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_boolean: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_floating: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert objects to best possible type, and optionally, 
    to types supporting ``pd.NA``. 
 
    Parameters 
    ---------- 
    input_array : ExtensionArray or np.ndarray 
    convert_string : bool, default True 
        Whether object dtypes should be converted to ``StringDtype()``. 
    convert_integer : bool, default True 
        Whether, if possible, conversion can be done to integer extension types. 
    convert_boolean : bool, defaults True 
        Whether object dtypes should be converted to ``BooleanDtypes()``. 
    convert_floating : bool, defaults True 
        Whether, if possible, conversion can be done to floating extension types. 
        If `convert_integer` is also True, preference will be give to integer 
        dtypes if the floats can be faithfully casted to integers. 
 
    Returns 
    ------- 
    np.dtype, or ExtensionDtype 
    &quot;&quot;&quot;</span>
    <span class="s1">inferred_dtype: str | DtypeObj</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">convert_string </span><span class="s2">or </span><span class="s1">convert_integer </span><span class="s2">or </span><span class="s1">convert_boolean </span><span class="s2">or </span><span class="s1">convert_floating</span>
    <span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(input_array</span><span class="s2">, </span><span class="s1">np.ndarray):</span>

        <span class="s2">if </span><span class="s1">is_object_dtype(input_array.dtype):</span>
            <span class="s1">inferred_dtype = lib.infer_dtype(input_array)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">inferred_dtype = input_array.dtype</span>

        <span class="s2">if </span><span class="s1">is_string_dtype(inferred_dtype):</span>
            <span class="s2">if not </span><span class="s1">convert_string </span><span class="s2">or </span><span class="s1">inferred_dtype == </span><span class="s3">&quot;bytes&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">input_array.dtype</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">pandas_dtype(</span><span class="s3">&quot;string&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">convert_integer:</span>
            <span class="s1">target_int_dtype = pandas_dtype(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">is_integer_dtype(input_array.dtype):</span>
                <span class="s2">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s2">import </span><span class="s1">INT_STR_TO_DTYPE</span>

                <span class="s1">inferred_dtype = INT_STR_TO_DTYPE.get(</span>
                    <span class="s1">input_array.dtype.name</span><span class="s2">, </span><span class="s1">target_int_dtype</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">is_numeric_dtype(input_array.dtype):</span>
                <span class="s4"># TODO: de-dup with maybe_cast_to_integer_array?</span>
                <span class="s1">arr = input_array[notna(input_array)]</span>
                <span class="s2">if </span><span class="s1">(arr.astype(int) == arr).all():</span>
                    <span class="s1">inferred_dtype = target_int_dtype</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">inferred_dtype = input_array.dtype</span>

        <span class="s2">if </span><span class="s1">convert_floating:</span>
            <span class="s2">if not </span><span class="s1">is_integer_dtype(input_array.dtype) </span><span class="s2">and </span><span class="s1">is_numeric_dtype(</span>
                <span class="s1">input_array.dtype</span>
            <span class="s1">):</span>
                <span class="s2">from </span><span class="s1">pandas.core.arrays.floating </span><span class="s2">import </span><span class="s1">FLOAT_STR_TO_DTYPE</span>

                <span class="s1">inferred_float_dtype: DtypeObj = FLOAT_STR_TO_DTYPE.get(</span>
                    <span class="s1">input_array.dtype.name</span><span class="s2">, </span><span class="s1">pandas_dtype(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s4"># if we could also convert to integer, check if all floats</span>
                <span class="s4"># are actually integers</span>
                <span class="s2">if </span><span class="s1">convert_integer:</span>
                    <span class="s4"># TODO: de-dup with maybe_cast_to_integer_array?</span>
                    <span class="s1">arr = input_array[notna(input_array)]</span>
                    <span class="s2">if </span><span class="s1">(arr.astype(int) == arr).all():</span>
                        <span class="s1">inferred_dtype = pandas_dtype(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">inferred_dtype = inferred_float_dtype</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">inferred_dtype = inferred_float_dtype</span>

        <span class="s2">if </span><span class="s1">convert_boolean:</span>
            <span class="s2">if </span><span class="s1">is_bool_dtype(input_array.dtype):</span>
                <span class="s1">inferred_dtype = pandas_dtype(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">inferred_dtype == </span><span class="s3">&quot;boolean&quot;</span><span class="s1">:</span>
                <span class="s1">inferred_dtype = pandas_dtype(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s4"># If we couldn't do anything else, then we retain the dtype</span>
            <span class="s1">inferred_dtype = input_array.dtype</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">input_array.dtype</span>

    <span class="s4"># error: Incompatible return value type (got &quot;Union[str, Union[dtype[Any],</span>
    <span class="s4"># ExtensionDtype]]&quot;, expected &quot;Union[dtype[Any], ExtensionDtype]&quot;)</span>
    <span class="s2">return </span><span class="s1">inferred_dtype  </span><span class="s4"># type: ignore[return-value]</span>


<span class="s2">def </span><span class="s1">maybe_infer_to_datetimelike(</span>
    <span class="s1">value: np.ndarray</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray | IntervalArray:</span>
    <span class="s0">&quot;&quot;&quot; 
    we might have a array (or single object) that is datetime like, 
    and no dtype is passed don't change the value unless we find a 
    datetime/timedelta set 
 
    this is pretty strict in that a datetime/timedelta is REQUIRED 
    in addition to possible nulls/string likes 
 
    Parameters 
    ---------- 
    value : np.ndarray[object] 
 
    Returns 
    ------- 
    np.ndarray, DatetimeArray, TimedeltaArray, PeriodArray, or IntervalArray 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">or </span><span class="s1">value.dtype != object:</span>
        <span class="s4"># Caller is responsible for passing only ndarray[object]</span>
        <span class="s2">raise </span><span class="s1">TypeError(type(value))  </span><span class="s4"># pragma: no cover</span>

    <span class="s1">v = np.array(value</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">shape = v.shape</span>
    <span class="s2">if </span><span class="s1">v.ndim != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">v = v.ravel()</span>

    <span class="s2">if not </span><span class="s1">len(v):</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">try_datetime(v: np.ndarray) -&gt; ArrayLike:</span>
        <span class="s4"># Coerce to datetime64, datetime64tz, or in corner cases</span>
        <span class="s4">#  object[datetimes]</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.datetimes </span><span class="s2">import </span><span class="s1">sequence_to_datetimes</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s4"># GH#19671 we pass require_iso8601 to be relatively strict</span>
            <span class="s4">#  when parsing strings.</span>
            <span class="s1">dta = sequence_to_datetimes(v</span><span class="s2">, </span><span class="s1">require_iso8601=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s4"># e.g. &lt;class 'numpy.timedelta64'&gt; is not convertible to datetime</span>
            <span class="s2">return </span><span class="s1">v.reshape(shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># GH#19761 we may have mixed timezones, in which cast 'dta' is</span>
            <span class="s4">#  an ndarray[object].  Only 1 test</span>
            <span class="s4">#  relies on this behavior, see GH#40111</span>
            <span class="s2">return </span><span class="s1">dta.reshape(shape)</span>

    <span class="s2">def </span><span class="s1">try_timedelta(v: np.ndarray) -&gt; np.ndarray:</span>
        <span class="s4"># safe coerce to timedelta64</span>

        <span class="s4"># will try first with a string &amp; object conversion</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s4"># bc we know v.dtype == object, this is equivalent to</span>
            <span class="s4">#  `np.asarray(to_timedelta(v))`, but using a lower-level API that</span>
            <span class="s4">#  does not require a circular import.</span>
            <span class="s1">td_values = array_to_timedelta64(v).view(</span><span class="s3">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s2">return </span><span class="s1">v.reshape(shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">td_values.reshape(shape)</span>

    <span class="s1">inferred_type</span><span class="s2">, </span><span class="s1">seen_str = lib.infer_datetimelike_array(ensure_object(v))</span>
    <span class="s2">if </span><span class="s1">inferred_type </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;period&quot;</span><span class="s2">, </span><span class="s3">&quot;interval&quot;</span><span class="s1">]:</span>
        <span class="s4"># Incompatible return value type (got &quot;Union[ExtensionArray, ndarray]&quot;,</span>
        <span class="s4"># expected &quot;Union[ndarray, DatetimeArray, TimedeltaArray, PeriodArray,</span>
        <span class="s4"># IntervalArray]&quot;)</span>
        <span class="s2">return </span><span class="s1">lib.maybe_convert_objects(  </span><span class="s4"># type: ignore[return-value]</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">convert_period=</span><span class="s2">True, </span><span class="s1">convert_interval=</span><span class="s2">True</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">inferred_type == </span><span class="s3">&quot;datetime&quot;</span><span class="s1">:</span>
        <span class="s4"># error: Incompatible types in assignment (expression has type &quot;ExtensionArray&quot;,</span>
        <span class="s4"># variable has type &quot;Union[ndarray, List[Any]]&quot;)</span>
        <span class="s1">value = try_datetime(v)  </span><span class="s4"># type: ignore[assignment]</span>
    <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;timedelta&quot;</span><span class="s1">:</span>
        <span class="s1">value = try_timedelta(v)</span>
    <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;nat&quot;</span><span class="s1">:</span>

        <span class="s4"># if all NaT, return as datetime</span>
        <span class="s2">if </span><span class="s1">isna(v).all():</span>
            <span class="s4"># error: Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;ExtensionArray&quot;, variable has type &quot;Union[ndarray, List[Any]]&quot;)</span>
            <span class="s1">value = try_datetime(v)  </span><span class="s4"># type: ignore[assignment]</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s4"># We have at least a NaT and a string</span>
            <span class="s4"># try timedelta first to avoid spurious datetime conversions</span>
            <span class="s4"># e.g. '00:00:01' is a timedelta but technically is also a datetime</span>
            <span class="s1">value = try_timedelta(v)</span>
            <span class="s2">if </span><span class="s1">lib.infer_dtype(value</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;mixed&quot;</span><span class="s1">]:</span>
                <span class="s4"># cannot skip missing values, as NaT implies that the string</span>
                <span class="s4"># is actually a datetime</span>

                <span class="s4"># error: Incompatible types in assignment (expression has type</span>
                <span class="s4"># &quot;ExtensionArray&quot;, variable has type &quot;Union[ndarray, List[Any]]&quot;)</span>
                <span class="s1">value = try_datetime(v)  </span><span class="s4"># type: ignore[assignment]</span>

    <span class="s2">if </span><span class="s1">value.dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">seen_str:</span>
        <span class="s4"># TODO(2.0): enforcing this deprecation should close GH#40111</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">f&quot;Inferring </span><span class="s2">{</span><span class="s1">value.dtype</span><span class="s2">} </span><span class="s3">from data containing strings is deprecated &quot;</span>
            <span class="s3">&quot;and will be removed in a future version. To retain the old behavior &quot;</span>
            <span class="s3">f&quot;explicitly pass Series(data, dtype=</span><span class="s2">{</span><span class="s1">value.dtype</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">maybe_cast_to_datetime(</span>
    <span class="s1">value: ExtensionArray | np.ndarray | list</span><span class="s2">, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None</span>
<span class="s1">) -&gt; ExtensionArray | np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    try to cast the array/value to a datetimelike dtype, converting float 
    nan to iNaT 
 
    We allow a list *only* when dtype is not None. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.datetimes </span><span class="s2">import </span><span class="s1">sequence_to_datetimes</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.timedeltas </span><span class="s2">import </span><span class="s1">TimedeltaArray</span>

    <span class="s2">if not </span><span class="s1">is_list_like(value):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;value must be listlike&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">is_timedelta64_dtype(dtype):</span>
        <span class="s4"># TODO: _from_sequence would raise ValueError in cases where</span>
        <span class="s4">#  ensure_nanosecond_dtype raises TypeError</span>
        <span class="s1">dtype = cast(np.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">dtype = ensure_nanosecond_dtype(dtype)</span>
        <span class="s1">res = TimedeltaArray._from_sequence(value</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">is_datetime64 = is_datetime64_dtype(dtype)</span>
        <span class="s1">is_datetime64tz = is_datetime64tz_dtype(dtype)</span>

        <span class="s1">vdtype = getattr(value</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">is_datetime64 </span><span class="s2">or </span><span class="s1">is_datetime64tz:</span>
            <span class="s1">dtype = ensure_nanosecond_dtype(dtype)</span>

            <span class="s1">value = np.array(value</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

            <span class="s4"># we have an array of datetime or timedeltas &amp; nulls</span>
            <span class="s2">if </span><span class="s1">value.size </span><span class="s2">or not </span><span class="s1">is_dtype_equal(value.dtype</span><span class="s2">, </span><span class="s1">dtype):</span>
                <span class="s1">_disallow_mismatched_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">is_datetime64:</span>
                        <span class="s1">dta = sequence_to_datetimes(value)</span>
                        <span class="s4"># GH 25843: Remove tz information since the dtype</span>
                        <span class="s4"># didn't specify one</span>

                        <span class="s2">if </span><span class="s1">dta.tz </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s1">warnings.warn(</span>
                                <span class="s3">&quot;Data is timezone-aware. Converting &quot;</span>
                                <span class="s3">&quot;timezone-aware data to timezone-naive by &quot;</span>
                                <span class="s3">&quot;passing dtype='datetime64[ns]' to &quot;</span>
                                <span class="s3">&quot;DataFrame or Series is deprecated and will &quot;</span>
                                <span class="s3">&quot;raise in a future version. Use &quot;</span>
                                <span class="s3">&quot;`pd.Series(values).dt.tz_localize(None)` &quot;</span>
                                <span class="s3">&quot;instead.&quot;</span><span class="s2">,</span>
                                <span class="s1">FutureWarning</span><span class="s2">,</span>
                                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                            <span class="s1">)</span>
                            <span class="s4"># equiv: dta.view(dtype)</span>
                            <span class="s4"># Note: NOT equivalent to dta.astype(dtype)</span>
                            <span class="s1">dta = dta.tz_localize(</span><span class="s2">None</span><span class="s1">)</span>

                        <span class="s1">value = dta</span>
                    <span class="s2">elif </span><span class="s1">is_datetime64tz:</span>
                        <span class="s1">dtype = cast(DatetimeTZDtype</span><span class="s2">, </span><span class="s1">dtype)</span>
                        <span class="s4"># The string check can be removed once issue #13712</span>
                        <span class="s4"># is solved. String data that is passed with a</span>
                        <span class="s4"># datetime64tz is assumed to be naive which should</span>
                        <span class="s4"># be localized to the timezone.</span>
                        <span class="s1">is_dt_string = is_string_dtype(value.dtype)</span>
                        <span class="s1">dta = sequence_to_datetimes(value)</span>
                        <span class="s2">if </span><span class="s1">dta.tz </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s1">value = dta.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
                        <span class="s2">elif </span><span class="s1">is_dt_string:</span>
                            <span class="s4"># Strings here are naive, so directly localize</span>
                            <span class="s4"># equiv: dta.astype(dtype)  # though deprecated</span>

                            <span class="s1">value = dta.tz_localize(dtype.tz)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s4"># Numeric values are UTC at this point,</span>
                            <span class="s4"># so localize and convert</span>
                            <span class="s4"># equiv: Series(dta).astype(dtype) # though deprecated</span>
                            <span class="s2">if </span><span class="s1">getattr(vdtype</span><span class="s2">, </span><span class="s3">&quot;kind&quot;</span><span class="s2">, None</span><span class="s1">) == </span><span class="s3">&quot;M&quot;</span><span class="s1">:</span>
                                <span class="s4"># GH#24559, GH#33401 deprecate behavior inconsistent</span>
                                <span class="s4">#  with DatetimeArray/DatetimeIndex</span>
                                <span class="s1">warnings.warn(</span>
                                    <span class="s3">&quot;In a future version, constructing a Series &quot;</span>
                                    <span class="s3">&quot;from datetime64[ns] data and a &quot;</span>
                                    <span class="s3">&quot;DatetimeTZDtype will interpret the data &quot;</span>
                                    <span class="s3">&quot;as wall-times instead of &quot;</span>
                                    <span class="s3">&quot;UTC times, matching the behavior of &quot;</span>
                                    <span class="s3">&quot;DatetimeIndex. To treat the data as UTC &quot;</span>
                                    <span class="s3">&quot;times, use pd.Series(data).dt&quot;</span>
                                    <span class="s3">&quot;.tz_localize('UTC').tz_convert(dtype.tz) &quot;</span>
                                    <span class="s3">&quot;or pd.Series(data.view('int64'), dtype=dtype)&quot;</span><span class="s2">,</span>
                                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                                    <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                                <span class="s1">)</span>

                            <span class="s1">value = dta.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz_convert(dtype.tz)</span>
                <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
                    <span class="s2">raise</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s4"># TODO(GH#40048): only catch dateutil's ParserError</span>
                    <span class="s4">#  once we can reliably import it in all supported versions</span>
                    <span class="s2">pass</span>

        <span class="s2">elif </span><span class="s1">getattr(vdtype</span><span class="s2">, </span><span class="s3">&quot;kind&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>
            <span class="s4"># we are already datetimelike and want to coerce to non-datetimelike;</span>
            <span class="s4">#  astype_nansafe will raise for anything other than object, then upcast.</span>
            <span class="s4">#  see test_datetimelike_values_with_object_dtype</span>
            <span class="s4"># error: Argument 2 to &quot;astype_nansafe&quot; has incompatible type</span>
            <span class="s4"># &quot;Union[dtype[Any], ExtensionDtype]&quot;; expected &quot;dtype[Any]&quot;</span>
            <span class="s2">return </span><span class="s1">astype_nansafe(value</span><span class="s2">, </span><span class="s1">dtype)  </span><span class="s4"># type: ignore[arg-type]</span>

    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">value.dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">]:</span>
            <span class="s4"># catch a datetime/timedelta that is not of ns variety</span>
            <span class="s4"># and no coercion specified</span>
            <span class="s1">value = sanitize_to_nanoseconds(value)</span>

        <span class="s2">elif </span><span class="s1">value.dtype == _dtype_obj:</span>
            <span class="s1">value = maybe_infer_to_datetimelike(value)</span>

    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s4"># we only get here with dtype=None, which we do not allow</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;maybe_cast_to_datetime allows a list *only* if dtype is not None&quot;</span>
        <span class="s1">)</span>

    <span class="s4"># at this point we have converted or raised in all cases where we had a list</span>
    <span class="s2">return </span><span class="s1">cast(ArrayLike</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s2">def </span><span class="s1">sanitize_to_nanoseconds(values: np.ndarray</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">False</span><span class="s1">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    Safely convert non-nanosecond datetime64 or timedelta64 values to nanosecond. 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = values.dtype</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot; </span><span class="s2">and </span><span class="s1">dtype != DT64NS_DTYPE:</span>
        <span class="s1">values = conversion.ensure_datetime64ns(values)</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;m&quot; </span><span class="s2">and </span><span class="s1">dtype != TD64NS_DTYPE:</span>
        <span class="s1">values = conversion.ensure_timedelta64ns(values)</span>

    <span class="s2">elif </span><span class="s1">copy:</span>
        <span class="s1">values = values.copy()</span>

    <span class="s2">return </span><span class="s1">values</span>


<span class="s2">def </span><span class="s1">ensure_nanosecond_dtype(dtype: DtypeObj) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert dtypes with granularity less than nanosecond to nanosecond 
 
    &gt;&gt;&gt; ensure_nanosecond_dtype(np.dtype(&quot;M8[s]&quot;)) 
    dtype('&lt;M8[ns]') 
 
    &gt;&gt;&gt; ensure_nanosecond_dtype(np.dtype(&quot;m8[ps]&quot;)) 
    Traceback (most recent call last): 
        ... 
    TypeError: cannot convert timedeltalike to dtype [timedelta64[ps]] 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = (</span>
        <span class="s3">f&quot;The '</span><span class="s2">{</span><span class="s1">dtype.name</span><span class="s2">}</span><span class="s3">' dtype has no unit. &quot;</span>
        <span class="s3">f&quot;Please pass in '</span><span class="s2">{</span><span class="s1">dtype.name</span><span class="s2">}</span><span class="s3">[ns]' instead.&quot;</span>
    <span class="s1">)</span>

    <span class="s4"># unpack e.g. SparseDtype</span>
    <span class="s1">dtype = getattr(dtype</span><span class="s2">, </span><span class="s3">&quot;subtype&quot;</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s4"># i.e. datetime64tz</span>
        <span class="s2">pass</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot; </span><span class="s2">and </span><span class="s1">dtype != DT64NS_DTYPE:</span>
        <span class="s4"># pandas supports dtype whose granularity is less than [ns]</span>
        <span class="s4"># e.g., [ps], [fs], [as]</span>
        <span class="s2">if </span><span class="s1">dtype &lt;= np.dtype(</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">dtype.name == </span><span class="s3">&quot;datetime64&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">dtype = DT64NS_DTYPE</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;cannot convert datetimelike to dtype [</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;m&quot; </span><span class="s2">and </span><span class="s1">dtype != TD64NS_DTYPE:</span>
        <span class="s4"># pandas supports dtype whose granularity is less than [ns]</span>
        <span class="s4"># e.g., [ps], [fs], [as]</span>
        <span class="s2">if </span><span class="s1">dtype &lt;= np.dtype(</span><span class="s3">&quot;m8[ns]&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">dtype.name == </span><span class="s3">&quot;timedelta64&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">dtype = TD64NS_DTYPE</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;cannot convert timedeltalike to dtype [</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">find_common_type(types: list[np.dtype]) -&gt; np.dtype:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">find_common_type(types: list[ExtensionDtype]) -&gt; DtypeObj:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">find_common_type(types: list[DtypeObj]) -&gt; DtypeObj:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">find_common_type(types):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find a common data type among the given dtypes. 
 
    Parameters 
    ---------- 
    types : list of dtypes 
 
    Returns 
    ------- 
    pandas extension or numpy dtype 
 
    See Also 
    -------- 
    numpy.find_common_type 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">types:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;no types given&quot;</span><span class="s1">)</span>

    <span class="s1">first = types[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4"># workaround for find_common_type([np.dtype('datetime64[ns]')] * 2)</span>
    <span class="s4"># =&gt; object</span>
    <span class="s2">if </span><span class="s1">lib.dtypes_all_equal(list(types)):</span>
        <span class="s2">return </span><span class="s1">first</span>

    <span class="s4"># get unique types (dict.fromkeys is used as order-preserving set())</span>
    <span class="s1">types = list(dict.fromkeys(types).keys())</span>

    <span class="s2">if </span><span class="s1">any(isinstance(t</span><span class="s2">, </span><span class="s1">ExtensionDtype) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types):</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types:</span>
            <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
                <span class="s1">res = t._get_common_dtype(types)</span>
                <span class="s2">if </span><span class="s1">res </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s4"># take lowest unit</span>
    <span class="s2">if </span><span class="s1">all(is_datetime64_dtype(t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types):</span>
        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">all(is_timedelta64_dtype(t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types):</span>
        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

    <span class="s4"># don't mix bool / int or float or complex</span>
    <span class="s4"># this is different from numpy, which casts bool with float/int as int</span>
    <span class="s1">has_bools = any(is_bool_dtype(t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types)</span>
    <span class="s2">if </span><span class="s1">has_bools:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types:</span>
            <span class="s2">if </span><span class="s1">is_integer_dtype(t) </span><span class="s2">or </span><span class="s1">is_float_dtype(t) </span><span class="s2">or </span><span class="s1">is_complex_dtype(t):</span>
                <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">np.find_common_type(types</span><span class="s2">, </span><span class="s1">[])</span>


<span class="s2">def </span><span class="s1">construct_2d_arraylike_from_scalar(</span>
    <span class="s1">value: Scalar</span><span class="s2">, </span><span class="s1">length: int</span><span class="s2">, </span><span class="s1">width: int</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">copy: bool</span>
<span class="s1">) -&gt; np.ndarray:</span>

    <span class="s1">shape = (length</span><span class="s2">, </span><span class="s1">width)</span>

    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s1">value = maybe_unbox_datetimelike_tz_deprecation(value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">elif </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.timedelta64</span><span class="s2">, </span><span class="s1">np.datetime64)):</span>
            <span class="s4"># calling np.array below would cast to pytimedelta/pydatetime</span>
            <span class="s1">out = np.empty(shape</span><span class="s2">, </span><span class="s1">dtype=object)</span>
            <span class="s1">out.fill(value)</span>
            <span class="s2">return </span><span class="s1">out</span>

    <span class="s4"># Attempt to coerce to a numpy array</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">arr = np.array(value</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>
    <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError) </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">f&quot;DataFrame constructor called with incompatible data and dtype: </span><span class="s2">{</span><span class="s1">err</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s2">if </span><span class="s1">arr.ndim != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;DataFrame constructor not properly called!&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">np.full(shape</span><span class="s2">, </span><span class="s1">arr)</span>


<span class="s2">def </span><span class="s1">construct_1d_arraylike_from_scalar(</span>
    <span class="s1">value: Scalar</span><span class="s2">, </span><span class="s1">length: int</span><span class="s2">, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    create a np.ndarray / pandas type of specified shape and dtype 
    filled with values 
 
    Parameters 
    ---------- 
    value : scalar value 
    length : int 
    dtype : pandas_dtype or np.dtype 
 
    Returns 
    ------- 
    np.ndarray / pandas type of length, filled with value 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">value = infer_dtype_from_scalar(value</span><span class="s2">, </span><span class="s1">pandas_dtype=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
            <span class="s1">dtype = _dtype_obj</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s1">cls = dtype.construct_array_type()</span>
        <span class="s1">subarr = cls._from_sequence([value] * length</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s2">else</span><span class="s1">:</span>

        <span class="s2">if </span><span class="s1">length </span><span class="s2">and </span><span class="s1">is_integer_dtype(dtype) </span><span class="s2">and </span><span class="s1">isna(value):</span>
            <span class="s4"># coerce if we have nan for an integer dtype</span>
            <span class="s1">dtype = np.dtype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">and </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;U&quot;</span><span class="s2">, </span><span class="s3">&quot;S&quot;</span><span class="s1">):</span>
            <span class="s4"># we need to coerce to object dtype to avoid</span>
            <span class="s4"># to allow numpy to take our string as a scalar value</span>
            <span class="s1">dtype = np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">isna(value):</span>
                <span class="s1">value = ensure_str(value)</span>
        <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">]:</span>
            <span class="s1">value = maybe_unbox_datetimelike_tz_deprecation(value</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s1">subarr = np.empty(length</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">subarr.fill(value)</span>

    <span class="s2">return </span><span class="s1">subarr</span>


<span class="s2">def </span><span class="s1">maybe_unbox_datetimelike_tz_deprecation(value: Scalar</span><span class="s2">, </span><span class="s1">dtype: DtypeObj):</span>
    <span class="s0">&quot;&quot;&quot; 
    Wrap maybe_unbox_datetimelike with a check for a timezone-aware Timestamp 
    along with a timezone-naive datetime64 dtype, which is deprecated. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Caller is responsible for checking dtype.kind in [&quot;m&quot;, &quot;M&quot;]</span>

    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">datetime):</span>
        <span class="s4"># we dont want to box dt64, in particular datetime64(&quot;NaT&quot;)</span>
        <span class="s1">value = maybe_box_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">value = maybe_unbox_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">and </span><span class="s1">value.tzinfo </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype)</span>
            <span class="s2">and </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot;</span>
        <span class="s1">):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Data is timezone-aware. Converting &quot;</span>
                <span class="s3">&quot;timezone-aware data to timezone-naive by &quot;</span>
                <span class="s3">&quot;passing dtype='datetime64[ns]' to &quot;</span>
                <span class="s3">&quot;DataFrame or Series is deprecated and will &quot;</span>
                <span class="s3">&quot;raise in a future version. Use &quot;</span>
                <span class="s3">&quot;`pd.Series(values).dt.tz_localize(None)` &quot;</span>
                <span class="s3">&quot;instead.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">new_value = value.tz_localize(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">maybe_unbox_datetimelike(new_value</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">construct_1d_object_array_from_listlike(values: Sized) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    Transform any list-like object in a 1-dimensional numpy array of object 
    dtype. 
 
    Parameters 
    ---------- 
    values : any iterable which has a len() 
 
    Raises 
    ------ 
    TypeError 
        * If `values` does not have a len() 
 
    Returns 
    ------- 
    1-dimensional numpy array of dtype object 
    &quot;&quot;&quot;</span>
    <span class="s4"># numpy will try to interpret nested lists as further dimensions, hence</span>
    <span class="s4"># making a 1D array that contains list-likes is a bit tricky:</span>
    <span class="s1">result = np.empty(len(values)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
    <span class="s1">result[:] = values</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">maybe_cast_to_integer_array(</span>
    <span class="s1">arr: list | np.ndarray</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    Takes any dtype and returns the casted version, raising for when data is 
    incompatible with integer/unsigned integer dtypes. 
 
    Parameters 
    ---------- 
    arr : np.ndarray or list 
        The array to cast. 
    dtype : np.dtype 
        The integer dtype to cast the array to. 
    copy: bool, default False 
        Whether to make a copy of the array before returning. 
 
    Returns 
    ------- 
    ndarray 
        Array of integer or unsigned integer dtype. 
 
    Raises 
    ------ 
    OverflowError : the dtype is incompatible with the data 
    ValueError : loss of precision has occurred during casting 
 
    Examples 
    -------- 
    If you try to coerce negative values to unsigned integers, it raises: 
 
    &gt;&gt;&gt; pd.Series([-1], dtype=&quot;uint64&quot;) 
    Traceback (most recent call last): 
        ... 
    OverflowError: Trying to coerce negative values to unsigned integers 
 
    Also, if you try to coerce float values to integers, it raises: 
 
    &gt;&gt;&gt; pd.Series([1, 2, 3.5], dtype=&quot;int64&quot;) 
    Traceback (most recent call last): 
        ... 
    ValueError: Trying to coerce float values to integers 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">is_integer_dtype(dtype)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">casted = np.array(arr</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">casted = arr.astype(dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>
    <span class="s2">except </span><span class="s1">OverflowError </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">raise </span><span class="s1">OverflowError(</span>
            <span class="s3">&quot;The elements provided in the data cannot all be &quot;</span>
            <span class="s3">f&quot;casted to the dtype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s2">if </span><span class="s1">np.array_equal(arr</span><span class="s2">, </span><span class="s1">casted):</span>
        <span class="s2">return </span><span class="s1">casted</span>

    <span class="s4"># We do this casting to allow for proper</span>
    <span class="s4"># data and dtype checking.</span>
    <span class="s4">#</span>
    <span class="s4"># We didn't do this earlier because NumPy</span>
    <span class="s4"># doesn't handle `uint64` correctly.</span>
    <span class="s1">arr = np.asarray(arr)</span>

    <span class="s2">if </span><span class="s1">is_unsigned_integer_dtype(dtype) </span><span class="s2">and </span><span class="s1">(arr &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
        <span class="s2">raise </span><span class="s1">OverflowError(</span><span class="s3">&quot;Trying to coerce negative values to unsigned integers&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">is_float_dtype(arr.dtype):</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(arr).all():</span>
            <span class="s2">raise </span><span class="s1">IntCastingNaNError(</span>
                <span class="s3">&quot;Cannot convert non-finite values (NA or inf) to integer&quot;</span>
            <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Trying to coerce float values to integers&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">is_object_dtype(arr.dtype):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Trying to coerce float values to integers&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">casted.dtype &lt; arr.dtype:</span>
        <span class="s4"># GH#41734 e.g. [1, 200, 923442] and dtype=&quot;int8&quot; -&gt; overflows</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">f&quot;Values are too large to be losslessly cast to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">. &quot;</span>
            <span class="s3">&quot;In a future version this will raise OverflowError. To retain the &quot;</span>
            <span class="s3">f&quot;old behavior, use pd.Series(values).astype(</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">casted</span>

    <span class="s2">if </span><span class="s1">arr.dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s4"># test_constructor_maskedarray_nonfloat</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">f&quot;Constructing Series or DataFrame from </span><span class="s2">{</span><span class="s1">arr.dtype</span><span class="s2">} </span><span class="s3">values and &quot;</span>
            <span class="s3">f&quot;dtype=</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">is deprecated and will raise in a future version. &quot;</span>
            <span class="s3">&quot;Use values.view(dtype) instead.&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">casted</span>

    <span class="s4"># No known cases that get here, but raising explicitly to cover our bases.</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;values cannot be losslessly cast to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">convert_scalar_for_putitemlike(scalar: Scalar</span><span class="s2">, </span><span class="s1">dtype: np.dtype) -&gt; Scalar:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert datetimelike scalar if we are setting into a datetime64 
    or timedelta64 ndarray. 
 
    Parameters 
    ---------- 
    scalar : scalar 
    dtype : np.dtype 
 
    Returns 
    ------- 
    scalar 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s1">scalar = maybe_box_datetimelike(scalar</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">return </span><span class="s1">maybe_unbox_datetimelike(scalar</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">_validate_numeric_casting(dtype</span><span class="s2">, </span><span class="s1">scalar)</span>
    <span class="s2">return </span><span class="s1">scalar</span>


<span class="s2">def </span><span class="s1">_validate_numeric_casting(dtype: np.dtype</span><span class="s2">, </span><span class="s1">value: Scalar) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check that we can losslessly insert the given value into an array 
    with the given dtype. 
 
    Parameters 
    ---------- 
    dtype : np.dtype 
    value : scalar 
 
    Raises 
    ------ 
    ValueError 
    &quot;&quot;&quot;</span>
    <span class="s4"># error: Argument 1 to &quot;__call__&quot; of &quot;ufunc&quot; has incompatible type</span>
    <span class="s4"># &quot;Union[Union[str, int, float, bool], Union[Any, Timestamp, Timedelta, Any]]&quot;;</span>
    <span class="s4"># expected &quot;Union[Union[int, float, complex, str, bytes, generic],</span>
    <span class="s4"># Sequence[Union[int, float, complex, str, bytes, generic]],</span>
    <span class="s4"># Sequence[Sequence[Any]], _SupportsArray]&quot;</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">(np.integer</span><span class="s2">, </span><span class="s1">np.bool_))</span>
        <span class="s2">and </span><span class="s1">is_float(value)</span>
        <span class="s2">and </span><span class="s1">np.isnan(value)  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot assign nan to integer series&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s2">, </span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">is_bool(value) </span><span class="s2">or </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">np.timedelta64):</span>
            <span class="s4"># numpy will cast td64 to integer if we're not careful</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Cannot assign </span><span class="s2">{</span><span class="s1">type(value).__name__</span><span class="s2">} </span><span class="s3">to float/integer series&quot;</span>
            <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_scalar(value) </span><span class="s2">and not </span><span class="s1">is_bool(value):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Cannot assign </span><span class="s2">{</span><span class="s1">type(value).__name__</span><span class="s2">} </span><span class="s3">to bool series&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">can_hold_element(arr: ArrayLike</span><span class="s2">, </span><span class="s1">element: Any) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Can we do an inplace setitem with this element in an array with this dtype? 
 
    Parameters 
    ---------- 
    arr : np.ndarray or ExtensionArray 
    element : Any 
 
    Returns 
    ------- 
    bool 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = arr.dtype</span>
    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">or </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">(PeriodDtype</span><span class="s2">, </span><span class="s1">IntervalDtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span><span class="s2">, </span><span class="s1">np.dtype)):</span>
            <span class="s4"># np.dtype here catches datetime64ns and timedelta64ns; we assume</span>
            <span class="s4">#  in this case that we have DatetimeArray/TimedeltaArray</span>
            <span class="s1">arr = cast(</span>
                <span class="s3">&quot;PeriodArray | DatetimeArray | TimedeltaArray | IntervalArray&quot;</span><span class="s2">, </span><span class="s1">arr</span>
            <span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">arr._validate_setitem_value(element)</span>
                <span class="s2">return True</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                <span class="s2">return False</span>

        <span class="s4"># This is technically incorrect, but maintains the behavior of</span>
        <span class="s4"># ExtensionBlock._can_hold_element</span>
        <span class="s2">return True</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">np_can_hold_element(dtype</span><span class="s2">, </span><span class="s1">element)</span>
        <span class="s2">return True</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">np_can_hold_element(dtype: np.dtype</span><span class="s2">, </span><span class="s1">element: Any) -&gt; Any:</span>
    <span class="s0">&quot;&quot;&quot; 
    Raise if we cannot losslessly set this element into an ndarray with this dtype. 
 
    Specifically about places where we disagree with numpy.  i.e. there are 
    cases where numpy will raise in doing the setitem that we do not check 
    for here, e.g. setting str &quot;X&quot; into a numeric ndarray. 
 
    Returns 
    ------- 
    Any 
        The element, potentially cast to the dtype. 
 
    Raises 
    ------ 
    ValueError : If we cannot losslessly store this element with this dtype. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">return </span><span class="s1">element</span>

    <span class="s1">tipo = maybe_infer_dtype_type(element)</span>

    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">range):</span>
            <span class="s2">if </span><span class="s1">_dtype_can_hold_range(element</span><span class="s2">, </span><span class="s1">dtype):</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>

        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">is_float(element) </span><span class="s2">and </span><span class="s1">element.is_integer():</span>
                    <span class="s2">return </span><span class="s1">element</span>

                <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">element.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
                    <span class="s4"># If all can be losslessly cast to integers, then we can hold them</span>
                    <span class="s4">#  We do something similar in putmask_smart</span>
                    <span class="s1">casted = element.astype(dtype)</span>
                    <span class="s1">comp = casted == element</span>
                    <span class="s2">if </span><span class="s1">comp.all():</span>
                        <span class="s2">return </span><span class="s1">element</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span>

                <span class="s4"># Anything other than integer we cannot hold</span>
                <span class="s2">raise </span><span class="s1">ValueError</span>
            <span class="s2">elif </span><span class="s1">dtype.itemsize &lt; tipo.itemsize:</span>
                <span class="s2">if </span><span class="s1">is_integer(element):</span>
                    <span class="s4"># e.g. test_setitem_series_int8 if we have a python int 1</span>
                    <span class="s4">#  tipo may be np.int32, despite the fact that it will fit</span>
                    <span class="s4">#  in smaller int dtypes.</span>
                    <span class="s1">info = np.iinfo(dtype)</span>
                    <span class="s2">if </span><span class="s1">info.min &lt;= element &lt;= info.max:</span>
                        <span class="s2">return </span><span class="s1">element</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span>
                <span class="s2">raise </span><span class="s1">ValueError</span>
            <span class="s2">elif not </span><span class="s1">isinstance(tipo</span><span class="s2">, </span><span class="s1">np.dtype):</span>
                <span class="s4"># i.e. nullable IntegerDtype; we can put this into an ndarray</span>
                <span class="s4">#  losslessly iff it has no NAs</span>
                <span class="s1">hasnas = element._mask.any()</span>
                <span class="s4"># TODO: don't rely on implementation detail</span>
                <span class="s2">if </span><span class="s1">hasnas:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span>
                <span class="s2">return </span><span class="s1">element</span>

            <span class="s2">return </span><span class="s1">element</span>

        <span class="s4"># We have not inferred an integer from the dtype</span>
        <span class="s4"># check if we have a builtin int or a float equal to an int</span>
        <span class="s2">if </span><span class="s1">is_integer(element) </span><span class="s2">or </span><span class="s1">(is_float(element) </span><span class="s2">and </span><span class="s1">element.is_integer()):</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s4"># TODO: itemsize check?</span>
            <span class="s2">if </span><span class="s1">tipo.kind </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]:</span>
                <span class="s4"># Anything other than float/integer we cannot hold</span>
                <span class="s2">raise </span><span class="s1">ValueError</span>
            <span class="s2">elif not </span><span class="s1">isinstance(tipo</span><span class="s2">, </span><span class="s1">np.dtype):</span>
                <span class="s4"># i.e. nullable IntegerDtype or FloatingDtype;</span>
                <span class="s4">#  we can put this into an ndarray losslessly iff it has no NAs</span>
                <span class="s1">hasnas = element._mask.any()</span>
                <span class="s4"># TODO: don't rely on implementation detail</span>
                <span class="s2">if </span><span class="s1">hasnas:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">return </span><span class="s1">element</span>

        <span class="s2">if </span><span class="s1">lib.is_integer(element) </span><span class="s2">or </span><span class="s1">lib.is_float(element):</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]:</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>
        <span class="s2">if </span><span class="s1">lib.is_integer(element) </span><span class="s2">or </span><span class="s1">lib.is_complex(element) </span><span class="s2">or </span><span class="s1">lib.is_float(element):</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:  </span><span class="s4"># FIXME: wrong with BooleanArray?</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>
        <span class="s2">if </span><span class="s1">lib.is_bool(element):</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;S&quot;</span><span class="s1">:</span>
        <span class="s4"># TODO: test tests.frame.methods.test_replace tests get here,</span>
        <span class="s4">#  need more targeted tests.  xref phofl has a PR about this</span>
        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind == </span><span class="s3">&quot;S&quot; </span><span class="s2">and </span><span class="s1">tipo.itemsize &lt;= dtype.itemsize:</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>
        <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">bytes) </span><span class="s2">and </span><span class="s1">len(element) &lt;= dtype.itemsize:</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s2">raise </span><span class="s1">NotImplementedError(dtype)</span>


<span class="s2">def </span><span class="s1">_dtype_can_hold_range(rng: range</span><span class="s2">, </span><span class="s1">dtype: np.dtype) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    maybe_infer_dtype_type infers to int64 (and float64 for very large endpoints), 
    but in many cases a range can be held by a smaller integer dtype. 
    Check if this is one of those cases. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">len(rng):</span>
        <span class="s2">return True</span>
    <span class="s2">return </span><span class="s1">np.can_cast(rng[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype) </span><span class="s2">and </span><span class="s1">np.can_cast(rng[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype)</span>
</pre>
</body>
</html>