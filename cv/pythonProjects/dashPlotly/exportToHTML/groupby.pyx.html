<html>
<head>
<title>groupby.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
groupby.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>

<span class="s0">from cython cimport floating</span>
<span class="s0">from libc.stdlib cimport (</span>
    <span class="s0">free,</span>
    <span class="s0">malloc,</span>
<span class="s0">)</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">complex64_t,</span>
    <span class="s0">complex128_t,</span>
    <span class="s0">float32_t,</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int8_t,</span>
    <span class="s0">int16_t,</span>
    <span class="s0">int32_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">intp_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
    <span class="s0">uint16_t,</span>
    <span class="s0">uint32_t,</span>
    <span class="s0">uint64_t,</span>
<span class="s0">)</span>
<span class="s0">from numpy.math cimport NAN</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from pandas._libs.algos cimport kth_smallest_c</span>
<span class="s0">from pandas._libs.util cimport get_nat</span>

<span class="s0">from pandas._libs.algos import (</span>
    <span class="s0">ensure_platform_int,</span>
    <span class="s0">groupsort_indexer,</span>
    <span class="s0">rank_1d,</span>
    <span class="s0">take_2d_axis1_float64_float64,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.dtypes cimport (</span>
    <span class="s0">iu_64_floating_obj_t,</span>
    <span class="s0">iu_64_floating_t,</span>
    <span class="s0">numeric_t,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.missing cimport checknull</span>


<span class="s0">cdef int64_t NPY_NAT = get_nat()</span>
<span class="s0">_int64_max = np.iinfo(np.int64).max</span>

<span class="s0">cdef float64_t NaN = &lt;float64_t&gt;np.NaN</span>

<span class="s0">cdef enum InterpolationEnumType:</span>
    <span class="s0">INTERPOLATION_LINEAR,</span>
    <span class="s0">INTERPOLATION_LOWER,</span>
    <span class="s0">INTERPOLATION_HIGHER,</span>
    <span class="s0">INTERPOLATION_NEAREST,</span>
    <span class="s0">INTERPOLATION_MIDPOINT</span>


<span class="s0">cdef inline float64_t median_linear(float64_t* a, int n) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int i, j, na_count = 0</span>
        <span class="s0">float64_t result</span>
        <span class="s0">float64_t* tmp</span>

    <span class="s0">if n == 0:</span>
        <span class="s0">return NaN</span>

    <span class="s0"># count NAs</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if a[i] != a[i]:</span>
            <span class="s0">na_count += 1</span>

    <span class="s0">if na_count:</span>
        <span class="s0">if na_count == n:</span>
            <span class="s0">return NaN</span>

        <span class="s0">tmp = &lt;float64_t*&gt;malloc((n - na_count) * sizeof(float64_t))</span>

        <span class="s0">j = 0</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">if a[i] == a[i]:</span>
                <span class="s0">tmp[j] = a[i]</span>
                <span class="s0">j += 1</span>

        <span class="s0">a = tmp</span>
        <span class="s0">n -= na_count</span>

    <span class="s0">if n % 2:</span>
        <span class="s0">result = kth_smallest_c(a, n // 2, n)</span>
    <span class="s0">else:</span>
        <span class="s0">result = (kth_smallest_c(a, n // 2, n) +</span>
                  <span class="s0">kth_smallest_c(a, n // 2 - 1, n)) / 2</span>

    <span class="s0">if na_count:</span>
        <span class="s0">free(a)</span>

    <span class="s0">return result</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_median_float64(ndarray[float64_t, ndim=2] out,</span>
                         <span class="s0">ndarray[int64_t] counts,</span>
                         <span class="s0">ndarray[float64_t, ndim=2] values,</span>
                         <span class="s0">ndarray[intp_t] labels,</span>
                         <span class="s0">Py_ssize_t min_count=-1) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Only aggregates on axis=0</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, ngroups, size</span>
        <span class="s0">ndarray[intp_t] _counts</span>
        <span class="s0">ndarray[float64_t, ndim=2] data</span>
        <span class="s0">ndarray[intp_t] indexer</span>
        <span class="s0">float64_t* ptr</span>

    <span class="s0">assert min_count == -1, &quot;'min_count' only used in add and prod&quot;</span>

    <span class="s0">ngroups = len(counts)</span>
    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">indexer, _counts = groupsort_indexer(labels, ngroups)</span>
    <span class="s0">counts[:] = _counts[1:]</span>

    <span class="s0">data = np.empty((K, N), dtype=np.float64)</span>
    <span class="s0">ptr = &lt;float64_t*&gt;cnp.PyArray_DATA(data)</span>

    <span class="s0">take_2d_axis1_float64_float64(values.T, indexer, out=data)</span>

    <span class="s0">with nogil:</span>

        <span class="s0">for i in range(K):</span>
            <span class="s0"># exclude NA group</span>
            <span class="s0">ptr += _counts[0]</span>
            <span class="s0">for j in range(ngroups):</span>
                <span class="s0">size = _counts[j + 1]</span>
                <span class="s0">out[j, i] = median_linear(ptr, size)</span>
                <span class="s0">ptr += size</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_cumprod_float64(float64_t[:, ::1] out,</span>
                          <span class="s0">const float64_t[:, :] values,</span>
                          <span class="s0">const intp_t[::1] labels,</span>
                          <span class="s0">int ngroups,</span>
                          <span class="s0">bint is_datetimelike,</span>
                          <span class="s0">bint skipna=True) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Cumulative product of columns of `values`, in row groups `labels`.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[np.float64, ndim=2]</span>
        <span class="s0">Array to store cumprod in.</span>
    <span class="s0">values : np.ndarray[np.float64, ndim=2]</span>
        <span class="s0">Values to take cumprod of.</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Labels to group by.</span>
    <span class="s0">ngroups : int</span>
        <span class="s0">Number of groups, larger than all entries of `labels`.</span>
    <span class="s0">is_datetimelike : bool</span>
        <span class="s0">Always false, `values` is never datetime-like.</span>
    <span class="s0">skipna : bool</span>
        <span class="s0">If true, ignore nans in `values`.</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter, rather than returning an object.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, size</span>
        <span class="s0">float64_t val</span>
        <span class="s0">float64_t[:, ::1] accum</span>
        <span class="s0">intp_t lab</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>
    <span class="s0">accum = np.ones((ngroups, K), dtype=np.float64)</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>

            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>
                <span class="s0">if val == val:</span>
                    <span class="s0">accum[lab, j] *= val</span>
                    <span class="s0">out[i, j] = accum[lab, j]</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = NaN</span>
                    <span class="s0">if not skipna:</span>
                        <span class="s0">accum[lab, j] = NaN</span>
                        <span class="s0">break</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_cumsum(numeric_t[:, ::1] out,</span>
                 <span class="s0">ndarray[numeric_t, ndim=2] values,</span>
                 <span class="s0">const intp_t[::1] labels,</span>
                 <span class="s0">int ngroups,</span>
                 <span class="s0">is_datetimelike,</span>
                 <span class="s0">bint skipna=True) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Cumulative sum of columns of `values`, in row groups `labels`.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[ndim=2]</span>
        <span class="s0">Array to store cumsum in.</span>
    <span class="s0">values : np.ndarray[ndim=2]</span>
        <span class="s0">Values to take cumsum of.</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Labels to group by.</span>
    <span class="s0">ngroups : int</span>
        <span class="s0">Number of groups, larger than all entries of `labels`.</span>
    <span class="s0">is_datetimelike : bool</span>
        <span class="s0">True if `values` contains datetime-like entries.</span>
    <span class="s0">skipna : bool</span>
        <span class="s0">If true, ignore nans in `values`.</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter, rather than returning an object.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, size</span>
        <span class="s0">numeric_t val, y, t</span>
        <span class="s0">numeric_t[:, ::1] accum, compensation</span>
        <span class="s0">intp_t lab</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>
    <span class="s0">accum = np.zeros((ngroups, K), dtype=np.asarray(values).dtype)</span>
    <span class="s0">compensation = np.zeros((ngroups, K), dtype=np.asarray(values).dtype)</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>

            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0"># For floats, use Kahan summation to reduce floating-point</span>
                <span class="s0"># error (https://en.wikipedia.org/wiki/Kahan_summation_algorithm)</span>
                <span class="s0">if numeric_t == float32_t or numeric_t == float64_t:</span>
                    <span class="s0">if val == val:</span>
                        <span class="s0">y = val - compensation[lab, j]</span>
                        <span class="s0">t = accum[lab, j] + y</span>
                        <span class="s0">compensation[lab, j] = t - accum[lab, j] - y</span>
                        <span class="s0">accum[lab, j] = t</span>
                        <span class="s0">out[i, j] = t</span>
                    <span class="s0">else:</span>
                        <span class="s0">out[i, j] = NaN</span>
                        <span class="s0">if not skipna:</span>
                            <span class="s0">accum[lab, j] = NaN</span>
                            <span class="s0">break</span>
                <span class="s0">else:</span>
                    <span class="s0">t = val + accum[lab, j]</span>
                    <span class="s0">accum[lab, j] = t</span>
                    <span class="s0">out[i, j] = t</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_shift_indexer(int64_t[::1] out, const intp_t[::1] labels,</span>
                        <span class="s0">int ngroups, int periods) -&gt; None:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t N, i, j, ii, lab</span>
        <span class="s0">int offset = 0, sign</span>
        <span class="s0">int64_t idxer, idxer_slot</span>
        <span class="s0">int64_t[::1] label_seen = np.zeros(ngroups, dtype=np.int64)</span>
        <span class="s0">int64_t[:, ::1] label_indexer</span>

    <span class="s0">N, = (&lt;object&gt;labels).shape</span>

    <span class="s0">if periods &lt; 0:</span>
        <span class="s0">periods = -periods</span>
        <span class="s0">offset = N - 1</span>
        <span class="s0">sign = -1</span>
    <span class="s0">elif periods &gt; 0:</span>
        <span class="s0">offset = 0</span>
        <span class="s0">sign = 1</span>

    <span class="s0">if periods == 0:</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(N):</span>
                <span class="s0">out[i] = i</span>
    <span class="s0">else:</span>
        <span class="s0"># array of each previous indexer seen</span>
        <span class="s0">label_indexer = np.zeros((ngroups, periods), dtype=np.int64)</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(N):</span>
                <span class="s0"># reverse iterator if shifting backwards</span>
                <span class="s0">ii = offset + sign * i</span>
                <span class="s0">lab = labels[ii]</span>

                <span class="s0"># Skip null keys</span>
                <span class="s0">if lab == -1:</span>
                    <span class="s0">out[ii] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">label_seen[lab] += 1</span>

                <span class="s0">idxer_slot = label_seen[lab] % periods</span>
                <span class="s0">idxer = label_indexer[lab, idxer_slot]</span>

                <span class="s0">if label_seen[lab] &gt; periods:</span>
                    <span class="s0">out[ii] = idxer</span>
                <span class="s0">else:</span>
                    <span class="s0">out[ii] = -1</span>

                <span class="s0">label_indexer[lab, idxer_slot] = ii</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_fillna_indexer(ndarray[intp_t] out, ndarray[intp_t] labels,</span>
                         <span class="s0">ndarray[intp_t] sorted_labels,</span>
                         <span class="s0">ndarray[uint8_t] mask, str direction,</span>
                         <span class="s0">int64_t limit, bint dropna) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Indexes how to fill values forwards or backwards within a group.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[np.intp]</span>
        <span class="s0">Values into which this method will write its results.</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Array containing unique label for each group, with its ordering</span>
        <span class="s0">matching up to the corresponding record in `values`.</span>
    <span class="s0">sorted_labels : np.ndarray[np.intp]</span>
        <span class="s0">obtained by `np.argsort(labels, kind=&quot;mergesort&quot;)`; reversed if</span>
        <span class="s0">direction == &quot;bfill&quot;</span>
    <span class="s0">values : np.ndarray[np.uint8]</span>
        <span class="s0">Containing the truth value of each element.</span>
    <span class="s0">mask : np.ndarray[np.uint8]</span>
        <span class="s0">Indicating whether a value is na or not.</span>
    <span class="s0">direction : {'ffill', 'bfill'}</span>
        <span class="s0">Direction for fill to be applied (forwards or backwards, respectively)</span>
    <span class="s0">limit : Consecutive values to fill before stopping, or -1 for no limit</span>
    <span class="s0">dropna : Flag to indicate if NaN groups should return all NaN values</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter rather than returning an object</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, N, idx</span>
        <span class="s0">intp_t curr_fill_idx=-1</span>
        <span class="s0">int64_t filled_vals = 0</span>

    <span class="s0">N = len(out)</span>

    <span class="s0"># Make sure all arrays are the same size</span>
    <span class="s0">assert N == len(labels) == len(mask)</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">idx = sorted_labels[i]</span>
            <span class="s0">if dropna and labels[idx] == -1:  # nan-group gets nan-values</span>
                <span class="s0">curr_fill_idx = -1</span>
            <span class="s0">elif mask[idx] == 1:  # is missing</span>
                <span class="s0"># Stop filling once we've hit the limit</span>
                <span class="s0">if filled_vals &gt;= limit and limit != -1:</span>
                    <span class="s0">curr_fill_idx = -1</span>
                <span class="s0">filled_vals += 1</span>
            <span class="s0">else:  # reset items when not missing</span>
                <span class="s0">filled_vals = 0</span>
                <span class="s0">curr_fill_idx = idx</span>

            <span class="s0">out[idx] = curr_fill_idx</span>

            <span class="s0"># If we move to the next group, reset</span>
            <span class="s0"># the fill_idx and counter</span>
            <span class="s0">if i == N - 1 or labels[idx] != labels[sorted_labels[i + 1]]:</span>
                <span class="s0">curr_fill_idx = -1</span>
                <span class="s0">filled_vals = 0</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_any_all(int8_t[:, ::1] out,</span>
                  <span class="s0">const int8_t[:, :] values,</span>
                  <span class="s0">const intp_t[::1] labels,</span>
                  <span class="s0">const uint8_t[:, :] mask,</span>
                  <span class="s0">str val_test,</span>
                  <span class="s0">bint skipna,</span>
                  <span class="s0">bint nullable) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Aggregated boolean values to show truthfulness of group elements. If the</span>
    <span class="s0">input is a nullable type (nullable=True), the result will be computed</span>
    <span class="s0">using Kleene logic.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[np.int8]</span>
        <span class="s0">Values into which this method will write its results.</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Array containing unique label for each group, with its</span>
        <span class="s0">ordering matching up to the corresponding record in `values`</span>
    <span class="s0">values : np.ndarray[np.int8]</span>
        <span class="s0">Containing the truth value of each element.</span>
    <span class="s0">mask : np.ndarray[np.uint8]</span>
        <span class="s0">Indicating whether a value is na or not.</span>
    <span class="s0">val_test : {'any', 'all'}</span>
        <span class="s0">String object dictating whether to use any or all truth testing</span>
    <span class="s0">skipna : bool</span>
        <span class="s0">Flag to ignore nan values during truth testing</span>
    <span class="s0">nullable : bool</span>
        <span class="s0">Whether or not the input is a nullable type. If True, the</span>
        <span class="s0">result will be computed using Kleene logic</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter rather than returning an object.</span>
    <span class="s0">The returned values will either be 0, 1 (False or True, respectively), or</span>
    <span class="s0">-1 to signify a masked position in the case of a nullable input.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N = len(labels), K = out.shape[1]</span>
        <span class="s0">intp_t lab</span>
        <span class="s0">int8_t flag_val, val</span>

    <span class="s0">if val_test == 'all':</span>
        <span class="s0"># Because the 'all' value of an empty iterable in Python is True we can</span>
        <span class="s0"># start with an array full of ones and set to zero when a False value</span>
        <span class="s0"># is encountered</span>
        <span class="s0">flag_val = 0</span>
    <span class="s0">elif val_test == 'any':</span>
        <span class="s0"># Because the 'any' value of an empty iterable in Python is False we</span>
        <span class="s0"># can start with an array full of zeros and set to one only if any</span>
        <span class="s0"># value encountered is True</span>
        <span class="s0">flag_val = 1</span>
    <span class="s0">else:</span>
        <span class="s0">raise ValueError(&quot;'bool_func' must be either 'any' or 'all'!&quot;)</span>

    <span class="s0">out[:] = 1 - flag_val</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">for j in range(K):</span>
                <span class="s0">if skipna and mask[i, j]:</span>
                    <span class="s0">continue</span>

                <span class="s0">if nullable and mask[i, j]:</span>
                    <span class="s0"># Set the position as masked if `out[lab] != flag_val`, which</span>
                    <span class="s0"># would indicate True/False has not yet been seen for any/all,</span>
                    <span class="s0"># so by Kleene logic the result is currently unknown</span>
                    <span class="s0">if out[lab, j] != flag_val:</span>
                        <span class="s0">out[lab, j] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">val = values[i, j]</span>

                <span class="s0"># If True and 'any' or False and 'all', the result is</span>
                <span class="s0"># already determined</span>
                <span class="s0">if val == flag_val:</span>
                    <span class="s0">out[lab, j] = flag_val</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># group_add, group_prod, group_var, group_mean, group_ohlc</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">ctypedef fused add_t:</span>
    <span class="s0">float64_t</span>
    <span class="s0">float32_t</span>
    <span class="s0">complex64_t</span>
    <span class="s0">complex128_t</span>
    <span class="s0">object</span>

<span class="s0">ctypedef fused mean_t:</span>
    <span class="s0">float64_t</span>
    <span class="s0">float32_t</span>
    <span class="s0">complex64_t</span>
    <span class="s0">complex128_t</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_add(add_t[:, ::1] out,</span>
              <span class="s0">int64_t[::1] counts,</span>
              <span class="s0">ndarray[add_t, ndim=2] values,</span>
              <span class="s0">const intp_t[::1] labels,</span>
              <span class="s0">Py_ssize_t min_count=0,</span>
              <span class="s0">bint datetimelike=False) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Only aggregates on axis=0 using Kahan summation</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ncounts = len(counts)</span>
        <span class="s0">add_t val, t, y</span>
        <span class="s0">add_t[:, ::1] sumx, compensation</span>
        <span class="s0">int64_t[:, ::1] nobs</span>
        <span class="s0">Py_ssize_t len_values = len(values), len_labels = len(labels)</span>

    <span class="s0">if len_values != len_labels:</span>
        <span class="s0">raise ValueError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>
    <span class="s0"># the below is equivalent to `np.zeros_like(out)` but faster</span>
    <span class="s0">sumx = np.zeros((&lt;object&gt;out).shape, dtype=(&lt;object&gt;out).base.dtype)</span>
    <span class="s0">compensation = np.zeros((&lt;object&gt;out).shape, dtype=(&lt;object&gt;out).base.dtype)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">if add_t is object:</span>
        <span class="s0"># NB: this does not use 'compensation' like the non-object track does.</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0"># not nan</span>
                <span class="s0">if not checknull(val):</span>
                    <span class="s0">nobs[lab, j] += 1</span>

                    <span class="s0">if nobs[lab, j] == 1:</span>
                        <span class="s0"># i.e. we haven't added anything yet; avoid TypeError</span>
                        <span class="s0">#  if e.g. val is a str and sumx[lab, j] is 0</span>
                        <span class="s0">t = val</span>
                    <span class="s0">else:</span>
                        <span class="s0">t = sumx[lab, j] + val</span>
                    <span class="s0">sumx[lab, j] = t</span>

        <span class="s0">for i in range(ncounts):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if nobs[i, j] &lt; min_count:</span>
                    <span class="s0">out[i, j] = NAN</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = sumx[i, j]</span>
    <span class="s0">else:</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(N):</span>
                <span class="s0">lab = labels[i]</span>
                <span class="s0">if lab &lt; 0:</span>
                    <span class="s0">continue</span>

                <span class="s0">counts[lab] += 1</span>
                <span class="s0">for j in range(K):</span>
                    <span class="s0">val = values[i, j]</span>

                    <span class="s0"># not nan</span>
                    <span class="s0"># With dt64/td64 values, values have been cast to float64</span>
                    <span class="s0">#  instead if int64 for group_add, but the logic</span>
                    <span class="s0">#  is otherwise the same as in _treat_as_na</span>
                    <span class="s0">if val == val and not (</span>
                        <span class="s0">add_t is float64_t</span>
                        <span class="s0">and datetimelike</span>
                        <span class="s0">and val == &lt;float64_t&gt;NPY_NAT</span>
                    <span class="s0">):</span>
                        <span class="s0">nobs[lab, j] += 1</span>
                        <span class="s0">y = val - compensation[lab, j]</span>
                        <span class="s0">t = sumx[lab, j] + y</span>
                        <span class="s0">compensation[lab, j] = t - sumx[lab, j] - y</span>
                        <span class="s0">sumx[lab, j] = t</span>

            <span class="s0">for i in range(ncounts):</span>
                <span class="s0">for j in range(K):</span>
                    <span class="s0">if nobs[i, j] &lt; min_count:</span>
                        <span class="s0">out[i, j] = NAN</span>
                    <span class="s0">else:</span>
                        <span class="s0">out[i, j] = sumx[i, j]</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_prod(floating[:, ::1] out,</span>
               <span class="s0">int64_t[::1] counts,</span>
               <span class="s0">ndarray[floating, ndim=2] values,</span>
               <span class="s0">const intp_t[::1] labels,</span>
               <span class="s0">Py_ssize_t min_count=0) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Only aggregates on axis=0</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ncounts = len(counts)</span>
        <span class="s0">floating val, count</span>
        <span class="s0">floating[:, ::1] prodx</span>
        <span class="s0">int64_t[:, ::1] nobs</span>
        <span class="s0">Py_ssize_t len_values = len(values), len_labels = len(labels)</span>

    <span class="s0">if len_values != len_labels:</span>
        <span class="s0">raise ValueError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>
    <span class="s0">prodx = np.ones((&lt;object&gt;out).shape, dtype=(&lt;object&gt;out).base.dtype)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0"># not nan</span>
                <span class="s0">if val == val:</span>
                    <span class="s0">nobs[lab, j] += 1</span>
                    <span class="s0">prodx[lab, j] *= val</span>

        <span class="s0">for i in range(ncounts):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if nobs[i, j] &lt; min_count:</span>
                    <span class="s0">out[i, j] = NAN</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = prodx[i, j]</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.cdivision(True)</span>
<span class="s0">def group_var(floating[:, ::1] out,</span>
              <span class="s0">int64_t[::1] counts,</span>
              <span class="s0">ndarray[floating, ndim=2] values,</span>
              <span class="s0">const intp_t[::1] labels,</span>
              <span class="s0">Py_ssize_t min_count=-1,</span>
              <span class="s0">int64_t ddof=1) -&gt; None:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ncounts = len(counts)</span>
        <span class="s0">floating val, ct, oldmean</span>
        <span class="s0">floating[:, ::1] mean</span>
        <span class="s0">int64_t[:, ::1] nobs</span>
        <span class="s0">Py_ssize_t len_values = len(values), len_labels = len(labels)</span>

    <span class="s0">assert min_count == -1, &quot;'min_count' only used in add and prod&quot;</span>

    <span class="s0">if len_values != len_labels:</span>
        <span class="s0">raise ValueError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>
    <span class="s0">mean = np.zeros((&lt;object&gt;out).shape, dtype=(&lt;object&gt;out).base.dtype)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">out[:, :] = 0.0</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>

            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0"># not nan</span>
                <span class="s0">if val == val:</span>
                    <span class="s0">nobs[lab, j] += 1</span>
                    <span class="s0">oldmean = mean[lab, j]</span>
                    <span class="s0">mean[lab, j] += (val - oldmean) / nobs[lab, j]</span>
                    <span class="s0">out[lab, j] += (val - mean[lab, j]) * (val - oldmean)</span>

        <span class="s0">for i in range(ncounts):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">ct = nobs[i, j]</span>
                <span class="s0">if ct &lt;= ddof:</span>
                    <span class="s0">out[i, j] = NAN</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] /= (ct - ddof)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_mean(mean_t[:, ::1] out,</span>
               <span class="s0">int64_t[::1] counts,</span>
               <span class="s0">ndarray[mean_t, ndim=2] values,</span>
               <span class="s0">const intp_t[::1] labels,</span>
               <span class="s0">Py_ssize_t min_count=-1,</span>
               <span class="s0">bint is_datetimelike=False,</span>
               <span class="s0">const uint8_t[:, ::1] mask=None,</span>
               <span class="s0">uint8_t[:, ::1] result_mask=None</span>
               <span class="s0">) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Compute the mean per label given a label assignment for each value.</span>
    <span class="s0">NaN values are ignored.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[floating]</span>
        <span class="s0">Values into which this method will write its results.</span>
    <span class="s0">counts : np.ndarray[int64]</span>
        <span class="s0">A zeroed array of the same shape as labels,</span>
        <span class="s0">populated by group sizes during algorithm.</span>
    <span class="s0">values : np.ndarray[floating]</span>
        <span class="s0">2-d array of the values to find the mean of.</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Array containing unique label for each group, with its</span>
        <span class="s0">ordering matching up to the corresponding record in `values`.</span>
    <span class="s0">min_count : Py_ssize_t</span>
        <span class="s0">Only used in add and prod. Always -1.</span>
    <span class="s0">is_datetimelike : bool</span>
        <span class="s0">True if `values` contains datetime-like entries.</span>
    <span class="s0">mask : ndarray[bool, ndim=2], optional</span>
        <span class="s0">Not used.</span>
    <span class="s0">result_mask : ndarray[bool, ndim=2], optional</span>
        <span class="s0">Not used.</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter rather than returning an object.</span>
    <span class="s0">`counts` is modified to hold group sizes</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ncounts = len(counts)</span>
        <span class="s0">mean_t val, count, y, t, nan_val</span>
        <span class="s0">mean_t[:, ::1] sumx, compensation</span>
        <span class="s0">int64_t[:, ::1] nobs</span>
        <span class="s0">Py_ssize_t len_values = len(values), len_labels = len(labels)</span>

    <span class="s0">assert min_count == -1, &quot;'min_count' only used in add and prod&quot;</span>

    <span class="s0">if len_values != len_labels:</span>
        <span class="s0">raise ValueError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0"># the below is equivalent to `np.zeros_like(out)` but faster</span>
    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>
    <span class="s0">sumx = np.zeros((&lt;object&gt;out).shape, dtype=(&lt;object&gt;out).base.dtype)</span>
    <span class="s0">compensation = np.zeros((&lt;object&gt;out).shape, dtype=(&lt;object&gt;out).base.dtype)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>
    <span class="s0">nan_val = NPY_NAT if is_datetimelike else NAN</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>
                <span class="s0"># not nan</span>
                <span class="s0">if val == val and not (is_datetimelike and val == NPY_NAT):</span>
                    <span class="s0">nobs[lab, j] += 1</span>
                    <span class="s0">y = val - compensation[lab, j]</span>
                    <span class="s0">t = sumx[lab, j] + y</span>
                    <span class="s0">compensation[lab, j] = t - sumx[lab, j] - y</span>
                    <span class="s0">sumx[lab, j] = t</span>

        <span class="s0">for i in range(ncounts):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">count = nobs[i, j]</span>
                <span class="s0">if nobs[i, j] == 0:</span>
                    <span class="s0">out[i, j] = nan_val</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = sumx[i, j] / count</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_ohlc(floating[:, ::1] out,</span>
               <span class="s0">int64_t[::1] counts,</span>
               <span class="s0">ndarray[floating, ndim=2] values,</span>
               <span class="s0">const intp_t[::1] labels,</span>
               <span class="s0">Py_ssize_t min_count=-1) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Only aggregates on axis=0</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab</span>
        <span class="s0">floating val</span>

    <span class="s0">assert min_count == -1, &quot;'min_count' only used in add and prod&quot;</span>

    <span class="s0">if len(labels) == 0:</span>
        <span class="s0">return</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">if out.shape[1] != 4:</span>
        <span class="s0">raise ValueError('Output array must have 4 columns')</span>

    <span class="s0">if K &gt; 1:</span>
        <span class="s0">raise NotImplementedError(&quot;Argument 'values' must have only one dimension&quot;)</span>
    <span class="s0">out[:] = np.nan</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab == -1:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">val = values[i, 0]</span>
            <span class="s0">if val != val:</span>
                <span class="s0">continue</span>

            <span class="s0">if out[lab, 0] != out[lab, 0]:</span>
                <span class="s0">out[lab, 0] = out[lab, 1] = out[lab, 2] = out[lab, 3] = val</span>
            <span class="s0">else:</span>
                <span class="s0">out[lab, 1] = max(out[lab, 1], val)</span>
                <span class="s0">out[lab, 2] = min(out[lab, 2], val)</span>
                <span class="s0">out[lab, 3] = val</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_quantile(ndarray[float64_t, ndim=2] out,</span>
                   <span class="s0">ndarray[numeric_t, ndim=1] values,</span>
                   <span class="s0">ndarray[intp_t] labels,</span>
                   <span class="s0">ndarray[uint8_t] mask,</span>
                   <span class="s0">const intp_t[:] sort_indexer,</span>
                   <span class="s0">const float64_t[:] qs,</span>
                   <span class="s0">str interpolation) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Calculate the quantile per group.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[np.float64, ndim=2]</span>
        <span class="s0">Array of aggregated values that will be written to.</span>
    <span class="s0">values : np.ndarray</span>
        <span class="s0">Array containing the values to apply the function against.</span>
    <span class="s0">labels : ndarray[np.intp]</span>
        <span class="s0">Array containing the unique group labels.</span>
    <span class="s0">sort_indexer : ndarray[np.intp]</span>
        <span class="s0">Indices describing sort order by values and labels.</span>
    <span class="s0">qs : ndarray[float64_t]</span>
        <span class="s0">The quantile values to search for.</span>
    <span class="s0">interpolation : {'linear', 'lower', 'highest', 'nearest', 'midpoint'}</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">Rather than explicitly returning a value, this function modifies the</span>
    <span class="s0">provided `out` parameter.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, N=len(labels), ngroups, grp_sz, non_na_sz, k, nqs</span>
        <span class="s0">Py_ssize_t grp_start=0, idx=0</span>
        <span class="s0">intp_t lab</span>
        <span class="s0">InterpolationEnumType interp</span>
        <span class="s0">float64_t q_val, q_idx, frac, val, next_val</span>
        <span class="s0">int64_t[::1] counts, non_na_counts</span>

    <span class="s0">assert values.shape[0] == N</span>

    <span class="s0">if any(not (0 &lt;= q &lt;= 1) for q in qs):</span>
        <span class="s0">wrong = [x for x in qs if not (0 &lt;= x &lt;= 1)][0]</span>
        <span class="s0">raise ValueError(</span>
            <span class="s0">f&quot;Each 'q' must be between 0 and 1. Got '{wrong}' instead&quot;</span>
        <span class="s0">)</span>

    <span class="s0">inter_methods = {</span>
        <span class="s0">'linear': INTERPOLATION_LINEAR,</span>
        <span class="s0">'lower': INTERPOLATION_LOWER,</span>
        <span class="s0">'higher': INTERPOLATION_HIGHER,</span>
        <span class="s0">'nearest': INTERPOLATION_NEAREST,</span>
        <span class="s0">'midpoint': INTERPOLATION_MIDPOINT,</span>
    <span class="s0">}</span>
    <span class="s0">interp = inter_methods[interpolation]</span>

    <span class="s0">nqs = len(qs)</span>
    <span class="s0">ngroups = len(out)</span>
    <span class="s0">counts = np.zeros(ngroups, dtype=np.int64)</span>
    <span class="s0">non_na_counts = np.zeros(ngroups, dtype=np.int64)</span>

    <span class="s0"># First figure out the size of every group</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab == -1:  # NA group label</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">if not mask[i]:</span>
                <span class="s0">non_na_counts[lab] += 1</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(ngroups):</span>
            <span class="s0"># Figure out how many group elements there are</span>
            <span class="s0">grp_sz = counts[i]</span>
            <span class="s0">non_na_sz = non_na_counts[i]</span>

            <span class="s0">if non_na_sz == 0:</span>
                <span class="s0">for k in range(nqs):</span>
                    <span class="s0">out[i, k] = NaN</span>
            <span class="s0">else:</span>
                <span class="s0">for k in range(nqs):</span>
                    <span class="s0">q_val = qs[k]</span>

                    <span class="s0"># Calculate where to retrieve the desired value</span>
                    <span class="s0"># Casting to int will intentionally truncate result</span>
                    <span class="s0">idx = grp_start + &lt;int64_t&gt;(q_val * &lt;float64_t&gt;(non_na_sz - 1))</span>

                    <span class="s0">val = values[sort_indexer[idx]]</span>
                    <span class="s0"># If requested quantile falls evenly on a particular index</span>
                    <span class="s0"># then write that index's value out. Otherwise interpolate</span>
                    <span class="s0">q_idx = q_val * (non_na_sz - 1)</span>
                    <span class="s0">frac = q_idx % 1</span>

                    <span class="s0">if frac == 0.0 or interp == INTERPOLATION_LOWER:</span>
                        <span class="s0">out[i, k] = val</span>
                    <span class="s0">else:</span>
                        <span class="s0">next_val = values[sort_indexer[idx + 1]]</span>
                        <span class="s0">if interp == INTERPOLATION_LINEAR:</span>
                            <span class="s0">out[i, k] = val + (next_val - val) * frac</span>
                        <span class="s0">elif interp == INTERPOLATION_HIGHER:</span>
                            <span class="s0">out[i, k] = next_val</span>
                        <span class="s0">elif interp == INTERPOLATION_MIDPOINT:</span>
                            <span class="s0">out[i, k] = (val + next_val) / 2.0</span>
                        <span class="s0">elif interp == INTERPOLATION_NEAREST:</span>
                            <span class="s0">if frac &gt; .5 or (frac == .5 and q_val &gt; .5):  # Always OK?</span>
                                <span class="s0">out[i, k] = next_val</span>
                            <span class="s0">else:</span>
                                <span class="s0">out[i, k] = val</span>

            <span class="s0"># Increment the index reference in sorted_arr for the next group</span>
            <span class="s0">grp_start += grp_sz</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># group_nth, group_last, group_rank</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cdef inline bint _treat_as_na(iu_64_floating_obj_t val, bint is_datetimelike) nogil:</span>
    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0"># Should never be used, but we need to avoid the `val != val` below</span>
        <span class="s0">#  or else cython will raise about gil acquisition.</span>
        <span class="s0">raise NotImplementedError</span>

    <span class="s0">elif iu_64_floating_obj_t is int64_t:</span>
        <span class="s0">return is_datetimelike and val == NPY_NAT</span>
    <span class="s0">elif iu_64_floating_obj_t is uint64_t:</span>
        <span class="s0"># There is no NA value for uint64</span>
        <span class="s0">return False</span>
    <span class="s0">else:</span>
        <span class="s0">return val != val</span>


<span class="s0"># GH#31710 use memorviews once cython 0.30 is released so we can</span>
<span class="s0">#  use `const iu_64_floating_obj_t[:, :] values`</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_last(iu_64_floating_obj_t[:, ::1] out,</span>
               <span class="s0">int64_t[::1] counts,</span>
               <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] values,</span>
               <span class="s0">const intp_t[::1] labels,</span>
               <span class="s0">Py_ssize_t min_count=-1) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Only aggregates on axis=0</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ncounts = len(counts)</span>
        <span class="s0">iu_64_floating_obj_t val</span>
        <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] resx</span>
        <span class="s0">ndarray[int64_t, ndim=2] nobs</span>
        <span class="s0">bint runtime_error = False</span>

    <span class="s0"># TODO(cython3):</span>
    <span class="s0"># Instead of `labels.shape[0]` use `len(labels)`</span>
    <span class="s0">if not len(values) == labels.shape[0]:</span>
        <span class="s0">raise AssertionError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0">min_count = max(min_count, 1)</span>
    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>
    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0">resx = np.empty((&lt;object&gt;out).shape, dtype=object)</span>
    <span class="s0">else:</span>
        <span class="s0">resx = np.empty_like(out)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0"># TODO(cython3): De-duplicate once conditional-nogil is available</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0">if not checknull(val):</span>
                    <span class="s0"># NB: use _treat_as_na here once</span>
                    <span class="s0">#  conditional-nogil is available.</span>
                    <span class="s0">nobs[lab, j] += 1</span>
                    <span class="s0">resx[lab, j] = val</span>

        <span class="s0">for i in range(ncounts):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if nobs[i, j] &lt; min_count:</span>
                    <span class="s0">out[i, j] = None</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = resx[i, j]</span>
    <span class="s0">else:</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(N):</span>
                <span class="s0">lab = labels[i]</span>
                <span class="s0">if lab &lt; 0:</span>
                    <span class="s0">continue</span>

                <span class="s0">counts[lab] += 1</span>
                <span class="s0">for j in range(K):</span>
                    <span class="s0">val = values[i, j]</span>

                    <span class="s0">if not _treat_as_na(val, True):</span>
                        <span class="s0"># TODO: Sure we always want is_datetimelike=True?</span>
                        <span class="s0">nobs[lab, j] += 1</span>
                        <span class="s0">resx[lab, j] = val</span>

            <span class="s0">for i in range(ncounts):</span>
                <span class="s0">for j in range(K):</span>
                    <span class="s0">if nobs[i, j] &lt; min_count:</span>
                        <span class="s0">if iu_64_floating_obj_t is int64_t:</span>
                            <span class="s0">out[i, j] = NPY_NAT</span>
                        <span class="s0">elif iu_64_floating_obj_t is uint64_t:</span>
                            <span class="s0">runtime_error = True</span>
                            <span class="s0">break</span>
                        <span class="s0">else:</span>
                            <span class="s0">out[i, j] = NAN</span>

                    <span class="s0">else:</span>
                        <span class="s0">out[i, j] = resx[i, j]</span>

    <span class="s0">if runtime_error:</span>
        <span class="s0"># We cannot raise directly above because that is within a nogil</span>
        <span class="s0">#  block.</span>
        <span class="s0">raise RuntimeError(&quot;empty group with uint64_t&quot;)</span>


<span class="s0"># GH#31710 use memorviews once cython 0.30 is released so we can</span>
<span class="s0">#  use `const iu_64_floating_obj_t[:, :] values`</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_nth(iu_64_floating_obj_t[:, ::1] out,</span>
              <span class="s0">int64_t[::1] counts,</span>
              <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] values,</span>
              <span class="s0">const intp_t[::1] labels,</span>
              <span class="s0">int64_t min_count=-1,</span>
              <span class="s0">int64_t rank=1,</span>
              <span class="s0">) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Only aggregates on axis=0</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ncounts = len(counts)</span>
        <span class="s0">iu_64_floating_obj_t val</span>
        <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] resx</span>
        <span class="s0">ndarray[int64_t, ndim=2] nobs</span>
        <span class="s0">bint runtime_error = False</span>

    <span class="s0"># TODO(cython3):</span>
    <span class="s0"># Instead of `labels.shape[0]` use `len(labels)`</span>
    <span class="s0">if not len(values) == labels.shape[0]:</span>
        <span class="s0">raise AssertionError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0">min_count = max(min_count, 1)</span>
    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>
    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0">resx = np.empty((&lt;object&gt;out).shape, dtype=object)</span>
    <span class="s0">else:</span>
        <span class="s0">resx = np.empty_like(out)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0"># TODO(cython3): De-duplicate once conditional-nogil is available</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0">if not checknull(val):</span>
                    <span class="s0"># NB: use _treat_as_na here once</span>
                    <span class="s0">#  conditional-nogil is available.</span>
                    <span class="s0">nobs[lab, j] += 1</span>
                    <span class="s0">if nobs[lab, j] == rank:</span>
                        <span class="s0">resx[lab, j] = val</span>

        <span class="s0">for i in range(ncounts):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if nobs[i, j] &lt; min_count:</span>
                    <span class="s0">out[i, j] = None</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = resx[i, j]</span>

    <span class="s0">else:</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(N):</span>
                <span class="s0">lab = labels[i]</span>
                <span class="s0">if lab &lt; 0:</span>
                    <span class="s0">continue</span>

                <span class="s0">counts[lab] += 1</span>
                <span class="s0">for j in range(K):</span>
                    <span class="s0">val = values[i, j]</span>

                    <span class="s0">if not _treat_as_na(val, True):</span>
                        <span class="s0"># TODO: Sure we always want is_datetimelike=True?</span>
                        <span class="s0">nobs[lab, j] += 1</span>
                        <span class="s0">if nobs[lab, j] == rank:</span>
                            <span class="s0">resx[lab, j] = val</span>

            <span class="s0">for i in range(ncounts):</span>
                <span class="s0">for j in range(K):</span>
                    <span class="s0">if nobs[i, j] &lt; min_count:</span>
                        <span class="s0">if iu_64_floating_obj_t is int64_t:</span>
                            <span class="s0">out[i, j] = NPY_NAT</span>
                        <span class="s0">elif iu_64_floating_obj_t is uint64_t:</span>
                            <span class="s0">runtime_error = True</span>
                            <span class="s0">break</span>
                        <span class="s0">else:</span>
                            <span class="s0">out[i, j] = NAN</span>
                    <span class="s0">else:</span>
                        <span class="s0">out[i, j] = resx[i, j]</span>

    <span class="s0">if runtime_error:</span>
        <span class="s0"># We cannot raise directly above because that is within a nogil</span>
        <span class="s0">#  block.</span>
        <span class="s0">raise RuntimeError(&quot;empty group with uint64_t&quot;)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_rank(float64_t[:, ::1] out,</span>
               <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] values,</span>
               <span class="s0">const intp_t[::1] labels,</span>
               <span class="s0">int ngroups,</span>
               <span class="s0">bint is_datetimelike, str ties_method=&quot;average&quot;,</span>
               <span class="s0">bint ascending=True, bint pct=False, str na_option=&quot;keep&quot;) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Provides the rank of values within each group.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[np.float64, ndim=2]</span>
        <span class="s0">Values to which this method will write its results.</span>
    <span class="s0">values : np.ndarray of iu_64_floating_obj_t values to be ranked</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Array containing unique label for each group, with its ordering</span>
        <span class="s0">matching up to the corresponding record in `values`</span>
    <span class="s0">ngroups : int</span>
        <span class="s0">This parameter is not used, is needed to match signatures of other</span>
        <span class="s0">groupby functions.</span>
    <span class="s0">is_datetimelike : bool</span>
        <span class="s0">True if `values` contains datetime-like entries.</span>
    <span class="s0">ties_method : {'average', 'min', 'max', 'first', 'dense'}, default 'average'</span>
        <span class="s0">* average: average rank of group</span>
        <span class="s0">* min: lowest rank in group</span>
        <span class="s0">* max: highest rank in group</span>
        <span class="s0">* first: ranks assigned in order they appear in the array</span>
        <span class="s0">* dense: like 'min', but rank always increases by 1 between groups</span>
    <span class="s0">ascending : bool, default True</span>
        <span class="s0">False for ranks by high (1) to low (N)</span>
        <span class="s0">na_option : {'keep', 'top', 'bottom'}, default 'keep'</span>
    <span class="s0">pct : bool, default False</span>
        <span class="s0">Compute percentage rank of data within each group</span>
    <span class="s0">na_option : {'keep', 'top', 'bottom'}, default 'keep'</span>
        <span class="s0">* keep: leave NA values where they are</span>
        <span class="s0">* top: smallest rank if ascending</span>
        <span class="s0">* bottom: smallest rank if descending</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter rather than returning an object</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, k, N</span>
        <span class="s0">ndarray[float64_t, ndim=1] result</span>

    <span class="s0">N = values.shape[1]</span>

    <span class="s0">for k in range(N):</span>
        <span class="s0">result = rank_1d(</span>
            <span class="s0">values=values[:, k],</span>
            <span class="s0">labels=labels,</span>
            <span class="s0">is_datetimelike=is_datetimelike,</span>
            <span class="s0">ties_method=ties_method,</span>
            <span class="s0">ascending=ascending,</span>
            <span class="s0">pct=pct,</span>
            <span class="s0">na_option=na_option</span>
        <span class="s0">)</span>
        <span class="s0">for i in range(len(result)):</span>
            <span class="s0"># TODO: why can't we do out[:, k] = result?</span>
            <span class="s0">out[i, k] = result[i]</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># group_min, group_max</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0"># TODO: consider implementing for more dtypes</span>

<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef group_min_max(iu_64_floating_t[:, ::1] out,</span>
                   <span class="s0">int64_t[::1] counts,</span>
                   <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
                   <span class="s0">const intp_t[::1] labels,</span>
                   <span class="s0">Py_ssize_t min_count=-1,</span>
                   <span class="s0">bint is_datetimelike=False,</span>
                   <span class="s0">bint compute_max=True,</span>
                   <span class="s0">const uint8_t[:, ::1] mask=None,</span>
                   <span class="s0">uint8_t[:, ::1] result_mask=None):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Compute minimum/maximum  of columns of `values`, in row groups `labels`.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[iu_64_floating_t, ndim=2]</span>
        <span class="s0">Array to store result in.</span>
    <span class="s0">counts : np.ndarray[int64]</span>
        <span class="s0">Input as a zeroed array, populated by group sizes during algorithm</span>
    <span class="s0">values : array</span>
        <span class="s0">Values to find column-wise min/max of.</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Labels to group by.</span>
    <span class="s0">min_count : Py_ssize_t, default -1</span>
        <span class="s0">The minimum number of non-NA group elements, NA result if threshold</span>
        <span class="s0">is not met</span>
    <span class="s0">is_datetimelike : bool</span>
        <span class="s0">True if `values` contains datetime-like entries.</span>
    <span class="s0">compute_max : bint, default True</span>
        <span class="s0">True to compute group-wise max, False to compute min</span>
    <span class="s0">mask : ndarray[bool, ndim=2], optional</span>
        <span class="s0">If not None, indices represent missing values,</span>
        <span class="s0">otherwise the mask will not be used</span>
    <span class="s0">result_mask : ndarray[bool, ndim=2], optional</span>
        <span class="s0">If not None, these specify locations in the output that are NA.</span>
        <span class="s0">Modified in-place.</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter, rather than returning an object.</span>
    <span class="s0">`counts` is modified to hold group sizes</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K, lab, ngroups = len(counts)</span>
        <span class="s0">iu_64_floating_t val, nan_val</span>
        <span class="s0">ndarray[iu_64_floating_t, ndim=2] group_min_or_max</span>
        <span class="s0">bint runtime_error = False</span>
        <span class="s0">int64_t[:, ::1] nobs</span>
        <span class="s0">bint uses_mask = mask is not None</span>
        <span class="s0">bint isna_entry</span>

    <span class="s0"># TODO(cython3):</span>
    <span class="s0"># Instead of `labels.shape[0]` use `len(labels)`</span>
    <span class="s0">if not len(values) == labels.shape[0]:</span>
        <span class="s0">raise AssertionError(&quot;len(index) != len(labels)&quot;)</span>

    <span class="s0">min_count = max(min_count, 1)</span>
    <span class="s0">nobs = np.zeros((&lt;object&gt;out).shape, dtype=np.int64)</span>

    <span class="s0">group_min_or_max = np.empty_like(out)</span>
    <span class="s0">if iu_64_floating_t is int64_t:</span>
        <span class="s0">group_min_or_max[:] = -_int64_max if compute_max else _int64_max</span>
        <span class="s0">nan_val = NPY_NAT</span>
    <span class="s0">elif iu_64_floating_t is uint64_t:</span>
        <span class="s0"># NB: We do not define nan_val because there is no such thing</span>
        <span class="s0"># for uint64_t.  We carefully avoid having to reference it in this</span>
        <span class="s0"># case.</span>
        <span class="s0">group_min_or_max[:] = 0 if compute_max else np.iinfo(np.uint64).max</span>
    <span class="s0">else:</span>
        <span class="s0">group_min_or_max[:] = -np.inf if compute_max else np.inf</span>
        <span class="s0">nan_val = NAN</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>

            <span class="s0">counts[lab] += 1</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">val = values[i, j]</span>

                <span class="s0">if uses_mask:</span>
                    <span class="s0">isna_entry = mask[i, j]</span>
                <span class="s0">else:</span>
                    <span class="s0">isna_entry = _treat_as_na(val, is_datetimelike)</span>

                <span class="s0">if not isna_entry:</span>
                    <span class="s0">nobs[lab, j] += 1</span>
                    <span class="s0">if compute_max:</span>
                        <span class="s0">if val &gt; group_min_or_max[lab, j]:</span>
                            <span class="s0">group_min_or_max[lab, j] = val</span>
                    <span class="s0">else:</span>
                        <span class="s0">if val &lt; group_min_or_max[lab, j]:</span>
                            <span class="s0">group_min_or_max[lab, j] = val</span>

        <span class="s0">for i in range(ngroups):</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if nobs[i, j] &lt; min_count:</span>
                    <span class="s0">if iu_64_floating_t is uint64_t:</span>
                        <span class="s0">runtime_error = True</span>
                        <span class="s0">break</span>
                    <span class="s0">else:</span>
                        <span class="s0">if uses_mask:</span>
                            <span class="s0">result_mask[i, j] = True</span>
                        <span class="s0">else:</span>
                            <span class="s0">out[i, j] = nan_val</span>
                <span class="s0">else:</span>
                    <span class="s0">out[i, j] = group_min_or_max[i, j]</span>

    <span class="s0">if runtime_error:</span>
        <span class="s0"># We cannot raise directly above because that is within a nogil</span>
        <span class="s0">#  block.</span>
        <span class="s0">raise RuntimeError(&quot;empty group with uint64_t&quot;)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_max(iu_64_floating_t[:, ::1] out,</span>
              <span class="s0">int64_t[::1] counts,</span>
              <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
              <span class="s0">const intp_t[::1] labels,</span>
              <span class="s0">Py_ssize_t min_count=-1,</span>
              <span class="s0">bint is_datetimelike=False,</span>
              <span class="s0">const uint8_t[:, ::1] mask=None,</span>
              <span class="s0">uint8_t[:, ::1] result_mask=None) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;See group_min_max.__doc__&quot;&quot;&quot;</span>
    <span class="s0">group_min_max(</span>
        <span class="s0">out,</span>
        <span class="s0">counts,</span>
        <span class="s0">values,</span>
        <span class="s0">labels,</span>
        <span class="s0">min_count=min_count,</span>
        <span class="s0">is_datetimelike=is_datetimelike,</span>
        <span class="s0">compute_max=True,</span>
        <span class="s0">mask=mask,</span>
        <span class="s0">result_mask=result_mask,</span>
    <span class="s0">)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def group_min(iu_64_floating_t[:, ::1] out,</span>
              <span class="s0">int64_t[::1] counts,</span>
              <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
              <span class="s0">const intp_t[::1] labels,</span>
              <span class="s0">Py_ssize_t min_count=-1,</span>
              <span class="s0">bint is_datetimelike=False,</span>
              <span class="s0">const uint8_t[:, ::1] mask=None,</span>
              <span class="s0">uint8_t[:, ::1] result_mask=None) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;See group_min_max.__doc__&quot;&quot;&quot;</span>
    <span class="s0">group_min_max(</span>
        <span class="s0">out,</span>
        <span class="s0">counts,</span>
        <span class="s0">values,</span>
        <span class="s0">labels,</span>
        <span class="s0">min_count=min_count,</span>
        <span class="s0">is_datetimelike=is_datetimelike,</span>
        <span class="s0">compute_max=False,</span>
        <span class="s0">mask=mask,</span>
        <span class="s0">result_mask=result_mask,</span>
    <span class="s0">)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">cdef group_cummin_max(iu_64_floating_t[:, ::1] out,</span>
                      <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
                      <span class="s0">uint8_t[:, ::1] mask,</span>
                      <span class="s0">const intp_t[::1] labels,</span>
                      <span class="s0">int ngroups,</span>
                      <span class="s0">bint is_datetimelike,</span>
                      <span class="s0">bint skipna,</span>
                      <span class="s0">bint compute_max):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Cumulative minimum/maximum of columns of `values`, in row groups `labels`.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : np.ndarray[iu_64_floating_t, ndim=2]</span>
        <span class="s0">Array to store cummin/max in.</span>
    <span class="s0">values : np.ndarray[iu_64_floating_t, ndim=2]</span>
        <span class="s0">Values to take cummin/max of.</span>
    <span class="s0">mask : np.ndarray[bool] or None</span>
        <span class="s0">If not None, indices represent missing values,</span>
        <span class="s0">otherwise the mask will not be used</span>
    <span class="s0">labels : np.ndarray[np.intp]</span>
        <span class="s0">Labels to group by.</span>
    <span class="s0">ngroups : int</span>
        <span class="s0">Number of groups, larger than all entries of `labels`.</span>
    <span class="s0">is_datetimelike : bool</span>
        <span class="s0">True if `values` contains datetime-like entries.</span>
    <span class="s0">skipna : bool</span>
        <span class="s0">If True, ignore nans in `values`.</span>
    <span class="s0">compute_max : bool</span>
        <span class="s0">True if cumulative maximum should be computed, False</span>
        <span class="s0">if cumulative minimum should be computed</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This method modifies the `out` parameter, rather than returning an object.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">iu_64_floating_t[:, ::1] accum</span>

    <span class="s0">accum = np.empty((ngroups, (&lt;object&gt;values).shape[1]), dtype=values.dtype)</span>
    <span class="s0">if iu_64_floating_t is int64_t:</span>
        <span class="s0">accum[:] = -_int64_max if compute_max else _int64_max</span>
    <span class="s0">elif iu_64_floating_t is uint64_t:</span>
        <span class="s0">accum[:] = 0 if compute_max else np.iinfo(np.uint64).max</span>
    <span class="s0">else:</span>
        <span class="s0">accum[:] = -np.inf if compute_max else np.inf</span>

    <span class="s0">if mask is not None:</span>
        <span class="s0">masked_cummin_max(out, values, mask, labels, accum, skipna, compute_max)</span>
    <span class="s0">else:</span>
        <span class="s0">cummin_max(out, values, labels, accum, skipna, is_datetimelike, compute_max)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">cdef cummin_max(iu_64_floating_t[:, ::1] out,</span>
                <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
                <span class="s0">const intp_t[::1] labels,</span>
                <span class="s0">iu_64_floating_t[:, ::1] accum,</span>
                <span class="s0">bint skipna,</span>
                <span class="s0">bint is_datetimelike,</span>
                <span class="s0">bint compute_max):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Compute the cumulative minimum/maximum of columns of `values`, in row groups</span>
    <span class="s0">`labels`.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K</span>
        <span class="s0">iu_64_floating_t val, mval, na_val</span>
        <span class="s0">uint8_t[:, ::1] seen_na</span>
        <span class="s0">intp_t lab</span>
        <span class="s0">bint na_possible</span>

    <span class="s0">if iu_64_floating_t is float64_t or iu_64_floating_t is float32_t:</span>
        <span class="s0">na_val = NaN</span>
        <span class="s0">na_possible = True</span>
    <span class="s0">elif is_datetimelike:</span>
        <span class="s0">na_val = NPY_NAT</span>
        <span class="s0">na_possible = True</span>
    <span class="s0"># Will never be used, just to avoid uninitialized warning</span>
    <span class="s0">else:</span>
        <span class="s0">na_val = 0</span>
        <span class="s0">na_possible = False</span>

    <span class="s0">if na_possible:</span>
        <span class="s0">seen_na = np.zeros((&lt;object&gt;accum).shape, dtype=np.uint8)</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if not skipna and na_possible and seen_na[lab, j]:</span>
                    <span class="s0">out[i, j] = na_val</span>
                <span class="s0">else:</span>
                    <span class="s0">val = values[i, j]</span>
                    <span class="s0">if not _treat_as_na(val, is_datetimelike):</span>
                        <span class="s0">mval = accum[lab, j]</span>
                        <span class="s0">if compute_max:</span>
                            <span class="s0">if val &gt; mval:</span>
                                <span class="s0">accum[lab, j] = mval = val</span>
                        <span class="s0">else:</span>
                            <span class="s0">if val &lt; mval:</span>
                                <span class="s0">accum[lab, j] = mval = val</span>
                        <span class="s0">out[i, j] = mval</span>
                    <span class="s0">else:</span>
                        <span class="s0">seen_na[lab, j] = 1</span>
                        <span class="s0">out[i, j] = val</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">cdef masked_cummin_max(iu_64_floating_t[:, ::1] out,</span>
                       <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
                       <span class="s0">uint8_t[:, ::1] mask,</span>
                       <span class="s0">const intp_t[::1] labels,</span>
                       <span class="s0">iu_64_floating_t[:, ::1] accum,</span>
                       <span class="s0">bint skipna,</span>
                       <span class="s0">bint compute_max):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Compute the cumulative minimum/maximum of columns of `values`, in row groups</span>
    <span class="s0">`labels` with a masked algorithm.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K</span>
        <span class="s0">iu_64_floating_t val, mval</span>
        <span class="s0">uint8_t[:, ::1] seen_na</span>
        <span class="s0">intp_t lab</span>

    <span class="s0">N, K = (&lt;object&gt;values).shape</span>
    <span class="s0">seen_na = np.zeros((&lt;object&gt;accum).shape, dtype=np.uint8)</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">continue</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">if not skipna and seen_na[lab, j]:</span>
                    <span class="s0">mask[i, j] = 1</span>
                <span class="s0">else:</span>
                    <span class="s0">if not mask[i, j]:</span>
                        <span class="s0">val = values[i, j]</span>
                        <span class="s0">mval = accum[lab, j]</span>
                        <span class="s0">if compute_max:</span>
                            <span class="s0">if val &gt; mval:</span>
                                <span class="s0">accum[lab, j] = mval = val</span>
                        <span class="s0">else:</span>
                            <span class="s0">if val &lt; mval:</span>
                                <span class="s0">accum[lab, j] = mval = val</span>
                        <span class="s0">out[i, j] = mval</span>
                    <span class="s0">else:</span>
                        <span class="s0">seen_na[lab, j] = 1</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_cummin(iu_64_floating_t[:, ::1] out,</span>
                 <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
                 <span class="s0">const intp_t[::1] labels,</span>
                 <span class="s0">int ngroups,</span>
                 <span class="s0">bint is_datetimelike,</span>
                 <span class="s0">uint8_t[:, ::1] mask=None,</span>
                 <span class="s0">bint skipna=True) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;See group_cummin_max.__doc__&quot;&quot;&quot;</span>
    <span class="s0">group_cummin_max(</span>
        <span class="s0">out,</span>
        <span class="s0">values,</span>
        <span class="s0">mask,</span>
        <span class="s0">labels,</span>
        <span class="s0">ngroups,</span>
        <span class="s0">is_datetimelike,</span>
        <span class="s0">skipna,</span>
        <span class="s0">compute_max=False</span>
    <span class="s0">)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def group_cummax(iu_64_floating_t[:, ::1] out,</span>
                 <span class="s0">ndarray[iu_64_floating_t, ndim=2] values,</span>
                 <span class="s0">const intp_t[::1] labels,</span>
                 <span class="s0">int ngroups,</span>
                 <span class="s0">bint is_datetimelike,</span>
                 <span class="s0">uint8_t[:, ::1] mask=None,</span>
                 <span class="s0">bint skipna=True) -&gt; None:</span>
    <span class="s0">&quot;&quot;&quot;See group_cummin_max.__doc__&quot;&quot;&quot;</span>
    <span class="s0">group_cummin_max(</span>
        <span class="s0">out,</span>
        <span class="s0">values,</span>
        <span class="s0">mask,</span>
        <span class="s0">labels,</span>
        <span class="s0">ngroups,</span>
        <span class="s0">is_datetimelike,</span>
        <span class="s0">skipna,</span>
        <span class="s0">compute_max=True</span>
    <span class="s0">)</span>
</pre>
</body>
</html>